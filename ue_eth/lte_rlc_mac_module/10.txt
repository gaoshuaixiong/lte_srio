
lte_rlc_mac_module.ko:     file format elf32-i386


Disassembly of section .text:

00000000 <__fsm_skb_netrx>:
{
	fsm_pkt_destroy(pkptr);
}

static void __fsm_skb_netrx(unsigned long data)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	56                   	push   %esi
       4:	53                   	push   %ebx
       5:	e8 fc ff ff ff       	call   6 <__fsm_skb_netrx+0x6>
       a:	eb 1e                	jmp    2a <__fsm_skb_netrx+0x2a>
       c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.rx_queue);
      10:	e8 fc ff ff ff       	call   11 <__fsm_skb_netrx+0x11>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
      15:	89 f2                	mov    %esi,%edx
      17:	89 c3                	mov    %eax,%ebx
      19:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      1e:	e8 fc ff ff ff       	call   1f <__fsm_skb_netrx+0x1f>
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		NETIF_RX(pkptr);
      23:	89 d8                	mov    %ebx,%eax
      25:	e8 fc ff ff ff       	call   26 <__fsm_skb_netrx+0x26>
	unsigned long flags;


	while(1)
	{
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
      2a:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      2f:	e8 fc ff ff ff       	call   30 <__fsm_skb_netrx+0x30>
      34:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.rx_queue))
      36:	a1 bc 02 00 00       	mov    0x2bc,%eax
      3b:	3b 00                	cmp    (%eax),%eax
      3d:	75 d1                	jne    10 <__fsm_skb_netrx+0x10>
      3f:	89 f2                	mov    %esi,%edx
      41:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      46:	e8 fc ff ff ff       	call   47 <__fsm_skb_netrx+0x47>
		NETIF_RX(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_netrx() packet receive\n");
	return;
}
      4b:	5b                   	pop    %ebx
      4c:	5e                   	pop    %esi
      4d:	5d                   	pop    %ebp
      4e:	c3                   	ret    
      4f:	90                   	nop

00000050 <__fsm_skb_xmit>:

static void __fsm_skb_xmit(unsigned long data)
{
      50:	55                   	push   %ebp
      51:	89 e5                	mov    %esp,%ebp
      53:	56                   	push   %esi
      54:	53                   	push   %ebx
      55:	e8 fc ff ff ff       	call   56 <__fsm_skb_xmit+0x6>
      5a:	eb 1e                	jmp    7a <__fsm_skb_xmit+0x2a>
      5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.tx_queue);
      60:	e8 fc ff ff ff       	call   61 <__fsm_skb_xmit+0x11>
      65:	89 f2                	mov    %esi,%edx
      67:	89 c3                	mov    %eax,%ebx
      69:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      6e:	e8 fc ff ff ff       	call   6f <__fsm_skb_xmit+0x1f>
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
//		fsm_octets_print(pkptr->data, pkptr->len);
		DEV_QUEUE_XMIT(pkptr);
      73:	89 d8                	mov    %ebx,%eax
      75:	e8 fc ff ff ff       	call   76 <__fsm_skb_xmit+0x26>
{
	FSM_PKT* pkptr;
	unsigned long flags;
	while(1)
	{
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
      7a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      7f:	e8 fc ff ff ff       	call   80 <__fsm_skb_xmit+0x30>
      84:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.tx_queue))
      86:	a1 b8 02 00 00       	mov    0x2b8,%eax
      8b:	3b 00                	cmp    (%eax),%eax
      8d:	75 d1                	jne    60 <__fsm_skb_xmit+0x10>
      8f:	89 f2                	mov    %esi,%edx
      91:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      96:	e8 fc ff ff ff       	call   97 <__fsm_skb_xmit+0x47>
		DEV_QUEUE_XMIT(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}
      9b:	5b                   	pop    %ebx
      9c:	5e                   	pop    %esi
      9d:	5d                   	pop    %ebp
      9e:	c3                   	ret    
      9f:	90                   	nop

000000a0 <__fsm_do_ioctl>:
	}
}


static void __fsm_do_ioctl(unsigned long data)
{
      a0:	55                   	push   %ebp
      a1:	89 e5                	mov    %esp,%ebp
      a3:	57                   	push   %edi
      a4:	56                   	push   %esi
      a5:	53                   	push   %ebx
      a6:	e8 fc ff ff ff       	call   a7 <__fsm_do_ioctl+0x7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
      ab:	8b 35 d4 02 00 00    	mov    0x2d4,%esi
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
      b1:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
      b7:	74 60                	je     119 <__fsm_do_ioctl+0x79>
      b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		ev_ptr = list_first_entry(&fsm_core.do_ioctl_list, struct evioctl, list_node);
		ev_ptr->dev->netdev_ops->ndo_do_ioctl(ev_ptr->dev, (struct ifreq*)&ev_ptr->ifr, IOCKERNEL);
      c0:	8b 46 f0             	mov    -0x10(%esi),%eax
      c3:	8d 56 f4             	lea    -0xc(%esi),%edx
      c6:	b9 f0 89 00 00       	mov    $0x89f0,%ecx
      cb:	8d 7e f0             	lea    -0x10(%esi),%edi
      ce:	8b 98 34 01 00 00    	mov    0x134(%eax),%ebx
      d4:	ff 53 28             	call   *0x28(%ebx)
		spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
      d7:	b8 e4 02 00 00       	mov    $0x2e4,%eax
      dc:	e8 fc ff ff ff       	call   dd <__fsm_do_ioctl+0x3d>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
      e1:	8b 4e 04             	mov    0x4(%esi),%ecx
      e4:	8b 1e                	mov    (%esi),%ebx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
      e6:	89 4b 04             	mov    %ecx,0x4(%ebx)
      e9:	89 c2                	mov    %eax,%edx
      eb:	b8 e4 02 00 00       	mov    $0x2e4,%eax
	prev->next = next;
      f0:	89 19                	mov    %ebx,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
      f2:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
      f8:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
      ff:	e8 fc ff ff ff       	call   100 <__fsm_do_ioctl+0x60>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     104:	89 f8                	mov    %edi,%eax
     106:	e8 fc ff ff ff       	call   107 <__fsm_do_ioctl+0x67>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     10b:	8b 35 d4 02 00 00    	mov    0x2d4,%esi

static void __fsm_do_ioctl(unsigned long data)
{
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
     111:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
     117:	75 a7                	jne    c0 <__fsm_do_ioctl+0x20>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
     119:	5b                   	pop    %ebx
     11a:	5e                   	pop    %esi
     11b:	5f                   	pop    %edi
     11c:	5d                   	pop    %ebp
     11d:	c3                   	ret    
     11e:	66 90                	xchg   %ax,%ax

00000120 <__fsm_skb_send_null>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     120:	55                   	push   %ebp
     121:	89 e5                	mov    %esp,%ebp
     123:	e8 fc ff ff ff       	call   124 <__fsm_skb_send_null+0x4>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     128:	e8 fc ff ff ff       	call   129 <__fsm_skb_send_null+0x9>
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
	fsm_pkt_destroy(pkptr);
}
     12d:	5d                   	pop    %ebp
     12e:	c3                   	ret    
     12f:	90                   	nop

00000130 <__fsm_tm_restart>:
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
}

static void __fsm_tm_restart()
{
     130:	55                   	push   %ebp
     131:	89 e5                	mov    %esp,%ebp
     133:	83 ec 04             	sub    $0x4,%esp
     136:	e8 fc ff ff ff       	call   137 <__fsm_tm_restart+0x7>
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
     13b:	8b 15 88 02 00 00    	mov    0x288,%edx
     141:	85 d2                	test   %edx,%edx
     143:	74 7b                	je     1c0 <__fsm_tm_restart+0x90>
	{
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
     145:	a1 44 02 00 00       	mov    0x244,%eax
     14a:	85 c0                	test   %eax,%eax
     14c:	74 42                	je     190 <__fsm_tm_restart+0x60>
	{	
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
     14e:	83 f8 01             	cmp    $0x1,%eax
     151:	74 05                	je     158 <__fsm_tm_restart+0x28>
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     153:	c9                   	leave  
     154:	c3                   	ret    
     155:	8d 76 00             	lea    0x0(%esi),%esi
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
     158:	b8 48 02 00 00       	mov    $0x248,%eax
     15d:	e8 fc ff ff ff       	call   15e <__fsm_tm_restart+0x2e>
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     162:	a1 88 02 00 00       	mov    0x288,%eax
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
     167:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     16e:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     171:	8b 50 08             	mov    0x8(%eax),%edx
     174:	8b 48 0c             	mov    0xc(%eax),%ecx
     177:	b8 48 02 00 00       	mov    $0x248,%eax
     17c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     183:	e8 fc ff ff ff       	call   184 <__fsm_tm_restart+0x54>
	}
}
     188:	c9                   	leave  
     189:	c3                   	ret    
     18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
	{	
		pB->timer.function = __fsm_tm_expire;
     190:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     197:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     19a:	8b 4a 0c             	mov    0xc(%edx),%ecx
     19d:	b8 48 02 00 00       	mov    $0x248,%eax
     1a2:	8b 52 08             	mov    0x8(%edx),%edx
     1a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     1ac:	e8 fc ff ff ff       	call   1ad <__fsm_tm_restart+0x7d>
		pB->tm_state = FSM_TM_RUN;
     1b1:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     1b8:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1bb:	c9                   	leave  
     1bc:	c3                   	ret    
     1bd:	8d 76 00             	lea    0x0(%esi),%esi
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
	{
		pB->tm_state = FSM_TM_STOP;
     1c0:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     1c7:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1ca:	c9                   	leave  
     1cb:	c3                   	ret    
     1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000001d0 <__fsm_skb_pending_xmit>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1d0:	55                   	push   %ebp
     1d1:	89 e5                	mov    %esp,%ebp
     1d3:	83 ec 08             	sub    $0x8,%esp
     1d6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
     1d9:	89 75 fc             	mov    %esi,-0x4(%ebp)
     1dc:	e8 fc ff ff ff       	call   1dd <__fsm_skb_pending_xmit+0xd>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
     1e1:	66 89 48 66          	mov    %cx,0x66(%eax)
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1e5:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
     1e7:	89 50 14             	mov    %edx,0x14(%eax)
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1ea:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     1ef:	e8 fc ff ff ff       	call   1f0 <__fsm_skb_pending_xmit+0x20>
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f4:	89 da                	mov    %ebx,%edx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1f6:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f8:	a1 b8 02 00 00       	mov    0x2b8,%eax
     1fd:	e8 fc ff ff ff       	call   1fe <__fsm_skb_pending_xmit+0x2e>
     202:	89 f2                	mov    %esi,%edx
     204:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     209:	e8 fc ff ff ff       	call   20a <__fsm_skb_pending_xmit+0x3a>
	spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
	tasklet_schedule(fsm_core.tx_tsklt);
     20e:	a1 c0 02 00 00       	mov    0x2c0,%eax
 */
static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
{
	int oldbit;

	asm volatile(LOCK_PREFIX "bts %2,%1\n\t"
     213:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     219:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     21b:	85 d2                	test   %edx,%edx
     21d:	75 05                	jne    224 <__fsm_skb_pending_xmit+0x54>
		__tasklet_schedule(t);
     21f:	e8 fc ff ff ff       	call   220 <__fsm_skb_pending_xmit+0x50>
//	fsm_pkt_destroy(pkptr);
	return;
}
     224:	8b 5d f8             	mov    -0x8(%ebp),%ebx
     227:	8b 75 fc             	mov    -0x4(%ebp),%esi
     22a:	89 ec                	mov    %ebp,%esp
     22c:	5d                   	pop    %ebp
     22d:	c3                   	ret    
     22e:	66 90                	xchg   %ax,%ax

00000230 <__fsm_skb_pending_netrx>:
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     230:	55                   	push   %ebp
     231:	89 e5                	mov    %esp,%ebp
     233:	56                   	push   %esi
     234:	53                   	push   %ebx
     235:	e8 fc ff ff ff       	call   236 <__fsm_skb_pending_netrx+0x6>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
     23a:	66 83 f9 08          	cmp    $0x8,%cx
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     23e:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
     240:	66 89 48 66          	mov    %cx,0x66(%eax)
	skb->dev = dev;
     244:	89 50 14             	mov    %edx,0x14(%eax)
	if(skb->protocol == htons(ETH_P_IP))
     247:	75 0d                	jne    256 <__fsm_skb_pending_netrx+0x26>
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     249:	0f b6 40 64          	movzbl 0x64(%eax),%eax
     24d:	83 e0 f3             	and    $0xfffffff3,%eax
     250:	83 c8 04             	or     $0x4,%eax
     253:	88 43 64             	mov    %al,0x64(%ebx)
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     256:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     25b:	e8 fc ff ff ff       	call   25c <__fsm_skb_pending_netrx+0x2c>
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     260:	89 da                	mov    %ebx,%edx
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     262:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     264:	a1 bc 02 00 00       	mov    0x2bc,%eax
     269:	e8 fc ff ff ff       	call   26a <__fsm_skb_pending_netrx+0x3a>
     26e:	89 f2                	mov    %esi,%edx
     270:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     275:	e8 fc ff ff ff       	call   276 <__fsm_skb_pending_netrx+0x46>
	spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
	tasklet_schedule(fsm_core.rx_tsklt);
     27a:	a1 c4 02 00 00       	mov    0x2c4,%eax
     27f:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     285:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     287:	85 d2                	test   %edx,%edx
     289:	75 05                	jne    290 <__fsm_skb_pending_netrx+0x60>
		__tasklet_schedule(t);
     28b:	e8 fc ff ff ff       	call   28c <__fsm_skb_pending_netrx+0x5c>
//	fsm_pkt_destroy(pkptr);
	return;
}
     290:	5b                   	pop    %ebx
     291:	5e                   	pop    %esi
     292:	5d                   	pop    %ebp
     293:	c3                   	ret    
     294:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     29a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000002a0 <fsm_ev_type>:

/* ---------------------utilities for state machine-----------------------------*/

/* Return information of event.	*/
u32 fsm_ev_type()
{
     2a0:	55                   	push   %ebp
     2a1:	89 e5                	mov    %esp,%ebp
     2a3:	e8 fc ff ff ff       	call   2a4 <fsm_ev_type+0x4>
	return fsm_core.evtype;
}
     2a8:	a1 30 00 00 00       	mov    0x30,%eax
     2ad:	5d                   	pop    %ebp
     2ae:	c3                   	ret    
     2af:	90                   	nop

000002b0 <fsm_ev_code>:

u32 fsm_ev_code()
{
     2b0:	55                   	push   %ebp
     2b1:	89 e5                	mov    %esp,%ebp
     2b3:	e8 fc ff ff ff       	call   2b4 <fsm_ev_code+0x4>
	return fsm_core.code;
}
     2b8:	a1 34 00 00 00       	mov    0x34,%eax
     2bd:	5d                   	pop    %ebp
     2be:	c3                   	ret    
     2bf:	90                   	nop

000002c0 <fsm_ev_src>:

int fsm_ev_src()
{
     2c0:	55                   	push   %ebp
     2c1:	89 e5                	mov    %esp,%ebp
     2c3:	e8 fc ff ff ff       	call   2c4 <fsm_ev_src+0x4>
	return fsm_core.src;
}
     2c8:	a1 38 00 00 00       	mov    0x38,%eax
     2cd:	5d                   	pop    %ebp
     2ce:	c3                   	ret    
     2cf:	90                   	nop

000002d0 <fsm_ev_ioctrl_cmd>:

u32 fsm_ev_ioctrl_cmd()
{
     2d0:	55                   	push   %ebp
     2d1:	89 e5                	mov    %esp,%ebp
     2d3:	e8 fc ff ff ff       	call   2d4 <fsm_ev_ioctrl_cmd+0x4>
	return fsm_core.ioctrl_cmd;
}
     2d8:	a1 b0 02 00 00       	mov    0x2b0,%eax
     2dd:	5d                   	pop    %ebp
     2de:	c3                   	ret    
     2df:	90                   	nop

000002e0 <fsm_sv_ptr_get>:

/* FSM information get */
void* fsm_sv_ptr_get()
{
     2e0:	55                   	push   %ebp
     2e1:	89 e5                	mov    %esp,%ebp
     2e3:	e8 fc ff ff ff       	call   2e4 <fsm_sv_ptr_get+0x4>
	return fsm_core.fsm_sv_ptr;
}
     2e8:	a1 3c 00 00 00       	mov    0x3c,%eax
     2ed:	5d                   	pop    %ebp
     2ee:	c3                   	ret    
     2ef:	90                   	nop

000002f0 <fsm_current_state_ptr_get>:

int* fsm_current_state_ptr_get()
{
     2f0:	55                   	push   %ebp
     2f1:	89 e5                	mov    %esp,%ebp
     2f3:	e8 fc ff ff ff       	call   2f4 <fsm_current_state_ptr_get+0x4>
	return fsm_core.current_state_ptr;
}
     2f8:	a1 24 00 00 00       	mov    0x24,%eax
     2fd:	5d                   	pop    %ebp
     2fe:	c3                   	ret    
     2ff:	90                   	nop

00000300 <fsm_dev_get>:

void* fsm_dev_get()
{
     300:	55                   	push   %ebp
     301:	89 e5                	mov    %esp,%ebp
     303:	e8 fc ff ff ff       	call   304 <fsm_dev_get+0x4>
	return fsm_core.dev;
}
     308:	a1 a8 02 00 00       	mov    0x2a8,%eax
     30d:	5d                   	pop    %ebp
     30e:	c3                   	ret    
     30f:	90                   	nop

00000310 <fsm_get_id_by_name>:

int fsm_get_id_by_name(const char* name)
{
     310:	55                   	push   %ebp
     311:	89 e5                	mov    %esp,%ebp
     313:	56                   	push   %esi
     314:	53                   	push   %ebx
     315:	e8 fc ff ff ff       	call   316 <fsm_get_id_by_name+0x6>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     31a:	31 db                	xor    %ebx,%ebx
{
	return fsm_core.dev;
}

int fsm_get_id_by_name(const char* name)
{
     31c:	89 c6                	mov    %eax,%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
     31e:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
     325:	89 f2                	mov    %esi,%edx
     327:	e8 fc ff ff ff       	call   328 <fsm_get_id_by_name+0x18>
     32c:	85 c0                	test   %eax,%eax
     32e:	74 18                	je     348 <fsm_get_id_by_name+0x38>
}

int fsm_get_id_by_name(const char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     330:	83 c3 01             	add    $0x1,%ebx
     333:	83 fb 06             	cmp    $0x6,%ebx
     336:	75 e6                	jne    31e <fsm_get_id_by_name+0xe>
			{
			return FSM[i]->id;
			}
		}
	return -1;
}
     338:	5b                   	pop    %ebx
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
			}
		}
	return -1;
     339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
     33e:	5e                   	pop    %esi
     33f:	5d                   	pop    %ebp
     340:	c3                   	ret    
     341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     348:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
			}
		}
	return -1;
}
     34f:	5b                   	pop    %ebx
     350:	5e                   	pop    %esi
     351:	5d                   	pop    %ebp
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     352:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
			}
		}
	return -1;
}
     358:	c3                   	ret    
     359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000360 <fsm_get_name_by_id>:

void fsm_get_name_by_id(int id, char* name)
{
     360:	55                   	push   %ebp
     361:	89 e5                	mov    %esp,%ebp
     363:	53                   	push   %ebx
     364:	e8 fc ff ff ff       	call   365 <fsm_get_name_by_id+0x5>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     369:	31 c9                	xor    %ecx,%ecx
		}
	return -1;
}

void fsm_get_name_by_id(int id, char* name)
{
     36b:	89 d3                	mov    %edx,%ebx
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
     36d:	8b 14 8d 90 02 00 00 	mov    0x290(,%ecx,4),%edx
     374:	39 82 80 00 00 00    	cmp    %eax,0x80(%edx)
     37a:	74 14                	je     390 <fsm_get_name_by_id+0x30>
}

void fsm_get_name_by_id(int id, char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     37c:	83 c1 01             	add    $0x1,%ecx
     37f:	83 f9 06             	cmp    $0x6,%ecx
     382:	75 e9                	jne    36d <fsm_get_name_by_id+0xd>
			{
			strcpy(name, FSM[i]->name);
			break;
			}
		}
	*name ='\0';
     384:	c6 03 00             	movb   $0x0,(%ebx)
}
     387:	5b                   	pop    %ebx
     388:	5d                   	pop    %ebp
     389:	c3                   	ret    
     38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
			{
			strcpy(name, FSM[i]->name);
     390:	89 d8                	mov    %ebx,%eax
     392:	e8 fc ff ff ff       	call   393 <fsm_get_name_by_id+0x33>
			break;
			}
		}
	*name ='\0';
     397:	c6 03 00             	movb   $0x0,(%ebx)
}
     39a:	5b                   	pop    %ebx
     39b:	5d                   	pop    %ebp
     39c:	c3                   	ret    
     39d:	8d 76 00             	lea    0x0(%esi),%esi

000003a0 <fsm_intf_addr_get>:

void* fsm_intf_addr_get(int strm_id)
{
     3a0:	55                   	push   %ebp
     3a1:	89 e5                	mov    %esp,%ebp
     3a3:	e8 fc ff ff ff       	call   3a4 <fsm_intf_addr_get+0x4>
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3a8:	c1 e0 04             	shl    $0x4,%eax
     3ab:	8d 90 40 00 00 00    	lea    0x40(%eax),%edx
		return INTF[strm_id].dev->dev_addr;
	else
		return NULL;
     3b1:	31 c0                	xor    %eax,%eax
	*name ='\0';
}

void* fsm_intf_addr_get(int strm_id)
{
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3b3:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
     3b7:	75 09                	jne    3c2 <fsm_intf_addr_get+0x22>
		return INTF[strm_id].dev->dev_addr;
     3b9:	8b 42 0c             	mov    0xc(%edx),%eax
     3bc:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
	else
		return NULL;
}
     3c2:	5d                   	pop    %ebp
     3c3:	c3                   	ret    
     3c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     3ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000003d0 <fsm_self_addr_get>:
	
u8* fsm_self_addr_get()
{
     3d0:	55                   	push   %ebp
     3d1:	89 e5                	mov    %esp,%ebp
     3d3:	e8 fc ff ff ff       	call   3d4 <fsm_self_addr_get+0x4>
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3d8:	a1 a8 02 00 00       	mov    0x2a8,%eax
}
     3dd:	5d                   	pop    %ebp
	
u8* fsm_self_addr_get()
{
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3de:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
}
     3e4:	c3                   	ret    
     3e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     3e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000003f0 <fsm_data_get>:



void* fsm_data_get()
{
     3f0:	55                   	push   %ebp
     3f1:	89 e5                	mov    %esp,%ebp
     3f3:	e8 fc ff ff ff       	call   3f4 <fsm_data_get+0x4>
	void* buffer;
	buffer = fsm_core.buffer;
     3f8:	a1 ac 02 00 00       	mov    0x2ac,%eax
	fsm_core.buffer = NULL;
     3fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     404:	00 00 00 
	return buffer;
}
     407:	5d                   	pop    %ebp
     408:	c3                   	ret    
     409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000410 <fsm_data_destroy>:

void fsm_data_destroy(void* data_ptr)
{
     410:	55                   	push   %ebp
     411:	89 e5                	mov    %esp,%ebp
     413:	e8 fc ff ff ff       	call   414 <fsm_data_destroy+0x4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     418:	e8 fc ff ff ff       	call   419 <fsm_data_destroy+0x9>
}

void fsm_data_destroy(void* data_ptr)
{
	fsm_mem_free(data_ptr);
	freenum++;
     41d:	83 05 00 00 00 00 01 	addl   $0x1,0x0
}
     424:	5d                   	pop    %ebp
     425:	c3                   	ret    
     426:	8d 76 00             	lea    0x0(%esi),%esi
     429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000430 <__fsm_core_self_drive>:
		fsm_mem_free(tmev_ptr);
	}
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
     430:	55                   	push   %ebp
     431:	89 e5                	mov    %esp,%ebp
     433:	56                   	push   %esi
     434:	53                   	push   %ebx
     435:	e8 fc ff ff ff       	call   436 <__fsm_core_self_drive+0x6>
     43a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsm_core.current_fsm = dst_id;
     43d:	89 1d 20 00 00 00    	mov    %ebx,0x20
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     443:	8b 1c 9d 90 02 00 00 	mov    0x290(,%ebx,4),%ebx
	fsm_core.evtype = evtype;
     44a:	a3 30 00 00 00       	mov    %eax,0x30
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     44f:	8b 45 08             	mov    0x8(%ebp),%eax
static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
	fsm_core.evtype = evtype;
	fsm_core.code = code;
     452:	89 15 34 00 00 00    	mov    %edx,0x34
	fsm_core.pkptr = pkptr;
     458:	89 0d 2c 00 00 00    	mov    %ecx,0x2c
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     45e:	8d b3 8c 00 00 00    	lea    0x8c(%ebx),%esi
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     464:	a3 38 00 00 00       	mov    %eax,0x38
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     469:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     46f:	89 35 24 00 00 00    	mov    %esi,0x24
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     475:	a3 3c 00 00 00       	mov    %eax,0x3c
	fsm_core.buffer = buffer;
     47a:	8b 45 10             	mov    0x10(%ebp),%eax
     47d:	a3 ac 02 00 00       	mov    %eax,0x2ac
	fsm_core.ioctrl_cmd = ioctrl_cmd;
     482:	8b 45 14             	mov    0x14(%ebp),%eax
     485:	a3 b0 02 00 00       	mov    %eax,0x2b0
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
     48a:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
     490:	a3 40 00 00 00       	mov    %eax,0x40
	fsm_core.fsm_drive();
     495:	ff d0                	call   *%eax

/* ------------------internal functions-------------------------------*/
static void __fsm_ev_flush()
{
	
	if(fsm_core.pkptr)
     497:	a1 2c 00 00 00       	mov    0x2c,%eax
     49c:	85 c0                	test   %eax,%eax
     49e:	74 05                	je     4a5 <__fsm_core_self_drive+0x75>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     4a0:	e8 fc ff ff ff       	call   4a1 <__fsm_core_self_drive+0x71>
		}
//	if(fsm_core.buffer && !(fsm_ev_type()==FSM_EV_TYPE_CORE && fsm_ev_code()==FSM_EV_IOCTRL && fsm_ev_src()==USER_SPACE))
//		{
//		fsm_mem_free(fsm_core.buffer);
//		}
	if(fsm_core.buffer)
     4a5:	a1 ac 02 00 00       	mov    0x2ac,%eax
     4aa:	85 c0                	test   %eax,%eax
     4ac:	74 05                	je     4b3 <__fsm_core_self_drive+0x83>
		{
		fsm_data_destroy(fsm_core.buffer);
     4ae:	e8 fc ff ff ff       	call   4af <__fsm_core_self_drive+0x7f>
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4b3:	5b                   	pop    %ebx
//		}
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
     4b4:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
     4bb:	ff ff ff 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4be:	5e                   	pop    %esi
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
     4bf:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
     4c6:	00 00 00 
	fsm_core.pkptr = NULL;
     4c9:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     4d0:	00 00 00 
	fsm_core.evtype = INVALIDE;
     4d3:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
     4da:	00 00 00 
	fsm_core.code = INVALIDE;
     4dd:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
     4e4:	00 00 00 
	fsm_core.src = INVALIDE;
     4e7:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
     4ee:	00 00 00 
	FSM_SV_PTR = NULL;
     4f1:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
     4f8:	00 00 00 
	fsm_core.fsm_drive = NULL;
     4fb:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
     502:	00 00 00 
	fsm_core.buffer = NULL;
     505:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     50c:	00 00 00 
	fsm_core.ioctrl_cmd = INVALIDE;
     50f:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
     516:	00 00 00 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     519:	5d                   	pop    %ebp
     51a:	c3                   	ret    
     51b:	90                   	nop
     51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000520 <fsm_pkt_get>:


/* Packet operation */

FSM_PKT* fsm_pkt_get()
{
     520:	55                   	push   %ebp
     521:	89 e5                	mov    %esp,%ebp
     523:	e8 fc ff ff ff       	call   524 <fsm_pkt_get+0x4>
	FSM_PKT* ptr;
	ptr = fsm_core.pkptr;
     528:	a1 2c 00 00 00       	mov    0x2c,%eax
	fsm_core.pkptr = NULL;
     52d:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     534:	00 00 00 
	return ptr;
}
     537:	5d                   	pop    %ebp
     538:	c3                   	ret    
     539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000540 <fsm_pkt_send>:

void fsm_pkt_send(FSM_PKT* pkptr, int oinf)
{
     540:	55                   	push   %ebp
     541:	89 e5                	mov    %esp,%ebp
     543:	53                   	push   %ebx
     544:	e8 fc ff ff ff       	call   545 <fsm_pkt_send+0x5>
	if(oinf < MAX_INTF && INTF[oinf].valid)
     549:	83 fa 1f             	cmp    $0x1f,%edx
     54c:	7f 2a                	jg     578 <fsm_pkt_send+0x38>
     54e:	c1 e2 04             	shl    $0x4,%edx
     551:	8d 9a 40 00 00 00    	lea    0x40(%edx),%ebx
     557:	8b 53 04             	mov    0x4(%ebx),%edx
     55a:	85 d2                	test   %edx,%edx
     55c:	74 1a                	je     578 <fsm_pkt_send+0x38>
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
     55e:	83 fa 01             	cmp    $0x1,%edx
     561:	74 25                	je     588 <fsm_pkt_send+0x48>
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
			}
		else if(INTF[oinf].valid == DEV_INTF_IND)
     563:	83 fa 02             	cmp    $0x2,%edx
     566:	75 15                	jne    57d <fsm_pkt_send+0x3d>
			{
			INTF[oinf].send(pkptr, fsm_core.dev, INTF[oinf].proto);
     568:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     56c:	8b 15 a8 02 00 00    	mov    0x2a8,%edx
     572:	ff 53 10             	call   *0x10(%ebx)
     575:	eb 06                	jmp    57d <fsm_pkt_send+0x3d>
     577:	90                   	nop
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     578:	e8 fc ff ff ff       	call   579 <fsm_pkt_send+0x39>
	}
	else
	{
		fsm_pkt_destroy(pkptr);
	}
}
     57d:	5b                   	pop    %ebx
     57e:	5d                   	pop    %ebp
     57f:	90                   	nop
     580:	c3                   	ret    
     581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	if(oinf < MAX_INTF && INTF[oinf].valid)
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
     588:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     58c:	8b 53 0c             	mov    0xc(%ebx),%edx
     58f:	ff 53 10             	call   *0x10(%ebx)
     592:	eb e9                	jmp    57d <fsm_pkt_send+0x3d>
     594:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     59a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000005a0 <fsm_pkt_create>:
		fsm_pkt_destroy(pkptr);
	}
}

FSM_PKT* fsm_pkt_create(unsigned int size)
{
     5a0:	55                   	push   %ebp
     5a1:	89 e5                	mov    %esp,%ebp
     5a3:	53                   	push   %ebx
     5a4:	e8 fc ff ff ff       	call   5a5 <fsm_pkt_create+0x5>
 *	allocates memory it can be called from an interrupt.
 */
static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
					       unsigned int length)
{
	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
     5a9:	b9 20 00 00 00       	mov    $0x20,%ecx
     5ae:	89 c2                	mov    %eax,%edx
     5b0:	31 c0                	xor    %eax,%eax
     5b2:	e8 fc ff ff ff       	call   5b3 <fsm_pkt_create+0x13>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5b7:	31 d2                	xor    %edx,%edx
     5b9:	89 c3                	mov    %eax,%ebx

FSM_PKT* fsm_pkt_create(unsigned int size)
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
     5bb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
     5c1:	8b 8b a4 00 00 00    	mov    0xa4(%ebx),%ecx
     5c7:	29 c1                	sub    %eax,%ecx
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5c9:	e8 fc ff ff ff       	call   5ca <fsm_pkt_create+0x2a>
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
	return pkptr;
}
     5ce:	89 d8                	mov    %ebx,%eax
     5d0:	5b                   	pop    %ebx
     5d1:	5d                   	pop    %ebp
     5d2:	c3                   	ret    
     5d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005e0 <fsm_skb_realloc_headeroom>:


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
     5e0:	55                   	push   %ebp
     5e1:	89 e5                	mov    %esp,%ebp
     5e3:	83 ec 0c             	sub    $0xc,%esp
     5e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     5e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
     5ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
     5ef:	e8 fc ff ff ff       	call   5f0 <fsm_skb_realloc_headeroom+0x10>
     5f4:	89 c3                	mov    %eax,%ebx
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5f6:	e8 fc ff ff ff       	call   5f7 <fsm_skb_realloc_headeroom+0x17>
	if (unlikely(pkptr_new == NULL))
     5fb:	85 c0                	test   %eax,%eax


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5fd:	89 c6                	mov    %eax,%esi
	if (unlikely(pkptr_new == NULL))
     5ff:	74 27                	je     628 <fsm_skb_realloc_headeroom+0x48>
        {
        KFREE_SKB(pkptr);
        return NULL;
       	}
    if(pkptr->sk)
     601:	8b 7b 10             	mov    0x10(%ebx),%edi
     604:	85 ff                	test   %edi,%edi
     606:	74 20                	je     628 <fsm_skb_realloc_headeroom+0x48>
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */
static inline void skb_orphan(struct sk_buff *skb)
{
	if (skb->destructor)
     608:	8b 50 68             	mov    0x68(%eax),%edx
     60b:	85 d2                	test   %edx,%edx
     60d:	74 02                	je     611 <fsm_skb_realloc_headeroom+0x31>
		skb->destructor(skb);
     60f:	ff d2                	call   *%edx
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	skb_orphan(skb);
	skb->sk = sk;
     611:	89 7e 10             	mov    %edi,0x10(%esi)
 *
 * Atomically adds @i to @v.
 */
static inline void atomic_add(int i, atomic_t *v)
{
	asm volatile(LOCK_PREFIX "addl %1,%0"
     614:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
	skb->destructor = sock_wfree;
     61a:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
     621:	f0 01 87 94 00 00 00 	lock add %eax,0x94(%edi)
        {
        SKB_SET_OWNER_W(pkptr_new, pkptr->sk); 
	}
	KFREE_SKB(pkptr);
     628:	89 d8                	mov    %ebx,%eax
     62a:	e8 fc ff ff ff       	call   62b <fsm_skb_realloc_headeroom+0x4b>
	return pkptr_new;
}
     62f:	89 f0                	mov    %esi,%eax
     631:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     634:	8b 75 f8             	mov    -0x8(%ebp),%esi
     637:	8b 7d fc             	mov    -0x4(%ebp),%edi
     63a:	89 ec                	mov    %ebp,%esp
     63c:	5d                   	pop    %ebp
     63d:	c3                   	ret    
     63e:	66 90                	xchg   %ax,%ax

00000640 <fsm_pkt_destroy>:

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
     640:	55                   	push   %ebp
     641:	89 e5                	mov    %esp,%ebp
     643:	e8 fc ff ff ff       	call   644 <fsm_pkt_destroy+0x4>
	KFREE_SKB(pkptr);
     648:	e8 fc ff ff ff       	call   649 <fsm_pkt_destroy+0x9>
}
     64d:	5d                   	pop    %ebp
     64e:	c3                   	ret    
     64f:	90                   	nop

00000650 <fsm_pkt_duplicate>:

FSM_PKT* fsm_pkt_duplicate(FSM_PKT* pkptr)
{
     650:	55                   	push   %ebp
     651:	89 e5                	mov    %esp,%ebp
     653:	e8 fc ff ff ff       	call   654 <fsm_pkt_duplicate+0x4>
	return SKB_COPY(pkptr, GFP_ATOMIC);
     658:	ba 20 00 00 00       	mov    $0x20,%edx
     65d:	e8 fc ff ff ff       	call   65e <fsm_pkt_duplicate+0xe>
}
     662:	5d                   	pop    %ebp
     663:	c3                   	ret    
     664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     66a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000670 <fsm_skb_put>:

u8* fsm_skb_put(FSM_PKT* pkptr, int len)
{	
     670:	55                   	push   %ebp
     671:	89 e5                	mov    %esp,%ebp
     673:	e8 fc ff ff ff       	call   674 <fsm_skb_put+0x4>
	return (u8*)SKB_PUT(pkptr, len);
     678:	e8 fc ff ff ff       	call   679 <fsm_skb_put+0x9>
}
     67d:	5d                   	pop    %ebp
     67e:	c3                   	ret    
     67f:	90                   	nop

00000680 <fsm_skb_push>:

u8* fsm_skb_push(FSM_PKT* pkptr, int len)
{
     680:	55                   	push   %ebp
     681:	89 e5                	mov    %esp,%ebp
     683:	e8 fc ff ff ff       	call   684 <fsm_skb_push+0x4>
	return SKB_PUSH(pkptr, len);
     688:	e8 fc ff ff ff       	call   689 <fsm_skb_push+0x9>
}
     68d:	5d                   	pop    %ebp
     68e:	c3                   	ret    
     68f:	90                   	nop

00000690 <fsm_skb_pull>:

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	e8 fc ff ff ff       	call   694 <fsm_skb_pull+0x4>
     698:	89 c1                	mov    %eax,%ecx
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     69a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	pkptr->len -= len;
     6a0:	29 51 50             	sub    %edx,0x50(%ecx)
}

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     6a3:	01 d0                	add    %edx,%eax
     6a5:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
	pkptr->len -= len;
	return (u8 *)pkptr->data;
}
     6ab:	5d                   	pop    %ebp
     6ac:	c3                   	ret    
     6ad:	8d 76 00             	lea    0x0(%esi),%esi

000006b0 <fsm_skb_reserve>:

void fsm_skb_reserve(FSM_PKT* pkptr , int len)
{
     6b0:	55                   	push   %ebp
     6b1:	89 e5                	mov    %esp,%ebp
     6b3:	e8 fc ff ff ff       	call   6b4 <fsm_skb_reserve+0x4>
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
     6b8:	01 90 ac 00 00 00    	add    %edx,0xac(%eax)
	skb->tail += len;
     6be:	01 90 a0 00 00 00    	add    %edx,0xa0(%eax)
	SKB_RESERVE(pkptr, len);
}
     6c4:	5d                   	pop    %ebp
     6c5:	c3                   	ret    
     6c6:	8d 76 00             	lea    0x0(%esi),%esi
     6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000006d0 <fsm_skb_tailroom>:

int fsm_skb_tailroom(FSM_PKT* pkptr)
{
     6d0:	55                   	push   %ebp
     6d1:	89 e5                	mov    %esp,%ebp
     6d3:	e8 fc ff ff ff       	call   6d4 <fsm_skb_tailroom+0x4>
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */
static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
     6d8:	31 d2                	xor    %edx,%edx
     6da:	8b 48 54             	mov    0x54(%eax),%ecx
     6dd:	85 c9                	test   %ecx,%ecx
     6df:	75 0c                	jne    6ed <fsm_skb_tailroom+0x1d>
     6e1:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
     6e7:	2b 90 a0 00 00 00    	sub    0xa0(%eax),%edx
	return SKB_TAILROOM(pkptr);
}
     6ed:	89 d0                	mov    %edx,%eax
     6ef:	5d                   	pop    %ebp
     6f0:	c3                   	ret    
     6f1:	eb 0d                	jmp    700 <fsm_skb_headroom>
     6f3:	90                   	nop
     6f4:	90                   	nop
     6f5:	90                   	nop
     6f6:	90                   	nop
     6f7:	90                   	nop
     6f8:	90                   	nop
     6f9:	90                   	nop
     6fa:	90                   	nop
     6fb:	90                   	nop
     6fc:	90                   	nop
     6fd:	90                   	nop
     6fe:	90                   	nop
     6ff:	90                   	nop

00000700 <fsm_skb_headroom>:

int fsm_skb_headroom(FSM_PKT* pkptr)
{
     700:	55                   	push   %ebp
     701:	89 e5                	mov    %esp,%ebp
     703:	e8 fc ff ff ff       	call   704 <fsm_skb_headroom+0x4>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
     708:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
     70e:	2b 90 a8 00 00 00    	sub    0xa8(%eax),%edx
	return SKB_HEADROOM(pkptr);
}
     714:	5d                   	pop    %ebp
     715:	89 d0                	mov    %edx,%eax
     717:	c3                   	ret    
     718:	90                   	nop
     719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000720 <fsm_mem_alloc>:

/* Memory operation */
void* fsm_mem_alloc(size_t size)
{
     720:	55                   	push   %ebp
     721:	89 e5                	mov    %esp,%ebp
     723:	e8 fc ff ff ff       	call   724 <fsm_mem_alloc+0x4>
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(s, flags, size);
		}
	}
	return __kmalloc(size, flags);
     728:	ba 20 00 00 00       	mov    $0x20,%edx
     72d:	e8 fc ff ff ff       	call   72e <fsm_mem_alloc+0xe>
	void* ptr;
	ptr = FSM_MEM_ALLOC(size);
	mallocnum++;
     732:	83 05 00 00 00 00 01 	addl   $0x1,0x0
	return ptr;
}
     739:	5d                   	pop    %ebp
     73a:	c3                   	ret    
     73b:	90                   	nop
     73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000740 <__fsm_tm_ev_add.constprop.7>:
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     740:	55                   	push   %ebp
     741:	89 e5                	mov    %esp,%ebp
     743:	57                   	push   %edi
     744:	56                   	push   %esi
     745:	53                   	push   %ebx
     746:	83 ec 14             	sub    $0x14,%esp
     749:	e8 fc ff ff ff       	call   74a <__fsm_tm_ev_add.constprop.7+0xa>
     74e:	89 c3                	mov    %eax,%ebx
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     750:	b8 2c 00 00 00       	mov    $0x2c,%eax
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     755:	89 d6                	mov    %edx,%esi
     757:	89 cf                	mov    %ecx,%edi
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     759:	e8 fc ff ff ff       	call   75a <__fsm_tm_ev_add.constprop.7+0x1a>
	if(pE)
     75e:	85 c0                	test   %eax,%eax
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     760:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(pE)
     763:	0f 84 bc 00 00 00    	je     825 <__fsm_tm_ev_add.constprop.7+0xe5>
	{
		pE->evmask = EVMASK;
     769:	c7 40 04 d6 96 0f 04 	movl   $0x40f96d6,0x4(%eax)
		pE->pNext = 0;
		pE->type = type;
		pE->code = code;
		pE->delay = delay;
		pE->pkptr = pkptr;
		pE->src_id =src;
     770:	8b 55 f0             	mov    -0x10(%ebp),%edx
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
     773:	85 db                	test   %ebx,%ebx
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
	if(pE)
	{
		pE->evmask = EVMASK;
		pE->pNext = 0;
     775:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		pE->type = type;
     77b:	89 70 18             	mov    %esi,0x18(%eax)
		pE->code = code;
     77e:	89 78 14             	mov    %edi,0x14(%eax)
		pE->delay = delay;
     781:	89 58 10             	mov    %ebx,0x10(%eax)
		pE->pkptr = pkptr;
     784:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
		pE->src_id =src;
     78b:	8b 45 08             	mov    0x8(%ebp),%eax
     78e:	89 42 24             	mov    %eax,0x24(%edx)
		pE->dst_id = dst;
     791:	8b 45 0c             	mov    0xc(%ebp),%eax
     794:	89 42 20             	mov    %eax,0x20(%edx)
		pE->buffer = buffer;
     797:	8b 45 10             	mov    0x10(%ebp),%eax
     79a:	89 42 28             	mov    %eax,0x28(%edx)
		if(delay == 0)
     79d:	0f 84 8d 00 00 00    	je     830 <__fsm_tm_ev_add.constprop.7+0xf0>
			pE->expire = ktime_add_us(ktime_get(), 10);
		else
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
     7a3:	e8 fc ff ff ff       	call   7a4 <__fsm_tm_ev_add.constprop.7+0x64>
     7a8:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
     7ab:	01 db                	add    %ebx,%ebx
     7ad:	89 c6                	mov    %eax,%esi
       return ktime_to_us(ktime_sub(later, earlier));
}

static inline ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
	return ktime_add_ns(kt, usec * 1000);
     7af:	b8 e8 03 00 00       	mov    $0x3e8,%eax
     7b4:	89 d7                	mov    %edx,%edi
     7b6:	f7 e3                	mul    %ebx
     7b8:	01 f0                	add    %esi,%eax
     7ba:	8b 75 f0             	mov    -0x10(%ebp),%esi
     7bd:	11 fa                	adc    %edi,%edx
     7bf:	89 46 08             	mov    %eax,0x8(%esi)
     7c2:	89 56 0c             	mov    %edx,0xc(%esi)
	__tmEvent* p0;
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     7c5:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     7ca:	e8 fc ff ff ff       	call   7cb <__fsm_tm_ev_add.constprop.7+0x8b>
     7cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     7d2:	a1 88 02 00 00       	mov    0x288,%eax
     7d7:	85 c0                	test   %eax,%eax
     7d9:	74 24                	je     7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     7db:	8b 7d f0             	mov    -0x10(%ebp),%edi
     7de:	8b 48 08             	mov    0x8(%eax),%ecx
     7e1:	8b 58 0c             	mov    0xc(%eax),%ebx
     7e4:	8b 77 08             	mov    0x8(%edi),%esi
     7e7:	8b 7f 0c             	mov    0xc(%edi),%edi
     7ea:	89 75 e8             	mov    %esi,-0x18(%ebp)
     7ed:	89 ce                	mov    %ecx,%esi
     7ef:	89 7d ec             	mov    %edi,-0x14(%ebp)
     7f2:	89 df                	mov    %ebx,%edi
     7f4:	2b 75 e8             	sub    -0x18(%ebp),%esi
     7f7:	1b 7d ec             	sbb    -0x14(%ebp),%edi
     7fa:	83 ff 00             	cmp    $0x0,%edi
     7fd:	7e 51                	jle    850 <__fsm_tm_ev_add.constprop.7+0x110>
	{
		pE->pNext = pB->evQ;
     7ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
     802:	89 02                	mov    %eax,(%edx)
		pB->evQ = pE;
		if(pB->tm_state != FSM_TM_EXPIRE)
     804:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
	{
		pE->pNext = pB->evQ;
		pB->evQ = pE;
     80b:	89 15 88 02 00 00    	mov    %edx,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     811:	74 05                	je     818 <__fsm_tm_ev_add.constprop.7+0xd8>
		{
			__fsm_tm_restart();
     813:	e8 18 f9 ff ff       	call   130 <__fsm_tm_restart>
     818:	8b 55 e0             	mov    -0x20(%ebp),%edx
     81b:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     820:	e8 fc ff ff ff       	call   821 <__fsm_tm_ev_add.constprop.7+0xe1>
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
		__fsm_tm_ev_insert(pE);
		return EVHANDLE(pE);
	}
	return 0;
}
     825:	8b 45 f0             	mov    -0x10(%ebp),%eax
     828:	83 c4 14             	add    $0x14,%esp
     82b:	5b                   	pop    %ebx
     82c:	5e                   	pop    %esi
     82d:	5f                   	pop    %edi
     82e:	5d                   	pop    %ebp
     82f:	c3                   	ret    
		pE->pkptr = pkptr;
		pE->src_id =src;
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
			pE->expire = ktime_add_us(ktime_get(), 10);
     830:	e8 fc ff ff ff       	call   831 <__fsm_tm_ev_add.constprop.7+0xf1>
     835:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     838:	05 10 27 00 00       	add    $0x2710,%eax
     83d:	83 d2 00             	adc    $0x0,%edx
     840:	89 41 08             	mov    %eax,0x8(%ecx)
     843:	89 51 0c             	mov    %edx,0xc(%ecx)
     846:	e9 7a ff ff ff       	jmp    7c5 <__fsm_tm_ev_add.constprop.7+0x85>
     84b:	90                   	nop
     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     850:	7c 1f                	jl     871 <__fsm_tm_ev_add.constprop.7+0x131>
     852:	83 fe 00             	cmp    $0x0,%esi
     855:	76 1a                	jbe    871 <__fsm_tm_ev_add.constprop.7+0x131>
     857:	eb a6                	jmp    7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
	{
		p1 = p0;
		p0 = p0->pNext;
     860:	8b 10                	mov    (%eax),%edx
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return;
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
     862:	85 d2                	test   %edx,%edx
     864:	74 32                	je     898 <__fsm_tm_ev_add.constprop.7+0x158>
     866:	8b 4a 08             	mov    0x8(%edx),%ecx
     869:	8b 5a 0c             	mov    0xc(%edx),%ebx
     86c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     86f:	89 d0                	mov    %edx,%eax
     871:	8b 75 e8             	mov    -0x18(%ebp),%esi
     874:	8b 7d ec             	mov    -0x14(%ebp),%edi
     877:	29 ce                	sub    %ecx,%esi
     879:	19 df                	sbb    %ebx,%edi
     87b:	83 ff 00             	cmp    $0x0,%edi
     87e:	7f e0                	jg     860 <__fsm_tm_ev_add.constprop.7+0x120>
     880:	7c 05                	jl     887 <__fsm_tm_ev_add.constprop.7+0x147>
     882:	83 fe 00             	cmp    $0x0,%esi
     885:	77 d9                	ja     860 <__fsm_tm_ev_add.constprop.7+0x120>
     887:	8b 55 ec             	mov    -0x14(%ebp),%edx
     88a:	33 4d e8             	xor    -0x18(%ebp),%ecx
     88d:	31 da                	xor    %ebx,%edx
     88f:	09 ca                	or     %ecx,%edx
     891:	74 cd                	je     860 <__fsm_tm_ev_add.constprop.7+0x120>
     893:	89 c2                	mov    %eax,%edx
     895:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		p1 = p0;
		p0 = p0->pNext;
	}
	pE->pNext = p0;
     898:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     89b:	89 11                	mov    %edx,(%ecx)
	p1->pNext = pE;
     89d:	89 08                	mov    %ecx,(%eax)
     89f:	e9 74 ff ff ff       	jmp    818 <__fsm_tm_ev_add.constprop.7+0xd8>
     8a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     8aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000008b0 <fsm_mem_free>:
	mallocnum++;
	return ptr;
}

void fsm_mem_free(void* ptr)
{
     8b0:	55                   	push   %ebp
     8b1:	89 e5                	mov    %esp,%ebp
     8b3:	e8 fc ff ff ff       	call   8b4 <fsm_mem_free+0x4>
	FSM_MEM_FREE(ptr);
     8b8:	e8 fc ff ff ff       	call   8b9 <fsm_mem_free+0x9>
}
     8bd:	5d                   	pop    %ebp
     8be:	c3                   	ret    
     8bf:	90                   	nop

000008c0 <fsm_mem_cpy>:

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
     8c0:	55                   	push   %ebp
     8c1:	89 e5                	mov    %esp,%ebp
     8c3:	e8 fc ff ff ff       	call   8c4 <fsm_mem_cpy+0x4>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     8c8:	e8 fc ff ff ff       	call   8c9 <fsm_mem_cpy+0x9>
}
     8cd:	5d                   	pop    %ebp
     8ce:	c3                   	ret    
     8cf:	90                   	nop

000008d0 <fsm_mem_set>:

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
     8d0:	55                   	push   %ebp
     8d1:	89 e5                	mov    %esp,%ebp
     8d3:	e8 fc ff ff ff       	call   8d4 <fsm_mem_set+0x4>
	return FSM_MEM_SET(dst_ptr,val,size);
     8d8:	e8 fc ff ff ff       	call   8d9 <fsm_mem_set+0x9>
}
     8dd:	5d                   	pop    %ebp
     8de:	c3                   	ret    
     8df:	90                   	nop

000008e0 <fsm_mem_cmp>:

int fsm_mem_cmp(const void* dst_ptr, const void* src_ptr, size_t size)
{
     8e0:	55                   	push   %ebp
     8e1:	89 e5                	mov    %esp,%ebp
     8e3:	e8 fc ff ff ff       	call   8e4 <fsm_mem_cmp+0x4>
	return FSM_MEM_CMP(dst_ptr,src_ptr,size);
     8e8:	e8 fc ff ff ff       	call   8e9 <fsm_mem_cmp+0x9>
}
     8ed:	5d                   	pop    %ebp
     8ee:	c3                   	ret    
     8ef:	90                   	nop

000008f0 <fsm_printf>:


/* Print */
size_t fsm_printf(const char* fmt,...)
{
     8f0:	55                   	push   %ebp
     8f1:	89 e5                	mov    %esp,%ebp
     8f3:	83 ec 08             	sub    $0x8,%esp
     8f6:	e8 fc ff ff ff       	call   8f7 <fsm_printf+0x7>
	//return 0;
	int print_len;
	va_list args;
	va_start(args,fmt);
     8fb:	8d 45 0c             	lea    0xc(%ebp),%eax
	print_len = VPRINTK(fmt,args);
     8fe:	89 44 24 04          	mov    %eax,0x4(%esp)
     902:	8b 45 08             	mov    0x8(%ebp),%eax
     905:	89 04 24             	mov    %eax,(%esp)
     908:	e8 fc ff ff ff       	call   909 <fsm_printf+0x19>
	va_end(args);
	return print_len;
	
	return 0;
}
     90d:	c9                   	leave  
     90e:	c3                   	ret    
     90f:	90                   	nop

00000910 <__fsm_pending_expev>:
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}

static void __fsm_pending_expev(unsigned long data)
{
     910:	55                   	push   %ebp
     911:	89 e5                	mov    %esp,%ebp
     913:	57                   	push   %edi
     914:	56                   	push   %esi
     915:	53                   	push   %ebx
     916:	83 ec 18             	sub    $0x18,%esp
     919:	e8 fc ff ff ff       	call   91a <__fsm_pending_expev+0xa>
     91e:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     924:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     92a:	0f 85 a5 00 00 00    	jne    9d5 <__fsm_pending_expev+0xc5>
     930:	e9 eb 00 00 00       	jmp    a20 <__fsm_pending_expev+0x110>
     935:	8d 76 00             	lea    0x0(%esi),%esi
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     938:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     93d:	e8 fc ff ff ff       	call   93e <__fsm_pending_expev+0x2e>
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     942:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
     945:	8b 53 14             	mov    0x14(%ebx),%edx
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     948:	89 45 ec             	mov    %eax,-0x14(%ebp)
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     94b:	8b 43 18             	mov    0x18(%ebx),%eax
     94e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     955:	00 
     956:	8b 7b 28             	mov    0x28(%ebx),%edi
     959:	89 7c 24 08          	mov    %edi,0x8(%esp)
     95d:	8b 7b 20             	mov    0x20(%ebx),%edi
     960:	89 7c 24 04          	mov    %edi,0x4(%esp)
     964:	8b 7b 24             	mov    0x24(%ebx),%edi
     967:	89 3c 24             	mov    %edi,(%esp)
     96a:	e8 c1 fa ff ff       	call   430 <__fsm_core_self_drive>
     96f:	8b 55 ec             	mov    -0x14(%ebp),%edx
     972:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     977:	e8 fc ff ff ff       	call   978 <__fsm_pending_expev+0x68>

#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)

static inline int arch_spin_is_locked(struct arch_spinlock *lock)
{
	return PVOP_CALL1(int, pv_lock_ops.spin_is_locked, lock);
     97c:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     981:	ff 15 00 00 00 00    	call   *0x0
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
     987:	85 c0                	test   %eax,%eax
     989:	75 7d                	jne    a08 <__fsm_pending_expev+0xf8>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
//			return;
		} 
		spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
     98b:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     990:	e8 fc ff ff ff       	call   991 <__fsm_pending_expev+0x81>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     995:	8b 4e 04             	mov    0x4(%esi),%ecx
     998:	8b 3e                	mov    (%esi),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     99a:	89 4f 04             	mov    %ecx,0x4(%edi)
     99d:	89 c2                	mov    %eax,%edx
     99f:	b8 e6 02 00 00       	mov    $0x2e6,%eax
	prev->next = next;
     9a4:	89 39                	mov    %edi,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     9a6:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
     9ac:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
     9b3:	e8 fc ff ff ff       	call   9b4 <__fsm_pending_expev+0xa4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     9b8:	89 d8                	mov    %ebx,%eax
     9ba:	e8 fc ff ff ff       	call   9bb <__fsm_pending_expev+0xab>
     9bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9c2:	e8 fc ff ff ff       	call   9c3 <__fsm_pending_expev+0xb3>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     9c7:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
static void __fsm_pending_expev(unsigned long data)
{
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     9cd:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     9d3:	74 4b                	je     a20 <__fsm_pending_expev+0x110>
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9d5:	8d 46 fc             	lea    -0x4(%esi),%eax
		pE = tmev_ptr->pE;
     9d8:	8b 5e fc             	mov    -0x4(%esi),%ebx
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9db:	89 45 f0             	mov    %eax,-0x10(%ebp)
     9de:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     9e3:	ff 15 00 00 00 00    	call   *0x0
		pE = tmev_ptr->pE;
		if(spin_is_locked(&fsm_core.lock))
     9e9:	85 c0                	test   %eax,%eax
     9eb:	0f 84 47 ff ff ff    	je     938 <__fsm_pending_expev+0x28>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
     9f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     9f8:	e8 fc ff ff ff       	call   9f9 <__fsm_pending_expev+0xe9>
     9fd:	e9 36 ff ff ff       	jmp    938 <__fsm_pending_expev+0x28>
     a02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
     a08:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
     a0f:	e8 fc ff ff ff       	call   a10 <__fsm_pending_expev+0x100>
     a14:	e9 72 ff ff ff       	jmp    98b <__fsm_pending_expev+0x7b>
     a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		list_del(&tmev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
		fsm_mem_free(pE);
		fsm_mem_free(tmev_ptr);
	}
}
     a20:	83 c4 18             	add    $0x18,%esp
     a23:	5b                   	pop    %ebx
     a24:	5e                   	pop    %esi
     a25:	5f                   	pop    %edi
     a26:	5d                   	pop    %ebp
     a27:	c3                   	ret    
     a28:	90                   	nop
     a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000a30 <__fsm_tm_expire>:
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
}

static enum hrtimer_restart __fsm_tm_expire(struct hrtimer *timer)
{
     a30:	55                   	push   %ebp
     a31:	89 e5                	mov    %esp,%ebp
     a33:	57                   	push   %edi
     a34:	56                   	push   %esi
     a35:	53                   	push   %ebx
     a36:	83 ec 08             	sub    $0x8,%esp
     a39:	e8 fc ff ff ff       	call   a3a <__fsm_tm_expire+0xa>
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a3e:	e8 fc ff ff ff       	call   a3f <__fsm_tm_expire+0xf>
	pB->tm_state = FSM_TM_EXPIRE;
     a43:	c7 05 44 02 00 00 02 	movl   $0x2,0x244
     a4a:	00 00 00 
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a4d:	89 c6                	mov    %eax,%esi
     a4f:	89 d7                	mov    %edx,%edi
     a51:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a56:	ff 15 00 00 00 00    	call   *0x0
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
     a5c:	85 c0                	test   %eax,%eax
     a5e:	0f 85 9c 00 00 00    	jne    b00 <__fsm_tm_expire+0xd0>
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a64:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a69:	e8 fc ff ff ff       	call   a6a <__fsm_tm_expire+0x3a>
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a6e:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     a74:	85 db                	test   %ebx,%ebx
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a79:	74 15                	je     a90 <__fsm_tm_expire+0x60>
     a7b:	8b 43 08             	mov    0x8(%ebx),%eax
     a7e:	8b 53 0c             	mov    0xc(%ebx),%edx
     a81:	29 f0                	sub    %esi,%eax
     a83:	19 fa                	sbb    %edi,%edx
     a85:	83 fa 00             	cmp    $0x0,%edx
     a88:	0f 8e a2 00 00 00    	jle    b30 <__fsm_tm_expire+0x100>
     a8e:	66 90                	xchg   %ax,%ax
     a90:	8b 55 f0             	mov    -0x10(%ebp),%edx
     a93:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a98:	e8 fc ff ff ff       	call   a99 <__fsm_tm_expire+0x69>
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
			tmev_ptr->pE = pE;
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);		
		tasklet_schedule(fsm_core.exp_ev_tsklt);
     a9d:	a1 cc 02 00 00       	mov    0x2cc,%eax
     aa2:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     aa8:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     aaa:	85 d2                	test   %edx,%edx
     aac:	74 42                	je     af0 <__fsm_tm_expire+0xc0>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     aae:	a1 88 02 00 00       	mov    0x288,%eax
     ab3:	85 c0                	test   %eax,%eax
     ab5:	74 61                	je     b18 <__fsm_tm_expire+0xe8>
     ab7:	8b 50 0c             	mov    0xc(%eax),%edx
     aba:	8b 40 08             	mov    0x8(%eax),%eax
        {	
		hrtimer_set_expires(&pB->timer, pB->evQ->expire);
		pB->tm_state = FSM_TM_RUN;	
     abd:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     ac4:	00 00 00 
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
};

static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
	timer->node.expires = time;
     ac7:	89 15 58 02 00 00    	mov    %edx,0x258
     acd:	a3 54 02 00 00       	mov    %eax,0x254
	timer->_softexpires = time;
     ad2:	a3 5c 02 00 00       	mov    %eax,0x25c
		return HRTIMER_RESTART;
     ad7:	b8 01 00 00 00       	mov    $0x1,%eax
     adc:	89 15 60 02 00 00    	mov    %edx,0x260
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     ae2:	83 c4 08             	add    $0x8,%esp
     ae5:	5b                   	pop    %ebx
     ae6:	5e                   	pop    %esi
     ae7:	5f                   	pop    %edi
     ae8:	5d                   	pop    %ebp
     ae9:	c3                   	ret    
     aea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		__tasklet_schedule(t);
     af0:	e8 fc ff ff ff       	call   af1 <__fsm_tm_expire+0xc1>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     af5:	a1 88 02 00 00       	mov    0x288,%eax
     afa:	85 c0                	test   %eax,%eax
     afc:	75 b9                	jne    ab7 <__fsm_tm_expire+0x87>
     afe:	eb 18                	jmp    b18 <__fsm_tm_expire+0xe8>
	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
	{
		fsm_printf("dead lock\n");
     b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     b07:	e8 fc ff ff ff       	call   b08 <__fsm_tm_expire+0xd8>
		return HRTIMER_NORESTART;
     b0c:	31 c0                	xor    %eax,%eax
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     b0e:	83 c4 08             	add    $0x8,%esp
     b11:	5b                   	pop    %ebx
     b12:	5e                   	pop    %esi
     b13:	5f                   	pop    %edi
     b14:	5d                   	pop    %ebp
     b15:	c3                   	ret    
     b16:	66 90                	xchg   %ax,%ax
		pB->tm_state = FSM_TM_RUN;	
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
     b18:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     b1f:	00 00 00 
		return HRTIMER_NORESTART;	
	}
	
}
     b22:	83 c4 08             	add    $0x8,%esp
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
     b25:	31 c0                	xor    %eax,%eax
	}
	
}
     b27:	5b                   	pop    %ebx
     b28:	5e                   	pop    %esi
     b29:	5f                   	pop    %edi
     b2a:	5d                   	pop    %ebp
     b2b:	c3                   	ret    
     b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b30:	7c 0f                	jl     b41 <__fsm_tm_expire+0x111>
     b32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b38:	83 f8 00             	cmp    $0x0,%eax
     b3b:	0f 87 4f ff ff ff    	ja     a90 <__fsm_tm_expire+0x60>
		{
			pE = pB->evQ;
			pB->evQ = pE->pNext;
     b41:	8b 03                	mov    (%ebx),%eax
     b43:	a3 88 02 00 00       	mov    %eax,0x288
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
     b48:	b8 0c 00 00 00       	mov    $0xc,%eax
     b4d:	e8 fc ff ff ff       	call   b4e <__fsm_tm_expire+0x11e>
			tmev_ptr->pE = pE;
     b52:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     b54:	8b 15 e0 02 00 00    	mov    0x2e0,%edx
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
     b5a:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     b5d:	89 0d e0 02 00 00    	mov    %ecx,0x2e0
	new->next = next;
     b63:	c7 40 04 dc 02 00 00 	movl   $0x2dc,0x4(%eax)
	new->prev = prev;
     b6a:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
     b6d:	89 0a                	mov    %ecx,(%edx)
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b6f:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     b75:	85 db                	test   %ebx,%ebx
     b77:	0f 84 13 ff ff ff    	je     a90 <__fsm_tm_expire+0x60>
     b7d:	8b 43 08             	mov    0x8(%ebx),%eax
     b80:	8b 53 0c             	mov    0xc(%ebx),%edx
     b83:	29 f0                	sub    %esi,%eax
     b85:	19 fa                	sbb    %edi,%edx
     b87:	83 fa 00             	cmp    $0x0,%edx
     b8a:	7c b5                	jl     b41 <__fsm_tm_expire+0x111>
     b8c:	0f 8f fe fe ff ff    	jg     a90 <__fsm_tm_expire+0x60>
     b92:	eb a4                	jmp    b38 <__fsm_tm_expire+0x108>
     b94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000ba0 <fsm_octets_print>:
	
	return 0;
}

size_t fsm_octets_print(void* data_ptr, size_t num)
{
     ba0:	55                   	push   %ebp
     ba1:	89 e5                	mov    %esp,%ebp
     ba3:	e8 fc ff ff ff       	call   ba4 <fsm_octets_print+0x4>
		}
	}
	fsm_printf("\n");
	fsm_printf("=====================================================\n");
	return num;
}
     ba8:	31 c0                	xor    %eax,%eax
     baa:	5d                   	pop    %ebp
     bab:	c3                   	ret    
     bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bb0 <fsm_htons>:

/* Endianness */
u16 fsm_htons(u16 val)
{
     bb0:	55                   	push   %ebp
     bb1:	89 e5                	mov    %esp,%ebp
     bb3:	e8 fc ff ff ff       	call   bb4 <fsm_htons+0x4>
	return HTONS(val);
}
     bb8:	5d                   	pop    %ebp
static inline __attribute_const__ __u16 __fswab16(__u16 val)
{
#ifdef __arch_swab16
	return __arch_swab16(val);
#else
	return ___constant_swab16(val);
     bb9:	66 c1 c0 08          	rol    $0x8,%ax
     bbd:	c3                   	ret    
     bbe:	66 90                	xchg   %ax,%ax

00000bc0 <fsm_htonl>:

u32 fsm_htonl(u32 val)
{
     bc0:	55                   	push   %ebp
     bc1:	89 e5                	mov    %esp,%ebp
     bc3:	e8 fc ff ff ff       	call   bc4 <fsm_htonl+0x4>

static inline __attribute_const__ __u32 __arch_swab32(__u32 val)
{
#ifdef __i386__
# ifdef CONFIG_X86_BSWAP
	asm("bswap %0" : "=r" (val) : "0" (val));
     bc8:	0f c8                	bswap  %eax
	return HTONL(val);
}
     bca:	5d                   	pop    %ebp
     bcb:	c3                   	ret    
     bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bd0 <fsm_ntohs>:

u16 fsm_ntohs(u16 val)
{
     bd0:	55                   	push   %ebp
     bd1:	89 e5                	mov    %esp,%ebp
     bd3:	e8 fc ff ff ff       	call   bd4 <fsm_ntohs+0x4>
	return NTOHS(val);
}
     bd8:	5d                   	pop    %ebp
     bd9:	66 c1 c0 08          	rol    $0x8,%ax
     bdd:	c3                   	ret    
     bde:	66 90                	xchg   %ax,%ax

00000be0 <fsm_ntohl>:

u32 fsm_ntohl(u32 val)
{
     be0:	55                   	push   %ebp
     be1:	89 e5                	mov    %esp,%ebp
     be3:	e8 fc ff ff ff       	call   be4 <fsm_ntohl+0x4>
     be8:	0f c8                	bswap  %eax
	return NTOHL(val);
}
     bea:	5d                   	pop    %ebp
     beb:	c3                   	ret    
     bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bf0 <fsm_schedule_self>:

/*  Event scheduling operation */
evHandle fsm_schedule_self(unsigned int delay, u32 code)
{
     bf0:	55                   	push   %ebp
     bf1:	89 e5                	mov    %esp,%ebp
     bf3:	53                   	push   %ebx
     bf4:	83 ec 0c             	sub    $0xc,%esp
     bf7:	e8 fc ff ff ff       	call   bf8 <fsm_schedule_self+0x8>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_SELF, code, NULL, fsm_core.current_fsm, fsm_core.current_fsm, NULL);
     bfc:	8b 1d 20 00 00 00    	mov    0x20,%ebx
     c02:	89 d1                	mov    %edx,%ecx
     c04:	ba 03 00 00 00       	mov    $0x3,%edx
     c09:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     c0d:	89 1c 24             	mov    %ebx,(%esp)
     c10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c17:	00 
     c18:	e8 23 fb ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c1d:	83 c4 0c             	add    $0xc,%esp
     c20:	5b                   	pop    %ebx
     c21:	5d                   	pop    %ebp
     c22:	c3                   	ret    
     c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000c30 <fsm_schedule_exfsm>:

evHandle fsm_schedule_exfsm(unsigned int delay, u32 code, int dst_id)
{
     c30:	55                   	push   %ebp
     c31:	89 e5                	mov    %esp,%ebp
     c33:	83 ec 0c             	sub    $0xc,%esp
     c36:	e8 fc ff ff ff       	call   c37 <fsm_schedule_exfsm+0x7>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_EXFSM, code, NULL, fsm_core.current_fsm, dst_id, NULL);
     c3b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     c3f:	8b 0d 20 00 00 00    	mov    0x20,%ecx
     c45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c4c:	00 
     c4d:	89 0c 24             	mov    %ecx,(%esp)
     c50:	89 d1                	mov    %edx,%ecx
     c52:	ba 04 00 00 00       	mov    $0x4,%edx
     c57:	e8 e4 fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c5c:	c9                   	leave  
     c5d:	c3                   	ret    
     c5e:	66 90                	xchg   %ax,%ax

00000c60 <fsm_post_msg>:

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
     c60:	55                   	push   %ebp
     c61:	89 e5                	mov    %esp,%ebp
     c63:	83 ec 20             	sub    $0x20,%esp
     c66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     c69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     c6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     c6f:	e8 fc ff ff ff       	call   c70 <fsm_post_msg+0x10>
     c74:	89 cf                	mov    %ecx,%edi
     c76:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c79:	89 d6                	mov    %edx,%esi
     c7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c7e:	89 c8                	mov    %ecx,%eax
     c80:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     c83:	e8 fc ff ff ff       	call   c84 <fsm_post_msg+0x24>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     c8b:	89 f2                	mov    %esi,%edx
}

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c8d:	89 c3                	mov    %eax,%ebx
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c8f:	e8 fc ff ff ff       	call   c90 <fsm_post_msg+0x30>
evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
	fsm_mem_cpy(buffer, msg_ptr, size);
	return	__fsm_tm_ev_add(0, FSM_EV_TYPE_MSG, code, NULL, fsm_core.current_fsm, dst_id, buffer);
     c94:	a1 20 00 00 00       	mov    0x20,%eax
     c99:	ba 06 00 00 00       	mov    $0x6,%edx
     c9e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     ca1:	89 04 24             	mov    %eax,(%esp)
     ca4:	31 c0                	xor    %eax,%eax
     ca6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     caa:	89 7c 24 04          	mov    %edi,0x4(%esp)
     cae:	e8 8d fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     cb3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     cb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
     cb9:	8b 7d fc             	mov    -0x4(%ebp),%edi
     cbc:	89 ec                	mov    %ebp,%esp
     cbe:	5d                   	pop    %ebp
     cbf:	c3                   	ret    

00000cc0 <fsm_schedule_cancel>:

int fsm_schedule_cancel(evHandle eh)
{
     cc0:	55                   	push   %ebp
     cc1:	89 e5                	mov    %esp,%ebp
     cc3:	56                   	push   %esi
     cc4:	53                   	push   %ebx
     cc5:	e8 fc ff ff ff       	call   cc6 <fsm_schedule_cancel+0x6>
     cca:	89 c3                	mov    %eax,%ebx
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
     ccc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
     cd1:	81 7b 04 d6 96 0f 04 	cmpl   $0x40f96d6,0x4(%ebx)
     cd8:	75 43                	jne    d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
     cda:	8b 35 88 02 00 00    	mov    0x288,%esi
     ce0:	85 f6                	test   %esi,%esi
     ce2:	74 39                	je     d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     ce4:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     ce9:	e8 fc ff ff ff       	call   cea <fsm_schedule_cancel+0x2a>
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cee:	8b 15 88 02 00 00    	mov    0x288,%edx
     cf4:	39 d3                	cmp    %edx,%ebx
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     cf6:	89 c6                	mov    %eax,%esi
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cf8:	75 0c                	jne    d06 <fsm_schedule_cancel+0x46>
     cfa:	eb 49                	jmp    d45 <fsm_schedule_cancel+0x85>
     cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
     d00:	39 c3                	cmp    %eax,%ebx
     d02:	74 24                	je     d28 <fsm_schedule_cancel+0x68>
     d04:	89 c2                	mov    %eax,%edx
     d06:	8b 02                	mov    (%edx),%eax
     d08:	85 c0                	test   %eax,%eax
     d0a:	75 f4                	jne    d00 <fsm_schedule_cancel+0x40>
     d0c:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d11:	89 f2                	mov    %esi,%edx
     d13:	e8 fc ff ff ff       	call   d14 <fsm_schedule_cancel+0x54>
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
     d18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d1d:	5b                   	pop    %ebx
     d1e:	5e                   	pop    %esi
     d1f:	5d                   	pop    %ebp
     d20:	c3                   	ret    
     d21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
		p0 = p0->pNext;
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
     d28:	8b 03                	mov    (%ebx),%eax
     d2a:	89 02                	mov    %eax,(%edx)
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d2c:	89 d8                	mov    %ebx,%eax
     d2e:	e8 fc ff ff ff       	call   d2f <fsm_schedule_cancel+0x6f>
     d33:	89 f2                	mov    %esi,%edx
     d35:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d3a:	e8 fc ff ff ff       	call   d3b <fsm_schedule_cancel+0x7b>
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
     d3f:	31 c0                	xor    %eax,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d41:	5b                   	pop    %ebx
     d42:	5e                   	pop    %esi
     d43:	5d                   	pop    %ebp
     d44:	c3                   	ret    
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d45:	8b 03                	mov    (%ebx),%eax
		if(pB->tm_state != FSM_TM_EXPIRE)
     d47:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d4e:	a3 88 02 00 00       	mov    %eax,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     d53:	74 05                	je     d5a <fsm_schedule_cancel+0x9a>
		{
			__fsm_tm_restart();
     d55:	e8 d6 f3 ff ff       	call   130 <__fsm_tm_restart>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d5a:	89 d8                	mov    %ebx,%eax
     d5c:	e8 fc ff ff ff       	call   d5d <fsm_schedule_cancel+0x9d>
		if(pB->tm_state != FSM_TM_EXPIRE)
		{
			__fsm_tm_restart();
		}
		fsm_mem_free(pE);
		if(!pB->evQ)
     d61:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     d67:	85 db                	test   %ebx,%ebx
     d69:	75 c8                	jne    d33 <fsm_schedule_cancel+0x73>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
     d6b:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
     d70:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     d77:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
     d7a:	e8 fc ff ff ff       	call   d7b <fsm_schedule_cancel+0xbb>
     d7f:	eb b2                	jmp    d33 <fsm_schedule_cancel+0x73>
     d81:	eb 0d                	jmp    d90 <fsm_do_ioctrl>
     d83:	90                   	nop
     d84:	90                   	nop
     d85:	90                   	nop
     d86:	90                   	nop
     d87:	90                   	nop
     d88:	90                   	nop
     d89:	90                   	nop
     d8a:	90                   	nop
     d8b:	90                   	nop
     d8c:	90                   	nop
     d8d:	90                   	nop
     d8e:	90                   	nop
     d8f:	90                   	nop

00000d90 <fsm_do_ioctrl>:
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     d90:	55                   	push   %ebp
     d91:	89 e5                	mov    %esp,%ebp
     d93:	83 ec 14             	sub    $0x14,%esp
     d96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     d99:	89 75 f8             	mov    %esi,-0x8(%ebp)
     d9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     d9f:	e8 fc ff ff ff       	call   da0 <fsm_do_ioctrl+0x10>
     da4:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     da7:	c1 e0 04             	shl    $0x4,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     daa:	89 d6                	mov    %edx,%esi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     dac:	8b 90 4c 00 00 00    	mov    0x4c(%eax),%edx
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     db2:	b8 18 00 00 00       	mov    $0x18,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     db7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dba:	89 55 ec             	mov    %edx,-0x14(%ebp)
     dbd:	e8 fc ff ff ff       	call   dbe <fsm_do_ioctrl+0x2e>
	ev_ptr->dev =dev;
     dc2:	8b 55 ec             	mov    -0x14(%ebp),%edx
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     dc5:	85 ff                	test   %edi,%edi
int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dc7:	89 c3                	mov    %eax,%ebx
	ev_ptr->dev =dev;
     dc9:	89 10                	mov    %edx,(%eax)
	ev_ptr->ifr.cmd = cmd;
     dcb:	89 70 04             	mov    %esi,0x4(%eax)
	ev_ptr->ifr.size = size;
     dce:	89 78 08             	mov    %edi,0x8(%eax)
	if(data_ptr != NULL && size > 0)
     dd1:	75 65                	jne    e38 <fsm_do_ioctrl+0xa8>
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
		fsm_mem_cpy(ev_ptr->ifr.buffer, data_ptr, size);
		}
	else
		{
		ev_ptr->ifr.buffer = NULL;
     dd3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     dda:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     ddf:	e8 fc ff ff ff       	call   de0 <fsm_do_ioctrl+0x50>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     de4:	a1 d8 02 00 00       	mov    0x2d8,%eax
		}
	spin_lock(&fsm_core.ioctl_list_lock);
	list_add_tail(&ev_ptr->list_node, &fsm_core.do_ioctl_list);
     de9:	8d 53 10             	lea    0x10(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     dec:	89 15 d8 02 00 00    	mov    %edx,0x2d8
	new->next = next;
     df2:	c7 43 10 d4 02 00 00 	movl   $0x2d4,0x10(%ebx)
	new->prev = prev;
     df9:	89 43 14             	mov    %eax,0x14(%ebx)
	prev->next = new;
     dfc:	89 10                	mov    %edx,(%eax)
	return PVOP_CALL1(int, pv_lock_ops.spin_trylock, lock);
}

static __always_inline void arch_spin_unlock(struct arch_spinlock *lock)
{
	PVOP_VCALL1(pv_lock_ops.spin_unlock, lock);
     dfe:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     e03:	ff 15 14 00 00 00    	call   *0x14
	spin_unlock(&fsm_core.ioctl_list_lock);
	tasklet_schedule(fsm_core.do_ioctl_tsklt);
     e09:	a1 c8 02 00 00       	mov    0x2c8,%eax
     e0e:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     e14:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     e16:	85 d2                	test   %edx,%edx
     e18:	75 05                	jne    e1f <fsm_do_ioctrl+0x8f>
		__tasklet_schedule(t);
     e1a:	e8 fc ff ff ff       	call   e1b <fsm_do_ioctrl+0x8b>
	return 1;
}
     e1f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e22:	b8 01 00 00 00       	mov    $0x1,%eax
     e27:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e2a:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e2d:	89 ec                	mov    %ebp,%esp
     e2f:	5d                   	pop    %ebp
     e30:	c3                   	ret    
     e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e3b:	85 c0                	test   %eax,%eax
     e3d:	74 94                	je     dd3 <fsm_do_ioctrl+0x43>
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e3f:	89 f8                	mov    %edi,%eax
     e41:	e8 fc ff ff ff       	call   e42 <fsm_do_ioctrl+0xb2>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
     e49:	89 f9                	mov    %edi,%ecx
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e4b:	89 43 0c             	mov    %eax,0xc(%ebx)
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e4e:	e8 fc ff ff ff       	call   e4f <fsm_do_ioctrl+0xbf>
     e53:	eb 85                	jmp    dda <fsm_do_ioctrl+0x4a>
     e55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000e60 <fsm_ioctrl_arrival>:
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e60:	55                   	push   %ebp
     e61:	89 e5                	mov    %esp,%ebp
     e63:	83 ec 28             	sub    $0x28,%esp
     e66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     e69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     e6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     e6f:	e8 fc ff ff ff       	call   e70 <fsm_ioctrl_arrival+0x10>
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e74:	81 fa f0 89 00 00    	cmp    $0x89f0,%edx
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e7a:	89 c3                	mov    %eax,%ebx
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e7c:	0f 84 b6 00 00 00    	je     f38 <fsm_ioctrl_arrival+0xd8>
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		}	
	else if(cmd == IOCUSER)	
     e82:	81 fa f1 89 00 00    	cmp    $0x89f1,%edx
     e88:	74 16                	je     ea0 <fsm_ioctrl_arrival+0x40>
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
		}
	
	return 1;
}
     e8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e8d:	b8 01 00 00 00       	mov    $0x1,%eax
     e92:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e95:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e98:	89 ec                	mov    %ebp,%esp
     e9a:	5d                   	pop    %ebp
     e9b:	c3                   	ret    
     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					  unsigned long n)
{
	int sz = __compiletime_object_size(to);

	if (likely(sz == -1 || sz >= n))
		n = _copy_from_user(to, from, n);
     ea0:	8b 50 10             	mov    0x10(%eax),%edx
     ea3:	b9 0c 00 00 00       	mov    $0xc,%ecx
     ea8:	8d 45 e8             	lea    -0x18(%ebp),%eax
     eab:	e8 fc ff ff ff       	call   eac <fsm_ioctrl_arrival+0x4c>
	else if(cmd == IOCUSER)	
		{		
		uifr_ptr = ifr;		
		copy_from_user(&kifr, uifr_ptr->ifr_ifru.ifru_data, sizeof(struct kifreq)); 	
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
     eb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     eb3:	85 c0                	test   %eax,%eax
     eb5:	0f 84 cd 00 00 00    	je     f88 <fsm_ioctrl_arrival+0x128>
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
     ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
     ebe:	e8 fc ff ff ff       	call   ebf <fsm_ioctrl_arrival+0x5f>
     ec3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     ec6:	8b 55 f0             	mov    -0x10(%ebp),%edx
     ec9:	89 c6                	mov    %eax,%esi
     ecb:	e8 fc ff ff ff       	call   ecc <fsm_ioctrl_arrival+0x6c>
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ed0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     ed5:	e8 fc ff ff ff       	call   ed6 <fsm_ioctrl_arrival+0x76>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     eda:	31 c9                	xor    %ecx,%ecx
     edc:	ba 02 00 00 00       	mov    $0x2,%edx
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ee1:	89 c7                	mov    %eax,%edi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     ee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
     ee6:	89 74 24 08          	mov    %esi,0x8(%esp)
     eea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     ef1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ef5:	a1 8c 02 00 00       	mov    0x28c,%eax
     efa:	89 44 24 04          	mov    %eax,0x4(%esp)
     efe:	b8 05 00 00 00       	mov    $0x5,%eax
     f03:	e8 28 f5 ff ff       	call   430 <__fsm_core_self_drive>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     f08:	89 fa                	mov    %edi,%edx
     f0a:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f0f:	e8 fc ff ff ff       	call   f10 <fsm_ioctrl_arrival+0xb0>
			spin_unlock_irqrestore(&fsm_core.lock, flags2);
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
     f14:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     f17:	89 f2                	mov    %esi,%edx
     f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f1c:	e8 fc ff ff ff       	call   f1d <fsm_ioctrl_arrival+0xbd>
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
			spin_unlock_irqrestore(&fsm_core.lock, flags2);		
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
     f21:	8b 43 10             	mov    0x10(%ebx),%eax
     f24:	b9 0c 00 00 00       	mov    $0xc,%ecx
     f29:	8d 55 e8             	lea    -0x18(%ebp),%edx
     f2c:	e8 fc ff ff ff       	call   f2d <fsm_ioctrl_arrival+0xcd>
     f31:	e9 54 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f36:	66 90                	xchg   %ax,%ax
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f38:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f3d:	e8 fc ff ff ff       	call   f3e <fsm_ioctrl_arrival+0xde>
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f42:	31 c9                	xor    %ecx,%ecx
     f44:	ba 02 00 00 00       	mov    $0x2,%edx
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f49:	89 c6                	mov    %eax,%esi
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f4b:	8b 03                	mov    (%ebx),%eax
     f4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     f54:	89 44 24 0c          	mov    %eax,0xc(%esp)
     f58:	8b 43 08             	mov    0x8(%ebx),%eax
     f5b:	89 44 24 08          	mov    %eax,0x8(%esp)
     f5f:	a1 8c 02 00 00       	mov    0x28c,%eax
     f64:	89 44 24 04          	mov    %eax,0x4(%esp)
     f68:	b8 05 00 00 00       	mov    $0x5,%eax
     f6d:	e8 be f4 ff ff       	call   430 <__fsm_core_self_drive>
     f72:	89 f2                	mov    %esi,%edx
     f74:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f79:	e8 fc ff ff ff       	call   f7a <fsm_ioctrl_arrival+0x11a>
     f7e:	e9 07 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f83:	90                   	nop
     f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f88:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f8d:	e8 fc ff ff ff       	call   f8e <fsm_ioctrl_arrival+0x12e>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f92:	31 c9                	xor    %ecx,%ecx
     f94:	ba 02 00 00 00       	mov    $0x2,%edx
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f99:	89 c6                	mov    %eax,%esi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     f9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     fa5:	00 
     fa6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     fad:	89 44 24 0c          	mov    %eax,0xc(%esp)
     fb1:	a1 8c 02 00 00       	mov    0x28c,%eax
     fb6:	89 44 24 04          	mov    %eax,0x4(%esp)
     fba:	b8 05 00 00 00       	mov    $0x5,%eax
     fbf:	e8 6c f4 ff ff       	call   430 <__fsm_core_self_drive>
     fc4:	89 f2                	mov    %esi,%edx
     fc6:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     fcb:	e8 fc ff ff ff       	call   fcc <fsm_ioctrl_arrival+0x16c>
     fd0:	e9 4c ff ff ff       	jmp    f21 <fsm_ioctrl_arrival+0xc1>
     fd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000fe0 <fsm_get_curtime>:



/* Time get */
u32 fsm_get_curtime()
{
     fe0:	55                   	push   %ebp
     fe1:	89 e5                	mov    %esp,%ebp
     fe3:	e8 fc ff ff ff       	call   fe4 <fsm_get_curtime+0x4>
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
     fe8:	e8 fc ff ff ff       	call   fe9 <fsm_get_curtime+0x9>
	cur_time = ktime_to_timeval(ktime);
     fed:	e8 fc ff ff ff       	call   fee <fsm_get_curtime+0xe>
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
	ctm = ctm/10;
     ff2:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
	return ctm;
}
     ff7:	5d                   	pop    %ebp
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
	cur_time = ktime_to_timeval(ktime);
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
     ff8:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
     ffe:	01 c2                	add    %eax,%edx
	ctm = ctm/10;
    1000:	89 d0                	mov    %edx,%eax
    1002:	f7 e1                	mul    %ecx
    1004:	c1 ea 03             	shr    $0x3,%edx
	return ctm;
}
    1007:	89 d0                	mov    %edx,%eax
    1009:	c3                   	ret    
    100a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00001010 <fsm_get_random_bytes>:


/* Random bytes get*/
void fsm_get_random_bytes(void *buf, int nbytes)
{
    1010:	55                   	push   %ebp
    1011:	89 e5                	mov    %esp,%ebp
    1013:	e8 fc ff ff ff       	call   1014 <fsm_get_random_bytes+0x4>
	GET_RANDOM_BYTES(buf, nbytes);
    1018:	e8 fc ff ff ff       	call   1019 <fsm_get_random_bytes+0x9>
}
    101d:	5d                   	pop    %ebp
    101e:	c3                   	ret    
    101f:	90                   	nop

00001020 <fsm_core_create>:


/* FSM core operations */

void fsm_core_create(void* dev)
{
    1020:	55                   	push   %ebp
    1021:	89 e5                	mov    %esp,%ebp
    1023:	e8 fc ff ff ff       	call   1024 <fsm_core_create+0x4>
	int i;
	fsm_core.current_fsm = -1;
    1028:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
    102f:	ff ff ff 
	fsm_core.current_state_ptr = NULL;
    1032:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
    1039:	00 00 00 
	fsm_core.state = CORE_CLOSED;
    103c:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    1043:	00 00 00 
	fsm_core.pkptr = 0;
    1046:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
    104d:	00 00 00 
	fsm_core.evtype = 0;
    1050:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
    1057:	00 00 00 
	fsm_core.code = 0;
	fsm_core.src = 0;
	fsm_core.dev = dev;
    105a:	a3 a8 02 00 00       	mov    %eax,0x2a8
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
    105f:	b8 44 00 00 00       	mov    $0x44,%eax
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
	fsm_core.state = CORE_CLOSED;
	fsm_core.pkptr = 0;
	fsm_core.evtype = 0;
	fsm_core.code = 0;
    1064:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
    106b:	00 00 00 
	fsm_core.src = 0;
    106e:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
    1075:	00 00 00 
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
    1078:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
    107f:	00 00 00 
	fsm_core.fsm_drive = NULL;
    1082:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
    1089:	00 00 00 
	MAIN_PORT = -1;
    108c:	c7 05 8c 02 00 00 ff 	movl   $0xffffffff,0x28c
    1093:	ff ff ff 
    1096:	66 90                	xchg   %ax,%ax
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    1098:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    109e:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    10a4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    10ab:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    10b2:	83 c0 10             	add    $0x10,%eax
	fsm_core.src = 0;
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
	for(i = 0; i < MAX_INTF; i++)
    10b5:	3d 44 02 00 00       	cmp    $0x244,%eax
    10ba:	75 dc                	jne    1098 <fsm_core_create+0x78>
		FSM[i] = NULL;
	}
	fsm_core.buffer = NULL;
	fsm_core.ioctrl_cmd = 0;
	spin_lock_init(&fsm_core.lock);
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    10bc:	b8 10 00 00 00       	mov    $0x10,%eax
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	for(i = 0; i < MAX_FSM; ++i)
	{
		FSM[i] = NULL;
    10c1:	c7 05 90 02 00 00 00 	movl   $0x0,0x290
    10c8:	00 00 00 
    10cb:	c7 05 94 02 00 00 00 	movl   $0x0,0x294
    10d2:	00 00 00 
    10d5:	c7 05 98 02 00 00 00 	movl   $0x0,0x298
    10dc:	00 00 00 
    10df:	c7 05 9c 02 00 00 00 	movl   $0x0,0x29c
    10e6:	00 00 00 
    10e9:	c7 05 a0 02 00 00 00 	movl   $0x0,0x2a0
    10f0:	00 00 00 
    10f3:	c7 05 a4 02 00 00 00 	movl   $0x0,0x2a4
    10fa:	00 00 00 
	}
	fsm_core.buffer = NULL;
    10fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
    1104:	00 00 00 
	fsm_core.ioctrl_cmd = 0;
    1107:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
    110e:	00 00 00 
	spin_lock_init(&fsm_core.lock);
    1111:	66 c7 05 b4 02 00 00 	movw   $0x0,0x2b4
    1118:	00 00 
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    111a:	e8 fc ff ff ff       	call   111b <fsm_core_create+0xfb>
    111f:	a3 b8 02 00 00       	mov    %eax,0x2b8
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    1124:	b8 10 00 00 00       	mov    $0x10,%eax
    1129:	e8 fc ff ff ff       	call   112a <fsm_core_create+0x10a>
    112e:	a3 bc 02 00 00       	mov    %eax,0x2bc
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1133:	b8 14 00 00 00       	mov    $0x14,%eax
    1138:	e8 fc ff ff ff       	call   1139 <fsm_core_create+0x119>
    113d:	a3 c0 02 00 00       	mov    %eax,0x2c0
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1142:	b8 14 00 00 00       	mov    $0x14,%eax
    1147:	e8 fc ff ff ff       	call   1148 <fsm_core_create+0x128>
    114c:	a3 c4 02 00 00       	mov    %eax,0x2c4
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1151:	b8 14 00 00 00       	mov    $0x14,%eax
    1156:	e8 fc ff ff ff       	call   1157 <fsm_core_create+0x137>
    115b:	a3 c8 02 00 00       	mov    %eax,0x2c8
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1160:	b8 14 00 00 00       	mov    $0x14,%eax
    1165:	e8 fc ff ff ff       	call   1166 <fsm_core_create+0x146>
	return; 
}
    116a:	5d                   	pop    %ebp
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    116b:	a3 cc 02 00 00       	mov    %eax,0x2cc
	return; 
}
    1170:	c3                   	ret    
    1171:	eb 0d                	jmp    1180 <fsm_core_intf_set>
    1173:	90                   	nop
    1174:	90                   	nop
    1175:	90                   	nop
    1176:	90                   	nop
    1177:	90                   	nop
    1178:	90                   	nop
    1179:	90                   	nop
    117a:	90                   	nop
    117b:	90                   	nop
    117c:	90                   	nop
    117d:	90                   	nop
    117e:	90                   	nop
    117f:	90                   	nop

00001180 <fsm_core_intf_set>:
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    1180:	55                   	push   %ebp
    1181:	89 e5                	mov    %esp,%ebp
    1183:	83 ec 10             	sub    $0x10,%esp
    1186:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1189:	89 75 f8             	mov    %esi,-0x8(%ebp)
    118c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    118f:	e8 fc ff ff ff       	call   1190 <fsm_core_intf_set+0x10>
    1194:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV *dev = NULL;
	switch(type)
    1197:	83 fa 01             	cmp    $0x1,%edx
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    119a:	89 c3                	mov    %eax,%ebx
    119c:	89 ce                	mov    %ecx,%esi
	NETDEV *dev = NULL;
	switch(type)
    119e:	0f 84 bc 00 00 00    	je     1260 <fsm_core_intf_set+0xe0>
    11a4:	72 3a                	jb     11e0 <fsm_core_intf_set+0x60>
    11a6:	83 fa 02             	cmp    $0x2,%edx
    11a9:	74 55                	je     1200 <fsm_core_intf_set+0x80>
		INTF[index].proto = htons(proto);
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_xmit;
		break;
	}
	if(proto == 0 && dev_name == 0)
    11ab:	85 ff                	test   %edi,%edi
    11ad:	8d 76 00             	lea    0x0(%esi),%esi
    11b0:	75 1c                	jne    11ce <fsm_core_intf_set+0x4e>
    11b2:	66 85 f6             	test   %si,%si
    11b5:	75 17                	jne    11ce <fsm_core_intf_set+0x4e>
		{
		INTF[index].valid = DEV_INTF_NULL;
    11b7:	c1 e3 04             	shl    $0x4,%ebx
    11ba:	c7 83 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
    11c1:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11c4:	c7 83 50 00 00 00 20 	movl   $0x120,0x50(%ebx)
    11cb:	01 00 00 
		}
	return;
}
    11ce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    11d1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    11d4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    11d7:	89 ec                	mov    %ebp,%esp
    11d9:	5d                   	pop    %ebp
    11da:	c3                   	ret    
    11db:	90                   	nop
    11dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	NETDEV *dev = NULL;
	switch(type)
	{
	case DEV_INTF_NULL:
		INTF[index].valid = DEV_INTF_NULL;
    11e0:	c1 e0 04             	shl    $0x4,%eax
    11e3:	c7 80 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    11ea:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11ed:	c7 80 50 00 00 00 20 	movl   $0x120,0x50(%eax)
    11f4:	01 00 00 
		break;
    11f7:	eb b2                	jmp    11ab <fsm_core_intf_set+0x2b>
    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	case DEV_INTF_IND:
		if(dev_name)
    1200:	85 ff                	test   %edi,%edi
    1202:	0f 84 b8 00 00 00    	je     12c0 <fsm_core_intf_set+0x140>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1208:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].valid = DEV_INTF_NULL;
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    120d:	89 fa                	mov    %edi,%edx
    120f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1215:	e8 fc ff ff ff       	call   1216 <fsm_core_intf_set+0x96>
		INTF[index].valid = DEV_INTF_IND;
    121a:	8d 53 02             	lea    0x2(%ebx),%edx
    121d:	89 d1                	mov    %edx,%ecx
    121f:	c1 e1 04             	shl    $0x4,%ecx
    1222:	c7 81 24 00 00 00 02 	movl   $0x2,0x24(%ecx)
    1229:	00 00 00 
		INTF[index].proto = htons(proto);
    122c:	0f b7 ce             	movzwl %si,%ecx
    122f:	c1 e1 08             	shl    $0x8,%ecx
    1232:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1235:	89 f1                	mov    %esi,%ecx
    1237:	66 c1 e9 08          	shr    $0x8,%cx
    123b:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    123f:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    1242:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    1248:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_netrx;
    124f:	c7 82 30 00 00 00 30 	movl   $0x230,0x30(%edx)
    1256:	02 00 00 
		break;
    1259:	e9 4d ff ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    125e:	66 90                	xchg   %ax,%ax
	case DEV_INTF_REQ:
		if(dev_name)
    1260:	85 ff                	test   %edi,%edi
    1262:	74 7c                	je     12e0 <fsm_core_intf_set+0x160>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1264:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    1269:	89 fa                	mov    %edi,%edx
    126b:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1271:	e8 fc ff ff ff       	call   1272 <fsm_core_intf_set+0xf2>
		INTF[index].valid = DEV_INTF_REQ;
    1276:	8d 53 02             	lea    0x2(%ebx),%edx
    1279:	89 d1                	mov    %edx,%ecx
    127b:	c1 e1 04             	shl    $0x4,%ecx
    127e:	c7 81 24 00 00 00 01 	movl   $0x1,0x24(%ecx)
    1285:	00 00 00 
		INTF[index].proto = htons(proto);
    1288:	0f b7 ce             	movzwl %si,%ecx
    128b:	c1 e1 08             	shl    $0x8,%ecx
    128e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1291:	89 f1                	mov    %esi,%ecx
    1293:	66 c1 e9 08          	shr    $0x8,%cx
    1297:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    129b:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    129e:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    12a4:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_xmit;
    12ab:	c7 82 30 00 00 00 d0 	movl   $0x1d0,0x30(%edx)
    12b2:	01 00 00 
		break;
    12b5:	e9 f1 fe ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    12ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12c3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c6:	89 d0                	mov    %edx,%eax
    12c8:	c1 e0 04             	shl    $0x4,%eax
    12cb:	c7 80 24 00 00 00 02 	movl   $0x2,0x24(%eax)
    12d2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12d5:	31 c0                	xor    %eax,%eax
    12d7:	e9 53 ff ff ff       	jmp    122f <fsm_core_intf_set+0xaf>
    12dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12e3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e6:	89 d0                	mov    %edx,%eax
    12e8:	c1 e0 04             	shl    $0x4,%eax
    12eb:	c7 80 24 00 00 00 01 	movl   $0x1,0x24(%eax)
    12f2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12f5:	31 c0                	xor    %eax,%eax
    12f7:	eb 92                	jmp    128b <fsm_core_intf_set+0x10b>
    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001300 <fsm_core_open>:
	return;
}


int fsm_core_open()
{
    1300:	55                   	push   %ebp
    1301:	89 e5                	mov    %esp,%ebp
    1303:	53                   	push   %ebx
    1304:	83 ec 10             	sub    $0x10,%esp
    1307:	e8 fc ff ff ff       	call   1308 <fsm_core_open+0x8>
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
    130c:	a1 28 00 00 00       	mov    0x28,%eax
    1311:	85 c0                	test   %eax,%eax
    1313:	0f 85 54 01 00 00    	jne    146d <fsm_core_open+0x16d>
	{
	fsm_printf("core is opening.\n");
    1319:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    1320:	e8 fc ff ff ff       	call   1321 <fsm_core_open+0x21>
	spin_lock_irqsave(&fsm_core.lock, flags);
    1325:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    132a:	e8 fc ff ff ff       	call   132b <fsm_core_open+0x2b>
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    132f:	31 c9                	xor    %ecx,%ecx
    1331:	ba 50 00 00 00       	mov    $0x50,%edx
{
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
	{
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
    1336:	89 c3                	mov    %eax,%ebx
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
    1338:	a1 b8 02 00 00       	mov    0x2b8,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    133d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    1343:	89 00                	mov    %eax,(%eax)
    1345:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    1348:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	skb_queue_head_init(fsm_core.rx_queue);
    134f:	a1 bc 02 00 00       	mov    0x2bc,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    1354:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    135a:	89 00                	mov    %eax,(%eax)
    135c:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    135f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    1366:	a1 c0 02 00 00       	mov    0x2c0,%eax
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
    136b:	66 c7 05 d0 02 00 00 	movw   $0x0,0x2d0
    1372:	00 00 
	spin_lock_init(&fsm_core.rx_queue_lock);
    1374:	66 c7 05 d2 02 00 00 	movw   $0x0,0x2d2
    137b:	00 00 
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    137d:	e8 fc ff ff ff       	call   137e <fsm_core_open+0x7e>
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
    1382:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1387:	31 c9                	xor    %ecx,%ecx
    1389:	ba 00 00 00 00       	mov    $0x0,%edx
    138e:	e8 fc ff ff ff       	call   138f <fsm_core_open+0x8f>
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    1393:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1398:	31 c9                	xor    %ecx,%ecx
    139a:	ba a0 00 00 00       	mov    $0xa0,%edx
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
    139f:	66 c7 05 e4 02 00 00 	movw   $0x0,0x2e4
    13a6:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13a8:	c7 05 d4 02 00 00 d4 	movl   $0x2d4,0x2d4
    13af:	02 00 00 
	list->prev = list;
    13b2:	c7 05 d8 02 00 00 d4 	movl   $0x2d4,0x2d8
    13b9:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    13bc:	e8 fc ff ff ff       	call   13bd <fsm_core_open+0xbd>
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13c1:	a1 cc 02 00 00       	mov    0x2cc,%eax
    13c6:	31 c9                	xor    %ecx,%ecx
    13c8:	ba 10 09 00 00       	mov    $0x910,%edx
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
    13cd:	66 c7 05 e6 02 00 00 	movw   $0x0,0x2e6
    13d4:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13d6:	c7 05 dc 02 00 00 dc 	movl   $0x2dc,0x2dc
    13dd:	02 00 00 
	list->prev = list;
    13e0:	c7 05 e0 02 00 00 dc 	movl   $0x2dc,0x2e0
    13e7:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13ea:	e8 fc ff ff ff       	call   13eb <fsm_core_open+0xeb>
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	pB->evQ = 0;
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    13ef:	31 c9                	xor    %ecx,%ecx
    13f1:	ba 01 00 00 00       	mov    $0x1,%edx
    13f6:	b8 48 02 00 00       	mov    $0x248,%eax
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
    13fb:	66 c7 05 e8 02 00 00 	movw   $0x0,0x2e8
    1402:	00 00 

static void __fsm_tm_init()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    1404:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    140b:	00 00 00 
	pB->evQ = 0;
    140e:	c7 05 88 02 00 00 00 	movl   $0x0,0x288
    1415:	00 00 00 
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    1418:	e8 fc ff ff ff       	call   1419 <fsm_core_open+0x119>
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    141d:	a1 8c 02 00 00       	mov    0x28c,%eax
    1422:	31 c9                	xor    %ecx,%ecx
    1424:	31 d2                	xor    %edx,%edx
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
    1426:	c7 05 28 00 00 00 01 	movl   $0x1,0x28
    142d:	00 00 00 
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1430:	89 44 24 04          	mov    %eax,0x4(%esp)
    1434:	b8 05 00 00 00       	mov    $0x5,%eax
    1439:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1440:	00 
    1441:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1448:	00 
    1449:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1450:	e8 db ef ff ff       	call   430 <__fsm_core_self_drive>
    1455:	89 da                	mov    %ebx,%edx
    1457:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    145c:	e8 fc ff ff ff       	call   145d <fsm_core_open+0x15d>
	spin_unlock_irqrestore(&fsm_core.lock, flags);
	fsm_printf("core has opened.\n");
    1461:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
    1468:	e8 fc ff ff ff       	call   1469 <fsm_core_open+0x169>
	}
	return FSM_EXEC_SUCC;
}
    146d:	83 c4 10             	add    $0x10,%esp
    1470:	31 c0                	xor    %eax,%eax
    1472:	5b                   	pop    %ebx
    1473:	5d                   	pop    %ebp
    1474:	c3                   	ret    
    1475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001480 <fsm_core_close>:

int fsm_core_close()
{
    1480:	55                   	push   %ebp
    1481:	89 e5                	mov    %esp,%ebp
    1483:	57                   	push   %edi
    1484:	56                   	push   %esi
    1485:	53                   	push   %ebx
    1486:	83 ec 10             	sub    $0x10,%esp
    1489:	e8 fc ff ff ff       	call   148a <fsm_core_close+0xa>
	struct evioctl *ev_ptr, *tmp_ptr;
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
    148e:	a1 28 00 00 00       	mov    0x28,%eax
    1493:	85 c0                	test   %eax,%eax
    1495:	75 11                	jne    14a8 <fsm_core_close+0x28>
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    1497:	83 c4 10             	add    $0x10,%esp
    149a:	31 c0                	xor    %eax,%eax
    149c:	5b                   	pop    %ebx
    149d:	5e                   	pop    %esi
    149e:	5f                   	pop    %edi
    149f:	5d                   	pop    %ebp
    14a0:	c3                   	ret    
    14a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
		return FSM_EXEC_SUCC;
	spin_lock_irqsave(&fsm_core.lock, flags2);
    14a8:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    14ad:	e8 fc ff ff ff       	call   14ae <fsm_core_close+0x2e>
    14b2:	89 c7                	mov    %eax,%edi
	fsm_printf("core is closing.\n");
    14b4:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
    14bb:	e8 fc ff ff ff       	call   14bc <fsm_core_close+0x3c>
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    14c0:	a1 8c 02 00 00       	mov    0x28c,%eax
    14c5:	31 c9                	xor    %ecx,%ecx
    14c7:	ba 01 00 00 00       	mov    $0x1,%edx
    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    14d0:	b8 05 00 00 00       	mov    $0x5,%eax
    14d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    14dc:	00 
    14dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    14e4:	00 
    14e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    14ec:	e8 3f ef ff ff       	call   430 <__fsm_core_self_drive>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
    14f1:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    14f6:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    14fd:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
    1500:	e8 fc ff ff ff       	call   1501 <fsm_core_close+0x81>
{
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
    1505:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    150a:	e8 fc ff ff ff       	call   150b <fsm_core_close+0x8b>
    150f:	89 c3                	mov    %eax,%ebx
	while(pB->evQ)
    1511:	a1 88 02 00 00       	mov    0x288,%eax
    1516:	85 c0                	test   %eax,%eax
    1518:	74 1c                	je     1536 <fsm_core_close+0xb6>
    151a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		pE = pB->evQ;
		pB->evQ = pE->pNext;
    1520:	8b 10                	mov    (%eax),%edx
    1522:	89 15 88 02 00 00    	mov    %edx,0x288
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1528:	e8 fc ff ff ff       	call   1529 <fsm_core_close+0xa9>
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	while(pB->evQ)
    152d:	a1 88 02 00 00       	mov    0x288,%eax
    1532:	85 c0                	test   %eax,%eax
    1534:	75 ea                	jne    1520 <fsm_core_close+0xa0>
    1536:	89 da                	mov    %ebx,%edx
    1538:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    153d:	e8 fc ff ff ff       	call   153e <fsm_core_close+0xbe>
	fsm_printf("core is closing.\n");
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
	__fsm_tm_stop();
	__fsm_tm_flush();
	//Cancel tasklets
	tasklet_kill(fsm_core.tx_tsklt);
    1542:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1547:	e8 fc ff ff ff       	call   1548 <fsm_core_close+0xc8>
	tasklet_kill(fsm_core.rx_tsklt);
    154c:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1551:	e8 fc ff ff ff       	call   1552 <fsm_core_close+0xd2>
	tasklet_kill(fsm_core.do_ioctl_tsklt);
    1556:	a1 c8 02 00 00       	mov    0x2c8,%eax
    155b:	e8 fc ff ff ff       	call   155c <fsm_core_close+0xdc>
	tasklet_kill(fsm_core.exp_ev_tsklt);	
    1560:	a1 cc 02 00 00       	mov    0x2cc,%eax
    1565:	e8 fc ff ff ff       	call   1566 <fsm_core_close+0xe6>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    156a:	a1 b8 02 00 00       	mov    0x2b8,%eax
    156f:	3b 00                	cmp    (%eax),%eax
    1571:	74 2f                	je     15a2 <fsm_core_close+0x122>
    1573:	90                   	nop
    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
    1578:	e8 fc ff ff ff       	call   1579 <fsm_core_close+0xf9>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    157d:	e8 fc ff ff ff       	call   157e <fsm_core_close+0xfe>
	tasklet_kill(fsm_core.tx_tsklt);
	tasklet_kill(fsm_core.rx_tsklt);
	tasklet_kill(fsm_core.do_ioctl_tsklt);
	tasklet_kill(fsm_core.exp_ev_tsklt);	
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    1582:	a1 b8 02 00 00       	mov    0x2b8,%eax
    1587:	3b 00                	cmp    (%eax),%eax
    1589:	75 ed                	jne    1578 <fsm_core_close+0xf8>
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    158b:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1590:	3b 00                	cmp    (%eax),%eax
    1592:	74 17                	je     15ab <fsm_core_close+0x12b>
    1594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
    1598:	e8 fc ff ff ff       	call   1599 <fsm_core_close+0x119>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    159d:	e8 fc ff ff ff       	call   159e <fsm_core_close+0x11e>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    15a2:	a1 bc 02 00 00       	mov    0x2bc,%eax
    15a7:	3b 00                	cmp    (%eax),%eax
    15a9:	75 ed                	jne    1598 <fsm_core_close+0x118>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    15ab:	8b 1d d4 02 00 00    	mov    0x2d4,%ebx
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
	}
	if(!list_empty(&fsm_core.do_ioctl_list))
    15b1:	81 fb d4 02 00 00    	cmp    $0x2d4,%ebx
    15b7:	74 6b                	je     1624 <fsm_core_close+0x1a4>
	{
		list_for_each_entry_safe(ev_ptr, tmp_ptr, &fsm_core.do_ioctl_list, list_node)
    15b9:	8b 33                	mov    (%ebx),%esi
    15bb:	83 eb 10             	sub    $0x10,%ebx
    15be:	83 ee 10             	sub    $0x10,%esi
    15c1:	eb 17                	jmp    15da <fsm_core_close+0x15a>
    15c3:	90                   	nop
    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    15c8:	8b 46 10             	mov    0x10(%esi),%eax
    15cb:	83 e8 10             	sub    $0x10,%eax
    15ce:	81 fe c4 02 00 00    	cmp    $0x2c4,%esi
    15d4:	74 4e                	je     1624 <fsm_core_close+0x1a4>
    15d6:	89 f3                	mov    %esi,%ebx
    15d8:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
    15da:	b8 e4 02 00 00       	mov    $0x2e4,%eax
    15df:	e8 fc ff ff ff       	call   15e0 <fsm_core_close+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    15e4:	8b 4b 14             	mov    0x14(%ebx),%ecx
    15e7:	89 c2                	mov    %eax,%edx
    15e9:	8b 43 10             	mov    0x10(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    15ec:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    15ef:	89 01                	mov    %eax,(%ecx)
    15f1:	b8 e4 02 00 00       	mov    $0x2e4,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    15f6:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    15fd:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    1604:	e8 fc ff ff ff       	call   1605 <fsm_core_close+0x185>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1609:	8b 43 0c             	mov    0xc(%ebx),%eax
    160c:	e8 fc ff ff ff       	call   160d <fsm_core_close+0x18d>
    1611:	89 d8                	mov    %ebx,%eax
    1613:	e8 fc ff ff ff       	call   1614 <fsm_core_close+0x194>
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
			list_del(&ev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
			fsm_mem_free(ev_ptr->ifr.buffer);
			fsm_mem_free(ev_ptr);
			if(list_empty(&fsm_core.do_ioctl_list))
    1618:	81 3d d4 02 00 00 d4 	cmpl   $0x2d4,0x2d4
    161f:	02 00 00 
    1622:	75 a4                	jne    15c8 <fsm_core_close+0x148>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1624:	8b 1d dc 02 00 00    	mov    0x2dc,%ebx
				break;
		}
	}
	if(!list_empty(&fsm_core.exp_ev_list))
    162a:	81 fb dc 02 00 00    	cmp    $0x2dc,%ebx
    1630:	74 69                	je     169b <fsm_core_close+0x21b>
	{
		list_for_each_entry_safe(tmev_ptr, tmev_tmp_ptr, &fsm_core.exp_ev_list, list_node)
    1632:	8b 33                	mov    (%ebx),%esi
    1634:	83 eb 04             	sub    $0x4,%ebx
    1637:	83 ee 04             	sub    $0x4,%esi
    163a:	eb 16                	jmp    1652 <fsm_core_close+0x1d2>
    163c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1640:	8b 46 04             	mov    0x4(%esi),%eax
    1643:	83 e8 04             	sub    $0x4,%eax
    1646:	81 fe d8 02 00 00    	cmp    $0x2d8,%esi
    164c:	74 4d                	je     169b <fsm_core_close+0x21b>
    164e:	89 f3                	mov    %esi,%ebx
    1650:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
    1652:	b8 e6 02 00 00       	mov    $0x2e6,%eax
    1657:	e8 fc ff ff ff       	call   1658 <fsm_core_close+0x1d8>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    165c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    165f:	89 c2                	mov    %eax,%edx
    1661:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1664:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    1667:	89 01                	mov    %eax,(%ecx)
    1669:	b8 e6 02 00 00       	mov    $0x2e6,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    166e:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    1675:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    167c:	e8 fc ff ff ff       	call   167d <fsm_core_close+0x1fd>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1681:	8b 03                	mov    (%ebx),%eax
    1683:	e8 fc ff ff ff       	call   1684 <fsm_core_close+0x204>
    1688:	89 d8                	mov    %ebx,%eax
    168a:	e8 fc ff ff ff       	call   168b <fsm_core_close+0x20b>
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
			list_del(&tmev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
			fsm_mem_free(tmev_ptr->pE);
			fsm_mem_free(tmev_ptr);
			if(list_empty(&fsm_core.exp_ev_list))
    168f:	81 3d dc 02 00 00 dc 	cmpl   $0x2dc,0x2dc
    1696:	02 00 00 
    1699:	75 a5                	jne    1640 <fsm_core_close+0x1c0>
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
    169b:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    16a2:	00 00 00 
    16a5:	b8 4c 00 00 00       	mov    $0x4c,%eax
    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	for(i = 0; i < MAX_INTF; i++)
	{
		if(INTF[i].dev)
    16b0:	8b 10                	mov    (%eax),%edx
    16b2:	85 d2                	test   %edx,%edx
    16b4:	74 09                	je     16bf <fsm_core_close+0x23f>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    16b6:	8b 92 98 02 00 00    	mov    0x298(%edx),%edx
 *
 * Release reference to device to allow it to be freed.
 */
static inline void dev_put(struct net_device *dev)
{
	this_cpu_dec(*dev->pcpu_refcnt);
    16bc:	64 ff 0a             	decl   %fs:(%edx)
    16bf:	83 c0 10             	add    $0x10,%eax
			if(list_empty(&fsm_core.exp_ev_list))
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
	for(i = 0; i < MAX_INTF; i++)
    16c2:	3d 4c 02 00 00       	cmp    $0x24c,%eax
    16c7:	75 e7                	jne    16b0 <fsm_core_close+0x230>
    16c9:	b8 44 00 00 00       	mov    $0x44,%eax
    16ce:	66 90                	xchg   %ax,%ax
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    16d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    16d6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    16dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    16e3:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    16ea:	83 c0 10             	add    $0x10,%eax
		if(INTF[i].dev)
		{
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
    16ed:	3d 44 02 00 00       	cmp    $0x244,%eax
    16f2:	75 dc                	jne    16d0 <fsm_core_close+0x250>
		INTF[i].valid = 0;
		INTF[i].proto = 0;
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
    16f4:	c7 04 24 41 00 00 00 	movl   $0x41,(%esp)
    16fb:	e8 fc ff ff ff       	call   16fc <fsm_core_close+0x27c>
    1700:	89 fa                	mov    %edi,%edx
    1702:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1707:	e8 fc ff ff ff       	call   1708 <fsm_core_close+0x288>
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    170c:	31 c0                	xor    %eax,%eax
    170e:	83 c4 10             	add    $0x10,%esp
    1711:	5b                   	pop    %ebx
    1712:	5e                   	pop    %esi
    1713:	5f                   	pop    %edi
    1714:	5d                   	pop    %ebp
    1715:	c3                   	ret    
    1716:	8d 76 00             	lea    0x0(%esi),%esi
    1719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001720 <fsm_core_pkt_drive>:



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1720:	55                   	push   %ebp
    1721:	89 e5                	mov    %esp,%ebp
    1723:	83 ec 18             	sub    $0x18,%esp
    1726:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    1729:	89 75 fc             	mov    %esi,-0x4(%ebp)
    172c:	e8 fc ff ff ff       	call   172d <fsm_core_pkt_drive+0xd>
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1731:	83 fa 01             	cmp    $0x1,%edx
}



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1734:	89 c6                	mov    %eax,%esi
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1736:	74 68                	je     17a0 <fsm_core_pkt_drive+0x80>
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock ,flags2);
	}
	if(type == RXTX_PKT_REQ)
    1738:	85 d2                	test   %edx,%edx
    173a:	74 0c                	je     1748 <fsm_core_pkt_drive+0x28>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    173c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    173f:	31 c0                	xor    %eax,%eax
    1741:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1744:	89 ec                	mov    %ebp,%esp
    1746:	5d                   	pop    %ebp
    1747:	c3                   	ret    
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1748:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    174d:	e8 fc ff ff ff       	call   174e <fsm_core_pkt_drive+0x2e>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1752:	89 f1                	mov    %esi,%ecx
    1754:	31 d2                	xor    %edx,%edx
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1756:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1758:	a1 8c 02 00 00       	mov    0x28c,%eax
    175d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1764:	00 
    1765:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    176c:	00 
    176d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1774:	89 44 24 04          	mov    %eax,0x4(%esp)
    1778:	b8 01 00 00 00       	mov    $0x1,%eax
    177d:	e8 ae ec ff ff       	call   430 <__fsm_core_self_drive>
    1782:	89 da                	mov    %ebx,%edx
    1784:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1789:	e8 fc ff ff ff       	call   178a <fsm_core_pkt_drive+0x6a>
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    178e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1791:	31 c0                	xor    %eax,%eax
    1793:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1796:	89 ec                	mov    %ebp,%esp
    1798:	5d                   	pop    %ebp
    1799:	c3                   	ret    
    179a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17a0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17a5:	e8 fc ff ff ff       	call   17a6 <fsm_core_pkt_drive+0x86>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17aa:	89 f1                	mov    %esi,%ecx
    17ac:	31 d2                	xor    %edx,%edx
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17ae:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17b0:	a1 8c 02 00 00       	mov    0x28c,%eax
    17b5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    17bc:	00 
    17bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    17c4:	00 
    17c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    17cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    17d0:	b8 02 00 00 00       	mov    $0x2,%eax
    17d5:	e8 56 ec ff ff       	call   430 <__fsm_core_self_drive>
    17da:	89 da                	mov    %ebx,%edx
    17dc:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17e1:	e8 fc ff ff ff       	call   17e2 <fsm_core_pkt_drive+0xc2>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    17e6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    17e9:	31 c0                	xor    %eax,%eax
    17eb:	8b 75 fc             	mov    -0x4(%ebp),%esi
    17ee:	89 ec                	mov    %ebp,%esp
    17f0:	5d                   	pop    %ebp
    17f1:	c3                   	ret    
    17f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    17f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001800 <fsm_create_register>:

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1800:	55                   	push   %ebp
    1801:	89 e5                	mov    %esp,%ebp
    1803:	83 ec 14             	sub    $0x14,%esp
    1806:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1809:	89 75 f8             	mov    %esi,-0x8(%ebp)
    180c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    180f:	e8 fc ff ff ff       	call   1810 <fsm_create_register+0x10>
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1814:	31 db                	xor    %ebx,%ebx
	return FSM_EXEC_SUCC;
}

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1816:	89 c7                	mov    %eax,%edi
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
    1818:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
    181f:	85 c0                	test   %eax,%eax
    1821:	74 1d                	je     1840 <fsm_create_register+0x40>

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1823:	83 c3 01             	add    $0x1,%ebx
    1826:	83 fb 06             	cmp    $0x6,%ebx
    1829:	75 ed                	jne    1818 <fsm_create_register+0x18>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
			FSM[i]->_fsm_current_block = 0;
			return i;
			}
		}
	return -1;
    182b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
    1830:	8b 75 f8             	mov    -0x8(%ebp),%esi
    1833:	89 d8                	mov    %ebx,%eax
    1835:	8b 7d fc             	mov    -0x4(%ebp),%edi
    1838:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    183b:	89 ec                	mov    %ebp,%esp
    183d:	5d                   	pop    %ebp
    183e:	c3                   	ret    
    183f:	90                   	nop
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1840:	b8 90 00 00 00       	mov    $0x90,%eax
    1845:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1848:	8d b3 9c 00 00 00    	lea    0x9c(%ebx),%esi
    184e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    1851:	e8 fc ff ff ff       	call   1852 <fsm_create_register+0x52>
			FSM[i]->fsm_main = fsm_main;
    1856:	8b 55 ec             	mov    -0x14(%ebp),%edx
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1859:	89 04 b5 20 00 00 00 	mov    %eax,0x20(,%esi,4)
			FSM[i]->fsm_main = fsm_main;
    1860:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			FSM[i]->id = i;
    1866:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
			strcpy(FSM[i]->name, name);
    186d:	89 fa                	mov    %edi,%edx
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
			FSM[i]->fsm_main = fsm_main;
			FSM[i]->id = i;
    186f:	89 98 80 00 00 00    	mov    %ebx,0x80(%eax)
			strcpy(FSM[i]->name, name);
    1875:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    187c:	e8 fc ff ff ff       	call   187d <fsm_create_register+0x7d>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
    1881:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1888:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    188b:	89 88 88 00 00 00    	mov    %ecx,0x88(%eax)
			FSM[i]->_fsm_current_block = 0;
    1891:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1898:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
    189f:	00 00 00 
			return i;
			}
		}
	return -1;
}
    18a2:	89 d8                	mov    %ebx,%eax
    18a4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    18a7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    18aa:	8b 7d fc             	mov    -0x4(%ebp),%edi
    18ad:	89 ec                	mov    %ebp,%esp
    18af:	5d                   	pop    %ebp
    18b0:	c3                   	ret    
    18b1:	eb 0d                	jmp    18c0 <fsm_unregister_destroy>
    18b3:	90                   	nop
    18b4:	90                   	nop
    18b5:	90                   	nop
    18b6:	90                   	nop
    18b7:	90                   	nop
    18b8:	90                   	nop
    18b9:	90                   	nop
    18ba:	90                   	nop
    18bb:	90                   	nop
    18bc:	90                   	nop
    18bd:	90                   	nop
    18be:	90                   	nop
    18bf:	90                   	nop

000018c0 <fsm_unregister_destroy>:

void fsm_unregister_destroy(int id)
{
    18c0:	55                   	push   %ebp
    18c1:	89 e5                	mov    %esp,%ebp
    18c3:	53                   	push   %ebx
    18c4:	e8 fc ff ff ff       	call   18c5 <fsm_unregister_destroy+0x5>
	if(FSM[id]!=NULL)
    18c9:	8d 98 9c 00 00 00    	lea    0x9c(%eax),%ebx
    18cf:	8b 04 9d 20 00 00 00 	mov    0x20(,%ebx,4),%eax
    18d6:	85 c0                	test   %eax,%eax
    18d8:	74 10                	je     18ea <fsm_unregister_destroy+0x2a>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    18da:	e8 fc ff ff ff       	call   18db <fsm_unregister_destroy+0x1b>
void fsm_unregister_destroy(int id)
{
	if(FSM[id]!=NULL)
	{
		fsm_mem_free(FSM[id]);
		FSM[id] = NULL;
    18df:	c7 04 9d 20 00 00 00 	movl   $0x0,0x20(,%ebx,4)
    18e6:	00 00 00 00 
	}
}
    18ea:	5b                   	pop    %ebx
    18eb:	5d                   	pop    %ebp
    18ec:	c3                   	ret    
    18ed:	8d 76 00             	lea    0x0(%esi),%esi

000018f0 <fsm_core_destroy>:
	return; 
}

		
void fsm_core_destroy()
{
    18f0:	55                   	push   %ebp
    18f1:	89 e5                	mov    %esp,%ebp
    18f3:	53                   	push   %ebx
    18f4:	e8 fc ff ff ff       	call   18f5 <fsm_core_destroy+0x5>
	int i;
	if(fsm_core.state != CORE_CLOSED)
    18f9:	a1 28 00 00 00       	mov    0x28,%eax
    18fe:	85 c0                	test   %eax,%eax
    1900:	75 56                	jne    1958 <fsm_core_destroy+0x68>
	return; 
}

		
void fsm_core_destroy()
{
    1902:	31 db                	xor    %ebx,%ebx
    1904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
	{
		fsm_unregister_destroy(i);
    1908:	89 d8                	mov    %ebx,%eax
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    190a:	83 c3 01             	add    $0x1,%ebx
	{
		fsm_unregister_destroy(i);
    190d:	e8 fc ff ff ff       	call   190e <fsm_core_destroy+0x1e>
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    1912:	83 fb 06             	cmp    $0x6,%ebx
    1915:	75 f1                	jne    1908 <fsm_core_destroy+0x18>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1917:	a1 b8 02 00 00       	mov    0x2b8,%eax
    191c:	e8 fc ff ff ff       	call   191d <fsm_core_destroy+0x2d>
    1921:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1926:	e8 fc ff ff ff       	call   1927 <fsm_core_destroy+0x37>
    192b:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1930:	e8 fc ff ff ff       	call   1931 <fsm_core_destroy+0x41>
    1935:	a1 c4 02 00 00       	mov    0x2c4,%eax
    193a:	e8 fc ff ff ff       	call   193b <fsm_core_destroy+0x4b>
    193f:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1944:	e8 fc ff ff ff       	call   1945 <fsm_core_destroy+0x55>
    1949:	a1 cc 02 00 00       	mov    0x2cc,%eax
    194e:	e8 fc ff ff ff       	call   194f <fsm_core_destroy+0x5f>
	fsm_mem_free(fsm_core.tx_tsklt);
	fsm_mem_free(fsm_core.rx_tsklt);
	fsm_mem_free(fsm_core.do_ioctl_tsklt);
	fsm_mem_free(fsm_core.exp_ev_tsklt);
	return;
}
    1953:	5b                   	pop    %ebx
    1954:	5d                   	pop    %ebp
    1955:	c3                   	ret    
    1956:	66 90                	xchg   %ax,%ax
		
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
    1958:	e8 fc ff ff ff       	call   1959 <fsm_core_destroy+0x69>
    195d:	8d 76 00             	lea    0x0(%esi),%esi
    1960:	eb a0                	jmp    1902 <fsm_core_destroy+0x12>
    1962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1969:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001970 <fsm_mainport_bind>:
		FSM[id] = NULL;
	}
}

void fsm_mainport_bind(int id)
{
    1970:	55                   	push   %ebp
    1971:	89 e5                	mov    %esp,%ebp
    1973:	e8 fc ff ff ff       	call   1974 <fsm_mainport_bind+0x4>
	fsm_core.main_port = id;
}
    1978:	5d                   	pop    %ebp
	}
}

void fsm_mainport_bind(int id)
{
	fsm_core.main_port = id;
    1979:	a3 8c 02 00 00       	mov    %eax,0x28c
}
    197e:	c3                   	ret    
    197f:	90                   	nop

00001980 <__fsm_dev_set_config>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_set_config(struct net_device *dev, struct ifmap *p_ifmap)
{
    1980:	55                   	push   %ebp
    1981:	89 e5                	mov    %esp,%ebp
    1983:	e8 fc ff ff ff       	call   1984 <__fsm_dev_set_config+0x4>
    	return 0;
}
    1988:	31 c0                	xor    %eax,%eax
    198a:	5d                   	pop    %ebp
    198b:	c3                   	ret    
    198c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001990 <__fsm_dev_get_stats>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    1990:	55                   	push   %ebp
    1991:	89 e5                	mov    %esp,%ebp
    1993:	e8 fc ff ff ff       	call   1994 <__fsm_dev_get_stats+0x4>
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
}
    1998:	5d                   	pop    %ebp
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
    1999:	05 c0 04 00 00       	add    $0x4c0,%eax
}
    199e:	c3                   	ret    
    199f:	90                   	nop

000019a0 <__fsm_dev_tx_timeout>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_tx_timeout(struct net_device *dev)
{  
    19a0:	55                   	push   %ebp
    19a1:	89 e5                	mov    %esp,%ebp
    19a3:	e8 fc ff ff ff       	call   19a4 <__fsm_dev_tx_timeout+0x4>
    return;   
}
    19a8:	5d                   	pop    %ebp
    19a9:	c3                   	ret    
    19aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000019b0 <__fsm_dev_ioctl>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	e8 fc ff ff ff       	call   19b4 <__fsm_dev_ioctl+0x4>
    19b8:	89 d0                	mov    %edx,%eax
    19ba:	89 ca                	mov    %ecx,%edx
	fsm_ioctrl_arrival(ifr,cmd);
    19bc:	e8 fc ff ff ff       	call   19bd <__fsm_dev_ioctl+0xd>
	return 0;
}
    19c1:	31 c0                	xor    %eax,%eax
    19c3:	5d                   	pop    %ebp
    19c4:	c3                   	ret    
    19c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    19c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019d0 <__fsm_dev_tx>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_tx(struct sk_buff *skb, struct net_device *dev)
{ 
    19d0:	55                   	push   %ebp
    19d1:	89 e5                	mov    %esp,%ebp
    19d3:	e8 fc ff ff ff       	call   19d4 <__fsm_dev_tx+0x4>
	fsm_core_pkt_drive(skb, RXTX_PKT_REQ);	
    19d8:	31 d2                	xor    %edx,%edx
    19da:	e8 fc ff ff ff       	call   19db <__fsm_dev_tx+0xb>
   	return 0;    
}	
    19df:	31 c0                	xor    %eax,%eax
    19e1:	5d                   	pop    %ebp
    19e2:	c3                   	ret    
    19e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    19e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019f0 <__fsm_dev_recv>:
 **-------------------------------------- ------system--------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_recv(struct sk_buff *skb ,struct net_device *dev1, struct packet_type *pktype, struct net_device *dev2)
{  
    19f0:	55                   	push   %ebp
    19f1:	89 e5                	mov    %esp,%ebp
    19f3:	e8 fc ff ff ff       	call   19f4 <__fsm_dev_recv+0x4>
    	fsm_core_pkt_drive(skb, RXTX_PKT_IND);
    19f8:	ba 01 00 00 00       	mov    $0x1,%edx
    19fd:	e8 fc ff ff ff       	call   19fe <__fsm_dev_recv+0xe>
    	return 0;            
}
    1a02:	31 c0                	xor    %eax,%eax
    1a04:	5d                   	pop    %ebp
    1a05:	c3                   	ret    
    1a06:	8d 76 00             	lea    0x0(%esi),%esi
    1a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001a10 <__fsm_dev_open>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	53                   	push   %ebx
    1a14:	83 ec 04             	sub    $0x4,%esp
    1a17:	e8 fc ff ff ff       	call   1a18 <__fsm_dev_open+0x8>
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a1c:	b9 f3 f4 00 00       	mov    $0xf4f3,%ecx
    1a21:	ba 02 00 00 00       	mov    $0x2,%edx
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a26:	89 c3                	mov    %eax,%ebx
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a28:	b8 05 00 00 00       	mov    $0x5,%eax
    1a2d:	c7 04 24 53 00 00 00 	movl   $0x53,(%esp)
    1a34:	e8 fc ff ff ff       	call   1a35 <__fsm_dev_open+0x25>
	fsm_core_intf_set(STRM_TO_IPADP, DEV_INTF_IND, DEV_PROTO_IPADP, "LTE_IPADP0");
    1a39:	b9 f0 f4 00 00       	mov    $0xf4f0,%ecx
    1a3e:	ba 02 00 00 00       	mov    $0x2,%edx
    1a43:	b8 07 00 00 00       	mov    $0x7,%eax
    1a48:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp)
    1a4f:	e8 fc ff ff ff       	call   1a50 <__fsm_dev_open+0x40>
	fsm_core_intf_set(STRM_TO_PDCP, DEV_INTF_IND, DEV_PROTO_PDCP, "LTE_PDCP0");
    1a54:	b9 f1 f4 00 00       	mov    $0xf4f1,%ecx
    1a59:	ba 02 00 00 00       	mov    $0x2,%edx
    1a5e:	b8 06 00 00 00       	mov    $0x6,%eax
    1a63:	c7 04 24 67 00 00 00 	movl   $0x67,(%esp)
    1a6a:	e8 fc ff ff ff       	call   1a6b <__fsm_dev_open+0x5b>
	//fsm_core_intf_set(STRM_TO_RLC, DEV_INTF_IND, DEV_PROTO_RLC, "LTE_RLC0");
	fsm_core_intf_set(STRM_TO_SRIO, DEV_INTF_REQ, DEV_PROTO_RLC_MAC, "LTE_SRIO0");
    1a6f:	b9 f8 f4 00 00       	mov    $0xf4f8,%ecx
    1a74:	ba 01 00 00 00       	mov    $0x1,%edx
    1a79:	b8 03 00 00 00       	mov    $0x3,%eax
    1a7e:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
    1a85:	e8 fc ff ff ff       	call   1a86 <__fsm_dev_open+0x76>
    	dev_add_pack(&pk_t); 
    1a8a:	b8 00 00 00 00       	mov    $0x0,%eax
    1a8f:	e8 fc ff ff ff       	call   1a90 <__fsm_dev_open+0x80>
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    1a94:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 */
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    1a9a:	f0 80 60 50 fe       	lock andb $0xfe,0x50(%eax)
	netif_start_queue(dev);   
    	fsm_core_open();	 
    1a9f:	e8 fc ff ff ff       	call   1aa0 <__fsm_dev_open+0x90>
    	return 0;    
}
    1aa4:	31 c0                	xor    %eax,%eax
    1aa6:	83 c4 04             	add    $0x4,%esp
    1aa9:	5b                   	pop    %ebx
    1aaa:	5d                   	pop    %ebp
    1aab:	c3                   	ret    
    1aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001ab0 <dev_init>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1ab0:	55                   	push   %ebp
    1ab1:	89 e5                	mov    %esp,%ebp
    1ab3:	53                   	push   %ebx
    1ab4:	83 ec 08             	sub    $0x8,%esp
    1ab7:	e8 fc ff ff ff       	call   1ab8 <dev_init+0x8>
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1abc:	85 c0                	test   %eax,%eax
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1abe:	89 c3                	mov    %eax,%ebx
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1ac0:	0f 84 af 00 00 00    	je     1b75 <dev_init+0xc5>
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ac6:	83 88 a4 00 00 00 04 	orl    $0x4,0xa4(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1acd:	b9 60 00 00 00       	mov    $0x60,%ecx
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ad2:	83 88 a8 00 00 00 00 	orl    $0x0,0xa8(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1ad9:	31 d2                	xor    %edx,%edx
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    	dev->tx_queue_len = 128;   	/* the queue length */   
    1adb:	c7 80 50 02 00 00 80 	movl   $0x80,0x250(%eax)
    1ae2:	00 00 00 
    	dev->mtu = MTU;		/* now we do not fragmentate the packet */
    1ae5:	c7 80 50 01 00 00 dc 	movl   $0x5dc,0x150(%eax)
    1aec:	05 00 00 
   	dev->header_ops = NULL;   	/* cancle eth_header function for not building ethnet mac header */ 
    1aef:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%eax)
    1af6:	00 00 00 
    	dev->addr_len = 0;
    1af9:	c6 80 7d 01 00 00 00 	movb   $0x0,0x17d(%eax)
    	dev->hard_header_len = 0;
    1b00:	66 c7 80 56 01 00 00 	movw   $0x0,0x156(%eax)
    1b07:	00 00 
	dev->netdev_ops = &fsm_netdev_ops;
    1b09:	c7 80 34 01 00 00 20 	movl   $0x20,0x134(%eax)
    1b10:	00 00 00 
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
    1b13:	c7 80 60 02 00 00 e8 	movl   $0x3e8,0x260(%eax)
    1b1a:	03 00 00 
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    1b1d:	c7 80 40 01 00 00 82 	movl   $0x1082,0x140(%eax)
    1b24:	10 00 00 
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
    1b27:	8d 80 c0 04 00 00    	lea    0x4c0(%eax),%eax
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1b2d:	e8 fc ff ff ff       	call   1b2e <dev_init+0x7e>
	fsm_core_create(dev);
    1b32:	89 d8                	mov    %ebx,%eax
    1b34:	e8 fc ff ff ff       	call   1b35 <dev_init+0x85>
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b39:	b8 ac 5a 00 00       	mov    $0x5aac,%eax
    1b3e:	e8 fc ff ff ff       	call   1b3f <dev_init+0x8f>
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b43:	b9 ac 5a 00 00       	mov    $0x5aac,%ecx
    1b48:	31 d2                	xor    %edx,%edx
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
	fsm_core_create(dev);
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b4a:	89 83 1c 05 00 00    	mov    %eax,0x51c(%ebx)
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b50:	e8 fc ff ff ff       	call   1b51 <dev_init+0xa1>
/*-----------------------------------FSM creation---------------------------*/
	fsm_id = fsm_create_register("lte_rlc_mac_fsm", rlc_mac_main, priv->sv_ptr);
    1b55:	8b 8b 1c 05 00 00    	mov    0x51c(%ebx),%ecx
    1b5b:	ba 00 00 00 00       	mov    $0x0,%edx
    1b60:	b8 7b 00 00 00       	mov    $0x7b,%eax
    1b65:	e8 fc ff ff ff       	call   1b66 <dev_init+0xb6>
	fsm_mainport_bind(fsm_id);
    1b6a:	e8 fc ff ff ff       	call   1b6b <dev_init+0xbb>
/*--------------------------------------------------------------------------*/
    return;
}
    1b6f:	83 c4 08             	add    $0x8,%esp
    1b72:	5b                   	pop    %ebx
    1b73:	5d                   	pop    %ebp
    1b74:	c3                   	ret    
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1b75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1b7c:	00 
    1b7d:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
    1b84:	e8 fc ff ff ff       	call   1b85 <dev_init+0xd5>
    1b89:	e8 fc ff ff ff       	call   1b8a <dev_init+0xda>
    1b8e:	eb df                	jmp    1b6f <dev_init+0xbf>

00001b90 <__fsm_dev_stop>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_stop(struct net_device *dev)
{  
    1b90:	55                   	push   %ebp
    1b91:	89 e5                	mov    %esp,%ebp
    1b93:	53                   	push   %ebx
    1b94:	83 ec 04             	sub    $0x4,%esp
    1b97:	e8 fc ff ff ff       	call   1b98 <__fsm_dev_stop+0x8>
    1b9c:	89 c3                	mov    %eax,%ebx
         
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    1b9e:	e8 fc ff ff ff       	call   1b9f <__fsm_dev_stop+0xf>
    	dev_remove_pack(&pk_t);
    1ba3:	b8 00 00 00 00       	mov    $0x0,%eax
    1ba8:	e8 fc ff ff ff       	call   1ba9 <__fsm_dev_stop+0x19>
{  
    return;   
}

module_init(__fsm_dev_create);
module_exit(__fsm_dev_destroy);
    1bad:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
	}
}

static inline void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
	if (WARN_ON(!dev_queue)) {
    1bb3:	85 c0                	test   %eax,%eax
    1bb5:	74 0d                	je     1bc4 <__fsm_dev_stop+0x34>
 */
static __always_inline void
set_bit(unsigned int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1bb7:	f0 80 48 50 01       	lock orb $0x1,0x50(%eax)
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    	dev_remove_pack(&pk_t);
    	netif_stop_queue(dev);
     	return 0;    
}
    1bbc:	83 c4 04             	add    $0x4,%esp
    1bbf:	31 c0                	xor    %eax,%eax
    1bc1:	5b                   	pop    %ebx
    1bc2:	5d                   	pop    %ebp
    1bc3:	c3                   	ret    
    1bc4:	ba 50 07 00 00       	mov    $0x750,%edx
    1bc9:	b8 8b 00 00 00       	mov    $0x8b,%eax
    1bce:	e8 fc ff ff ff       	call   1bcf <__fsm_dev_stop+0x3f>
		pr_info("netif_stop_queue() cannot be called before register_netdev()\n");
    1bd3:	c7 04 24 8c 00 00 00 	movl   $0x8c,(%esp)
    1bda:	e8 fc ff ff ff       	call   1bdb <__fsm_dev_stop+0x4b>
    1bdf:	eb db                	jmp    1bbc <__fsm_dev_stop+0x2c>
    1be1:	eb 0d                	jmp    1bf0 <__fsm_dev_create>
    1be3:	90                   	nop
    1be4:	90                   	nop
    1be5:	90                   	nop
    1be6:	90                   	nop
    1be7:	90                   	nop
    1be8:	90                   	nop
    1be9:	90                   	nop
    1bea:	90                   	nop
    1beb:	90                   	nop
    1bec:	90                   	nop
    1bed:	90                   	nop
    1bee:	90                   	nop
    1bef:	90                   	nop

00001bf0 <__fsm_dev_create>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_create(void)
{   
    1bf0:	55                   	push   %ebp
    1bf1:	89 e5                	mov    %esp,%ebp
    1bf3:	53                   	push   %ebx
    1bf4:	83 ec 08             	sub    $0x8,%esp
    1bf7:	e8 fc ff ff ff       	call   1bf8 <__fsm_dev_create+0x8>
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1bfc:	b9 00 00 00 00       	mov    $0x0,%ecx
    1c01:	ba a5 00 00 00       	mov    $0xa5,%edx
    1c06:	b8 60 00 00 00       	mov    $0x60,%eax
    1c0b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1c12:	00 
    1c13:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1c1a:	e8 fc ff ff ff       	call   1c1b <__fsm_dev_create+0x2b>
    if (dev == NULL)   /* allocation error */
    1c1f:	85 c0                	test   %eax,%eax
{   
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1c21:	89 c3                	mov    %eax,%ebx
    if (dev == NULL)   /* allocation error */
    1c23:	74 41                	je     1c66 <__fsm_dev_create+0x76>
		{
		return -2;
		}
	memcpy(dev->dev_addr, &dev_addr, 6);       
    1c25:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
    1c2b:	c6 00 00             	movb   $0x0,(%eax)
    1c2e:	c6 40 01 11          	movb   $0x11,0x1(%eax)
    1c32:	c6 40 02 1a          	movb   $0x1a,0x2(%eax)
    1c36:	c6 40 03 1a          	movb   $0x1a,0x3(%eax)
    1c3a:	c6 40 04 8a          	movb   $0x8a,0x4(%eax)
    1c3e:	c6 40 05 42          	movb   $0x42,0x5(%eax)
    if (priv == NULL)
    	{                
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
    1c42:	89 d8                	mov    %ebx,%eax
    1c44:	e8 fc ff ff ff       	call   1c45 <__fsm_dev_create+0x55>
    1c49:	85 c0                	test   %eax,%eax
    1c4b:	75 0b                	jne    1c58 <__fsm_dev_create+0x68>
		{
        free_netdev(dev);   /* release the struct net_device */
        dev = NULL;               
        return -1;
		}
 	return 0;       
    1c4d:	31 c0                	xor    %eax,%eax
}
    1c4f:	83 c4 08             	add    $0x8,%esp
    1c52:	5b                   	pop    %ebx
    1c53:	5d                   	pop    %ebp
    1c54:	c3                   	ret    
    1c55:	8d 76 00             	lea    0x0(%esi),%esi
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
		{
        free_netdev(dev);   /* release the struct net_device */
    1c58:	89 d8                	mov    %ebx,%eax
    1c5a:	e8 fc ff ff ff       	call   1c5b <__fsm_dev_create+0x6b>
        dev = NULL;               
        return -1;
    1c5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1c64:	eb e9                	jmp    1c4f <__fsm_dev_create+0x5f>
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    if (dev == NULL)   /* allocation error */
		{
		return -2;
    1c66:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    1c6b:	eb e2                	jmp    1c4f <__fsm_dev_create+0x5f>
    1c6d:	8d 76 00             	lea    0x0(%esi),%esi

00001c70 <__fsm_dev_destroy>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_destroy(void)
{
    1c70:	55                   	push   %ebp
    1c71:	89 e5                	mov    %esp,%ebp
    1c73:	53                   	push   %ebx
    1c74:	e8 fc ff ff ff       	call   1c75 <__fsm_dev_destroy+0x5>
	NETDEV* dev;
	fsm_priv* priv;
	dev = (NETDEV*)fsm_dev_get();
    1c79:	e8 fc ff ff ff       	call   1c7a <__fsm_dev_destroy+0xa>
    1c7e:	89 c3                	mov    %eax,%ebx
	fsm_core_destroy();
    1c80:	e8 fc ff ff ff       	call   1c81 <__fsm_dev_destroy+0x11>
	priv = netdev_priv(dev);
	fsm_mem_free(priv->sv_ptr);
    1c85:	8b 83 1c 05 00 00    	mov    0x51c(%ebx),%eax
    1c8b:	e8 fc ff ff ff       	call   1c8c <__fsm_dev_destroy+0x1c>
    	unregister_netdev(dev);
    1c90:	89 d8                	mov    %ebx,%eax
    1c92:	e8 fc ff ff ff       	call   1c93 <__fsm_dev_destroy+0x23>
    	free_netdev(dev);
    1c97:	89 d8                	mov    %ebx,%eax
    1c99:	e8 fc ff ff ff       	call   1c9a <__fsm_dev_destroy+0x2a>
}   
    1c9e:	5b                   	pop    %ebx
    1c9f:	5d                   	pop    %ebp
    1ca0:	c3                   	ret    
    1ca1:	90                   	nop
    1ca2:	90                   	nop
    1ca3:	90                   	nop
    1ca4:	90                   	nop
    1ca5:	90                   	nop
    1ca6:	90                   	nop
    1ca7:	90                   	nop
    1ca8:	90                   	nop
    1ca9:	90                   	nop
    1caa:	90                   	nop
    1cab:	90                   	nop
    1cac:	90                   	nop
    1cad:	90                   	nop
    1cae:	90                   	nop
    1caf:	90                   	nop

00001cb0 <findInsByCode>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void * findInsByCode(long code, RlcTimerType * timer)
{
    1cb0:	55                   	push   %ebp
    1cb1:	89 e5                	mov    %esp,%ebp
    1cb3:	57                   	push   %edi
    1cb4:	56                   	push   %esi
    1cb5:	53                   	push   %ebx
    1cb6:	e8 fc ff ff ff       	call   1cb7 <findInsByCode+0x7>
    1cbb:	89 d6                	mov    %edx,%esi
    1cbd:	89 c3                	mov    %eax,%ebx
	struct list_head* pos;
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	
	FIN(findInsByCode());
	SV_PTR_GET(rlc_mac_sv);
    1cbf:	e8 fc ff ff ff       	call   1cc0 <findInsByCode+0x10>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1cc4:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
	/*if( SV(bufferReqTimerCode) == code )
	{
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    1cca:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    1cd0:	39 d1                	cmp    %edx,%ecx
    1cd2:	74 28                	je     1cfc <findInsByCode+0x4c>
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
    1cd4:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cda:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1ce0:	75 14                	jne    1cf6 <findInsByCode+0x46>
    1ce2:	eb 64                	jmp    1d48 <findInsByCode+0x98>
    1ce4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1ce8:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cee:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1cf4:	74 52                	je     1d48 <findInsByCode+0x98>
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    1cf6:	8b 12                	mov    (%edx),%edx
    1cf8:	39 d1                	cmp    %edx,%ecx
    1cfa:	75 ec                	jne    1ce8 <findInsByCode+0x38>
    1cfc:	8b 90 f4 25 00 00    	mov    0x25f4(%eax),%edx
				*timer = UM_REORDER;
				return (void*)umRxIns;
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
    1d02:	8d 88 f4 25 00 00    	lea    0x25f4(%eax),%ecx
    1d08:	39 d1                	cmp    %edx,%ecx
    1d0a:	75 1a                	jne    1d26 <findInsByCode+0x76>
    1d0c:	eb 5a                	jmp    1d68 <findInsByCode+0xb8>
    1d0e:	66 90                	xchg   %ax,%ax
			if(amIns->pollRetxTimerCode == code)
			{
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
    1d10:	39 9a 14 dd ff ff    	cmp    %ebx,-0x22ec(%edx)
    1d16:	74 40                	je     1d58 <findInsByCode+0xa8>
			{
				*timer = AM_REORDER;
				return (void*)amIns;
			}
			if(amIns->statProhTimerCode == code)
    1d18:	39 9a 20 dd ff ff    	cmp    %ebx,-0x22e0(%edx)
    1d1e:	74 40                	je     1d60 <findInsByCode+0xb0>
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    1d20:	8b 12                	mov    (%edx),%edx
    1d22:	39 d1                	cmp    %edx,%ecx
    1d24:	74 2a                	je     1d50 <findInsByCode+0xa0>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->pollRetxTimerCode == code)
    1d26:	39 9a 08 dd ff ff    	cmp    %ebx,-0x22f8(%edx)
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    1d2c:	8d ba fc dc ff ff    	lea    -0x2304(%edx),%edi
			if(amIns->pollRetxTimerCode == code)
    1d32:	75 dc                	jne    1d10 <findInsByCode+0x60>
			{
				*timer = POLL_RETX;
    1d34:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    1d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	else
	{
		return NULL;
	}
}
    1d40:	5b                   	pop    %ebx
    1d41:	89 f8                	mov    %edi,%eax
    1d43:	5e                   	pop    %esi
    1d44:	5f                   	pop    %edi
    1d45:	5d                   	pop    %ebp
    1d46:	c3                   	ret    
    1d47:	90                   	nop
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
			{
				*timer = UM_REORDER;
    1d48:	c7 06 04 00 00 00    	movl   $0x4,(%esi)
				return (void*)umRxIns;
    1d4e:	eb f0                	jmp    1d40 <findInsByCode+0x90>
	}
	else
	{
		return NULL;
	}
}
    1d50:	5b                   	pop    %ebx
    1d51:	5e                   	pop    %esi
    1d52:	5f                   	pop    %edi
    1d53:	5d                   	pop    %ebp
    1d54:	c3                   	ret    
    1d55:	8d 76 00             	lea    0x0(%esi),%esi
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
			{
				*timer = AM_REORDER;
    1d58:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				return (void*)amIns;
    1d5e:	eb e0                	jmp    1d40 <findInsByCode+0x90>
			}
			if(amIns->statProhTimerCode == code)
			{
				*timer = STAT_PRO;
    1d60:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
				return (void*)amIns;
    1d66:	eb d8                	jmp    1d40 <findInsByCode+0x90>
			}
		}
	}
	else
	{
		return NULL;
    1d68:	31 ff                	xor    %edi,%edi
    1d6a:	eb d4                	jmp    1d40 <findInsByCode+0x90>
    1d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001d70 <rlc_close>:
**--------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
***********************************************************************************/
static void rlc_close()
{
    1d70:	55                   	push   %ebp
    1d71:	89 e5                	mov    %esp,%ebp
    1d73:	57                   	push   %edi
    1d74:	56                   	push   %esi
    1d75:	53                   	push   %ebx
    1d76:	83 ec 20             	sub    $0x20,%esp
    1d79:	e8 fc ff ff ff       	call   1d7a <rlc_close+0xa>
	struct AmBuffer *amBuffer, *tempAmBuffer;
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
    1d7e:	e8 fc ff ff ff       	call   1d7f <rlc_close+0xf>
    1d83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
//AM
	if(!list_empty(&SV(vAm_ins).amList))
    1d86:	05 f4 25 00 00       	add    $0x25f4,%eax
    1d8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1d91:	8b b0 f4 25 00 00    	mov    0x25f4(%eax),%esi
    1d97:	39 75 e0             	cmp    %esi,-0x20(%ebp)
    1d9a:	0f 84 6f 04 00 00    	je     220f <rlc_close+0x49f>
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    1da0:	8b 06                	mov    (%esi),%eax
    1da2:	81 ee 04 23 00 00    	sub    $0x2304,%esi
    1da8:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    1dae:	89 55 e8             	mov    %edx,-0x18(%ebp)
    1db1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1db8:	8b 96 08 23 00 00    	mov    0x2308(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1dbe:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1dc1:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1dc3:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
    1dc9:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1dcf:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    1dd6:	01 10 00 
	entry->prev = LIST_POISON2;
    1dd9:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    1de0:	02 20 00 
    1de3:	39 c2                	cmp    %eax,%edx
    1de5:	0f 84 8d 08 00 00    	je     2678 <rlc_close+0x908>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    1deb:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1df1:	8b 00                	mov    (%eax),%eax
    1df3:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1df6:	89 d6                	mov    %edx,%esi
    1df8:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1dfe:	eb 1e                	jmp    1e1e <rlc_close+0xae>
    1e00:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1e06:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1e0c:	39 ce                	cmp    %ecx,%esi
    1e0e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1e14:	0f 84 ae 03 00 00    	je     21c8 <rlc_close+0x458>
    1e1a:	89 fb                	mov    %edi,%ebx
    1e1c:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1e1e:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1e24:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1e27:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1e29:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1e2b:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1e32:	01 10 00 
	entry->prev = LIST_POISON2;
    1e35:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1e3c:	02 20 00 
    1e3f:	85 c0                	test   %eax,%eax
    1e41:	74 0b                	je     1e4e <rlc_close+0xde>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1e43:	e8 fc ff ff ff       	call   1e44 <rlc_close+0xd4>
						amBuffer->pkt = NULL;
    1e48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1e4e:	85 db                	test   %ebx,%ebx
    1e50:	74 07                	je     1e59 <rlc_close+0xe9>
					{
						fsm_mem_free(amBuffer);
    1e52:	89 d8                	mov    %ebx,%eax
    1e54:	e8 fc ff ff ff       	call   1e55 <rlc_close+0xe5>
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
    1e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5c:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    1e62:	75 9c                	jne    1e00 <rlc_close+0x90>
    1e64:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
						break;
    1e66:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
    1e68:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
    1e6f:	e8 fc ff ff ff       	call   1e70 <rlc_close+0x100>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1e74:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    1e7a:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    1e80:	39 c2                	cmp    %eax,%edx
    1e82:	0f 84 59 03 00 00    	je     21e1 <rlc_close+0x471>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    1e88:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1e8e:	8b 00                	mov    (%eax),%eax
    1e90:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1e93:	89 d6                	mov    %edx,%esi
    1e95:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1e9b:	eb 21                	jmp    1ebe <rlc_close+0x14e>
    1e9d:	8d 76 00             	lea    0x0(%esi),%esi
    1ea0:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1ea6:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1eac:	39 ce                	cmp    %ecx,%esi
    1eae:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1eb4:	0f 84 e6 02 00 00    	je     21a0 <rlc_close+0x430>
    1eba:	89 fb                	mov    %edi,%ebx
    1ebc:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ebe:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1ec4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1ec7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1ec9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1ecb:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1ed2:	01 10 00 
	entry->prev = LIST_POISON2;
    1ed5:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1edc:	02 20 00 
    1edf:	85 c0                	test   %eax,%eax
    1ee1:	74 0b                	je     1eee <rlc_close+0x17e>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1ee3:	e8 fc ff ff ff       	call   1ee4 <rlc_close+0x174>
						amBuffer->pkt = NULL;
    1ee8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1eee:	85 db                	test   %ebx,%ebx
    1ef0:	74 07                	je     1ef9 <rlc_close+0x189>
					{
						fsm_mem_free(amBuffer);
    1ef2:	89 d8                	mov    %ebx,%eax
    1ef4:	e8 fc ff ff ff       	call   1ef5 <rlc_close+0x185>
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
    1ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1efc:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    1f02:	75 9c                	jne    1ea0 <rlc_close+0x130>
    1f04:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
						break;
    1f06:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
    1f08:	c7 04 24 2c 01 00 00 	movl   $0x12c,(%esp)
    1f0f:	e8 fc ff ff ff       	call   1f10 <rlc_close+0x1a0>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1f14:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    1f17:	8d 4e 44             	lea    0x44(%esi),%ecx
    1f1a:	39 f9                	cmp    %edi,%ecx
    1f1c:	0f 84 91 02 00 00    	je     21b3 <rlc_close+0x443>
			{
				list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    1f22:	8b 07                	mov    (%edi),%eax
    1f24:	83 ef 0c             	sub    $0xc,%edi
    1f27:	89 75 ec             	mov    %esi,-0x14(%ebp)
    1f2a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    1f2d:	89 cb                	mov    %ecx,%ebx
    1f2f:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f32:	89 d6                	mov    %edx,%esi
    1f34:	eb 17                	jmp    1f4d <rlc_close+0x1dd>
    1f36:	66 90                	xchg   %ax,%ax
    1f38:	8b 46 0c             	mov    0xc(%esi),%eax
    1f3b:	8d 4e 0c             	lea    0xc(%esi),%ecx
    1f3e:	39 cb                	cmp    %ecx,%ebx
    1f40:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f43:	0f 84 07 02 00 00    	je     2150 <rlc_close+0x3e0>
    1f49:	89 f7                	mov    %esi,%edi
    1f4b:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1f4d:	8b 57 10             	mov    0x10(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1f50:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1f53:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amsBuffer->list);
					if(amBuffer->pkt != NULL)
    1f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1f58:	c7 47 0c 00 01 10 00 	movl   $0x100100,0xc(%edi)
	entry->prev = LIST_POISON2;
    1f5f:	c7 47 10 00 02 20 00 	movl   $0x200200,0x10(%edi)
    1f66:	8b 00                	mov    (%eax),%eax
    1f68:	85 c0                	test   %eax,%eax
    1f6a:	74 10                	je     1f7c <rlc_close+0x20c>
					{
						fsm_pkt_destroy(amsBuffer->pkt);
    1f6c:	8b 07                	mov    (%edi),%eax
    1f6e:	e8 fc ff ff ff       	call   1f6f <rlc_close+0x1ff>
						amBuffer->pkt = NULL;
    1f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					}
					if(amsBuffer != NULL)
    1f7c:	85 ff                	test   %edi,%edi
    1f7e:	74 07                	je     1f87 <rlc_close+0x217>
					{
						fsm_mem_free(amsBuffer);
    1f80:	89 f8                	mov    %edi,%eax
    1f82:	e8 fc ff ff ff       	call   1f83 <rlc_close+0x213>
						amsBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amSduBuffer.list))
    1f87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f8a:	3b 58 44             	cmp    0x44(%eax),%ebx
    1f8d:	75 a9                	jne    1f38 <rlc_close+0x1c8>
    1f8f:	89 c6                	mov    %eax,%esi
    1f91:	8b 5d f0             	mov    -0x10(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:sdu buffer is realeasing\n");
    1f94:	c7 04 24 94 01 00 00 	movl   $0x194,(%esp)
    1f9b:	e8 fc ff ff ff       	call   1f9c <rlc_close+0x22c>
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    1fa0:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    1fa6:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    1fac:	0f 84 b6 01 00 00    	je     2168 <rlc_close+0x3f8>
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is not empty\n");
    1fb2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    1fb5:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
    1fbc:	e8 fc ff ff ff       	call   1fbd <rlc_close+0x24d>
				list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    1fc1:	8b 96 b0 01 00 00    	mov    0x1b0(%esi),%edx
    1fc7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    1fca:	8b 02                	mov    (%edx),%eax
    1fcc:	8d 7a fc             	lea    -0x4(%edx),%edi
    1fcf:	39 d1                	cmp    %edx,%ecx
    1fd1:	74 78                	je     204b <rlc_close+0x2db>
    1fd3:	8d 50 fc             	lea    -0x4(%eax),%edx
    1fd6:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1fd9:	89 ce                	mov    %ecx,%esi
    1fdb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    1fde:	89 d3                	mov    %edx,%ebx
    1fe0:	eb 1b                	jmp    1ffd <rlc_close+0x28d>
    1fe2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1fe8:	8b 43 04             	mov    0x4(%ebx),%eax
    1feb:	8d 4b 04             	lea    0x4(%ebx),%ecx
    1fee:	39 ce                	cmp    %ecx,%esi
    1ff0:	8d 50 fc             	lea    -0x4(%eax),%edx
    1ff3:	0f 84 ff 01 00 00    	je     21f8 <rlc_close+0x488>
    1ff9:	89 df                	mov    %ebx,%edi
    1ffb:	89 d3                	mov    %edx,%ebx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ffd:	8b 57 08             	mov    0x8(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2000:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2003:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    2005:	8b 07                	mov    (%edi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2007:	c7 47 04 00 01 10 00 	movl   $0x100100,0x4(%edi)
	entry->prev = LIST_POISON2;
    200e:	c7 47 08 00 02 20 00 	movl   $0x200200,0x8(%edi)
    2015:	85 c0                	test   %eax,%eax
    2017:	74 0b                	je     2024 <rlc_close+0x2b4>
					{
						fsm_pkt_destroy(buffer->pkt);
    2019:	e8 fc ff ff ff       	call   201a <rlc_close+0x2aa>
						buffer->pkt = NULL;
    201e:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
					}
					if(buffer != NULL)
    2024:	85 ff                	test   %edi,%edi
    2026:	74 07                	je     202f <rlc_close+0x2bf>
					{
						fsm_mem_free(buffer);
    2028:	89 f8                	mov    %edi,%eax
    202a:	e8 fc ff ff ff       	call   202b <rlc_close+0x2bb>
						buffer = NULL;
					}					
					if(list_empty(&amIns->ctrlPduBuffer.list))
    202f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2032:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    2038:	75 ae                	jne    1fe8 <rlc_close+0x278>
    203a:	89 c6                	mov    %eax,%esi
    203c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:ctrl buffer is realeasing\n");
    203f:	c7 04 24 20 02 00 00 	movl   $0x220,(%esp)
    2046:	e8 fc ff ff ff       	call   2047 <rlc_close+0x2d7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    204b:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    2051:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2057:	39 c2                	cmp    %eax,%edx
    2059:	0f 84 29 01 00 00    	je     2188 <rlc_close+0x418>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    205f:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    2065:	8b 00                	mov    (%eax),%eax
    2067:	89 75 f0             	mov    %esi,-0x10(%ebp)
    206a:	89 d6                	mov    %edx,%esi
    206c:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    2072:	eb 22                	jmp    2096 <rlc_close+0x326>
    2074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    207e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    2084:	39 ce                	cmp    %ecx,%esi
    2086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    208c:	0f 84 b6 00 00 00    	je     2148 <rlc_close+0x3d8>
    2092:	89 fb                	mov    %edi,%ebx
    2094:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2096:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    209c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    209f:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    20a1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    20a3:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    20aa:	01 10 00 
	entry->prev = LIST_POISON2;
    20ad:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    20b4:	02 20 00 
    20b7:	85 c0                	test   %eax,%eax
    20b9:	74 0b                	je     20c6 <rlc_close+0x356>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    20bb:	e8 fc ff ff ff       	call   20bc <rlc_close+0x34c>
						amBuffer->pkt = NULL;
    20c0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    20c6:	85 db                	test   %ebx,%ebx
    20c8:	74 07                	je     20d1 <rlc_close+0x361>
					{
						fsm_mem_free(amBuffer);
    20ca:	89 d8                	mov    %ebx,%eax
    20cc:	e8 fc ff ff ff       	call   20cd <rlc_close+0x35d>
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
    20d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    20d4:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    20da:	75 9c                	jne    2078 <rlc_close+0x308>
    20dc:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
						break;
    20de:	31 db                	xor    %ebx,%ebx
						fsm_mem_free(amBuffer);
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
    20e0:	c7 04 24 7c 02 00 00 	movl   $0x27c,(%esp)
    20e7:	e8 fc ff ff ff       	call   20e8 <rlc_close+0x378>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] am instance  has released(rbid is%d)\n", amIns->rbId);
    20ec:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    20f0:	c7 04 24 d8 02 00 00 	movl   $0x2d8,(%esp)
    20f7:	89 44 24 04          	mov    %eax,0x4(%esp)
    20fb:	e8 fc ff ff ff       	call   20fc <rlc_close+0x38c>
			if(amIns != NULL)
    2100:	85 f6                	test   %esi,%esi
    2102:	74 07                	je     210b <rlc_close+0x39b>
			{
				fsm_mem_free(amIns);
    2104:	89 f0                	mov    %esi,%eax
    2106:	e8 fc ff ff ff       	call   2107 <rlc_close+0x397>
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
    210b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    210e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2111:	3b 90 f4 25 00 00    	cmp    0x25f4(%eax),%edx
    2117:	0f 84 e6 00 00 00    	je     2203 <rlc_close+0x493>
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
//AM
	if(!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    211d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    2120:	8b 81 04 23 00 00    	mov    0x2304(%ecx),%eax
    2126:	81 c1 04 23 00 00    	add    $0x2304,%ecx
    212c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
    212f:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    2135:	0f 84 d4 00 00 00    	je     220f <rlc_close+0x49f>
    213b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    213e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    2141:	e9 72 fc ff ff       	jmp    1db8 <rlc_close+0x48>
    2146:	66 90                	xchg   %ax,%ax
    2148:	8b 75 f0             	mov    -0x10(%ebp),%esi
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    214b:	89 fb                	mov    %edi,%ebx
    214d:	eb 9d                	jmp    20ec <rlc_close+0x37c>
    214f:	90                   	nop
    2150:	8b 75 ec             	mov    -0x14(%ebp),%esi
    2153:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    2156:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    215c:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    2162:	0f 85 4a fe ff ff    	jne    1fb2 <rlc_close+0x242>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
    2168:	c7 04 24 50 02 00 00 	movl   $0x250,(%esp)
    216f:	e8 fc ff ff ff       	call   2170 <rlc_close+0x400>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2174:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    217a:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2180:	39 c2                	cmp    %eax,%edx
    2182:	0f 85 d7 fe ff ff    	jne    205f <rlc_close+0x2ef>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
    2188:	c7 04 24 ac 02 00 00 	movl   $0x2ac,(%esp)
    218f:	e8 fc ff ff ff       	call   2190 <rlc_close+0x420>
    2194:	e9 53 ff ff ff       	jmp    20ec <rlc_close+0x37c>
    2199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    21a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    21a3:	89 fb                	mov    %edi,%ebx
    21a5:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    21a8:	8d 4e 44             	lea    0x44(%esi),%ecx
    21ab:	39 f9                	cmp    %edi,%ecx
    21ad:	0f 85 6f fd ff ff    	jne    1f22 <rlc_close+0x1b2>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
    21b3:	c7 04 24 c4 01 00 00 	movl   $0x1c4,(%esp)
    21ba:	e8 fc ff ff ff       	call   21bb <rlc_close+0x44b>
    21bf:	e9 dc fd ff ff       	jmp    1fa0 <rlc_close+0x230>
    21c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    21c8:	8b 75 f0             	mov    -0x10(%ebp),%esi
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    21cb:	89 fb                	mov    %edi,%ebx
    21cd:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    21d3:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    21d9:	39 c2                	cmp    %eax,%edx
    21db:	0f 85 a7 fc ff ff    	jne    1e88 <rlc_close+0x118>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
    21e1:	c7 04 24 64 01 00 00 	movl   $0x164,(%esp)
    21e8:	e8 fc ff ff ff       	call   21e9 <rlc_close+0x479>
    21ed:	e9 22 fd ff ff       	jmp    1f14 <rlc_close+0x1a4>
    21f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    21f8:	8b 75 f0             	mov    -0x10(%ebp),%esi
    21fb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    21fe:	e9 48 fe ff ff       	jmp    204b <rlc_close+0x2db>
				fsm_mem_free(amIns);
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
			{
				fsm_printf("[RLC][rlc_close] amInsList is empty\n");
    2203:	c7 04 24 10 03 00 00 	movl   $0x310,(%esp)
    220a:	e8 fc ff ff ff       	call   220b <rlc_close+0x49b>
				break;
			}
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    220f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2212:	05 c0 36 00 00       	add    $0x36c0,%eax
    2217:	89 45 e8             	mov    %eax,-0x18(%ebp)
    221a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    221d:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
    2223:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2226:	0f 84 13 01 00 00    	je     233f <rlc_close+0x5cf>
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    222c:	8b 02                	mov    (%edx),%eax
    222e:	81 ea c4 10 00 00    	sub    $0x10c4,%edx
    2234:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2237:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    223d:	89 55 ec             	mov    %edx,-0x14(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2240:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2243:	8b 91 c8 10 00 00    	mov    0x10c8(%ecx),%edx
		{
			list_del(&umRxIns->umRxList);
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    2249:	89 cf                	mov    %ecx,%edi
    224b:	83 c7 30             	add    $0x30,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    224e:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2251:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2253:	8b 59 30             	mov    0x30(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2256:	c7 81 c4 10 00 00 00 	movl   $0x100100,0x10c4(%ecx)
    225d:	01 10 00 
	entry->prev = LIST_POISON2;
    2260:	c7 81 c8 10 00 00 00 	movl   $0x200200,0x10c8(%ecx)
    2267:	02 20 00 
    226a:	39 df                	cmp    %ebx,%edi
    226c:	0f 84 f5 03 00 00    	je     2667 <rlc_close+0x8f7>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    2272:	8b 03                	mov    (%ebx),%eax
    2274:	83 eb 10             	sub    $0x10,%ebx
    2277:	8d 70 f0             	lea    -0x10(%eax),%esi
    227a:	eb 15                	jmp    2291 <rlc_close+0x521>
    227c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2280:	8b 46 10             	mov    0x10(%esi),%eax
    2283:	8d 4e 10             	lea    0x10(%esi),%ecx
    2286:	39 cf                	cmp    %ecx,%edi
    2288:	8d 50 f0             	lea    -0x10(%eax),%edx
    228b:	74 4a                	je     22d7 <rlc_close+0x567>
    228d:	89 f3                	mov    %esi,%ebx
    228f:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2291:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2294:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2297:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    2299:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    229b:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    22a2:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    22a9:	85 c0                	test   %eax,%eax
    22ab:	74 0b                	je     22b8 <rlc_close+0x548>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    22ad:	e8 fc ff ff ff       	call   22ae <rlc_close+0x53e>
						umBuffer->pkt = NULL;
    22b2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    22b8:	85 db                	test   %ebx,%ebx
    22ba:	74 07                	je     22c3 <rlc_close+0x553>
					{
						fsm_mem_free(umBuffer);
    22bc:	89 d8                	mov    %ebx,%eax
    22be:	e8 fc ff ff ff       	call   22bf <rlc_close+0x54f>
						umBuffer = NULL;
					}				
					
					if(list_empty(&umRxIns->umRecvBuffer.list))
    22c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22c6:	3b 78 30             	cmp    0x30(%eax),%edi
    22c9:	75 b5                	jne    2280 <rlc_close+0x510>
					{
						fsm_printf("[RLC][rlc_close] um recv:recv buffer is realeasing\n");
    22cb:	c7 04 24 38 03 00 00 	movl   $0x338,(%esp)
    22d2:	e8 fc ff ff ff       	call   22d3 <rlc_close+0x563>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umRxIns->rbId);
    22d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22da:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    22de:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    22e5:	89 44 24 04          	mov    %eax,0x4(%esp)
    22e9:	e8 fc ff ff ff       	call   22ea <rlc_close+0x57a>
			if(umRxIns != NULL)
    22ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    22f1:	85 c9                	test   %ecx,%ecx
    22f3:	74 08                	je     22fd <rlc_close+0x58d>
			{
				fsm_mem_free(umRxIns);
    22f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22f8:	e8 fc ff ff ff       	call   22f9 <rlc_close+0x589>
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
    22fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2300:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2303:	3b 90 c0 36 00 00    	cmp    0x36c0(%eax),%edx
    2309:	74 28                	je     2333 <rlc_close+0x5c3>
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    230b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    230e:	8b 81 c4 10 00 00    	mov    0x10c4(%ecx),%eax
    2314:	81 c1 c4 10 00 00    	add    $0x10c4,%ecx
    231a:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    231d:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    2323:	74 1a                	je     233f <rlc_close+0x5cf>
    2325:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2328:	89 55 ec             	mov    %edx,-0x14(%ebp)
    232b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    232e:	e9 0d ff ff ff       	jmp    2240 <rlc_close+0x4d0>
				fsm_mem_free(umRxIns);
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
			{
				fsm_printf("[RLC][rlc_close] umRxInsList is empty\n");
    2333:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
    233a:	e8 fc ff ff ff       	call   233b <rlc_close+0x5cb>
				break;
			}
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
    233f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2342:	05 f8 36 00 00       	add    $0x36f8,%eax
    2347:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    234a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    234d:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
    2353:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2356:	0f 84 02 01 00 00    	je     245e <rlc_close+0x6ee>
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    235c:	8b 02                	mov    (%edx),%eax
    235e:	83 ea 30             	sub    $0x30,%edx
    2361:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2364:	8d 50 d0             	lea    -0x30(%eax),%edx
    2367:	89 55 ec             	mov    %edx,-0x14(%ebp)
    236a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2370:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2373:	8b 51 34             	mov    0x34(%ecx),%edx
		{
			list_del(&umTxIns->umTxList);
			if(!list_empty(&umTxIns->umSduBuffer.list))
    2376:	89 cf                	mov    %ecx,%edi
    2378:	83 c7 18             	add    $0x18,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    237b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    237e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2380:	8b 59 18             	mov    0x18(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2383:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    238a:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    2391:	39 df                	cmp    %ebx,%edi
    2393:	0f 84 bd 02 00 00    	je     2656 <rlc_close+0x8e6>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    2399:	8b 03                	mov    (%ebx),%eax
    239b:	83 eb 10             	sub    $0x10,%ebx
    239e:	8d 70 f0             	lea    -0x10(%eax),%esi
    23a1:	eb 16                	jmp    23b9 <rlc_close+0x649>
    23a3:	90                   	nop
    23a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    23a8:	8b 46 10             	mov    0x10(%esi),%eax
    23ab:	8d 4e 10             	lea    0x10(%esi),%ecx
    23ae:	39 cf                	cmp    %ecx,%edi
    23b0:	8d 50 f0             	lea    -0x10(%eax),%edx
    23b3:	74 4a                	je     23ff <rlc_close+0x68f>
    23b5:	89 f3                	mov    %esi,%ebx
    23b7:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    23b9:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    23bc:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    23bf:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    23c1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    23c3:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    23ca:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    23d1:	85 c0                	test   %eax,%eax
    23d3:	74 0b                	je     23e0 <rlc_close+0x670>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    23d5:	e8 fc ff ff ff       	call   23d6 <rlc_close+0x666>
						umBuffer->pkt = NULL;
    23da:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    23e0:	85 db                	test   %ebx,%ebx
    23e2:	74 07                	je     23eb <rlc_close+0x67b>
					{
						fsm_mem_free(umBuffer);
    23e4:	89 d8                	mov    %ebx,%eax
    23e6:	e8 fc ff ff ff       	call   23e7 <rlc_close+0x677>
						umBuffer = NULL;
					}					
					
					if(list_empty(&umTxIns->umSduBuffer.list))
    23eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23ee:	3b 78 18             	cmp    0x18(%eax),%edi
    23f1:	75 b5                	jne    23a8 <rlc_close+0x638>
					{
						fsm_printf("[RLC][rlc_close] um tran:sdu buffer is realeasing\n");
    23f3:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
    23fa:	e8 fc ff ff ff       	call   23fb <rlc_close+0x68b>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umTxIns->rbid);
    23ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2402:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    2406:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    240d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2411:	e8 fc ff ff ff       	call   2412 <rlc_close+0x6a2>
			if(umTxIns != NULL)
    2416:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2419:	85 d2                	test   %edx,%edx
    241b:	74 08                	je     2425 <rlc_close+0x6b5>
			{
				fsm_mem_free(umTxIns);
    241d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2420:	e8 fc ff ff ff       	call   2421 <rlc_close+0x6b1>
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
    2425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2428:	8b 55 e8             	mov    -0x18(%ebp),%edx
    242b:	3b 90 f8 36 00 00    	cmp    0x36f8(%eax),%edx
    2431:	74 1f                	je     2452 <rlc_close+0x6e2>
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    2433:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2436:	8b 41 30             	mov    0x30(%ecx),%eax
    2439:	83 c1 30             	add    $0x30,%ecx
    243c:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    243f:	8d 50 d0             	lea    -0x30(%eax),%edx
    2442:	74 1a                	je     245e <rlc_close+0x6ee>
    2444:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2447:	89 55 ec             	mov    %edx,-0x14(%ebp)
    244a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    244d:	e9 1e ff ff ff       	jmp    2370 <rlc_close+0x600>
				fsm_mem_free(umTxIns);
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
			{
				fsm_printf("[RLC][rlc_close] umTxInsList is empty\n");
    2452:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2459:	e8 fc ff ff ff       	call   245a <rlc_close+0x6ea>
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
    245e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2461:	05 2c 37 00 00       	add    $0x372c,%eax
    2466:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    246c:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
    2472:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2475:	0f 84 1f 01 00 00    	je     259a <rlc_close+0x82a>
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    247b:	8b 02                	mov    (%edx),%eax
    247d:	83 ea 1c             	sub    $0x1c,%edx
    2480:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2483:	8d 50 e4             	lea    -0x1c(%eax),%edx
    2486:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2490:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2493:	8b 51 20             	mov    0x20(%ecx),%edx
		{
			list_del(&tmTxIns->tmTxList);
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    2496:	89 cf                	mov    %ecx,%edi
    2498:	83 c7 0c             	add    $0xc,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    249b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    249e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    24a0:	8b 59 0c             	mov    0xc(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24a3:	c7 41 1c 00 01 10 00 	movl   $0x100100,0x1c(%ecx)
	entry->prev = LIST_POISON2;
    24aa:	c7 41 20 00 02 20 00 	movl   $0x200200,0x20(%ecx)
    24b1:	39 df                	cmp    %ebx,%edi
    24b3:	74 56                	je     250b <rlc_close+0x79b>
			{
				list_for_each_entry_safe(buffer,tempBuffer, &tmTxIns->tmSduBuffer.list,list)
    24b5:	8b 03                	mov    (%ebx),%eax
    24b7:	83 eb 04             	sub    $0x4,%ebx
    24ba:	8d 70 fc             	lea    -0x4(%eax),%esi
    24bd:	eb 12                	jmp    24d1 <rlc_close+0x761>
    24bf:	90                   	nop
    24c0:	8b 46 04             	mov    0x4(%esi),%eax
    24c3:	8d 4e 04             	lea    0x4(%esi),%ecx
    24c6:	39 cf                	cmp    %ecx,%edi
    24c8:	8d 50 fc             	lea    -0x4(%eax),%edx
    24cb:	74 4a                	je     2517 <rlc_close+0x7a7>
    24cd:	89 f3                	mov    %esi,%ebx
    24cf:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    24d1:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    24d4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    24d7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    24d9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24db:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    24e2:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    24e9:	85 c0                	test   %eax,%eax
    24eb:	74 0b                	je     24f8 <rlc_close+0x788>
					{
						fsm_pkt_destroy(buffer->pkt);
    24ed:	e8 fc ff ff ff       	call   24ee <rlc_close+0x77e>
						buffer->pkt = NULL;
    24f2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(buffer != NULL)
    24f8:	85 db                	test   %ebx,%ebx
    24fa:	74 07                	je     2503 <rlc_close+0x793>
					{
						fsm_mem_free(buffer);
    24fc:	89 d8                	mov    %ebx,%eax
    24fe:	e8 fc ff ff ff       	call   24ff <rlc_close+0x78f>
						buffer = NULL;
					}					
					
					if(list_empty(&tmTxIns->tmSduBuffer.list))
    2503:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2506:	3b 78 0c             	cmp    0xc(%eax),%edi
    2509:	75 b5                	jne    24c0 <rlc_close+0x750>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
    250b:	c7 04 24 88 04 00 00 	movl   $0x488,(%esp)
    2512:	e8 fc ff ff ff       	call   2513 <rlc_close+0x7a3>
			}
			if( tmTxIns->pbCh == 0)
    2517:	8b 55 f0             	mov    -0x10(%ebp),%edx
    251a:	0f b6 42 04          	movzbl 0x4(%edx),%eax
    251e:	84 c0                	test   %al,%al
    2520:	74 4e                	je     2570 <rlc_close+0x800>
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
			}
			else if(tmTxIns->pbCh == 1)
    2522:	3c 01                	cmp    $0x1,%al
    2524:	74 5a                	je     2580 <rlc_close+0x810>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    2526:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    252d:	e8 fc ff ff ff       	call   252e <rlc_close+0x7be>
			}
			if(tmTxIns != NULL)
    2532:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2535:	85 c0                	test   %eax,%eax
    2537:	74 08                	je     2541 <rlc_close+0x7d1>
			{
				fsm_mem_free(tmTxIns);
    2539:	8b 45 f0             	mov    -0x10(%ebp),%eax
    253c:	e8 fc ff ff ff       	call   253d <rlc_close+0x7cd>
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
    2541:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2544:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2547:	3b 90 2c 37 00 00    	cmp    0x372c(%eax),%edx
    254d:	74 3f                	je     258e <rlc_close+0x81e>
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    254f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2552:	8b 41 1c             	mov    0x1c(%ecx),%eax
    2555:	83 c1 1c             	add    $0x1c,%ecx
    2558:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    255b:	8d 50 e4             	lea    -0x1c(%eax),%edx
    255e:	74 3a                	je     259a <rlc_close+0x82a>
    2560:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2563:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2566:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2569:	e9 22 ff ff ff       	jmp    2490 <rlc_close+0x720>
    256e:	66 90                	xchg   %ax,%ax
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
			}
			if( tmTxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
    2570:	c7 04 24 b4 04 00 00 	movl   $0x4b4,(%esp)
    2577:	e8 fc ff ff ff       	call   2578 <rlc_close+0x808>
    257c:	eb b4                	jmp    2532 <rlc_close+0x7c2>
    257e:	66 90                	xchg   %ax,%ax
			}
			else if(tmTxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2580:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    2587:	e8 fc ff ff ff       	call   2588 <rlc_close+0x818>
    258c:	eb a4                	jmp    2532 <rlc_close+0x7c2>
				fsm_mem_free(tmTxIns);
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
			{
				fsm_printf("[RLC][rlc_close] tmTxInsList is empty\n");
    258e:	c7 04 24 28 05 00 00 	movl   $0x528,(%esp)
    2595:	e8 fc ff ff ff       	call   2596 <rlc_close+0x826>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    259a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
    259d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    25a0:	8b 98 08 37 00 00    	mov    0x3708(%eax),%ebx
    25a6:	81 c7 08 37 00 00    	add    $0x3708,%edi
    25ac:	39 df                	cmp    %ebx,%edi
    25ae:	0f 84 8e 00 00 00    	je     2642 <rlc_close+0x8d2>
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25b4:	8b 03                	mov    (%ebx),%eax
    25b6:	83 eb 08             	sub    $0x8,%ebx
    25b9:	8d 70 f8             	lea    -0x8(%eax),%esi
    25bc:	eb 39                	jmp    25f7 <rlc_close+0x887>
    25be:	66 90                	xchg   %ax,%ax
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
			}
			else if(tmRxIns->pbCh == 1)
    25c0:	3c 01                	cmp    $0x1,%al
    25c2:	74 64                	je     2628 <rlc_close+0x8b8>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    25c4:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    25cb:	e8 fc ff ff ff       	call   25cc <rlc_close+0x85c>
			}
			if(tmRxIns != NULL)
    25d0:	85 db                	test   %ebx,%ebx
    25d2:	74 07                	je     25db <rlc_close+0x86b>
			{
				fsm_mem_free(tmRxIns);
    25d4:	89 d8                	mov    %ebx,%eax
    25d6:	e8 fc ff ff ff       	call   25d7 <rlc_close+0x867>
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
    25db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25de:	3b b8 08 37 00 00    	cmp    0x3708(%eax),%edi
    25e4:	74 50                	je     2636 <rlc_close+0x8c6>
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25e6:	8b 46 08             	mov    0x8(%esi),%eax
    25e9:	8d 4e 08             	lea    0x8(%esi),%ecx
    25ec:	39 cf                	cmp    %ecx,%edi
    25ee:	8d 50 f8             	lea    -0x8(%eax),%edx
    25f1:	74 4f                	je     2642 <rlc_close+0x8d2>
    25f3:	89 f3                	mov    %esi,%ebx
    25f5:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    25f7:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    25fa:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    25fd:	89 02                	mov    %eax,(%edx)
		{
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
    25ff:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2603:	c7 43 08 00 01 10 00 	movl   $0x100100,0x8(%ebx)
	entry->prev = LIST_POISON2;
    260a:	c7 43 0c 00 02 20 00 	movl   $0x200200,0xc(%ebx)
    2611:	84 c0                	test   %al,%al
    2613:	75 ab                	jne    25c0 <rlc_close+0x850>
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
    2615:	c7 04 24 50 05 00 00 	movl   $0x550,(%esp)
    261c:	e8 fc ff ff ff       	call   261d <rlc_close+0x8ad>
    2621:	eb ad                	jmp    25d0 <rlc_close+0x860>
    2623:	90                   	nop
    2624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			else if(tmRxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2628:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    262f:	e8 fc ff ff ff       	call   2630 <rlc_close+0x8c0>
    2634:	eb 9a                	jmp    25d0 <rlc_close+0x860>
				fsm_mem_free(tmRxIns);
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
			{
				fsm_printf("[RLC][rlc_close] tmRxInsList is empty\n");
    2636:	c7 04 24 7c 05 00 00 	movl   $0x57c,(%esp)
    263d:	e8 fc ff ff ff       	call   263e <rlc_close+0x8ce>
				break;
			}
		}
	}
	fsm_printf("[RLC][rlc_close] rlc has closed \n");
    2642:	c7 04 24 a4 05 00 00 	movl   $0x5a4,(%esp)
    2649:	e8 fc ff ff ff       	call   264a <rlc_close+0x8da>
	FOUT;
}
    264e:	83 c4 20             	add    $0x20,%esp
    2651:	5b                   	pop    %ebx
    2652:	5e                   	pop    %esi
    2653:	5f                   	pop    %edi
    2654:	5d                   	pop    %ebp
    2655:	c3                   	ret    
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
    2656:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
    265d:	e8 fc ff ff ff       	call   265e <rlc_close+0x8ee>
    2662:	e9 98 fd ff ff       	jmp    23ff <rlc_close+0x68f>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
    2667:	c7 04 24 6c 03 00 00 	movl   $0x36c,(%esp)
    266e:	e8 fc ff ff ff       	call   266f <rlc_close+0x8ff>
    2673:	e9 5f fc ff ff       	jmp    22d7 <rlc_close+0x567>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
    2678:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
    267f:	e8 fc ff ff ff       	call   2680 <rlc_close+0x910>
    2684:	e9 eb f7 ff ff       	jmp    1e74 <rlc_close+0x104>
    2689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00002690 <StartWaitingForRaResponse>:
->output:
->Special:
*******************************
*/
static void StartWaitingForRaResponse()
{
    2690:	55                   	push   %ebp
    2691:	89 e5                	mov    %esp,%ebp
    2693:	53                   	push   %ebx
    2694:	83 ec 04             	sub    $0x4,%esp
    2697:	e8 fc ff ff ff       	call   2698 <StartWaitingForRaResponse+0x8>
	FIN(StartWaitingForRaResponse());
	SV_PTR_GET(rlc_mac_sv);
    269c:	e8 fc ff ff ff       	call   269d <StartWaitingForRaResponse+0xd>
    26a1:	89 c3                	mov    %eax,%ebx
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
    26a3:	8b 80 cc 00 00 00    	mov    0xcc(%eax),%eax
    26a9:	89 83 90 01 00 00    	mov    %eax,0x190(%ebx)
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
    26af:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)
    26b6:	e8 fc ff ff ff       	call   26b7 <StartWaitingForRaResponse+0x27>
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26bb:	ba 18 00 00 00       	mov    $0x18,%edx
    26c0:	6b 83 90 01 00 00 64 	imul   $0x64,0x190(%ebx),%eax
    26c7:	e8 fc ff ff ff       	call   26c8 <StartWaitingForRaResponse+0x38>
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
    26cc:	c6 83 98 01 00 00 01 	movb   $0x1,0x198(%ebx)
	SV_PTR_GET(rlc_mac_sv);
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26d3:	89 83 94 01 00 00    	mov    %eax,0x194(%ebx)
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
	FOUT;
}
    26d9:	83 c4 04             	add    $0x4,%esp
    26dc:	5b                   	pop    %ebx
    26dd:	5d                   	pop    %ebp
    26de:	c3                   	ret    
    26df:	90                   	nop

000026e0 <send_SR>:
->output:
->Special:
*******************************
*/
static void send_SR()
{
    26e0:	55                   	push   %ebp
    26e1:	89 e5                	mov    %esp,%ebp
    26e3:	53                   	push   %ebx
    26e4:	83 ec 04             	sub    $0x4,%esp
    26e7:	e8 fc ff ff ff       	call   26e8 <send_SR+0x8>
	FIN(send_SR());
	SV_PTR_GET(rlc_mac_sv);
    26ec:	e8 fc ff ff ff       	call   26ed <send_SR+0xd>
    26f1:	89 c3                	mov    %eax,%ebx
	fsm_printf("[UE MAC]send_SR\n");
    26f3:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    26fa:	e8 fc ff ff ff       	call   26fb <send_SR+0x1b>
	fsm_schedule_self(0,SR_Fail);//SR
    26ff:	ba 07 00 00 00       	mov    $0x7,%edx
    2704:	31 c0                	xor    %eax,%eax
    2706:	e8 fc ff ff ff       	call   2707 <send_SR+0x27>
	SV(ratype.ra_type)=2;
    270b:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    2712:	00 00 00 
	FOUT;
}
    2715:	83 c4 04             	add    $0x4,%esp
    2718:	5b                   	pop    %ebx
    2719:	5d                   	pop    %ebp
    271a:	c3                   	ret    
    271b:	90                   	nop
    271c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00002720 <rlc_init_enter>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void rlc_init_enter(void)
{
    2720:	55                   	push   %ebp
    2721:	89 e5                	mov    %esp,%ebp
    2723:	57                   	push   %edi
    2724:	56                   	push   %esi
    2725:	53                   	push   %ebx
    2726:	83 ec 04             	sub    $0x4,%esp
    2729:	e8 fc ff ff ff       	call   272a <rlc_init_enter+0xa>
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
    272e:	e8 fc ff ff ff       	call   272f <rlc_init_enter+0xf>
    2733:	89 c3                	mov    %eax,%ebx
	if(RLC_OPEN)
    2735:	e8 fc ff ff ff       	call   2736 <rlc_init_enter+0x16>
    273a:	83 f8 05             	cmp    $0x5,%eax
    273d:	74 09                	je     2748 <rlc_init_enter+0x28>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    273f:	83 c4 04             	add    $0x4,%esp
    2742:	5b                   	pop    %ebx
    2743:	5e                   	pop    %esi
    2744:	5f                   	pop    %edi
    2745:	5d                   	pop    %ebp
    2746:	c3                   	ret    
    2747:	90                   	nop
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
    2748:	e8 fc ff ff ff       	call   2749 <rlc_init_enter+0x29>
    274d:	85 c0                	test   %eax,%eax
    274f:	75 ee                	jne    273f <rlc_init_enter+0x1f>
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
    2751:	8d 83 f4 25 00 00    	lea    0x25f4(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2757:	89 83 f4 25 00 00    	mov    %eax,0x25f4(%ebx)
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
    275d:	8d b3 08 37 00 00    	lea    0x3708(%ebx),%esi
	list->prev = list;
    2763:	89 83 f8 25 00 00    	mov    %eax,0x25f8(%ebx)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
    2769:	8d 83 c0 36 00 00    	lea    0x36c0(%ebx),%eax
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
		INIT_LIST_HEAD(&SV(vTm_tx_ins).tmTxList);
    276f:	8d bb 2c 37 00 00    	lea    0x372c(%ebx),%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2775:	89 83 c0 36 00 00    	mov    %eax,0x36c0(%ebx)
	list->prev = list;
    277b:	89 83 c4 36 00 00    	mov    %eax,0x36c4(%ebx)
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
    2781:	8d 83 f8 36 00 00    	lea    0x36f8(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2787:	89 83 f8 36 00 00    	mov    %eax,0x36f8(%ebx)
	list->prev = list;
    278d:	89 83 fc 36 00 00    	mov    %eax,0x36fc(%ebx)
		SV(countDropPacket)=0;
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2793:	31 c0                	xor    %eax,%eax
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
    2795:	c6 83 24 02 00 00 00 	movb   $0x0,0x224(%ebx)
		SV(packetType) = -1;
    279c:	c7 83 20 02 00 00 ff 	movl   $0xffffffff,0x220(%ebx)
    27a3:	ff ff ff 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27a6:	89 b3 08 37 00 00    	mov    %esi,0x3708(%ebx)
	list->prev = list;
    27ac:	89 b3 0c 37 00 00    	mov    %esi,0x370c(%ebx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27b2:	89 bb 2c 37 00 00    	mov    %edi,0x372c(%ebx)
	list->prev = list;
    27b8:	89 bb 30 37 00 00    	mov    %edi,0x3730(%ebx)
		//mallocnum=0;
		//freenum=0;
	//	SV(pduLft).SN_Left = -1;
	//	SV(pduLft).sduLeft = NULL;
		//for test
		SV(countRecvFromUpper)=0;
    27be:	c7 83 8c 5a 00 00 00 	movl   $0x0,0x5a8c(%ebx)
    27c5:	00 00 00 
		SV(countSendToUpper)=0;
    27c8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    27cf:	00 00 00 
		SV(countRecvFromLower)=0;
    27d2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    27d9:	00 00 00 
		SV(countSentToLower)=0;
    27dc:	c7 83 98 5a 00 00 00 	movl   $0x0,0x5a98(%ebx)
    27e3:	00 00 00 
		SV(countDropPacket)=0;
    27e6:	c7 83 9c 5a 00 00 00 	movl   $0x0,0x5a9c(%ebx)
    27ed:	00 00 00 
		SV(countSendCtrlPdu)=0;
    27f0:	c7 83 a0 5a 00 00 00 	movl   $0x0,0x5aa0(%ebx)
    27f7:	00 00 00 
		SV(countRecvCtrlPdu)=0;
    27fa:	c7 83 a4 5a 00 00 00 	movl   $0x0,0x5aa4(%ebx)
    2801:	00 00 00 
		SV(max_queue_num)=0;
    2804:	c7 83 a8 5a 00 00 00 	movl   $0x0,0x5aa8(%ebx)
    280b:	00 00 00 
    280e:	66 90                	xchg   %ax,%ax
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2810:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
    2817:	83 c0 01             	add    $0x1,%eax
    281a:	83 f8 32             	cmp    $0x32,%eax
    281d:	75 f1                	jne    2810 <rlc_init_enter+0xf0>
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    281f:	c7 83 e8 02 00 00 ff 	movl   $0xffffffff,0x2e8(%ebx)
    2826:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2829:	b0 10                	mov    $0x10,%al
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    282b:	c7 83 cc 02 00 00 ff 	movl   $0xffffffff,0x2cc(%ebx)
    2832:	ff ff ff 
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
    2835:	c7 83 c8 02 00 00 ff 	movl   $0xffffffff,0x2c8(%ebx)
    283c:	ff ff ff 
    283f:	c7 83 c4 02 00 00 ff 	movl   $0xffffffff,0x2c4(%ebx)
    2846:	ff ff ff 
    2849:	c7 83 c0 02 00 00 ff 	movl   $0xffffffff,0x2c0(%ebx)
    2850:	ff ff ff 
    2853:	c7 83 bc 02 00 00 ff 	movl   $0xffffffff,0x2bc(%ebx)
    285a:	ff ff ff 
    285d:	c7 83 b8 02 00 00 ff 	movl   $0xffffffff,0x2b8(%ebx)
    2864:	ff ff ff 
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
    2867:	c7 83 b4 02 00 00 ff 	movl   $0xffffffff,0x2b4(%ebx)
    286e:	ff ff ff 
    2871:	c7 83 b0 02 00 00 ff 	movl   $0xffffffff,0x2b0(%ebx)
    2878:	ff ff ff 
    287b:	c7 83 ac 02 00 00 ff 	movl   $0xffffffff,0x2ac(%ebx)
    2882:	ff ff ff 
    2885:	c7 83 54 02 00 00 ff 	movl   $0xffffffff,0x254(%ebx)
    288c:	ff ff ff 
    288f:	c7 83 28 02 00 00 ff 	movl   $0xffffffff,0x228(%ebx)
    2896:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2899:	e8 fc ff ff ff       	call   289a <rlc_init_enter+0x17a>
		tmRxIns->pbCh = 1;            //PCCH
    289e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28a2:	8d 48 08             	lea    0x8(%eax),%ecx
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 1;            //PCCH
		tmRxIns->rnti = 0;
    28a5:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28aa:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;
    28ae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28b2:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28b8:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28be:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28c1:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    28c4:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");
    28c6:	c7 04 24 fc 05 00 00 	movl   $0x5fc,(%esp)
    28cd:	e8 fc ff ff ff       	call   28ce <rlc_init_enter+0x1ae>

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    28d2:	b8 10 00 00 00       	mov    $0x10,%eax
    28d7:	e8 fc ff ff ff       	call   28d8 <rlc_init_enter+0x1b8>
		tmRxIns->pbCh = 2;            //BCCH
    28dc:	c6 40 04 02          	movb   $0x2,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //BCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28e0:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 2;            //BCCH
		tmRxIns->rnti = 0;
    28e3:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28e8:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //BCCH
    28ec:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28f0:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28f6:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28fc:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28ff:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2902:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");
    2904:	c7 04 24 30 06 00 00 	movl   $0x630,(%esp)
    290b:	e8 fc ff ff ff       	call   290c <rlc_init_enter+0x1ec>

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2910:	b8 10 00 00 00       	mov    $0x10,%eax
    2915:	e8 fc ff ff ff       	call   2916 <rlc_init_enter+0x1f6>
		tmRxIns->pbCh = 0;            //CCCH
    291a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //CCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    291e:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 0;            //CCCH
		tmRxIns->rnti = 0;
    2921:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    2926:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //CCCH
    292a:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    292e:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2934:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    293a:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    293d:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2940:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");
    2942:	c7 04 24 64 06 00 00 	movl   $0x664,(%esp)
    2949:	e8 fc ff ff ff       	call   294a <rlc_init_enter+0x22a>

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
    294e:	b8 24 00 00 00       	mov    $0x24,%eax
    2953:	e8 fc ff ff ff       	call   2954 <rlc_init_enter+0x234>
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
    2958:	8d 50 0c             	lea    0xc(%eax),%edx
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
    295b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
		tmTxIns->tmSduBufferSize = 0;
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
    295f:	8d 48 1c             	lea    0x1c(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
    2962:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmTxIns->rbId = 0;
    2967:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmTxIns->lcId = 0;       //CCCH
    296b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    296f:	89 50 0c             	mov    %edx,0xc(%eax)
	list->prev = list;
    2972:	89 50 10             	mov    %edx,0x10(%eax)
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
    2975:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		tmTxIns->tmSduBufferSize = 0;
    297c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    2983:	8b 93 30 37 00 00    	mov    0x3730(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2989:	89 8b 30 37 00 00    	mov    %ecx,0x3730(%ebx)
	new->next = next;
    298f:	89 78 1c             	mov    %edi,0x1c(%eax)
	new->prev = prev;
    2992:	89 50 20             	mov    %edx,0x20(%eax)
	prev->next = new;
    2995:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH tran instance has bulided\n");
    2997:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    299e:	e8 fc ff ff ff       	call   299f <rlc_init_enter+0x27f>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    29a3:	83 c4 04             	add    $0x4,%esp
    29a6:	5b                   	pop    %ebx
    29a7:	5e                   	pop    %esi
    29a8:	5f                   	pop    %edi
    29a9:	5d                   	pop    %ebp
    29aa:	c3                   	ret    
    29ab:	90                   	nop
    29ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000029b0 <rlc_pkt_receive_from_upper>:
**--------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
static void rlc_pkt_receive_from_upper(void)
{
    29b0:	55                   	push   %ebp
    29b1:	89 e5                	mov    %esp,%ebp
    29b3:	83 ec 18             	sub    $0x18,%esp
    29b6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    29b9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    29bc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    29bf:	e8 fc ff ff ff       	call   29c0 <rlc_pkt_receive_from_upper+0x10>
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	
    29c4:	e8 fc ff ff ff       	call   29c5 <rlc_pkt_receive_from_upper+0x15>
    29c9:	89 c7                	mov    %eax,%edi

	skb = (FSM_PKT *)fsm_pkt_get();
    29cb:	e8 fc ff ff ff       	call   29cc <rlc_pkt_receive_from_upper+0x1c>
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
    29d0:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	

	skb = (FSM_PKT *)fsm_pkt_get();
    29d6:	89 c6                	mov    %eax,%esi
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
	fsm_printf("[RLC][rlc_pkt_receive_from_upper][-->] receive from upper, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
    29d8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    29dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    29e0:	0f b6 03             	movzbl (%ebx),%eax
    29e3:	c7 04 24 d4 06 00 00 	movl   $0x6d4,(%esp)
    29ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    29ee:	e8 fc ff ff ff       	call   29ef <rlc_pkt_receive_from_upper+0x3f>
	fsm_octets_print(skb->data,64);
    29f3:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    29f9:	ba 40 00 00 00       	mov    $0x40,%edx
    29fe:	e8 fc ff ff ff       	call   29ff <rlc_pkt_receive_from_upper+0x4f>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    2a03:	80 3b 00             	cmpb   $0x0,(%ebx)
    2a06:	75 0d                	jne    2a15 <rlc_pkt_receive_from_upper+0x65>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    2a08:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2a0b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2a0e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2a11:	89 ec                	mov    %ebp,%esp
    2a13:	5d                   	pop    %ebp
    2a14:	c3                   	ret    
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    2a15:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
    2a1c:	c7 04 24 24 07 00 00 	movl   $0x724,(%esp)
    2a23:	e8 fc ff ff ff       	call   2a24 <rlc_pkt_receive_from_upper+0x74>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    2a28:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    2a2e:	c7 04 24 74 07 00 00 	movl   $0x774,(%esp)
    2a35:	89 44 24 04          	mov    %eax,0x4(%esp)
    2a39:	e8 fc ff ff ff       	call   2a3a <rlc_pkt_receive_from_upper+0x8a>
		fsm_pkt_destroy(skb);
    2a3e:	89 f0                	mov    %esi,%eax
    2a40:	e8 fc ff ff ff       	call   2a41 <rlc_pkt_receive_from_upper+0x91>
		skb = NULL;
		FOUT;
    2a45:	eb c1                	jmp    2a08 <rlc_pkt_receive_from_upper+0x58>
    2a47:	89 f6                	mov    %esi,%esi
    2a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00002a50 <ue_mac_sv_close>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_close()
{
    2a50:	55                   	push   %ebp
    2a51:	89 e5                	mov    %esp,%ebp
    2a53:	53                   	push   %ebx
    2a54:	e8 fc ff ff ff       	call   2a55 <ue_mac_sv_close+0x5>
	FIN(ue_mac_sv_close());
	SV_PTR_GET(rlc_mac_sv);
    2a59:	e8 fc ff ff ff       	call   2a5a <ue_mac_sv_close+0xa>
    2a5e:	89 c3                	mov    %eax,%ebx
	if(SV(m_temp_cr) != NULL)
    2a60:	8b 80 a0 01 00 00    	mov    0x1a0(%eax),%eax
    2a66:	85 c0                	test   %eax,%eax
    2a68:	74 0f                	je     2a79 <ue_mac_sv_close+0x29>
	{
		fsm_mem_free(SV(m_temp_cr));
    2a6a:	e8 fc ff ff ff       	call   2a6b <ue_mac_sv_close+0x1b>
		SV(m_temp_cr) = NULL;
    2a6f:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    2a76:	00 00 00 
	}
	Free_Uemac_Scheduler_Resource();
    2a79:	e8 fc ff ff ff       	call   2a7a <ue_mac_sv_close+0x2a>
	if(SV(msg3_buf_ptr)!=NULL)
    2a7e:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    2a84:	85 c0                	test   %eax,%eax
    2a86:	74 0f                	je     2a97 <ue_mac_sv_close+0x47>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));
    2a88:	e8 fc ff ff ff       	call   2a89 <ue_mac_sv_close+0x39>
		SV(msg3_buf_ptr)=NULL;
    2a8d:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    2a94:	00 00 00 
	}
	FOUT;
}
    2a97:	5b                   	pop    %ebx
    2a98:	5d                   	pop    %ebp
    2a99:	c3                   	ret    
    2a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00002aa0 <SendRaPreamble>:
->output:
->Special:
*******************************
*/
static void SendRaPreamble(RACH_ConfigDedicated *randomaccess_info)
{
    2aa0:	55                   	push   %ebp
    2aa1:	89 e5                	mov    %esp,%ebp
    2aa3:	53                   	push   %ebx
    2aa4:	83 ec 04             	sub    $0x4,%esp
    2aa7:	e8 fc ff ff ff       	call   2aa8 <SendRaPreamble+0x8>
    2aac:	89 c3                	mov    %eax,%ebx
	FIN(SendRaPreamble());
	//modified by HQ
	fsm_printf("[UEMAC][sendrapreamble]run here,start send RAP \n");//testing code
    2aae:	c7 04 24 c0 07 00 00 	movl   $0x7c0,(%esp)
    2ab5:	e8 fc ff ff ff       	call   2ab6 <SendRaPreamble+0x16>
	//fsm_octets_print(randomaccess_info,sizeof(RACH_ConfigDedicated));// for test
	fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_Preamble_Indicate, (void*)randomaccess_info , sizeof(randomaccess_info));
    2aba:	89 d9                	mov    %ebx,%ecx
    2abc:	ba 25 00 00 00       	mov    $0x25,%edx
    2ac1:	b8 03 00 00 00       	mov    $0x3,%eax
    2ac6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    2acd:	e8 fc ff ff ff       	call   2ace <SendRaPreamble+0x2e>
	//send the information of random access to PHYadapter
	fsm_mem_free(randomaccess_info);//20140722 modified by lhl IOCTL
    2ad2:	89 d8                	mov    %ebx,%eax
    2ad4:	e8 fc ff ff ff       	call   2ad5 <SendRaPreamble+0x35>
	FOUT;
 }
    2ad9:	83 c4 04             	add    $0x4,%esp
    2adc:	5b                   	pop    %ebx
    2add:	5d                   	pop    %ebp
    2ade:	c3                   	ret    
    2adf:	90                   	nop

00002ae0 <ioctrl_handler>:
->output:
->Special:
*******************************
*/
static void ioctrl_handler()
{
    2ae0:	55                   	push   %ebp
    2ae1:	89 e5                	mov    %esp,%ebp
    2ae3:	83 ec 18             	sub    $0x18,%esp
    2ae6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    2ae9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    2aec:	89 7d fc             	mov    %edi,-0x4(%ebp)
    2aef:	e8 fc ff ff ff       	call   2af0 <ioctrl_handler+0x10>
	UEPHY_TO_MAC_ULgrant *tempulgrant;
	u32 rar_failed_times;//201501
	u32 contention_failed_times;//201501
	FIN(ioctrl_handler());

	SV_PTR_GET(rlc_mac_sv);
    2af4:	e8 fc ff ff ff       	call   2af5 <ioctrl_handler+0x15>
    2af9:	89 c6                	mov    %eax,%esi

	int cmd_value=fsm_ev_ioctrl_cmd();
    2afb:	e8 fc ff ff ff       	call   2afc <ioctrl_handler+0x1c>

	switch(cmd_value)
    2b00:	3d 87 00 00 00       	cmp    $0x87,%eax
    2b05:	76 21                	jbe    2b28 <ioctrl_handler+0x48>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
			
			
			break;
		default:
			fsm_printf("[RLC_MAC] unidentified ioctrl command!\n");
    2b07:	c7 04 24 b4 0b 00 00 	movl   $0xbb4,(%esp)
    2b0e:	e8 fc ff ff ff       	call   2b0f <ioctrl_handler+0x2f>
    2b13:	90                   	nop
    2b14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		
/**/
	}	
	FOUT;
}
    2b18:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2b1b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2b1e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2b21:	89 ec                	mov    %ebp,%esp
    2b23:	5d                   	pop    %ebp
    2b24:	c3                   	ret    
    2b25:	8d 76 00             	lea    0x0(%esi),%esi

	SV_PTR_GET(rlc_mac_sv);

	int cmd_value=fsm_ev_ioctrl_cmd();

	switch(cmd_value)
    2b28:	ff 24 85 e0 00 00 00 	jmp    *0xe0(,%eax,4)
    2b2f:	90                   	nop
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
		break;
		case TEST_RECV_SYS :  
			fsm_printf("[MAC][RECVSYS]\n");
    2b30:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
    2b37:	e8 fc ff ff ff       	call   2b38 <ioctrl_handler+0x58>
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
    2b3c:	31 c9                	xor    %ecx,%ecx
    2b3e:	ba 26 00 00 00       	mov    $0x26,%edx
    2b43:	b8 03 00 00 00       	mov    $0x3,%eax
    2b48:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2b4f:	e8 fc ff ff ff       	call   2b50 <ioctrl_handler+0x70>
		//ioctrlRNTI
		break;
    2b54:	eb c2                	jmp    2b18 <ioctrl_handler+0x38>
    2b56:	66 90                	xchg   %ax,%ax
			test_print_pkt_num();
		break;

		/***************** RLC ioctl_handler ******************/
		case CRLC_CONFIG_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
    2b58:	c7 04 24 8c 0a 00 00 	movl   $0xa8c,(%esp)
    2b5f:	e8 fc ff ff ff       	call   2b60 <ioctrl_handler+0x80>
			PCRLC_CONFIG_REQ();
    2b64:	e8 fc ff ff ff       	call   2b65 <ioctrl_handler+0x85>
			FOUT;
    2b69:	eb ad                	jmp    2b18 <ioctrl_handler+0x38>
    2b6b:	90                   	nop
    2b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
		//ioctrlRNTI
		break;
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
    2b70:	c7 04 24 d4 00 00 00 	movl   $0xd4,(%esp)
    2b77:	e8 fc ff ff ff       	call   2b78 <ioctrl_handler+0x98>
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
    2b7c:	31 c9                	xor    %ecx,%ecx
    2b7e:	ba 46 00 00 00       	mov    $0x46,%edx
    2b83:	b8 03 00 00 00       	mov    $0x3,%eax
    2b88:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2b8f:	e8 fc ff ff ff       	call   2b90 <ioctrl_handler+0xb0>
		break;
    2b94:	eb 82                	jmp    2b18 <ioctrl_handler+0x38>
    2b96:	66 90                	xchg   %ax,%ax
			SV(RetxBSRTimer.time_value)	= SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer);
			SV(RetxBSRTimer.timer_sign) = fsm_schedule_self(SV(RetxBSRTimer.time_value), RexBSRTimer_Expire);
			SV(RetxBSRTimer.flag)= true;*/ 	//noted in 20151228
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
    2b98:	ba 0b 00 00 00       	mov    $0xb,%edx
    2b9d:	b8 64 00 00 00       	mov    $0x64,%eax
    2ba2:	e8 fc ff ff ff       	call   2ba3 <ioctrl_handler+0xc3>
		break;
    2ba7:	e9 6c ff ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
*/
static void handle_HARQ_feedback()
{
	void *tmpdata_ptr;	
	FIN(handle_HARQ_feedback());
	SV_PTR_GET(rlc_mac_sv);
    2bb0:	e8 fc ff ff ff       	call   2bb1 <ioctrl_handler+0xd1>
    2bb5:	89 c6                	mov    %eax,%esi
	HARQ_statu_parameters ACK_statu={0,true,0};
	tmpdata_ptr = fsm_data_get();
    2bb7:	e8 fc ff ff ff       	call   2bb8 <ioctrl_handler+0xd8>
	if( ((struct HARQ_feedback*)tmpdata_ptr)->HARQ_FEEDBACK == true )
    2bbc:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
    2bc0:	74 31                	je     2bf3 <ioctrl_handler+0x113>
	{
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].avaiable_flag = true;
    2bc2:	8b 10                	mov    (%eax),%edx
    2bc4:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bc7:	c6 44 96 38 01       	movb   $0x1,0x38(%esi,%edx,4)
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].HARQ_buffer_pointer = NULL;
    2bcc:	8b 10                	mov    (%eax),%edx
    2bce:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bd1:	c7 44 96 44 00 00 00 	movl   $0x0,0x44(%esi,%edx,4)
    2bd8:	00 
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].statu=ACK_statu;
    2bd9:	8b 10                	mov    (%eax),%edx
    2bdb:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bde:	8d 4c 96 30          	lea    0x30(%esi,%edx,4),%ecx
    2be2:	66 c7 41 0c 00 00    	movw   $0x0,0xc(%ecx)
    2be8:	c6 41 0e 01          	movb   $0x1,0xe(%ecx)
    2bec:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
    2bf3:	e8 fc ff ff ff       	call   2bf4 <ioctrl_handler+0x114>
		break;
    2bf8:	e9 1b ff ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2bfd:	8d 76 00             	lea    0x0(%esi),%esi
*/
static void ue_mac_lc_release()
{
	void *tmpdata_ptr;
	FIN(ue_mac_lc_release());
	tmpdata_ptr = fsm_data_get();
    2c00:	e8 fc ff ff ff       	call   2c01 <ioctrl_handler+0x121>
    2c05:	89 c6                	mov    %eax,%esi
	Delete_LogicalChannel_ConfigInfo(*((unsigned char *)tmpdata_ptr));
    2c07:	0f b6 00             	movzbl (%eax),%eax
    2c0a:	e8 fc ff ff ff       	call   2c0b <ioctrl_handler+0x12b>
	fsm_data_destroy(tmpdata_ptr);
    2c0f:	89 f0                	mov    %esi,%eax
    2c11:	e8 fc ff ff ff       	call   2c12 <ioctrl_handler+0x132>
    2c16:	e9 fd fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c1b:	90                   	nop
    2c1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
			ue_mac_rach_config();
		break;
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
    2c20:	c7 04 24 ac 08 00 00 	movl   $0x8ac,(%esp)
    2c27:	e8 fc ff ff ff       	call   2c28 <ioctrl_handler+0x148>
*/
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    2c2c:	b8 15 00 00 00       	mov    $0x15,%eax
    2c31:	e8 fc ff ff ff       	call   2c32 <ioctrl_handler+0x152>
    2c36:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2c38:	e8 fc ff ff ff       	call   2c39 <ioctrl_handler+0x159>
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2c3d:	b9 15 00 00 00       	mov    $0x15,%ecx
    2c42:	89 c2                	mov    %eax,%edx
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	tmpdata_ptr = fsm_data_get();	
    2c44:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2c46:	89 f0                	mov    %esi,%eax
    2c48:	e8 fc ff ff ff       	call   2c49 <ioctrl_handler+0x169>
	fsm_data_destroy(tmpdata_ptr);//
    2c4d:	89 f8                	mov    %edi,%eax
    2c4f:	e8 fc ff ff ff       	call   2c50 <ioctrl_handler+0x170>
	Init_LogicalChannel_ConfigInfo(lc_configinfo);//lc_configinfo 20140506
    2c54:	89 f0                	mov    %esi,%eax
    2c56:	e8 fc ff ff ff       	call   2c57 <ioctrl_handler+0x177>
	//fsm_printf("[UEMAC][logch_config]LCID:%d, ",lc_configinfo->logicalChannelIdentity);
	//fsm_printf("[UEMAC][logch_config]RRC TO MAC:LCGROUP:%d\n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup);
	//fsm_printf("[UEMAC][logch_config]prioritisedBitRate: %d \n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate);
	fsm_mem_free(lc_configinfo);	
    2c5b:	89 f0                	mov    %esi,%eax
    2c5d:	e8 fc ff ff ff       	call   2c5e <ioctrl_handler+0x17e>
    2c62:	e9 b1 fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c67:	90                   	nop
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
			ue_mac_PCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_SPS  : 
			fsm_printf("[UEMAC][RRCTOMAC_spsconfig]rrctomac_spsconfig\n");
    2c68:	c7 04 24 44 09 00 00 	movl   $0x944,(%esp)
    2c6f:	e8 fc ff ff ff       	call   2c70 <ioctrl_handler+0x190>
*/
static void ue_mac_SPS_Config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_SPS_Config());
	SV_PTR_GET(rlc_mac_sv);
    2c74:	e8 fc ff ff ff       	call   2c75 <ioctrl_handler+0x195>
    2c79:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();
    2c7b:	e8 fc ff ff ff       	call   2c7c <ioctrl_handler+0x19c>
	SV(systemconfigInfo.SPSConfigInfo)= *((struct SPS_Config*)tmpdata_ptr); //ioctrl //
    2c80:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    2c86:	b9 11 00 00 00       	mov    $0x11,%ecx
    2c8b:	89 c6                	mov    %eax,%esi
    2c8d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2c8f:	e8 fc ff ff ff       	call   2c90 <ioctrl_handler+0x1b0>
    2c94:	e9 7f fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		break;
		case IOCCMD_PDCCHtoMAC_ULGRANT : //PHYPDCCHUL_grantDCI,MAC
		//MACul_grant 
		//MSG4
			
			tempdata_ptr = fsm_data_get();
    2ca0:	e8 fc ff ff ff       	call   2ca1 <ioctrl_handler+0x1c1>
    2ca5:	89 c7                	mov    %eax,%edi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
    2ca7:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    2cab:	66 89 46 0a          	mov    %ax,0xa(%esi)
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
    2caf:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    2cb3:	66 89 46 0c          	mov    %ax,0xc(%esi)
			if(tempulgrant->m_rnti == SV(C_RNTI))
    2cb7:	0f b7 06             	movzwl (%esi),%eax
    2cba:	66 39 07             	cmp    %ax,(%edi)
    2cbd:	0f 84 ed 03 00 00    	je     30b0 <ioctrl_handler+0x5d0>
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
    2cc3:	66 85 c0             	test   %ax,%ax
    2cc6:	74 28                	je     2cf0 <ioctrl_handler+0x210>
    2cc8:	8b 86 ec 01 00 00    	mov    0x1ec(%esi),%eax
    2cce:	85 c0                	test   %eax,%eax
    2cd0:	74 1e                	je     2cf0 <ioctrl_handler+0x210>
    2cd2:	8b 86 f0 01 00 00    	mov    0x1f0(%esi),%eax
    2cd8:	85 c0                	test   %eax,%eax
    2cda:	0f 84 df 03 00 00    	je     30bf <ioctrl_handler+0x5df>
    2ce0:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    2ce7:	0f 84 fc 03 00 00    	je     30e9 <ioctrl_handler+0x609>
    2ced:	8d 76 00             	lea    0x0(%esi),%esi
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2cf0:	8b 47 06             	mov    0x6(%edi),%eax
    2cf3:	e8 fc ff ff ff       	call   2cf4 <ioctrl_handler+0x214>
			//fsm_printf("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d\n",SV(UL_resource_info.m_tbsize));
			//printk("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d, ul_sched_count:%d\n",SV(UL_resource_info.m_tbsize),++ul_sched_count);
			//SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(*((int *)tempdata_ptr)); //UL_grant 
			// ul_grant retxBSR-Timer 36321-80c 5.4.5
			SV(UL_resource_info.resource_flag) = true;
    2cf8:	c6 46 28 01          	movb   $0x1,0x28(%esi)

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    2cfc:	89 c2                	mov    %eax,%edx
    2cfe:	c1 ea 03             	shr    $0x3,%edx
    2d01:	89 96 f4 01 00 00    	mov    %edx,0x1f4(%esi)
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2d07:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2d0d:	89 46 2c             	mov    %eax,0x2c(%esi)
			SV(UL_resource_info.resource_flag) = true;

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2d10:	8d 4a 05             	lea    0x5(%edx),%ecx
    2d13:	39 4a 05             	cmp    %ecx,0x5(%edx)
    2d16:	74 0a                	je     2d22 <ioctrl_handler+0x242>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    2d18:	e8 fc ff ff ff       	call   2d19 <ioctrl_handler+0x239>
    2d1d:	e8 fc ff ff ff       	call   2d1e <ioctrl_handler+0x23e>
				SV(UL_resource_info.resource_flag)=false;
    2d22:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    2d26:	e9 ed fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2d2b:	90                   	nop
    2d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
			TATimer_config();//RRCTA 
		break;
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
    2d30:	c7 04 24 44 08 00 00 	movl   $0x844,(%esp)
    2d37:	e8 fc ff ff ff       	call   2d38 <ioctrl_handler+0x258>
*/
static void ue_mac_main_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_main_config());
	SV_PTR_GET(rlc_mac_sv);
    2d3c:	e8 fc ff ff ff       	call   2d3d <ioctrl_handler+0x25d>
    2d41:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();	
    2d43:	e8 fc ff ff ff       	call   2d44 <ioctrl_handler+0x264>
	SV(systemconfigInfo.MACMainConfigInfo) = *((struct MAC_MainConfig*)tmpdata_ptr); //ioctrl
    2d48:	83 c7 5c             	add    $0x5c,%edi
    2d4b:	b9 14 00 00 00       	mov    $0x14,%ecx
    2d50:	89 c6                	mov    %eax,%esi
    2d52:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2d54:	e8 fc ff ff ff       	call   2d55 <ioctrl_handler+0x275>
    2d59:	e9 ba fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2d5e:	66 90                	xchg   %ax,%ax
}

static void test_print_pkt_num()
{
	FIN(test_print_pkt_num());
	SV_PTR_GET(rlc_mac_sv);
    2d60:	e8 fc ff ff ff       	call   2d61 <ioctrl_handler+0x281>
    2d65:	89 c6                	mov    %eax,%esi
	printk("[UEMAC]uplink lost pkt num:%d\n",SV(lost_pkt_num_uplink));
    2d67:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
    2d6d:	c7 04 24 04 0a 00 00 	movl   $0xa04,(%esp)
    2d74:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d78:	e8 fc ff ff ff       	call   2d79 <ioctrl_handler+0x299>
	printk("[UEMAC]uplink total pkt num:%d\n",SV(pkt_num_uplink));
    2d7d:	8b 86 08 02 00 00    	mov    0x208(%esi),%eax
    2d83:	c7 04 24 24 0a 00 00 	movl   $0xa24,(%esp)
    2d8a:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d8e:	e8 fc ff ff ff       	call   2d8f <ioctrl_handler+0x2af>
	printk("[UEMAC]downlink lost pkt num:%d\n",SV(lost_pkt_num_downlink));
    2d93:	8b 86 0c 02 00 00    	mov    0x20c(%esi),%eax
    2d99:	c7 04 24 44 0a 00 00 	movl   $0xa44,(%esp)
    2da0:	89 44 24 04          	mov    %eax,0x4(%esp)
    2da4:	e8 fc ff ff ff       	call   2da5 <ioctrl_handler+0x2c5>
	printk("[UEMAC]downlink total pkt num:%d\n",SV(pkt_num_downlink));
    2da9:	8b 86 10 02 00 00    	mov    0x210(%esi),%eax
    2daf:	c7 04 24 68 0a 00 00 	movl   $0xa68,(%esp)
    2db6:	89 44 24 04          	mov    %eax,0x4(%esp)
    2dba:	e8 fc ff ff ff       	call   2dbb <ioctrl_handler+0x2db>
    2dbf:	e9 54 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
		break;
		case _IOCTLtoUEMAC_Contention_Failed:
			tempdata_ptr = fsm_data_get();
    2dc8:	e8 fc ff ff ff       	call   2dc9 <ioctrl_handler+0x2e9>
			contention_failed_times=*((u32 *)tempdata_ptr);
    2dcd:	8b 10                	mov    (%eax),%edx
			SV(contention_failed_num)=contention_failed_times;
    2dcf:	89 96 00 02 00 00    	mov    %edx,0x200(%esi)
			fsm_data_destroy(tempdata_ptr);
    2dd5:	e8 fc ff ff ff       	call   2dd6 <ioctrl_handler+0x2f6>
		break;
    2dda:	e9 39 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2ddf:	90                   	nop
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
    2de0:	e8 fc ff ff ff       	call   2de1 <ioctrl_handler+0x301>
			rar_failed_times=*((u32 *)tempdata_ptr);
    2de5:	8b 10                	mov    (%eax),%edx
			SV(rar_failed_num)=rar_failed_times;
    2de7:	89 96 fc 01 00 00    	mov    %edx,0x1fc(%esi)
    2ded:	e9 01 fe ff ff       	jmp    2bf3 <ioctrl_handler+0x113>
    2df2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
			PCRLC_RESUME_REQ();
			FOUT;
			break;
		case  PRLC_DISC_REQ:
			PPRLC_DISC_REQ();
    2df8:	e8 fc ff ff ff       	call   2df9 <ioctrl_handler+0x319>
			FOUT;
    2dfd:	e9 16 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
			PCRLC_CONFIG_REQ();
			FOUT;
			break;
		case CRLC_BULID_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
    2e08:	c7 04 24 c8 0a 00 00 	movl   $0xac8,(%esp)
    2e0f:	e8 fc ff ff ff       	call   2e10 <ioctrl_handler+0x330>
			PCRLC_BULID_REQ();
    2e14:	e8 fc ff ff ff       	call   2e15 <ioctrl_handler+0x335>
			FOUT;
    2e19:	e9 fa fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e1e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
			PCRLC_SUSPEND_REQ();
			FOUT;
			break;
		case CRLC_RESUME_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
    2e20:	c7 04 24 78 0b 00 00 	movl   $0xb78,(%esp)
    2e27:	e8 fc ff ff ff       	call   2e28 <ioctrl_handler+0x348>
			PCRLC_RESUME_REQ();
    2e2c:	e8 fc ff ff ff       	call   2e2d <ioctrl_handler+0x34d>
			FOUT;
    2e31:	e9 e2 fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e36:	66 90                	xchg   %ax,%ax
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
			PCRLC_DEACT_REQ();
			FOUT;
			break;
		case CRLC_SUSPEND_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
    2e38:	c7 04 24 3c 0b 00 00 	movl   $0xb3c,(%esp)
    2e3f:	e8 fc ff ff ff       	call   2e40 <ioctrl_handler+0x360>
			PCRLC_SUSPEND_REQ();
    2e44:	e8 fc ff ff ff       	call   2e45 <ioctrl_handler+0x365>
			FOUT;
    2e49:	e9 ca fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e4e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
			PCRLC_BULID_REQ();
			FOUT;
			break;
		case CRLC_DEACT_REQ:
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
    2e50:	c7 04 24 00 0b 00 00 	movl   $0xb00,(%esp)
    2e57:	e8 fc ff ff ff       	call   2e58 <ioctrl_handler+0x378>
			PCRLC_DEACT_REQ();
    2e5c:	e8 fc ff ff ff       	call   2e5d <ioctrl_handler+0x37d>
			FOUT;
    2e61:	e9 b2 fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e66:	66 90                	xchg   %ax,%ax
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
			ue_mac_main_config(); 
		break;
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
    2e68:	c7 04 24 78 08 00 00 	movl   $0x878,(%esp)
    2e6f:	e8 fc ff ff ff       	call   2e70 <ioctrl_handler+0x390>
*/
static void ue_mac_rach_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_rach_config());
	SV_PTR_GET(rlc_mac_sv);
    2e74:	e8 fc ff ff ff       	call   2e75 <ioctrl_handler+0x395>
    2e79:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();
    2e7b:	e8 fc ff ff ff       	call   2e7c <ioctrl_handler+0x39c>
	//ioctrl
	SV(systemconfigInfo.RACHCommonConfigInfo) = *((struct RachConfigCommon*)tmpdata_ptr); 
    2e80:	8b 10                	mov    (%eax),%edx
    2e82:	89 96 ac 00 00 00    	mov    %edx,0xac(%esi)
    2e88:	8b 50 04             	mov    0x4(%eax),%edx
    2e8b:	89 96 b0 00 00 00    	mov    %edx,0xb0(%esi)
    2e91:	8b 50 08             	mov    0x8(%eax),%edx
    2e94:	89 96 b4 00 00 00    	mov    %edx,0xb4(%esi)
    2e9a:	8b 50 0c             	mov    0xc(%eax),%edx
    2e9d:	89 96 b8 00 00 00    	mov    %edx,0xb8(%esi)
    2ea3:	8b 50 10             	mov    0x10(%eax),%edx
    2ea6:	89 96 bc 00 00 00    	mov    %edx,0xbc(%esi)
    2eac:	8b 50 14             	mov    0x14(%eax),%edx
    2eaf:	89 96 c0 00 00 00    	mov    %edx,0xc0(%esi)
    2eb5:	8b 50 18             	mov    0x18(%eax),%edx
    2eb8:	89 96 c4 00 00 00    	mov    %edx,0xc4(%esi)
    2ebe:	8b 50 1c             	mov    0x1c(%eax),%edx
    2ec1:	89 96 c8 00 00 00    	mov    %edx,0xc8(%esi)
    2ec7:	8b 50 20             	mov    0x20(%eax),%edx
    2eca:	89 96 cc 00 00 00    	mov    %edx,0xcc(%esi)
    2ed0:	8b 50 24             	mov    0x24(%eax),%edx
    2ed3:	89 96 d0 00 00 00    	mov    %edx,0xd0(%esi)
    2ed9:	8b 50 28             	mov    0x28(%eax),%edx
    2edc:	89 96 d4 00 00 00    	mov    %edx,0xd4(%esi)
	//fsm_mem_cpy(&(SV(systemconfigInfo.RACHCommonConfigInfo)), tmpdata_ptr, sizeof(struct RachConfigCommon));
	//fsm_printf("[UEMAC][rach_config]maxHARQ_Msg3Tx :%d ",	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx) );//testing code
	//fsm_printf("[UEMAC][rach_config]mac_ContentionResolutionTimer : %d \n",SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer));
	fsm_data_destroy(tmpdata_ptr);//
    2ee2:	e8 fc ff ff ff       	call   2ee3 <ioctrl_handler+0x403>
    2ee7:	e9 2c fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
			//ioctrl
		break ;
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
    2ef0:	c7 04 24 f4 07 00 00 	movl   $0x7f4,(%esp)
    2ef7:	e8 fc ff ff ff       	call   2ef8 <ioctrl_handler+0x418>
*/
static void TATimer_config() 
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
    2efc:	e8 fc ff ff ff       	call   2efd <ioctrl_handler+0x41d>
    2f01:	89 c6                	mov    %eax,%esi
	int time;
	tmpdata_ptr = fsm_data_get();
    2f03:	e8 fc ff ff ff       	call   2f04 <ioctrl_handler+0x424>
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2f08:	b9 04 00 00 00       	mov    $0x4,%ecx
    2f0d:	89 c2                	mov    %eax,%edx
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
    2f0f:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2f11:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2f14:	e8 fc ff ff ff       	call   2f15 <ioctrl_handler+0x435>
	SV(TA_Periodic_time)=time;//LHL 20141021
    2f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2f1c:	80 be 68 01 00 00 00 	cmpb   $0x0,0x168(%esi)
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
	SV(TA_Periodic_time)=time;//LHL 20141021
    2f23:	89 46 24             	mov    %eax,0x24(%esi)
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2f26:	74 3a                	je     2f62 <ioctrl_handler+0x482>
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
    2f28:	c7 04 24 1c 08 00 00 	movl   $0x81c,(%esp)
    2f2f:	e8 fc ff ff ff       	call   2f30 <ioctrl_handler+0x450>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    2f34:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
    2f3a:	e8 fc ff ff ff       	call   2f3b <ioctrl_handler+0x45b>
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2f3f:	8b 46 24             	mov    0x24(%esi),%eax
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2f42:	ba 0b 00 00 00       	mov    $0xb,%edx
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
		SV(TATimer.flag)=true;
    2f47:	c6 86 68 01 00 00 01 	movb   $0x1,0x168(%esi)
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2f4e:	89 86 60 01 00 00    	mov    %eax,0x160(%esi)
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2f54:	6b c0 64             	imul   $0x64,%eax,%eax
    2f57:	e8 fc ff ff ff       	call   2f58 <ioctrl_handler+0x478>
    2f5c:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
		//SV(TA_timer_flag)=0;
	}//  
	fsm_data_destroy(tmpdata_ptr);
    2f62:	89 f8                	mov    %edi,%eax
    2f64:	e8 fc ff ff ff       	call   2f65 <ioctrl_handler+0x485>
    2f69:	e9 aa fb ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2f6e:	66 90                	xchg   %ax,%ax
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
			//ioctrlRNTI
		break;
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
    2f70:	31 c9                	xor    %ecx,%ecx
    2f72:	ba 27 00 00 00       	mov    $0x27,%edx
    2f77:	b8 03 00 00 00       	mov    $0x3,%eax
    2f7c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2f83:	e8 fc ff ff ff       	call   2f84 <ioctrl_handler+0x4a4>
			//ioctrl
		break ;
    2f88:	e9 8b fb ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2f8d:	8d 76 00             	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] MRLC_TRANSOP_IND  has received\n");
			PMRLC_TRANSOP_IND();
			FOUT;
			break;*/ //noted in 20150804
		case PRINTRLC:
			printk("\ncountRecvFromUpper =%d\n",SV(countRecvFromUpper));
    2f90:	8b 86 8c 5a 00 00    	mov    0x5a8c(%esi),%eax
    2f96:	c7 04 24 e4 00 00 00 	movl   $0xe4,(%esp)
    2f9d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fa1:	e8 fc ff ff ff       	call   2fa2 <ioctrl_handler+0x4c2>
			printk("countSentToLower =%d\n",SV(countSentToLower));
    2fa6:	8b 86 98 5a 00 00    	mov    0x5a98(%esi),%eax
    2fac:	c7 04 24 fd 00 00 00 	movl   $0xfd,(%esp)
    2fb3:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fb7:	e8 fc ff ff ff       	call   2fb8 <ioctrl_handler+0x4d8>
			printk("countSendToUpper =%d\n",SV(countSendToUpper));
    2fbc:	8b 86 90 5a 00 00    	mov    0x5a90(%esi),%eax
    2fc2:	c7 04 24 13 01 00 00 	movl   $0x113,(%esp)
    2fc9:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fcd:	e8 fc ff ff ff       	call   2fce <ioctrl_handler+0x4ee>
			printk("countRecvFromLower =%d\n",SV(countRecvFromLower));
    2fd2:	8b 86 94 5a 00 00    	mov    0x5a94(%esi),%eax
    2fd8:	c7 04 24 29 01 00 00 	movl   $0x129,(%esp)
    2fdf:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fe3:	e8 fc ff ff ff       	call   2fe4 <ioctrl_handler+0x504>
			printk("countSendCtrlPdu =%d\n",SV(countSendCtrlPdu));
    2fe8:	8b 86 a0 5a 00 00    	mov    0x5aa0(%esi),%eax
    2fee:	c7 04 24 41 01 00 00 	movl   $0x141,(%esp)
    2ff5:	89 44 24 04          	mov    %eax,0x4(%esp)
    2ff9:	e8 fc ff ff ff       	call   2ffa <ioctrl_handler+0x51a>
			printk("countRecvCtrlPdu =%d\n",SV(countRecvCtrlPdu));
    2ffe:	8b 86 a4 5a 00 00    	mov    0x5aa4(%esi),%eax
    3004:	c7 04 24 57 01 00 00 	movl   $0x157,(%esp)
    300b:	89 44 24 04          	mov    %eax,0x4(%esp)
    300f:	e8 fc ff ff ff       	call   3010 <ioctrl_handler+0x530>
			printk("countDropPacket =%d\n\n",SV(countDropPacket));
    3014:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    301a:	c7 04 24 6d 01 00 00 	movl   $0x16d,(%esp)
    3021:	89 44 24 04          	mov    %eax,0x4(%esp)
    3025:	e8 fc ff ff ff       	call   3026 <ioctrl_handler+0x546>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
    302a:	8b 86 a8 5a 00 00    	mov    0x5aa8(%esi),%eax
    3030:	c7 04 24 83 01 00 00 	movl   $0x183,(%esp)
    3037:	89 44 24 04          	mov    %eax,0x4(%esp)
    303b:	e8 fc ff ff ff       	call   303c <ioctrl_handler+0x55c>
			
			
			break;
    3040:	e9 d3 fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    3045:	8d 76 00             	lea    0x0(%esi),%esi
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
			ue_mac_BCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
    3048:	c7 04 24 10 09 00 00 	movl   $0x910,(%esp)
    304f:	e8 fc ff ff ff       	call   3050 <ioctrl_handler+0x570>
*/
static void ue_mac_PCCH_config()
{
	void *tmpdata_ptr;	
	FIN( ue_mac_PCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    3054:	e8 fc ff ff ff       	call   3055 <ioctrl_handler+0x575>
    3059:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();		
    305b:	e8 fc ff ff ff       	call   305c <ioctrl_handler+0x57c>
	SV(systemconfigInfo.PCCHConfigInfo) = *((struct PCCH_Config*)tmpdata_ptr);  //ioctrl
    3060:	8b 08                	mov    (%eax),%ecx
    3062:	8b 58 04             	mov    0x4(%eax),%ebx
    3065:	89 8e d8 00 00 00    	mov    %ecx,0xd8(%esi)
    306b:	89 9e dc 00 00 00    	mov    %ebx,0xdc(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    3071:	e8 fc ff ff ff       	call   3072 <ioctrl_handler+0x592>
    3076:	e9 9d fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    307b:	90                   	nop
    307c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
			ue_mac_logCh_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
    3080:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp)
    3087:	e8 fc ff ff ff       	call   3088 <ioctrl_handler+0x5a8>
*/
static void ue_mac_BCCH_config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_BCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    308c:	e8 fc ff ff ff       	call   308d <ioctrl_handler+0x5ad>
    3091:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    3093:	e8 fc ff ff ff       	call   3094 <ioctrl_handler+0x5b4>
	SV(systemconfigInfo.BCCHConfigInfo)= *((struct BCCH_Config*)tmpdata_ptr);  //ioctrl 
    3098:	8b 10                	mov    (%eax),%edx
    309a:	89 96 e0 00 00 00    	mov    %edx,0xe0(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    30a0:	e8 fc ff ff ff       	call   30a1 <ioctrl_handler+0x5c1>
    30a5:	e9 6e fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    30aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
    30b0:	c7 86 f0 01 00 00 01 	movl   $0x1,0x1f0(%esi)
    30b7:	00 00 00 
    30ba:	e9 04 fc ff ff       	jmp    2cc3 <ioctrl_handler+0x1e3>
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
				fsm_schedule_self(0, Contention_Success );
			}
			else if(SV(C_RNTI) && SV(sendmsg3) && !SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )
    30bf:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    30c6:	0f 85 24 fc ff ff    	jne    2cf0 <ioctrl_handler+0x210>
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
    30cc:	c7 04 24 c0 09 00 00 	movl   $0x9c0,(%esp)
    30d3:	e8 fc ff ff ff       	call   30d4 <ioctrl_handler+0x5f4>
				fsm_schedule_self(0, ContentionResolution_Fail );
    30d8:	ba 05 00 00 00       	mov    $0x5,%edx
    30dd:	31 c0                	xor    %eax,%eax
    30df:	e8 fc ff ff ff       	call   30e0 <ioctrl_handler+0x600>
    30e4:	e9 07 fc ff ff       	jmp    2cf0 <ioctrl_handler+0x210>
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
    30e9:	c7 04 24 74 09 00 00 	movl   $0x974,(%esp)
    30f0:	e8 fc ff ff ff       	call   30f1 <ioctrl_handler+0x611>
				fsm_schedule_self(0, Contention_Success );
    30f5:	ba 06 00 00 00       	mov    $0x6,%edx
    30fa:	31 c0                	xor    %eax,%eax
    30fc:	e8 fc ff ff ff       	call   30fd <ioctrl_handler+0x61d>
    3101:	e9 ea fb ff ff       	jmp    2cf0 <ioctrl_handler+0x210>
    3106:	8d 76 00             	lea    0x0(%esi),%esi
    3109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003110 <doStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
static void doStartContentionBasedRandomAccessProcedure() //modified by HQ  20140419
{
    3110:	55                   	push   %ebp
    3111:	89 e5                	mov    %esp,%ebp
    3113:	83 ec 18             	sub    $0x18,%esp
    3116:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3119:	89 75 f8             	mov    %esi,-0x8(%ebp)
    311c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    311f:	e8 fc ff ff ff       	call   3120 <doStartContentionBasedRandomAccessProcedure+0x10>
	FIN(doStartContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    3124:	e8 fc ff ff ff       	call   3125 <doStartContentionBasedRandomAccessProcedure+0x15>
    3129:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated));
    312b:	b8 02 00 00 00       	mov    $0x2,%eax
    3130:	e8 fc ff ff ff       	call   3131 <doStartContentionBasedRandomAccessProcedure+0x21>
    3135:	89 c6                	mov    %eax,%esi
	int mg3_buffer;
	//print_tran_info("[UEMAC][contention_ra]startCRA IDLE -> CRA");//testing code
	if(SV(PREAMBLE_TRANSMISSION_COUNTER )== 0)   //
    3137:	8b 43 14             	mov    0x14(%ebx),%eax
    313a:	85 c0                	test   %eax,%eax
    313c:	75 10                	jne    314e <doStartContentionBasedRandomAccessProcedure+0x3e>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
    313e:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    3145:	b0 01                	mov    $0x1,%al
    3147:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    314e:	89 44 24 04          	mov    %eax,0x4(%esp)
    3152:	c7 04 24 dc 0b 00 00 	movl   $0xbdc,(%esp)
    3159:	e8 fc ff ff ff       	call   315a <doStartContentionBasedRandomAccessProcedure+0x4a>
*******************************
*/
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
    315e:	e8 fc ff ff ff       	call   315f <doStartContentionBasedRandomAccessProcedure+0x4f>
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    3163:	ba 01 00 00 00       	mov    $0x1,%edx
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
    3168:	0f b6 b8 ac 00 00 00 	movzbl 0xac(%eax),%edi
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    316f:	8d 45 f3             	lea    -0xd(%ebp),%eax
    3172:	e8 fc ff ff ff       	call   3173 <doStartContentionBasedRandomAccessProcedure+0x63>
	raPreambleID = raPreambleID%NumberOfRA_Preambles;
    3177:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    317b:	89 fa                	mov    %edi,%edx
    317d:	f6 f2                	div    %dl
    317f:	0f b6 c4             	movzbl %ah,%eax
    3182:	88 45 f3             	mov    %al,-0xd(%ebp)
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
		SV(backoff_index) = 0;  //UEbackoff0ms    
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
	randomaccess_info->ra_PreambleIndex=RandomlySelectRaPreamble();//rapreamble
    3185:	88 06                	mov    %al,(%esi)
	SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//rapid,RAR //HQ 20140506 
    3187:	88 43 04             	mov    %al,0x4(%ebx)
	
	/*for test*/
	//randomaccess_info->ra_PreambleIndex=2;//for test 20141103
	//SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//for test20141103
	/*for test*/
	fsm_printf("[UEMAC][contention_ra]MAC ra_PreambleIndex:%d\n",SV(RA_info.ra_PreambleIndex));//test code
    318a:	0f b6 c0             	movzbl %al,%eax
    318d:	89 44 24 04          	mov    %eax,0x4(%esp)
    3191:	c7 04 24 04 0c 00 00 	movl   $0xc04,(%esp)
    3198:	e8 fc ff ff ff       	call   3199 <doStartContentionBasedRandomAccessProcedure+0x89>
	/*randomaccess_info->ra_PRACHMaskIndex=0;
	SV(RA_info.ra_PRACHMaskIndex)=randomaccess_info->ra_PRACHMaskIndex;*/
	SendRaPreamble(randomaccess_info);//
    319d:	89 f0                	mov    %esi,%eax
    319f:	e8 fc f8 ff ff       	call   2aa0 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    31a4:	e8 e7 f4 ff ff       	call   2690 <StartWaitingForRaResponse>
	FOUT;
}
    31a9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    31ac:	8b 75 f8             	mov    -0x8(%ebp),%esi
    31af:	8b 7d fc             	mov    -0x4(%ebp),%edi
    31b2:	89 ec                	mov    %ebp,%esp
    31b4:	5d                   	pop    %ebp
    31b5:	c3                   	ret    
    31b6:	8d 76 00             	lea    0x0(%esi),%esi
    31b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000031c0 <reports_handler>:
->output:
->Special:
*******************************
*/
static void reports_handler()
{
    31c0:	55                   	push   %ebp
    31c1:	89 e5                	mov    %esp,%ebp
    31c3:	53                   	push   %ebx
    31c4:	83 ec 04             	sub    $0x4,%esp
    31c7:	e8 fc ff ff ff       	call   31c8 <reports_handler+0x8>
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    31cc:	e8 fc ff ff ff       	call   31cd <reports_handler+0xd>
    31d1:	83 f8 03             	cmp    $0x3,%eax
    31d4:	74 4a                	je     3220 <reports_handler+0x60>
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    31d6:	e8 fc ff ff ff       	call   31d7 <reports_handler+0x17>
    31db:	83 f8 03             	cmp    $0x3,%eax
    31de:	66 90                	xchg   %ax,%ax
    31e0:	74 06                	je     31e8 <reports_handler+0x28>
		handle_RetxBSRTimerExpire();
	//PHR 
FOUT;
}
    31e2:	83 c4 04             	add    $0x4,%esp
    31e5:	5b                   	pop    %ebx
    31e6:	5d                   	pop    %ebp
    31e7:	c3                   	ret    
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    31e8:	e8 fc ff ff ff       	call   31e9 <reports_handler+0x29>
    31ed:	83 f8 0d             	cmp    $0xd,%eax
    31f0:	75 f0                	jne    31e2 <reports_handler+0x22>
->Special:
*******************************
*/
static void handle_RetxBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    31f2:	e8 fc ff ff ff       	call   31f3 <reports_handler+0x33>
    31f7:	89 c3                	mov    %eax,%ebx
	FIN(handle_RetxBSRTimerExpire());
	DoProduceBsr_RetxBSRTimer();
    31f9:	e8 fc ff ff ff       	call   31fa <reports_handler+0x3a>
	SV(RetxBSRTimer.timer_sign) = NULL;
    31fe:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3205:	00 00 00 
	SV(RetxBSRTimer.flag) = false;	
    3208:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	fsm_printf("[UEMAC][handle_retxbsrtimer]handle RetxBSRTimer expire\n");//testing code 
    320f:	c7 04 24 74 0c 00 00 	movl   $0xc74,(%esp)
    3216:	e8 fc ff ff ff       	call   3217 <reports_handler+0x57>
    321b:	eb c5                	jmp    31e2 <reports_handler+0x22>
    321d:	8d 76 00             	lea    0x0(%esi),%esi
*******************************
*/
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    3220:	e8 fc ff ff ff       	call   3221 <reports_handler+0x61>
    3225:	83 f8 0c             	cmp    $0xc,%eax
    3228:	75 ac                	jne    31d6 <reports_handler+0x16>
->Special:
*******************************
*/
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    322a:	e8 fc ff ff ff       	call   322b <reports_handler+0x6b>
    322f:	89 c3                	mov    %eax,%ebx
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
    3231:	e8 fc ff ff ff       	call   3232 <reports_handler+0x72>
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3236:	ba 0c 00 00 00       	mov    $0xc,%edx
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
    323b:	6b 43 64 64          	imul   $0x64,0x64(%ebx),%eax
    323f:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3245:	e8 fc ff ff ff       	call   3246 <reports_handler+0x86>
	SV(PeriodicBSRTimer).flag = true;
    324a:	c6 83 8c 01 00 00 01 	movb   $0x1,0x18c(%ebx)
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3251:	89 83 88 01 00 00    	mov    %eax,0x188(%ebx)
	SV(PeriodicBSRTimer).flag = true;
	fsm_printf("[UEMAC][handle_periodicbsrtimer]handle PeriodicBSRTimer expire\n");//testing code 
    3257:	c7 04 24 34 0c 00 00 	movl   $0xc34,(%esp)
    325e:	e8 fc ff ff ff       	call   325f <reports_handler+0x9f>
    3263:	e9 6e ff ff ff       	jmp    31d6 <reports_handler+0x16>
    3268:	90                   	nop
    3269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003270 <send_msg3>:
->output:
->Special:
*******************************
*/
void send_msg3(FSM_PKT *skb) //defined by HQ 20140430  
{
    3270:	55                   	push   %ebp
    3271:	89 e5                	mov    %esp,%ebp
    3273:	56                   	push   %esi
    3274:	53                   	push   %ebx
    3275:	83 ec 08             	sub    $0x8,%esp
    3278:	e8 fc ff ff ff       	call   3279 <send_msg3+0x9>
    327d:	89 c6                	mov    %eax,%esi
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	//FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    327f:	e8 fc ff ff ff       	call   3280 <send_msg3+0x10>
    3284:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    3286:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    328c:	c7 04 24 ac 0c 00 00 	movl   $0xcac,(%esp)
    3293:	89 44 24 04          	mov    %eax,0x4(%esp)
    3297:	e8 fc ff ff ff       	call   3298 <send_msg3+0x28>
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    329c:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    32a2:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    32a8:	83 fa 01             	cmp    $0x1,%edx
    32ab:	74 3b                	je     32e8 <send_msg3+0x78>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    32ad:	85 c0                	test   %eax,%eax
    32af:	74 09                	je     32ba <send_msg3+0x4a>
    32b1:	83 fa 02             	cmp    $0x2,%edx
    32b4:	0f 84 a6 00 00 00    	je     3360 <send_msg3+0xf0>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    32ba:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32c0:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    32c5:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32cb:	6b c0 64             	imul   $0x64,%eax,%eax
    32ce:	e8 fc ff ff ff       	call   32cf <send_msg3+0x5f>
	SV(CRTimer.flag)=true;
    32d3:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32da:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	SV(CRTimer.flag)=true;
	FOUT;
}
    32e0:	83 c4 08             	add    $0x8,%esp
    32e3:	5b                   	pop    %ebx
    32e4:	5e                   	pop    %esi
    32e5:	5d                   	pop    %ebp
    32e6:	c3                   	ret    
    32e7:	90                   	nop
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    32e8:	85 c0                	test   %eax,%eax
    32ea:	74 05                	je     32f1 <send_msg3+0x81>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    32ec:	e8 fc ff ff ff       	call   32ed <send_msg3+0x7d>
		SV(msg3_buf_ptr)=skb;//3
    32f1:	89 b3 e4 01 00 00    	mov    %esi,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32f7:	89 f0                	mov    %esi,%eax
    32f9:	e8 fc ff ff ff       	call   32fa <send_msg3+0x8a>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32fe:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3303:	89 c6                	mov    %eax,%esi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3305:	e8 fc ff ff ff       	call   3306 <send_msg3+0x96>
    330a:	85 c0                	test   %eax,%eax
    330c:	74 1a                	je     3328 <send_msg3+0xb8>
    330e:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3312:	74 14                	je     3328 <send_msg3+0xb8>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3314:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    331b:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3322:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
		complexUeMacPdu(skb);
    3328:	89 f0                	mov    %esi,%eax
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    332a:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3331:	00 00 00 
		complexUeMacPdu(skb);
    3334:	e8 fc ff ff ff       	call   3335 <send_msg3+0xc5>
		
	
		if(SV(Tbsize_Complex)!=0)
    3339:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    333f:	85 c0                	test   %eax,%eax
    3341:	74 0a                	je     334d <send_msg3+0xdd>
			SV(Tbsize_Complex)=0;//TBSIZE
    3343:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    334a:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    334d:	c7 04 24 d8 0c 00 00 	movl   $0xcd8,(%esp)
    3354:	e8 fc ff ff ff       	call   3355 <send_msg3+0xe5>
    3359:	e9 5c ff ff ff       	jmp    32ba <send_msg3+0x4a>
    335e:	66 90                	xchg   %ax,%ax
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3360:	e8 fc ff ff ff       	call   3361 <send_msg3+0xf1>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3365:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    336a:	89 c6                	mov    %eax,%esi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    336c:	e8 fc ff ff ff       	call   336d <send_msg3+0xfd>
    3371:	85 c0                	test   %eax,%eax
    3373:	74 06                	je     337b <send_msg3+0x10b>
    3375:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3379:	75 3d                	jne    33b8 <send_msg3+0x148>
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
		complexUeMacPdu(skb); 	
    337b:	89 f0                	mov    %esi,%eax
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
    337d:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3384:	00 00 00 
		complexUeMacPdu(skb); 	
    3387:	e8 fc ff ff ff       	call   3388 <send_msg3+0x118>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    338c:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    3392:	85 c0                	test   %eax,%eax
    3394:	74 0a                	je     33a0 <send_msg3+0x130>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    3396:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    339d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    33a0:	c7 04 24 10 0d 00 00 	movl   $0xd10,(%esp)
    33a7:	e8 fc ff ff ff       	call   33a8 <send_msg3+0x138>
    33ac:	e9 09 ff ff ff       	jmp    32ba <send_msg3+0x4a>
    33b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    33b8:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    33bf:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    33c6:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
    33cc:	eb ad                	jmp    337b <send_msg3+0x10b>
    33ce:	66 90                	xchg   %ax,%ax

000033d0 <print_tran_info>:
->output:
->Special:
*******************************
*/
void print_tran_info( const char *str)
{
    33d0:	55                   	push   %ebp
    33d1:	89 e5                	mov    %esp,%ebp
    33d3:	53                   	push   %ebx
    33d4:	83 ec 04             	sub    $0x4,%esp
    33d7:	e8 fc ff ff ff       	call   33d8 <print_tran_info+0x8>
    33dc:	89 c3                	mov    %eax,%ebx
	FIN( print_tran_info());
	int curtime=0;
	curtime=fsm_get_curtime();
    33de:	e8 fc ff ff ff       	call   33df <print_tran_info+0xf>
	//fsm_printf("[UEMAC][print_info]%d ",curtime);
	fsm_printf(str);
    33e3:	89 1c 24             	mov    %ebx,(%esp)
    33e6:	e8 fc ff ff ff       	call   33e7 <print_tran_info+0x17>
	fsm_printf("\n");
    33eb:	c7 04 24 95 01 00 00 	movl   $0x195,(%esp)
    33f2:	e8 fc ff ff ff       	call   33f3 <print_tran_info+0x23>
	FOUT;
}
    33f7:	83 c4 04             	add    $0x4,%esp
    33fa:	5b                   	pop    %ebx
    33fb:	5d                   	pop    %ebp
    33fc:	c3                   	ret    
    33fd:	8d 76 00             	lea    0x0(%esi),%esi

00003400 <handle_timeAlignmentTimerExpire>:
->output:
->Special:
*******************************
*/
static void handle_timeAlignmentTimerExpire()
{
    3400:	55                   	push   %ebp
    3401:	89 e5                	mov    %esp,%ebp
    3403:	e8 fc ff ff ff       	call   3404 <handle_timeAlignmentTimerExpire+0x4>
	FIN(handle_timeAlignmentTimerExpire());  
	SV_PTR_GET(rlc_mac_sv);
    3408:	e8 fc ff ff ff       	call   3409 <handle_timeAlignmentTimerExpire+0x9>
	SV(TATimer.time_value)=0;
    340d:	c7 80 60 01 00 00 00 	movl   $0x0,0x160(%eax)
    3414:	00 00 00 
	SV(TATimer.flag)=false;//
    3417:	c6 80 68 01 00 00 00 	movb   $0x0,0x168(%eax)
	SV(TATimer.timer_sign)=NULL;
    341e:	c7 80 64 01 00 00 00 	movl   $0x0,0x164(%eax)
    3425:	00 00 00 
	cleanharqBuff(); //HARQ
	//fsm_do_ioctrl(STRM_TO_IP, IOCCMD_MACtoRRC_PUCCHSRS_release  , NULL , 0);  //RRCPUCCH/SRS
	//
	SV(UL_resource_info.resource_flag)=false;//
    3428:	c6 40 28 00          	movb   $0x0,0x28(%eax)
	SV(UL_resource_info.m_tbsize)=0;
    342c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
											//??? 
	print_tran_info("[UEMAC][handle_tatimer]LostUL"); //testing code 
    3433:	b8 97 01 00 00       	mov    $0x197,%eax
    3438:	e8 fc ff ff ff       	call   3439 <handle_timeAlignmentTimerExpire+0x39>
	FOUT;
}
    343d:	5d                   	pop    %ebp
    343e:	c3                   	ret    
    343f:	90                   	nop

00003440 <random_test>:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
{
    3440:	55                   	push   %ebp
    3441:	89 e5                	mov    %esp,%ebp
    3443:	56                   	push   %esi
    3444:	53                   	push   %ebx
    3445:	83 ec 18             	sub    $0x18,%esp
    3448:	e8 fc ff ff ff       	call   3449 <random_test+0x9>
    344d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    3453:	89 45 f4             	mov    %eax,-0xc(%ebp)
    3456:	31 c0                	xor    %eax,%eax
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    3458:	8d 5d ea             	lea    -0x16(%ebp),%ebx
void random_test()   //HQ 20140410 0-63
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    345b:	c7 04 24 48 0d 00 00 	movl   $0xd48,(%esp)
->input:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
    3462:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    3465:	e8 fc ff ff ff       	call   3466 <random_test+0x26>
    346a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    3470:	89 d8                	mov    %ebx,%eax
    3472:	ba 01 00 00 00       	mov    $0x1,%edx
    3477:	e8 fc ff ff ff       	call   3478 <random_test+0x38>
		randNum[i]=randNum[i]%64;
    347c:	0f b6 03             	movzbl (%ebx),%eax
    347f:	83 e0 3f             	and    $0x3f,%eax
    3482:	88 03                	mov    %al,(%ebx)
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
    3484:	0f b6 c0             	movzbl %al,%eax
    3487:	83 c3 01             	add    $0x1,%ebx
    348a:	89 44 24 04          	mov    %eax,0x4(%esp)
    348e:	c7 04 24 78 0d 00 00 	movl   $0xd78,(%esp)
    3495:	e8 fc ff ff ff       	call   3496 <random_test+0x56>
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
    349a:	39 f3                	cmp    %esi,%ebx
    349c:	75 d2                	jne    3470 <random_test+0x30>
		fsm_get_random_bytes(&randNum[i], sizeof(char));
		randNum[i]=randNum[i]%64;
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
	} 
	FOUT;
}
    349e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    34a1:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    34a8:	75 07                	jne    34b1 <random_test+0x71>
    34aa:	83 c4 18             	add    $0x18,%esp
    34ad:	5b                   	pop    %ebx
    34ae:	5e                   	pop    %esi
    34af:	5d                   	pop    %ebp
    34b0:	c3                   	ret    
    34b1:	e8 fc ff ff ff       	call   34b2 <random_test+0x72>
    34b6:	8d 76 00             	lea    0x0(%esi),%esi
    34b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000034c0 <RA_RRCconfig_testingfun>:
->output:
->Special:
*******************************
*/
void RA_RRCconfig_testingfun() // RRC HQ 20140428 
{
    34c0:	55                   	push   %ebp
    34c1:	89 e5                	mov    %esp,%ebp
    34c3:	83 ec 04             	sub    $0x4,%esp
    34c6:	e8 fc ff ff ff       	call   34c7 <RA_RRCconfig_testingfun+0x7>
	FIN(RA_RRCconfig_testingfun());
	SV_PTR_GET(rlc_mac_sv);
    34cb:	e8 fc ff ff ff       	call   34cc <RA_RRCconfig_testingfun+0xc>
	SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles)= 64;
    34d0:	c7 80 ac 00 00 00 40 	movl   $0x40,0xac(%eax)
    34d7:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax)=8;
    34da:	c7 80 c8 00 00 00 08 	movl   $0x8,0xc8(%eax)
    34e1:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize)=800000;//8; 800s
    34e4:	c7 80 cc 00 00 00 00 	movl   $0xc3500,0xcc(%eax)
    34eb:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer)=800000;// 800s;
    34ee:	c7 80 d0 00 00 00 00 	movl   $0xc3500,0xd0(%eax)
    34f5:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx)=5;
    34f8:	c7 80 d4 00 00 00 05 	movl   $0x5,0xd4(%eax)
    34ff:	00 00 00 
	SV(backoff_index)= 2 ; 
    3502:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
	fsm_printf("[UEMAC][ra_rrcconfig]:RACH config have done \n");//testing code
    3509:	c7 04 24 a4 0d 00 00 	movl   $0xda4,(%esp)
    3510:	e8 fc ff ff ff       	call   3511 <RA_RRCconfig_testingfun+0x51>
	FOUT;
}
    3515:	c9                   	leave  
    3516:	c3                   	ret    
    3517:	89 f6                	mov    %esi,%esi
    3519:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003520 <ue_mac_sv_init>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_init()
{
    3520:	55                   	push   %ebp
    3521:	89 e5                	mov    %esp,%ebp
    3523:	57                   	push   %edi
    3524:	56                   	push   %esi
    3525:	53                   	push   %ebx
    3526:	83 ec 08             	sub    $0x8,%esp
    3529:	e8 fc ff ff ff       	call   352a <ue_mac_sv_init+0xa>
	FIN(ue_mac_sv_init());
	int len;
	
	SV_PTR_GET(rlc_mac_sv);
    352e:	e8 fc ff ff ff       	call   352f <ue_mac_sv_init+0xf>
    3533:	89 c3                	mov    %eax,%ebx
	print_tran_info("FSM INIT-init SV");//testing code
    3535:	b8 b5 01 00 00       	mov    $0x1b5,%eax
    353a:	e8 fc ff ff ff       	call   353b <ue_mac_sv_init+0x1b>
	SV(TA_Periodic_time)=800000000;//testing code ,
    353f:	c7 43 24 00 08 af 2f 	movl   $0x2faf0800,0x24(%ebx)
	Init_Uemac_Scheduler();
    3546:	e8 fc ff ff ff       	call   3547 <ue_mac_sv_init+0x27>
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    354b:	b8 06 00 00 00       	mov    $0x6,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("FSM INIT-init SV");//testing code
	SV(TA_Periodic_time)=800000000;//testing code ,
	Init_Uemac_Scheduler();
	SV(sys_frame.frameNo)=0;//modified LHL 20141105
    3550:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
	SV(sys_frame.subframeNo)=0;
    3556:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
	SV(recv_frame).subframeNo=0;//
    355c:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	SV(recv_frame).frameNo=0;
    3562:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	SV(ue_schedule_frame.frameNo)=0;
    3568:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
	SV(ue_schedule_frame.subframeNo)=0;
    356e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
    3574:	66 c7 43 22 00 00    	movw   $0x0,0x22(%ebx)
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    357a:	e8 fc ff ff ff       	call   357b <ue_mac_sv_init+0x5b>
	//
	
	SV(TATimer.time_value) = 0;
    357f:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    3586:	00 00 00 
	SV(TATimer.timer_sign) = NULL;
    3589:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    3590:	00 00 00 
	SV(TATimer.flag) = false;
    3593:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
	SV(CRTimer.time_value) = 0;
    359a:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    35a1:	00 00 00 
	SV(CRTimer.timer_sign) = NULL;
    35a4:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    35ab:	00 00 00 
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    35ae:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	SV(TATimer.time_value) = 0;
	SV(TATimer.timer_sign) = NULL;
	SV(TATimer.flag) = false;
	SV(CRTimer.time_value) = 0;
	SV(CRTimer.timer_sign) = NULL;
	SV(CRTimer.flag) = false;
    35b4:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
	SV(RetxBSRTimer.time_value) = 0;
    35bb:	c7 83 78 01 00 00 00 	movl   $0x0,0x178(%ebx)
    35c2:	00 00 00 
	SV(RetxBSRTimer.timer_sign) = NULL;
    35c5:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    35cc:	00 00 00 
	SV(RetxBSRTimer.flag) = false;
    35cf:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	SV(PeriodicBSRTimer.time_value) = 0;
    35d6:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
    35dd:	00 00 00 
	SV(PeriodicBSRTimer.timer_sign) = NULL;
    35e0:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    35e7:	00 00 00 
	SV(PeriodicBSRTimer.flag) = false;	
    35ea:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
	SV(WaitforRAresponseTimer.time_value) = 0;
    35f1:	c7 83 90 01 00 00 00 	movl   $0x0,0x190(%ebx)
    35f8:	00 00 00 
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
    35fb:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3602:	00 00 00 
	SV(WaitforRAresponseTimer.flag) = false;
    3605:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
	SV(msg3_buf_ptr) = NULL;	
    360c:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    3613:	00 00 00 
	SV(ra_allocation_res)=0;
    3616:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    361d:	00 00 00 
*******************************
*/
static void macmain_defaultconfig()
{
	FIN(macmain_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3620:	e8 fc ff ff ff       	call   3621 <ue_mac_sv_init+0x101>
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx) = maxHARQ_Tx_n5;
    3625:	c7 40 60 05 00 00 00 	movl   $0x5,0x60(%eax)
	//fsm_printf("test maxHARQTX:%d \n ",SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx));//testing code
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)= periodicBSR_Timer_infinity;//
    362c:	c7 40 64 ff ff ff ff 	movl   $0xffffffff,0x64(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)= retxBSR_Timer_sf2560 ;
    3633:	c7 40 68 00 0a 00 00 	movl   $0xa00,0x68(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.ttiBundling)= false ;
    363a:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.drx_Config.choice.setup.haveShortDRX)= false ;//means release
    363e:	c6 80 8c 00 00 00 00 	movb   $0x0,0x8c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.type)= 1 ; //means phr-Config release ??  
    3645:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
    364c:	00 00 00 
*******************************
*/
static void sps_defaultconfig()
{
	FIN(sps_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    364f:	e8 fc ff ff ff       	call   3650 <ue_mac_sv_init+0x130>
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigDL)=false;
    3654:	c6 80 e8 00 00 00 00 	movb   $0x0,0xe8(%eax)
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigUL)=false; 
    365b:	c6 80 08 01 00 00 00 	movb   $0x0,0x108(%eax)
*******************************
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3662:	e8 fc ff ff ff       	call   3663 <ue_mac_sv_init+0x143>
    3667:	89 c7                	mov    %eax,%edi
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    3669:	b8 15 00 00 00       	mov    $0x15,%eax
    366e:	e8 fc ff ff ff       	call   366f <ue_mac_sv_init+0x14f>
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    3673:	8d 97 28 01 00 00    	lea    0x128(%edi),%edx
    3679:	b9 15 00 00 00       	mov    $0x15,%ecx
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
    367e:	c7 87 28 01 00 00 00 	movl   $0x0,0x128(%edi)
    3685:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
    3688:	c6 87 2c 01 00 00 01 	movb   $0x1,0x12c(%edi)
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
    368f:	c7 87 2d 01 00 00 01 	movl   $0x1,0x12d(%edi)
    3696:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
    3699:	c7 87 31 01 00 00 ff 	movl   $0xffffffff,0x131(%edi)
    36a0:	ff ff ff 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
    36a3:	c7 87 39 01 00 00 00 	movl   $0x0,0x139(%edi)
    36aa:	00 00 00 
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    36ad:	89 c6                	mov    %eax,%esi
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    36af:	e8 fc ff ff ff       	call   36b0 <ue_mac_sv_init+0x190>
	Init_LogicalChannel_ConfigInfo(ccch_info); 
    36b4:	89 f0                	mov    %esi,%eax
    36b6:	e8 fc ff ff ff       	call   36b7 <ue_mac_sv_init+0x197>
	fsm_mem_free(ccch_info);//
    36bb:	89 f0                	mov    %esi,%eax
    36bd:	e8 fc ff ff ff       	call   36be <ue_mac_sv_init+0x19e>
	fsm_printf("[UEMAC][init]CCCH_defaultconfig completed\n");
    36c2:	c7 04 24 d4 0d 00 00 	movl   $0xdd4,(%esp)
    36c9:	e8 fc ff ff ff       	call   36ca <ue_mac_sv_init+0x1aa>
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
    36ce:	e8 fc ff ff ff       	call   36cf <ue_mac_sv_init+0x1af>
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    36d3:	b9 04 00 00 00       	mov    $0x4,%ecx
    36d8:	31 d2                	xor    %edx,%edx
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
	SV(UL_resource_info.resource_flag)= false; //testing code
    36da:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    36de:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
    36e4:	e8 fc ff ff ff       	call   36e5 <ue_mac_sv_init+0x1c5>
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    36e9:	b8 0c 00 00 00       	mov    $0xc,%eax
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
	SV(sendmsg3)=0;//0:MSG31:MSG3
    36ee:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    36f5:	00 00 00 
	SV(pdcch_rnti)=0;//0:PDCCHC_RNTI1:C_RNTI
    36f8:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    36ff:	00 00 00 
	SV(Tbsize_Complex)=0;//modified by lhl ,20140718,to 
    3702:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    3709:	00 00 00 
	//test_init_logicalchannel(1);//TEST 20141103
	//test_init_logicalchannel(3);//TEST 20141103
	SV(contention_failed_num)=0;
    370c:	c7 83 00 02 00 00 00 	movl   $0x0,0x200(%ebx)
    3713:	00 00 00 
	SV(rar_failed_num)=0;
    3716:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
    371d:	00 00 00 
	
	SV(lost_pkt_num_uplink)=0;
    3720:	c7 83 04 02 00 00 00 	movl   $0x0,0x204(%ebx)
    3727:	00 00 00 
	SV(pkt_num_uplink)=0;
    372a:	c7 83 08 02 00 00 00 	movl   $0x0,0x208(%ebx)
    3731:	00 00 00 
	SV(lost_pkt_num_downlink)=0;
    3734:	c7 83 0c 02 00 00 00 	movl   $0x0,0x20c(%ebx)
    373b:	00 00 00 
	SV(pkt_num_downlink)=0;
    373e:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%ebx)
    3745:	00 00 00 
	
	SV(countSendToUpper)=0;
    3748:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    374f:	00 00 00 
	SV(countRecvFromLower)=0;
    3752:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    3759:	00 00 00 
	SV(countreceive_from_mac)=0;
    375c:	c7 83 88 5a 00 00 00 	movl   $0x0,0x5a88(%ebx)
    3763:	00 00 00 
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    3766:	e8 fc ff ff ff       	call   3767 <ue_mac_sv_init+0x247>
    376b:	89 c6                	mov    %eax,%esi
    376d:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)
	(*Q)->front = (*Q)->rear = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    3773:	b8 08 00 00 00       	mov    $0x8,%eax
    3778:	e8 fc ff ff ff       	call   3779 <ue_mac_sv_init+0x259>
    377d:	89 46 04             	mov    %eax,0x4(%esi)
    3780:	89 06                	mov    %eax,(%esi)
	// Q->front = NULL;
	// Q->rear = NULL;
	(*Q)->pkt_count = 0;
    3782:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    3788:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	fsm_printf("[InitQueue]Q point: %p\n", *Q);
    378e:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    3794:	c7 04 24 c6 01 00 00 	movl   $0x1c6,(%esp)
    379b:	89 44 24 04          	mov    %eax,0x4(%esp)
    379f:	e8 fc ff ff ff       	call   37a0 <ue_mac_sv_init+0x280>
	SV(countSendToUpper)=0;
	SV(countRecvFromLower)=0;
	SV(countreceive_from_mac)=0;

	InitQueue(&SV(CraQueue));	//add cra queue initialization by LXR in 20151020
	fsm_printf("[ue_mac_sv_init]SV(CraQueue): %p\n", SV(CraQueue));
    37a4:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    37aa:	c7 04 24 00 0e 00 00 	movl   $0xe00,(%esp)
    37b1:	89 44 24 04          	mov    %eax,0x4(%esp)
    37b5:	e8 fc ff ff ff       	call   37b6 <ue_mac_sv_init+0x296>
	
	FOUT;
}
    37ba:	83 c4 08             	add    $0x8,%esp
    37bd:	5b                   	pop    %ebx
    37be:	5e                   	pop    %esi
    37bf:	5f                   	pop    %edi
    37c0:	5d                   	pop    %ebp
    37c1:	c3                   	ret    
    37c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    37c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000037d0 <testdoStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartContentionBasedRandomAccessProcedure()
{
    37d0:	55                   	push   %ebp
    37d1:	89 e5                	mov    %esp,%ebp
    37d3:	e8 fc ff ff ff       	call   37d4 <testdoStartContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> CRA");
    37d8:	b8 de 01 00 00       	mov    $0x1de,%eax
    37dd:	e8 fc ff ff ff       	call   37de <testdoStartContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	//fsm_schedule_self(100000, RandomAcc_Fail );//testing code
	FOUT;
}
    37e2:	5d                   	pop    %ebp
    37e3:	c3                   	ret    
    37e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    37ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000037f0 <testdoStartNonContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartNonContentionBasedRandomAccessProcedure() // 
{
    37f0:	55                   	push   %ebp
    37f1:	89 e5                	mov    %esp,%ebp
    37f3:	e8 fc ff ff ff       	call   37f4 <testdoStartNonContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartNonContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> NCRA");
    37f8:	b8 ea 01 00 00       	mov    $0x1ea,%eax
    37fd:	e8 fc ff ff ff       	call   37fe <testdoStartNonContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	FOUT;
}
    3802:	5d                   	pop    %ebp
    3803:	c3                   	ret    
    3804:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    380a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003810 <stop_WRAP_timer>:
->output:
->Special:
*******************************
*/
void stop_WRAP_timer()
{
    3810:	55                   	push   %ebp
    3811:	89 e5                	mov    %esp,%ebp
    3813:	53                   	push   %ebx
    3814:	e8 fc ff ff ff       	call   3815 <stop_WRAP_timer+0x5>
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3819:	e8 fc ff ff ff       	call   381a <stop_WRAP_timer+0xa>
	if(SV(WaitforRAresponseTimer.flag)==true)
    381e:	80 b8 98 01 00 00 00 	cmpb   $0x0,0x198(%eax)
*******************************
*/
void stop_WRAP_timer()
{
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3825:	89 c3                	mov    %eax,%ebx
	if(SV(WaitforRAresponseTimer.flag)==true)
    3827:	74 1c                	je     3845 <stop_WRAP_timer+0x35>
	{
		fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    3829:	8b 80 94 01 00 00    	mov    0x194(%eax),%eax
    382f:	e8 fc ff ff ff       	call   3830 <stop_WRAP_timer+0x20>
		SV(WaitforRAresponseTimer.flag)=false;
    3834:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)=NULL;
    383b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3842:	00 00 00 
	}
	FOUT;
}
    3845:	5b                   	pop    %ebx
    3846:	5d                   	pop    %ebp
    3847:	c3                   	ret    
    3848:	90                   	nop
    3849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003850 <NCRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void NCRAtoCON_testingfun() 
{
    3850:	55                   	push   %ebp
    3851:	89 e5                	mov    %esp,%ebp
    3853:	e8 fc ff ff ff       	call   3854 <NCRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("NCRA -> CON");
    3858:	b8 f7 01 00 00       	mov    $0x1f7,%eax
    385d:	e8 fc ff ff ff       	call   385e <NCRAtoCON_testingfun+0xe>
	stop_WRAP_timer(); //RAR
    3862:	e8 fc ff ff ff       	call   3863 <NCRAtoCON_testingfun+0x13>
	FOUT;
}
    3867:	5d                   	pop    %ebp
    3868:	c3                   	ret    
    3869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003870 <stop_CR_timer>:
->output:
->Special:
*******************************
*/
void stop_CR_timer()
{
    3870:	55                   	push   %ebp
    3871:	89 e5                	mov    %esp,%ebp
    3873:	53                   	push   %ebx
    3874:	e8 fc ff ff ff       	call   3875 <stop_CR_timer+0x5>
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3879:	e8 fc ff ff ff       	call   387a <stop_CR_timer+0xa>
	if(SV(CRTimer.flag)==true)
    387e:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
*******************************
*/
void stop_CR_timer()
{
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3885:	89 c3                	mov    %eax,%ebx
	if(SV(CRTimer.flag)==true)
    3887:	74 1c                	je     38a5 <stop_CR_timer+0x35>
	{
		fsm_schedule_cancel(SV(CRTimer.timer_sign));
    3889:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    388f:	e8 fc ff ff ff       	call   3890 <stop_CR_timer+0x20>
		SV(CRTimer.flag)=false;
    3894:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
		SV(CRTimer.timer_sign)=NULL;
    389b:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    38a2:	00 00 00 
	}
	FOUT;
}
    38a5:	5b                   	pop    %ebx
    38a6:	5d                   	pop    %ebp
    38a7:	c3                   	ret    
    38a8:	90                   	nop
    38a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038b0 <stop_TA_timer>:
->output:
->Special:
*******************************
*/
void stop_TA_timer()
{
    38b0:	55                   	push   %ebp
    38b1:	89 e5                	mov    %esp,%ebp
    38b3:	53                   	push   %ebx
    38b4:	e8 fc ff ff ff       	call   38b5 <stop_TA_timer+0x5>
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    38b9:	e8 fc ff ff ff       	call   38ba <stop_TA_timer+0xa>
	if(SV(TATimer.flag)==true)
    38be:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
void stop_TA_timer()
{
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    38c5:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true)
    38c7:	74 1c                	je     38e5 <stop_TA_timer+0x35>
	{
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    38c9:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    38cf:	e8 fc ff ff ff       	call   38d0 <stop_TA_timer+0x20>
		SV(TATimer.flag)=false;
    38d4:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.timer_sign)=NULL;
    38db:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    38e2:	00 00 00 
	}
	FOUT;
}
    38e5:	5b                   	pop    %ebx
    38e6:	5d                   	pop    %ebp
    38e7:	c3                   	ret    
    38e8:	90                   	nop
    38e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038f0 <stop_RetxBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_RetxBSR_timer()
{
    38f0:	55                   	push   %ebp
    38f1:	89 e5                	mov    %esp,%ebp
    38f3:	53                   	push   %ebx
    38f4:	e8 fc ff ff ff       	call   38f5 <stop_RetxBSR_timer+0x5>
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    38f9:	e8 fc ff ff ff       	call   38fa <stop_RetxBSR_timer+0xa>
	if(SV(RetxBSRTimer.flag)==true)
    38fe:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
*******************************
*/
void stop_RetxBSR_timer()
{
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3905:	89 c3                	mov    %eax,%ebx
	if(SV(RetxBSRTimer.flag)==true)
    3907:	74 1c                	je     3925 <stop_RetxBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(RetxBSRTimer.timer_sign));
    3909:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    390f:	e8 fc ff ff ff       	call   3910 <stop_RetxBSR_timer+0x20>
		SV(RetxBSRTimer.flag)=false;
    3914:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
		SV(RetxBSRTimer.timer_sign)=NULL;
    391b:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3922:	00 00 00 
	}
	FOUT;
}
    3925:	5b                   	pop    %ebx
    3926:	5d                   	pop    %ebp
    3927:	c3                   	ret    
    3928:	90                   	nop
    3929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003930 <stop_PeriodicBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_PeriodicBSR_timer()
{
    3930:	55                   	push   %ebp
    3931:	89 e5                	mov    %esp,%ebp
    3933:	53                   	push   %ebx
    3934:	e8 fc ff ff ff       	call   3935 <stop_PeriodicBSR_timer+0x5>
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3939:	e8 fc ff ff ff       	call   393a <stop_PeriodicBSR_timer+0xa>
	if(SV(PeriodicBSRTimer.flag)==true)
    393e:	80 b8 8c 01 00 00 00 	cmpb   $0x0,0x18c(%eax)
*******************************
*/
void stop_PeriodicBSR_timer()
{
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3945:	89 c3                	mov    %eax,%ebx
	if(SV(PeriodicBSRTimer.flag)==true)
    3947:	74 1c                	je     3965 <stop_PeriodicBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(PeriodicBSRTimer.timer_sign));
    3949:	8b 80 88 01 00 00    	mov    0x188(%eax),%eax
    394f:	e8 fc ff ff ff       	call   3950 <stop_PeriodicBSR_timer+0x20>
		SV(PeriodicBSRTimer.flag)=false;
    3954:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
		SV(PeriodicBSRTimer.timer_sign)=NULL;
    395b:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    3962:	00 00 00 
	}
	FOUT;
}
    3965:	5b                   	pop    %ebx
    3966:	5d                   	pop    %ebp
    3967:	c3                   	ret    
    3968:	90                   	nop
    3969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003970 <ue_mac_reset>:
->output:
->Special:
*******************************
*/
static void ue_mac_reset()//modified by LHL 20140717
{
    3970:	55                   	push   %ebp
    3971:	89 e5                	mov    %esp,%ebp
    3973:	53                   	push   %ebx
    3974:	e8 fc ff ff ff       	call   3975 <ue_mac_reset+0x5>
	FIN( ue_mac_reset());
	SV_PTR_GET(rlc_mac_sv);
    3979:	e8 fc ff ff ff       	call   397a <ue_mac_reset+0xa>
    397e:	89 c3                	mov    %eax,%ebx
	//initialize Bj for each logical channel to zero;BJ0 
	Zero_LogicalChannel_Bj_Reset();
    3980:	e8 fc ff ff ff       	call   3981 <ue_mac_reset+0x11>
	//stop (if running) all timers; 
	stop_WRAP_timer();//WaitforRAresponseTimer
    3985:	e8 fc ff ff ff       	call   3986 <ue_mac_reset+0x16>
	stop_CR_timer();//CR
    398a:	e8 fc ff ff ff       	call   398b <ue_mac_reset+0x1b>
    398f:	90                   	nop
	stop_RetxBSR_timer();
    3990:	e8 fc ff ff ff       	call   3991 <ue_mac_reset+0x21>
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
    3995:	e8 fc ff ff ff       	call   3996 <ue_mac_reset+0x26>
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    399a:	8b 83 e8 01 00 00    	mov    0x1e8(%ebx),%eax
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
	//	consider timeAlignmentTimer as expired and perform the corresponding actions in subclause 5.2;
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
    39a0:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	SV(SR_COUNTER)= 0; 
    39a7:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    39ae:	83 f8 03             	cmp    $0x3,%eax
    39b1:	74 4d                	je     3a00 <ue_mac_reset+0x90>
    39b3:	83 f8 01             	cmp    $0x1,%eax
    39b6:	74 48                	je     3a00 <ue_mac_reset+0x90>
	{
		SV(RA_info.ra_PreambleIndex)=0;//
		SV(RA_info.ra_PRACHMaskIndex)=0;
	}
	//	flush Msg3 buffer;
	if(SV(msg3_buf_ptr)!=NULL)
    39b8:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    39be:	85 c0                	test   %eax,%eax
    39c0:	74 0f                	je     39d1 <ue_mac_reset+0x61>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));	
    39c2:	e8 fc ff ff ff       	call   39c3 <ue_mac_reset+0x53>
		SV(msg3_buf_ptr) = NULL; 
    39c7:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    39ce:	00 00 00 
	}
	//	cancel, if any, triggered Scheduling Request procedure;
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
    39d1:	e8 fc ff ff ff       	call   39d2 <ue_mac_reset+0x62>
	Empty_MACBuffer_Rlc();//RLC 
    39d6:	e8 fc ff ff ff       	call   39d7 <ue_mac_reset+0x67>
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
	if(SV(m_temp_cr) != NULL)
    39db:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
	Empty_MACBuffer_Rlc();//RLC 
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
    39e1:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if(SV(m_temp_cr) != NULL)
    39e7:	85 c0                	test   %eax,%eax
    39e9:	74 0f                	je     39fa <ue_mac_reset+0x8a>
	{
		fsm_mem_free(SV(m_temp_cr));
    39eb:	e8 fc ff ff ff       	call   39ec <ue_mac_reset+0x7c>
		SV(m_temp_cr) = NULL;
    39f0:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    39f7:	00 00 00 
	}
	FOUT;
}
    39fa:	5b                   	pop    %ebx
    39fb:	5d                   	pop    %ebp
    39fc:	c3                   	ret    
    39fd:	8d 76 00             	lea    0x0(%esi),%esi
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
	{
		SV(RA_info.ra_PreambleIndex)=0;//
    3a00:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0;
    3a04:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    3a08:	eb ae                	jmp    39b8 <ue_mac_reset+0x48>
    3a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00003a10 <CRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void CRAtoCON_testingfun()
{
    3a10:	55                   	push   %ebp
    3a11:	89 e5                	mov    %esp,%ebp
    3a13:	e8 fc ff ff ff       	call   3a14 <CRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("CRA -> CON");
    3a18:	b8 03 02 00 00       	mov    $0x203,%eax
    3a1d:	e8 fc ff ff ff       	call   3a1e <CRAtoCON_testingfun+0xe>
	stop_CR_timer(); //
    3a22:	e8 fc ff ff ff       	call   3a23 <CRAtoCON_testingfun+0x13>
	FOUT;
}
    3a27:	5d                   	pop    %ebp
    3a28:	c3                   	ret    
    3a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003a30 <test1_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test1_idle_default_handler()
{
    3a30:	55                   	push   %ebp
    3a31:	89 e5                	mov    %esp,%ebp
    3a33:	83 ec 10             	sub    $0x10,%esp
    3a36:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    3a39:	89 75 fc             	mov    %esi,-0x4(%ebp)
    3a3c:	e8 fc ff ff ff       	call   3a3d <test1_idle_default_handler+0xd>
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    3a41:	e8 fc ff ff ff       	call   3a42 <test1_idle_default_handler+0x12>
    3a46:	89 c3                	mov    %eax,%ebx
	print_tran_info("MAC:idle_default_handler");
    3a48:	b8 0e 02 00 00       	mov    $0x20e,%eax
    3a4d:	e8 fc ff ff ff       	call   3a4e <test1_idle_default_handler+0x1e>
	if(MAC_CLOSE)
    3a52:	e8 fc ff ff ff       	call   3a53 <test1_idle_default_handler+0x23>
    3a57:	83 f8 05             	cmp    $0x5,%eax
    3a5a:	74 5c                	je     3ab8 <test1_idle_default_handler+0x88>
    3a5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3a60:	e8 fc ff ff ff       	call   3a61 <test1_idle_default_handler+0x31>
    3a65:	83 f8 02             	cmp    $0x2,%eax
    3a68:	74 76                	je     3ae0 <test1_idle_default_handler+0xb0>
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3a6a:	e8 fc ff ff ff       	call   3a6b <test1_idle_default_handler+0x3b>
    3a6f:	83 f8 05             	cmp    $0x5,%eax
    3a72:	74 0c                	je     3a80 <test1_idle_default_handler+0x50>
			ioctrl_handler();  	
		break;
		}
	}
FOUT;
}
    3a74:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    3a77:	8b 75 fc             	mov    -0x4(%ebp),%esi
    3a7a:	89 ec                	mov    %ebp,%esp
    3a7c:	5d                   	pop    %ebp
    3a7d:	c3                   	ret    
    3a7e:	66 90                	xchg   %ax,%ax
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3a80:	e8 fc ff ff ff       	call   3a81 <test1_idle_default_handler+0x51>
    3a85:	83 f8 02             	cmp    $0x2,%eax
    3a88:	75 ea                	jne    3a74 <test1_idle_default_handler+0x44>
	{//IOCTL
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
    3a8a:	b8 3a 02 00 00       	mov    $0x23a,%eax
    3a8f:	e8 fc ff ff ff       	call   3a90 <test1_idle_default_handler+0x60>
		switch(fsm_ev_ioctrl_cmd())
    3a94:	e8 fc ff ff ff       	call   3a95 <test1_idle_default_handler+0x65>
    3a99:	83 f8 0b             	cmp    $0xb,%eax
    3a9c:	0f 84 be 00 00 00    	je     3b60 <test1_idle_default_handler+0x130>
    3aa2:	83 f8 0c             	cmp    $0xc,%eax
    3aa5:	74 6d                	je     3b14 <test1_idle_default_handler+0xe4>
    3aa7:	83 f8 04             	cmp    $0x4,%eax
    3aaa:	74 4d                	je     3af9 <test1_idle_default_handler+0xc9>
    3aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		*/

		//
		default:
			ioctrl_handler();  	
    3ab0:	e8 2b f0 ff ff       	call   2ae0 <ioctrl_handler>
		break;
    3ab5:	eb bd                	jmp    3a74 <test1_idle_default_handler+0x44>
    3ab7:	90                   	nop
    3ab8:	90                   	nop
    3ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("MAC:idle_default_handler");
	if(MAC_CLOSE)
    3ac0:	e8 fc ff ff ff       	call   3ac1 <test1_idle_default_handler+0x91>
    3ac5:	83 f8 01             	cmp    $0x1,%eax
    3ac8:	75 92                	jne    3a5c <test1_idle_default_handler+0x2c>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3aca:	b8 27 02 00 00       	mov    $0x227,%eax
    3acf:	e8 fc ff ff ff       	call   3ad0 <test1_idle_default_handler+0xa0>
		ue_mac_sv_close();
    3ad4:	e8 77 ef ff ff       	call   2a50 <ue_mac_sv_close>
    3ad9:	eb 81                	jmp    3a5c <test1_idle_default_handler+0x2c>
    3adb:	90                   	nop
    3adc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("MAC:IDLE receive a data packet from PHYadapter"); //testing code
    3ae0:	b8 24 0e 00 00       	mov    $0xe24,%eax
    3ae5:	e8 fc ff ff ff       	call   3ae6 <test1_idle_default_handler+0xb6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3aea:	e8 fc ff ff ff       	call   3aeb <test1_idle_default_handler+0xbb>
    3aef:	e8 fc ff ff ff       	call   3af0 <test1_idle_default_handler+0xc0>
    3af4:	e9 71 ff ff ff       	jmp    3a6a <test1_idle_default_handler+0x3a>
				fsm_data_destroy(tmpdata_ptr);//
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("MAC:IDLE receive a cra order ");
    3af9:	b8 9d 02 00 00       	mov    $0x29d,%eax
    3afe:	e8 fc ff ff ff       	call   3aff <test1_idle_default_handler+0xcf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//		
    3b03:	ba 02 00 00 00       	mov    $0x2,%edx
    3b08:	31 c0                	xor    %eax,%eax
    3b0a:	e8 fc ff ff ff       	call   3b0b <test1_idle_default_handler+0xdb>
		break;
    3b0f:	e9 60 ff ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;

		//PHYRA
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				tmpdata_ptr = fsm_data_get();
    3b14:	e8 fc ff ff ff       	call   3b15 <test1_idle_default_handler+0xe5>
    3b19:	89 c6                	mov    %eax,%esi
				print_tran_info("IDLE receive a ncra order ");
    3b1b:	b8 76 02 00 00       	mov    $0x276,%eax
    3b20:	e8 fc ff ff ff       	call   3b21 <test1_idle_default_handler+0xf1>
				fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    3b25:	b9 02 00 00 00       	mov    $0x2,%ecx
    3b2a:	89 f2                	mov    %esi,%edx
    3b2c:	8d 43 04             	lea    0x4(%ebx),%eax
    3b2f:	e8 fc ff ff ff       	call   3b30 <test1_idle_default_handler+0x100>
				fsm_printf("RAPID: %d \n",SV(RA_info.ra_PreambleIndex));		
    3b34:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    3b38:	c7 04 24 91 02 00 00 	movl   $0x291,(%esp)
    3b3f:	89 44 24 04          	mov    %eax,0x4(%esp)
    3b43:	e8 fc ff ff ff       	call   3b44 <test1_idle_default_handler+0x114>
				if(tmpdata_ptr != NULL)
    3b48:	85 f6                	test   %esi,%esi
    3b4a:	0f 84 24 ff ff ff    	je     3a74 <test1_idle_default_handler+0x44>
				fsm_data_destroy(tmpdata_ptr);//
    3b50:	89 f0                	mov    %esi,%eax
    3b52:	e8 fc ff ff ff       	call   3b53 <test1_idle_default_handler+0x123>
    3b57:	e9 18 ff ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
    3b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3b60:	e8 fc ff ff ff       	call   3b61 <test1_idle_default_handler+0x131>
    3b65:	89 c3                	mov    %eax,%ebx
			print_tran_info("MAC:IDLE receive a RLCdatareq");
    3b67:	b8 58 02 00 00       	mov    $0x258,%eax
    3b6c:	e8 fc ff ff ff       	call   3b6d <test1_idle_default_handler+0x13d>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3b71:	89 d8                	mov    %ebx,%eax
    3b73:	e8 fc ff ff ff       	call   3b74 <test1_idle_default_handler+0x144>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3b78:	ba 02 00 00 00       	mov    $0x2,%edx
    3b7d:	31 c0                	xor    %eax,%eax
    3b7f:	e8 fc ff ff ff       	call   3b80 <test1_idle_default_handler+0x150>
		break;
    3b84:	e9 eb fe ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
    3b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003b90 <test2_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test2_idle_default_handler()
{
    3b90:	55                   	push   %ebp
    3b91:	89 e5                	mov    %esp,%ebp
    3b93:	53                   	push   %ebx
    3b94:	e8 fc ff ff ff       	call   3b95 <test2_idle_default_handler+0x5>
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
    3b99:	e8 fc ff ff ff       	call   3b9a <test2_idle_default_handler+0xa>
	print_tran_info("idle_default_handler");
    3b9e:	b8 bb 02 00 00       	mov    $0x2bb,%eax
    3ba3:	e8 fc ff ff ff       	call   3ba4 <test2_idle_default_handler+0x14>
	if(MAC_CLOSE)
    3ba8:	e8 fc ff ff ff       	call   3ba9 <test2_idle_default_handler+0x19>
    3bad:	83 f8 05             	cmp    $0x5,%eax
    3bb0:	74 56                	je     3c08 <test2_idle_default_handler+0x78>
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3bb2:	e8 fc ff ff ff       	call   3bb3 <test2_idle_default_handler+0x23>
    3bb7:	83 f8 02             	cmp    $0x2,%eax
    3bba:	74 74                	je     3c30 <test2_idle_default_handler+0xa0>
    3bbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3bc0:	e8 fc ff ff ff       	call   3bc1 <test2_idle_default_handler+0x31>
    3bc5:	83 f8 05             	cmp    $0x5,%eax
    3bc8:	74 06                	je     3bd0 <test2_idle_default_handler+0x40>
			ioctrl_handler();
		break;
		}
	}
	FOUT;
}
    3bca:	5b                   	pop    %ebx
    3bcb:	5d                   	pop    %ebp
    3bcc:	c3                   	ret    
    3bcd:	8d 76 00             	lea    0x0(%esi),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3bd0:	e8 fc ff ff ff       	call   3bd1 <test2_idle_default_handler+0x41>
    3bd5:	83 f8 02             	cmp    $0x2,%eax
    3bd8:	75 f0                	jne    3bca <test2_idle_default_handler+0x3a>
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
    3bda:	b8 d0 02 00 00       	mov    $0x2d0,%eax
    3bdf:	e8 fc ff ff ff       	call   3be0 <test2_idle_default_handler+0x50>
		switch(fsm_ev_ioctrl_cmd())
    3be4:	e8 fc ff ff ff       	call   3be5 <test2_idle_default_handler+0x55>
    3be9:	83 f8 0b             	cmp    $0xb,%eax
    3bec:	0f 84 96 00 00 00    	je     3c88 <test2_idle_default_handler+0xf8>
    3bf2:	77 5c                	ja     3c50 <test2_idle_default_handler+0xc0>
    3bf4:	83 f8 04             	cmp    $0x4,%eax
    3bf7:	74 70                	je     3c69 <test2_idle_default_handler+0xd9>
    3bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
		break;
		//do_ioctl
		//
		default:
			ioctrl_handler();
    3c00:	e8 db ee ff ff       	call   2ae0 <ioctrl_handler>
		break;
    3c05:	eb c3                	jmp    3bca <test2_idle_default_handler+0x3a>
    3c07:	90                   	nop
    3c08:	90                   	nop
    3c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("idle_default_handler");
	if(MAC_CLOSE)
    3c10:	e8 fc ff ff ff       	call   3c11 <test2_idle_default_handler+0x81>
    3c15:	83 f8 01             	cmp    $0x1,%eax
    3c18:	75 98                	jne    3bb2 <test2_idle_default_handler+0x22>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3c1a:	b8 27 02 00 00       	mov    $0x227,%eax
    3c1f:	e8 fc ff ff ff       	call   3c20 <test2_idle_default_handler+0x90>
		ue_mac_sv_close();
    3c24:	e8 27 ee ff ff       	call   2a50 <ue_mac_sv_close>
    3c29:	eb 87                	jmp    3bb2 <test2_idle_default_handler+0x22>
    3c2b:	90                   	nop
    3c2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("IDLE receive a data packet from PHYadapter"); //testing code
    3c30:	b8 54 0e 00 00       	mov    $0xe54,%eax
    3c35:	e8 fc ff ff ff       	call   3c36 <test2_idle_default_handler+0xa6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3c3a:	e8 fc ff ff ff       	call   3c3b <test2_idle_default_handler+0xab>
    3c3f:	e8 fc ff ff ff       	call   3c40 <test2_idle_default_handler+0xb0>
    3c44:	e9 73 ff ff ff       	jmp    3bbc <test2_idle_default_handler+0x2c>
    3c49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
    3c50:	83 f8 0c             	cmp    $0xc,%eax
    3c53:	74 5c                	je     3cb1 <test2_idle_default_handler+0x121>
    3c55:	83 f8 31             	cmp    $0x31,%eax
    3c58:	75 9f                	jne    3bf9 <test2_idle_default_handler+0x69>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;
		//
		//PHYRA
		case NCRATEST:
				print_tran_info("IDLE receive a ncra test ");
    3c5a:	b8 04 03 00 00       	mov    $0x304,%eax
    3c5f:	e8 fc ff ff ff       	call   3c60 <test2_idle_default_handler+0xd0>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
    3c64:	e9 61 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>
				print_tran_info("IDLE receive a ncra order ");
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("IDLE receive a cra order ");
    3c69:	b8 1e 03 00 00       	mov    $0x31e,%eax
    3c6e:	e8 fc ff ff ff       	call   3c6f <test2_idle_default_handler+0xdf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    3c73:	ba 02 00 00 00       	mov    $0x2,%edx
    3c78:	31 c0                	xor    %eax,%eax
    3c7a:	e8 fc ff ff ff       	call   3c7b <test2_idle_default_handler+0xeb>
		break;
    3c7f:	e9 46 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>
    3c84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3c88:	e8 fc ff ff ff       	call   3c89 <test2_idle_default_handler+0xf9>
    3c8d:	89 c3                	mov    %eax,%ebx
			print_tran_info("IDLE receive a RLCdatareq");
    3c8f:	b8 ea 02 00 00       	mov    $0x2ea,%eax
    3c94:	e8 fc ff ff ff       	call   3c95 <test2_idle_default_handler+0x105>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3c99:	89 d8                	mov    %ebx,%eax
    3c9b:	e8 fc ff ff ff       	call   3c9c <test2_idle_default_handler+0x10c>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3ca0:	ba 02 00 00 00       	mov    $0x2,%edx
    3ca5:	31 c0                	xor    %eax,%eax
    3ca7:	e8 fc ff ff ff       	call   3ca8 <test2_idle_default_handler+0x118>
		break;
    3cac:	e9 19 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				print_tran_info("IDLE receive a ncra order ");
    3cb1:	b8 76 02 00 00       	mov    $0x276,%eax
    3cb6:	e8 fc ff ff ff       	call   3cb7 <test2_idle_default_handler+0x127>
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
    3cbb:	e9 0a ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>

00003cc0 <findInsByRbid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsByRbid(u8 rbid,void **up, void **down , RlcMode *mode)
{
    3cc0:	55                   	push   %ebp
    3cc1:	89 e5                	mov    %esp,%ebp
    3cc3:	57                   	push   %edi
    3cc4:	56                   	push   %esi
    3cc5:	53                   	push   %ebx
    3cc6:	83 ec 10             	sub    $0x10,%esp
    3cc9:	e8 fc ff ff ff       	call   3cca <findInsByRbid+0xa>
    3cce:	8b 75 08             	mov    0x8(%ebp),%esi
    3cd1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3cd4:	89 c3                	mov    %eax,%ebx
    3cd6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsByRbid());
	SV_PTR_GET(rlc_mac_sv);
    3cd9:	e8 fc ff ff ff       	call   3cda <findInsByRbid+0x1a>
	*up = *down = NULL;
    3cde:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3ce1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3ce4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    3cea:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    3cf0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    3cf6:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    3cfc:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    3d02:	39 d1                	cmp    %edx,%ecx
    3d04:	74 29                	je     3d2f <findInsByRbid+0x6f>
    3d06:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d09:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3d0c:	eb 08                	jmp    3d16 <findInsByRbid+0x56>
    3d0e:	66 90                	xchg   %ax,%ax
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3d10:	8b 12                	mov    (%edx),%edx
    3d12:	39 d1                	cmp    %edx,%ecx
    3d14:	74 16                	je     3d2c <findInsByRbid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->rbId == rbid)
    3d16:	38 5a e6             	cmp    %bl,-0x1a(%edx)
    3d19:	75 f5                	jne    3d10 <findInsByRbid+0x50>
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    3d1b:	8d 42 e4             	lea    -0x1c(%edx),%eax
    3d1e:	89 07                	mov    %eax,(%edi)
			if(tmTxIns->rbId == rbid)
			{
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
    3d20:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3d26:	8b 12                	mov    (%edx),%edx
    3d28:	39 d1                	cmp    %edx,%ecx
    3d2a:	75 ea                	jne    3d16 <findInsByRbid+0x56>
    3d2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3d2f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    3d35:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    3d3b:	39 d1                	cmp    %edx,%ecx
    3d3d:	74 28                	je     3d67 <findInsByRbid+0xa7>
    3d3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d42:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d45:	eb 07                	jmp    3d4e <findInsByRbid+0x8e>
    3d47:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3d48:	8b 12                	mov    (%edx),%edx
    3d4a:	39 d1                	cmp    %edx,%ecx
    3d4c:	74 16                	je     3d64 <findInsByRbid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->rbId == rbid)
    3d4e:	38 5a fa             	cmp    %bl,-0x6(%edx)
    3d51:	75 f5                	jne    3d48 <findInsByRbid+0x88>
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    3d53:	8d 42 f8             	lea    -0x8(%edx),%eax
    3d56:	89 07                	mov    %eax,(%edi)
			if(tmRxIns->rbId == rbid)
			{
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
    3d58:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3d5e:	8b 12                	mov    (%edx),%edx
    3d60:	39 d1                	cmp    %edx,%ecx
    3d62:	75 ea                	jne    3d4e <findInsByRbid+0x8e>
    3d64:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
			}
		}
	}
	if(*mode == TM_MODE)
    3d67:	83 3e 01             	cmpl   $0x1,(%esi)
    3d6a:	0f 84 c8 00 00 00    	je     3e38 <findInsByRbid+0x178>
    3d70:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    3d76:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    3d7c:	39 d1                	cmp    %edx,%ecx
    3d7e:	74 27                	je     3da7 <findInsByRbid+0xe7>
    3d80:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d83:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3d86:	eb 06                	jmp    3d8e <findInsByRbid+0xce>
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3d88:	8b 12                	mov    (%edx),%edx
    3d8a:	39 d1                	cmp    %edx,%ecx
    3d8c:	74 16                	je     3da4 <findInsByRbid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->rbid == rbid)
    3d8e:	38 5a d2             	cmp    %bl,-0x2e(%edx)
    3d91:	75 f5                	jne    3d88 <findInsByRbid+0xc8>
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    3d93:	8d 42 d0             	lea    -0x30(%edx),%eax
    3d96:	89 07                	mov    %eax,(%edi)
			if(umTxIns->rbid == rbid)
			{
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
    3d98:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3d9e:	8b 12                	mov    (%edx),%edx
    3da0:	39 d1                	cmp    %edx,%ecx
    3da2:	75 ea                	jne    3d8e <findInsByRbid+0xce>
    3da4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3da7:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    3dad:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    3db3:	39 d1                	cmp    %edx,%ecx
    3db5:	74 2e                	je     3de5 <findInsByRbid+0x125>
    3db7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3dba:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3dbd:	eb 07                	jmp    3dc6 <findInsByRbid+0x106>
    3dbf:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3dc0:	8b 12                	mov    (%edx),%edx
    3dc2:	39 d1                	cmp    %edx,%ecx
    3dc4:	74 1c                	je     3de2 <findInsByRbid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->rbId == rbid)
    3dc6:	38 9a 3e ef ff ff    	cmp    %bl,-0x10c2(%edx)
    3dcc:	75 f2                	jne    3dc0 <findInsByRbid+0x100>
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    3dce:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
    3dd4:	89 07                	mov    %eax,(%edi)
			if(umRxIns->rbId == rbid)
			{
				*down = (void*)umRxIns;
				*mode = UM_MODE;
    3dd6:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3ddc:	8b 12                	mov    (%edx),%edx
    3dde:	39 d1                	cmp    %edx,%ecx
    3de0:	75 e4                	jne    3dc6 <findInsByRbid+0x106>
    3de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)umRxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(*mode == UM_MODE)
    3de5:	83 3e 02             	cmpl   $0x2,(%esi)
    3de8:	74 4e                	je     3e38 <findInsByRbid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    3dea:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    3df0:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    3df6:	39 c2                	cmp    %eax,%edx
    3df8:	74 3e                	je     3e38 <findInsByRbid+0x178>
    3dfa:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3dfd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    3e00:	eb 0c                	jmp    3e0e <findInsByRbid+0x14e>
    3e02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3e08:	8b 00                	mov    (%eax),%eax
    3e0a:	39 c2                	cmp    %eax,%edx
    3e0c:	74 2a                	je     3e38 <findInsByRbid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->rbId == rbid)
    3e0e:	38 98 fe dc ff ff    	cmp    %bl,-0x2302(%eax)
    3e14:	75 f2                	jne    3e08 <findInsByRbid+0x148>
			{
				*mode = AM_MODE;
    3e16:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    3e19:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->rbId == rbid)
			{
				*mode = AM_MODE;
    3e1f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    3e25:	8b 75 ec             	mov    -0x14(%ebp),%esi
    3e28:	89 0f                	mov    %ecx,(%edi)
    3e2a:	89 0e                	mov    %ecx,(%esi)
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3e2c:	8b 00                	mov    (%eax),%eax
    3e2e:	39 c2                	cmp    %eax,%edx
    3e30:	75 dc                	jne    3e0e <findInsByRbid+0x14e>
    3e32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				*up = *down =  (void*)amIns;
			}
		}
	}
	FOUT;
}
    3e38:	83 c4 10             	add    $0x10,%esp
    3e3b:	5b                   	pop    %ebx
    3e3c:	5e                   	pop    %esi
    3e3d:	5f                   	pop    %edi
    3e3e:	5d                   	pop    %ebp
    3e3f:	c3                   	ret    

00003e40 <rlc_mac_main>:
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
    3e40:	55                   	push   %ebp
    3e41:	89 e5                	mov    %esp,%ebp
    3e43:	83 ec 3c             	sub    $0x3c,%esp
    3e46:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3e49:	89 75 f8             	mov    %esi,-0x8(%ebp)
    3e4c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    3e4f:	e8 fc ff ff ff       	call   3e50 <rlc_mac_main+0x10>
	FSM_ENTER(rlc_mac_main);
    3e54:	e8 fc ff ff ff       	call   3e55 <rlc_mac_main+0x15>
	FSM_BLOCK_SWITCH
    3e59:	83 38 19             	cmpl   $0x19,(%eax)
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
    3e5c:	89 c6                	mov    %eax,%esi
	FSM_BLOCK_SWITCH
    3e5e:	76 18                	jbe    3e78 <rlc_mac_main+0x38>
		FSM_STATE_FORCED(ST_NULL_IDLE, "NULL_IDLE", , )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
    3e60:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
    3e66:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    3e69:	8b 75 f8             	mov    -0x8(%ebp),%esi
    3e6c:	8b 7d fc             	mov    -0x4(%ebp),%edi
    3e6f:	89 ec                	mov    %ebp,%esp
    3e71:	5d                   	pop    %ebp
    3e72:	c3                   	ret    
    3e73:	90                   	nop
    3e74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
    3e78:	8b 00                	mov    (%eax),%eax
    3e7a:	ff 24 85 00 03 00 00 	jmp    *0x300(,%eax,4)
    3e81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    3e88:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    3e8f:	03 00 00 
		{
			FSM_COND_TEST_IN("IDLE")				
    3e92:	31 db                	xor    %ebx,%ebx
    3e94:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    3e99:	e8 fc ff ff ff       	call   3e9a <rlc_mac_main+0x5a>
    3e9e:	83 f8 03             	cmp    $0x3,%eax
    3ea1:	0f 84 a4 0f 00 00    	je     4e4b <rlc_mac_main+0x100b>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    3ea7:	e8 fc ff ff ff       	call   3ea8 <rlc_mac_main+0x68>
    3eac:	83 f8 03             	cmp    $0x3,%eax
    3eaf:	90                   	nop
    3eb0:	0f 84 7a 0f 00 00    	je     4e30 <rlc_mac_main+0xff0>
				FSM_TEST_COND(MAC_RESET)
    3eb6:	e8 fc ff ff ff       	call   3eb7 <rlc_mac_main+0x77>
    3ebb:	83 f8 05             	cmp    $0x5,%eax
    3ebe:	66 90                	xchg   %ax,%ax
    3ec0:	0f 84 3d 0f 00 00    	je     4e03 <rlc_mac_main+0xfc3>
				
				FSM_TEST_COND(RLC_SUSPEND)
    3ec6:	e8 fc ff ff ff       	call   3ec7 <rlc_mac_main+0x87>
    3ecb:	83 f8 03             	cmp    $0x3,%eax
    3ece:	66 90                	xchg   %ax,%ax
    3ed0:	0f 84 12 0f 00 00    	je     4de8 <rlc_mac_main+0xfa8>
				FSM_TEST_COND(RLC_DEACT)
    3ed6:	e8 fc ff ff ff       	call   3ed7 <rlc_mac_main+0x97>
    3edb:	83 f8 03             	cmp    $0x3,%eax
    3ede:	66 90                	xchg   %ax,%ax
    3ee0:	0f 84 89 0e 00 00    	je     4d6f <rlc_mac_main+0xf2f>
				FSM_TEST_COND(RLC_RESUME)
    3ee6:	e8 fc ff ff ff       	call   3ee7 <rlc_mac_main+0xa7>
    3eeb:	83 f8 03             	cmp    $0x3,%eax
    3eee:	66 90                	xchg   %ax,%ax
    3ef0:	0f 84 5e 0e 00 00    	je     4d54 <rlc_mac_main+0xf14>
			FSM_COND_TEST_OUT("IDLE")
    3ef6:	83 fb 01             	cmp    $0x1,%ebx
    3ef9:	0f 8e 01 08 00 00    	jle    4700 <rlc_mac_main+0x8c0>
    3eff:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    3f06:	00 
    3f07:	c7 44 24 04 4f 03 00 	movl   $0x34f,0x4(%esp)
    3f0e:	00 
    3f0f:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    3f16:	e8 fc ff ff ff       	call   3f17 <rlc_mac_main+0xd7>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    3f1b:	c7 05 30 00 00 00 86 	movl   $0x386,0x30
    3f22:	03 00 00 
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    3f25:	e8 fc ff ff ff       	call   3f26 <rlc_mac_main+0xe6>
    3f2a:	89 c7                	mov    %eax,%edi
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code
    3f2c:	b8 dc 0e 00 00       	mov    $0xedc,%eax
    3f31:	e8 fc ff ff ff       	call   3f32 <rlc_mac_main+0xf2>

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    3f36:	e8 fc ff ff ff       	call   3f37 <rlc_mac_main+0xf7>
    3f3b:	83 f8 05             	cmp    $0x5,%eax
    3f3e:	0f 84 96 13 00 00    	je     52da <rlc_mac_main+0x149a>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    3f44:	e8 fc ff ff ff       	call   3f45 <rlc_mac_main+0x105>
    3f49:	83 f8 05             	cmp    $0x5,%eax
    3f4c:	0f 84 49 14 00 00    	je     539b <rlc_mac_main+0x155b>
	{
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    3f52:	e8 fc ff ff ff       	call   3f53 <rlc_mac_main+0x113>
    3f57:	83 f8 02             	cmp    $0x2,%eax
    3f5a:	0f 84 02 14 00 00    	je     5362 <rlc_mac_main+0x1522>
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    3f60:	e8 fc ff ff ff       	call   3f61 <rlc_mac_main+0x121>
    3f65:	83 f8 01             	cmp    $0x1,%eax
    3f68:	0f 84 6f 17 00 00    	je     56dd <rlc_mac_main+0x189d>
    3f6e:	66 90                	xchg   %ax,%ax
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    3f70:	e8 fc ff ff ff       	call   3f71 <rlc_mac_main+0x131>
    3f75:	83 f8 03             	cmp    $0x3,%eax
    3f78:	0f 84 a0 16 00 00    	je     561e <rlc_mac_main+0x17de>
    3f7e:	66 90                	xchg   %ax,%ax
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    3f80:	e8 fc ff ff ff       	call   3f81 <rlc_mac_main+0x141>
    3f85:	83 f8 03             	cmp    $0x3,%eax
    3f88:	0f 84 e8 16 00 00    	je     5676 <rlc_mac_main+0x1836>
    3f8e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
    3f90:	e8 fc ff ff ff       	call   3f91 <rlc_mac_main+0x151>
    3f95:	83 f8 03             	cmp    $0x3,%eax
    3f98:	0f 84 97 16 00 00    	je     5635 <rlc_mac_main+0x17f5>
    3f9e:	66 90                	xchg   %ax,%ax
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    3fa0:	e8 fc ff ff ff       	call   3fa1 <rlc_mac_main+0x161>
    3fa5:	83 f8 05             	cmp    $0x5,%eax
    3fa8:	0f 85 ba 20 00 00    	jne    6068 <rlc_mac_main+0x2228>
    3fae:	66 90                	xchg   %ax,%ax
    3fb0:	e8 fc ff ff ff       	call   3fb1 <rlc_mac_main+0x171>
    3fb5:	83 f8 02             	cmp    $0x2,%eax
    3fb8:	0f 85 aa 20 00 00    	jne    6068 <rlc_mac_main+0x2228>
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
    3fbe:	b8 48 10 00 00       	mov    $0x1048,%eax
    3fc3:	e8 fc ff ff ff       	call   3fc4 <rlc_mac_main+0x184>
		u32 cmd1=fsm_ev_ioctrl_cmd();
    3fc8:	e8 fc ff ff ff       	call   3fc9 <rlc_mac_main+0x189>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
    3fcd:	89 44 24 04          	mov    %eax,0x4(%esp)
    3fd1:	c7 04 24 91 03 00 00 	movl   $0x391,(%esp)
    3fd8:	e8 fc ff ff ff       	call   3fd9 <rlc_mac_main+0x199>
		switch(fsm_ev_ioctrl_cmd())
    3fdd:	e8 fc ff ff ff       	call   3fde <rlc_mac_main+0x19e>
    3fe2:	83 f8 0b             	cmp    $0xb,%eax
    3fe5:	0f 84 ce 18 00 00    	je     58b9 <rlc_mac_main+0x1a79>
    3feb:	90                   	nop
    3fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3ff0:	0f 87 f8 16 00 00    	ja     56ee <rlc_mac_main+0x18ae>
    3ff6:	83 f8 04             	cmp    $0x4,%eax
    3ff9:	0f 84 af 19 00 00    	je     59ae <rlc_mac_main+0x1b6e>
    3fff:	90                   	nop
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
				fsm_data_destroy(tmpdata_ptr);
			break;
			default:
				ioctrl_handler();
    4000:	e8 db ea ff ff       	call   2ae0 <ioctrl_handler>
			break;
		}
		reports_handler();//BSR PHR 
    4005:	e8 b6 f1 ff ff       	call   31c0 <reports_handler>
    400a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    4010:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4016:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4019:	8b 75 f8             	mov    -0x8(%ebp),%esi
    401c:	8b 7d fc             	mov    -0x4(%ebp),%edi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    401f:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    4026:	03 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4029:	89 ec                	mov    %ebp,%esp
    402b:	5d                   	pop    %ebp
    402c:	c3                   	ret    
    402d:	8b 75 dc             	mov    -0x24(%ebp),%esi
			do_bsr_and_resource_alloc();	//this function should in while loop or not? this a question
		}
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
    4030:	e8 fc ff ff ff       	call   4031 <rlc_mac_main+0x1f1>
    4035:	83 f8 02             	cmp    $0x2,%eax
    4038:	0f 84 d6 20 00 00    	je     6114 <rlc_mac_main+0x22d4>
		}
		decomplexUeDataPdu(skb);
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    403e:	e8 fc ff ff ff       	call   403f <rlc_mac_main+0x1ff>
    4043:	83 f8 01             	cmp    $0x1,%eax
    4046:	0f 84 69 13 00 00    	je     53b5 <rlc_mac_main+0x1575>
    404c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4050:	e8 fc ff ff ff       	call   4051 <rlc_mac_main+0x211>
    4055:	83 f8 03             	cmp    $0x3,%eax
    4058:	0f 84 18 15 00 00    	je     5576 <rlc_mac_main+0x1736>
    405e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
    4060:	e8 fc ff ff ff       	call   4061 <rlc_mac_main+0x221>
    4065:	83 f8 03             	cmp    $0x3,%eax
    4068:	0f 84 bf 14 00 00    	je     552d <rlc_mac_main+0x16ed>
    406e:	66 90                	xchg   %ax,%ax
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
	}
	else if(IOCTRL_ARRIVAL)
    4070:	e8 fc ff ff ff       	call   4071 <rlc_mac_main+0x231>
    4075:	83 f8 05             	cmp    $0x5,%eax
    4078:	0f 85 87 1f 00 00    	jne    6005 <rlc_mac_main+0x21c5>
    407e:	66 90                	xchg   %ax,%ax
    4080:	e8 fc ff ff ff       	call   4081 <rlc_mac_main+0x241>
    4085:	83 f8 02             	cmp    $0x2,%eax
    4088:	0f 85 77 1f 00 00    	jne    6005 <rlc_mac_main+0x21c5>
    408e:	66 90                	xchg   %ax,%ax
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
    4090:	e8 fc ff ff ff       	call   4091 <rlc_mac_main+0x251>
    4095:	83 f8 0b             	cmp    $0xb,%eax
    4098:	0f 84 80 16 00 00    	je     571e <rlc_mac_main+0x18de>
    409e:	66 90                	xchg   %ax,%ax
			//RLCdatareqMAC reqregularBSR 
			//SR RLCreq
			//MACSR  
		}
		else 
			ioctrl_handler();  //ioctrl		
    40a0:	e8 3b ea ff ff       	call   2ae0 <ioctrl_handler>
		//print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
    40a5:	e8 16 f1 ff ff       	call   31c0 <reports_handler>
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
	}
	//fsm_printf("[RLC_MAC][con_default_handler][end]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	fsm_mem_free(pdu_type);
    40aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    40ad:	e8 fc ff ff ff       	call   40ae <rlc_mac_main+0x26e>
    40b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    40b8:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    40be:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    40c1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    40c4:	8b 7d fc             	mov    -0x4(%ebp),%edi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    40c7:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    40ce:	04 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    40d1:	89 ec                	mov    %ebp,%esp
    40d3:	5d                   	pop    %ebp
    40d4:	c3                   	ret    
    40d5:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    40d8:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    40df:	03 00 00 
		{
			FSM_COND_TEST_IN("CRA")
    40e2:	31 db                	xor    %ebx,%ebx
    40e4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    40e9:	e8 fc ff ff ff       	call   40ea <rlc_mac_main+0x2aa>
    40ee:	83 f8 03             	cmp    $0x3,%eax
    40f1:	0f 84 ca 0b 00 00    	je     4cc1 <rlc_mac_main+0xe81>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    40f7:	e8 fc ff ff ff       	call   40f8 <rlc_mac_main+0x2b8>
    40fc:	83 f8 03             	cmp    $0x3,%eax
    40ff:	90                   	nop
    4100:	0f 84 4a 0a 00 00    	je     4b50 <rlc_mac_main+0xd10>
    4106:	e8 fc ff ff ff       	call   4107 <rlc_mac_main+0x2c7>
    410b:	83 f8 03             	cmp    $0x3,%eax
    410e:	66 90                	xchg   %ax,%ax
    4110:	0f 84 7a 0a 00 00    	je     4b90 <rlc_mac_main+0xd50>
    4116:	e8 fc ff ff ff       	call   4117 <rlc_mac_main+0x2d7>
    411b:	83 f8 05             	cmp    $0x5,%eax
    411e:	66 90                	xchg   %ax,%ax
    4120:	0f 84 12 0f 00 00    	je     5038 <rlc_mac_main+0x11f8>
				FSM_TEST_COND(RARREV_SUCCESS)
    4126:	e8 fc ff ff ff       	call   4127 <rlc_mac_main+0x2e7>
    412b:	83 f8 03             	cmp    $0x3,%eax
    412e:	66 90                	xchg   %ax,%ax
    4130:	0f 84 fa 09 00 00    	je     4b30 <rlc_mac_main+0xcf0>
    4136:	e8 fc ff ff ff       	call   4137 <rlc_mac_main+0x2f7>
    413b:	83 f8 05             	cmp    $0x5,%eax
    413e:	66 90                	xchg   %ax,%ax
    4140:	0f 84 92 0d 00 00    	je     4ed8 <rlc_mac_main+0x1098>
				FSM_TEST_COND(CONTENTION_FAIL)
    4146:	e8 fc ff ff ff       	call   4147 <rlc_mac_main+0x307>
    414b:	83 f8 03             	cmp    $0x3,%eax
    414e:	66 90                	xchg   %ax,%ax
    4150:	0f 84 ba 09 00 00    	je     4b10 <rlc_mac_main+0xcd0>
    4156:	e8 fc ff ff ff       	call   4157 <rlc_mac_main+0x317>
    415b:	83 f8 03             	cmp    $0x3,%eax
    415e:	66 90                	xchg   %ax,%ax
    4160:	0f 84 62 0a 00 00    	je     4bc8 <rlc_mac_main+0xd88>
    4166:	e8 fc ff ff ff       	call   4167 <rlc_mac_main+0x327>
    416b:	83 f8 05             	cmp    $0x5,%eax
    416e:	66 90                	xchg   %ax,%ax
    4170:	0f 84 a0 0e 00 00    	je     5016 <rlc_mac_main+0x11d6>
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4176:	e8 fc ff ff ff       	call   4177 <rlc_mac_main+0x337>
    417b:	83 f8 03             	cmp    $0x3,%eax
    417e:	66 90                	xchg   %ax,%ax
    4180:	0f 84 6a 09 00 00    	je     4af0 <rlc_mac_main+0xcb0>
    4186:	e8 fc ff ff ff       	call   4187 <rlc_mac_main+0x347>
    418b:	83 f8 05             	cmp    $0x5,%eax
    418e:	66 90                	xchg   %ax,%ax
    4190:	0f 84 1d 0d 00 00    	je     4eb3 <rlc_mac_main+0x1073>
				FSM_TEST_COND(MAC_RESET)
    4196:	e8 fc ff ff ff       	call   4197 <rlc_mac_main+0x357>
    419b:	83 f8 05             	cmp    $0x5,%eax
    419e:	66 90                	xchg   %ax,%ax
    41a0:	0f 84 12 0c 00 00    	je     4db8 <rlc_mac_main+0xf78>
			FSM_COND_TEST_OUT("CRA")
    41a6:	83 fb 01             	cmp    $0x1,%ebx
    41a9:	0f 8e 09 06 00 00    	jle    47b8 <rlc_mac_main+0x978>
    41af:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    41b6:	00 
    41b7:	c7 44 24 04 a7 03 00 	movl   $0x3a7,0x4(%esp)
    41be:	00 
    41bf:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    41c6:	e8 fc ff ff ff       	call   41c7 <rlc_mac_main+0x387>
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
				FSM_CASE_DEFAULT(ST_CRA,cra_default_handler() , "CRA->CRA")	//transit to CRA state	by default.
    41cb:	c7 05 30 00 00 00 cd 	movl   $0x3cd,0x30
    41d2:	03 00 00 
{
	void *tmpdata_ptr;
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    41d5:	e8 fc ff ff ff       	call   41d6 <rlc_mac_main+0x396>
    41da:	89 c3                	mov    %eax,%ebx

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    41dc:	b8 01 00 00 00       	mov    $0x1,%eax
    41e1:	e8 fc ff ff ff       	call   41e2 <rlc_mac_main+0x3a2>
	fsm_mem_set(pdu_type,0,sizeof(char));
    41e6:	31 d2                	xor    %edx,%edx
    41e8:	b9 01 00 00 00       	mov    $0x1,%ecx
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    41ed:	89 c7                	mov    %eax,%edi
	fsm_mem_set(pdu_type,0,sizeof(char));
    41ef:	e8 fc ff ff ff       	call   41f0 <rlc_mac_main+0x3b0>

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    41f4:	83 bb ec 01 00 00 01 	cmpl   $0x1,0x1ec(%ebx)
    41fb:	0f 84 fb 10 00 00    	je     52fc <rlc_mac_main+0x14bc>
		fsm_schedule_self(0, Contention_Success );//TEST  
	if(MAC_CLOSE)
    4201:	e8 fc ff ff ff       	call   4202 <rlc_mac_main+0x3c2>
    4206:	83 f8 05             	cmp    $0x5,%eax
    4209:	0f 84 08 11 00 00    	je     5317 <rlc_mac_main+0x14d7>
    420f:	90                   	nop
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    4210:	e8 fc ff ff ff       	call   4211 <rlc_mac_main+0x3d1>
    4215:	83 f8 02             	cmp    $0x2,%eax
    4218:	0f 84 c7 1c 00 00    	je     5ee5 <rlc_mac_main+0x20a5>
    421e:	66 90                	xchg   %ax,%ax
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_pkt_destroy(fsm_pkt_get());
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
    4220:	e8 fc ff ff ff       	call   4221 <rlc_mac_main+0x3e1>
    4225:	83 f8 01             	cmp    $0x1,%eax
    4228:	0f 84 6a 12 00 00    	je     5498 <rlc_mac_main+0x1658>
    422e:	66 90                	xchg   %ax,%ax
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4230:	e8 fc ff ff ff       	call   4231 <rlc_mac_main+0x3f1>
    4235:	83 f8 03             	cmp    $0x3,%eax
    4238:	0f 84 2e 12 00 00    	je     546c <rlc_mac_main+0x162c>
    423e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    4240:	e8 fc ff ff ff       	call   4241 <rlc_mac_main+0x401>
    4245:	83 f8 05             	cmp    $0x5,%eax
    4248:	75 1e                	jne    4268 <rlc_mac_main+0x428>
    424a:	e8 fc ff ff ff       	call   424b <rlc_mac_main+0x40b>
    424f:	83 f8 02             	cmp    $0x2,%eax
    4252:	75 14                	jne    4268 <rlc_mac_main+0x428>
	{
		switch(fsm_ev_ioctrl_cmd())
    4254:	e8 fc ff ff ff       	call   4255 <rlc_mac_main+0x415>
    4259:	83 f8 0b             	cmp    $0xb,%eax
    425c:	0f 84 1f 1c 00 00    	je     5e81 <rlc_mac_main+0x2041>
					tmpdata_ptr = (char *)fsm_data_get();
					fsm_data_destroy((void *)tmpdata_ptr);//
				}				
			break;
			default:
				ioctrl_handler();//ioctrl
    4262:	e8 79 e8 ff ff       	call   2ae0 <ioctrl_handler>
    4267:	90                   	nop
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    4268:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    426f:	03 00 00 
    4272:	c7 06 05 00 00 00    	movl   $0x5,(%esi)
    4278:	e9 e9 fb ff ff       	jmp    3e66 <rlc_mac_main+0x26>
    427d:	8d 76 00             	lea    0x0(%esi),%esi
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    4280:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    4287:	03 00 00 
		{
			FSM_COND_TEST_IN("NCRA")
    428a:	31 db                	xor    %ebx,%ebx
    428c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4291:	e8 fc ff ff ff       	call   4292 <rlc_mac_main+0x452>
    4296:	83 f8 03             	cmp    $0x3,%eax
    4299:	0f 84 c5 0b 00 00    	je     4e64 <rlc_mac_main+0x1024>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    429f:	e8 fc ff ff ff       	call   42a0 <rlc_mac_main+0x460>
    42a4:	83 f8 03             	cmp    $0x3,%eax
    42a7:	0f 84 c3 08 00 00    	je     4b70 <rlc_mac_main+0xd30>
    42ad:	8d 76 00             	lea    0x0(%esi),%esi
    42b0:	e8 fc ff ff ff       	call   42b1 <rlc_mac_main+0x471>
    42b5:	83 f8 03             	cmp    $0x3,%eax
    42b8:	0f 84 ea 08 00 00    	je     4ba8 <rlc_mac_main+0xd68>
    42be:	66 90                	xchg   %ax,%ax
    42c0:	e8 fc ff ff ff       	call   42c1 <rlc_mac_main+0x481>
    42c5:	83 f8 05             	cmp    $0x5,%eax
    42c8:	0f 84 9a 0d 00 00    	je     5068 <rlc_mac_main+0x1228>
    42ce:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RARREV_SUCCESS)
    42d0:	e8 fc ff ff ff       	call   42d1 <rlc_mac_main+0x491>
    42d5:	83 f8 03             	cmp    $0x3,%eax
    42d8:	0f 84 f2 07 00 00    	je     4ad0 <rlc_mac_main+0xc90>
    42de:	66 90                	xchg   %ax,%ax
    42e0:	e8 fc ff ff ff       	call   42e1 <rlc_mac_main+0x4a1>
    42e5:	83 f8 05             	cmp    $0x5,%eax
    42e8:	0f 84 1a 0c 00 00    	je     4f08 <rlc_mac_main+0x10c8>
    42ee:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(MAC_RESET)
    42f0:	e8 fc ff ff ff       	call   42f1 <rlc_mac_main+0x4b1>
    42f5:	83 f8 05             	cmp    $0x5,%eax
    42f8:	0f 84 8c 0a 00 00    	je     4d8a <rlc_mac_main+0xf4a>
			FSM_COND_TEST_OUT("NCRA")
    42fe:	83 fb 01             	cmp    $0x1,%ebx
    4301:	0f 8e 81 07 00 00    	jle    4a88 <rlc_mac_main+0xc48>
    4307:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    430e:	00 
    430f:	c7 44 24 04 d6 03 00 	movl   $0x3d6,0x4(%esp)
    4316:	00 
    4317:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    431e:	e8 fc ff ff ff       	call   431f <rlc_mac_main+0x4df>
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4323:	b8 b8 17 00 00       	mov    $0x17b8,%eax
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
    4328:	c7 05 30 00 00 00 f4 	movl   $0x3f4,0x30
    432f:	03 00 00 
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4332:	e8 fc ff ff ff       	call   4333 <rlc_mac_main+0x4f3>
	if(MAC_CLOSE)
    4337:	e8 fc ff ff ff       	call   4338 <rlc_mac_main+0x4f8>
    433c:	83 f8 05             	cmp    $0x5,%eax
    433f:	0f 84 95 12 00 00    	je     55da <rlc_mac_main+0x179a>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    4345:	e8 fc ff ff ff       	call   4346 <rlc_mac_main+0x506>
    434a:	83 f8 02             	cmp    $0x2,%eax
    434d:	0f 84 76 12 00 00    	je     55c9 <rlc_mac_main+0x1789>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4353:	e8 fc ff ff ff       	call   4354 <rlc_mac_main+0x514>
    4358:	83 f8 03             	cmp    $0x3,%eax
    435b:	0f 84 3e 12 00 00    	je     559f <rlc_mac_main+0x175f>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
	}
	if(IOCTRL_ARRIVAL)
    4361:	e8 fc ff ff ff       	call   4362 <rlc_mac_main+0x522>
    4366:	83 f8 05             	cmp    $0x5,%eax
    4369:	75 15                	jne    4380 <rlc_mac_main+0x540>
    436b:	90                   	nop
    436c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4370:	e8 fc ff ff ff       	call   4371 <rlc_mac_main+0x531>
    4375:	83 f8 02             	cmp    $0x2,%eax
    4378:	75 06                	jne    4380 <rlc_mac_main+0x540>
		ioctrl_handler();//ioctrl
    437a:	e8 61 e7 ff ff       	call   2ae0 <ioctrl_handler>
    437f:	90                   	nop
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    4380:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    4387:	03 00 00 
    438a:	c7 06 07 00 00 00    	movl   $0x7,(%esi)
    4390:	e9 d1 fa ff ff       	jmp    3e66 <rlc_mac_main+0x26>
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
    4395:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
		}
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
    439b:	c7 05 30 00 00 00 3d 	movl   $0x33d,0x30
    43a2:	03 00 00 
    43a5:	e8 76 e3 ff ff       	call   2720 <rlc_init_enter>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
    43aa:	e9 61 fc ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    43af:	90                   	nop
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    43b0:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    43b7:	04 00 00 
		{
			FSM_COND_TEST_IN("CON")
    43ba:	31 db                	xor    %ebx,%ebx
    43bc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    43c1:	e8 fc ff ff ff       	call   43c2 <rlc_mac_main+0x582>
    43c6:	83 f8 03             	cmp    $0x3,%eax
    43c9:	0f 84 6c 09 00 00    	je     4d3b <rlc_mac_main+0xefb>
				FSM_TEST_COND(SR_FAIL)
    43cf:	e8 fc ff ff ff       	call   43d0 <rlc_mac_main+0x590>
    43d4:	83 f8 03             	cmp    $0x3,%eax
    43d7:	0f 84 43 09 00 00    	je     4d20 <rlc_mac_main+0xee0>
    43dd:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_TEST_COND(MAC_RESET)
    43e0:	e8 fc ff ff ff       	call   43e1 <rlc_mac_main+0x5a1>
    43e5:	83 f8 05             	cmp    $0x5,%eax
    43e8:	0f 84 07 09 00 00    	je     4cf5 <rlc_mac_main+0xeb5>
    43ee:	66 90                	xchg   %ax,%ax

				FSM_TEST_COND(RLC_SUSPEND)
    43f0:	e8 fc ff ff ff       	call   43f1 <rlc_mac_main+0x5b1>
    43f5:	83 f8 03             	cmp    $0x3,%eax
    43f8:	0f 84 9a 0a 00 00    	je     4e98 <rlc_mac_main+0x1058>
    43fe:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_DEACT)
    4400:	e8 fc ff ff ff       	call   4401 <rlc_mac_main+0x5c1>
    4405:	83 f8 03             	cmp    $0x3,%eax
    4408:	0f 84 6f 0a 00 00    	je     4e7d <rlc_mac_main+0x103d>
    440e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_RESUME)
    4410:	e8 fc ff ff ff       	call   4411 <rlc_mac_main+0x5d1>
    4415:	83 f8 03             	cmp    $0x3,%eax
    4418:	0f 84 bc 08 00 00    	je     4cda <rlc_mac_main+0xe9a>
			FSM_COND_TEST_OUT("CON")
    441e:	83 fb 01             	cmp    $0x1,%ebx
    4421:	0f 8e 79 02 00 00    	jle    46a0 <rlc_mac_main+0x860>
    4427:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    442e:	00 
    442f:	c7 44 24 04 01 04 00 	movl   $0x401,0x4(%esp)
    4436:	00 
    4437:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    443e:	e8 fc ff ff ff       	call   443f <rlc_mac_main+0x5ff>
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    4443:	b8 01 00 00 00       	mov    $0x1,%eax
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_CON,con_default_handler() , "CON -> CON")	//transit to CON state	by default.
    4448:	c7 05 30 00 00 00 1c 	movl   $0x41c,0x30
    444f:	04 00 00 
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    4452:	e8 fc ff ff ff       	call   4453 <rlc_mac_main+0x613>
	fsm_mem_set(pdu_type,0,sizeof(char));
    4457:	31 d2                	xor    %edx,%edx
    4459:	b9 01 00 00 00       	mov    $0x1,%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    445e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_mem_set(pdu_type,0,sizeof(char));
    4461:	e8 fc ff ff ff       	call   4462 <rlc_mac_main+0x622>

	FIN(con_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4466:	e8 fc ff ff ff       	call   4467 <rlc_mac_main+0x627>
    446b:	89 c7                	mov    %eax,%edi

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    446d:	e8 fc ff ff ff       	call   446e <rlc_mac_main+0x62e>
    4472:	83 f8 05             	cmp    $0x5,%eax
    4475:	0f 84 bf 0e 00 00    	je     533a <rlc_mac_main+0x14fa>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    447b:	e8 fc ff ff ff       	call   447c <rlc_mac_main+0x63c>
    4480:	83 f8 05             	cmp    $0x5,%eax
    4483:	0f 84 fa 12 00 00    	je     5783 <rlc_mac_main+0x1943>
		rlc_close();
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
		FOUT;
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
    4489:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4490:	74 0a                	je     449c <rlc_mac_main+0x65c>
    4492:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    4496:	0f 85 03 12 00 00    	jne    569f <rlc_mac_main+0x185f>
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
    449c:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    44a2:	66 83 7a 08 00       	cmpw   $0x0,0x8(%edx)
    44a7:	0f 84 83 fb ff ff    	je     4030 <rlc_mac_main+0x1f0>
	fsm_octets_print(skb->data,64);
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    44ad:	89 75 dc             	mov    %esi,-0x24(%ebp)
    44b0:	e9 c7 00 00 00       	jmp    457c <rlc_mac_main+0x73c>
    44b5:	8d 76 00             	lea    0x0(%esi),%esi
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
    44b8:	83 f8 03             	cmp    $0x3,%eax
    44bb:	0f 84 ba 0a 00 00    	je     4f7b <rlc_mac_main+0x113b>
    44c1:	83 f8 01             	cmp    $0x1,%eax
    44c4:	0f 84 6e 0a 00 00    	je     4f38 <rlc_mac_main+0x10f8>
			tmTxIns->tmSduBufferSize += skb->len;
			
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    44ca:	83 86 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%esi)
			printk("[RLC][skb_from_cra_to_con] cannot distinfuish this %d\n", SV(ins_mode));
    44d1:	89 44 24 04          	mov    %eax,0x4(%esp)
    44d5:	c7 04 24 80 1a 00 00 	movl   $0x1a80,(%esp)
    44dc:	e8 fc ff ff ff       	call   44dd <rlc_mac_main+0x69d>
			printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    44e1:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    44e7:	c7 04 24 b8 1a 00 00 	movl   $0x1ab8,(%esp)
    44ee:	89 44 24 04          	mov    %eax,0x4(%esp)
    44f2:	e8 fc ff ff ff       	call   44f3 <rlc_mac_main+0x6b3>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    44f7:	89 d8                	mov    %ebx,%eax
    44f9:	e8 fc ff ff ff       	call   44fa <rlc_mac_main+0x6ba>
{
	char *tmpdata_ptr;
	int tmpdata;

	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);
    44fe:	e8 fc ff ff ff       	call   44ff <rlc_mac_main+0x6bf>
    4503:	89 c3                	mov    %eax,%ebx

	if( PMRLC_BUFFERREP_REQ() == NULL )
    4505:	e8 fc ff ff ff       	call   4506 <rlc_mac_main+0x6c6>
    450a:	85 c0                	test   %eax,%eax
    450c:	0f 84 88 0c 00 00    	je     519a <rlc_mac_main+0x135a>
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4512:	e8 fc ff ff ff       	call   4513 <rlc_mac_main+0x6d3>
		tmpdata = *((u32*)tmpdata_ptr);//	
    4517:	8b 10                	mov    (%eax),%edx
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4519:	89 c6                	mov    %eax,%esi
		tmpdata = *((u32*)tmpdata_ptr);//	
		if( tmpdata > 0 )
    451b:	85 d2                	test   %edx,%edx
    451d:	7e 21                	jle    4540 <rlc_mac_main+0x700>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    451f:	8d 40 04             	lea    0x4(%eax),%eax
    4522:	e8 fc ff ff ff       	call   4523 <rlc_mac_main+0x6e3>
    4527:	e8 fc ff ff ff       	call   4528 <rlc_mac_main+0x6e8>
			fsm_data_destroy((void *)tmpdata_ptr);//
    452c:	89 f0                	mov    %esi,%eax
    452e:	e8 fc ff ff ff       	call   452f <rlc_mac_main+0x6ef>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    4533:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    453a:	0f 85 b1 0b 00 00    	jne    50f1 <rlc_mac_main+0x12b1>
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    4540:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
		}
	}

	SV(UL_resource_info.resource_flag) = true;
    4546:	c6 43 28 01          	movb   $0x1,0x28(%ebx)
		/********for test 20150916 *********/
	if(SV(UL_resource_info.resource_flag) == true)
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
    454a:	c7 43 2c f0 2d 00 00 	movl   $0x2df0,0x2c(%ebx)
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4551:	c7 83 f4 01 00 00 be 	movl   $0x5be,0x1f4(%ebx)
    4558:	05 00 00 
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    455b:	8d 50 05             	lea    0x5(%eax),%edx
    455e:	39 50 05             	cmp    %edx,0x5(%eax)
    4561:	74 0f                	je     4572 <rlc_mac_main+0x732>
			DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    4563:	b8 f0 2d 00 00       	mov    $0x2df0,%eax
    4568:	e8 fc ff ff ff       	call   4569 <rlc_mac_main+0x729>
    456d:	e8 fc ff ff ff       	call   456e <rlc_mac_main+0x72e>
		SV(UL_resource_info.resource_flag)=false;
    4572:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    4576:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    457c:	8b 0a                	mov    (%edx),%ecx
    457e:	8b 72 04             	mov    0x4(%edx),%esi
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
    4581:	39 f1                	cmp    %esi,%ecx
    4583:	0f 84 a4 fa ff ff    	je     402d <rlc_mac_main+0x1ed>
//the first node is head node, so always take the second node out.
static FSM_PKT * DeQueue(CraQueuePtr *Q)
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
    4589:	3b 97 18 02 00 00    	cmp    0x218(%edi),%edx
    458f:	0f 84 16 0c 00 00    	je     51ab <rlc_mac_main+0x136b>
	// p = (*Q)->front;
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
    4595:	8b 41 04             	mov    0x4(%ecx),%eax
	pktptr = p->pkt;
	if((*Q)->rear == p)
    4598:	39 f0                	cmp    %esi,%eax
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
    459a:	8b 18                	mov    (%eax),%ebx
	if((*Q)->rear == p)
    459c:	0f 84 f6 0a 00 00    	je     5098 <rlc_mac_main+0x1258>
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
		(*Q)->front->next = NULL;
	}
	else
		(*Q)->front->next = p->next;	//more than 2 pkt in the queue.
    45a2:	8b 50 04             	mov    0x4(%eax),%edx
    45a5:	89 51 04             	mov    %edx,0x4(%ecx)

	fsm_mem_free(p);
    45a8:	e8 fc ff ff ff       	call   45a9 <rlc_mac_main+0x769>
	(*Q)->pkt_count--;
    45ad:	8b 87 14 02 00 00    	mov    0x214(%edi),%eax
    45b3:	66 83 68 08 01       	subw   $0x1,0x8(%eax)
	fsm_printf("[DeQueue]DeQueue successfully!\n");
    45b8:	c7 04 24 64 18 00 00 	movl   $0x1864,(%esp)
    45bf:	e8 fc ff ff ff       	call   45c0 <rlc_mac_main+0x780>
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
		{
			pkptr = DeQueue(&SV(CraQueue));
			if(pkptr == NULL)
    45c4:	85 db                	test   %ebx,%ebx
    45c6:	74 ae                	je     4576 <rlc_mac_main+0x736>
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    45c8:	e8 fc ff ff ff       	call   45c9 <rlc_mac_main+0x789>

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    45cd:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    45d3:	ba 40 00 00 00       	mov    $0x40,%edx
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    45d8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    45db:	89 c6                	mov    %eax,%esi

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    45dd:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    45e3:	e8 fc ff ff ff       	call   45e4 <rlc_mac_main+0x7a4>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    45e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    45eb:	80 38 00             	cmpb   $0x0,(%eax)
    45ee:	0f 85 85 1a 00 00    	jne    6079 <rlc_mac_main+0x2239>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    45f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    45f8:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    45fe:	89 14 24             	mov    %edx,(%esp)
    4601:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    4604:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4607:	e8 fc ff ff ff       	call   4608 <rlc_mac_main+0x7c8>
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
    460c:	8b 86 18 02 00 00    	mov    0x218(%esi),%eax
    4612:	c7 04 24 84 18 00 00 	movl   $0x1884,(%esp)
    4619:	89 44 24 04          	mov    %eax,0x4(%esp)
    461d:	e8 fc ff ff ff       	call   461e <rlc_mac_main+0x7de>
		switch(SV(ins_mode))
    4622:	8b 86 18 02 00 00    	mov    0x218(%esi),%eax
    4628:	83 f8 02             	cmp    $0x2,%eax
    462b:	0f 85 87 fe ff ff    	jne    44b8 <rlc_mac_main+0x678>
			
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    4631:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4634:	85 d2                	test   %edx,%edx
    4636:	0f 84 bc 1a 00 00    	je     60f8 <rlc_mac_main+0x22b8>
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    463c:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    4640:	3c 0b                	cmp    $0xb,%al
    4642:	74 08                	je     464c <rlc_mac_main+0x80c>
    4644:	3c 09                	cmp    $0x9,%al
    4646:	0f 85 af 0a 00 00    	jne    50fb <rlc_mac_main+0x12bb>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    464c:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    4650:	c7 04 24 04 1a 00 00 	movl   $0x1a04,(%esp)
    4657:	89 44 24 04          	mov    %eax,0x4(%esp)
    465b:	e8 fc ff ff ff       	call   465c <rlc_mac_main+0x81c>
    4660:	e9 92 fe ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
    4665:	8d 76 00             	lea    0x0(%esi),%esi
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
    4668:	c7 05 30 00 00 00 38 	movl   $0x338,0x30
    466f:	03 00 00 
}

static void init_enter()
{
	FIN(init_enter());
	ue_mac_sv_init();
    4672:	e8 a9 ee ff ff       	call   3520 <ue_mac_sv_init>
	rlc_init_enter();
    4677:	e8 a4 e0 ff ff       	call   2720 <rlc_init_enter>
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
    467c:	e9 8f f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4681:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
			//add RLC_INTI state, transmit to IDLE, 20150803
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
    4688:	c7 05 30 00 00 00 46 	movl   $0x346,0x30
    468f:	03 00 00 
    4692:	e8 89 ee ff ff       	call   3520 <ue_mac_sv_init>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
    4697:	e9 74 f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    469c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
    46a0:	85 db                	test   %ebx,%ebx
    46a2:	0f 84 9b fd ff ff    	je     4443 <rlc_mac_main+0x603>
			FSM_TRANSIT_SWITCH
    46a8:	83 ff 05             	cmp    $0x5,%edi
    46ab:	90                   	nop
    46ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    46b0:	0f 87 8d fd ff ff    	ja     4443 <rlc_mac_main+0x603>
    46b6:	ff 24 bd 68 03 00 00 	jmp    *0x368(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")
    46bd:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    46c4:	04 00 00 
    46c7:	e8 a4 f2 ff ff       	call   3970 <ue_mac_reset>
    46cc:	e9 3f f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
    46d1:	c7 05 30 00 00 00 11 	movl   $0x411,0x30
    46d8:	04 00 00 
    46db:	e8 30 ea ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
    46e0:	e9 83 fb ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
    46e5:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    46ec:	04 00 00 
    46ef:	e8 0c ed ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    46f4:	e9 17 f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    46f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
    4700:	85 db                	test   %ebx,%ebx
    4702:	0f 84 13 f8 ff ff    	je     3f1b <rlc_mac_main+0xdb>
			FSM_TRANSIT_SWITCH
    4708:	83 ff 05             	cmp    $0x5,%edi
    470b:	90                   	nop
    470c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4710:	0f 87 05 f8 ff ff    	ja     3f1b <rlc_mac_main+0xdb>
    4716:	ff 24 bd 80 03 00 00 	jmp    *0x380(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
    471d:	c7 05 30 00 00 00 79 	movl   $0x379,0x30
    4724:	03 00 00 
    4727:	e8 44 f2 ff ff       	call   3970 <ue_mac_reset>
    472c:	e9 df f8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4731:	c7 05 30 00 00 00 ea 	movl   $0x1ea,0x30
    4738:	01 00 00 
*******************************
*/
static void doStartNonContentionBasedRandomAccessProcedure() //modified by HQ  20140413
{
	FIN(doStartNonContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    473b:	e8 fc ff ff ff       	call   473c <rlc_mac_main+0x8fc>
    4740:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated ));
    4742:	b8 02 00 00 00       	mov    $0x2,%eax
    4747:	e8 fc ff ff ff       	call   4748 <rlc_mac_main+0x908>
    474c:	89 c7                	mov    %eax,%edi
	int mg3_buffer;
	print_tran_info("[UEMAC][noncontention_ra]startNCRA IDLE -> NCRA");//testing code
    474e:	b8 80 0e 00 00       	mov    $0xe80,%eax
    4753:	e8 fc ff ff ff       	call   4754 <rlc_mac_main+0x914>
	if(SV(PREAMBLE_TRANSMISSION_COUNTER ) == 0)   //
    4758:	8b 43 14             	mov    0x14(%ebx),%eax
    475b:	85 c0                	test   %eax,%eax
    475d:	75 10                	jne    476f <rlc_mac_main+0x92f>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER ) = 1; //PREAMBLE_TRANSMISSION_COUNTER1 
    475f:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    4766:	b0 01                	mov    $0x1,%al
    4768:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer = 0;   //MSG3//
	}
	fsm_printf("[UEMAC][noncontention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    476f:	89 44 24 04          	mov    %eax,0x4(%esp)
    4773:	c7 04 24 b0 0e 00 00 	movl   $0xeb0,(%esp)
    477a:	e8 fc ff ff ff       	call   477b <rlc_mac_main+0x93b>
	//
	randomaccess_info->ra_PreambleIndex=SV(RA_info.ra_PreambleIndex);
    477f:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    4783:	88 07                	mov    %al,(%edi)
	//fsm_printf("[HEXI]PREAMBLE INDEX IN MACFSM:%d\n",SV(RA_info.ra_PreambleIndex));
	
	randomaccess_info->ra_PRACHMaskIndex= SV(RA_info.ra_PRACHMaskIndex);
    4785:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
    4789:	88 47 01             	mov    %al,0x1(%edi)
	SendRaPreamble(randomaccess_info);//
    478c:	89 f8                	mov    %edi,%eax
    478e:	e8 0d e3 ff ff       	call   2aa0 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    4793:	e8 f8 de ff ff       	call   2690 <StartWaitingForRaResponse>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4798:	e9 e3 fb ff ff       	jmp    4380 <rlc_mac_main+0x540>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
    479d:	c7 05 30 00 00 00 de 	movl   $0x1de,0x30
    47a4:	01 00 00 
    47a7:	e8 64 e9 ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
    47ac:	e9 b7 fa ff ff       	jmp    4268 <rlc_mac_main+0x428>
    47b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
    47b8:	85 db                	test   %ebx,%ebx
    47ba:	0f 84 0b fa ff ff    	je     41cb <rlc_mac_main+0x38b>
			FSM_TRANSIT_SWITCH
    47c0:	83 ff 05             	cmp    $0x5,%edi
    47c3:	0f 87 02 fa ff ff    	ja     41cb <rlc_mac_main+0x38b>
    47c9:	ff 24 bd 98 03 00 00 	jmp    *0x398(,%edi,4)
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    47d0:	c7 05 30 00 00 00 03 	movl   $0x203,0x30
    47d7:	02 00 00 
*/
static void cra_success()
{
	RNTI_indication *data_ptr;
	FIN(cra_success());
	SV_PTR_GET(rlc_mac_sv);
    47da:	e8 fc ff ff ff       	call   47db <rlc_mac_main+0x99b>
    47df:	89 c7                	mov    %eax,%edi
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    47e1:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    47e5:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    47e9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	cleanharqBuff();//HARQmsg3
	SV(ra_allocation_res)=0;
    47f0:	c7 80 f8 01 00 00 00 	movl   $0x0,0x1f8(%eax)
    47f7:	00 00 00 
	if(SV(msg3_buf_ptr) != NULL)
    47fa:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
    4800:	85 c0                	test   %eax,%eax
    4802:	74 0f                	je     4813 <rlc_mac_main+0x9d3>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    4804:	e8 fc ff ff ff       	call   4805 <rlc_mac_main+0x9c5>
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    4809:	c7 87 e4 01 00 00 00 	movl   $0x0,0x1e4(%edi)
    4810:	00 00 00 
	}
	if(SV(C_RNTI) == 0)
    4813:	66 83 3f 00          	cmpw   $0x0,(%edi)
    4817:	0f 85 92 08 00 00    	jne    50af <rlc_mac_main+0x126f>
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    481d:	0f b7 47 02          	movzwl 0x2(%edi),%eax
	SV(T_C_RNTI) = 0;//T_C_RNTI
    4821:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
    4827:	66 85 c0             	test   %ax,%ax
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    482a:	66 89 07             	mov    %ax,(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
    482d:	0f 85 82 08 00 00    	jne    50b5 <rlc_mac_main+0x1275>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
		fsm_mem_free(data_ptr);//LHL20141018
	}
	if(SV(CRTimer.flag)==true) //CR
    4833:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    483a:	74 1b                	je     4857 <rlc_mac_main+0xa17>
	{
		SV(CRTimer.timer_sign)= NULL;
    483c:	c7 87 70 01 00 00 00 	movl   $0x0,0x170(%edi)
    4843:	00 00 00 
		SV(CRTimer.flag)= false;
    4846:	c6 87 74 01 00 00 00 	movb   $0x0,0x174(%edi)
		SV(CRTimer.time_value)=0;
    484d:	c7 87 6c 01 00 00 00 	movl   $0x0,0x16c(%edi)
    4854:	00 00 00 
	}
	SV(sendmsg3)=0;//MSG30
    4857:	c7 87 ec 01 00 00 00 	movl   $0x0,0x1ec(%edi)
    485e:	00 00 00 
	SV(ratype.ra_type)=0;//0 
    4861:	c7 87 e8 01 00 00 00 	movl   $0x0,0x1e8(%edi)
    4868:	00 00 00 
	SV(pdcch_rnti)=0;
    486b:	c7 87 f0 01 00 00 00 	movl   $0x0,0x1f0(%edi)
    4872:	00 00 00 
	fsm_printf("[UEMAC][cra_success]:contention based random access success \n");//testing code 
    4875:	c7 04 24 54 14 00 00 	movl   $0x1454,(%esp)
    487c:	e8 fc ff ff ff       	call   487d <rlc_mac_main+0xa3d>
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4881:	e9 32 f8 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4886:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    488d:	03 00 00 
*******************************
*/
static void ContentionFailed() 
{
	FIN(ContentionFailed());
	SV_PTR_GET(rlc_mac_sv);
    4890:	e8 fc ff ff ff       	call   4891 <rlc_mac_main+0xa51>
    4895:	89 c3                	mov    %eax,%ebx
	int result=1;//TEST
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4897:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	u32 backoff_time=0,backoff_param=0;//ms backoff_index
    489d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
    48a4:	c7 04 24 f8 13 00 00 	movl   $0x13f8,(%esp)
    48ab:	e8 fc ff ff ff       	call   48ac <rlc_mac_main+0xa6c>
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
    48b0:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
    48b7:	0f 85 fb 09 00 00    	jne    52b8 <rlc_mac_main+0x1478>
		SV(CRTimer.timer_sign)= NULL;
		SV(CRTimer.flag)= false;
	}
	//if(SV(TATimer.time_value)== SV(TA_fromRAR) && SV(TATimer.flag)==true) //TATimer MAC5.1.6
	
	if(SV(TATimer.flag)==true) 
    48bd:	80 bb 68 01 00 00 00 	cmpb   $0x0,0x168(%ebx)
    48c4:	74 2a                	je     48f0 <rlc_mac_main+0xab0>
	{//HQ 20140428 
		//fsm_printf("[UEMAC][con_failed]CR fail,stop TAtimer\n");//testing code 
		if(SV(TATimer.timer_sign) != NULL)
    48c6:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
    48cc:	85 c0                	test   %eax,%eax
    48ce:	74 05                	je     48d5 <rlc_mac_main+0xa95>
		{
			result=fsm_schedule_cancel (SV(TATimer.timer_sign));
    48d0:	e8 fc ff ff ff       	call   48d1 <rlc_mac_main+0xa91>
		}
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
    48d5:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    48dc:	00 00 00 
		SV(TATimer.flag)=false;
    48df:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.time_value)=0;
    48e6:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    48ed:	00 00 00 
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    48f0:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    48f3:	83 c7 01             	add    $0x1,%edi
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
    48f6:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    48fc:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    48ff:	39 f8                	cmp    %edi,%eax
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4901:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4904:	0f 84 9d 0e 00 00    	je     57a7 <rlc_mac_main+0x1967>
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    490a:	8b 43 1c             	mov    0x1c(%ebx),%eax
	}
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
    490d:	c7 83 f8 01 00 00 01 	movl   $0x1,0x1f8(%ebx)
    4914:	00 00 00 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4917:	8b 55 e8             	mov    -0x18(%ebp),%edx
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    491a:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4921:	00 
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4922:	85 db                	test   %ebx,%ebx
    4924:	0f 85 26 0b 00 00    	jne    5450 <rlc_mac_main+0x1610>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			//fsm_printf("[UEMAC][con_failed]:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    492a:	6b c2 64             	imul   $0x64,%edx,%eax
    492d:	ba 02 00 00 00       	mov    $0x2,%edx
    4932:	e8 fc ff ff ff       	call   4933 <rlc_mac_main+0xaf3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4937:	e9 d4 f6 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    493c:	c7 05 30 00 00 00 c2 	movl   $0x3c2,0x30
    4943:	03 00 00 
*/
static void waitsending_msg3() //defined by HQ 20140430 
{
	RNTI_indication *data_ptr;
	FIN(waitsending_msg3());   
	SV_PTR_GET(rlc_mac_sv);
    4946:	e8 fc ff ff ff       	call   4947 <rlc_mac_main+0xb07>
    494b:	89 c7                	mov    %eax,%edi
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    494d:	e8 fc ff ff ff       	call   494e <rlc_mac_main+0xb0e>
	if(SV(TATimer.flag)==false)
    4952:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4959:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==false)
    495b:	0f 84 98 08 00 00    	je     51f9 <rlc_mac_main+0x13b9>
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		//T_C_RNTI
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
    4961:	66 83 7f 02 00       	cmpw   $0x0,0x2(%edi)
    4966:	0f 85 50 08 00 00    	jne    51bc <rlc_mac_main+0x137c>
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		fsm_mem_free(data_ptr);
	}
	//HQ HQ modified end 20140717
	fsm_printf("[UEMAC][waitsend_msg3]MAC SV(PREAMBLE_TRANSMISSION_COUNTER):%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER));
    496c:	8b 47 14             	mov    0x14(%edi),%eax
    496f:	c7 04 24 ec 12 00 00 	movl   $0x12ec,(%esp)
    4976:	89 44 24 04          	mov    %eax,0x4(%esp)
    497a:	e8 fc ff ff ff       	call   497b <rlc_mac_main+0xb3b>
	{  	
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte,    	
  		fsm_printf("MAC SEND MSG3:this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
	}*/ //modified by lhl 20140725

	if(SV(ra_allocation_res)==0)
    497f:	8b 87 f8 01 00 00    	mov    0x1f8(%edi),%eax
    4985:	85 c0                	test   %eax,%eax
    4987:	0f 85 9f 08 00 00    	jne    522c <rlc_mac_main+0x13ec>
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
    498d:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4994:	0f 84 f1 07 00 00    	je     518b <rlc_mac_main+0x134b>
    499a:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    499e:	0f 84 e7 07 00 00    	je     518b <rlc_mac_main+0x134b>
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49a4:	8b 47 2c             	mov    0x2c(%edi),%eax
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    49a7:	66 83 3f 00          	cmpw   $0x0,(%edi)
	if(SV(ra_allocation_res)==0)
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
    49ab:	c7 87 f8 01 00 00 01 	movl   $0x1,0x1f8(%edi)
    49b2:	00 00 00 
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49b5:	89 c2                	mov    %eax,%edx
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    49b7:	0f 84 45 0c 00 00    	je     5602 <rlc_mac_main+0x17c2>
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49bd:	c1 ea 03             	shr    $0x3,%edx
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    49c0:	83 e8 18             	sub    $0x18,%eax
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49c3:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    49c9:	e8 fc ff ff ff       	call   49ca <rlc_mac_main+0xb8a>
    49ce:	e8 fc ff ff ff       	call   49cf <rlc_mac_main+0xb8f>
				SV(UL_resource_info.resource_flag)=false;
    49d3:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    49d7:	e9 8c f8 ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    49dc:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    49e3:	03 00 00 
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    49e6:	e8 fc ff ff ff       	call   49e7 <rlc_mac_main+0xba7>
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    49eb:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    49f1:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    49f3:	b8 34 12 00 00       	mov    $0x1234,%eax
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
    49f8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    49fe:	e8 fc ff ff ff       	call   49ff <rlc_mac_main+0xbbf>
	if(SV(WaitforRAresponseTimer.flag)==true)//
    4a03:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4a0a:	74 11                	je     4a1d <rlc_mac_main+0xbdd>
	{
		SV(WaitforRAresponseTimer.flag)= false;
    4a0c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4a13:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4a1a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a1d:	8b 43 14             	mov    0x14(%ebx),%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a20:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a23:	83 c0 01             	add    $0x1,%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a26:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a28:	89 43 14             	mov    %eax,0x14(%ebx)
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a2b:	0f 84 bb 0d 00 00    	je     57ec <rlc_mac_main+0x19ac>
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
		//fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
	//modified by HQ
	else
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
    4a31:	8b 43 1c             	mov    0x1c(%ebx),%eax
    4a34:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4a3b:	00 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4a3c:	66 85 db             	test   %bx,%bx
    4a3f:	0f 85 b5 09 00 00    	jne    53fa <rlc_mac_main+0x15ba>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4a45:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    4a49:	ba 02 00 00 00       	mov    $0x2,%edx
    4a4e:	6b c0 64             	imul   $0x64,%eax,%eax
    4a51:	e8 fc ff ff ff       	call   4a52 <rlc_mac_main+0xc12>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4a56:	e9 b5 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
    4a5b:	c7 05 30 00 00 00 ab 	movl   $0x3ab,0x30
    4a62:	03 00 00 
    4a65:	e8 96 e9 ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    4a6a:	e9 a1 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
    4a6f:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4a76:	03 00 00 
    4a79:	e8 f2 ee ff ff       	call   3970 <ue_mac_reset>
    4a7e:	e9 8d f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4a83:	90                   	nop
    4a84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
    4a88:	85 db                	test   %ebx,%ebx
    4a8a:	0f 84 93 f8 ff ff    	je     4323 <rlc_mac_main+0x4e3>
			FSM_TRANSIT_SWITCH
    4a90:	83 ff 01             	cmp    $0x1,%edi
    4a93:	0f 84 b9 01 00 00    	je     4c52 <rlc_mac_main+0xe12>
    4a99:	0f 8e 95 09 00 00    	jle    5434 <rlc_mac_main+0x15f4>
    4a9f:	83 ff 02             	cmp    $0x2,%edi
    4aa2:	0f 84 3d 01 00 00    	je     4be5 <rlc_mac_main+0xda5>
    4aa8:	83 ff 03             	cmp    $0x3,%edi
    4aab:	90                   	nop
    4aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4ab0:	0f 85 6d f8 ff ff    	jne    4323 <rlc_mac_main+0x4e3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
    4ab6:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4abd:	03 00 00 
    4ac0:	e8 ab ee ff ff       	call   3970 <ue_mac_reset>
    4ac5:	e9 46 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4ad0:	e8 fc ff ff ff       	call   4ad1 <rlc_mac_main+0xc91>
    4ad5:	83 f8 04             	cmp    $0x4,%eax
    4ad8:	0f 85 00 f8 ff ff    	jne    42de <rlc_mac_main+0x49e>
    4ade:	83 c3 01             	add    $0x1,%ebx
    4ae1:	bf 02 00 00 00       	mov    $0x2,%edi
    4ae6:	e9 03 f8 ff ff       	jmp    42ee <rlc_mac_main+0x4ae>
    4aeb:	90                   	nop
    4aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4af0:	e8 fc ff ff ff       	call   4af1 <rlc_mac_main+0xcb1>
    4af5:	83 f8 06             	cmp    $0x6,%eax
    4af8:	0f 85 88 f6 ff ff    	jne    4186 <rlc_mac_main+0x346>
    4afe:	83 c3 01             	add    $0x1,%ebx
    4b01:	bf 04 00 00 00       	mov    $0x4,%edi
    4b06:	e9 8b f6 ff ff       	jmp    4196 <rlc_mac_main+0x356>
    4b0b:	90                   	nop
    4b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4b10:	e8 fc ff ff ff       	call   4b11 <rlc_mac_main+0xcd1>
    4b15:	83 f8 05             	cmp    $0x5,%eax
    4b18:	0f 85 38 f6 ff ff    	jne    4156 <rlc_mac_main+0x316>
    4b1e:	83 c3 01             	add    $0x1,%ebx
    4b21:	bf 03 00 00 00       	mov    $0x3,%edi
    4b26:	e9 4b f6 ff ff       	jmp    4176 <rlc_mac_main+0x336>
    4b2b:	90                   	nop
    4b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4b30:	e8 fc ff ff ff       	call   4b31 <rlc_mac_main+0xcf1>
    4b35:	83 f8 04             	cmp    $0x4,%eax
    4b38:	0f 85 f8 f5 ff ff    	jne    4136 <rlc_mac_main+0x2f6>
    4b3e:	83 c3 01             	add    $0x1,%ebx
    4b41:	bf 02 00 00 00       	mov    $0x2,%edi
    4b46:	e9 fb f5 ff ff       	jmp    4146 <rlc_mac_main+0x306>
    4b4b:	90                   	nop
    4b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b50:	e8 fc ff ff ff       	call   4b51 <rlc_mac_main+0xd11>
    4b55:	83 f8 03             	cmp    $0x3,%eax
    4b58:	0f 85 a8 f5 ff ff    	jne    4106 <rlc_mac_main+0x2c6>
    4b5e:	83 c3 01             	add    $0x1,%ebx
    4b61:	bf 01 00 00 00       	mov    $0x1,%edi
    4b66:	e9 bb f5 ff ff       	jmp    4126 <rlc_mac_main+0x2e6>
    4b6b:	90                   	nop
    4b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b70:	e8 fc ff ff ff       	call   4b71 <rlc_mac_main+0xd31>
    4b75:	83 f8 03             	cmp    $0x3,%eax
    4b78:	0f 85 2f f7 ff ff    	jne    42ad <rlc_mac_main+0x46d>
    4b7e:	83 c3 01             	add    $0x1,%ebx
    4b81:	bf 01 00 00 00       	mov    $0x1,%edi
    4b86:	e9 43 f7 ff ff       	jmp    42ce <rlc_mac_main+0x48e>
    4b8b:	90                   	nop
    4b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b90:	e8 fc ff ff ff       	call   4b91 <rlc_mac_main+0xd51>
    4b95:	83 f8 18             	cmp    $0x18,%eax
    4b98:	0f 85 78 f5 ff ff    	jne    4116 <rlc_mac_main+0x2d6>
    4b9e:	66 90                	xchg   %ax,%ax
    4ba0:	eb bc                	jmp    4b5e <rlc_mac_main+0xd1e>
    4ba2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4ba8:	90                   	nop
    4ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4bb0:	e8 fc ff ff ff       	call   4bb1 <rlc_mac_main+0xd71>
    4bb5:	83 f8 18             	cmp    $0x18,%eax
    4bb8:	0f 85 00 f7 ff ff    	jne    42be <rlc_mac_main+0x47e>
    4bbe:	66 90                	xchg   %ax,%ax
    4bc0:	eb bc                	jmp    4b7e <rlc_mac_main+0xd3e>
    4bc2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4bc8:	90                   	nop
    4bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4bd0:	e8 fc ff ff ff       	call   4bd1 <rlc_mac_main+0xd91>
    4bd5:	83 f8 0f             	cmp    $0xf,%eax
    4bd8:	0f 85 88 f5 ff ff    	jne    4166 <rlc_mac_main+0x326>
    4bde:	66 90                	xchg   %ax,%ax
    4be0:	e9 39 ff ff ff       	jmp    4b1e <rlc_mac_main+0xcde>
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4be5:	c7 05 30 00 00 00 f7 	movl   $0x1f7,0x30
    4bec:	01 00 00 
*******************************
*/
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
    4bef:	e8 fc ff ff ff       	call   4bf0 <rlc_mac_main+0xdb0>
    4bf4:	89 c7                	mov    %eax,%edi
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4bf6:	e8 fc ff ff ff       	call   4bf7 <rlc_mac_main+0xdb7>
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4bfb:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4c02:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4c04:	74 0f                	je     4c15 <rlc_mac_main+0xdd5>
    4c06:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    4c0c:	85 c0                	test   %eax,%eax
    4c0e:	74 05                	je     4c15 <rlc_mac_main+0xdd5>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    4c10:	e8 fc ff ff ff       	call   4c11 <rlc_mac_main+0xdd1>
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4c15:	8b 43 24             	mov    0x24(%ebx),%eax
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c18:	ba 0b 00 00 00       	mov    $0xb,%edx
	SV_PTR_GET(rlc_mac_sv);	
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4c1d:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c23:	6b c0 64             	imul   $0x64,%eax,%eax
    4c26:	e8 fc ff ff ff       	call   4c27 <rlc_mac_main+0xde7>
	SV(TATimer.flag)=true;
    4c2b:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c32:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
	RARTA_handleA();//RAR  TA 
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4c38:	c6 47 04 00          	movb   $0x0,0x4(%edi)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4c3c:	c6 47 05 00          	movb   $0x0,0x5(%edi)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4c40:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI 
    4c47:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4c4d:	e9 66 f4 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4c52:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4c59:	03 00 00 
*******************************
*/
static void NC_RaResponseFailed() 
{
	FIN(NC_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c5c:	e8 fc ff ff ff       	call   4c5d <rlc_mac_main+0xe1d>
    4c61:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4c63:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	print_tran_info("[UEMAC][nc_ra_failed]NCRA -> IDLE");//testing code
    4c69:	b8 28 17 00 00       	mov    $0x1728,%eax
    4c6e:	e8 fc ff ff ff       	call   4c6f <rlc_mac_main+0xe2f>
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
    4c73:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4c7a:	74 11                	je     4c8d <rlc_mac_main+0xe4d>
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
    4c7c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4c83:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4c8a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c8d:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c90:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c93:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c96:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c98:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c9b:	0f 84 d1 04 00 00    	je     5172 <rlc_mac_main+0x1332>
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
	}
	else
	{
		fsm_printf("[UEMAC][nc_ra_failed]MAC:start a new NCRA \n");//testing code 
    4ca1:	c7 04 24 8c 17 00 00 	movl   $0x178c,(%esp)
    4ca8:	e8 fc ff ff ff       	call   4ca9 <rlc_mac_main+0xe69>
		fsm_schedule_self(100,Start_NonContentionBase_RandomAcc);//trigger a new random access procedure
    4cad:	ba 01 00 00 00       	mov    $0x1,%edx
    4cb2:	b8 64 00 00 00       	mov    $0x64,%eax
    4cb7:	e8 fc ff ff ff       	call   4cb8 <rlc_mac_main+0xe78>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4cbc:	e9 4f f3 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4cc1:	e8 fc ff ff ff       	call   4cc2 <rlc_mac_main+0xe82>
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
    4cc6:	83 f8 0b             	cmp    $0xb,%eax
    4cc9:	0f 94 c3             	sete   %bl
    4ccc:	0f b6 fb             	movzbl %bl,%edi
    4ccf:	0f b6 db             	movzbl %bl,%ebx
    4cd2:	83 ef 01             	sub    $0x1,%edi
    4cd5:	e9 1d f4 ff ff       	jmp    40f7 <rlc_mac_main+0x2b7>
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4cda:	e8 fc ff ff ff       	call   4cdb <rlc_mac_main+0xe9b>
    4cdf:	83 f8 54             	cmp    $0x54,%eax
    4ce2:	0f 85 36 f7 ff ff    	jne    441e <rlc_mac_main+0x5de>
    4ce8:	83 c3 01             	add    $0x1,%ebx
    4ceb:	bf 05 00 00 00       	mov    $0x5,%edi
    4cf0:	e9 29 f7 ff ff       	jmp    441e <rlc_mac_main+0x5de>
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)
    4cf5:	e8 fc ff ff ff       	call   4cf6 <rlc_mac_main+0xeb6>
    4cfa:	83 f8 02             	cmp    $0x2,%eax
    4cfd:	0f 85 eb f6 ff ff    	jne    43ee <rlc_mac_main+0x5ae>
    4d03:	e8 fc ff ff ff       	call   4d04 <rlc_mac_main+0xec4>
    4d08:	83 f8 03             	cmp    $0x3,%eax
    4d0b:	0f 85 dd f6 ff ff    	jne    43ee <rlc_mac_main+0x5ae>
    4d11:	83 c3 01             	add    $0x1,%ebx
    4d14:	bf 02 00 00 00       	mov    $0x2,%edi
    4d19:	e9 d0 f6 ff ff       	jmp    43ee <rlc_mac_main+0x5ae>
    4d1e:	66 90                	xchg   %ax,%ax
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
    4d20:	e8 fc ff ff ff       	call   4d21 <rlc_mac_main+0xee1>
    4d25:	83 f8 07             	cmp    $0x7,%eax
    4d28:	0f 85 af f6 ff ff    	jne    43dd <rlc_mac_main+0x59d>
    4d2e:	83 c3 01             	add    $0x1,%ebx
    4d31:	bf 01 00 00 00       	mov    $0x1,%edi
    4d36:	e9 a2 f6 ff ff       	jmp    43dd <rlc_mac_main+0x59d>
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4d3b:	e8 fc ff ff ff       	call   4d3c <rlc_mac_main+0xefc>
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
    4d40:	83 f8 0b             	cmp    $0xb,%eax
    4d43:	0f 94 c3             	sete   %bl
    4d46:	0f b6 fb             	movzbl %bl,%edi
    4d49:	0f b6 db             	movzbl %bl,%ebx
    4d4c:	83 ef 01             	sub    $0x1,%edi
    4d4f:	e9 7b f6 ff ff       	jmp    43cf <rlc_mac_main+0x58f>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4d54:	e8 fc ff ff ff       	call   4d55 <rlc_mac_main+0xf15>
    4d59:	83 f8 54             	cmp    $0x54,%eax
    4d5c:	0f 85 94 f1 ff ff    	jne    3ef6 <rlc_mac_main+0xb6>
    4d62:	83 c3 01             	add    $0x1,%ebx
    4d65:	bf 05 00 00 00       	mov    $0x5,%edi
    4d6a:	e9 87 f1 ff ff       	jmp    3ef6 <rlc_mac_main+0xb6>
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4d6f:	e8 fc ff ff ff       	call   4d70 <rlc_mac_main+0xf30>
    4d74:	83 f8 52             	cmp    $0x52,%eax
    4d77:	0f 85 69 f1 ff ff    	jne    3ee6 <rlc_mac_main+0xa6>
    4d7d:	83 c3 01             	add    $0x1,%ebx
    4d80:	bf 04 00 00 00       	mov    $0x4,%edi
    4d85:	e9 5c f1 ff ff       	jmp    3ee6 <rlc_mac_main+0xa6>
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4d8a:	e8 fc ff ff ff       	call   4d8b <rlc_mac_main+0xf4b>
    4d8f:	83 f8 02             	cmp    $0x2,%eax
    4d92:	0f 85 66 f5 ff ff    	jne    42fe <rlc_mac_main+0x4be>
    4d98:	e8 fc ff ff ff       	call   4d99 <rlc_mac_main+0xf59>
    4d9d:	83 f8 03             	cmp    $0x3,%eax
    4da0:	0f 85 58 f5 ff ff    	jne    42fe <rlc_mac_main+0x4be>
    4da6:	83 c3 01             	add    $0x1,%ebx
    4da9:	bf 03 00 00 00       	mov    $0x3,%edi
    4dae:	e9 4b f5 ff ff       	jmp    42fe <rlc_mac_main+0x4be>
    4db3:	90                   	nop
    4db4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4db8:	e8 fc ff ff ff       	call   4db9 <rlc_mac_main+0xf79>
    4dbd:	83 f8 02             	cmp    $0x2,%eax
    4dc0:	0f 85 e0 f3 ff ff    	jne    41a6 <rlc_mac_main+0x366>
    4dc6:	e8 fc ff ff ff       	call   4dc7 <rlc_mac_main+0xf87>
    4dcb:	83 f8 03             	cmp    $0x3,%eax
    4dce:	66 90                	xchg   %ax,%ax
    4dd0:	0f 85 d0 f3 ff ff    	jne    41a6 <rlc_mac_main+0x366>
    4dd6:	83 c3 01             	add    $0x1,%ebx
    4dd9:	bf 05 00 00 00       	mov    $0x5,%edi
    4dde:	e9 c3 f3 ff ff       	jmp    41a6 <rlc_mac_main+0x366>
    4de3:	90                   	nop
    4de4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
    4de8:	e8 fc ff ff ff       	call   4de9 <rlc_mac_main+0xfa9>
    4ded:	83 f8 53             	cmp    $0x53,%eax
    4df0:	0f 85 e0 f0 ff ff    	jne    3ed6 <rlc_mac_main+0x96>
    4df6:	83 c3 01             	add    $0x1,%ebx
    4df9:	bf 03 00 00 00       	mov    $0x3,%edi
    4dfe:	e9 d3 f0 ff ff       	jmp    3ed6 <rlc_mac_main+0x96>
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
    4e03:	e8 fc ff ff ff       	call   4e04 <rlc_mac_main+0xfc4>
    4e08:	83 f8 02             	cmp    $0x2,%eax
    4e0b:	0f 85 b5 f0 ff ff    	jne    3ec6 <rlc_mac_main+0x86>
    4e11:	e8 fc ff ff ff       	call   4e12 <rlc_mac_main+0xfd2>
    4e16:	83 f8 03             	cmp    $0x3,%eax
    4e19:	0f 85 a7 f0 ff ff    	jne    3ec6 <rlc_mac_main+0x86>
    4e1f:	83 c3 01             	add    $0x1,%ebx
    4e22:	bf 02 00 00 00       	mov    $0x2,%edi
    4e27:	e9 9a f0 ff ff       	jmp    3ec6 <rlc_mac_main+0x86>
    4e2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    4e30:	e8 fc ff ff ff       	call   4e31 <rlc_mac_main+0xff1>
    4e35:	83 f8 01             	cmp    $0x1,%eax
    4e38:	0f 85 78 f0 ff ff    	jne    3eb6 <rlc_mac_main+0x76>
    4e3e:	83 c3 01             	add    $0x1,%ebx
    4e41:	bf 01 00 00 00       	mov    $0x1,%edi
    4e46:	e9 6b f0 ff ff       	jmp    3eb6 <rlc_mac_main+0x76>
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    4e4b:	e8 fc ff ff ff       	call   4e4c <rlc_mac_main+0x100c>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
    4e50:	83 f8 02             	cmp    $0x2,%eax
    4e53:	0f 94 c3             	sete   %bl
    4e56:	0f b6 fb             	movzbl %bl,%edi
    4e59:	0f b6 db             	movzbl %bl,%ebx
    4e5c:	83 ef 01             	sub    $0x1,%edi
    4e5f:	e9 43 f0 ff ff       	jmp    3ea7 <rlc_mac_main+0x67>
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4e64:	e8 fc ff ff ff       	call   4e65 <rlc_mac_main+0x1025>
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
    4e69:	83 f8 0b             	cmp    $0xb,%eax
    4e6c:	0f 94 c3             	sete   %bl
    4e6f:	0f b6 fb             	movzbl %bl,%edi
    4e72:	0f b6 db             	movzbl %bl,%ebx
    4e75:	83 ef 01             	sub    $0x1,%edi
    4e78:	e9 22 f4 ff ff       	jmp    429f <rlc_mac_main+0x45f>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4e7d:	e8 fc ff ff ff       	call   4e7e <rlc_mac_main+0x103e>
    4e82:	83 f8 52             	cmp    $0x52,%eax
    4e85:	0f 85 83 f5 ff ff    	jne    440e <rlc_mac_main+0x5ce>
    4e8b:	83 c3 01             	add    $0x1,%ebx
    4e8e:	bf 04 00 00 00       	mov    $0x4,%edi
    4e93:	e9 76 f5 ff ff       	jmp    440e <rlc_mac_main+0x5ce>
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
    4e98:	e8 fc ff ff ff       	call   4e99 <rlc_mac_main+0x1059>
    4e9d:	83 f8 53             	cmp    $0x53,%eax
    4ea0:	0f 85 58 f5 ff ff    	jne    43fe <rlc_mac_main+0x5be>
    4ea6:	83 c3 01             	add    $0x1,%ebx
    4ea9:	bf 03 00 00 00       	mov    $0x3,%edi
    4eae:	e9 4b f5 ff ff       	jmp    43fe <rlc_mac_main+0x5be>
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4eb3:	e8 fc ff ff ff       	call   4eb4 <rlc_mac_main+0x1074>
    4eb8:	83 f8 02             	cmp    $0x2,%eax
    4ebb:	0f 85 d5 f2 ff ff    	jne    4196 <rlc_mac_main+0x356>
    4ec1:	e8 fc ff ff ff       	call   4ec2 <rlc_mac_main+0x1082>
    4ec6:	83 f8 43             	cmp    $0x43,%eax
    4ec9:	0f 85 c7 f2 ff ff    	jne    4196 <rlc_mac_main+0x356>
    4ecf:	90                   	nop
    4ed0:	e9 29 fc ff ff       	jmp    4afe <rlc_mac_main+0xcbe>
    4ed5:	8d 76 00             	lea    0x0(%esi),%esi
    4ed8:	90                   	nop
    4ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4ee0:	e8 fc ff ff ff       	call   4ee1 <rlc_mac_main+0x10a1>
    4ee5:	83 f8 02             	cmp    $0x2,%eax
    4ee8:	0f 85 58 f2 ff ff    	jne    4146 <rlc_mac_main+0x306>
    4eee:	66 90                	xchg   %ax,%ax
    4ef0:	e8 fc ff ff ff       	call   4ef1 <rlc_mac_main+0x10b1>
    4ef5:	83 f8 41             	cmp    $0x41,%eax
    4ef8:	0f 85 48 f2 ff ff    	jne    4146 <rlc_mac_main+0x306>
    4efe:	66 90                	xchg   %ax,%ax
    4f00:	e9 39 fc ff ff       	jmp    4b3e <rlc_mac_main+0xcfe>
    4f05:	8d 76 00             	lea    0x0(%esi),%esi
    4f08:	90                   	nop
    4f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4f10:	e8 fc ff ff ff       	call   4f11 <rlc_mac_main+0x10d1>
    4f15:	83 f8 02             	cmp    $0x2,%eax
    4f18:	0f 85 d0 f3 ff ff    	jne    42ee <rlc_mac_main+0x4ae>
    4f1e:	66 90                	xchg   %ax,%ax
    4f20:	e8 fc ff ff ff       	call   4f21 <rlc_mac_main+0x10e1>
    4f25:	83 f8 41             	cmp    $0x41,%eax
    4f28:	0f 85 c0 f3 ff ff    	jne    42ee <rlc_mac_main+0x4ae>
    4f2e:	66 90                	xchg   %ax,%ax
    4f30:	e9 a9 fb ff ff       	jmp    4ade <rlc_mac_main+0xc9e>
    4f35:	8d 76 00             	lea    0x0(%esi),%esi
			
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    4f38:	8b 75 ec             	mov    -0x14(%ebp),%esi
    4f3b:	85 f6                	test   %esi,%esi
    4f3d:	8d 76 00             	lea    0x0(%esi),%esi
    4f40:	0f 84 61 11 00 00    	je     60a7 <rlc_mac_main+0x2267>
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    4f46:	b8 0c 00 00 00       	mov    $0xc,%eax
    4f4b:	e8 fc ff ff ff       	call   4f4c <rlc_mac_main+0x110c>
			tmElm->pkt = skb;
    4f50:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4f52:	8b 56 10             	mov    0x10(%esi),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    4f55:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4f58:	89 4e 10             	mov    %ecx,0x10(%esi)
    4f5b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4f5e:	8d 4e 0c             	lea    0xc(%esi),%ecx
    4f61:	89 48 04             	mov    %ecx,0x4(%eax)
	new->next = next;
	new->prev = prev;
    4f64:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    4f67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f6a:	89 02                	mov    %eax,(%edx)
			tmTxIns->tmSduBufferNum++;
    4f6c:	83 46 18 01          	addl   $0x1,0x18(%esi)
			tmTxIns->tmSduBufferSize += skb->len;
    4f70:	8b 43 50             	mov    0x50(%ebx),%eax
    4f73:	01 46 14             	add    %eax,0x14(%esi)
    4f76:	e9 83 f5 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    4f7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f7e:	85 c0                	test   %eax,%eax
    4f80:	0f 84 56 11 00 00    	je     60dc <rlc_mac_main+0x229c>
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    4f86:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    4f89:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
    4f8d:	66 83 fa 0b          	cmp    $0xb,%dx
    4f91:	0f 84 2c 11 00 00    	je     60c3 <rlc_mac_main+0x2283>
    4f97:	66 83 fa 09          	cmp    $0x9,%dx
    4f9b:	0f 84 22 11 00 00    	je     60c3 <rlc_mac_main+0x2283>
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    4fa1:	b8 14 00 00 00       	mov    $0x14,%eax
    4fa6:	e8 fc ff ff ff       	call   4fa7 <rlc_mac_main+0x1167>
			
			amElm->pkt = skb;
    4fab:	89 18                	mov    %ebx,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    4fad:	8d 48 0c             	lea    0xc(%eax),%ecx
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
			
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    4fb0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    4fb7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    4fbe:	8b 55 e8             	mov    -0x18(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4fc1:	8b 72 48             	mov    0x48(%edx),%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4fc4:	89 4a 48             	mov    %ecx,0x48(%edx)
    4fc7:	83 c2 44             	add    $0x44,%edx
    4fca:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    4fcd:	89 70 10             	mov    %esi,0x10(%eax)
	prev->next = new;
    4fd0:	89 0e                	mov    %ecx,(%esi)
			fsm_printf("[RLC][skb_from_cra_to_con]AM_MODE list_add done!\n");
    4fd2:	c7 04 24 3c 19 00 00 	movl   $0x193c,(%esp)
    4fd9:	e8 fc ff ff ff       	call   4fda <rlc_mac_main+0x119a>
			fsm_printf("[RLC][skb_from_cra_to_con] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    4fde:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4fe1:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    4fe5:	89 54 24 0c          	mov    %edx,0xc(%esp)
    4fe9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    4fed:	c7 04 24 70 19 00 00 	movl   $0x1970,(%esp)
    4ff4:	89 44 24 08          	mov    %eax,0x8(%esp)
    4ff8:	8d 45 e8             	lea    -0x18(%ebp),%eax
    4ffb:	89 44 24 04          	mov    %eax,0x4(%esp)
    4fff:	e8 fc ff ff ff       	call   5000 <rlc_mac_main+0x11c0>
			amIns->amSduBufferSize += skb->len;
    5004:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5007:	8b 53 50             	mov    0x50(%ebx),%edx
    500a:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    500d:	83 40 50 01          	addl   $0x1,0x50(%eax)
    5011:	e9 e8 f4 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    5016:	e8 fc ff ff ff       	call   5017 <rlc_mac_main+0x11d7>
    501b:	83 f8 02             	cmp    $0x2,%eax
    501e:	0f 85 52 f1 ff ff    	jne    4176 <rlc_mac_main+0x336>
    5024:	e8 fc ff ff ff       	call   5025 <rlc_mac_main+0x11e5>
    5029:	83 f8 42             	cmp    $0x42,%eax
    502c:	0f 85 44 f1 ff ff    	jne    4176 <rlc_mac_main+0x336>
    5032:	e9 e7 fa ff ff       	jmp    4b1e <rlc_mac_main+0xcde>
    5037:	90                   	nop
    5038:	90                   	nop
    5039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    5040:	e8 fc ff ff ff       	call   5041 <rlc_mac_main+0x1201>
    5045:	83 f8 02             	cmp    $0x2,%eax
    5048:	0f 85 d8 f0 ff ff    	jne    4126 <rlc_mac_main+0x2e6>
    504e:	66 90                	xchg   %ax,%ax
    5050:	e8 fc ff ff ff       	call   5051 <rlc_mac_main+0x1211>
    5055:	83 f8 40             	cmp    $0x40,%eax
    5058:	0f 85 c8 f0 ff ff    	jne    4126 <rlc_mac_main+0x2e6>
    505e:	66 90                	xchg   %ax,%ax
    5060:	e9 f9 fa ff ff       	jmp    4b5e <rlc_mac_main+0xd1e>
    5065:	8d 76 00             	lea    0x0(%esi),%esi
    5068:	90                   	nop
    5069:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    5070:	e8 fc ff ff ff       	call   5071 <rlc_mac_main+0x1231>
    5075:	83 f8 02             	cmp    $0x2,%eax
    5078:	0f 85 50 f2 ff ff    	jne    42ce <rlc_mac_main+0x48e>
    507e:	66 90                	xchg   %ax,%ax
    5080:	e8 fc ff ff ff       	call   5081 <rlc_mac_main+0x1241>
    5085:	83 f8 40             	cmp    $0x40,%eax
    5088:	0f 85 40 f2 ff ff    	jne    42ce <rlc_mac_main+0x48e>
    508e:	66 90                	xchg   %ax,%ax
    5090:	e9 e9 fa ff ff       	jmp    4b7e <rlc_mac_main+0xd3e>
    5095:	8d 76 00             	lea    0x0(%esi),%esi
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
	if((*Q)->rear == p)
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
    5098:	89 4a 04             	mov    %ecx,0x4(%edx)
		(*Q)->front->next = NULL;
    509b:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    50a1:	8b 12                	mov    (%edx),%edx
    50a3:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    50aa:	e9 f9 f4 ff ff       	jmp    45a8 <rlc_mac_main+0x768>
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
    50af:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    50b5:	b8 08 00 00 00       	mov    $0x8,%eax
    50ba:	e8 fc ff ff ff       	call   50bb <rlc_mac_main+0x127b>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50bf:	ba 24 00 00 00       	mov    $0x24,%edx
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    50c4:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 1; 
    50c6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		data_ptr->rnti_value = SV(C_RNTI);
    50cc:	0f b7 07             	movzwl (%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50cf:	89 d9                	mov    %ebx,%ecx
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
    50d1:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50d4:	b8 03 00 00 00       	mov    $0x3,%eax
    50d9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    50e0:	e8 fc ff ff ff       	call   50e1 <rlc_mac_main+0x12a1>
		fsm_mem_free(data_ptr);//LHL20141018
    50e5:	89 d8                	mov    %ebx,%eax
    50e7:	e8 fc ff ff ff       	call   50e8 <rlc_mac_main+0x12a8>
    50ec:	e9 42 f7 ff ff       	jmp    4833 <rlc_mac_main+0x9f3>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    50f1:	e8 fc ff ff ff       	call   50f2 <rlc_mac_main+0x12b2>
    50f6:	e9 45 f4 ff ff       	jmp    4540 <rlc_mac_main+0x700>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    50fb:	b8 18 00 00 00       	mov    $0x18,%eax
    5100:	89 55 d8             	mov    %edx,-0x28(%ebp)
    5103:	e8 fc ff ff ff       	call   5104 <rlc_mac_main+0x12c4>
			umElm->pkt = skb;
    5108:	89 18                	mov    %ebx,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    510a:	8d 48 10             	lea    0x10(%eax),%ecx
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    510d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    5114:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    511b:	8b 55 d8             	mov    -0x28(%ebp),%edx
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    511e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5121:	8b 4a 1c             	mov    0x1c(%edx),%ecx
    5124:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5127:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    512a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    512d:	8d 4a 18             	lea    0x18(%edx),%ecx
    5130:	89 48 10             	mov    %ecx,0x10(%eax)
	new->next = next;
	new->prev = prev;
    5133:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    5136:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    5139:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    513c:	89 01                	mov    %eax,(%ecx)
			fsm_printf("[RLC][skb_from_cra_to_con]UM_MODE list_add done!\n");
    513e:	89 55 d8             	mov    %edx,-0x28(%ebp)
    5141:	c7 04 24 4c 1a 00 00 	movl   $0x1a4c,(%esp)
    5148:	e8 fc ff ff ff       	call   5149 <rlc_mac_main+0x1309>
			
			umTxIns->umSduBufferNum++;
    514d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5150:	8b 42 24             	mov    0x24(%edx),%eax
    5153:	83 c0 01             	add    $0x1,%eax
    5156:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    5159:	3b 86 a8 5a 00 00    	cmp    0x5aa8(%esi),%eax
    515f:	76 06                	jbe    5167 <rlc_mac_main+0x1327>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    5161:	89 86 a8 5a 00 00    	mov    %eax,0x5aa8(%esi)
			}
			umTxIns->umSduBufferSize += skb->len;
    5167:	8b 43 50             	mov    0x50(%ebx),%eax
    516a:	01 42 20             	add    %eax,0x20(%edx)
    516d:	e9 8c f3 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
	{
		//modified by HQ    	
		fsm_printf("[UEMAC][nc_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    5172:	c7 04 24 4c 17 00 00 	movl   $0x174c,(%esp)
    5179:	e8 fc ff ff ff       	call   517a <rlc_mac_main+0x133a>
		// fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
		//modified by HQ
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
    517e:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
    5182:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    5186:	e9 85 ee ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				SV(UL_resource_info.resource_flag)=false;
			}
			//fsm_printf("[UEMAC][waitsend_msg3]DoResourceAllocation \n");
		}
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
    518b:	b8 2c 13 00 00       	mov    $0x132c,%eax
    5190:	e8 fc ff ff ff       	call   5191 <rlc_mac_main+0x1351>
    5195:	e9 ce f0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);

	if( PMRLC_BUFFERREP_REQ() == NULL )
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    519a:	c7 04 24 48 1b 00 00 	movl   $0x1b48,(%esp)
    51a1:	e8 fc ff ff ff       	call   51a2 <rlc_mac_main+0x1362>
    51a6:	e9 cb f3 ff ff       	jmp    4576 <rlc_mac_main+0x736>
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
	{
		fsm_printf("[DeQueue]Queue is empty!\n");
    51ab:	c7 04 24 44 04 00 00 	movl   $0x444,(%esp)
    51b2:	e8 fc ff ff ff       	call   51b3 <rlc_mac_main+0x1373>
    51b7:	e9 ba f3 ff ff       	jmp    4576 <rlc_mac_main+0x736>
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    51bc:	b8 08 00 00 00       	mov    $0x8,%eax
    51c1:	e8 fc ff ff ff       	call   51c2 <rlc_mac_main+0x1382>
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51c6:	ba 24 00 00 00       	mov    $0x24,%edx
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    51cb:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 2; 
    51cd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
		data_ptr->rnti_value = SV(T_C_RNTI);
    51d3:	0f b7 47 02          	movzwl 0x2(%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51d7:	89 d9                	mov    %ebx,%ecx
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
    51d9:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51dc:	b8 03 00 00 00       	mov    $0x3,%eax
    51e1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    51e8:	e8 fc ff ff ff       	call   51e9 <rlc_mac_main+0x13a9>
		fsm_mem_free(data_ptr);
    51ed:	89 d8                	mov    %ebx,%eax
    51ef:	e8 fc ff ff ff       	call   51f0 <rlc_mac_main+0x13b0>
    51f4:	e9 73 f7 ff ff       	jmp    496c <rlc_mac_main+0xb2c>
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    51f9:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    51fd:	ba 0b 00 00 00       	mov    $0xb,%edx
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5202:	c1 e0 04             	shl    $0x4,%eax
    5205:	66 89 43 22          	mov    %ax,0x22(%ebx)
		SV(TATimer.time_value)=SV(TA_Periodic_time);
    5209:	8b 43 24             	mov    0x24(%ebx),%eax
    520c:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5212:	6b c0 64             	imul   $0x64,%eax,%eax
    5215:	e8 fc ff ff ff       	call   5216 <rlc_mac_main+0x13d6>
		SV(TATimer.flag)=true;
    521a:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5221:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
    5227:	e9 35 f7 ff ff       	jmp    4961 <rlc_mac_main+0xb21>
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    522c:	8b 47 2c             	mov    0x2c(%edi),%eax
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
    522f:	c7 87 f8 01 00 00 02 	movl   $0x2,0x1f8(%edi)
    5236:	00 00 00 
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    5239:	c1 e8 03             	shr    $0x3,%eax
    523c:	89 87 f4 01 00 00    	mov    %eax,0x1f4(%edi)
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    5242:	e8 fc ff ff ff       	call   5243 <rlc_mac_main+0x1403>
    5247:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    5249:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    524f:	c7 04 24 58 13 00 00 	movl   $0x1358,(%esp)
    5256:	89 44 24 04          	mov    %eax,0x4(%esp)
    525a:	e8 fc ff ff ff       	call   525b <rlc_mac_main+0x141b>
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    525f:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    5265:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    526b:	83 fa 01             	cmp    $0x1,%edx
    526e:	0f 84 c5 06 00 00    	je     5939 <rlc_mac_main+0x1af9>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    5274:	85 c0                	test   %eax,%eax
    5276:	74 09                	je     5281 <rlc_mac_main+0x1441>
    5278:	83 fa 02             	cmp    $0x2,%edx
    527b:	0f 84 b1 09 00 00    	je     5c32 <rlc_mac_main+0x1df2>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    5281:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5287:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    528c:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5292:	6b c0 64             	imul   $0x64,%eax,%eax
    5295:	e8 fc ff ff ff       	call   5296 <rlc_mac_main+0x1456>
	SV(CRTimer.flag)=true;
    529a:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    52a1:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
		//fsm_schedule_self(0, RA_Send_Msg3);//LHL 20140726 ,MSG3MAC
		retransmit_msg3(); 	//call static retransmit_msg3(void) function 20150901 
		fsm_printf("[UEMAC][waitsend_msg3]this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
    52a7:	c7 04 24 7c 13 00 00 	movl   $0x137c,(%esp)
    52ae:	e8 fc ff ff ff       	call   52af <rlc_mac_main+0x146f>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    52b3:	e9 b0 ef ff ff       	jmp    4268 <rlc_mac_main+0x428>
	u32 backoff_time=0,backoff_param=0;//ms backoff_index

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
	{
		fsm_printf("[UEMAC][con_failed]because CRtimer expire \n");
    52b8:	c7 04 24 28 14 00 00 	movl   $0x1428,(%esp)
    52bf:	e8 fc ff ff ff       	call   52c0 <rlc_mac_main+0x1480>
		SV(CRTimer.timer_sign)= NULL;
    52c4:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    52cb:	00 00 00 
		SV(CRTimer.flag)= false;
    52ce:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
    52d5:	e9 e3 f5 ff ff       	jmp    48bd <rlc_mac_main+0xa7d>
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    52da:	e8 fc ff ff ff       	call   52db <rlc_mac_main+0x149b>
    52df:	83 f8 01             	cmp    $0x1,%eax
    52e2:	0f 85 5c ec ff ff    	jne    3f44 <rlc_mac_main+0x104>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
    52e8:	b8 0c 0f 00 00       	mov    $0xf0c,%eax
    52ed:	e8 fc ff ff ff       	call   52ee <rlc_mac_main+0x14ae>
		ue_mac_sv_close();
    52f2:	e8 59 d7 ff ff       	call   2a50 <ue_mac_sv_close>
    52f7:	e9 14 ed ff ff       	jmp    4010 <rlc_mac_main+0x1d0>

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
	fsm_mem_set(pdu_type,0,sizeof(char));

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    52fc:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5300:	0f 84 fb ee ff ff    	je     4201 <rlc_mac_main+0x3c1>
		fsm_schedule_self(0, Contention_Success );//TEST  
    5306:	ba 06 00 00 00       	mov    $0x6,%edx
    530b:	31 c0                	xor    %eax,%eax
    530d:	e8 fc ff ff ff       	call   530e <rlc_mac_main+0x14ce>
    5312:	e9 ea ee ff ff       	jmp    4201 <rlc_mac_main+0x3c1>
	if(MAC_CLOSE)
    5317:	e8 fc ff ff ff       	call   5318 <rlc_mac_main+0x14d8>
    531c:	83 f8 01             	cmp    $0x1,%eax
    531f:	90                   	nop
    5320:	0f 85 e9 ee ff ff    	jne    420f <rlc_mac_main+0x3cf>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
    5326:	b8 94 14 00 00       	mov    $0x1494,%eax
    532b:	e8 fc ff ff ff       	call   532c <rlc_mac_main+0x14ec>
		ue_mac_sv_close();
    5330:	e8 1b d7 ff ff       	call   2a50 <ue_mac_sv_close>
    5335:	e9 2e ef ff ff       	jmp    4268 <rlc_mac_main+0x428>
    533a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    5340:	e8 fc ff ff ff       	call   5341 <rlc_mac_main+0x1501>
    5345:	83 f8 01             	cmp    $0x1,%eax
    5348:	0f 85 2d f1 ff ff    	jne    447b <rlc_mac_main+0x63b>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
    534e:	b8 04 18 00 00       	mov    $0x1804,%eax
    5353:	e8 fc ff ff ff       	call   5354 <rlc_mac_main+0x1514>
		ue_mac_sv_close();
    5358:	e8 f3 d6 ff ff       	call   2a50 <ue_mac_sv_close>
    535d:	e9 56 ed ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
	{//ICIRLC
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
    5362:	b8 34 0f 00 00       	mov    $0xf34,%eax
    5367:	e8 fc ff ff ff       	call   5368 <rlc_mac_main+0x1528>
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
    536c:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    5373:	0f 84 53 03 00 00    	je     56cc <rlc_mac_main+0x188c>
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
    5379:	c7 04 24 80 0f 00 00 	movl   $0xf80,(%esp)
    5380:	e8 fc ff ff ff       	call   5381 <rlc_mac_main+0x1541>
		{
			//IDLE
			fsm_pkt_destroy(fsm_pkt_get());
		}
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
    5385:	e8 fc ff ff ff       	call   5386 <rlc_mac_main+0x1546>
    538a:	e8 fc ff ff ff       	call   538b <rlc_mac_main+0x154b>
		SV(countRecvFromLower)++;
    538f:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
    5396:	e9 75 ec ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    539b:	e8 fc ff ff ff       	call   539c <rlc_mac_main+0x155c>
    53a0:	83 f8 01             	cmp    $0x1,%eax
    53a3:	0f 85 a9 eb ff ff    	jne    3f52 <rlc_mac_main+0x112>
	{
		rlc_close();
    53a9:	e8 c2 c9 ff ff       	call   1d70 <rlc_close>
    53ae:	66 90                	xchg   %ax,%ax
    53b0:	e9 5b ec ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    53b5:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    53bc:	e8 ef d5 ff ff       	call   29b0 <rlc_pkt_receive_from_upper>

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
    53c1:	e8 fc ff ff ff       	call   53c2 <rlc_mac_main+0x1582>
    53c6:	85 c0                	test   %eax,%eax
    53c8:	0f 84 86 06 00 00    	je     5a54 <rlc_mac_main+0x1c14>
    53ce:	66 90                	xchg   %ax,%ax
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    53d0:	e8 fc ff ff ff       	call   53d1 <rlc_mac_main+0x1591>
			tmpdata = *((u32*)tmpdata_ptr);//	
    53d5:	8b 10                	mov    (%eax),%edx
		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    53d7:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    53d9:	85 d2                	test   %edx,%edx
    53db:	0f 8e c9 ec ff ff    	jle    40aa <rlc_mac_main+0x26a>
			{
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    53e1:	8d 40 04             	lea    0x4(%eax),%eax
    53e4:	e8 fc ff ff ff       	call   53e5 <rlc_mac_main+0x15a5>
    53e9:	e8 fc ff ff ff       	call   53ea <rlc_mac_main+0x15aa>
				fsm_data_destroy((void *)tmpdata_ptr);//
    53ee:	89 d8                	mov    %ebx,%eax
    53f0:	e8 fc ff ff ff       	call   53f1 <rlc_mac_main+0x15b1>
    53f5:	e9 b0 ec ff ff       	jmp    40aa <rlc_mac_main+0x26a>
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    53fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
    53fd:	ba 02 00 00 00       	mov    $0x2,%edx
    5402:	e8 fc ff ff ff       	call   5403 <rlc_mac_main+0x15c3>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    5407:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    540b:	31 d2                	xor    %edx,%edx
    540d:	66 f7 f3             	div    %bx
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5410:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    5417:	00 
    5418:	c7 04 24 ac 12 00 00 	movl   $0x12ac,(%esp)
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    541f:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5423:	0f b7 d2             	movzwl %dx,%edx
    5426:	89 54 24 08          	mov    %edx,0x8(%esp)
    542a:	e8 fc ff ff ff       	call   542b <rlc_mac_main+0x15eb>
    542f:	e9 11 f6 ff ff       	jmp    4a45 <rlc_mac_main+0xc05>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
    5434:	85 ff                	test   %edi,%edi
    5436:	0f 85 e7 ee ff ff    	jne    4323 <rlc_mac_main+0x4e3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
    543c:	c7 05 30 00 00 00 db 	movl   $0x3db,0x30
    5443:	03 00 00 
    5446:	e8 b5 df ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    544b:	e9 c0 eb ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    5450:	ba 04 00 00 00       	mov    $0x4,%edx
    5455:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5458:	e8 fc ff ff ff       	call   5459 <rlc_mac_main+0x1619>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    545d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5460:	31 d2                	xor    %edx,%edx
    5462:	f7 f3                	div    %ebx
    5464:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5467:	e9 be f4 ff ff       	jmp    492a <rlc_mac_main+0xaea>
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    546c:	e8 fc ff ff ff       	call   546d <rlc_mac_main+0x162d>
    5471:	83 f8 09             	cmp    $0x9,%eax
    5474:	0f 85 c4 ed ff ff    	jne    423e <rlc_mac_main+0x3fe>
	{
		FlushBj();
    547a:	e8 fc ff ff ff       	call   547b <rlc_mac_main+0x163b>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    547f:	ba 09 00 00 00       	mov    $0x9,%edx
    5484:	b8 64 00 00 00       	mov    $0x64,%eax
    5489:	e8 fc ff ff ff       	call   548a <rlc_mac_main+0x164a>
    548e:	e9 d5 ed ff ff       	jmp    4268 <rlc_mac_main+0x428>
    5493:	90                   	nop
    5494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void cra_pkt_recv_from_upper(void)
{
	FSM_PKT *skb;

	FIN(cra_pkt_recv_from_upper());
	SV_PTR_GET(rlc_mac_sv);
    5498:	e8 fc ff ff ff       	call   5499 <rlc_mac_main+0x1659>
    549d:	89 c3                	mov    %eax,%ebx
    549f:	90                   	nop
	
	skb = (FSM_PKT *)fsm_pkt_get();
    54a0:	e8 fc ff ff ff       	call   54a1 <rlc_mac_main+0x1661>
    54a5:	89 c7                	mov    %eax,%edi
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]recv from upper\n");
    54a7:	c7 04 24 24 16 00 00 	movl   $0x1624,(%esp)
    54ae:	e8 fc ff ff ff       	call   54af <rlc_mac_main+0x166f>
	fsm_octets_print(skb->data, 64);
    54b3:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    54b9:	ba 40 00 00 00       	mov    $0x40,%edx
    54be:	e8 fc ff ff ff       	call   54bf <rlc_mac_main+0x167f>
	return Q->front == Q->rear;		//because of the head node existence, once front==rear represent the queue empty.
}

static void EnQueue(CraQueuePtr *Q, FSM_PKT *pktptr)
{
	QueueNode *p = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    54c3:	b8 08 00 00 00       	mov    $0x8,%eax
    54c8:	e8 fc ff ff ff       	call   54c9 <rlc_mac_main+0x1689>
	p->pkt = pktptr;
    54cd:	89 38                	mov    %edi,(%eax)
	p->next = NULL;
    54cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	// 	(*Q)->front = (*Q)->rear = p;		//insert node p into a empty queue
	// else{
	// 	(*Q)->rear->next = p;
	// 	(*Q)->rear = p;
	// }
	(*Q)->rear->next = p;
    54d6:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    54dc:	8b 52 04             	mov    0x4(%edx),%edx
    54df:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->rear = p;
    54e2:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    54e8:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->pkt_count++;
    54eb:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    54f1:	66 83 40 08 01       	addw   $0x1,0x8(%eax)
	fsm_printf("[EnQueue]EnQueue successfully!\n");
    54f6:	c7 04 24 58 16 00 00 	movl   $0x1658,(%esp)
    54fd:	e8 fc ff ff ff       	call   54fe <rlc_mac_main+0x16be>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    5502:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5508:	0f b7 40 08          	movzwl 0x8(%eax),%eax
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    550c:	c7 04 24 78 16 00 00 	movl   $0x1678,(%esp)
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5513:	89 44 24 04          	mov    %eax,0x4(%esp)
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    5517:	e8 fc ff ff ff       	call   5518 <rlc_mac_main+0x16d8>
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
    551c:	c7 04 24 b4 16 00 00 	movl   $0x16b4,(%esp)
    5523:	e8 fc ff ff ff       	call   5524 <rlc_mac_main+0x16e4>
    5528:	e9 3b ed ff ff       	jmp    4268 <rlc_mac_main+0x428>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    552d:	e8 fc ff ff ff       	call   552e <rlc_mac_main+0x16ee>
    5532:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    5538:	e8 73 c7 ff ff       	call   1cb0 <findInsByCode>
    553d:	85 c0                	test   %eax,%eax
    553f:	89 c3                	mov    %eax,%ebx
    5541:	0f 84 20 0c 00 00    	je     6167 <rlc_mac_main+0x2327>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    5547:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    554d:	83 f8 02             	cmp    $0x2,%eax
    5550:	0f 84 53 07 00 00    	je     5ca9 <rlc_mac_main+0x1e69>
    5556:	0f 87 a1 02 00 00    	ja     57fd <rlc_mac_main+0x19bd>
    555c:	83 e8 01             	sub    $0x1,%eax
    555f:	0f 84 31 07 00 00    	je     5c96 <rlc_mac_main+0x1e56>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    5565:	c7 04 24 14 10 00 00 	movl   $0x1014,(%esp)
    556c:	e8 fc ff ff ff       	call   556d <rlc_mac_main+0x172d>
    5571:	e9 34 eb ff ff       	jmp    40aa <rlc_mac_main+0x26a>
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5576:	e8 fc ff ff ff       	call   5577 <rlc_mac_main+0x1737>
    557b:	83 f8 09             	cmp    $0x9,%eax
    557e:	66 90                	xchg   %ax,%ax
    5580:	0f 85 d8 ea ff ff    	jne    405e <rlc_mac_main+0x21e>
	{
		FlushBj();
    5586:	e8 fc ff ff ff       	call   5587 <rlc_mac_main+0x1747>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    558b:	ba 09 00 00 00       	mov    $0x9,%edx
    5590:	b8 64 00 00 00       	mov    $0x64,%eax
    5595:	e8 fc ff ff ff       	call   5596 <rlc_mac_main+0x1756>
    559a:	e9 0b eb ff ff       	jmp    40aa <rlc_mac_main+0x26a>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    559f:	e8 fc ff ff ff       	call   55a0 <rlc_mac_main+0x1760>
    55a4:	83 f8 09             	cmp    $0x9,%eax
    55a7:	0f 85 b4 ed ff ff    	jne    4361 <rlc_mac_main+0x521>
    55ad:	8d 76 00             	lea    0x0(%esi),%esi
	{
		FlushBj();
    55b0:	e8 fc ff ff ff       	call   55b1 <rlc_mac_main+0x1771>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    55b5:	ba 09 00 00 00       	mov    $0x9,%edx
    55ba:	b8 64 00 00 00       	mov    $0x64,%eax
    55bf:	e8 fc ff ff ff       	call   55c0 <rlc_mac_main+0x1780>
    55c4:	e9 98 ed ff ff       	jmp    4361 <rlc_mac_main+0x521>
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
	{
		//decomplexUeDataPdu(fsm_pkt_get());
		decomplexUeRARPdu(fsm_pkt_get());	//modify by lxr 20160122
    55c9:	e8 fc ff ff ff       	call   55ca <rlc_mac_main+0x178a>
    55ce:	66 90                	xchg   %ax,%ax
    55d0:	e8 fc ff ff ff       	call   55d1 <rlc_mac_main+0x1791>
    55d5:	e9 79 ed ff ff       	jmp    4353 <rlc_mac_main+0x513>
    55da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
	if(MAC_CLOSE)
    55e0:	e8 fc ff ff ff       	call   55e1 <rlc_mac_main+0x17a1>
    55e5:	83 f8 01             	cmp    $0x1,%eax
    55e8:	0f 85 57 ed ff ff    	jne    4345 <rlc_mac_main+0x505>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
    55ee:	b8 dc 17 00 00       	mov    $0x17dc,%eax
    55f3:	e8 fc ff ff ff       	call   55f4 <rlc_mac_main+0x17b4>
		ue_mac_sv_close();
    55f8:	e8 53 d4 ff ff       	call   2a50 <ue_mac_sv_close>
    55fd:	e9 43 ed ff ff       	jmp    4345 <rlc_mac_main+0x505>
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
				SV(UL_resource_info.resource_flag)=false;
			}
			else//RRCC_RNTI2010721 LHL
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5602:	c1 ea 03             	shr    $0x3,%edx
    5605:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//20140531 ,20140718LHL:32MAC
    560b:	e8 fc ff ff ff       	call   560c <rlc_mac_main+0x17cc>
    5610:	e8 fc ff ff ff       	call   5611 <rlc_mac_main+0x17d1>
				SV(UL_resource_info.resource_flag)=false;
    5615:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    5619:	e9 4a ec ff ff       	jmp    4268 <rlc_mac_main+0x428>
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    561e:	e8 fc ff ff ff       	call   561f <rlc_mac_main+0x17df>
    5623:	83 f8 0b             	cmp    $0xb,%eax
    5626:	0f 85 52 e9 ff ff    	jne    3f7e <rlc_mac_main+0x13e>
    562c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5630:	e9 30 f4 ff ff       	jmp    4a65 <rlc_mac_main+0xc25>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    5635:	e8 fc ff ff ff       	call   5636 <rlc_mac_main+0x17f6>
    563a:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    5640:	e8 6b c6 ff ff       	call   1cb0 <findInsByCode>
    5645:	89 c3                	mov    %eax,%ebx
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5647:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    564d:	83 f8 02             	cmp    $0x2,%eax
    5650:	0f 84 b0 04 00 00    	je     5b06 <rlc_mac_main+0x1cc6>
    5656:	0f 87 09 04 00 00    	ja     5a65 <rlc_mac_main+0x1c25>
    565c:	83 e8 01             	sub    $0x1,%eax
    565f:	0f 84 ba 05 00 00    	je     5c1f <rlc_mac_main+0x1ddf>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    5665:	c7 04 24 14 10 00 00 	movl   $0x1014,(%esp)
    566c:	e8 fc ff ff ff       	call   566d <rlc_mac_main+0x182d>
    5671:	e9 9a e9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	else if(TimeAlignmentTimerExpire)
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5676:	e8 fc ff ff ff       	call   5677 <rlc_mac_main+0x1837>
    567b:	83 f8 09             	cmp    $0x9,%eax
    567e:	66 90                	xchg   %ax,%ax
    5680:	0f 85 08 e9 ff ff    	jne    3f8e <rlc_mac_main+0x14e>
	{
		FlushBj();
    5686:	e8 fc ff ff ff       	call   5687 <rlc_mac_main+0x1847>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    568b:	ba 09 00 00 00       	mov    $0x9,%edx
    5690:	b8 64 00 00 00       	mov    $0x64,%eax
    5695:	e8 fc ff ff ff       	call   5696 <rlc_mac_main+0x1856>
    569a:	e9 71 e9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
	{// 
		//DoResourceAllocation(SV(UL_resource_info.m_tbsize)); 
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
    569f:	c7 04 24 2c 18 00 00 	movl   $0x182c,(%esp)
    56a6:	e8 fc ff ff ff       	call   56a7 <rlc_mac_main+0x1867>
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    56ab:	8b 47 2c             	mov    0x2c(%edi),%eax
    56ae:	89 c2                	mov    %eax,%edx
    56b0:	c1 ea 03             	shr    $0x3,%edx
    56b3:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
    56b9:	e8 fc ff ff ff       	call   56ba <rlc_mac_main+0x187a>
    56be:	e8 fc ff ff ff       	call   56bf <rlc_mac_main+0x187f>
		SV(UL_resource_info.resource_flag)=false;
    56c3:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    56c7:	e9 d0 ed ff ff       	jmp    449c <rlc_mac_main+0x65c>
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
		else
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=false\n");//testing code 	 
    56cc:	c7 04 24 ac 0f 00 00 	movl   $0xfac,(%esp)
    56d3:	e8 fc ff ff ff       	call   56d4 <rlc_mac_main+0x1894>
    56d8:	e9 a8 fc ff ff       	jmp    5385 <rlc_mac_main+0x1545>
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    56dd:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    56e4:	e8 c7 d2 ff ff       	call   29b0 <rlc_pkt_receive_from_upper>
    56e9:	e9 22 e9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	else if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
		u32 cmd1=fsm_ev_ioctrl_cmd();
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
    56ee:	83 f8 0c             	cmp    $0xc,%eax
    56f1:	0f 84 23 03 00 00    	je     5a1a <rlc_mac_main+0x1bda>
    56f7:	83 f8 0e             	cmp    $0xe,%eax
    56fa:	0f 85 ff e8 ff ff    	jne    3fff <rlc_mac_main+0x1bf>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//
			case IOCCMD_PHYtoMAC_SYSFRAME:
				tmpdata_ptr = fsm_data_get();
    5700:	e8 fc ff ff ff       	call   5701 <rlc_mac_main+0x18c1>
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
    5705:	0f b7 10             	movzwl (%eax),%edx
    5708:	66 89 57 06          	mov    %dx,0x6(%edi)
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
    570c:	0f b7 50 02          	movzwl 0x2(%eax),%edx
    5710:	66 89 57 08          	mov    %dx,0x8(%edi)
				fsm_data_destroy(tmpdata_ptr);
    5714:	e8 fc ff ff ff       	call   5715 <rlc_mac_main+0x18d5>
    5719:	e9 e7 e8 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
	else if(IOCTRL_ARRIVAL)
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
		{
			tmpdata_ptr = (char *)fsm_data_get();
    571e:	e8 fc ff ff ff       	call   571f <rlc_mac_main+0x18df>
    5723:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//
			//print_tran_info("CON receive a RLCdatareq");//testing code
			//fsm_printf("tmpdata:%d \n",tmpdata);//testing code
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5725:	8b 13                	mov    (%ebx),%edx
    5727:	8d 40 04             	lea    0x4(%eax),%eax
    572a:	e8 fc ff ff ff       	call   572b <rlc_mac_main+0x18eb>
    572f:	e8 fc ff ff ff       	call   5730 <rlc_mac_main+0x18f0>
			fsm_data_destroy((void *)tmpdata_ptr);//
    5734:	89 d8                	mov    %ebx,%eax
    5736:	e8 fc ff ff ff       	call   5737 <rlc_mac_main+0x18f7>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    573b:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5742:	0f 85 cd 04 00 00    	jne    5c15 <rlc_mac_main+0x1dd5>
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    5748:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
			
			/*******for test *********/
			SV(UL_resource_info.resource_flag) = true;
    574e:	c6 47 28 01          	movb   $0x1,0x28(%edi)
			/********for test *********/
			if(SV(UL_resource_info.resource_flag) == true)
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
    5752:	c7 47 2c c0 2b 00 00 	movl   $0x2bc0,0x2c(%edi)
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5759:	c7 87 f4 01 00 00 78 	movl   $0x578,0x1f4(%edi)
    5760:	05 00 00 
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    5763:	8d 50 05             	lea    0x5(%eax),%edx
    5766:	39 50 05             	cmp    %edx,0x5(%eax)
    5769:	74 0f                	je     577a <rlc_mac_main+0x193a>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    576b:	b8 c0 2b 00 00       	mov    $0x2bc0,%eax
    5770:	e8 fc ff ff ff       	call   5771 <rlc_mac_main+0x1931>
    5775:	e8 fc ff ff ff       	call   5776 <rlc_mac_main+0x1936>
				SV(UL_resource_info.resource_flag)=false;
    577a:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    577e:	e9 22 e9 ff ff       	jmp    40a5 <rlc_mac_main+0x265>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    5783:	e8 fc ff ff ff       	call   5784 <rlc_mac_main+0x1944>
    5788:	83 e8 01             	sub    $0x1,%eax
    578b:	0f 85 f8 ec ff ff    	jne    4489 <rlc_mac_main+0x649>
	{
		rlc_close();
    5791:	e8 da c5 ff ff       	call   1d70 <rlc_close>
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
    5796:	c7 04 24 27 04 00 00 	movl   $0x427,(%esp)
    579d:	e8 fc ff ff ff       	call   579e <rlc_mac_main+0x195e>
    57a2:	e9 11 e9 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
    57a7:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    57ae:	00 00 00 
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    57b1:	31 c9                	xor    %ecx,%ecx
    57b3:	ba 22 00 00 00       	mov    $0x22,%edx
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
    57b8:	c7 83 e8 01 00 00 00 	movl   $0x0,0x1e8(%ebx)
    57bf:	00 00 00 
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    57c2:	b8 05 00 00 00       	mov    $0x5,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
    57c7:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    57ce:	00 00 00 
		SV(ra_allocation_res)=0;
    57d1:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    57d8:	00 00 00 
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    57db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    57e2:	e8 fc ff ff ff       	call   57e3 <rlc_mac_main+0x19a3>
    57e7:	e9 24 e8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
		//modified by HQ
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    57ec:	c7 04 24 6c 12 00 00 	movl   $0x126c,(%esp)
    57f3:	e8 fc ff ff ff       	call   57f4 <rlc_mac_main+0x19b4>
    57f8:	e9 13 e8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    57fd:	83 f8 03             	cmp    $0x3,%eax
    5800:	0f 84 c0 04 00 00    	je     5cc6 <rlc_mac_main+0x1e86>
    5806:	83 f8 04             	cmp    $0x4,%eax
    5809:	0f 85 56 fd ff ff    	jne    5565 <rlc_mac_main+0x1725>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    580f:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5813:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    581a:	c7 04 24 dc 0f 00 00 	movl   $0xfdc,(%esp)
    5821:	89 44 24 04          	mov    %eax,0x4(%esp)
    5825:	e8 fc ff ff ff       	call   5826 <rlc_mac_main+0x19e6>
			if(umRxIns->snFiledLength == 5)
    582a:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    582f:	0f 84 88 05 00 00    	je     5dbd <rlc_mac_main+0x1f7d>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5835:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    583a:	0f 85 78 e8 ff ff    	jne    40b8 <rlc_mac_main+0x278>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5840:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    5847:	bf 00 04 00 00       	mov    $0x400,%edi
    584c:	89 ca                	mov    %ecx,%edx
    584e:	89 c8                	mov    %ecx,%eax
    5850:	66 c1 fa 0f          	sar    $0xf,%dx
    5854:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5857:	0f bf fa             	movswl %dx,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    585a:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5861:	83 bc bb b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edi,4)
    5868:	00 
    5869:	74 3f                	je     58aa <rlc_mac_main+0x1a6a>
    586b:	66 39 d1             	cmp    %dx,%cx
    586e:	7e 12                	jle    5882 <rlc_mac_main+0x1a42>
    5870:	eb 38                	jmp    58aa <rlc_mac_main+0x1a6a>
    5872:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    5878:	66 39 c1             	cmp    %ax,%cx
    587b:	90                   	nop
    587c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5880:	7f 21                	jg     58a3 <rlc_mac_main+0x1a63>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5882:	8d 47 01             	lea    0x1(%edi),%eax
    5885:	89 c2                	mov    %eax,%edx
    5887:	c1 fa 1f             	sar    $0x1f,%edx
    588a:	c1 ea 16             	shr    $0x16,%edx
    588d:	01 d0                	add    %edx,%eax
    588f:	25 ff 03 00 00       	and    $0x3ff,%eax
    5894:	29 d0                	sub    %edx,%eax
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5896:	0f bf f8             	movswl %ax,%edi
    5899:	83 bc bb b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edi,4)
    58a0:	00 
    58a1:	75 d5                	jne    5878 <rlc_mac_main+0x1a38>
    58a3:	66 89 83 bc 10 00 00 	mov    %ax,0x10bc(%ebx)
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    58aa:	8d 53 18             	lea    0x18(%ebx),%edx
    58ad:	89 d8                	mov    %ebx,%eax
    58af:	e8 fc ff ff ff       	call   58b0 <rlc_mac_main+0x1a70>
    58b4:	e9 ff e7 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    58b9:	e8 fc ff ff ff       	call   58ba <rlc_mac_main+0x1a7a>
				tmpdata = *((u32*)tmpdata_ptr);//				
    58be:	8b 10                	mov    (%eax),%edx
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    58c0:	89 c3                	mov    %eax,%ebx
				tmpdata = *((u32*)tmpdata_ptr);//				
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    58c2:	c7 04 24 7c 10 00 00 	movl   $0x107c,(%esp)
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
				tmpdata = *((u32*)tmpdata_ptr);//				
    58c9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    58cc:	e8 fc ff ff ff       	call   58cd <rlc_mac_main+0x1a8d>
				fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
    58d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    58d4:	c7 04 24 b0 10 00 00 	movl   $0x10b0,(%esp)
    58db:	89 54 24 04          	mov    %edx,0x4(%esp)
    58df:	e8 fc ff ff ff       	call   58e0 <rlc_mac_main+0x1aa0>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    58e4:	8b 43 07             	mov    0x7(%ebx),%eax
    58e7:	c7 04 24 d4 10 00 00 	movl   $0x10d4,(%esp)
    58ee:	89 44 24 04          	mov    %eax,0x4(%esp)
    58f2:	e8 fc ff ff ff       	call   58f3 <rlc_mac_main+0x1ab3>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    58f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    58fa:	8d 43 04             	lea    0x4(%ebx),%eax
    58fd:	e8 fc ff ff ff       	call   58fe <rlc_mac_main+0x1abe>
    5902:	e8 fc ff ff ff       	call   5903 <rlc_mac_main+0x1ac3>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    5907:	89 d8                	mov    %ebx,%eax
    5909:	e8 fc ff ff ff       	call   590a <rlc_mac_main+0x1aca>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    590e:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5915:	0f 85 b9 05 00 00    	jne    5ed4 <rlc_mac_main+0x2094>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    591b:	ba 02 00 00 00       	mov    $0x2,%edx
    5920:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5925:	e8 fc ff ff ff       	call   5926 <rlc_mac_main+0x1ae6>
				SV(ratype.ra_type)=2;
    592a:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5931:	00 00 00 
    5934:	e9 cc e6 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    5939:	85 c0                	test   %eax,%eax
    593b:	74 05                	je     5942 <rlc_mac_main+0x1b02>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    593d:	e8 fc ff ff ff       	call   593e <rlc_mac_main+0x1afe>
		SV(msg3_buf_ptr)=skb;//3
    5942:	31 c0                	xor    %eax,%eax
    5944:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    594a:	e8 fc ff ff ff       	call   594b <rlc_mac_main+0x1b0b>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    594f:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5954:	89 c7                	mov    %eax,%edi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5956:	e8 fc ff ff ff       	call   5957 <rlc_mac_main+0x1b17>
    595b:	85 c0                	test   %eax,%eax
    595d:	74 1a                	je     5979 <rlc_mac_main+0x1b39>
    595f:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5963:	74 14                	je     5979 <rlc_mac_main+0x1b39>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5965:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    596c:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5973:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    5979:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5980:	00 00 00 
		complexUeMacPdu(skb);
    5983:	89 f8                	mov    %edi,%eax
    5985:	e8 fc ff ff ff       	call   5986 <rlc_mac_main+0x1b46>
		
	
		if(SV(Tbsize_Complex)!=0)
    598a:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5991:	74 0a                	je     599d <rlc_mac_main+0x1b5d>
			SV(Tbsize_Complex)=0;//TBSIZE
    5993:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    599a:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    599d:	c7 04 24 d8 0c 00 00 	movl   $0xcd8,(%esp)
    59a4:	e8 fc ff ff ff       	call   59a5 <rlc_mac_main+0x1b65>
    59a9:	e9 d3 f8 ff ff       	jmp    5281 <rlc_mac_main+0x1441>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//RRCRA
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
    59ae:	e8 fc ff ff ff       	call   59af <rlc_mac_main+0x1b6f>
    59b3:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    59b5:	b8 fc 10 00 00       	mov    $0x10fc,%eax
    59ba:	e8 fc ff ff ff       	call   59bb <rlc_mac_main+0x1b7b>
				if(tmpdata_ptr > 0)//
    59bf:	85 db                	test   %ebx,%ebx
    59c1:	0f 84 e8 04 00 00    	je     5eaf <rlc_mac_main+0x206f>
				{
					fsm_printf("[UEMAC][idle_default]IDLE receive a ncra order ");
    59c7:	c7 04 24 3c 11 00 00 	movl   $0x113c,(%esp)
    59ce:	e8 fc ff ff ff       	call   59cf <rlc_mac_main+0x1b8f>
					fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    59d3:	89 da                	mov    %ebx,%edx
    59d5:	b9 02 00 00 00       	mov    $0x2,%ecx
    59da:	8d 47 04             	lea    0x4(%edi),%eax
    59dd:	e8 fc ff ff ff       	call   59de <rlc_mac_main+0x1b9e>
					fsm_printf("[UEMAC][idle_default]the RAPID is %d\n",SV(RA_info.ra_PreambleIndex));
    59e2:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    59e6:	c7 04 24 6c 11 00 00 	movl   $0x116c,(%esp)
    59ed:	89 44 24 04          	mov    %eax,0x4(%esp)
    59f1:	e8 fc ff ff ff       	call   59f2 <rlc_mac_main+0x1bb2>
					if(tmpdata_ptr != NULL)
					{
						fsm_data_destroy(tmpdata_ptr);//
    59f6:	89 d8                	mov    %ebx,%eax
    59f8:	e8 fc ff ff ff       	call   59f9 <rlc_mac_main+0x1bb9>
						fsm_printf("[UEMAC][idle_default]fsm_ev_data,then free the memory\n");
    59fd:	c7 04 24 94 11 00 00 	movl   $0x1194,(%esp)
    5a04:	e8 fc ff ff ff       	call   5a05 <rlc_mac_main+0x1bc5>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
    5a09:	ba 01 00 00 00       	mov    $0x1,%edx
    5a0e:	31 c0                	xor    %eax,%eax
    5a10:	e8 fc ff ff ff       	call   5a11 <rlc_mac_main+0x1bd1>
    5a15:	e9 eb e5 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
				SV(ratype.ra_type)=2;
			break;
			//PHYRA
			case IOCCMD_PDCCHtoMAC_RandomAcc_Req: 	
			// break	  
				tmpdata_ptr = fsm_data_get();
    5a1a:	e8 fc ff ff ff       	call   5a1b <rlc_mac_main+0x1bdb>
    5a1f:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5a21:	b8 fc 10 00 00       	mov    $0x10fc,%eax
    5a26:	e8 fc ff ff ff       	call   5a27 <rlc_mac_main+0x1be7>
				if(tmpdata_ptr > 0)//
    5a2b:	85 db                	test   %ebx,%ebx
    5a2d:	75 98                	jne    59c7 <rlc_mac_main+0x1b87>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5a2f:	b8 cc 11 00 00       	mov    $0x11cc,%eax
    5a34:	e8 fc ff ff ff       	call   5a35 <rlc_mac_main+0x1bf5>
					SV(ratype.ra_type)=1;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5a39:	ba 02 00 00 00       	mov    $0x2,%edx
    5a3e:	31 c0                	xor    %eax,%eax
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=1;
    5a40:	c7 87 e8 01 00 00 01 	movl   $0x1,0x1e8(%edi)
    5a47:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5a4a:	e8 fc ff ff ff       	call   5a4b <rlc_mac_main+0x1c0b>
    5a4f:	e9 b1 e5 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
		rlc_pkt_receive_from_upper();

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    5a54:	c7 04 24 2c 1c 00 00 	movl   $0x1c2c,(%esp)
    5a5b:	e8 fc ff ff ff       	call   5a5c <rlc_mac_main+0x1c1c>
    5a60:	e9 45 e6 ff ff       	jmp    40aa <rlc_mac_main+0x26a>
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5a65:	83 f8 03             	cmp    $0x3,%eax
    5a68:	0f 84 b5 00 00 00    	je     5b23 <rlc_mac_main+0x1ce3>
    5a6e:	83 f8 04             	cmp    $0x4,%eax
    5a71:	0f 85 ee fb ff ff    	jne    5665 <rlc_mac_main+0x1825>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5a77:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5a7b:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5a82:	c7 04 24 dc 0f 00 00 	movl   $0xfdc,(%esp)
    5a89:	89 44 24 04          	mov    %eax,0x4(%esp)
    5a8d:	e8 fc ff ff ff       	call   5a8e <rlc_mac_main+0x1c4e>
			if(umRxIns->snFiledLength == 5)
    5a92:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    5a97:	0f 84 8b 03 00 00    	je     5e28 <rlc_mac_main+0x1fe8>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5a9d:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    5aa2:	0f 85 68 e5 ff ff    	jne    4010 <rlc_mac_main+0x1d0>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5aa8:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    5aaf:	bf 00 04 00 00       	mov    $0x400,%edi
    5ab4:	89 ca                	mov    %ecx,%edx
    5ab6:	89 c8                	mov    %ecx,%eax
    5ab8:	66 c1 fa 0f          	sar    $0xf,%dx
    5abc:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5abf:	bf 00 04 00 00       	mov    $0x400,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5ac4:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5acb:	eb 16                	jmp    5ae3 <rlc_mac_main+0x1ca3>
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5acd:	66 39 c1             	cmp    %ax,%cx
    5ad0:	7f 25                	jg     5af7 <rlc_mac_main+0x1cb7>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5ad2:	8d 42 01             	lea    0x1(%edx),%eax
    5ad5:	89 c2                	mov    %eax,%edx
    5ad7:	c1 fa 1f             	sar    $0x1f,%edx
    5ada:	f7 ff                	idiv   %edi
    5adc:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5ae3:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5aea:	0f bf d0             	movswl %ax,%edx
    5aed:	83 bc 93 b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edx,4)
    5af4:	00 
    5af5:	75 d6                	jne    5acd <rlc_mac_main+0x1c8d>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5af7:	8d 53 18             	lea    0x18(%ebx),%edx
    5afa:	89 d8                	mov    %ebx,%eax
    5afc:	e8 fc ff ff ff       	call   5afd <rlc_mac_main+0x1cbd>
    5b01:	e9 0a e5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5b06:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5b0a:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5b11:	0f 84 f9 e4 ff ff    	je     4010 <rlc_mac_main+0x1d0>
			{
				rlc_ctrl_pkt_trans(amIns);
    5b17:	89 d8                	mov    %ebx,%eax
    5b19:	e8 fc ff ff ff       	call   5b1a <rlc_mac_main+0x1cda>
    5b1e:	e9 ed e4 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5b23:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5b2a:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5b31:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5b38:	39 d0                	cmp    %edx,%eax
    5b3a:	7d 29                	jge    5b65 <rlc_mac_main+0x1d25>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5b3c:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5b43:	00 
    5b44:	0f 84 d5 02 00 00    	je     5e1f <rlc_mac_main+0x1fdf>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5b4a:	83 c0 01             	add    $0x1,%eax
    5b4d:	eb 12                	jmp    5b61 <rlc_mac_main+0x1d21>
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5b4f:	83 c0 01             	add    $0x1,%eax
    5b52:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5b59:	85 c9                	test   %ecx,%ecx
    5b5b:	0f 84 be 02 00 00    	je     5e1f <rlc_mac_main+0x1fdf>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5b61:	39 d0                	cmp    %edx,%eax
    5b63:	75 ea                	jne    5b4f <rlc_mac_main+0x1d0f>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5b65:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5b6c:	bf 00 04 00 00       	mov    $0x400,%edi
    5b71:	89 ca                	mov    %ecx,%edx
    5b73:	89 c8                	mov    %ecx,%eax
    5b75:	66 c1 fa 0f          	sar    $0xf,%dx
    5b79:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5b7c:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5b7f:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5b86:	7e 30                	jle    5bb8 <rlc_mac_main+0x1d78>
    5b88:	eb 3c                	jmp    5bc6 <rlc_mac_main+0x1d86>
    5b8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5b90:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5b94:	74 30                	je     5bc6 <rlc_mac_main+0x1d86>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5b96:	8d 42 01             	lea    0x1(%edx),%eax
    5b99:	89 c2                	mov    %eax,%edx
    5b9b:	c1 fa 1f             	sar    $0x1f,%edx
    5b9e:	c1 ea 16             	shr    $0x16,%edx
    5ba1:	01 d0                	add    %edx,%eax
    5ba3:	25 ff 03 00 00       	and    $0x3ff,%eax
    5ba8:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5baa:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5bad:	89 c2                	mov    %eax,%edx
    5baf:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5bb6:	7f 0e                	jg     5bc6 <rlc_mac_main+0x1d86>
    5bb8:	0f bf d2             	movswl %dx,%edx
    5bbb:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5bc2:	85 c0                	test   %eax,%eax
    5bc4:	75 ca                	jne    5b90 <rlc_mac_main+0x1d50>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5bc6:	8d 53 30             	lea    0x30(%ebx),%edx
    5bc9:	89 d8                	mov    %ebx,%eax
    5bcb:	e8 fc ff ff ff       	call   5bcc <rlc_mac_main+0x1d8c>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5bd0:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5bd7:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5bde:	66 39 c2             	cmp    %ax,%dx
    5be1:	7f 11                	jg     5bf4 <rlc_mac_main+0x1db4>
    5be3:	98                   	cwtl   
    5be4:	0f bf d2             	movswl %dx,%edx
    5be7:	2d 00 02 00 00       	sub    $0x200,%eax
    5bec:	39 c2                	cmp    %eax,%edx
    5bee:	0f 8d 1c e4 ff ff    	jge    4010 <rlc_mac_main+0x1d0>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5bf4:	8b 53 18             	mov    0x18(%ebx),%edx
    5bf7:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5bfa:	e8 fc ff ff ff       	call   5bfb <rlc_mac_main+0x1dbb>
    5bff:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5c02:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5c09:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5c10:	e9 fb e3 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    5c15:	e8 fc ff ff ff       	call   5c16 <rlc_mac_main+0x1dd6>
    5c1a:	e9 29 fb ff ff       	jmp    5748 <rlc_mac_main+0x1908>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5c1f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5c26:	89 d8                	mov    %ebx,%eax
    5c28:	e8 fc ff ff ff       	call   5c29 <rlc_mac_main+0x1de9>
    5c2d:	e9 de e3 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5c32:	e8 fc ff ff ff       	call   5c33 <rlc_mac_main+0x1df3>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5c37:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5c3c:	89 c7                	mov    %eax,%edi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5c3e:	e8 fc ff ff ff       	call   5c3f <rlc_mac_main+0x1dff>
    5c43:	85 c0                	test   %eax,%eax
    5c45:	74 1a                	je     5c61 <rlc_mac_main+0x1e21>
    5c47:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5c4b:	74 14                	je     5c61 <rlc_mac_main+0x1e21>
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5c4d:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5c54:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5c5b:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
		}
		SV(sendmsg3)=1;	
    5c61:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5c68:	00 00 00 
		complexUeMacPdu(skb); 	
    5c6b:	89 f8                	mov    %edi,%eax
    5c6d:	e8 fc ff ff ff       	call   5c6e <rlc_mac_main+0x1e2e>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    5c72:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5c79:	74 0a                	je     5c85 <rlc_mac_main+0x1e45>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    5c7b:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5c82:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    5c85:	c7 04 24 10 0d 00 00 	movl   $0xd10,(%esp)
    5c8c:	e8 fc ff ff ff       	call   5c8d <rlc_mac_main+0x1e4d>
    5c91:	e9 eb f5 ff ff       	jmp    5281 <rlc_mac_main+0x1441>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5c96:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5c9d:	89 d8                	mov    %ebx,%eax
    5c9f:	e8 fc ff ff ff       	call   5ca0 <rlc_mac_main+0x1e60>
    5ca4:	e9 0f e4 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5ca9:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5cad:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5cb4:	0f 84 fe e3 ff ff    	je     40b8 <rlc_mac_main+0x278>
			{
				rlc_ctrl_pkt_trans(amIns);
    5cba:	89 d8                	mov    %ebx,%eax
    5cbc:	e8 fc ff ff ff       	call   5cbd <rlc_mac_main+0x1e7d>
    5cc1:	e9 f2 e3 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5cc6:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5ccd:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5cd4:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5cdb:	39 d0                	cmp    %edx,%eax
    5cdd:	7d 2f                	jge    5d0e <rlc_mac_main+0x1ece>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5cdf:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5ce6:	00 
    5ce7:	0f 84 29 01 00 00    	je     5e16 <rlc_mac_main+0x1fd6>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5ced:	83 c0 01             	add    $0x1,%eax
    5cf0:	eb 18                	jmp    5d0a <rlc_mac_main+0x1eca>
    5cf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5cf8:	83 c0 01             	add    $0x1,%eax
    5cfb:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5d02:	85 c9                	test   %ecx,%ecx
    5d04:	0f 84 0c 01 00 00    	je     5e16 <rlc_mac_main+0x1fd6>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5d0a:	39 d0                	cmp    %edx,%eax
    5d0c:	75 ea                	jne    5cf8 <rlc_mac_main+0x1eb8>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5d0e:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5d15:	bf 00 04 00 00       	mov    $0x400,%edi
    5d1a:	89 ca                	mov    %ecx,%edx
    5d1c:	89 c8                	mov    %ecx,%eax
    5d1e:	66 c1 fa 0f          	sar    $0xf,%dx
    5d22:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5d25:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5d28:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5d2f:	7e 2f                	jle    5d60 <rlc_mac_main+0x1f20>
    5d31:	eb 3b                	jmp    5d6e <rlc_mac_main+0x1f2e>
    5d33:	90                   	nop
    5d34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5d38:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5d3c:	74 30                	je     5d6e <rlc_mac_main+0x1f2e>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5d3e:	8d 42 01             	lea    0x1(%edx),%eax
    5d41:	89 c2                	mov    %eax,%edx
    5d43:	c1 fa 1f             	sar    $0x1f,%edx
    5d46:	c1 ea 16             	shr    $0x16,%edx
    5d49:	01 d0                	add    %edx,%eax
    5d4b:	25 ff 03 00 00       	and    $0x3ff,%eax
    5d50:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5d52:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5d55:	89 c2                	mov    %eax,%edx
    5d57:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5d5e:	7f 0e                	jg     5d6e <rlc_mac_main+0x1f2e>
    5d60:	0f bf d2             	movswl %dx,%edx
    5d63:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5d6a:	85 c0                	test   %eax,%eax
    5d6c:	75 ca                	jne    5d38 <rlc_mac_main+0x1ef8>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5d6e:	8d 53 30             	lea    0x30(%ebx),%edx
    5d71:	89 d8                	mov    %ebx,%eax
    5d73:	e8 fc ff ff ff       	call   5d74 <rlc_mac_main+0x1f34>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5d78:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5d7f:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5d86:	66 39 c2             	cmp    %ax,%dx
    5d89:	7f 11                	jg     5d9c <rlc_mac_main+0x1f5c>
    5d8b:	98                   	cwtl   
    5d8c:	0f bf d2             	movswl %dx,%edx
    5d8f:	2d 00 02 00 00       	sub    $0x200,%eax
    5d94:	39 c2                	cmp    %eax,%edx
    5d96:	0f 8d 1c e3 ff ff    	jge    40b8 <rlc_mac_main+0x278>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5d9c:	8b 53 18             	mov    0x18(%ebx),%edx
    5d9f:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5da2:	e8 fc ff ff ff       	call   5da3 <rlc_mac_main+0x1f63>
    5da7:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5daa:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5db1:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5db8:	e9 fb e2 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5dbd:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    5dc4:	b9 20 00 00 00       	mov    $0x20,%ecx
    5dc9:	83 c0 01             	add    $0x1,%eax
    5dcc:	89 c2                	mov    %eax,%edx
    5dce:	c1 fa 1f             	sar    $0x1f,%edx
    5dd1:	f7 f9                	idiv   %ecx
    5dd3:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5dda:	eb 1a                	jmp    5df6 <rlc_mac_main+0x1fb6>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5ddc:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    5de3:	7f 22                	jg     5e07 <rlc_mac_main+0x1fc7>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5de5:	8d 42 01             	lea    0x1(%edx),%eax
    5de8:	89 c2                	mov    %eax,%edx
    5dea:	c1 fa 1f             	sar    $0x1f,%edx
    5ded:	f7 f9                	idiv   %ecx
    5def:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5df6:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5dfd:	0f bf d0             	movswl %ax,%edx
    5e00:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    5e05:	75 d5                	jne    5ddc <rlc_mac_main+0x1f9c>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5e07:	8d 53 18             	lea    0x18(%ebx),%edx
    5e0a:	89 d8                	mov    %ebx,%eax
    5e0c:	e8 fc ff ff ff       	call   5e0d <rlc_mac_main+0x1fcd>
    5e11:	e9 1f fa ff ff       	jmp    5835 <rlc_mac_main+0x19f5>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    5e16:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    5e1a:	e9 ef fe ff ff       	jmp    5d0e <rlc_mac_main+0x1ece>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    5e1f:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    5e23:	e9 3d fd ff ff       	jmp    5b65 <rlc_mac_main+0x1d25>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5e28:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    5e2f:	b9 20 00 00 00       	mov    $0x20,%ecx
    5e34:	83 c0 01             	add    $0x1,%eax
    5e37:	89 c2                	mov    %eax,%edx
    5e39:	c1 fa 1f             	sar    $0x1f,%edx
    5e3c:	f7 f9                	idiv   %ecx
    5e3e:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5e45:	eb 1a                	jmp    5e61 <rlc_mac_main+0x2021>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5e47:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    5e4e:	7f 22                	jg     5e72 <rlc_mac_main+0x2032>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5e50:	8d 42 01             	lea    0x1(%edx),%eax
    5e53:	89 c2                	mov    %eax,%edx
    5e55:	c1 fa 1f             	sar    $0x1f,%edx
    5e58:	f7 f9                	idiv   %ecx
    5e5a:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5e61:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5e68:	0f bf d0             	movswl %ax,%edx
    5e6b:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    5e70:	75 d5                	jne    5e47 <rlc_mac_main+0x2007>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5e72:	8d 53 18             	lea    0x18(%ebx),%edx
    5e75:	89 d8                	mov    %ebx,%eax
    5e77:	e8 fc ff ff ff       	call   5e78 <rlc_mac_main+0x2038>
    5e7c:	e9 1c fc ff ff       	jmp    5a9d <rlc_mac_main+0x1c5d>
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
    5e81:	c7 04 24 ec 16 00 00 	movl   $0x16ec,(%esp)
    5e88:	e8 fc ff ff ff       	call   5e89 <rlc_mac_main+0x2049>
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
    5e8d:	83 bb ec 01 00 00 00 	cmpl   $0x0,0x1ec(%ebx)
    5e94:	74 0a                	je     5ea0 <rlc_mac_main+0x2060>
    5e96:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5e9a:	0f 85 b6 00 00 00    	jne    5f56 <rlc_mac_main+0x2116>
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
					SV(ratype.ra_type)=2;
				}
				else//
				{
					tmpdata_ptr = (char *)fsm_data_get();
    5ea0:	e8 fc ff ff ff       	call   5ea1 <rlc_mac_main+0x2061>
					fsm_data_destroy((void *)tmpdata_ptr);//
    5ea5:	e8 fc ff ff ff       	call   5ea6 <rlc_mac_main+0x2066>
    5eaa:	e9 b9 e3 ff ff       	jmp    4268 <rlc_mac_main+0x428>
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5eaf:	b8 cc 11 00 00       	mov    $0x11cc,%eax
    5eb4:	e8 fc ff ff ff       	call   5eb5 <rlc_mac_main+0x2075>
					SV(ratype.ra_type)=3;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5eb9:	ba 02 00 00 00       	mov    $0x2,%edx
    5ebe:	31 c0                	xor    %eax,%eax
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=3;
    5ec0:	c7 87 e8 01 00 00 03 	movl   $0x3,0x1e8(%edi)
    5ec7:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5eca:	e8 fc ff ff ff       	call   5ecb <rlc_mac_main+0x208b>
    5ecf:	e9 31 e1 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    5ed4:	e8 fc ff ff ff       	call   5ed5 <rlc_mac_main+0x2095>
    5ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    5ee0:	e9 36 fa ff ff       	jmp    591b <rlc_mac_main+0x1adb>
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    5ee5:	e8 fc ff ff ff       	call   5ee6 <rlc_mac_main+0x20a6>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    5eea:	b9 01 00 00 00       	mov    $0x1,%ecx
    5eef:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    5ef5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    5ef8:	89 f8                	mov    %edi,%eax
    5efa:	e8 fc ff ff ff       	call   5efb <rlc_mac_main+0x20bb>
		*pdu_type=(*pdu_type)>>6;
    5eff:	0f b6 07             	movzbl (%edi),%eax
    5f02:	c0 f8 06             	sar    $0x6,%al
    5f05:	88 07                	mov    %al,(%edi)
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    5f07:	0f be c0             	movsbl %al,%eax
    5f0a:	89 44 24 04          	mov    %eax,0x4(%esp)
    5f0e:	c7 04 24 bc 14 00 00 	movl   $0x14bc,(%esp)
    5f15:	e8 fc ff ff ff       	call   5f16 <rlc_mac_main+0x20d6>
		if(SV(sendmsg3)==0){
    5f1a:	8b 83 ec 01 00 00    	mov    0x1ec(%ebx),%eax
    5f20:	85 c0                	test   %eax,%eax
    5f22:	0f 85 0e 01 00 00    	jne    6036 <rlc_mac_main+0x21f6>
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    5f28:	0f b6 07             	movzbl (%edi),%eax
    5f2b:	83 e8 01             	sub    $0x1,%eax
    5f2e:	3c 02                	cmp    $0x2,%al
				decomplexUeRARPdu(skb);
    5f30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if(SV(sendmsg3)==0){
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    5f33:	0f 87 dd 00 00 00    	ja     6016 <rlc_mac_main+0x21d6>
				decomplexUeRARPdu(skb);
    5f39:	e8 fc ff ff ff       	call   5f3a <rlc_mac_main+0x20fa>
				fsm_mem_free(pdu_type);
    5f3e:	89 f8                	mov    %edi,%eax
    5f40:	e8 fc ff ff ff       	call   5f41 <rlc_mac_main+0x2101>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
    5f45:	c7 04 24 f8 14 00 00 	movl   $0x14f8,(%esp)
    5f4c:	e8 fc ff ff ff       	call   5f4d <rlc_mac_main+0x210d>
    5f51:	e9 12 e3 ff ff       	jmp    4268 <rlc_mac_main+0x428>
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
				{
					tmpdata_ptr = (char *)fsm_data_get();
    5f56:	e8 fc ff ff ff       	call   5f57 <rlc_mac_main+0x2117>
    5f5b:	89 c7                	mov    %eax,%edi
					tmpdata = *((u32*)tmpdata_ptr);//	
					DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5f5d:	8b 17                	mov    (%edi),%edx
    5f5f:	8d 40 04             	lea    0x4(%eax),%eax
    5f62:	e8 fc ff ff ff       	call   5f63 <rlc_mac_main+0x2123>
    5f67:	e8 fc ff ff ff       	call   5f68 <rlc_mac_main+0x2128>
					//tmpdata_ptr+sizeof(int)//4 
					fsm_data_destroy((void *)tmpdata_ptr);//
    5f6c:	89 f8                	mov    %edi,%eax
    5f6e:	e8 fc ff ff ff       	call   5f6f <rlc_mac_main+0x212f>
					if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5f73:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    5f7a:	74 05                	je     5f81 <rlc_mac_main+0x2141>
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    5f7c:	e8 fc ff ff ff       	call   5f7d <rlc_mac_main+0x213d>
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    5f81:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
					//cra_success();//
					//IOCTL

					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    5f87:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
    5f8b:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    5f8f:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    5f96:	85 c0                	test   %eax,%eax
					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
    5f98:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    5f9f:	00 00 00 
					if(SV(msg3_buf_ptr) != NULL)
    5fa2:	74 0f                	je     5fb3 <rlc_mac_main+0x2173>
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    5fa4:	e8 fc ff ff ff       	call   5fa5 <rlc_mac_main+0x2165>
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    5fa9:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    5fb0:	00 00 00 
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
					if(SV(CRTimer.flag)==true) //CR
    5fb3:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
					if(SV(msg3_buf_ptr) != NULL)
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
    5fba:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
					if(SV(CRTimer.flag)==true) //CR
    5fc0:	74 1b                	je     5fdd <rlc_mac_main+0x219d>
					{
						SV(CRTimer.timer_sign)= NULL;
    5fc2:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    5fc9:	00 00 00 
						SV(CRTimer.flag)= false;
    5fcc:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
						SV(CRTimer.time_value)=0;
    5fd3:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    5fda:	00 00 00 
					}
					SV(sendmsg3)=0;//MSG30
    5fdd:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    5fe4:	00 00 00 
					//SV(ratype.ra_type)=0;//0 
					SV(pdcch_rnti)=0;
    5fe7:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    5fee:	00 00 00 
					/*************/
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
    5ff1:	e8 1a d1 ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
					SV(ratype.ra_type)=2;
    5ff6:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    5ffd:	00 00 00 
    6000:	e9 63 e2 ff ff       	jmp    4268 <rlc_mac_main+0x428>
		//print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    6005:	c7 04 24 fc 11 00 00 	movl   $0x11fc,(%esp)
    600c:	e8 fc ff ff ff       	call   600d <rlc_mac_main+0x21cd>
    6011:	e9 94 e0 ff ff       	jmp    40aa <rlc_mac_main+0x26a>
				decomplexUeRARPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    6016:	e8 fc ff ff ff       	call   6017 <rlc_mac_main+0x21d7>
				fsm_mem_free(pdu_type);
    601b:	89 f8                	mov    %edi,%eax
    601d:	8d 76 00             	lea    0x0(%esi),%esi
    6020:	e8 fc ff ff ff       	call   6021 <rlc_mac_main+0x21e1>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
    6025:	c7 04 24 3c 15 00 00 	movl   $0x153c,(%esp)
    602c:	e8 fc ff ff ff       	call   602d <rlc_mac_main+0x21ed>
    6031:	e9 32 e2 ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
    6036:	83 e8 01             	sub    $0x1,%eax
    6039:	0f 85 29 e2 ff ff    	jne    4268 <rlc_mac_main+0x428>
			if( (*pdu_type) == 0){  
    603f:	80 3f 00             	cmpb   $0x0,(%edi)
				decomplexUeDataPdu(skb);
    6042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
			if( (*pdu_type) == 0){  
    6045:	0f 85 2d 01 00 00    	jne    6178 <rlc_mac_main+0x2338>
				decomplexUeDataPdu(skb);
    604b:	e8 fc ff ff ff       	call   604c <rlc_mac_main+0x220c>
				fsm_mem_free(pdu_type);
    6050:	89 f8                	mov    %edi,%eax
    6052:	e8 fc ff ff ff       	call   6053 <rlc_mac_main+0x2213>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
    6057:	c7 04 24 90 15 00 00 	movl   $0x1590,(%esp)
    605e:	e8 fc ff ff ff       	call   605f <rlc_mac_main+0x221f>
    6063:	e9 00 e2 ff ff       	jmp    4268 <rlc_mac_main+0x428>
		}
		reports_handler();//BSR PHR 
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    6068:	c7 04 24 fc 11 00 00 	movl   $0x11fc,(%esp)
    606f:	e8 fc ff ff ff       	call   6070 <rlc_mac_main+0x2230>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    6074:	e9 97 df ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    6079:	83 86 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%esi)
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
    6080:	c7 04 24 00 1b 00 00 	movl   $0x1b00,(%esp)
    6087:	e8 fc ff ff ff       	call   6088 <rlc_mac_main+0x2248>
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    608c:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    6092:	c7 04 24 b8 1a 00 00 	movl   $0x1ab8,(%esp)
    6099:	89 44 24 04          	mov    %eax,0x4(%esp)
    609d:	e8 fc ff ff ff       	call   609e <rlc_mac_main+0x225e>
    60a2:	e9 50 e4 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    60a7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    60aa:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    60ae:	c7 04 24 c0 19 00 00 	movl   $0x19c0,(%esp)
    60b5:	89 44 24 04          	mov    %eax,0x4(%esp)
    60b9:	e8 fc ff ff ff       	call   60ba <rlc_mac_main+0x227a>
    60be:	e9 34 e4 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    60c3:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    60c7:	c7 04 24 f4 18 00 00 	movl   $0x18f4,(%esp)
    60ce:	89 44 24 04          	mov    %eax,0x4(%esp)
    60d2:	e8 fc ff ff ff       	call   60d3 <rlc_mac_main+0x2293>
    60d7:	e9 1b e4 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    60dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    60df:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    60e3:	c7 04 24 b4 18 00 00 	movl   $0x18b4,(%esp)
    60ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    60ee:	e8 fc ff ff ff       	call   60ef <rlc_mac_main+0x22af>
    60f3:	e9 ff e3 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
			break;

		case UM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    60f8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    60fb:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
    60ff:	c7 04 24 c0 19 00 00 	movl   $0x19c0,(%esp)
    6106:	89 44 24 04          	mov    %eax,0x4(%esp)
    610a:	e8 fc ff ff ff       	call   610b <rlc_mac_main+0x22cb>
    610f:	e9 e3 e3 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
	}

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		//print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
		SV(countRecvFromLower)++;
    6114:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
		skb=fsm_pkt_get();
    611b:	e8 fc ff ff ff       	call   611c <rlc_mac_main+0x22dc>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    6120:	b9 01 00 00 00       	mov    $0x1,%ecx
    6125:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		//print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
		SV(countRecvFromLower)++;
		skb=fsm_pkt_get();
    612b:	89 c3                	mov    %eax,%ebx
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    612d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6130:	e8 fc ff ff ff       	call   6131 <rlc_mac_main+0x22f1>
		*pdu_type=(*pdu_type)>>6;
    6135:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6138:	0f b6 02             	movzbl (%edx),%eax
    613b:	c0 f8 06             	sar    $0x6,%al
    613e:	88 02                	mov    %al,(%edx)
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    6140:	0f be c0             	movsbl %al,%eax
    6143:	89 44 24 04          	mov    %eax,0x4(%esp)
    6147:	c7 04 24 a4 1b 00 00 	movl   $0x1ba4,(%esp)
    614e:	e8 fc ff ff ff       	call   614f <rlc_mac_main+0x230f>
		if( (*pdu_type) > 0){
    6153:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6156:	80 38 00             	cmpb   $0x0,(%eax)
			fsm_pkt_destroy(skb);
    6159:	89 d8                	mov    %ebx,%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
    615b:	7f 39                	jg     6196 <rlc_mac_main+0x2356>
			fsm_pkt_destroy(skb);
			fsm_mem_free(pdu_type);
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			FOUT;
		}
		decomplexUeDataPdu(skb);
    615d:	e8 fc ff ff ff       	call   615e <rlc_mac_main+0x231e>
    6162:	e9 43 df ff ff       	jmp    40aa <rlc_mac_main+0x26a>
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
    6167:	c7 04 24 80 1c 00 00 	movl   $0x1c80,(%esp)
    616e:	e8 fc ff ff ff       	call   616f <rlc_mac_main+0x232f>
    6173:	e9 40 df ff ff       	jmp    40b8 <rlc_mac_main+0x278>
				decomplexUeDataPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    6178:	e8 fc ff ff ff       	call   6179 <rlc_mac_main+0x2339>
				fsm_mem_free(pdu_type);
    617d:	89 f8                	mov    %edi,%eax
    617f:	90                   	nop
    6180:	e8 fc ff ff ff       	call   6181 <rlc_mac_main+0x2341>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a other PDU !!!\n");
    6185:	c7 04 24 dc 15 00 00 	movl   $0x15dc,(%esp)
    618c:	e8 fc ff ff ff       	call   618d <rlc_mac_main+0x234d>
    6191:	e9 d2 e0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
			fsm_pkt_destroy(skb);
    6196:	e8 fc ff ff ff       	call   6197 <rlc_mac_main+0x2357>
			fsm_mem_free(pdu_type);
    619b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    619e:	66 90                	xchg   %ax,%ax
    61a0:	e8 fc ff ff ff       	call   61a1 <rlc_mac_main+0x2361>
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
    61a5:	c7 04 24 e0 1b 00 00 	movl   $0x1be0,(%esp)
    61ac:	e8 fc ff ff ff       	call   61ad <rlc_mac_main+0x236d>
    61b1:	e9 02 df ff ff       	jmp    40b8 <rlc_mac_main+0x278>
    61b6:	8d 76 00             	lea    0x0(%esi),%esi
    61b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000061c0 <findInsBylcid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsBylcid(u8 lcid, void **up, void**down, RlcMode *mode)
{
    61c0:	55                   	push   %ebp
    61c1:	89 e5                	mov    %esp,%ebp
    61c3:	57                   	push   %edi
    61c4:	56                   	push   %esi
    61c5:	53                   	push   %ebx
    61c6:	83 ec 10             	sub    $0x10,%esp
    61c9:	e8 fc ff ff ff       	call   61ca <findInsBylcid+0xa>
    61ce:	8b 75 08             	mov    0x8(%ebp),%esi
    61d1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    61d4:	89 c3                	mov    %eax,%ebx
    61d6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsBylcid());
	SV_PTR_GET(rlc_mac_sv);
    61d9:	e8 fc ff ff ff       	call   61da <findInsBylcid+0x1a>
	*up = *down = NULL;
    61de:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    61e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61e4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    61ea:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    61f0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    61f6:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    61fc:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    6202:	39 d1                	cmp    %edx,%ecx
    6204:	74 29                	je     622f <findInsBylcid+0x6f>
    6206:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6209:	8b 7d ec             	mov    -0x14(%ebp),%edi
    620c:	eb 08                	jmp    6216 <findInsBylcid+0x56>
    620e:	66 90                	xchg   %ax,%ax
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6210:	8b 12                	mov    (%edx),%edx
    6212:	39 d1                	cmp    %edx,%ecx
    6214:	74 16                	je     622c <findInsBylcid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->lcId == lcid)
    6216:	38 5a e7             	cmp    %bl,-0x19(%edx)
    6219:	75 f5                	jne    6210 <findInsBylcid+0x50>
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    621b:	8d 42 e4             	lea    -0x1c(%edx),%eax
			if(tmTxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    621e:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    6224:	89 07                	mov    %eax,(%edi)
	SV_PTR_GET(rlc_mac_sv);
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6226:	8b 12                	mov    (%edx),%edx
    6228:	39 d1                	cmp    %edx,%ecx
    622a:	75 ea                	jne    6216 <findInsBylcid+0x56>
    622c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    622f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up =  (void*)tmTxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    6235:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    623b:	39 d1                	cmp    %edx,%ecx
    623d:	74 28                	je     6267 <findInsBylcid+0xa7>
    623f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6242:	8b 7d e8             	mov    -0x18(%ebp),%edi
    6245:	eb 07                	jmp    624e <findInsBylcid+0x8e>
    6247:	90                   	nop
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    6248:	8b 12                	mov    (%edx),%edx
    624a:	39 d1                	cmp    %edx,%ecx
    624c:	74 16                	je     6264 <findInsBylcid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->lcId == lcid)
    624e:	38 5a fb             	cmp    %bl,-0x5(%edx)
    6251:	75 f5                	jne    6248 <findInsBylcid+0x88>
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    6253:	8d 42 f8             	lea    -0x8(%edx),%eax
			if(tmRxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    6256:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    625c:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    625e:	8b 12                	mov    (%edx),%edx
    6260:	39 d1                	cmp    %edx,%ecx
    6262:	75 ea                	jne    624e <findInsBylcid+0x8e>
    6264:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down =  (void*)tmRxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if(*mode == TM_MODE)
    6267:	83 3e 01             	cmpl   $0x1,(%esi)
    626a:	0f 84 c8 00 00 00    	je     6338 <findInsBylcid+0x178>
    6270:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    6276:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    627c:	39 d1                	cmp    %edx,%ecx
    627e:	74 27                	je     62a7 <findInsBylcid+0xe7>
    6280:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6283:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6286:	eb 06                	jmp    628e <findInsBylcid+0xce>
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    6288:	8b 12                	mov    (%edx),%edx
    628a:	39 d1                	cmp    %edx,%ecx
    628c:	74 16                	je     62a4 <findInsBylcid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->lcid == lcid)
    628e:	38 5a d3             	cmp    %bl,-0x2d(%edx)
    6291:	75 f5                	jne    6288 <findInsBylcid+0xc8>
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    6293:	8d 42 d0             	lea    -0x30(%edx),%eax
			if(umTxIns->lcid == lcid)
			{
				*mode = UM_MODE;
    6296:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    629c:	89 07                	mov    %eax,(%edi)
	}
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    629e:	8b 12                	mov    (%edx),%edx
    62a0:	39 d1                	cmp    %edx,%ecx
    62a2:	75 ea                	jne    628e <findInsBylcid+0xce>
    62a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62a7:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*mode = UM_MODE;
				*up =  (void*)umTxIns;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    62ad:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    62b3:	39 d1                	cmp    %edx,%ecx
    62b5:	74 2e                	je     62e5 <findInsBylcid+0x125>
    62b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    62ba:	8b 7d e8             	mov    -0x18(%ebp),%edi
    62bd:	eb 07                	jmp    62c6 <findInsBylcid+0x106>
    62bf:	90                   	nop
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    62c0:	8b 12                	mov    (%edx),%edx
    62c2:	39 d1                	cmp    %edx,%ecx
    62c4:	74 1c                	je     62e2 <findInsBylcid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->lcId == lcid)
    62c6:	38 9a 3f ef ff ff    	cmp    %bl,-0x10c1(%edx)
    62cc:	75 f2                	jne    62c0 <findInsBylcid+0x100>
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    62ce:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
			if(umRxIns->lcId == lcid)
			{
				*mode = UM_MODE;
    62d4:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    62da:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    62dc:	8b 12                	mov    (%edx),%edx
    62de:	39 d1                	cmp    %edx,%ecx
    62e0:	75 e4                	jne    62c6 <findInsBylcid+0x106>
    62e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*mode = UM_MODE;
				*down =  (void*)umRxIns;
			}
		}
	}
	if(*mode == UM_MODE)
    62e5:	83 3e 02             	cmpl   $0x2,(%esi)
    62e8:	74 4e                	je     6338 <findInsBylcid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    62ea:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    62f0:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    62f6:	39 c2                	cmp    %eax,%edx
    62f8:	74 3e                	je     6338 <findInsBylcid+0x178>
    62fa:	8b 7d e8             	mov    -0x18(%ebp),%edi
    62fd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    6300:	eb 0c                	jmp    630e <findInsBylcid+0x14e>
    6302:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    6308:	8b 00                	mov    (%eax),%eax
    630a:	39 c2                	cmp    %eax,%edx
    630c:	74 2a                	je     6338 <findInsBylcid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->lcId == lcid)
    630e:	38 98 ff dc ff ff    	cmp    %bl,-0x2301(%eax)
    6314:	75 f2                	jne    6308 <findInsBylcid+0x148>
			{
				*mode = AM_MODE;
    6316:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    6319:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->lcId == lcid)
			{
				*mode = AM_MODE;
    631f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    6325:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6328:	89 0f                	mov    %ecx,(%edi)
    632a:	89 0e                	mov    %ecx,(%esi)
	}
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    632c:	8b 00                	mov    (%eax),%eax
    632e:	39 c2                	cmp    %eax,%edx
    6330:	75 dc                	jne    630e <findInsBylcid+0x14e>
    6332:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				//      fsm_printf("am instance(lcid is %d)\n",lcid);
			}
		}
	}
	FOUT;
}
    6338:	83 c4 10             	add    $0x10,%esp
    633b:	5b                   	pop    %ebx
    633c:	5e                   	pop    %esi
    633d:	5f                   	pop    %edi
    633e:	5d                   	pop    %ebp
    633f:	c3                   	ret    

00006340 <isInsideTranWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideTranWin(struct AM_Instance *amIns, SequenceNumber SN)
{
    6340:	55                   	push   %ebp
    6341:	89 e5                	mov    %esp,%ebp
    6343:	53                   	push   %ebx
    6344:	e8 fc ff ff ff       	call   6345 <isInsideTranWin+0x5>
	//printk("[RLC][isInsideTranWin] vt_a=%d, vt_ms=%d, SN=%d\n",amIns->vt_a, amIns->vt_ms, SN);
	//return((amIns->vt_a <= SN)&&(SN < amIns->vt_ms));
	return (SN-amIns->vt_a+1024)%1024 < (amIns->vt_ms-amIns->vt_a+1024)%1024;
    6349:	0f bf 98 66 12 00 00 	movswl 0x1266(%eax),%ebx
    6350:	0f bf 80 68 12 00 00 	movswl 0x1268(%eax),%eax
    6357:	0f bf d2             	movswl %dx,%edx
    635a:	29 da                	sub    %ebx,%edx
    635c:	81 c2 00 04 00 00    	add    $0x400,%edx
    6362:	29 d8                	sub    %ebx,%eax
    6364:	89 d1                	mov    %edx,%ecx
    6366:	05 00 04 00 00       	add    $0x400,%eax
    636b:	c1 f9 1f             	sar    $0x1f,%ecx
    636e:	c1 e9 16             	shr    $0x16,%ecx
    6371:	01 ca                	add    %ecx,%edx
    6373:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6379:	29 ca                	sub    %ecx,%edx
    637b:	89 c1                	mov    %eax,%ecx
    637d:	c1 f9 1f             	sar    $0x1f,%ecx
    6380:	c1 e9 16             	shr    $0x16,%ecx
    6383:	01 c8                	add    %ecx,%eax
    6385:	25 ff 03 00 00       	and    $0x3ff,%eax
    638a:	29 c8                	sub    %ecx,%eax
    638c:	39 c2                	cmp    %eax,%edx
    638e:	0f 9c c0             	setl   %al
}
    6391:	5b                   	pop    %ebx
    6392:	5d                   	pop    %ebp
    6393:	c3                   	ret    
    6394:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    639a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000063a0 <isInsideAmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    63a0:	55                   	push   %ebp
    63a1:	89 e5                	mov    %esp,%ebp
    63a3:	56                   	push   %esi
    63a4:	53                   	push   %ebx
    63a5:	83 ec 14             	sub    $0x14,%esp
    63a8:	e8 fc ff ff ff       	call   63a9 <isInsideAmRecvWin+0x9>
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    63ad:	0f bf 88 ec 22 00 00 	movswl 0x22ec(%eax),%ecx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    63b4:	89 c3                	mov    %eax,%ebx
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    63b6:	0f bf 80 f4 22 00 00 	movswl 0x22f4(%eax),%eax
    63bd:	0f bf f2             	movswl %dx,%esi
    63c0:	89 ca                	mov    %ecx,%edx
    63c2:	89 74 24 0c          	mov    %esi,0xc(%esp)
    63c6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    63ca:	29 c2                	sub    %eax,%edx
    63cc:	89 54 24 10          	mov    %edx,0x10(%esp)
    63d0:	89 44 24 04          	mov    %eax,0x4(%esp)
    63d4:	c7 04 24 b8 1c 00 00 	movl   $0x1cb8,(%esp)
    63db:	e8 fc ff ff ff       	call   63dc <isInsideAmRecvWin+0x3c>
	return (SN-amIns->vr_r+1024)%1024 < (amIns->vr_mr-amIns->vr_r+1024)%1024;
    63e0:	0f bf 93 f4 22 00 00 	movswl 0x22f4(%ebx),%edx
    63e7:	29 d6                	sub    %edx,%esi
    63e9:	81 c6 00 04 00 00    	add    $0x400,%esi
    63ef:	89 f0                	mov    %esi,%eax
    63f1:	c1 f8 1f             	sar    $0x1f,%eax
    63f4:	c1 e8 16             	shr    $0x16,%eax
    63f7:	01 c6                	add    %eax,%esi
    63f9:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    63ff:	29 c6                	sub    %eax,%esi
    6401:	0f bf 83 ec 22 00 00 	movswl 0x22ec(%ebx),%eax
    6408:	29 d0                	sub    %edx,%eax
    640a:	05 00 04 00 00       	add    $0x400,%eax
    640f:	89 c2                	mov    %eax,%edx
    6411:	c1 fa 1f             	sar    $0x1f,%edx
    6414:	c1 ea 16             	shr    $0x16,%edx
    6417:	01 d0                	add    %edx,%eax
    6419:	25 ff 03 00 00       	and    $0x3ff,%eax
    641e:	29 d0                	sub    %edx,%eax
    6420:	39 c6                	cmp    %eax,%esi
    6422:	0f 9c c0             	setl   %al
}
    6425:	83 c4 14             	add    $0x14,%esp
    6428:	5b                   	pop    %ebx
    6429:	5e                   	pop    %esi
    642a:	5d                   	pop    %ebp
    642b:	c3                   	ret    
    642c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006430 <isInsideUmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6430:	55                   	push   %ebp
    6431:	89 e5                	mov    %esp,%ebp
    6433:	e8 fc ff ff ff       	call   6434 <isInsideUmRecvWin+0x4>
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6438:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    643d:	0f bf 80 c0 10 00 00 	movswl 0x10c0(%eax),%eax
    6444:	0f bf d2             	movswl %dx,%edx
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6447:	74 27                	je     6470 <isInsideUmRecvWin+0x40>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    6449:	29 c2                	sub    %eax,%edx
    644b:	81 c2 00 06 00 00    	add    $0x600,%edx
    6451:	89 d0                	mov    %edx,%eax
    6453:	c1 f8 1f             	sar    $0x1f,%eax
    6456:	c1 e8 16             	shr    $0x16,%eax
    6459:	01 c2                	add    %eax,%edx
    645b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6461:	29 c2                	sub    %eax,%edx
    6463:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    6469:	0f 9e c0             	setle  %al
	}
}
    646c:	5d                   	pop    %ebp
    646d:	c3                   	ret    
    646e:	66 90                	xchg   %ax,%ax
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    6470:	29 c2                	sub    %eax,%edx
    6472:	83 c2 30             	add    $0x30,%edx
    6475:	89 d0                	mov    %edx,%eax
    6477:	c1 f8 1f             	sar    $0x1f,%eax
    647a:	c1 e8 1b             	shr    $0x1b,%eax
    647d:	01 c2                	add    %eax,%edx
    647f:	83 e2 1f             	and    $0x1f,%edx
    6482:	29 c2                	sub    %eax,%edx
    6484:	83 fa 0f             	cmp    $0xf,%edx
    6487:	0f 9e c0             	setle  %al
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
	}
}
    648a:	5d                   	pop    %ebp
    648b:	c3                   	ret    
    648c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006490 <isOrderedUm>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isOrderedUm(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6490:	55                   	push   %ebp
    6491:	89 e5                	mov    %esp,%ebp
    6493:	53                   	push   %ebx
    6494:	e8 fc ff ff ff       	call   6495 <isOrderedUm+0x5>
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6499:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    649e:	0f bf 98 c0 10 00 00 	movswl 0x10c0(%eax),%ebx
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    64a5:	74 51                	je     64f8 <isOrderedUm+0x68>
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
	}
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
    64a7:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    64ae:	b9 00 02 00 00       	mov    $0x200,%ecx
    64b3:	0f bf d2             	movswl %dx,%edx
    64b6:	29 d9                	sub    %ebx,%ecx
    64b8:	8d 94 11 00 04 00 00 	lea    0x400(%ecx,%edx,1),%edx
    64bf:	89 d3                	mov    %edx,%ebx
    64c1:	8d 84 01 00 04 00 00 	lea    0x400(%ecx,%eax,1),%eax
    64c8:	89 c1                	mov    %eax,%ecx
    64ca:	c1 fb 1f             	sar    $0x1f,%ebx
    64cd:	c1 f9 1f             	sar    $0x1f,%ecx
    64d0:	c1 eb 16             	shr    $0x16,%ebx
    64d3:	c1 e9 16             	shr    $0x16,%ecx
    64d6:	01 da                	add    %ebx,%edx
    64d8:	01 c8                	add    %ecx,%eax
    64da:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    64e0:	25 ff 03 00 00       	and    $0x3ff,%eax
    64e5:	29 da                	sub    %ebx,%edx
    64e7:	29 c8                	sub    %ecx,%eax
    64e9:	39 c2                	cmp    %eax,%edx
    64eb:	0f 9c c0             	setl   %al
	}
}
    64ee:	5b                   	pop    %ebx
    64ef:	5d                   	pop    %ebp
    64f0:	c3                   	ret    
    64f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    64f8:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    64ff:	b9 10 00 00 00       	mov    $0x10,%ecx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6504:	0f bf d2             	movswl %dx,%edx
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    6507:	29 d9                	sub    %ebx,%ecx
    6509:	8d 54 11 20          	lea    0x20(%ecx,%edx,1),%edx
    650d:	89 d3                	mov    %edx,%ebx
    650f:	8d 44 01 20          	lea    0x20(%ecx,%eax,1),%eax
    6513:	89 c1                	mov    %eax,%ecx
    6515:	c1 fb 1f             	sar    $0x1f,%ebx
    6518:	c1 f9 1f             	sar    $0x1f,%ecx
    651b:	c1 eb 1b             	shr    $0x1b,%ebx
    651e:	c1 e9 1b             	shr    $0x1b,%ecx
    6521:	01 da                	add    %ebx,%edx
    6523:	01 c8                	add    %ecx,%eax
    6525:	83 e2 1f             	and    $0x1f,%edx
    6528:	83 e0 1f             	and    $0x1f,%eax
    652b:	29 da                	sub    %ebx,%edx
    652d:	29 c8                	sub    %ecx,%eax
    652f:	39 c2                	cmp    %eax,%edx
    6531:	0f 9c c0             	setl   %al
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
	}
}
    6534:	5b                   	pop    %ebx
    6535:	5d                   	pop    %ebp
    6536:	c3                   	ret    
    6537:	89 f6                	mov    %esi,%esi
    6539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00006540 <countSegInd>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
    6540:	55                   	push   %ebp
    6541:	89 e5                	mov    %esp,%ebp
    6543:	e8 fc ff ff ff       	call   6544 <countSegInd+0x4>
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6548:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    654e:	31 c0                	xor    %eax,%eax
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    6550:	f6 42 01 04          	testb  $0x4,0x1(%edx)
    6554:	74 20                	je     6576 <countSegInd+0x36>
	{
		count++;
		while(1 == (ind++)->E)
    6556:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    655a:	b0 01                	mov    $0x1,%al
    655c:	79 18                	jns    6576 <countSegInd+0x36>
    655e:	83 c2 06             	add    $0x6,%edx
    6561:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    6568:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
		{
			count++;
    656c:	83 c0 01             	add    $0x1,%eax
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    656f:	83 c2 02             	add    $0x2,%edx
    6572:	84 c9                	test   %cl,%cl
    6574:	78 f2                	js     6568 <countSegInd+0x28>
		{
			count++;
		}
	}
	return count;
}
    6576:	5d                   	pop    %ebp
    6577:	c3                   	ret    
    6578:	90                   	nop
    6579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006580 <assamble_segment>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6580:	55                   	push   %ebp
    6581:	89 e5                	mov    %esp,%ebp
    6583:	57                   	push   %edi
    6584:	56                   	push   %esi
    6585:	53                   	push   %ebx
    6586:	83 ec 20             	sub    $0x20,%esp
    6589:	e8 fc ff ff ff       	call   658a <assamble_segment+0xa>
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    658e:	8b 9a ac 00 00 00    	mov    0xac(%edx),%ebx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6594:	89 c6                	mov    %eax,%esi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6596:	8b 00                	mov    (%eax),%eax
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6598:	89 55 ec             	mov    %edx,-0x14(%ebp)
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    659b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    659e:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    65a5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    65ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    65ae:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    65b2:	74 34                	je     65e8 <assamble_segment+0x68>
	{
		count++;
		while(1 == (ind++)->E)
    65b4:	c7 45 e8 06 00 00 00 	movl   $0x6,-0x18(%ebp)
    65bb:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    65bf:	79 27                	jns    65e8 <assamble_segment+0x68>
    65c1:	83 c0 06             	add    $0x6,%eax
    65c4:	ba 01 00 00 00       	mov    $0x1,%edx
    65c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    65d0:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    65d4:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    65d7:	83 c0 02             	add    $0x2,%eax
    65da:	84 c9                	test   %cl,%cl
    65dc:	78 f2                	js     65d0 <assamble_segment+0x50>
    65de:	8d 54 12 04          	lea    0x4(%edx,%edx,1),%edx
    65e2:	0f b7 d2             	movzwl %dx,%edx
    65e5:	89 55 e8             	mov    %edx,-0x18(%ebp)
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    65e8:	8b 7d f0             	mov    -0x10(%ebp),%edi
	u32 posEnd = posStart + pkt->len - headLen;
    65eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    65ee:	0f b6 5f 03          	movzbl 0x3(%edi),%ebx
    65f2:	0f b6 47 02          	movzbl 0x2(%edi),%eax
	u32 posEnd = posStart + pkt->len - headLen;
    65f6:	8b 4a 50             	mov    0x50(%edx),%ecx
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    65f9:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    65ff:	83 e3 7f             	and    $0x7f,%ebx
    6602:	c1 e3 08             	shl    $0x8,%ebx
    6605:	09 c3                	or     %eax,%ebx
	u32 posEnd = posStart + pkt->len - headLen;
    6607:	8d 3c 0b             	lea    (%ebx,%ecx,1),%edi
    660a:	89 7d e0             	mov    %edi,-0x20(%ebp)
    660d:	2b 7d e8             	sub    -0x18(%ebp),%edi
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6610:	85 d2                	test   %edx,%edx
    6612:	74 1b                	je     662f <assamble_segment+0xaf>
    6614:	31 c0                	xor    %eax,%eax
    6616:	66 90                	xchg   %ax,%ax
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
    6618:	3b 5c 86 10          	cmp    0x10(%esi,%eax,4),%ebx
    661c:	72 0a                	jb     6628 <assamble_segment+0xa8>
    661e:	3b 7c 86 50          	cmp    0x50(%esi,%eax,4),%edi
    6622:	0f 86 50 01 00 00    	jbe    6778 <assamble_segment+0x1f8>
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6628:	83 c0 01             	add    $0x1,%eax
    662b:	39 d0                	cmp    %edx,%eax
    662d:	75 e9                	jne    6618 <assamble_segment+0x98>
	char *posbuf = (char*)ambuf->pkt->data;
	int i, j,datalen = 0;
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
    662f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6632:	03 45 e8             	add    -0x18(%ebp),%eax
    6635:	89 45 d8             	mov    %eax,-0x28(%ebp)
	}
	//fsm_printf("[RLC][assamble_segment] ambuf->datalen is %d\n",ambuf->datalen);
	//fsm_printf("[RLC][assamble_segment] ambuf->segEnd[ambuf->segnum - 1] is %d\n",ambuf->segEnd[ambuf->segnum - 1]);
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
    6638:	8d 42 ff             	lea    -0x1(%edx),%eax
    663b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    663e:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6642:	39 c7                	cmp    %eax,%edi
    6644:	0f 82 3e 01 00 00    	jb     6788 <assamble_segment+0x208>
	//
	else
	{
		//fsm_printf("[RLC][assamble_segment] have not received the last segment\n");
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
    664a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    664d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6651:	78 6d                	js     66c0 <assamble_segment+0x140>
    6653:	39 c7                	cmp    %eax,%edi
    6655:	77 69                	ja     66c0 <assamble_segment+0x140>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
		ambuf->datalen = datalen;
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6657:	39 c3                	cmp    %eax,%ebx
    6659:	0f 87 f9 00 00 00    	ja     6758 <assamble_segment+0x1d8>
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    665f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6662:	85 d2                	test   %edx,%edx
    6664:	7e 3b                	jle    66a1 <assamble_segment+0x121>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6666:	8d 44 96 10          	lea    0x10(%esi,%edx,4),%eax
    666a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
			{
				//10:
				if((ambuf->segStart[i] <= posStart)&&(posStart <= ambuf->segEnd[i]))
    6670:	8b 08                	mov    (%eax),%ecx
    6672:	39 cb                	cmp    %ecx,%ebx
    6674:	72 09                	jb     667f <assamble_segment+0xff>
    6676:	3b 58 40             	cmp    0x40(%eax),%ebx
    6679:	0f 86 5f 02 00 00    	jbe    68de <assamble_segment+0x35e>
					ambuf->segEnd[i] = posEnd;
					ambuf->segnum = i + 1;
					FOUT;
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
    667f:	3b 58 3c             	cmp    0x3c(%eax),%ebx
    6682:	76 08                	jbe    668c <assamble_segment+0x10c>
    6684:	39 cb                	cmp    %ecx,%ebx
    6686:	0f 86 4e 02 00 00    	jbe    68da <assamble_segment+0x35a>
					ambuf->segnum = i + 1;
					FOUT;
				}
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
    668c:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    6693:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    6699:	83 e8 04             	sub    $0x4,%eax
    669c:	83 ea 01             	sub    $0x1,%edx
    669f:	75 cf                	jne    6670 <assamble_segment+0xf0>
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
				}
			}
			if(posStart > ambuf->segStart[0])
    66a1:	3b 5e 10             	cmp    0x10(%esi),%ebx
    66a4:	77 03                	ja     66a9 <assamble_segment+0x129>
				ambuf->segnum = 1;
				FOUT;
			}
            else
            {
	            ambuf->segStart[0]  = posStart;
    66a6:	89 5e 10             	mov    %ebx,0x10(%esi)
	            ambuf->segEnd[0] = posEnd;
    66a9:	89 7e 50             	mov    %edi,0x50(%esi)
	            ambuf->segnum = 1;
    66ac:	c7 86 90 00 00 00 01 	movl   $0x1,0x90(%esi)
    66b3:	00 00 00 
	            FOUT;
			}
		}
	}
}
    66b6:	83 c4 20             	add    $0x20,%esp
    66b9:	5b                   	pop    %ebx
    66ba:	5e                   	pop    %esi
    66bb:	5f                   	pop    %edi
    66bc:	5d                   	pop    %ebp
    66bd:	c3                   	ret    
    66be:	66 90                	xchg   %ax,%ax
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
		{
			//pdu
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    66c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    66c3:	e8 fc ff ff ff       	call   66c4 <assamble_segment+0x144>
    66c8:	03 45 e0             	add    -0x20(%ebp),%eax
    66cb:	e8 fc ff ff ff       	call   66cc <assamble_segment+0x14c>
    66d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
    66d3:	8b 06                	mov    (%esi),%eax
    66d5:	8b 48 50             	mov    0x50(%eax),%ecx
    66d8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    66de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    66e1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    66e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    66ea:	e8 fc ff ff ff       	call   66eb <assamble_segment+0x16b>
			fsm_skb_put(pkptr, datalen);
    66ef:	8b 55 e0             	mov    -0x20(%ebp),%edx
    66f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    66f5:	e8 fc ff ff ff       	call   66f6 <assamble_segment+0x176>
			fsm_pkt_destroy(ambuf->pkt);
    66fa:	8b 06                	mov    (%esi),%eax
    66fc:	e8 fc ff ff ff       	call   66fd <assamble_segment+0x17d>
			ambuf->pkt = pkptr;
    6701:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6704:	8b 55 ec             	mov    -0x14(%ebp),%edx
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
    6707:	89 06                	mov    %eax,(%esi)
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    6709:	8b 45 e8             	mov    -0x18(%ebp),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    670c:	8b 4a 50             	mov    0x50(%edx),%ecx
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    670f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6712:	01 d8                	add    %ebx,%eax
    6714:	03 82 ac 00 00 00    	add    0xac(%edx),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    671a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    671d:	e8 fc ff ff ff       	call   671e <assamble_segment+0x19e>
			fsm_pkt_destroy(pkt);
    6722:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6725:	e8 fc ff ff ff       	call   6726 <assamble_segment+0x1a6>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    672a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    672d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6731:	0f 89 bc 01 00 00    	jns    68f3 <assamble_segment+0x373>
		ambuf->datalen = datalen;
    6737:	8b 55 e0             	mov    -0x20(%ebp),%edx
    673a:	89 96 98 00 00 00    	mov    %edx,0x98(%esi)
    6740:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6746:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    674a:	8d 4a ff             	lea    -0x1(%edx),%ecx
    674d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6750:	39 c3                	cmp    %eax,%ebx
    6752:	0f 86 07 ff ff ff    	jbe    665f <assamble_segment+0xdf>
		{
			ambuf->segEnd[ambuf->segnum] = posEnd;
    6758:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
			ambuf->segStart[ambuf->segnum]  = posStart;
    675c:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
			ambuf->segnum++;
    6760:	83 c2 01             	add    $0x1,%edx
    6763:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6769:	83 c4 20             	add    $0x20,%esp
    676c:	5b                   	pop    %ebx
    676d:	5e                   	pop    %esi
    676e:	5f                   	pop    %edi
    676f:	5d                   	pop    %ebp
    6770:	c3                   	ret    
    6771:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
		{
			//fsm_printf("[RLC][assamble_segment] this segment has been received\n");
			fsm_pkt_destroy(pkt);
    6778:	8b 45 ec             	mov    -0x14(%ebp),%eax
    677b:	e8 fc ff ff ff       	call   677c <assamble_segment+0x1fc>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6780:	83 c4 20             	add    $0x20,%esp
    6783:	5b                   	pop    %ebx
    6784:	5e                   	pop    %esi
    6785:	5f                   	pop    %edi
    6786:	5d                   	pop    %ebp
    6787:	c3                   	ret    
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
    6788:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    678b:	03 45 e8             	add    -0x18(%ebp),%eax
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    678e:	8b 55 d8             	mov    -0x28(%ebp),%edx
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
    6791:	01 d8                	add    %ebx,%eax
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6793:	e8 fc ff ff ff       	call   6794 <assamble_segment+0x214>
		fsm_pkt_destroy(pkt);
    6798:	8b 45 ec             	mov    -0x14(%ebp),%eax
    679b:	e8 fc ff ff ff       	call   679c <assamble_segment+0x21c>
		pkt = NULL;
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
    67a0:	8b 46 10             	mov    0x10(%esi),%eax
    67a3:	85 c0                	test   %eax,%eax
    67a5:	7e 29                	jle    67d0 <assamble_segment+0x250>
    67a7:	3b 7e 14             	cmp    0x14(%esi),%edi
    67aa:	73 24                	jae    67d0 <assamble_segment+0x250>
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    67ac:	39 c3                	cmp    %eax,%ebx
    67ae:	0f 82 54 01 00 00    	jb     6908 <assamble_segment+0x388>
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    67b4:	77 1a                	ja     67d0 <assamble_segment+0x250>
    67b6:	39 c7                	cmp    %eax,%edi
    67b8:	76 16                	jbe    67d0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    67ba:	8b 46 50             	mov    0x50(%esi),%eax
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    67bd:	39 c3                	cmp    %eax,%ebx
    67bf:	90                   	nop
    67c0:	73 0e                	jae    67d0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    67c2:	39 c7                	cmp    %eax,%edi
    67c4:	76 0a                	jbe    67d0 <assamble_segment+0x250>
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
    67c6:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    67c9:	89 7e 50             	mov    %edi,0x50(%esi)
				FOUT;
    67cc:	eb b2                	jmp    6780 <assamble_segment+0x200>
    67ce:	66 90                	xchg   %ax,%ax
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    67d0:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    67d6:	89 ca                	mov    %ecx,%edx
    67d8:	83 ea 01             	sub    $0x1,%edx
    67db:	89 55 dc             	mov    %edx,-0x24(%ebp)
    67de:	74 a0                	je     6780 <assamble_segment+0x200>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				FOUT;
    67e0:	89 75 ec             	mov    %esi,-0x14(%ebp)
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    67e3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    67ea:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    67ed:	89 75 e0             	mov    %esi,-0x20(%ebp)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    67f0:	8b 75 ec             	mov    -0x14(%ebp),%esi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    67f3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    67f6:	8b 46 50             	mov    0x50(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    67f9:	83 eb 01             	sub    $0x1,%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    67fc:	39 45 e8             	cmp    %eax,-0x18(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    67ff:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6802:	76 14                	jbe    6818 <assamble_segment+0x298>
    6804:	8b 56 14             	mov    0x14(%esi),%edx
    6807:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    680a:	73 0c                	jae    6818 <assamble_segment+0x298>
    680c:	39 c7                	cmp    %eax,%edi
    680e:	76 08                	jbe    6818 <assamble_segment+0x298>
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
    6810:	39 d7                	cmp    %edx,%edi
    6812:	0f 82 5d 03 00 00    	jb     6b75 <assamble_segment+0x5f5>
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
    6818:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    681b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    681e:	3b 73 10             	cmp    0x10(%ebx),%esi
    6821:	72 5d                	jb     6880 <assamble_segment+0x300>
    6823:	39 c6                	cmp    %eax,%esi
    6825:	77 5e                	ja     6885 <assamble_segment+0x305>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6827:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    682a:	76 34                	jbe    6860 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    682c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    682f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    6832:	8d 44 93 10          	lea    0x10(%ebx,%edx,4),%eax
    6836:	66 90                	xchg   %ax,%ax
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6838:	8b 18                	mov    (%eax),%ebx
    683a:	39 df                	cmp    %ebx,%edi
    683c:	72 0b                	jb     6849 <assamble_segment+0x2c9>
    683e:	8b 70 40             	mov    0x40(%eax),%esi
    6841:	39 f7                	cmp    %esi,%edi
    6843:	0f 86 09 01 00 00    	jbe    6952 <assamble_segment+0x3d2>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6849:	3b 78 3c             	cmp    0x3c(%eax),%edi
    684c:	72 08                	jb     6856 <assamble_segment+0x2d6>
    684e:	39 df                	cmp    %ebx,%edi
    6850:	0f 82 76 01 00 00    	jb     69cc <assamble_segment+0x44c>
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6856:	83 c2 01             	add    $0x1,%edx
    6859:	83 c0 04             	add    $0x4,%eax
    685c:	39 d1                	cmp    %edx,%ecx
    685e:	77 d8                	ja     6838 <assamble_segment+0x2b8>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6860:	8b 45 f0             	mov    -0x10(%ebp),%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6863:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6866:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
    686a:	83 c0 01             	add    $0x1,%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    686d:	39 55 dc             	cmp    %edx,-0x24(%ebp)
    6870:	0f 86 0a ff ff ff    	jbe    6780 <assamble_segment+0x200>
    6876:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6879:	e9 72 ff ff ff       	jmp    67f0 <assamble_segment+0x270>
    687e:	66 90                	xchg   %ax,%ax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6880:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6883:	72 db                	jb     6860 <assamble_segment+0x2e0>
    6885:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6888:	8b 55 e0             	mov    -0x20(%ebp),%edx
    688b:	83 c0 04             	add    $0x4,%eax
    688e:	8b 1c 82             	mov    (%edx,%eax,4),%ebx
    6891:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
    6894:	89 45 d8             	mov    %eax,-0x28(%ebp)
    6897:	77 c7                	ja     6860 <assamble_segment+0x2e0>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6899:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    689c:	76 c2                	jbe    6860 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    689e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    68a1:	8d 44 b2 14          	lea    0x14(%edx,%esi,4),%eax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    68a5:	89 f2                	mov    %esi,%edx
    68a7:	eb 0c                	jmp    68b5 <assamble_segment+0x335>
    68a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68b0:	8b 18                	mov    (%eax),%ebx
    68b2:	83 c0 04             	add    $0x4,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    68b5:	39 df                	cmp    %ebx,%edi
    68b7:	72 0b                	jb     68c4 <assamble_segment+0x344>
    68b9:	8b 70 3c             	mov    0x3c(%eax),%esi
    68bc:	39 f7                	cmp    %esi,%edi
    68be:	0f 86 08 02 00 00    	jbe    6acc <assamble_segment+0x54c>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    68c4:	3b 78 38             	cmp    0x38(%eax),%edi
    68c7:	72 08                	jb     68d1 <assamble_segment+0x351>
    68c9:	39 df                	cmp    %ebx,%edi
    68cb:	0f 82 73 01 00 00    	jb     6a44 <assamble_segment+0x4c4>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68d1:	83 c2 01             	add    $0x1,%edx
    68d4:	39 d1                	cmp    %edx,%ecx
    68d6:	77 d8                	ja     68b0 <assamble_segment+0x330>
    68d8:	eb 86                	jmp    6860 <assamble_segment+0x2e0>
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
				{
					//fsm_printf("[RLC][assamble_segment] condition 11\n");
					ambuf->segStart[i] = posStart;
    68da:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
					ambuf->segEnd[i] = posEnd;
    68de:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
					ambuf->segnum = i + 1;
    68e2:	83 c2 01             	add    $0x1,%edx
    68e5:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    68eb:	83 c4 20             	add    $0x20,%esp
    68ee:	5b                   	pop    %ebx
    68ef:	5e                   	pop    %esi
    68f0:	5f                   	pop    %edi
    68f1:	5d                   	pop    %ebp
    68f2:	c3                   	ret    
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
			fsm_pkt_destroy(pkt);
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    68f3:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    68f9:	8d 42 ff             	lea    -0x1(%edx),%eax
    68fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    68ff:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6903:	e9 4f fd ff ff       	jmp    6657 <assamble_segment+0xd7>
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    6908:	39 c7                	cmp    %eax,%edi
    690a:	0f 83 4c 02 00 00    	jae    6b5c <assamble_segment+0x5dc>
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6910:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6916:	89 ca                	mov    %ecx,%edx
    6918:	83 ea 01             	sub    $0x1,%edx
    691b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    691e:	78 1b                	js     693b <assamble_segment+0x3bb>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6920:	8d 44 8e 4c          	lea    0x4c(%esi,%ecx,4),%eax
    6924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
    6928:	8b 08                	mov    (%eax),%ecx
    692a:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[i+1] = ambuf->segStart[i];
    692d:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6930:	89 48 c4             	mov    %ecx,-0x3c(%eax)
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6933:	83 e8 04             	sub    $0x4,%eax
    6936:	83 ea 01             	sub    $0x1,%edx
    6939:	79 ed                	jns    6928 <assamble_segment+0x3a8>
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
    693b:	8b 45 f0             	mov    -0x10(%ebp),%eax
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
    693e:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    6941:	89 7e 50             	mov    %edi,0x50(%esi)
				ambuf->segnum++;
    6944:	83 c0 01             	add    $0x1,%eax
    6947:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
				FOUT;
    694d:	e9 2e fe ff ff       	jmp    6780 <assamble_segment+0x200>
    6952:	89 f0                	mov    %esi,%eax
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6954:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6957:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;j++;
    695a:	8d 5a 01             	lea    0x1(%edx),%ebx
						for(; i < ambuf->segnum; j++, i++)
    695d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6960:	89 44 be 50          	mov    %eax,0x50(%esi,%edi,4)
						i++;j++;
    6964:	8b 7d f0             	mov    -0x10(%ebp),%edi
						for(; i < ambuf->segnum; j++, i++)
    6967:	39 f9                	cmp    %edi,%ecx
    6969:	76 4f                	jbe    69ba <assamble_segment+0x43a>
    696b:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6971:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
    6975:	89 75 f0             	mov    %esi,-0x10(%ebp)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6978:	89 45 ec             	mov    %eax,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    697b:	8d 44 be 50          	lea    0x50(%esi,%edi,4),%eax
    697f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6982:	eb 20                	jmp    69a4 <assamble_segment+0x424>
    6984:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6988:	8b 0a                	mov    (%edx),%ecx
    698a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    698c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    698f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6992:	83 c7 01             	add    $0x1,%edi
    6995:	83 c3 01             	add    $0x1,%ebx
    6998:	83 c2 04             	add    $0x4,%edx
    699b:	83 c0 04             	add    $0x4,%eax
    699e:	39 f7                	cmp    %esi,%edi
    69a0:	73 15                	jae    69b7 <assamble_segment+0x437>
    69a2:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    69a4:	39 cb                	cmp    %ecx,%ebx
    69a6:	72 e0                	jb     6988 <assamble_segment+0x408>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    69a8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    69ae:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    69b5:	eb db                	jmp    6992 <assamble_segment+0x412>
    69b7:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    69ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    69bd:	29 df                	sub    %ebx,%edi
    69bf:	01 f8                	add    %edi,%eax
    69c1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    69c7:	e9 b4 fd ff ff       	jmp    6780 <assamble_segment+0x200>
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    69cc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    69cf:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
    69d2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    69d5:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    69d9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						for(; i < ambuf->segnum; j++, i++)
    69dc:	39 d9                	cmp    %ebx,%ecx
    69de:	76 52                	jbe    6a32 <assamble_segment+0x4b2>
    69e0:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69e6:	8d 44 9e 50          	lea    0x50(%esi,%ebx,4),%eax
    69ea:	89 75 f0             	mov    %esi,-0x10(%ebp)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    69ed:	89 7d ec             	mov    %edi,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69f0:	8d 7c 96 50          	lea    0x50(%esi,%edx,4),%edi
    69f4:	8b 75 ec             	mov    -0x14(%ebp),%esi
    69f7:	eb 23                	jmp    6a1c <assamble_segment+0x49c>
    69f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6a00:	8b 0f                	mov    (%edi),%ecx
    6a02:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6a04:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6a07:	89 48 c0             	mov    %ecx,-0x40(%eax)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a0a:	83 c3 01             	add    $0x1,%ebx
    6a0d:	83 c2 01             	add    $0x1,%edx
    6a10:	83 c7 04             	add    $0x4,%edi
    6a13:	83 c0 04             	add    $0x4,%eax
    6a16:	39 de                	cmp    %ebx,%esi
    6a18:	76 15                	jbe    6a2f <assamble_segment+0x4af>
    6a1a:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6a1c:	39 d1                	cmp    %edx,%ecx
    6a1e:	77 e0                	ja     6a00 <assamble_segment+0x480>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6a20:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6a26:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6a2d:	eb db                	jmp    6a0a <assamble_segment+0x48a>
    6a2f:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6a32:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a35:	29 d3                	sub    %edx,%ebx
    6a37:	01 d8                	add    %ebx,%eax
    6a39:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6a3f:	e9 3c fd ff ff       	jmp    6780 <assamble_segment+0x200>
    6a44:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6a47:	8b 75 e0             	mov    -0x20(%ebp),%esi
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
    6a4a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6a4d:	89 1c 86             	mov    %ebx,(%esi,%eax,4)
						ambuf->segEnd[i] = posEnd;
    6a50:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a53:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
    6a56:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6a5a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6a5d:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6a60:	39 d9                	cmp    %ebx,%ecx
    6a62:	76 56                	jbe    6aba <assamble_segment+0x53a>
    6a64:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a6a:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6a6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a71:	89 7d f0             	mov    %edi,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a74:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6a77:	8d 44 be 58          	lea    0x58(%esi,%edi,4),%eax
    6a7b:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6a7e:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6a81:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6a84:	eb 1e                	jmp    6aa4 <assamble_segment+0x524>
    6a86:	66 90                	xchg   %ax,%ax
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6a88:	8b 0f                	mov    (%edi),%ecx
    6a8a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6a8c:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6a8f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a92:	83 c3 01             	add    $0x1,%ebx
    6a95:	83 c2 01             	add    $0x1,%edx
    6a98:	83 c7 04             	add    $0x4,%edi
    6a9b:	83 c0 04             	add    $0x4,%eax
    6a9e:	39 de                	cmp    %ebx,%esi
    6aa0:	76 15                	jbe    6ab7 <assamble_segment+0x537>
    6aa2:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6aa4:	39 ca                	cmp    %ecx,%edx
    6aa6:	72 e0                	jb     6a88 <assamble_segment+0x508>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6aa8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6aae:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6ab5:	eb db                	jmp    6a92 <assamble_segment+0x512>
    6ab7:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6aba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6abd:	29 d3                	sub    %edx,%ebx
    6abf:	01 d8                	add    %ebx,%eax
    6ac1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6ac7:	e9 b4 fc ff ff       	jmp    6780 <assamble_segment+0x200>
    6acc:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6acf:	89 f0                	mov    %esi,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
    6ad1:	8b 7d d8             	mov    -0x28(%ebp),%edi
    6ad4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6ad7:	89 1c be             	mov    %ebx,(%esi,%edi,4)
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6ada:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;j++;
    6add:	8d 7a 01             	lea    0x1(%edx),%edi
						for(; i < ambuf->segnum; j++, i++)
    6ae0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6ae3:	89 44 9e 50          	mov    %eax,0x50(%esi,%ebx,4)
						i++;j++;
    6ae7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6aea:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6aed:	39 d9                	cmp    %ebx,%ecx
    6aef:	76 59                	jbe    6b4a <assamble_segment+0x5ca>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6af1:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6af5:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6afb:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6afe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b01:	89 45 f0             	mov    %eax,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b04:	8d 44 96 58          	lea    0x58(%esi,%edx,4),%eax
    6b08:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6b0b:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6b0e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6b11:	eb 21                	jmp    6b34 <assamble_segment+0x5b4>
    6b13:	90                   	nop
    6b14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6b18:	8b 0a                	mov    (%edx),%ecx
    6b1a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6b1c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6b1f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b22:	83 c3 01             	add    $0x1,%ebx
    6b25:	83 c7 01             	add    $0x1,%edi
    6b28:	83 c2 04             	add    $0x4,%edx
    6b2b:	83 c0 04             	add    $0x4,%eax
    6b2e:	39 de                	cmp    %ebx,%esi
    6b30:	76 15                	jbe    6b47 <assamble_segment+0x5c7>
    6b32:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6b34:	39 cf                	cmp    %ecx,%edi
    6b36:	72 e0                	jb     6b18 <assamble_segment+0x598>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6b38:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6b3e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6b45:	eb db                	jmp    6b22 <assamble_segment+0x5a2>
    6b47:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6b4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b4d:	29 fb                	sub    %edi,%ebx
    6b4f:	01 d8                	add    %ebx,%eax
    6b51:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6b57:	e9 24 fc ff ff       	jmp    6780 <assamble_segment+0x200>
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//2:
			if((posStart < ambuf->segStart[0] )&&(ambuf->segStart[0] < posEnd)&&(posEnd <= ambuf->segEnd[0]))
    6b5c:	0f 86 6e fc ff ff    	jbe    67d0 <assamble_segment+0x250>
    6b62:	3b 7e 50             	cmp    0x50(%esi),%edi
    6b65:	0f 87 4f fc ff ff    	ja     67ba <assamble_segment+0x23a>
			{
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
    6b6b:	89 5e 10             	mov    %ebx,0x10(%esi)
    6b6e:	66 90                	xchg   %ax,%ax
				FOUT;
    6b70:	e9 0b fc ff ff       	jmp    6780 <assamble_segment+0x200>
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6b75:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6b78:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6b7b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6b7e:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6b81:	7e 20                	jle    6ba3 <assamble_segment+0x623>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b83:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6b87:	89 4d f0             	mov    %ecx,-0x10(%ebp)
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6b8a:	8b 08                	mov    (%eax),%ecx
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6b8c:	83 ea 01             	sub    $0x1,%edx
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6b8f:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[j+1] = ambuf->segStart[j];
    6b92:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6b95:	89 48 c4             	mov    %ecx,-0x3c(%eax)
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6b98:	83 e8 04             	sub    $0x4,%eax
    6b9b:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6b9e:	7f ea                	jg     6b8a <assamble_segment+0x60a>
    6ba0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
    6ba3:	83 c1 01             	add    $0x1,%ecx
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
    6ba6:	89 5c 96 14          	mov    %ebx,0x14(%esi,%edx,4)
				ambuf->segEnd[j+1] = posEnd;
    6baa:	89 7c 96 54          	mov    %edi,0x54(%esi,%edx,4)
				ambuf->segnum++;
    6bae:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
				FOUT;
    6bb4:	e9 c7 fb ff ff       	jmp    6780 <assamble_segment+0x200>
    6bb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006bc0 <rlc_pkt_receive_from_mac>:
**-------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
******************************************************************************/
void rlc_pkt_receive_from_mac(FSM_PKT * skb)
{
    6bc0:	55                   	push   %ebp
    6bc1:	89 e5                	mov    %esp,%ebp
    6bc3:	57                   	push   %edi
    6bc4:	56                   	push   %esi
    6bc5:	53                   	push   %ebx
    6bc6:	83 ec 4c             	sub    $0x4c,%esp
    6bc9:	e8 fc ff ff ff       	call   6bca <rlc_pkt_receive_from_mac+0xa>
    6bce:	89 c3                	mov    %eax,%ebx
	struct  UM_RX_Instance *umRxIns;
//   struct  TM_RX_Instance *tmRxIns;
	void *insptru, *insptrd;
	
	FIN(rlc_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6bd0:	e8 fc ff ff ff       	call   6bd1 <rlc_pkt_receive_from_mac+0x11>
    6bd5:	89 c7                	mov    %eax,%edi
	SV(countreceive_from_mac)++;
    6bd7:	8b 80 88 5a 00 00    	mov    0x5a88(%eax),%eax
    6bdd:	83 c0 01             	add    $0x1,%eax
    6be0:	89 87 88 5a 00 00    	mov    %eax,0x5a88(%edi)
	printk("[rlc_pkt_receive_from_mac]UE RLC_MAC SEND TO UPPER=%d\n",SV(countreceive_from_mac));
    6be6:	89 44 24 04          	mov    %eax,0x4(%esp)
    6bea:	c7 04 24 f8 1c 00 00 	movl   $0x1cf8,(%esp)
    6bf1:	e8 fc ff ff ff       	call   6bf2 <rlc_pkt_receive_from_mac+0x32>

	//skb = fsm_pkt_get();

	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from lower\n");
	//fsm_octets_print(skb->data,50);
	micimsg = (MRLC_fromMac_IciMsg*)skb->head;
    6bf6:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
    6bfc:	8b 46 02             	mov    0x2(%esi),%eax
    6bff:	89 44 24 08          	mov    %eax,0x8(%esp)
    6c03:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6c07:	c7 04 24 30 1d 00 00 	movl   $0x1d30,(%esp)
    6c0e:	89 44 24 04          	mov    %eax,0x4(%esp)
    6c12:	e8 fc ff ff ff       	call   6c13 <rlc_pkt_receive_from_mac+0x53>
	fsm_octets_print(skb->data,64);
    6c17:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    6c1d:	ba 40 00 00 00       	mov    $0x40,%edx
    6c22:	e8 fc ff ff ff       	call   6c23 <rlc_pkt_receive_from_mac+0x63>
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
    6c27:	8b 46 02             	mov    0x2(%esi),%eax
    6c2a:	85 c0                	test   %eax,%eax
    6c2c:	75 08                	jne    6c36 <rlc_pkt_receive_from_mac+0x76>
    6c2e:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6c32:	84 c0                	test   %al,%al
    6c34:	75 5a                	jne    6c90 <rlc_pkt_receive_from_mac+0xd0>
		}
		
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    6c36:	89 d8                	mov    %ebx,%eax
    6c38:	e8 fc ff ff ff       	call   6c39 <rlc_pkt_receive_from_mac+0x79>
    6c3d:	83 f8 01             	cmp    $0x1,%eax
    6c40:	0f 86 92 03 00 00    	jbe    6fd8 <rlc_pkt_receive_from_mac+0x418>
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6c46:	8b 46 02             	mov    0x2(%esi),%eax
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6c49:	8d 55 f2             	lea    -0xe(%ebp),%edx
    6c4c:	b9 02 00 00 00       	mov    $0x2,%ecx
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
    6c51:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6c55:	88 45 f2             	mov    %al,-0xe(%ebp)
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6c58:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    6c5e:	e8 fc ff ff ff       	call   6c5f <rlc_pkt_receive_from_mac+0x9f>
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
    6c63:	c7 04 24 44 26 00 00 	movl   $0x2644,(%esp)
    6c6a:	e8 fc ff ff ff       	call   6c6b <rlc_pkt_receive_from_mac+0xab>
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6c6f:	ba 05 00 00 00       	mov    $0x5,%edx
    6c74:	89 d8                	mov    %ebx,%eax
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
    6c76:	83 87 90 5a 00 00 01 	addl   $0x1,0x5a90(%edi)
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6c7d:	e8 fc ff ff ff       	call   6c7e <rlc_pkt_receive_from_mac+0xbe>
	}
	//printk("[RLC_MAC]SV(countDropPacket):%d\n", SV(countDropPacket));
	FOUT;
}
    6c82:	83 c4 4c             	add    $0x4c,%esp
    6c85:	5b                   	pop    %ebx
    6c86:	5e                   	pop    %esi
    6c87:	5f                   	pop    %edi
    6c88:	5d                   	pop    %ebp
    6c89:	c3                   	ret    
    6c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
	fsm_octets_print(skb->data,64);
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
    6c90:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    6c96:	0f b6 c0             	movzbl %al,%eax
    6c99:	89 14 24             	mov    %edx,(%esp)
    6c9c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    6c9f:	8d 55 e8             	lea    -0x18(%ebp),%edx
    6ca2:	e8 fc ff ff ff       	call   6ca3 <rlc_pkt_receive_from_mac+0xe3>
		switch(SV(ins_mode))
    6ca7:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    6cad:	83 f8 02             	cmp    $0x2,%eax
    6cb0:	74 3e                	je     6cf0 <rlc_pkt_receive_from_mac+0x130>
    6cb2:	83 f8 03             	cmp    $0x3,%eax
    6cb5:	0f 84 35 03 00 00    	je     6ff0 <rlc_pkt_receive_from_mac+0x430>
			//printk("[RLC_MAC UM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		default:
			printk("[RLC][rlc_pkt_receive_from_mac] cannot distinfuish this  %d", SV(ins_mode));
    6cbb:	89 44 24 04          	mov    %eax,0x4(%esp)
    6cbf:	c7 04 24 d0 25 00 00 	movl   $0x25d0,(%esp)
    6cc6:	e8 fc ff ff ff       	call   6cc7 <rlc_pkt_receive_from_mac+0x107>
			break;
		}
		//fsm_printf("[RLC][rlc_pkt_receive_from_mac] cannot find the instance or the instance is suspended(rbid is %d)\n", micimsg->lcid);
		printk("[RLC][rlc_pkt_receive_from_mac] A packet has dropped\n");
    6ccb:	c7 04 24 0c 26 00 00 	movl   $0x260c,(%esp)
    6cd2:	e8 fc ff ff ff       	call   6cd3 <rlc_pkt_receive_from_mac+0x113>
		SV(countDropPacket)++;
    6cd7:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		if(skb != NULL)
    6cde:	85 db                	test   %ebx,%ebx
    6ce0:	74 a0                	je     6c82 <rlc_pkt_receive_from_mac+0xc2>
		{
			fsm_pkt_destroy(skb);
    6ce2:	89 d8                	mov    %ebx,%eax
    6ce4:	e8 fc ff ff ff       	call   6ce5 <rlc_pkt_receive_from_mac+0x125>
    6ce9:	eb 97                	jmp    6c82 <rlc_pkt_receive_from_mac+0xc2>
    6ceb:	90                   	nop
    6cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		case UM_MODE:
			if(insptrd == NULL)
    6cf0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    6cf3:	85 c9                	test   %ecx,%ecx
    6cf5:	0f 84 ab 0d 00 00    	je     7aa6 <rlc_pkt_receive_from_mac+0xee6>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
    6cfb:	0f b6 81 c2 10 00 00 	movzbl 0x10c2(%ecx),%eax
    6d02:	3c 0b                	cmp    $0xb,%al
    6d04:	0f 84 83 0d 00 00    	je     7a8d <rlc_pkt_receive_from_mac+0xecd>
    6d0a:	3c 09                	cmp    $0x9,%al
    6d0c:	0f 84 7b 0d 00 00    	je     7a8d <rlc_pkt_receive_from_mac+0xecd>
	u16 windows;
	//MRLC_fromMac_IciMsg *mac_ici;
	//URLC_IciMsg *icimsg;
	
	FIN(rlc_UM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6d12:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6d15:	e8 fc ff ff ff       	call   6d16 <rlc_pkt_receive_from_mac+0x156>
    6d1a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	fsm_printf("\n[RLC][rlc_UM_pkt_receive_from_mac] entering rlc_UM_pkt_receive_from_mac\n");
    6d1d:	c7 04 24 00 22 00 00 	movl   $0x2200,(%esp)
    6d24:	e8 fc ff ff ff       	call   6d25 <rlc_pkt_receive_from_mac+0x165>
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
    6d29:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6d2c:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6d30:	c7 04 24 4c 22 00 00 	movl   $0x224c,(%esp)
    6d37:	89 44 24 04          	mov    %eax,0x4(%esp)
    6d3b:	e8 fc ff ff ff       	call   6d3c <rlc_pkt_receive_from_mac+0x17c>
	switch(umRxIns->snFiledLength)
    6d40:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6d43:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6d47:	66 83 f8 05          	cmp    $0x5,%ax
    6d4b:	0f 84 3f 06 00 00    	je     7390 <rlc_pkt_receive_from_mac+0x7d0>
    6d51:	66 83 f8 0a          	cmp    $0xa,%ax
    6d55:	0f 84 7d 06 00 00    	je     73d8 <rlc_pkt_receive_from_mac+0x818>
			FOUT;
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size10 + 1));
		break;
	default:
		printk("[RLC][rlc_UM_pkt_receive_from_mac] cannot distinguish the %d",umRxIns->snFiledLength);
    6d5b:	0f b7 c0             	movzwl %ax,%eax
    6d5e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6d61:	89 44 24 04          	mov    %eax,0x4(%esp)
    6d65:	c7 04 24 e4 22 00 00 	movl   $0x22e4,(%esp)
    6d6c:	e8 fc ff ff ff       	call   6d6d <rlc_pkt_receive_from_mac+0x1ad>
    6d71:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6d74:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    6d7a:	0f bf 75 e4          	movswl -0x1c(%ebp),%esi
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6d7e:	b8 18 00 00 00       	mov    $0x18,%eax
    6d83:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6d86:	e8 fc ff ff ff       	call   6d87 <rlc_pkt_receive_from_mac+0x1c7>
	umbuf->pkt = pkt;
    6d8b:	89 18                	mov    %ebx,(%eax)
	umbuf->SN = SN;
    6d8d:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6d91:	8d 50 10             	lea    0x10(%eax),%edx
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6d94:	89 c7                	mov    %eax,%edi
	umbuf->pkt = pkt;
	umbuf->SN = SN;
    6d96:	66 89 58 0c          	mov    %bx,0xc(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    6d9a:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6d9d:	8b 41 34             	mov    0x34(%ecx),%eax
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6da0:	8d 59 30             	lea    0x30(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    6da3:	89 51 34             	mov    %edx,0x34(%ecx)
    6da6:	89 5f 10             	mov    %ebx,0x10(%edi)
	new->next = next;
	new->prev = prev;
    6da9:	89 47 14             	mov    %eax,0x14(%edi)
	prev->next = new;
    6dac:	89 10                	mov    %edx,(%eax)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    6dae:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6db1:	89 74 24 04          	mov    %esi,0x4(%esp)
    6db5:	c7 04 24 24 23 00 00 	movl   $0x2324,(%esp)
    6dbc:	e8 fc ff ff ff       	call   6dbd <rlc_pkt_receive_from_mac+0x1fd>
	if(umRxIns->snFiledLength == 5)
    6dc1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6dc4:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6dc8:	66 83 f8 05          	cmp    $0x5,%ax
    6dcc:	0f 84 1e 07 00 00    	je     74f0 <rlc_pkt_receive_from_mac+0x930>
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
	}
	if(umRxIns->snFiledLength == 10)
    6dd2:	66 83 f8 0a          	cmp    $0xa,%ax
    6dd6:	75 07                	jne    6ddf <rlc_pkt_receive_from_mac+0x21f>
	{
		umRxIns->umRecvWindow10[SN] = umbuf;
    6dd8:	89 bc b1 b8 00 00 00 	mov    %edi,0xb8(%ecx,%esi,4)
	}
	umRxIns->vr_uh %= windows;
    6ddf:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6de6:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    6dea:	89 c2                	mov    %eax,%edx
    6dec:	c1 fa 1f             	sar    $0x1f,%edx
    6def:	f7 fb                	idiv   %ebx
    6df1:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_uh is %d\n", umRxIns->vr_uh);
    6df8:	0f bf d2             	movswl %dx,%edx
    6dfb:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6dfe:	89 54 24 04          	mov    %edx,0x4(%esp)
    6e02:	c7 04 24 70 23 00 00 	movl   $0x2370,(%esp)
    6e09:	e8 fc ff ff ff       	call   6e0a <rlc_pkt_receive_from_mac+0x24a>
	//
	if((SN>=umRxIns->vr_uh)||(SN <= umRxIns->vr_uh - windows/2))
    6e0e:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6e11:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
    6e15:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    6e1c:	66 d1 ef             	shr    %di
    6e1f:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
    6e23:	0f b7 ff             	movzwl %di,%edi
    6e26:	7d 07                	jge    6e2f <rlc_pkt_receive_from_mac+0x26f>
    6e28:	98                   	cwtl   
    6e29:	29 f8                	sub    %edi,%eax
    6e2b:	39 c6                	cmp    %eax,%esi
    6e2d:	7f 66                	jg     6e95 <rlc_pkt_receive_from_mac+0x2d5>
	{
		//	fsm_printf("umbuf->SN  >=  umRxIns->vr_uh is %d\n",umRxIns->vr_uh);
		umRxIns->vr_uh = (SN + 1)%windows;
    6e2f:	8d 46 01             	lea    0x1(%esi),%eax
    6e32:	89 c2                	mov    %eax,%edx
    6e34:	c1 fa 1f             	sar    $0x1f,%edx
    6e37:	f7 fb                	idiv   %ebx
    6e39:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] outside the windows: umRxIns->vr_uh is updated to %d\n", umRxIns->vr_uh);
    6e40:	89 54 24 04          	mov    %edx,0x4(%esp)
    6e44:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6e47:	c7 04 24 ac 23 00 00 	movl   $0x23ac,(%esp)
    6e4e:	e8 fc ff ff ff       	call   6e4f <rlc_pkt_receive_from_mac+0x28f>
		//temp = umRxIns->vr_ur;
		if(umRxIns->vr_ur < umRxIns->vr_uh - windows/2 )
    6e53:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6e56:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6e5d:	0f bf 91 bc 10 00 00 	movswl 0x10bc(%ecx),%edx
    6e64:	89 c6                	mov    %eax,%esi
    6e66:	29 fe                	sub    %edi,%esi
    6e68:	39 f2                	cmp    %esi,%edx
    6e6a:	7d 13                	jge    6e7f <rlc_pkt_receive_from_mac+0x2bf>
		{
			umRxIns->vr_ur = (umRxIns->vr_uh + windows/2)%windows;
    6e6c:	01 f8                	add    %edi,%eax
    6e6e:	89 c2                	mov    %eax,%edx
    6e70:	c1 fa 1f             	sar    $0x1f,%edx
    6e73:	f7 fb                	idiv   %ebx
    6e75:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
    6e7c:	0f bf d2             	movswl %dx,%edx
			}
			umRxIns->vr_ur =  temp;*/
			//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
		}		
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    6e7f:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6e82:	89 54 24 04          	mov    %edx,0x4(%esp)
    6e86:	c7 04 24 08 24 00 00 	movl   $0x2408,(%esp)
    6e8d:	e8 fc ff ff ff       	call   6e8e <rlc_pkt_receive_from_mac+0x2ce>
    6e92:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		//	fsm_printf("umRxIns->vr_ur is %d\n",umRxIns->vr_ur);
		//	   fsm_pkt_send(rlc_UM_reassemble_deliver( umRxIns),STRM_TO_PDCP);
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
    6e95:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6e99:	66 83 f8 05          	cmp    $0x5,%ax
    6e9d:	0f 84 f6 06 00 00    	je     7599 <rlc_pkt_receive_from_mac+0x9d9>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
		}
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
    6ea3:	66 83 f8 0a          	cmp    $0xa,%ax
    6ea7:	0f 84 92 07 00 00    	je     763f <rlc_pkt_receive_from_mac+0xa7f>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6ead:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    6eb4:	8b 71 08             	mov    0x8(%ecx),%esi
    6eb7:	85 f6                	test   %esi,%esi
    6eb9:	0f 84 a4 00 00 00    	je     6f63 <rlc_pkt_receive_from_mac+0x3a3>
    6ebf:	0f b7 81 be 10 00 00 	movzwl 0x10be(%ecx),%eax
    6ec6:	66 39 c7             	cmp    %ax,%di
    6ec9:	7d 6d                	jge    6f38 <rlc_pkt_receive_from_mac+0x378>
    6ecb:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    6ecf:	0f bf d0             	movswl %ax,%edx
    6ed2:	0f bf ff             	movswl %di,%edi
    6ed5:	66 d1 ee             	shr    %si
    6ed8:	0f b7 f6             	movzwl %si,%esi
    6edb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    6ede:	89 d6                	mov    %edx,%esi
    6ee0:	2b 75 e4             	sub    -0x1c(%ebp),%esi
    6ee3:	39 f7                	cmp    %esi,%edi
    6ee5:	7e 51                	jle    6f38 <rlc_pkt_receive_from_mac+0x378>
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6ee7:	66 83 79 06 05       	cmpw   $0x5,0x6(%ecx)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    6eec:	0f bf b1 c0 10 00 00 	movswl 0x10c0(%ecx),%esi
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6ef3:	0f 84 f4 08 00 00    	je     77ed <rlc_pkt_receive_from_mac+0xc2d>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    6ef9:	29 f2                	sub    %esi,%edx
    6efb:	81 c2 00 06 00 00    	add    $0x600,%edx
    6f01:	89 d6                	mov    %edx,%esi
    6f03:	c1 fe 1f             	sar    $0x1f,%esi
    6f06:	c1 ee 16             	shr    $0x16,%esi
    6f09:	01 f2                	add    %esi,%edx
    6f0b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6f11:	29 f2                	sub    %esi,%edx
    6f13:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    6f19:	0f 9e c2             	setle  %dl
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    6f1c:	84 d2                	test   %dl,%dl
    6f1e:	0f 85 5e fd ff ff    	jne    6c82 <rlc_pkt_receive_from_mac+0xc2>
								((!isInsideUmRecvWin(umRxIns,umRxIns->vr_ux ))&&(umRxIns->vr_ux != umRxIns->vr_uh))))
    6f24:	66 3b 81 c0 10 00 00 	cmp    0x10c0(%ecx),%ax
    6f2b:	0f 84 51 fd ff ff    	je     6c82 <rlc_pkt_receive_from_mac+0xc2>
    6f31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is canceling\n\n");
    6f38:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f3b:	c7 04 24 18 25 00 00 	movl   $0x2518,(%esp)
    6f42:	e8 fc ff ff ff       	call   6f43 <rlc_pkt_receive_from_mac+0x383>
		fsm_schedule_cancel(umRxIns->reorderTimer);
    6f47:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f4a:	8b 41 08             	mov    0x8(%ecx),%eax
    6f4d:	e8 fc ff ff ff       	call   6f4e <rlc_pkt_receive_from_mac+0x38e>
		umRxIns->reorderTimer = 0;
    6f52:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f55:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    6f5c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
	}
	//h>r(!=)
	//if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh != umRxIns->vr_ur))//??
	if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh>umRxIns->vr_ur||umRxIns->vr_uh<umRxIns->vr_ur-windows/2))
    6f63:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    6f6a:	66 39 c7             	cmp    %ax,%di
    6f6d:	7c 18                	jl     6f87 <rlc_pkt_receive_from_mac+0x3c7>
    6f6f:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    6f73:	0f bf ff             	movswl %di,%edi
    6f76:	98                   	cwtl   
    6f77:	66 d1 ea             	shr    %dx
    6f7a:	0f b7 d2             	movzwl %dx,%edx
    6f7d:	29 d7                	sub    %edx,%edi
    6f7f:	39 f8                	cmp    %edi,%eax
    6f81:	0f 8d fb fc ff ff    	jge    6c82 <rlc_pkt_receive_from_mac+0xc2>
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is scheduling\n");
    6f87:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f8a:	c7 04 24 50 25 00 00 	movl   $0x2550,(%esp)
    6f91:	e8 fc ff ff ff       	call   6f92 <rlc_pkt_receive_from_mac+0x3d2>
		umRxIns->reorderTimer = fsm_schedule_self(umRxIns->reorderTimerValue, umRxIns->reorderTimerCode);
    6f96:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f99:	8b 51 0c             	mov    0xc(%ecx),%edx
    6f9c:	8b 41 10             	mov    0x10(%ecx),%eax
    6f9f:	e8 fc ff ff ff       	call   6fa0 <rlc_pkt_receive_from_mac+0x3e0>
    6fa4:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6fa7:	89 41 08             	mov    %eax,0x8(%ecx)
		umRxIns->vr_ux = umRxIns->vr_uh;
		umRxIns->vr_ux %= windows;
    6faa:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6fb1:	89 c2                	mov    %eax,%edx
    6fb3:	c1 fa 1f             	sar    $0x1f,%edx
    6fb6:	f7 fb                	idiv   %ebx
    6fb8:	66 89 91 be 10 00 00 	mov    %dx,0x10be(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ux is updated to %d\n\n", umRxIns->vr_ux);
    6fbf:	0f bf d2             	movswl %dx,%edx
    6fc2:	89 54 24 04          	mov    %edx,0x4(%esp)
    6fc6:	c7 04 24 88 25 00 00 	movl   $0x2588,(%esp)
    6fcd:	e8 fc ff ff ff       	call   6fce <rlc_pkt_receive_from_mac+0x40e>
    6fd2:	e9 ab fc ff ff       	jmp    6c82 <rlc_pkt_receive_from_mac+0xc2>
    6fd7:	90                   	nop
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    6fd8:	89 d8                	mov    %ebx,%eax
    6fda:	ba 02 00 00 00       	mov    $0x2,%edx
    6fdf:	e8 fc ff ff ff       	call   6fe0 <rlc_pkt_receive_from_mac+0x420>
    6fe4:	89 c3                	mov    %eax,%ebx
    6fe6:	e9 5b fc ff ff       	jmp    6c46 <rlc_pkt_receive_from_mac+0x86>
    6feb:	90                   	nop
    6fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    6ff0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6ff3:	85 c0                	test   %eax,%eax
    6ff5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    6ff8:	0f 84 76 0a 00 00    	je     7a74 <rlc_pkt_receive_from_mac+0xeb4>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    6ffe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7001:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
    7005:	66 83 f8 0b          	cmp    $0xb,%ax
    7009:	0f 84 4c 0a 00 00    	je     7a5b <rlc_pkt_receive_from_mac+0xe9b>
    700f:	66 83 f8 09          	cmp    $0x9,%ax
    7013:	0f 84 42 0a 00 00    	je     7a5b <rlc_pkt_receive_from_mac+0xe9b>
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7019:	e8 fc ff ff ff       	call   701a <rlc_pkt_receive_from_mac+0x45a>
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
    701e:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
    7024:	66 c1 06 08          	rolw   $0x8,(%esi)
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7028:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
	*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
	fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the header is:\n");
    702b:	c7 04 24 1c 1e 00 00 	movl   $0x1e1c,(%esp)
    7032:	e8 fc ff ff ff       	call   7033 <rlc_pkt_receive_from_mac+0x473>
	fsm_octets_print(fixhead,2);
    7037:	ba 02 00 00 00       	mov    $0x2,%edx
    703c:	89 f0                	mov    %esi,%eax
    703e:	e8 fc ff ff ff       	call   703f <rlc_pkt_receive_from_mac+0x47f>
	//fsm_printf("\n[RLC][rlc_AM_pkt_receive_from_mac] entering rlc_AM_pkt_receive_from_mac\n");
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
    7043:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7047:	84 c0                	test   %al,%al
    7049:	0f 89 b1 04 00 00    	jns    7500 <rlc_pkt_receive_from_mac+0x940>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    704f:	a8 40                	test   $0x40,%al
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7051:	0f b6 16             	movzbl (%esi),%edx
    7054:	0f b6 46 01          	movzbl 0x1(%esi),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    7058:	0f 84 3a 02 00 00    	je     7298 <rlc_pkt_receive_from_mac+0x6d8>
	}

//AMD PDU 
	else
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
    705e:	83 e0 03             	and    $0x3,%eax
    7061:	c1 e0 08             	shl    $0x8,%eax
    7064:	09 d0                	or     %edx,%eax
    7066:	89 44 24 04          	mov    %eax,0x4(%esp)
    706a:	c7 04 24 d8 1e 00 00 	movl   $0x1ed8,(%esp)
    7071:	e8 fc ff ff ff       	call   7072 <rlc_pkt_receive_from_mac+0x4b2>
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
    7076:	8b 8b ac 00 00 00    	mov    0xac(%ebx),%ecx
    707c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    707f:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7083:	0f b6 16             	movzbl (%esi),%edx
    7086:	83 e0 03             	and    $0x3,%eax
    7089:	c1 e0 08             	shl    $0x8,%eax
    708c:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    708e:	0f bf d0             	movswl %ax,%edx
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    7091:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    7095:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7098:	89 55 e0             	mov    %edx,-0x20(%ebp)
    709b:	e8 fc ff ff ff       	call   709c <rlc_pkt_receive_from_mac+0x4dc>
    70a0:	84 c0                	test   %al,%al
    70a2:	0f 84 4b 09 00 00    	je     79f3 <rlc_pkt_receive_from_mac+0xe33>
    70a8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    70ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    70ae:	81 c1 98 04 00 00    	add    $0x498,%ecx
    70b4:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
    70b8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    70bb:	85 c0                	test   %eax,%eax
    70bd:	0f 84 49 07 00 00    	je     780c <rlc_pkt_receive_from_mac+0xc4c>
    70c3:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    70c7:	0f 84 26 09 00 00    	je     79f3 <rlc_pkt_receive_from_mac+0xe33>
		//PDU
		else
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not received this PDU segment before(pos is %d)\n", extseghead->SO);
			//
			if(extseghead->LSF == 1)
    70cd:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    70d0:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    70d4:	79 3a                	jns    7110 <rlc_pkt_receive_from_mac+0x550>
			{
				amIns->amRecvWindow[SN]->pktstatus = LAST_SEGMENT;
    70d6:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
    70dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    70e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    70e3:	8b 44 82 0c          	mov    0xc(%edx,%eax,4),%eax
    70e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    70ea:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    70ee:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    70f2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    70f5:	83 e0 7f             	and    $0x7f,%eax
    70f8:	c1 e0 08             	shl    $0x8,%eax
    70fb:	09 d0                	or     %edx,%eax
    70fd:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    7100:	03 43 50             	add    0x50(%ebx),%eax
    7103:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    7109:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    710c:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
    7110:	89 da                	mov    %ebx,%edx
    7112:	e8 fc ff ff ff       	call   7113 <rlc_pkt_receive_from_mac+0x553>
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    7117:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    711a:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    711d:	8b 44 9a 0c          	mov    0xc(%edx,%ebx,4),%eax
    7121:	8b 10                	mov    (%eax),%edx
    7123:	8b 4a 50             	mov    0x50(%edx),%ecx
    7126:	39 88 98 00 00 00    	cmp    %ecx,0x98(%eax)
    712c:	0f 84 d9 05 00 00    	je     770b <rlc_pkt_receive_from_mac+0xb4b>
	}

//PDUSN

//vr_h
	if(SN >= amIns->vr_h || SN <= amIns->vr_h-AM_WINDOW_SIZE)
    7132:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7135:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    713c:	66 3b 45 da          	cmp    -0x26(%ebp),%ax
    7140:	7e 0b                	jle    714d <rlc_pkt_receive_from_mac+0x58d>
    7142:	98                   	cwtl   
    7143:	2d 00 02 00 00       	sub    $0x200,%eax
    7148:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    714b:	7f 31                	jg     717e <rlc_pkt_receive_from_mac+0x5be>
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN > amIns->vr_h\n");
    714d:	c7 04 24 98 1f 00 00 	movl   $0x1f98,(%esp)
    7154:	e8 fc ff ff ff       	call   7155 <rlc_pkt_receive_from_mac+0x595>
		amIns->vr_h = (SN + 1)%(AM_WINDOW_SIZE*2);
    7159:	8b 45 e0             	mov    -0x20(%ebp),%eax
    715c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    715f:	83 c0 01             	add    $0x1,%eax
    7162:	25 ff 03 00 00       	and    $0x3ff,%eax
    7167:	66 89 82 ee 22 00 00 	mov    %ax,0x22ee(%edx)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_h is updated to %d\n",amIns->vr_h);
    716e:	89 44 24 04          	mov    %eax,0x4(%esp)
    7172:	c7 04 24 d0 1f 00 00 	movl   $0x1fd0,(%esp)
    7179:	e8 fc ff ff ff       	call   717a <rlc_pkt_receive_from_mac+0x5ba>
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    717e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7181:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
    7188:	8b 84 90 6c 12 00 00 	mov    0x126c(%eax,%edx,4),%eax
    718f:	85 c0                	test   %eax,%eax
    7191:	74 0a                	je     719d <rlc_pkt_receive_from_mac+0x5dd>
    7193:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7197:	0f 84 83 03 00 00    	je     7520 <rlc_pkt_receive_from_mac+0x960>
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    719d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    71a0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    71a3:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    71aa:	0f bf c2             	movswl %dx,%eax
    71ad:	8b 84 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%eax
    71b4:	85 c0                	test   %eax,%eax
    71b6:	74 0a                	je     71c2 <rlc_pkt_receive_from_mac+0x602>
    71b8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    71bc:	0f 84 6d 05 00 00    	je     772f <rlc_pkt_receive_from_mac+0xb6f>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
	}
	
//x>r,xmr
	if(amIns->reorderTimer &&((amIns->vr_x == amIns->vr_r)||(!isInsideAmRecvWin(amIns, SN)&&(amIns->vr_x != amIns->vr_mr))))
    71c2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    71c5:	8b 41 14             	mov    0x14(%ecx),%eax
    71c8:	85 c0                	test   %eax,%eax
    71ca:	74 4b                	je     7217 <rlc_pkt_receive_from_mac+0x657>
    71cc:	66 3b 91 f0 22 00 00 	cmp    0x22f0(%ecx),%dx
    71d3:	74 2c                	je     7201 <rlc_pkt_receive_from_mac+0x641>
    71d5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    71d8:	89 c8                	mov    %ecx,%eax
    71da:	e8 fc ff ff ff       	call   71db <rlc_pkt_receive_from_mac+0x61b>
    71df:	84 c0                	test   %al,%al
    71e1:	0f 85 a1 02 00 00    	jne    7488 <rlc_pkt_receive_from_mac+0x8c8>
    71e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    71ea:	0f b7 90 ec 22 00 00 	movzwl 0x22ec(%eax),%edx
    71f1:	66 39 90 f0 22 00 00 	cmp    %dx,0x22f0(%eax)
    71f8:	0f 84 8a 02 00 00    	je     7488 <rlc_pkt_receive_from_mac+0x8c8>
    71fe:	8b 40 14             	mov    0x14(%eax),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
    7201:	e8 fc ff ff ff       	call   7202 <rlc_pkt_receive_from_mac+0x642>
		amIns->reorderTimer = 0;
    7206:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7209:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    7210:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7217:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    721a:	0f b7 81 ee 22 00 00 	movzwl 0x22ee(%ecx),%eax
    7221:	66 39 c2             	cmp    %ax,%dx
    7224:	7c 0e                	jl     7234 <rlc_pkt_receive_from_mac+0x674>
    7226:	0f bf d2             	movswl %dx,%edx
    7229:	98                   	cwtl   
    722a:	81 ea 00 02 00 00    	sub    $0x200,%edx
    7230:	39 d0                	cmp    %edx,%eax
    7232:	7d 24                	jge    7258 <rlc_pkt_receive_from_mac+0x698>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is scheduling\n");
		amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue ,amIns->reorderTimerCode);
    7234:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7237:	8b 50 18             	mov    0x18(%eax),%edx
    723a:	8b 40 1c             	mov    0x1c(%eax),%eax
    723d:	e8 fc ff ff ff       	call   723e <rlc_pkt_receive_from_mac+0x67e>
    7242:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7245:	89 43 14             	mov    %eax,0x14(%ebx)
		amIns->vr_x = amIns->vr_h;
    7248:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    724f:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    7256:	66 90                	xchg   %ax,%ax
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_x is updated to %d\n",amIns->vr_x);
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
    7258:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    725c:	c7 04 24 5e 04 00 00 	movl   $0x45e,(%esp)
    7263:	c0 e8 05             	shr    $0x5,%al
    7266:	83 e0 01             	and    $0x1,%eax
    7269:	89 44 24 04          	mov    %eax,0x4(%esp)
    726d:	e8 fc ff ff ff       	call   726e <rlc_pkt_receive_from_mac+0x6ae>
	if(fixhead->P == 1)
    7272:	f6 46 01 20          	testb  $0x20,0x1(%esi)
    7276:	0f 85 2c 02 00 00    	jne    74a8 <rlc_pkt_receive_from_mac+0x8e8>
			//amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
			//fsm_printf("After am receive_from_mac pollRetxRimer is running\n");
			//addpkt_recvData(amIns);				
			rlc_AM_pkt_receive_from_mac(amIns,skb);
			//    fsm_printf("time for rlc_AM_pkt_receive_from_mac(amIns,skb)\n");
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
    727c:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    7282:	c7 04 24 4c 21 00 00 	movl   $0x214c,(%esp)
    7289:	89 44 24 04          	mov    %eax,0x4(%esp)
    728d:	e8 fc ff ff ff       	call   728e <rlc_pkt_receive_from_mac+0x6ce>
			FOUT;
    7292:	e9 eb f9 ff ff       	jmp    6c82 <rlc_pkt_receive_from_mac+0xc2>
    7297:	90                   	nop
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7298:	83 e0 03             	and    $0x3,%eax
    729b:	c1 e0 08             	shl    $0x8,%eax
    729e:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    72a0:	0f bf d0             	movswl %ax,%edx
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    72a3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    72a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72aa:	89 55 e0             	mov    %edx,-0x20(%ebp)
    72ad:	e8 fc ff ff ff       	call   72ae <rlc_pkt_receive_from_mac+0x6ee>
    72b2:	84 c0                	test   %al,%al
    72b4:	0f 84 45 07 00 00    	je     79ff <rlc_pkt_receive_from_mac+0xe3f>
				pkt= NULL;
			}			
			FOUT;
		}
//,
		if(amIns->amRecvWindow[SN] != NULL)
    72ba:	8b 55 e0             	mov    -0x20(%ebp),%edx
    72bd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    72c0:	81 c2 98 04 00 00    	add    $0x498,%edx
    72c6:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    72ca:	89 55 dc             	mov    %edx,-0x24(%ebp)
    72cd:	85 c0                	test   %eax,%eax
    72cf:	74 42                	je     7313 <rlc_pkt_receive_from_mac+0x753>
		{
			if(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)
    72d1:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    72d5:	0f 84 24 07 00 00    	je     79ff <rlc_pkt_receive_from_mac+0xe3f>
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received completly\n");
				FOUT;
			}
			else
			{
				if(amIns->amRecvWindow[SN]->pkt != NULL)
    72db:	8b 10                	mov    (%eax),%edx
    72dd:	85 d2                	test   %edx,%edx
    72df:	74 1f                	je     7300 <rlc_pkt_receive_from_mac+0x740>
				{
					fsm_pkt_destroy(amIns->amRecvWindow[SN]->pkt);
    72e1:	89 d0                	mov    %edx,%eax
    72e3:	e8 fc ff ff ff       	call   72e4 <rlc_pkt_receive_from_mac+0x724>
					amIns->amRecvWindow[SN]->pkt = NULL;
    72e8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    72eb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    72ee:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    72f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				}
				if(amIns->amRecvWindow[SN] != NULL)
    72f8:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    72fc:	85 c0                	test   %eax,%eax
    72fe:	74 13                	je     7313 <rlc_pkt_receive_from_mac+0x753>
				{
					fsm_mem_free(amIns->amRecvWindow[SN]);
    7300:	e8 fc ff ff ff       	call   7301 <rlc_pkt_receive_from_mac+0x741>
					amIns->amRecvWindow[SN] = NULL;
    7305:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7308:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    730b:	c7 44 82 0c 00 00 00 	movl   $0x0,0xc(%edx,%eax,4)
    7312:	00 
					//printk("RLC FREE: %d\n", freenum);
				}				
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received but not completly\n");
			}
		}
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    7313:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7318:	e8 fc ff ff ff       	call   7319 <rlc_pkt_receive_from_mac+0x759>
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
    731d:	89 18                	mov    %ebx,(%eax)
		ambuf->pktstatus = FULL_SDU;
		ambuf->pos = 0;
		ambuf->segnum = 0;
		ambuf->SN = SN;
    731f:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7323:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
		ambuf->pktstatus = FULL_SDU;
    7329:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		ambuf->pos = 0;
    7330:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		ambuf->segnum = 0;
    7337:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    733e:	00 00 00 
		ambuf->SN = SN;
    7341:	66 89 98 94 00 00 00 	mov    %bx,0x94(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    7348:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    734b:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7351:	89 8b 60 02 00 00    	mov    %ecx,0x260(%ebx)
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7357:	81 c3 5c 02 00 00    	add    $0x25c,%ebx
    735d:	89 98 9c 00 00 00    	mov    %ebx,0x9c(%eax)
		amIns->amRecvWindow[SN] = ambuf;
    7363:	8b 5d dc             	mov    -0x24(%ebp),%ebx
	new->next = next;
	new->prev = prev;
    7366:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
    736c:	89 0a                	mov    %ecx,(%edx)
    736e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7371:	89 44 9a 0c          	mov    %eax,0xc(%edx,%ebx,4)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    7375:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7378:	c7 04 24 8c 1e 00 00 	movl   $0x1e8c,(%esp)
    737f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7383:	e8 fc ff ff ff       	call   7384 <rlc_pkt_receive_from_mac+0x7c4>
    7388:	e9 a5 fd ff ff       	jmp    7132 <rlc_pkt_receive_from_mac+0x572>
    738d:	8d 76 00             	lea    0x0(%esi),%esi
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
	switch(umRxIns->snFiledLength)
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
    7390:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    7396:	0f b6 00             	movzbl (%eax),%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
    7399:	89 c6                	mov    %eax,%esi
    739b:	83 e6 1f             	and    $0x1f,%esi
    739e:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
    73a2:	0f bf f6             	movswl %si,%esi
    73a5:	8b 44 b1 38          	mov    0x38(%ecx,%esi,4),%eax
    73a9:	85 c0                	test   %eax,%eax
    73ab:	0f 85 78 06 00 00    	jne    7a29 <rlc_pkt_receive_from_mac+0xe69>
    73b1:	89 c8                	mov    %ecx,%eax
    73b3:	89 f2                	mov    %esi,%edx
    73b5:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    73b8:	e8 fc ff ff ff       	call   73b9 <rlc_pkt_receive_from_mac+0x7f9>
    73bd:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    73c0:	84 c0                	test   %al,%al
    73c2:	0f 85 61 06 00 00    	jne    7a29 <rlc_pkt_receive_from_mac+0xe69>
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
    73c8:	66 c7 45 e0 20 00    	movw   $0x20,-0x20(%ebp)
    73ce:	e9 ab f9 ff ff       	jmp    6d7e <rlc_pkt_receive_from_mac+0x1be>
    73d3:	90                   	nop
    73d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
    73d8:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    73de:	ba 02 00 00 00       	mov    $0x2,%edx
    73e3:	66 c1 00 08          	rolw   $0x8,(%eax)
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
    73e7:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    73ed:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    73f0:	89 f0                	mov    %esi,%eax
    73f2:	e8 fc ff ff ff       	call   73f3 <rlc_pkt_receive_from_mac+0x833>
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    73f7:	0f b6 46 01          	movzbl 0x1(%esi),%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    73fb:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    73fe:	0f b6 16             	movzbl (%esi),%edx
    7401:	83 e0 03             	and    $0x3,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7404:	0f bf b9 bc 10 00 00 	movswl 0x10bc(%ecx),%edi
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    740b:	c1 e0 08             	shl    $0x8,%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    740e:	09 d0                	or     %edx,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7410:	0f bf f0             	movswl %ax,%esi
    7413:	89 f2                	mov    %esi,%edx
    7415:	29 fa                	sub    %edi,%edx
    7417:	81 c2 00 04 00 00    	add    $0x400,%edx
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    741d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7421:	89 d0                	mov    %edx,%eax
    7423:	c1 f8 1f             	sar    $0x1f,%eax
    7426:	c1 e8 16             	shr    $0x16,%eax
    7429:	01 c2                	add    %eax,%edx
    742b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    7431:	29 c2                	sub    %eax,%edx
    7433:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    743a:	29 f8                	sub    %edi,%eax
    743c:	05 00 04 00 00       	add    $0x400,%eax
    7441:	89 c7                	mov    %eax,%edi
    7443:	c1 ff 1f             	sar    $0x1f,%edi
    7446:	c1 ef 16             	shr    $0x16,%edi
    7449:	01 f8                	add    %edi,%eax
    744b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7450:	29 f8                	sub    %edi,%eax
    7452:	39 c2                	cmp    %eax,%edx
    7454:	7d 0f                	jge    7465 <rlc_pkt_receive_from_mac+0x8a5>
    7456:	8b bc b1 b8 00 00 00 	mov    0xb8(%ecx,%esi,4),%edi
    745d:	85 ff                	test   %edi,%edi
    745f:	0f 85 6c 05 00 00    	jne    79d1 <rlc_pkt_receive_from_mac+0xe11>
    7465:	89 c8                	mov    %ecx,%eax
    7467:	89 f2                	mov    %esi,%edx
    7469:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    746c:	e8 fc ff ff ff       	call   746d <rlc_pkt_receive_from_mac+0x8ad>
    7471:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7474:	84 c0                	test   %al,%al
    7476:	0f 85 55 05 00 00    	jne    79d1 <rlc_pkt_receive_from_mac+0xe11>
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
    747c:	66 c7 45 e0 00 04    	movw   $0x400,-0x20(%ebp)
    7482:	e9 f7 f8 ff ff       	jmp    6d7e <rlc_pkt_receive_from_mac+0x1be>
    7487:	90                   	nop
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
		amIns->reorderTimer = 0;
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7488:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    748b:	8b 50 14             	mov    0x14(%eax),%edx
    748e:	85 d2                	test   %edx,%edx
    7490:	0f 85 c2 fd ff ff    	jne    7258 <rlc_pkt_receive_from_mac+0x698>
    7496:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    749d:	e9 75 fd ff ff       	jmp    7217 <rlc_pkt_receive_from_mac+0x657>
    74a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
	if(fixhead->P == 1)
	{
		fsm_printf("[RLC] amIns->statProhTimer = %d\n",amIns->statProhTimer);
    74a8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    74ab:	8b 46 20             	mov    0x20(%esi),%eax
    74ae:	c7 04 24 ec 20 00 00 	movl   $0x20ec,(%esp)
    74b5:	89 44 24 04          	mov    %eax,0x4(%esp)
    74b9:	e8 fc ff ff ff       	call   74ba <rlc_pkt_receive_from_mac+0x8fa>
		//
		if( !amIns->statProhTimer )
    74be:	8b 46 20             	mov    0x20(%esi),%eax
    74c1:	85 c0                	test   %eax,%eax
    74c3:	0f 85 b3 fd ff ff    	jne    727c <rlc_pkt_receive_from_mac+0x6bc>
		{
			amIns->statFlag = true;
    74c9:	c6 46 06 01          	movb   $0x1,0x6(%esi)
			fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the statProhTimer start\n");
    74cd:	c7 04 24 10 21 00 00 	movl   $0x2110,(%esp)
    74d4:	e8 fc ff ff ff       	call   74d5 <rlc_pkt_receive_from_mac+0x915>
			amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    74d9:	8b 56 24             	mov    0x24(%esi),%edx
    74dc:	8b 46 28             	mov    0x28(%esi),%eax
    74df:	e8 fc ff ff ff       	call   74e0 <rlc_pkt_receive_from_mac+0x920>
    74e4:	89 46 20             	mov    %eax,0x20(%esi)
    74e7:	e9 90 fd ff ff       	jmp    727c <rlc_pkt_receive_from_mac+0x6bc>
    74ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	umbuf->SN = SN;
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
	if(umRxIns->snFiledLength == 5)
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
    74f0:	89 7c b1 38          	mov    %edi,0x38(%ecx,%esi,4)
    74f4:	e9 e6 f8 ff ff       	jmp    6ddf <rlc_pkt_receive_from_mac+0x21f>
    74f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    7500:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		rlc_ctrl_pkt_recv(amIns, pkt);
    7503:	89 da                	mov    %ebx,%edx
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    7505:	83 80 a4 5a 00 00 01 	addl   $0x1,0x5aa4(%eax)
		rlc_ctrl_pkt_recv(amIns, pkt);
    750c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    750f:	e8 fc ff ff ff       	call   7510 <rlc_pkt_receive_from_mac+0x950>
    7514:	e9 63 fd ff ff       	jmp    727c <rlc_pkt_receive_from_mac+0x6bc>
    7519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    7520:	8d 42 01             	lea    0x1(%edx),%eax
    7523:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7526:	89 c1                	mov    %eax,%ecx
    7528:	c1 f9 1f             	sar    $0x1f,%ecx
    752b:	c1 e9 16             	shr    $0x16,%ecx
    752e:	01 c8                	add    %ecx,%eax
    7530:	25 ff 03 00 00       	and    $0x3ff,%eax
    7535:	29 c8                	sub    %ecx,%eax
    7537:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    753e:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7545:	85 d2                	test   %edx,%edx
    7547:	74 3b                	je     7584 <rlc_pkt_receive_from_mac+0x9c4>
    7549:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    754d:	75 35                	jne    7584 <rlc_pkt_receive_from_mac+0x9c4>
    754f:	89 d9                	mov    %ebx,%ecx
    7551:	eb 0b                	jmp    755e <rlc_pkt_receive_from_mac+0x99e>
    7553:	90                   	nop
    7554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    7558:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    755c:	75 26                	jne    7584 <rlc_pkt_receive_from_mac+0x9c4>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    755e:	83 c0 01             	add    $0x1,%eax
    7561:	89 c2                	mov    %eax,%edx
    7563:	c1 fa 1f             	sar    $0x1f,%edx
    7566:	c1 ea 16             	shr    $0x16,%edx
    7569:	01 d0                	add    %edx,%eax
    756b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7570:	29 d0                	sub    %edx,%eax
    7572:	66 89 81 f2 22 00 00 	mov    %ax,0x22f2(%ecx)

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    7579:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7580:	85 d2                	test   %edx,%edx
    7582:	75 d4                	jne    7558 <rlc_pkt_receive_from_mac+0x998>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
    7584:	89 44 24 04          	mov    %eax,0x4(%esp)
    7588:	c7 04 24 14 20 00 00 	movl   $0x2014,(%esp)
    758f:	e8 fc ff ff ff       	call   7590 <rlc_pkt_receive_from_mac+0x9d0>
    7594:	e9 04 fc ff ff       	jmp    719d <rlc_pkt_receive_from_mac+0x5dd>
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
    7599:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    759c:	c7 04 24 4c 24 00 00 	movl   $0x244c,(%esp)
    75a3:	e8 fc ff ff ff       	call   75a4 <rlc_pkt_receive_from_mac+0x9e4>
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
    75a8:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    75ab:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    75b2:	0f bf c7             	movswl %di,%eax
    75b5:	8b 74 81 38          	mov    0x38(%ecx,%eax,4),%esi
    75b9:	85 f6                	test   %esi,%esi
    75bb:	0f 84 f3 f8 ff ff    	je     6eb4 <rlc_pkt_receive_from_mac+0x2f4>
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    75c1:	83 c0 01             	add    $0x1,%eax
    75c4:	89 c2                	mov    %eax,%edx
    75c6:	c1 fa 1f             	sar    $0x1f,%edx
    75c9:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    75cb:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    75ce:	89 d7                	mov    %edx,%edi
    75d0:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    75d7:	8b 54 81 38          	mov    0x38(%ecx,%eax,4),%edx
    75db:	85 d2                	test   %edx,%edx
    75dd:	74 31                	je     7610 <rlc_pkt_receive_from_mac+0xa50>
    75df:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    75e6:	66 39 fe             	cmp    %di,%si
    75e9:	7d 0a                	jge    75f5 <rlc_pkt_receive_from_mac+0xa35>
    75eb:	eb 23                	jmp    7610 <rlc_pkt_receive_from_mac+0xa50>
    75ed:	8d 76 00             	lea    0x0(%esi),%esi
    75f0:	66 39 d6             	cmp    %dx,%si
    75f3:	7c 14                	jl     7609 <rlc_pkt_receive_from_mac+0xa49>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    75f5:	83 c0 01             	add    $0x1,%eax
    75f8:	89 c2                	mov    %eax,%edx
    75fa:	c1 fa 1f             	sar    $0x1f,%edx
    75fd:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    75ff:	0f bf c2             	movswl %dx,%eax
    7602:	83 7c 81 38 00       	cmpl   $0x0,0x38(%ecx,%eax,4)
    7607:	75 e7                	jne    75f0 <rlc_pkt_receive_from_mac+0xa30>
    7609:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    7610:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7613:	89 44 24 04          	mov    %eax,0x4(%esp)
    7617:	c7 04 24 08 24 00 00 	movl   $0x2408,(%esp)
    761e:	e8 fc ff ff ff       	call   761f <rlc_pkt_receive_from_mac+0xa5f>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    7623:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7626:	8d 51 18             	lea    0x18(%ecx),%edx
    7629:	89 c8                	mov    %ecx,%eax
    762b:	e8 fc ff ff ff       	call   762c <rlc_pkt_receive_from_mac+0xa6c>
    7630:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7633:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    763a:	e9 75 f8 ff ff       	jmp    6eb4 <rlc_pkt_receive_from_mac+0x2f4>
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
    763f:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    7646:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7649:	c7 04 24 7c 24 00 00 	movl   $0x247c,(%esp)
    7650:	89 44 24 04          	mov    %eax,0x4(%esp)
    7654:	e8 fc ff ff ff       	call   7655 <rlc_pkt_receive_from_mac+0xa95>
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
    7659:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    765c:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    7663:	0f bf c7             	movswl %di,%eax
    7666:	8b b4 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%esi
    766d:	85 f6                	test   %esi,%esi
    766f:	0f 84 3f f8 ff ff    	je     6eb4 <rlc_pkt_receive_from_mac+0x2f4>
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
    7675:	c7 04 24 c4 24 00 00 	movl   $0x24c4,(%esp)
    767c:	e8 fc ff ff ff       	call   767d <rlc_pkt_receive_from_mac+0xabd>
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7681:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7684:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    768b:	83 c0 01             	add    $0x1,%eax
    768e:	89 c2                	mov    %eax,%edx
    7690:	c1 fa 1f             	sar    $0x1f,%edx
    7693:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7695:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7698:	89 d7                	mov    %edx,%edi
    769a:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    76a1:	8b 94 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%edx
    76a8:	85 d2                	test   %edx,%edx
    76aa:	74 37                	je     76e3 <rlc_pkt_receive_from_mac+0xb23>
    76ac:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    76b3:	66 39 f7             	cmp    %si,%di
    76b6:	7e 0d                	jle    76c5 <rlc_pkt_receive_from_mac+0xb05>
    76b8:	eb 29                	jmp    76e3 <rlc_pkt_receive_from_mac+0xb23>
    76ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    76c0:	66 39 f2             	cmp    %si,%dx
    76c3:	7f 17                	jg     76dc <rlc_pkt_receive_from_mac+0xb1c>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    76c5:	83 c0 01             	add    $0x1,%eax
    76c8:	89 c2                	mov    %eax,%edx
    76ca:	c1 fa 1f             	sar    $0x1f,%edx
    76cd:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    76cf:	0f bf c2             	movswl %dx,%eax
    76d2:	83 bc 81 b8 00 00 00 	cmpl   $0x0,0xb8(%ecx,%eax,4)
    76d9:	00 
    76da:	75 e4                	jne    76c0 <rlc_pkt_receive_from_mac+0xb00>
    76dc:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    76e3:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    76e6:	89 44 24 04          	mov    %eax,0x4(%esp)
    76ea:	c7 04 24 08 24 00 00 	movl   $0x2408,(%esp)
    76f1:	e8 fc ff ff ff       	call   76f2 <rlc_pkt_receive_from_mac+0xb32>
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    76f6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    76f9:	8d 51 18             	lea    0x18(%ecx),%edx
    76fc:	89 c8                	mov    %ecx,%eax
    76fe:	e8 fc ff ff ff       	call   76ff <rlc_pkt_receive_from_mac+0xb3f>
    7703:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7706:	e9 a2 f7 ff ff       	jmp    6ead <rlc_pkt_receive_from_mac+0x2ed>
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    770b:	83 b8 90 00 00 00 01 	cmpl   $0x1,0x90(%eax)
    7712:	0f 85 1a fa ff ff    	jne    7132 <rlc_pkt_receive_from_mac+0x572>
				(amIns->amRecvWindow[SN]->segnum == 1)&&(amIns->amRecvWindow[SN]->segStart[0] == 0))
    7718:	8b 48 10             	mov    0x10(%eax),%ecx
    771b:	85 c9                	test   %ecx,%ecx
    771d:	0f 85 0f fa ff ff    	jne    7132 <rlc_pkt_receive_from_mac+0x572>
			{
				amIns->amRecvWindow[SN]->pktstatus = FULL_SDU;
    7723:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    772a:	e9 03 fa ff ff       	jmp    7132 <rlc_pkt_receive_from_mac+0x572>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
    772f:	c7 04 24 70 20 00 00 	movl   $0x2070,(%esp)
    7736:	e8 fc ff ff ff       	call   7737 <rlc_pkt_receive_from_mac+0xb77>
		amIns->vr_r = (amIns->vr_r+1)%1024;
    773b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    773e:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    7745:	83 c0 01             	add    $0x1,%eax
    7748:	89 c2                	mov    %eax,%edx
    774a:	c1 fa 1f             	sar    $0x1f,%edx
    774d:	c1 ea 16             	shr    $0x16,%edx
    7750:	01 d0                	add    %edx,%eax
    7752:	25 ff 03 00 00       	and    $0x3ff,%eax
    7757:	29 d0                	sub    %edx,%eax
    7759:	66 89 83 f4 22 00 00 	mov    %ax,0x22f4(%ebx)
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7760:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7767:	85 d2                	test   %edx,%edx
    7769:	74 39                	je     77a4 <rlc_pkt_receive_from_mac+0xbe4>
    776b:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    776f:	75 33                	jne    77a4 <rlc_pkt_receive_from_mac+0xbe4>
    7771:	89 d9                	mov    %ebx,%ecx
    7773:	eb 09                	jmp    777e <rlc_pkt_receive_from_mac+0xbbe>
    7775:	8d 76 00             	lea    0x0(%esi),%esi
    7778:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    777c:	75 26                	jne    77a4 <rlc_pkt_receive_from_mac+0xbe4>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
    777e:	83 c0 01             	add    $0x1,%eax
    7781:	89 c2                	mov    %eax,%edx
    7783:	c1 fa 1f             	sar    $0x1f,%edx
    7786:	c1 ea 16             	shr    $0x16,%edx
    7789:	01 d0                	add    %edx,%eax
    778b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7790:	29 d0                	sub    %edx,%eax
    7792:	66 89 81 f4 22 00 00 	mov    %ax,0x22f4(%ecx)
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
		amIns->vr_r = (amIns->vr_r+1)%1024;
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7799:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    77a0:	85 d2                	test   %edx,%edx
    77a2:	75 d4                	jne    7778 <rlc_pkt_receive_from_mac+0xbb8>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
		}
		amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 1024;
    77a4:	05 00 02 00 00       	add    $0x200,%eax
    77a9:	89 c2                	mov    %eax,%edx
    77ab:	c1 fa 1f             	sar    $0x1f,%edx
    77ae:	c1 ea 16             	shr    $0x16,%edx
    77b1:	01 d0                	add    %edx,%eax
    77b3:	25 ff 03 00 00       	and    $0x3ff,%eax
    77b8:	29 d0                	sub    %edx,%eax
    77ba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    77bd:	66 89 82 ec 22 00 00 	mov    %ax,0x22ec(%edx)
		//amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_r is updated to %d, amIns->vr_mr is updated to %d\n",amIns->vr_r, amIns->vr_mr);
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
    77c4:	c7 04 24 a8 20 00 00 	movl   $0x20a8,(%esp)
    77cb:	e8 fc ff ff ff       	call   77cc <rlc_pkt_receive_from_mac+0xc0c>
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    77d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    77d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77d6:	83 c2 30             	add    $0x30,%edx
    77d9:	e8 fc ff ff ff       	call   77da <rlc_pkt_receive_from_mac+0xc1a>
    77de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77e1:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    77e8:	e9 d5 f9 ff ff       	jmp    71c2 <rlc_pkt_receive_from_mac+0x602>
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    77ed:	29 f2                	sub    %esi,%edx
    77ef:	83 c2 30             	add    $0x30,%edx
    77f2:	89 d6                	mov    %edx,%esi
    77f4:	c1 fe 1f             	sar    $0x1f,%esi
    77f7:	c1 ee 1b             	shr    $0x1b,%esi
    77fa:	01 f2                	add    %esi,%edx
    77fc:	83 e2 1f             	and    $0x1f,%edx
    77ff:	29 f2                	sub    %esi,%edx
    7801:	83 fa 0f             	cmp    $0xf,%edx
    7804:	0f 9e c2             	setle  %dl
    7807:	e9 10 f7 ff ff       	jmp    6f1c <rlc_pkt_receive_from_mac+0x35c>

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    780c:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7811:	e8 fc ff ff ff       	call   7812 <rlc_pkt_receive_from_mac+0xc52>
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7816:	8b 4d d0             	mov    -0x30(%ebp),%ecx

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    7819:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    781c:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    7820:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    7824:	83 e0 7f             	and    $0x7f,%eax
    7827:	c1 e0 08             	shl    $0x8,%eax
    782a:	09 d0                	or     %edx,%eax
    782c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
			if(0 == ambuf->pos)
    782f:	85 c0                	test   %eax,%eax
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7831:	89 42 08             	mov    %eax,0x8(%edx)
			if(0 == ambuf->pos)
    7834:	0f 85 e6 00 00 00    	jne    7920 <rlc_pkt_receive_from_mac+0xd60>
			{
				ambuf->pkt = pkt;
    783a:	89 1a                	mov    %ebx,(%edx)
    783c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7843:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7846:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
			ambuf->segnum = 1;
			ambuf->datalen = 0;
			if(extseghead->LSF == 1)
    784a:	8b 4d d0             	mov    -0x30(%ebp),%ecx
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
			ambuf->segnum = 1;
    784d:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    7854:	00 00 00 
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7857:	66 89 90 94 00 00 00 	mov    %dx,0x94(%eax)
			ambuf->segnum = 1;
			ambuf->datalen = 0;
    785e:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    7865:	00 00 00 
			if(extseghead->LSF == 1)
    7868:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    786c:	0f 89 9f 00 00 00    	jns    7911 <rlc_pkt_receive_from_mac+0xd51>
			{
				ambuf->pktstatus = LAST_SEGMENT;
    7872:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				ambuf->datalen = ambuf->pos + pkt->len;
    7879:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    787c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    787f:	03 43 50             	add    0x50(%ebx),%eax
    7882:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
    7888:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    788b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    788e:	89 50 10             	mov    %edx,0x10(%eax)
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7891:	8b 4b 50             	mov    0x50(%ebx),%ecx
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7894:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    789a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    789d:	31 c9                	xor    %ecx,%ecx
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    789f:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    78a3:	74 19                	je     78be <rlc_pkt_receive_from_mac+0xcfe>
	{
		count++;
		while(1 == (ind++)->E)
    78a5:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    78a9:	b1 01                	mov    $0x1,%cl
    78ab:	79 11                	jns    78be <rlc_pkt_receive_from_mac+0xcfe>
    78ad:	83 c0 06             	add    $0x6,%eax
    78b0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
		{
			count++;
    78b4:	83 c1 01             	add    $0x1,%ecx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    78b7:	83 c0 02             	add    $0x2,%eax
    78ba:	84 d2                	test   %dl,%dl
    78bc:	78 f2                	js     78b0 <rlc_pkt_receive_from_mac+0xcf0>
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    78be:	8b 45 d0             	mov    -0x30(%ebp),%eax
    78c1:	8b 5d cc             	mov    -0x34(%ebp),%ebx
    78c4:	8d 54 18 fc          	lea    -0x4(%eax,%ebx,1),%edx
    78c8:	0f b7 c1             	movzwl %cx,%eax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    78cb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    78ce:	f7 d8                	neg    %eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    78d0:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    78d3:	8d 04 42             	lea    (%edx,%eax,2),%eax
    78d6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    78d9:	89 42 50             	mov    %eax,0x50(%edx)
    78dc:	8b 81 60 02 00 00    	mov    0x260(%ecx),%eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    78e2:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    78e8:	89 91 60 02 00 00    	mov    %edx,0x260(%ecx)
    78ee:	81 c1 5c 02 00 00    	add    $0x25c,%ecx
    78f4:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    78fa:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    7900:	89 10                	mov    %edx,(%eax)
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been put into buffer(SN is %d)\n", SN);
			amIns->amRecvWindow[SN] = ambuf;
    7902:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7905:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7908:	89 5c 82 0c          	mov    %ebx,0xc(%edx,%eax,4)
    790c:	e9 21 f8 ff ff       	jmp    7132 <rlc_pkt_receive_from_mac+0x572>
				ambuf->datalen = ambuf->pos + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", ambuf->datalen );
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
    7911:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7914:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    791b:	e9 68 ff ff ff       	jmp    7888 <rlc_pkt_receive_from_mac+0xcc8>
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7920:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    7923:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
    7927:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    792b:	8b 4b 50             	mov    0x50(%ebx),%ecx
    792e:	83 e2 7f             	and    $0x7f,%edx
    7931:	c1 e2 08             	shl    $0x8,%edx
    7934:	09 c2                	or     %eax,%edx
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7936:	89 d8                	mov    %ebx,%eax
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7938:	01 ca                	add    %ecx,%edx
    793a:	89 55 cc             	mov    %edx,-0x34(%ebp)
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    793d:	e8 fc ff ff ff       	call   793e <rlc_pkt_receive_from_mac+0xd7e>
    7942:	03 45 cc             	add    -0x34(%ebp),%eax
    7945:	e8 fc ff ff ff       	call   7946 <rlc_pkt_receive_from_mac+0xd86>
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    794a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    7950:	89 55 c8             	mov    %edx,-0x38(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7953:	8b 4d c8             	mov    -0x38(%ebp),%ecx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    7956:	31 d2                	xor    %edx,%edx
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7958:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    795b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    7961:	89 45 c0             	mov    %eax,-0x40(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7964:	f6 41 01 04          	testb  $0x4,0x1(%ecx)
    7968:	74 1b                	je     7985 <rlc_pkt_receive_from_mac+0xdc5>
	{
		count++;
		while(1 == (ind++)->E)
    796a:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
    796e:	b2 01                	mov    $0x1,%dl
    7970:	79 13                	jns    7985 <rlc_pkt_receive_from_mac+0xdc5>
    7972:	89 c8                	mov    %ecx,%eax
    7974:	83 c0 06             	add    $0x6,%eax
    7977:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    797b:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    797e:	83 c0 02             	add    $0x2,%eax
    7981:	84 c9                	test   %cl,%cl
    7983:	78 f2                	js     7977 <rlc_pkt_receive_from_mac+0xdb7>
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7985:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7988:	8b 4b 50             	mov    0x50(%ebx),%ecx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    798b:	8b 40 08             	mov    0x8(%eax),%eax
    798e:	89 45 bc             	mov    %eax,-0x44(%ebp)
    7991:	0f b7 c2             	movzwl %dx,%eax
    7994:	8b 55 bc             	mov    -0x44(%ebp),%edx
    7997:	8d 44 42 04          	lea    0x4(%edx,%eax,2),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    799b:	8b 55 c8             	mov    -0x38(%ebp),%edx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    799e:	03 45 c0             	add    -0x40(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    79a1:	e8 fc ff ff ff       	call   79a2 <rlc_pkt_receive_from_mac+0xde2>
				fsm_skb_put(pkptr, datalen);
    79a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    79a9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    79ac:	e8 fc ff ff ff       	call   79ad <rlc_pkt_receive_from_mac+0xded>
				if(pkt != NULL)
    79b1:	85 db                	test   %ebx,%ebx
    79b3:	74 07                	je     79bc <rlc_pkt_receive_from_mac+0xdfc>
				{
					fsm_pkt_destroy(pkt);
    79b5:	89 d8                	mov    %ebx,%eax
    79b7:	e8 fc ff ff ff       	call   79b8 <rlc_pkt_receive_from_mac+0xdf8>
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
    79bc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    79bf:	31 db                	xor    %ebx,%ebx
    79c1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    79c4:	8b 48 08             	mov    0x8(%eax),%ecx
    79c7:	89 10                	mov    %edx,(%eax)
    79c9:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    79cc:	e9 72 fe ff ff       	jmp    7843 <rlc_pkt_receive_from_mac+0xc83>
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
		{
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    79d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    79d4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    79db:	89 d8                	mov    %ebx,%eax
    79dd:	e8 fc ff ff ff       	call   79de <rlc_pkt_receive_from_mac+0xe1e>
			printk("rlc_macfsm 4361\n");
    79e2:	c7 04 24 86 04 00 00 	movl   $0x486,(%esp)
    79e9:	e8 fc ff ff ff       	call   79ea <rlc_pkt_receive_from_mac+0xe2a>
    79ee:	e9 8f f2 ff ff       	jmp    6c82 <rlc_pkt_receive_from_mac+0xc2>
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
		{
			printk("[RLC][rlc_AM_pkt_receive_from_mac] PDU segment is outside the receiving window or the segment has been received\n");
    79f3:	c7 04 24 24 1f 00 00 	movl   $0x1f24,(%esp)
    79fa:	e8 fc ff ff ff       	call   79fb <rlc_pkt_receive_from_mac+0xe3b>
			printk("[RLC][rlc_AM_pkt_receive_from_mac] A packet has dropped\n");
    79ff:	c7 04 24 50 1e 00 00 	movl   $0x1e50,(%esp)
    7a06:	e8 fc ff ff ff       	call   7a07 <rlc_pkt_receive_from_mac+0xe47>
			SV(countDropPacket)++;
    7a0b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a0e:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			if(pkt != NULL)
    7a15:	85 db                	test   %ebx,%ebx
    7a17:	0f 84 5f f8 ff ff    	je     727c <rlc_pkt_receive_from_mac+0x6bc>
			{
				fsm_pkt_destroy(pkt);
    7a1d:	89 d8                	mov    %ebx,%eax
    7a1f:	e8 fc ff ff ff       	call   7a20 <rlc_pkt_receive_from_mac+0xe60>
    7a24:	e9 53 f8 ff ff       	jmp    727c <rlc_pkt_receive_from_mac+0x6bc>
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
    7a29:	89 74 24 04          	mov    %esi,0x4(%esp)
    7a2d:	c7 04 24 94 22 00 00 	movl   $0x2294,(%esp)
    7a34:	e8 fc ff ff ff       	call   7a35 <rlc_pkt_receive_from_mac+0xe75>
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7a39:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7a3c:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7a43:	89 d8                	mov    %ebx,%eax
    7a45:	e8 fc ff ff ff       	call   7a46 <rlc_pkt_receive_from_mac+0xe86>
			printk("rlc_macfsm 4328\n");
    7a4a:	c7 04 24 75 04 00 00 	movl   $0x475,(%esp)
    7a51:	e8 fc ff ff ff       	call   7a52 <rlc_pkt_receive_from_mac+0xe92>
    7a56:	e9 27 f2 ff ff       	jmp    6c82 <rlc_pkt_receive_from_mac+0xc2>
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7a5b:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7a5f:	c7 04 24 d0 1d 00 00 	movl   $0x1dd0,(%esp)
    7a66:	89 44 24 04          	mov    %eax,0x4(%esp)
    7a6a:	e8 fc ff ff ff       	call   7a6b <rlc_pkt_receive_from_mac+0xeab>
				break;
    7a6f:	e9 57 f2 ff ff       	jmp    6ccb <rlc_pkt_receive_from_mac+0x10b>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
    7a74:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7a78:	c7 04 24 8c 1d 00 00 	movl   $0x1d8c,(%esp)
    7a7f:	89 44 24 04          	mov    %eax,0x4(%esp)
    7a83:	e8 fc ff ff ff       	call   7a84 <rlc_pkt_receive_from_mac+0xec4>
				break;
    7a88:	e9 3e f2 ff ff       	jmp    6ccb <rlc_pkt_receive_from_mac+0x10b>
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7a8d:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7a91:	c7 04 24 b4 21 00 00 	movl   $0x21b4,(%esp)
    7a98:	89 44 24 04          	mov    %eax,0x4(%esp)
    7a9c:	e8 fc ff ff ff       	call   7a9d <rlc_pkt_receive_from_mac+0xedd>
				break;
    7aa1:	e9 25 f2 ff ff       	jmp    6ccb <rlc_pkt_receive_from_mac+0x10b>
			break;

		case UM_MODE:
			if(insptrd == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
    7aa6:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7aaa:	c7 04 24 70 21 00 00 	movl   $0x2170,(%esp)
    7ab1:	89 44 24 04          	mov    %eax,0x4(%esp)
    7ab5:	e8 fc ff ff ff       	call   7ab6 <rlc_pkt_receive_from_mac+0xef6>
				break;
    7aba:	e9 0c f2 ff ff       	jmp    6ccb <rlc_pkt_receive_from_mac+0x10b>
    7abf:	90                   	nop

00007ac0 <MACCETA_handle>:
//HQ
/**
 * @function: deal with Timing Advance control element
 * @param ta_index: Timing Advance Command
 */
void MACCETA_handle(unsigned char ta_index) {   
    7ac0:	55                   	push   %ebp
    7ac1:	89 e5                	mov    %esp,%ebp
    7ac3:	56                   	push   %esi
    7ac4:	53                   	push   %ebx
    7ac5:	e8 fc ff ff ff       	call   7ac6 <MACCETA_handle+0x6>
    7aca:	89 c6                	mov    %eax,%esi
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7acc:	e8 fc ff ff ff       	call   7acd <MACCETA_handle+0xd>
    if(SV(TATimer.flag)==true)
    7ad1:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
 */
void MACCETA_handle(unsigned char ta_index) {   
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7ad8:	89 c3                	mov    %eax,%ebx
    if(SV(TATimer.flag)==true)
    7ada:	74 0b                	je     7ae7 <MACCETA_handle+0x27>
        fsm_schedule_cancel(SV(TATimer.timer_sign));
    7adc:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    7ae2:	e8 fc ff ff ff       	call   7ae3 <MACCETA_handle+0x23>
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7ae7:	8b 43 24             	mov    0x24(%ebx),%eax
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7aea:	81 e6 ff 00 00 00    	and    $0xff,%esi
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7af0:	ba 0b 00 00 00       	mov    $0xb,%edx
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7af5:	83 ee 1f             	sub    $0x1f,%esi
    7af8:	c1 e6 04             	shl    $0x4,%esi
    7afb:	66 01 73 22          	add    %si,0x22(%ebx)
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7aff:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7b05:	6b c0 64             	imul   $0x64,%eax,%eax
    7b08:	e8 fc ff ff ff       	call   7b09 <MACCETA_handle+0x49>
	SV(TATimer.flag)=true;
    7b0d:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7b14:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
	SV(TATimer.flag)=true;
		
FOUT;
}
    7b1a:	5b                   	pop    %ebx
    7b1b:	5e                   	pop    %esi
    7b1c:	5d                   	pop    %ebp
    7b1d:	c3                   	ret    
    7b1e:	66 90                	xchg   %ax,%ax

00007b20 <decomplexRarPdu>:
/**
 * @function: decomplex the RAR PDU to get the MAC RAR that belongs to the user
 * @param skb: the sk_buff that contains the RAR PDU
 * @return: is there MAC RAR in the RAR PDU that belongs to the user
 */
bool decomplexRarPdu(FSM_PKT *skb){		//RAR SDU	//RAR
    7b20:	55                   	push   %ebp
    7b21:	89 e5                	mov    %esp,%ebp
    7b23:	57                   	push   %edi
    7b24:	56                   	push   %esi
    7b25:	53                   	push   %ebx
    7b26:	83 ec 3c             	sub    $0x3c,%esp
    7b29:	e8 fc ff ff ff       	call   7b2a <decomplexRarPdu+0xa>
    7b2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
	MAC_RAR_subhead_withbi *bi_subhead=(MAC_RAR_subhead_withbi*)fsm_mem_alloc(sizeof(MAC_RAR_subhead_withbi));	//20140430
    7b31:	b8 01 00 00 00       	mov    $0x1,%eax
    7b36:	e8 fc ff ff ff       	call   7b37 <decomplexRarPdu+0x17>
    7b3b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
    7b3e:	b8 01 00 00 00       	mov    $0x1,%eax
    7b43:	e8 fc ff ff ff       	call   7b44 <decomplexRarPdu+0x24>
    7b48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
    7b4b:	b8 06 00 00 00       	mov    $0x6,%eax
    7b50:	e8 fc ff ff ff       	call   7b51 <decomplexRarPdu+0x31>
    7b55:	89 45 d8             	mov    %eax,-0x28(%ebp)
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
    7b58:	b8 04 00 00 00       	mov    $0x4,%eax
    7b5d:	e8 fc ff ff ff       	call   7b5e <decomplexRarPdu+0x3e>
    7b62:	89 45 cc             	mov    %eax,-0x34(%ebp)
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));
    7b65:	b8 07 00 00 00       	mov    $0x7,%eax
    7b6a:	e8 fc ff ff ff       	call   7b6b <decomplexRarPdu+0x4b>
    7b6f:	89 45 c8             	mov    %eax,-0x38(%ebp)

	SV_PTR_GET(rlc_mac_sv);
    7b72:	e8 fc ff ff ff       	call   7b73 <decomplexRarPdu+0x53>
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7b77:	31 d2                	xor    %edx,%edx
    7b79:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));

	SV_PTR_GET(rlc_mac_sv);
    7b7e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7b81:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7b84:	e8 fc ff ff ff       	call   7b85 <decomplexRarPdu+0x65>
	fsm_mem_set(rar_subhead,0,sizeof(MAC_RAR_subhead));	//20140430
    7b89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7b8c:	31 d2                	xor    %edx,%edx
    7b8e:	b9 01 00 00 00       	mov    $0x1,%ecx
    7b93:	e8 fc ff ff ff       	call   7b94 <decomplexRarPdu+0x74>
	fsm_mem_set(rar_sdu,0,sizeof(MAC_RAR_sdu));	//20140430
    7b98:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7b9b:	31 d2                	xor    %edx,%edx
    7b9d:	b9 06 00 00 00       	mov    $0x6,%ecx
    7ba2:	e8 fc ff ff ff       	call   7ba3 <decomplexRarPdu+0x83>
	fsm_mem_set(rar_ulgrant,0,sizeof(RAR_ULgrant));	//20141111modified
    7ba7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7baa:	31 d2                	xor    %edx,%edx
    7bac:	b9 04 00 00 00       	mov    $0x4,%ecx
    7bb1:	e8 fc ff ff ff       	call   7bb2 <decomplexRarPdu+0x92>
	fsm_mem_set(phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    7bb6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7bb9:	31 d2                	xor    %edx,%edx
    7bbb:	b9 07 00 00 00       	mov    $0x7,%ecx
    7bc0:	e8 fc ff ff ff       	call   7bc1 <decomplexRarPdu+0xa1>
		fsm_printf("%c,",*((char *)skb->data+offset));
	}
	fsm_printf("\n");*/
	//fsm_octets_print(newskb->data,4);
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
    7bc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7bc8:	b9 01 00 00 00       	mov    $0x1,%ecx
    7bcd:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    7bd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7bd6:	e8 fc ff ff ff       	call   7bd7 <decomplexRarPdu+0xb7>
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
    7bdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7bde:	0f b6 10             	movzbl (%eax),%edx
    7be1:	89 d0                	mov    %edx,%eax
    7be3:	c0 e8 06             	shr    $0x6,%al
    7be6:	0f b6 c0             	movzbl %al,%eax
	if(typ_flag==0||typ_flag==2){		//BI
    7be9:	83 f8 02             	cmp    $0x2,%eax
    7bec:	0f 84 5e 01 00 00    	je     7d50 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7bf2:	31 ff                	xor    %edi,%edi
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
    7bf4:	85 c0                	test   %eax,%eax
    7bf6:	0f 84 54 01 00 00    	je     7d50 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7bfc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7bff:	8b 75 e0             	mov    -0x20(%ebp),%esi
    7c02:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7c09:	89 7d ec             	mov    %edi,-0x14(%ebp)
    7c0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7c10:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    7c16:	b9 01 00 00 00       	mov    $0x1,%ecx
    7c1b:	89 d8                	mov    %ebx,%eax
	else{
		continue_flag=true;
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
    7c1d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7c21:	01 fa                	add    %edi,%edx
		from_len=from_len+sizeof(MAC_RAR_subhead);
    7c23:	83 c7 01             	add    $0x1,%edi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7c26:	e8 fc ff ff ff       	call   7c27 <decomplexRarPdu+0x107>
		from_len=from_len+sizeof(MAC_RAR_subhead);
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
    7c2b:	80 3b 00             	cmpb   $0x0,(%ebx)
    7c2e:	78 e0                	js     7c10 <decomplexRarPdu+0xf0>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7c30:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7c33:	89 fe                	mov    %edi,%esi
    7c35:	89 74 24 08          	mov    %esi,0x8(%esp)
    7c39:	8b 7d ec             	mov    -0x14(%ebp),%edi
    7c3c:	c7 04 24 78 26 00 00 	movl   $0x2678,(%esp)
    7c43:	89 44 24 04          	mov    %eax,0x4(%esp)
    7c47:	e8 fc ff ff ff       	call   7c48 <decomplexRarPdu+0x128>

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7c4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7c4f:	85 c0                	test   %eax,%eax
    7c51:	0f 84 f3 00 00 00    	je     7d4a <decomplexRarPdu+0x22a>
    7c57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    7c5e:	eb 4a                	jmp    7caa <decomplexRarPdu+0x18a>
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7c60:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7c64:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7c68:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7c6f:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7c73:	e8 fc ff ff ff       	call   7c74 <decomplexRarPdu+0x154>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7c78:	0f bf 55 d6          	movswl -0x2a(%ebp),%edx
    7c7c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    7c7f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7c83:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    7c8a:	e8 fc ff ff ff       	call   7c8b <decomplexRarPdu+0x16b>
		if(rapid_in_subhead==my_id){	//RAR
    7c8f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7c92:	39 da                	cmp    %ebx,%edx
    7c94:	0f 84 1f 01 00 00    	je     7db9 <decomplexRarPdu+0x299>
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7c9a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7c9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ca1:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7ca4:	0f 84 a0 00 00 00    	je     7d4a <decomplexRarPdu+0x22a>
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7caa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7cad:	89 fa                	mov    %edi,%edx
    7caf:	b9 01 00 00 00       	mov    $0x1,%ecx
		head_len=head_len+len;
    7cb4:	83 c7 01             	add    $0x1,%edi

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7cb7:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7cbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7cc0:	e8 fc ff ff ff       	call   7cc1 <decomplexRarPdu+0x1a1>
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7cc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7cc8:	0f b6 18             	movzbl (%eax),%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7ccb:	c7 04 24 a4 04 00 00 	movl   $0x4a4,(%esp)

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7cd2:	83 e3 3f             	and    $0x3f,%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7cd5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7cd9:	e8 fc ff ff ff       	call   7cda <decomplexRarPdu+0x1ba>

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7cde:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7ce1:	89 f2                	mov    %esi,%edx
    7ce3:	b9 06 00 00 00       	mov    $0x6,%ecx

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
    7ce8:	83 c6 06             	add    $0x6,%esi
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7ceb:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7cf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7cf4:	e8 fc ff ff ff       	call   7cf5 <decomplexRarPdu+0x1d5>

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
    7cf9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7cfc:	8b 82 fc 01 00 00    	mov    0x1fc(%edx),%eax
    7d02:	85 c0                	test   %eax,%eax
    7d04:	0f 84 56 ff ff ff    	je     7c60 <decomplexRarPdu+0x140>
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
			
		}
		else
		{
			SV(rar_failed_num)=SV(rar_failed_num)-1;
    7d0a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d0d:	83 e8 01             	sub    $0x1,%eax
    7d10:	89 82 fc 01 00 00    	mov    %eax,0x1fc(%edx)
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7d16:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7d1a:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
    7d21:	e8 fc ff ff ff       	call   7d22 <decomplexRarPdu+0x202>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7d26:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
    7d2d:	00 
    7d2e:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    7d35:	e8 fc ff ff ff       	call   7d36 <decomplexRarPdu+0x216>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7d3a:	8b 55 e8             	mov    -0x18(%ebp),%edx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7d3d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7d41:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7d44:	0f 85 60 ff ff ff    	jne    7caa <decomplexRarPdu+0x18a>
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7d4a:	31 db                	xor    %ebx,%ebx
    7d4c:	eb 2f                	jmp    7d7d <decomplexRarPdu+0x25d>
    7d4e:	66 90                	xchg   %ax,%ax
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7d50:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7d53:	89 d0                	mov    %edx,%eax
    7d55:	83 e0 0f             	and    $0xf,%eax
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7d58:	84 d2                	test   %dl,%dl
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7d5a:	89 41 1c             	mov    %eax,0x1c(%ecx)
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7d5d:	78 50                	js     7daf <decomplexRarPdu+0x28f>
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7d5f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    7d66:	00 
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7d67:	31 db                	xor    %ebx,%ebx
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7d69:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    7d70:	00 
    7d71:	c7 04 24 78 26 00 00 	movl   $0x2678,(%esp)
    7d78:	e8 fc ff ff ff       	call   7d79 <decomplexRarPdu+0x259>
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
	}
	fsm_mem_free(bi_subhead);
    7d7d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7d80:	e8 fc ff ff ff       	call   7d81 <decomplexRarPdu+0x261>
	fsm_mem_free(rar_subhead);
    7d85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d88:	e8 fc ff ff ff       	call   7d89 <decomplexRarPdu+0x269>
	fsm_mem_free(rar_sdu);
    7d8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7d90:	e8 fc ff ff ff       	call   7d91 <decomplexRarPdu+0x271>
	fsm_mem_free(rar_ulgrant);	//20141111modified
    7d95:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7d98:	e8 fc ff ff ff       	call   7d99 <decomplexRarPdu+0x279>
	fsm_mem_free(phy_ici);
    7d9d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7da0:	e8 fc ff ff ff       	call   7da1 <decomplexRarPdu+0x281>
	FRET(return_value);
}
    7da5:	89 d8                	mov    %ebx,%eax
    7da7:	83 c4 3c             	add    $0x3c,%esp
    7daa:	5b                   	pop    %ebx
    7dab:	5e                   	pop    %esi
    7dac:	5f                   	pop    %edi
    7dad:	5d                   	pop    %ebp
    7dae:	c3                   	ret    
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
		SV(backoff_index)=bi;
		from_len=from_len+len;
    7daf:	bf 01 00 00 00       	mov    $0x1,%edi
    7db4:	e9 43 fe ff ff       	jmp    7bfc <decomplexRarPdu+0xdc>
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
    7db9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7dbc:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7dbf:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    7dc3:	66 89 42 02          	mov    %ax,0x2(%edx)
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
    7dc7:	89 44 24 04          	mov    %eax,0x4(%esp)
    7dcb:	c7 04 24 e2 04 00 00 	movl   $0x4e2,(%esp)
    7dd2:	e8 fc ff ff ff       	call   7dd3 <decomplexRarPdu+0x2b3>
			
			tadvance=(rar_sdu->m_r_ta)&127;
    7dd7:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7dda:	0f b6 01             	movzbl (%ecx),%eax
			tadvance=tadvance<<4;
    7ddd:	89 c2                	mov    %eax,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7ddf:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
			
			tadvance=(rar_sdu->m_r_ta)&127;
			tadvance=tadvance<<4;
    7de3:	83 e2 7f             	and    $0x7f,%edx
    7de6:	c1 e2 04             	shl    $0x4,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7de9:	c0 e8 04             	shr    $0x4,%al
    7dec:	0f b6 c0             	movzbl %al,%eax
    7def:	01 d0                	add    %edx,%eax
    7df1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7df4:	66 89 42 20          	mov    %ax,0x20(%edx)
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
    7df8:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			ul_grant=ul_grant<<12;
    7dfc:	c1 e0 10             	shl    $0x10,%eax
    7dff:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7e02:	0f b7 51 02          	movzwl 0x2(%ecx),%edx
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7e06:	b9 04 00 00 00       	mov    $0x4,%ecx
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
			ul_grant=ul_grant<<12;
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7e0b:	01 d0                	add    %edx,%eax
    7e0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7e10:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7e13:	8d 55 f0             	lea    -0x10(%ebp),%edx
    7e16:	e8 fc ff ff ff       	call   7e17 <decomplexRarPdu+0x2f7>
			//m_tb_size=DoReceiveRARULgrant_Tbsize(ul_grant);	//make		//20140428 

			SV(recv_frame).frameNo=phy_ici->frameNo;	//add on 11,17.2014
    7e1b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    7e1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7e21:	0f b7 41 03          	movzwl 0x3(%ecx),%eax
    7e25:	66 89 42 0a          	mov    %ax,0xa(%edx)
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014
    7e29:	0f b7 41 05          	movzwl 0x5(%ecx),%eax
    7e2d:	66 89 42 0c          	mov    %ax,0xc(%edx)

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
    7e31:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7e34:	e8 fc ff ff ff       	call   7e35 <decomplexRarPdu+0x315>
    7e39:	89 c3                	mov    %eax,%ebx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
    7e3b:	89 44 24 04          	mov    %eax,0x4(%esp)
    7e3f:	c7 04 24 fc 04 00 00 	movl   $0x4fc,(%esp)
    7e46:	e8 fc ff ff ff       	call   7e47 <decomplexRarPdu+0x327>
			SV(UL_resource_info).m_tbsize=m_tb_size;		
    7e4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7e4e:	89 58 2c             	mov    %ebx,0x2c(%eax)
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
    7e51:	bb 01 00 00 00       	mov    $0x1,%ebx
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
    7e56:	c6 40 28 01          	movb   $0x1,0x28(%eax)
			break;
    7e5a:	e9 1e ff ff ff       	jmp    7d7d <decomplexRarPdu+0x25d>
    7e5f:	90                   	nop

00007e60 <lteMacCEC_rntiSend>:
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    7e60:	55                   	push   %ebp
    7e61:	89 e5                	mov    %esp,%ebp
    7e63:	83 ec 10             	sub    $0x10,%esp
    7e66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    7e69:	89 75 f8             	mov    %esi,-0x8(%ebp)
    7e6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    7e6f:	e8 fc ff ff ff       	call   7e70 <lteMacCEC_rntiSend+0x10>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7e74:	31 db                	xor    %ebx,%ebx
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    7e76:	89 c7                	mov    %eax,%edi
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
    7e78:	e8 fc ff ff ff       	call   7e79 <lteMacCEC_rntiSend+0x19>
    7e7d:	89 c6                	mov    %eax,%esi
    7e7f:	90                   	nop
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
    7e80:	80 bc de a5 01 00 00 	cmpb   $0x1b,0x1a5(%esi,%ebx,8)
    7e87:	1b 
    7e88:	74 1e                	je     7ea8 <lteMacCEC_rntiSend+0x48>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7e8a:	83 c3 01             	add    $0x1,%ebx
    7e8d:	83 fb 08             	cmp    $0x8,%ebx
    7e90:	75 ee                	jne    7e80 <lteMacCEC_rntiSend+0x20>
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    7e92:	8b 5d f4             	mov    -0xc(%ebp),%ebx
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
    7e95:	31 c0                	xor    %eax,%eax
}
    7e97:	8b 75 f8             	mov    -0x8(%ebp),%esi
    7e9a:	8b 7d fc             	mov    -0x4(%ebp),%edi
    7e9d:	89 ec                	mov    %ebp,%esp
    7e9f:	5d                   	pop    %ebp
    7ea0:	c3                   	ret    
    7ea1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    7ea8:	83 c3 34             	add    $0x34,%ebx
	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");
    7eab:	c7 04 24 a4 26 00 00 	movl   $0x26a4,(%esp)
    7eb2:	e8 fc ff ff ff       	call   7eb3 <lteMacCEC_rntiSend+0x53>

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    7eb7:	8b 44 de 08          	mov    0x8(%esi,%ebx,8),%eax
    7ebb:	0f b7 00             	movzwl (%eax),%eax
    7ebe:	66 89 07             	mov    %ax,(%edi)
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    7ec1:	8b 7d fc             	mov    -0x4(%ebp),%edi

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
			
			//fsm_printf("[MAC CRNTI]RNTI IN SV:%d\n",SV(C_RNTI));
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    7ec4:	0f b6 44 de 04       	movzbl 0x4(%esi,%ebx,8),%eax
		}
	}
	
	FRET(false);
}
    7ec9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    7ecc:	8b 75 f8             	mov    -0x8(%ebp),%esi
    7ecf:	89 ec                	mov    %ebp,%esp
    7ed1:	5d                   	pop    %ebp
    7ed2:	c3                   	ret    
    7ed3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00007ee0 <lteMacCEPhSend>:
/**
 * @function: fill in the Power Headroom control element
 * @param m_power_headroom: the structure of Power Headroom control element
 * @return: is there Power Headroom control element tfsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);o send
 */
bool lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom){		//
    7ee0:	55                   	push   %ebp
    7ee1:	89 e5                	mov    %esp,%ebp
    7ee3:	e8 fc ff ff ff       	call   7ee4 <lteMacCEPhSend+0x4>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
    7ee8:	e8 fc ff ff ff       	call   7ee9 <lteMacCEPhSend+0x9>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7eed:	31 d2                	xor    %edx,%edx
    7eef:	90                   	nop
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
    7ef0:	80 bc d0 a5 01 00 00 	cmpb   $0x1a,0x1a5(%eax,%edx,8)
    7ef7:	1a 
    7ef8:	74 0e                	je     7f08 <lteMacCEPhSend+0x28>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7efa:	83 c2 01             	add    $0x1,%edx
    7efd:	83 fa 08             	cmp    $0x8,%edx
    7f00:	75 ee                	jne    7ef0 <lteMacCEPhSend+0x10>
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	FRET(false);
    7f02:	31 c0                	xor    %eax,%eax
}
    7f04:	5d                   	pop    %ebp
    7f05:	c3                   	ret    
    7f06:	66 90                	xchg   %ax,%ax

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    7f08:	0f b6 84 d0 a4 01 00 	movzbl 0x1a4(%eax,%edx,8),%eax
    7f0f:	00 
		}
	}
	FRET(false);
}
    7f10:	5d                   	pop    %ebp
    7f11:	c3                   	ret    
    7f12:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    7f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00007f20 <lteMacCcchSend>:
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7f20:	55                   	push   %ebp
    7f21:	89 e5                	mov    %esp,%ebp
    7f23:	57                   	push   %edi
    7f24:	56                   	push   %esi
    7f25:	53                   	push   %ebx
    7f26:	83 ec 2c             	sub    $0x2c,%esp
    7f29:	e8 fc ff ff ff       	call   7f2a <lteMacCcchSend+0xa>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    7f2e:	bf 1f 00 00 00       	mov    $0x1f,%edi
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7f33:	89 45 f0             	mov    %eax,-0x10(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    7f36:	b8 0a 00 00 00       	mov    $0xa,%eax
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7f3b:	89 55 ec             	mov    %edx,-0x14(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    7f3e:	e8 fc ff ff ff       	call   7f3f <lteMacCcchSend+0x1f>
    7f43:	89 45 e0             	mov    %eax,-0x20(%ebp)
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
    7f46:	b8 01 00 00 00       	mov    $0x1,%eax
    7f4b:	e8 fc ff ff ff       	call   7f4c <lteMacCcchSend+0x2c>
    7f50:	89 c3                	mov    %eax,%ebx
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    7f52:	b8 03 00 00 00       	mov    $0x3,%eax
    7f57:	e8 fc ff ff ff       	call   7f58 <lteMacCcchSend+0x38>
    7f5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    7f5f:	e8 fc ff ff ff       	call   7f60 <lteMacCcchSend+0x40>
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    7f64:	31 d2                	xor    %edx,%edx
    7f66:	b9 0a 00 00 00       	mov    $0xa,%ecx
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    7f6b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    7f6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f71:	e8 fc ff ff ff       	call   7f72 <lteMacCcchSend+0x52>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    7f76:	31 d2                	xor    %edx,%edx
    7f78:	b9 02 00 00 00       	mov    $0x2,%ecx
    7f7d:	89 d8                	mov    %ebx,%eax
    7f7f:	e8 fc ff ff ff       	call   7f80 <lteMacCcchSend+0x60>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
    7f84:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f87:	31 d2                	xor    %edx,%edx
    7f89:	b9 03 00 00 00       	mov    $0x3,%ecx
    7f8e:	e8 fc ff ff ff       	call   7f8f <lteMacCcchSend+0x6f>
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    7f93:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7f96:	b9 02 00 00 00       	mov    $0x2,%ecx
    7f9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7f9e:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    7fa4:	89 d8                	mov    %ebx,%eax
    7fa6:	e8 fc ff ff ff       	call   7fa7 <lteMacCcchSend+0x87>
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    7fab:	0f b6 13             	movzbl (%ebx),%edx
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    7fae:	21 d7                	and    %edx,%edi
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    7fb0:	89 d0                	mov    %edx,%eax
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    7fb2:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    7fb6:	c0 e8 05             	shr    $0x5,%al
    7fb9:	0f b6 f0             	movzbl %al,%esi
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    7fbc:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    7fc0:	c0 ea 07             	shr    $0x7,%dl
    7fc3:	0f b6 d2             	movzbl %dl,%edx
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    7fc6:	89 54 24 0c          	mov    %edx,0xc(%esp)
    7fca:	89 55 d8             	mov    %edx,-0x28(%ebp)
    7fcd:	89 74 24 04          	mov    %esi,0x4(%esp)
    7fd1:	c7 04 24 cc 26 00 00 	movl   $0x26cc,(%esp)
    7fd8:	e8 fc ff ff ff       	call   7fd9 <lteMacCcchSend+0xb9>
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    7fdd:	83 fe 01             	cmp    $0x1,%esi
    7fe0:	8b 55 d8             	mov    -0x28(%ebp),%edx
	/*for(i=0;i<4;i++){
		fsm_printf("%c,",*(skb->data+i));
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
    7fe3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	
	while(continue_flag==1){
    7fea:	0f 85 7d 00 00 00    	jne    806d <lteMacCcchSend+0x14d>
		if(lcid==0){								//ccch
    7ff0:	85 ff                	test   %edi,%edi
    7ff2:	0f 84 ab 00 00 00    	je     80a3 <lteMacCcchSend+0x183>
    7ff8:	66 31 f6             	xor    %si,%si
    7ffb:	31 ff                	xor    %edi,%edi
    7ffd:	eb 44                	jmp    8043 <lteMacCcchSend+0x123>
    7fff:	90                   	nop
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    8000:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
    8004:	83 c6 02             	add    $0x2,%esi
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    8007:	83 e0 7f             	and    $0x7f,%eax
				offset=offset+sdu_len;
    800a:	01 c7                	add    %eax,%edi
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    800c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    800f:	b9 02 00 00 00       	mov    $0x2,%ecx
    8014:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8017:	01 f2                	add    %esi,%edx
    8019:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    801f:	89 d8                	mov    %ebx,%eax
    8021:	e8 fc ff ff ff       	call   8022 <lteMacCcchSend+0x102>
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8026:	0f b6 03             	movzbl (%ebx),%eax
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    8029:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    802d:	89 c1                	mov    %eax,%ecx
				sdu_len=(m_7bit_subhead->m_f_l)&127;
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    802f:	c0 e8 05             	shr    $0x5,%al
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    8032:	83 e1 1f             	and    $0x1f,%ecx
		f_domain=m_7bit_subhead->m_f_l>>7;
    8035:	c0 ea 07             	shr    $0x7,%dl
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    8038:	3c 01                	cmp    $0x1,%al
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    803a:	0f b6 d2             	movzbl %dl,%edx
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    803d:	75 29                	jne    8068 <lteMacCcchSend+0x148>
		if(lcid==0){								//ccch
    803f:	85 c9                	test   %ecx,%ecx
    8041:	74 5d                	je     80a0 <lteMacCcchSend+0x180>
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
    8043:	83 fa 01             	cmp    $0x1,%edx
    8046:	75 b8                	jne    8000 <lteMacCcchSend+0xe0>
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8048:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
    804b:	83 c6 03             	add    $0x3,%esi
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    804e:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			sdu_len=sdu_len<<8;
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    8052:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8056:	83 e0 7f             	and    $0x7f,%eax
			sdu_len=sdu_len<<8;
    8059:	c1 e0 08             	shl    $0x8,%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    805c:	01 d0                	add    %edx,%eax
			offset=offset+sdu_len;
    805e:	01 c7                	add    %eax,%edi
    8060:	eb aa                	jmp    800c <lteMacCcchSend+0xec>
    8062:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8068:	89 7d dc             	mov    %edi,-0x24(%ebp)
    806b:	89 cf                	mov    %ecx,%edi
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
    806d:	85 ff                	test   %edi,%edi
    806f:	0f 84 c3 01 00 00    	je     8238 <lteMacCcchSend+0x318>
	FIN(lteMacCcchSend());

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
    8075:	be 01 00 00 00       	mov    $0x1,%esi
			skb_len = skb->tail - skb->data;
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
		}
	fsm_mem_free(m_rrc_request);
    807a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    807d:	e8 fc ff ff ff       	call   807e <lteMacCcchSend+0x15e>
	fsm_mem_free(m_7bit_subhead);
    8082:	89 d8                	mov    %ebx,%eax
    8084:	e8 fc ff ff ff       	call   8085 <lteMacCcchSend+0x165>
	fsm_mem_free(m_15bit_subhead);
    8089:	8b 45 e8             	mov    -0x18(%ebp),%eax
    808c:	e8 fc ff ff ff       	call   808d <lteMacCcchSend+0x16d>
	FRET(ccch_or_not);
		//FRET(0);
}
    8091:	89 f0                	mov    %esi,%eax
    8093:	83 c4 2c             	add    $0x2c,%esp
    8096:	5b                   	pop    %ebx
    8097:	5e                   	pop    %esi
    8098:	5f                   	pop    %edi
    8099:	5d                   	pop    %ebp
    809a:	c3                   	ret    
    809b:	90                   	nop
    809c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    80a0:	89 7d dc             	mov    %edi,-0x24(%ebp)
	while(continue_flag==1){
		if(lcid==0){								//ccch
		    //fsm_printf("There are two SDU from CCCH ,error \n");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    80a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    80a6:	b9 0a 00 00 00       	mov    $0xa,%ecx
    80ab:	8b 55 dc             	mov    -0x24(%ebp),%edx
    80ae:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    80b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    80b7:	e8 fc ff ff ff       	call   80b8 <lteMacCcchSend+0x198>
			/*
			SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity)&0x0000ffff;
			SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity&0x000f0000)>>32;
			*/
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    80bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    80bf:	b9 05 00 00 00       	mov    $0x5,%ecx
    80c4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    80c7:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    80cd:	83 c6 01             	add    $0x1,%esi
    80d0:	89 f2                	mov    %esi,%edx
    80d2:	e8 fc ff ff ff       	call   80d3 <lteMacCcchSend+0x1b3>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    80d7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    80da:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    80e0:	8b 00                	mov    (%eax),%eax
    80e2:	c7 04 24 0c 27 00 00 	movl   $0x270c,(%esp)
    80e9:	89 44 24 04          	mov    %eax,0x4(%esp)
    80ed:	e8 fc ff ff ff       	call   80ee <lteMacCcchSend+0x1ce>
			
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    80f2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    80f5:	b9 01 00 00 00       	mov    $0x1,%ecx
    80fa:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8100:	89 f2                	mov    %esi,%edx
    8102:	83 c0 04             	add    $0x4,%eax
    8105:	e8 fc ff ff ff       	call   8106 <lteMacCcchSend+0x1e6>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    810a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    810d:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8113:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8117:	c7 04 24 30 27 00 00 	movl   $0x2730,(%esp)
    811e:	89 44 24 04          	mov    %eax,0x4(%esp)
    8122:	e8 fc ff ff ff       	call   8123 <lteMacCcchSend+0x203>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    8127:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    812a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    812d:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    8133:	8b 41 06             	mov    0x6(%ecx),%eax
    8136:	83 e0 0f             	and    $0xf,%eax
    8139:	66 03 42 04          	add    0x4(%edx),%ax
    813d:	c1 e0 08             	shl    $0x8,%eax
    8140:	66 89 42 04          	mov    %ax,0x4(%edx)
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8144:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8147:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    814d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8151:	c7 04 24 30 27 00 00 	movl   $0x2730,(%esp)
    8158:	89 44 24 04          	mov    %eax,0x4(%esp)
    815c:	e8 fc ff ff ff       	call   815d <lteMacCcchSend+0x23d>
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8161:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8164:	b9 0a 00 00 00       	mov    $0xa,%ecx
    8169:	8b 55 dc             	mov    -0x24(%ebp),%edx
    816c:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    8172:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8175:	e8 fc ff ff ff       	call   8176 <lteMacCcchSend+0x256>
			//fsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);

			//SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity.randomValue)&0x0000ffff;	//randomValue32
			//SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity.randomValue&0x000f0000)>>32;	//randomValue33~40
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    817a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    817d:	b9 05 00 00 00       	mov    $0x5,%ecx
    8182:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8188:	89 f2                	mov    %esi,%edx
    818a:	e8 fc ff ff ff       	call   818b <lteMacCcchSend+0x26b>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    818f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    8192:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8198:	8b 00                	mov    (%eax),%eax
    819a:	c7 04 24 0c 27 00 00 	movl   $0x270c,(%esp)
    81a1:	89 44 24 04          	mov    %eax,0x4(%esp)
    81a5:	e8 fc ff ff ff       	call   81a6 <lteMacCcchSend+0x286>
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
    81aa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    81ad:	b9 02 00 00 00       	mov    $0x2,%ecx
    81b2:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    81b8:	31 d2                	xor    %edx,%edx
    81ba:	83 c0 04             	add    $0x4,%eax
    81bd:	e8 fc ff ff ff       	call   81be <lteMacCcchSend+0x29e>
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    81c2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    81c5:	89 f2                	mov    %esi,%edx
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
    81c7:	31 f6                	xor    %esi,%esi
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    81c9:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    81cf:	b9 01 00 00 00       	mov    $0x1,%ecx
    81d4:	83 c0 04             	add    $0x4,%eax
    81d7:	e8 fc ff ff ff       	call   81d8 <lteMacCcchSend+0x2b8>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    81dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    81df:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    81e5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    81e9:	c7 04 24 30 27 00 00 	movl   $0x2730,(%esp)
    81f0:	89 44 24 04          	mov    %eax,0x4(%esp)
    81f4:	e8 fc ff ff ff       	call   81f5 <lteMacCcchSend+0x2d5>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    81f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    81fc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    81ff:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    8205:	8b 41 06             	mov    0x6(%ecx),%eax
    8208:	83 e0 0f             	and    $0xf,%eax
    820b:	66 03 42 04          	add    0x4(%edx),%ax
    820f:	c1 e0 08             	shl    $0x8,%eax
    8212:	66 89 42 04          	mov    %ax,0x4(%edx)
			//fsm_printf("[MAC CCCHSEND]%d\n",m_rrc_request->establishmentCause);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8216:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8219:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    821f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8223:	c7 04 24 30 27 00 00 	movl   $0x2730,(%esp)
    822a:	89 44 24 04          	mov    %eax,0x4(%esp)
    822e:	e8 fc ff ff ff       	call   822f <lteMacCcchSend+0x30f>
    8233:	e9 42 fe ff ff       	jmp    807a <lteMacCcchSend+0x15a>
    8238:	8b 45 e0             	mov    -0x20(%ebp),%eax
    823b:	8d 70 01             	lea    0x1(%eax),%esi
    823e:	e9 1e ff ff ff       	jmp    8161 <lteMacCcchSend+0x241>
    8243:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008250 <setMACtoRLC_IciMsg>:
 * @function: fill in the ICI from MAC to RLC
 * @param ici_msg: the structure of the ICI
 * @param pbch: the channel that carries the PDU
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
    8250:	55                   	push   %ebp
    8251:	89 e5                	mov    %esp,%ebp
    8253:	83 ec 0c             	sub    $0xc,%esp
    8256:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8259:	89 75 f8             	mov    %esi,-0x8(%ebp)
    825c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    825f:	e8 fc ff ff ff       	call   8260 <setMACtoRLC_IciMsg+0x10>
    8264:	89 c3                	mov    %eax,%ebx
    8266:	89 d6                	mov    %edx,%esi
    8268:	89 cf                	mov    %ecx,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    826a:	e8 fc ff ff ff       	call   826b <setMACtoRLC_IciMsg+0x1b>
	ici_msg->lcid=lcid;
    826f:	89 fa                	mov    %edi,%edx
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8271:	8b 7d fc             	mov    -0x4(%ebp),%edi
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
    8274:	89 73 02             	mov    %esi,0x2(%ebx)
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8277:	8b 75 f8             	mov    -0x8(%ebp),%esi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    827a:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    827d:	0f b7 00             	movzwl (%eax),%eax
    8280:	66 89 03             	mov    %ax,(%ebx)
	FOUT;
}
    8283:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    8286:	89 ec                	mov    %ebp,%esp
    8288:	5d                   	pop    %ebp
    8289:	c3                   	ret    
    828a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008290 <setMACtoPHY_IciMsg>:
	SV(sys_frame).subframeNo=0;
		
	//
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
    8290:	55                   	push   %ebp
    8291:	89 e5                	mov    %esp,%ebp
    8293:	83 ec 0c             	sub    $0xc,%esp
    8296:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8299:	89 75 f8             	mov    %esi,-0x8(%ebp)
    829c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    829f:	e8 fc ff ff ff       	call   82a0 <setMACtoPHY_IciMsg+0x10>
    82a4:	89 d6                	mov    %edx,%esi
    82a6:	89 cf                	mov    %ecx,%edi
    82a8:	89 c3                	mov    %eax,%ebx
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
    82aa:	e8 fc ff ff ff       	call   82ab <setMACtoPHY_IciMsg+0x1b>
	ici_msg->tcid=tcid;
    82af:	89 f2                	mov    %esi,%edx
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    82b1:	66 85 ff             	test   %di,%di
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
	ici_msg->tcid=tcid;
    82b4:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    82b7:	75 0c                	jne    82c5 <setMACtoPHY_IciMsg+0x35>
    82b9:	0f b7 38             	movzwl (%eax),%edi
    82bc:	66 85 ff             	test   %di,%di
    82bf:	75 04                	jne    82c5 <setMACtoPHY_IciMsg+0x35>
    82c1:	0f b7 78 02          	movzwl 0x2(%eax),%edi
    82c5:	66 89 7b 04          	mov    %di,0x4(%ebx)

	ici_msg->frameNo=SV(sys_frame).frameNo;
    82c9:	0f b7 50 06          	movzwl 0x6(%eax),%edx
    82cd:	66 89 13             	mov    %dx,(%ebx)
	ici_msg->subframeNo=SV(sys_frame).subframeNo;
    82d0:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    82d4:	66 89 53 02          	mov    %dx,0x2(%ebx)
	SV(sys_frame).frameNo=0;
    82d8:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
	SV(sys_frame).subframeNo=0;
    82de:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		
	//
	FOUT;
}
    82e4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    82e7:	8b 75 f8             	mov    -0x8(%ebp),%esi
    82ea:	8b 7d fc             	mov    -0x4(%ebp),%edi
    82ed:	89 ec                	mov    %ebp,%esp
    82ef:	5d                   	pop    %ebp
    82f0:	c3                   	ret    
    82f1:	eb 0d                	jmp    8300 <lteMacCEBSRSend>
    82f3:	90                   	nop
    82f4:	90                   	nop
    82f5:	90                   	nop
    82f6:	90                   	nop
    82f7:	90                   	nop
    82f8:	90                   	nop
    82f9:	90                   	nop
    82fa:	90                   	nop
    82fb:	90                   	nop
    82fc:	90                   	nop
    82fd:	90                   	nop
    82fe:	90                   	nop
    82ff:	90                   	nop

00008300 <lteMacCEBSRSend>:
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    8300:	55                   	push   %ebp
    8301:	89 e5                	mov    %esp,%ebp
    8303:	57                   	push   %edi
    8304:	56                   	push   %esi
    8305:	53                   	push   %ebx
    8306:	83 ec 08             	sub    $0x8,%esp
    8309:	e8 fc ff ff ff       	call   830a <lteMacCEBSRSend+0xa>
    830e:	89 c7                	mov    %eax,%edi
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    8310:	b8 1a 00 00 00       	mov    $0x1a,%eax
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    8315:	89 55 f0             	mov    %edx,-0x10(%ebp)
    8318:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    831b:	e8 fc ff ff ff       	call   831c <lteMacCEBSRSend+0x1c>
    8320:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
    8322:	e8 fc ff ff ff       	call   8323 <lteMacCEBSRSend+0x23>

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8327:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    832c:	31 d2                	xor    %edx,%edx
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);
    832e:	89 c3                	mov    %eax,%ebx

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8330:	89 f0                	mov    %esi,%eax
    8332:	e8 fc ff ff ff       	call   8333 <lteMacCEBSRSend+0x33>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8337:	31 c0                	xor    %eax,%eax
    8339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
    8340:	0f b6 94 c3 a5 01 00 	movzbl 0x1a5(%ebx,%eax,8),%edx
    8347:	00 
    8348:	80 fa 1d             	cmp    $0x1d,%dl
    834b:	74 2b                	je     8378 <lteMacCEBSRSend+0x78>
					*lcg_id=0;
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
    834d:	80 fa 1e             	cmp    $0x1e,%dl
    8350:	0f 84 92 00 00 00    	je     83e8 <lteMacCEBSRSend+0xe8>
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8356:	83 c0 01             	add    $0x1,%eax
    8359:	83 f8 08             	cmp    $0x8,%eax
    835c:	75 e2                	jne    8340 <lteMacCEBSRSend+0x40>
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    835e:	89 f0                	mov    %esi,%eax
	FRET(0);
    8360:	31 db                	xor    %ebx,%ebx
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    8362:	e8 fc ff ff ff       	call   8363 <lteMacCEBSRSend+0x63>
	FRET(0);
}
    8367:	89 d8                	mov    %ebx,%eax
    8369:	83 c4 08             	add    $0x8,%esp
    836c:	5b                   	pop    %ebx
    836d:	5e                   	pop    %esi
    836e:	5f                   	pop    %edi
    836f:	5d                   	pop    %ebp
    8370:	c3                   	ret    
    8371:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8378:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    837f:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    8384:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    8386:	31 db                	xor    %ebx,%ebx
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8388:	e8 fc ff ff ff       	call   8389 <lteMacCEBSRSend+0x89>
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    838d:	8b 46 06             	mov    0x6(%esi),%eax
    8390:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8393:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8395:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8398:	31 c0                	xor    %eax,%eax
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
    839a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    839e:	85 c9                	test   %ecx,%ecx
    83a0:	74 36                	je     83d8 <lteMacCEBSRSend+0xd8>
					lcg_numb++;
					*lcg_id=lcg_pos;
    83a2:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    83a4:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
					lcg_numb++;
    83a8:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    83ab:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    83ae:	83 fb 01             	cmp    $0x1,%ebx
    83b1:	76 06                	jbe    83b9 <lteMacCEBSRSend+0xb9>
					*lcg_id=0;
    83b3:	c7 07 00 00 00 00    	movl   $0x0,(%edi)

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    83b9:	83 c0 01             	add    $0x1,%eax
    83bc:	83 f8 04             	cmp    $0x4,%eax
    83bf:	75 d9                	jne    839a <lteMacCEBSRSend+0x9a>
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
    83c1:	89 f0                	mov    %esi,%eax
    83c3:	e8 fc ff ff ff       	call   83c4 <lteMacCEBSRSend+0xc4>
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
	FRET(0);
}
    83c8:	83 c4 08             	add    $0x8,%esp
    83cb:	89 d8                	mov    %ebx,%eax
    83cd:	5b                   	pop    %ebx
    83ce:	5e                   	pop    %esi
    83cf:	5f                   	pop    %edi
    83d0:	5d                   	pop    %ebp
    83d1:	c3                   	ret    
    83d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    83d8:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    83df:	eb cd                	jmp    83ae <lteMacCEBSRSend+0xae>
    83e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    83e8:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    83ef:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    83f4:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    83f6:	31 db                	xor    %ebx,%ebx
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    83f8:	e8 fc ff ff ff       	call   83f9 <lteMacCEBSRSend+0xf9>
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    83fd:	8b 46 06             	mov    0x6(%esi),%eax
    8400:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8403:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8405:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8408:	31 c0                	xor    %eax,%eax
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
    840a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    840e:	85 c9                	test   %ecx,%ecx
    8410:	74 36                	je     8448 <lteMacCEBSRSend+0x148>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8412:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8414:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
					lcg_numb++;
    8418:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    841b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    841e:	83 fb 01             	cmp    $0x1,%ebx
    8421:	76 06                	jbe    8429 <lteMacCEBSRSend+0x129>
					*lcg_id=0;
    8423:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8429:	83 c0 01             	add    $0x1,%eax
    842c:	83 f8 04             	cmp    $0x4,%eax
    842f:	75 d9                	jne    840a <lteMacCEBSRSend+0x10a>
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8431:	8b 55 f0             	mov    -0x10(%ebp),%edx
			fsm_mem_free(m_bsr_infor);
    8434:	89 f0                	mov    %esi,%eax
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8436:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			fsm_mem_free(m_bsr_infor);
    843c:	e8 fc ff ff ff       	call   843d <lteMacCEBSRSend+0x13d>
    8441:	eb 85                	jmp    83c8 <lteMacCEBSRSend+0xc8>
    8443:	90                   	nop
    8444:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    8448:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    844f:	eb cd                	jmp    841e <lteMacCEBSRSend+0x11e>
    8451:	eb 0d                	jmp    8460 <lteMacGetDlHeadLength>
    8453:	90                   	nop
    8454:	90                   	nop
    8455:	90                   	nop
    8456:	90                   	nop
    8457:	90                   	nop
    8458:	90                   	nop
    8459:	90                   	nop
    845a:	90                   	nop
    845b:	90                   	nop
    845c:	90                   	nop
    845d:	90                   	nop
    845e:	90                   	nop
    845f:	90                   	nop

00008460 <lteMacGetDlHeadLength>:
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8460:	55                   	push   %ebp
    8461:	89 e5                	mov    %esp,%ebp
    8463:	57                   	push   %edi
    8464:	56                   	push   %esi
    8465:	53                   	push   %ebx
    8466:	83 ec 1c             	sub    $0x1c,%esp
    8469:	e8 fc ff ff ff       	call   846a <lteMacGetDlHeadLength+0xa>
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
    846e:	31 db                	xor    %ebx,%ebx
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8470:	89 c7                	mov    %eax,%edi
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    8472:	b8 03 00 00 00       	mov    $0x3,%eax
    8477:	e8 fc ff ff ff       	call   8478 <lteMacGetDlHeadLength+0x18>
    847c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
    847f:	b8 01 00 00 00       	mov    $0x1,%eax
    8484:	e8 fc ff ff ff       	call   8485 <lteMacGetDlHeadLength+0x25>
    8489:	89 c6                	mov    %eax,%esi
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    848b:	b8 02 00 00 00       	mov    $0x2,%eax
    8490:	e8 fc ff ff ff       	call   8491 <lteMacGetDlHeadLength+0x31>

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8495:	31 d2                	xor    %edx,%edx
    8497:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    849c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    849f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    84a2:	e8 fc ff ff ff       	call   84a3 <lteMacGetDlHeadLength+0x43>
	fsm_mem_set(fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    84a7:	31 d2                	xor    %edx,%edx
    84a9:	b9 01 00 00 00       	mov    $0x1,%ecx
    84ae:	89 f0                	mov    %esi,%eax
    84b0:	e8 fc ff ff ff       	call   84b1 <lteMacGetDlHeadLength+0x51>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    84b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    84b8:	31 d2                	xor    %edx,%edx
    84ba:	b9 02 00 00 00       	mov    $0x2,%ecx
    84bf:	e8 fc ff ff ff       	call   84c0 <lteMacGetDlHeadLength+0x60>
	
	last_len=sizeof(MAC_SDU_subhead_last);
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
    84c4:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    84ca:	b9 01 00 00 00       	mov    $0x1,%ecx
    84cf:	89 f0                	mov    %esi,%eax
    84d1:	e8 fc ff ff ff       	call   84d2 <lteMacGetDlHeadLength+0x72>
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
    84d6:	0f b6 16             	movzbl (%esi),%edx
    84d9:	89 d0                	mov    %edx,%eax
    84db:	c0 e8 05             	shr    $0x5,%al
	//20140626
	while(m_e==1){		//
    84de:	3c 01                	cmp    $0x1,%al
    84e0:	74 50                	je     8532 <lteMacGetDlHeadLength+0xd2>
    84e2:	e9 89 00 00 00       	jmp    8570 <lteMacGetDlHeadLength+0x110>
    84e7:	90                   	nop
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
		switch(m_lcid){
    84e8:	83 fa 1c             	cmp    $0x1c,%edx
    84eb:	74 7b                	je     8568 <lteMacGetDlHeadLength+0x108>
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
			break;
		default:
			fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    84ed:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    84f3:	b9 02 00 00 00       	mov    $0x2,%ecx
    84f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    84fb:	01 da                	add    %ebx,%edx
    84fd:	e8 fc ff ff ff       	call   84fe <lteMacGetDlHeadLength+0x9e>
			m_f=m_7bit_subhead->m_f_l>>7;
			if(m_f==1){
				from_len=from_len+subhead_15bit_len;
    8502:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8505:	8d 43 03             	lea    0x3(%ebx),%eax
    8508:	83 c3 02             	add    $0x2,%ebx
    850b:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    850f:	0f 48 d8             	cmovs  %eax,%ebx
			else{
				from_len=from_len+subhead_7bit_len;
			}
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
    8512:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    8518:	b9 01 00 00 00       	mov    $0x1,%ecx
    851d:	89 f0                	mov    %esi,%eax
    851f:	01 da                	add    %ebx,%edx
    8521:	e8 fc ff ff ff       	call   8522 <lteMacGetDlHeadLength+0xc2>
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
    8526:	0f b6 16             	movzbl (%esi),%edx
    8529:	89 d0                	mov    %edx,%eax
    852b:	c0 e8 05             	shr    $0x5,%al
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
	//20140626
	while(m_e==1){		//
    852e:	3c 01                	cmp    $0x1,%al
    8530:	75 3e                	jne    8570 <lteMacGetDlHeadLength+0x110>
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8532:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8535:	89 54 24 04          	mov    %edx,0x4(%esp)
    8539:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    853c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    8540:	c7 04 24 54 27 00 00 	movl   $0x2754,(%esp)
    8547:	e8 fc ff ff ff       	call   8548 <lteMacGetDlHeadLength+0xe8>
		
		switch(m_lcid){
    854c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    854f:	83 fa 1d             	cmp    $0x1d,%edx
    8552:	74 14                	je     8568 <lteMacGetDlHeadLength+0x108>
    8554:	76 92                	jbe    84e8 <lteMacGetDlHeadLength+0x88>
    8556:	83 fa 1e             	cmp    $0x1e,%edx
    8559:	74 0d                	je     8568 <lteMacGetDlHeadLength+0x108>
    855b:	83 fa 1f             	cmp    $0x1f,%edx
    855e:	66 90                	xchg   %ax,%ax
    8560:	75 8b                	jne    84ed <lteMacGetDlHeadLength+0x8d>
    8562:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			break;
		case TIMING_ADVANCE_LCID :
			from_len=from_len+last_len;
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
    8568:	83 c3 01             	add    $0x1,%ebx
			break;
    856b:	eb a5                	jmp    8512 <lteMacGetDlHeadLength+0xb2>
    856d:	8d 76 00             	lea    0x0(%esi),%esi
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8570:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8573:	89 54 24 04          	mov    %edx,0x4(%esp)
    8577:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    857a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    857e:	c7 04 24 54 27 00 00 	movl   $0x2754,(%esp)
    8585:	e8 fc ff ff ff       	call   8586 <lteMacGetDlHeadLength+0x126>
		
	switch(m_lcid){		//while
    858a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		break;
	case DRX_LCID :
		from_len=from_len+last_len;
		break;
	case TIMING_ADVANCE_LCID :
		from_len=from_len+last_len;
    858d:	8d 43 01             	lea    0x1(%ebx),%eax
    8590:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    8593:	83 fa 1d             	cmp    $0x1d,%edx
    8596:	74 10                	je     85a8 <lteMacGetDlHeadLength+0x148>
    8598:	76 36                	jbe    85d0 <lteMacGetDlHeadLength+0x170>
    859a:	83 fa 1e             	cmp    $0x1e,%edx
    859d:	74 09                	je     85a8 <lteMacGetDlHeadLength+0x148>
    859f:	83 fa 1f             	cmp    $0x1f,%edx
    85a2:	75 31                	jne    85d5 <lteMacGetDlHeadLength+0x175>
    85a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
			from_len=from_len+subhead_7bit_len;
		}
		break;
	}
	fsm_mem_free(m_15bit_subhead);
    85a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    85ab:	e8 fc ff ff ff       	call   85ac <lteMacGetDlHeadLength+0x14c>
	fsm_mem_free(fixed_subhead);
    85b0:	89 f0                	mov    %esi,%eax
    85b2:	e8 fc ff ff ff       	call   85b3 <lteMacGetDlHeadLength+0x153>
	fsm_mem_free(m_7bit_subhead);
    85b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85ba:	e8 fc ff ff ff       	call   85bb <lteMacGetDlHeadLength+0x15b>
	FRET(from_len);
}
    85bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    85c2:	83 c4 1c             	add    $0x1c,%esp
    85c5:	5b                   	pop    %ebx
    85c6:	5e                   	pop    %esi
    85c7:	5f                   	pop    %edi
    85c8:	5d                   	pop    %ebp
    85c9:	c3                   	ret    
    85ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    85d0:	83 fa 1c             	cmp    $0x1c,%edx
    85d3:	74 d3                	je     85a8 <lteMacGetDlHeadLength+0x148>
		break;
	case CONTENTION_RESOLUTION_LCID :
		from_len=from_len+last_len;
		break;
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    85d5:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    85db:	b9 02 00 00 00       	mov    $0x2,%ecx
    85e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85e3:	01 da                	add    %ebx,%edx
    85e5:	e8 fc ff ff ff       	call   85e6 <lteMacGetDlHeadLength+0x186>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
    85ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    85ed:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    85f1:	78 14                	js     8607 <lteMacGetDlHeadLength+0x1a7>
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_7bit_len;
    85f3:	83 c3 02             	add    $0x2,%ebx
		
			from_len=from_len+subhead_15bit_len;
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
    85f6:	c7 04 24 1a 05 00 00 	movl   $0x51a,(%esp)
    85fd:	e8 fc ff ff ff       	call   85fe <lteMacGetDlHeadLength+0x19e>
		
			from_len=from_len+subhead_7bit_len;
    8602:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    8605:	eb a1                	jmp    85a8 <lteMacGetDlHeadLength+0x148>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_15bit_len;
    8607:	83 c3 03             	add    $0x3,%ebx
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
    860a:	c7 04 24 90 27 00 00 	movl   $0x2790,(%esp)
    8611:	e8 fc ff ff ff       	call   8612 <lteMacGetDlHeadLength+0x1b2>
		
			from_len=from_len+subhead_15bit_len;
    8616:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    8619:	eb 8d                	jmp    85a8 <lteMacGetDlHeadLength+0x148>
    861b:	90                   	nop
    861c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00008620 <Pdcch_c_rnti>:
/**
 * @function: exclude the information in PCH, BCCH in the decomplexing to offer the result whether the MSG4 is successful
 * @param c_rnti: rnti in the PHY-T-MAC-ICI
 */

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
    8620:	55                   	push   %ebp
    8621:	89 e5                	mov    %esp,%ebp
    8623:	53                   	push   %ebx
    8624:	e8 fc ff ff ff       	call   8625 <Pdcch_c_rnti+0x5>
    8629:	89 c3                	mov    %eax,%ebx
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
    862b:	e8 fc ff ff ff       	call   862c <Pdcch_c_rnti+0xc>
	if(SV(sendmsg3)==1){//msg3
    8630:	83 b8 ec 01 00 00 01 	cmpl   $0x1,0x1ec(%eax)
    8637:	74 0f                	je     8648 <Pdcch_c_rnti+0x28>
			fsm_schedule_self(0, ContentionResolution_Fail );//3
			//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution fail\n");
		}
	}
	else
		SV(pdcch_rnti)=0;
    8639:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    8640:	00 00 00 
	FOUT;
}
    8643:	5b                   	pop    %ebx
    8644:	5d                   	pop    %ebp
    8645:	c3                   	ret    
    8646:	66 90                	xchg   %ax,%ax

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8648:	0f b7 10             	movzwl (%eax),%edx
    864b:	66 39 da             	cmp    %bx,%dx
    864e:	74 20                	je     8670 <Pdcch_c_rnti+0x50>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
				//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution successfully\n");
			}				
		}
		else if ((c_rnti !=SV(C_RNTI)) && SV(C_RNTI)!=0){//PDCCHCRNTI
    8650:	66 85 d2             	test   %dx,%dx
    8653:	74 ee                	je     8643 <Pdcch_c_rnti+0x23>
			SV(pdcch_rnti)=0;//0
    8655:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    865c:	00 00 00 
			fsm_schedule_self(0, ContentionResolution_Fail );//3
    865f:	ba 05 00 00 00       	mov    $0x5,%edx
    8664:	31 c0                	xor    %eax,%eax
    8666:	e8 fc ff ff ff       	call   8667 <Pdcch_c_rnti+0x47>
    866b:	eb d6                	jmp    8643 <Pdcch_c_rnti+0x23>
    866d:	8d 76 00             	lea    0x0(%esi),%esi

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8670:	66 85 d2             	test   %dx,%dx
    8673:	74 ce                	je     8643 <Pdcch_c_rnti+0x23>
		{
			SV(pdcch_rnti)=1;//1
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8675:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
		{
			SV(pdcch_rnti)=1;//1
    867c:	c7 80 f0 01 00 00 01 	movl   $0x1,0x1f0(%eax)
    8683:	00 00 00 
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8686:	74 bb                	je     8643 <Pdcch_c_rnti+0x23>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
    8688:	ba 06 00 00 00       	mov    $0x6,%edx
    868d:	31 c0                	xor    %eax,%eax
    868f:	e8 fc ff ff ff       	call   8690 <Pdcch_c_rnti+0x70>
    8694:	eb ad                	jmp    8643 <Pdcch_c_rnti+0x23>
    8696:	8d 76 00             	lea    0x0(%esi),%esi
    8699:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000086a0 <compare>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
    86a0:	55                   	push   %ebp
    86a1:	89 e5                	mov    %esp,%ebp
    86a3:	e8 fc ff ff ff       	call   86a4 <compare+0x4>
	u32 ret=first<second?0:1;
	return ret;
}
    86a8:	5d                   	pop    %ebp
/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
	u32 ret=first<second?0:1;
    86a9:	39 d0                	cmp    %edx,%eax
    86ab:	0f 93 c0             	setae  %al
    86ae:	0f b6 c0             	movzbl %al,%eax
	return ret;
}
    86b1:	c3                   	ret    
    86b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    86b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000086c0 <decomplexUeRARPdu>:
/**
 * @function: decomplex RAR PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
 void decomplexUeRARPdu(FSM_PKT *skb)
{
    86c0:	55                   	push   %ebp
    86c1:	89 e5                	mov    %esp,%ebp
    86c3:	56                   	push   %esi
    86c4:	53                   	push   %ebx
    86c5:	83 ec 18             	sub    $0x18,%esp
    86c8:	e8 fc ff ff ff       	call   86c9 <decomplexUeRARPdu+0x9>
    86cd:	89 c3                	mov    %eax,%ebx
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    86cf:	e8 fc ff ff ff       	call   86d0 <decomplexUeRARPdu+0x10>

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    86d4:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
{
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    86da:	89 c6                	mov    %eax,%esi

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    86dc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    86e2:	29 d0                	sub    %edx,%eax
    86e4:	83 f8 06             	cmp    $0x6,%eax
    86e7:	0f 86 98 01 00 00    	jbe    8885 <decomplexUeRARPdu+0x1c5>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    86ed:	b9 07 00 00 00       	mov    $0x7,%ecx
    86f2:	8d 45 f1             	lea    -0xf(%ebp),%eax
    86f5:	e8 fc ff ff ff       	call   86f6 <decomplexUeRARPdu+0x36>
	if(m_phy_ici.tcid==BCH){
    86fa:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    86fe:	3c 01                	cmp    $0x1,%al
    8700:	0f 84 ca 00 00 00    	je     87d0 <decomplexUeRARPdu+0x110>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    8706:	84 c0                	test   %al,%al
    8708:	74 0e                	je     8718 <decomplexUeRARPdu+0x58>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    870a:	3c 02                	cmp    $0x2,%al
    870c:	74 72                	je     8780 <decomplexUeRARPdu+0xc0>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    870e:	83 c4 18             	add    $0x18,%esp
    8711:	5b                   	pop    %ebx
    8712:	5e                   	pop    %esi
    8713:	5d                   	pop    %ebp
    8714:	c3                   	ret    
    8715:	8d 76 00             	lea    0x0(%esi),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8718:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    871f:	e8 fc ff ff ff       	call   8720 <decomplexUeRARPdu+0x60>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8724:	e8 fc ff ff ff       	call   8725 <decomplexUeRARPdu+0x65>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8729:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    872f:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    8733:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    873a:	0f b7 00             	movzwl (%eax),%eax
    873d:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8741:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8747:	29 c2                	sub    %eax,%edx
    8749:	83 fa 06             	cmp    $0x6,%edx
    874c:	0f 86 52 01 00 00    	jbe    88a4 <decomplexUeRARPdu+0x1e4>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8752:	8d 55 ea             	lea    -0x16(%ebp),%edx
    8755:	b9 07 00 00 00       	mov    $0x7,%ecx
    875a:	e8 fc ff ff ff       	call   875b <decomplexUeRARPdu+0x9b>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    875f:	31 c0                	xor    %eax,%eax
    8761:	e8 fc ff ff ff       	call   8762 <decomplexUeRARPdu+0xa2>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8766:	8b 43 50             	mov    0x50(%ebx),%eax
    8769:	c7 04 24 b0 27 00 00 	movl   $0x27b0,(%esp)
    8770:	89 44 24 04          	mov    %eax,0x4(%esp)
    8774:	e8 fc ff ff ff       	call   8775 <decomplexUeRARPdu+0xb5>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    8779:	83 c4 18             	add    $0x18,%esp
    877c:	5b                   	pop    %ebx
    877d:	5e                   	pop    %esi
    877e:	5d                   	pop    %ebp
    877f:	c3                   	ret    
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code
    8780:	c7 04 24 d4 27 00 00 	movl   $0x27d4,(%esp)
    8787:	e8 fc ff ff ff       	call   8788 <decomplexUeRARPdu+0xc8>

		if(!compare(skb->tail-skb->data,len)){
    878c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8792:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8798:	83 f8 06             	cmp    $0x6,%eax
    879b:	0f 86 22 01 00 00    	jbe    88c3 <decomplexUeRARPdu+0x203>
			fsm_pkt_destroy(skb);
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
    87a1:	80 be 98 01 00 00 00 	cmpb   $0x0,0x198(%esi)
    87a8:	0f 85 82 00 00 00    	jne    8830 <decomplexUeRARPdu+0x170>
					fsm_schedule_self(0,RandomAcc_Fail);
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
				} 
		}
		else { //RAR
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test	
    87ae:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		}
		fsm_pkt_destroy(skb);//
    87b5:	89 d8                	mov    %ebx,%eax
    87b7:	e8 fc ff ff ff       	call   87b8 <decomplexUeRARPdu+0xf8>
		//printk("ue mac_pkthandler 796\n");
		fsm_printf("decomplex for RAR function done\n");//testing code
    87bc:	c7 04 24 38 28 00 00 	movl   $0x2838,(%esp)
    87c3:	e8 fc ff ff ff       	call   87c4 <decomplexUeRARPdu+0x104>
			
		FOUT;
	}
		
}
    87c8:	83 c4 18             	add    $0x18,%esp
    87cb:	5b                   	pop    %ebx
    87cc:	5e                   	pop    %esi
    87cd:	5d                   	pop    %ebp
    87ce:	c3                   	ret    
    87cf:	90                   	nop
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    87d0:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    87d7:	e8 fc ff ff ff       	call   87d8 <decomplexUeRARPdu+0x118>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    87dc:	e8 fc ff ff ff       	call   87dd <decomplexUeRARPdu+0x11d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    87e1:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    87e7:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    87eb:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    87f2:	0f b7 00             	movzwl (%eax),%eax
    87f5:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    87f9:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    87ff:	29 c2                	sub    %eax,%edx
    8801:	83 fa 06             	cmp    $0x6,%edx
    8804:	0f 87 48 ff ff ff    	ja     8752 <decomplexUeRARPdu+0x92>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    880a:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8811:	89 d8                	mov    %ebx,%eax
    8813:	e8 fc ff ff ff       	call   8814 <decomplexUeRARPdu+0x154>
			printk("ue mac_pkthandler 715\n");
    8818:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    881f:	e8 fc ff ff ff       	call   8820 <decomplexUeRARPdu+0x160>
			FOUT;
    8824:	e9 e5 fe ff ff       	jmp    870e <decomplexUeRARPdu+0x4e>
    8829:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    8830:	8b 86 94 01 00 00    	mov    0x194(%esi),%eax
    8836:	e8 fc ff ff ff       	call   8837 <decomplexUeRARPdu+0x177>
				SV(WaitforRAresponseTimer.flag)=false;
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    883b:	89 d8                	mov    %ebx,%eax
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
				SV(WaitforRAresponseTimer.flag)=false;
    883d:	c6 86 98 01 00 00 00 	movb   $0x0,0x198(%esi)
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
    8844:	c7 86 94 01 00 00 00 	movl   $0x0,0x194(%esi)
    884b:	00 00 00 
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    884e:	e8 fc ff ff ff       	call   884f <decomplexUeRARPdu+0x18f>
    8853:	84 c0                	test   %al,%al
    8855:	74 11                	je     8868 <decomplexUeRARPdu+0x1a8>
					fsm_schedule_self(0,RARrev_Success);
    8857:	ba 04 00 00 00       	mov    $0x4,%edx
    885c:	31 c0                	xor    %eax,%eax
    885e:	e8 fc ff ff ff       	call   885f <decomplexUeRARPdu+0x19f>
    8863:	e9 4d ff ff ff       	jmp    87b5 <decomplexUeRARPdu+0xf5>
				else{
					fsm_schedule_self(0,RandomAcc_Fail);
    8868:	ba 03 00 00 00       	mov    $0x3,%edx
    886d:	31 c0                	xor    %eax,%eax
    886f:	e8 fc ff ff ff       	call   8870 <decomplexUeRARPdu+0x1b0>
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
    8874:	c7 04 24 04 28 00 00 	movl   $0x2804,(%esp)
    887b:	e8 fc ff ff ff       	call   887c <decomplexUeRARPdu+0x1bc>
    8880:	e9 30 ff ff ff       	jmp    87b5 <decomplexUeRARPdu+0xf5>
	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8885:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		fsm_pkt_destroy(skb);
    888c:	89 d8                	mov    %ebx,%eax
    888e:	e8 fc ff ff ff       	call   888f <decomplexUeRARPdu+0x1cf>
		printk("ue mac_pkthandler 701\n");
    8893:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    889a:	e8 fc ff ff ff       	call   889b <decomplexUeRARPdu+0x1db>
		FOUT;
    889f:	e9 6a fe ff ff       	jmp    870e <decomplexUeRARPdu+0x4e>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    88a4:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    88ab:	89 d8                	mov    %ebx,%eax
    88ad:	e8 fc ff ff ff       	call   88ae <decomplexUeRARPdu+0x1ee>
			printk("ue mac_pkthandler 740\n");
    88b2:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    88b9:	e8 fc ff ff ff       	call   88ba <decomplexUeRARPdu+0x1fa>
			FOUT;
    88be:	e9 4b fe ff ff       	jmp    870e <decomplexUeRARPdu+0x4e>
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code

		if(!compare(skb->tail-skb->data,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    88c3:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    88ca:	89 d8                	mov    %ebx,%eax
    88cc:	e8 fc ff ff ff       	call   88cd <decomplexUeRARPdu+0x20d>
			printk("ue mac_pkthandler 767\n");
    88d1:	c7 04 24 b1 05 00 00 	movl   $0x5b1,(%esp)
    88d8:	e8 fc ff ff ff       	call   88d9 <decomplexUeRARPdu+0x219>
			FOUT;
    88dd:	e9 2c fe ff ff       	jmp    870e <decomplexUeRARPdu+0x4e>
    88e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    88e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000088f0 <decomplexUeDataPdu>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
void decomplexUeDataPdu(FSM_PKT *skb){		//  
    88f0:	55                   	push   %ebp
    88f1:	89 e5                	mov    %esp,%ebp
    88f3:	57                   	push   %edi
    88f4:	56                   	push   %esi
    88f5:	53                   	push   %ebx
    88f6:	83 ec 54             	sub    $0x54,%esp
    88f9:	e8 fc ff ff ff       	call   88fa <decomplexUeDataPdu+0xa>
    88fe:	89 c3                	mov    %eax,%ebx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    8900:	e8 fc ff ff ff       	call   8901 <decomplexUeDataPdu+0x11>

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8905:	31 d2                	xor    %edx,%edx
    8907:	b9 03 00 00 00       	mov    $0x3,%ecx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    890c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    890f:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8912:	e8 fc ff ff ff       	call   8913 <decomplexUeDataPdu+0x23>
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8917:	31 d2                	xor    %edx,%edx
    8919:	b9 01 00 00 00       	mov    $0x1,%ecx
    891e:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8921:	e8 fc ff ff ff       	call   8922 <decomplexUeDataPdu+0x32>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8926:	31 d2                	xor    %edx,%edx
    8928:	b9 02 00 00 00       	mov    $0x2,%ecx
    892d:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8930:	e8 fc ff ff ff       	call   8931 <decomplexUeDataPdu+0x41>
	fsm_mem_set(&m_content_resolution,0,sizeof(MAC_CE_content_resolution_identity));	//20140430
    8935:	31 d2                	xor    %edx,%edx
    8937:	b9 06 00 00 00       	mov    $0x6,%ecx
    893c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    893f:	e8 fc ff ff ff       	call   8940 <decomplexUeDataPdu+0x50>
	fsm_mem_set(&m_time_advance,0,sizeof(MAC_CE_time_advance));	//20140430
    8944:	31 d2                	xor    %edx,%edx
    8946:	b9 01 00 00 00       	mov    $0x1,%ecx
    894b:	8d 45 f3             	lea    -0xd(%ebp),%eax
    894e:	e8 fc ff ff ff       	call   894f <decomplexUeDataPdu+0x5f>
	fsm_mem_set(&m_rlc_type2_icimsg,0,sizeof(MACtoRLC_IciMsg));	//20140430
    8953:	31 d2                	xor    %edx,%edx
    8955:	b9 07 00 00 00       	mov    $0x7,%ecx
    895a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    895d:	e8 fc ff ff ff       	call   895e <decomplexUeDataPdu+0x6e>
	fsm_mem_set(&m_padding_subhead,0,sizeof(MAC_SH_padding));	//20140430
    8962:	31 d2                	xor    %edx,%edx
    8964:	b9 01 00 00 00       	mov    $0x1,%ecx
    8969:	8d 45 f2             	lea    -0xe(%ebp),%eax
    896c:	e8 fc ff ff ff       	call   896d <decomplexUeDataPdu+0x7d>
	fsm_mem_set(&m_phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    8971:	31 d2                	xor    %edx,%edx
    8973:	b9 07 00 00 00       	mov    $0x7,%ecx
    8978:	8d 45 df             	lea    -0x21(%ebp),%eax
    897b:	e8 fc ff ff ff       	call   897c <decomplexUeDataPdu+0x8c>
    //PHYICI  HQ 20140502

	/*
	 * for test
	 */
	SV(pkt_num_downlink)=SV(pkt_num_downlink)+1;
    8980:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8983:	83 80 10 02 00 00 01 	addl   $0x1,0x210(%eax)


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    898a:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    8990:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8996:	29 d0                	sub    %edx,%eax
    8998:	83 f8 06             	cmp    $0x6,%eax
    899b:	0f 86 6c 06 00 00    	jbe    900d <decomplexUeDataPdu+0x71d>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    89a1:	b9 07 00 00 00       	mov    $0x7,%ecx
    89a6:	8d 45 df             	lea    -0x21(%ebp),%eax
    89a9:	e8 fc ff ff ff       	call   89aa <decomplexUeDataPdu+0xba>
	if(m_phy_ici.tcid==BCH){
    89ae:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
    89b2:	3c 01                	cmp    $0x1,%al
    89b4:	0f 84 a6 00 00 00    	je     8a60 <decomplexUeDataPdu+0x170>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    89ba:	84 c0                	test   %al,%al
    89bc:	74 32                	je     89f0 <decomplexUeDataPdu+0x100>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    89be:	3c 02                	cmp    $0x2,%al
    89c0:	0f 84 f2 00 00 00    	je     8ab8 <decomplexUeDataPdu+0x1c8>
	
	/*
	 * for test
	 */
	 else{
	 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    89c6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    89c9:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
    89d0:	89 d8                	mov    %ebx,%eax
    89d2:	e8 fc ff ff ff       	call   89d3 <decomplexUeDataPdu+0xe3>
   	fsm_printf("decomplex function done\n");//testing code
    89d7:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    89de:	e8 fc ff ff ff       	call   89df <decomplexUeDataPdu+0xef>
	FOUT;
}
    89e3:	83 c4 54             	add    $0x54,%esp
    89e6:	5b                   	pop    %ebx
    89e7:	5e                   	pop    %esi
    89e8:	5f                   	pop    %edi
    89e9:	5d                   	pop    %ebp
    89ea:	c3                   	ret    
    89eb:	90                   	nop
    89ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    89f0:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    89f7:	e8 fc ff ff ff       	call   89f8 <decomplexUeDataPdu+0x108>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    89fc:	e8 fc ff ff ff       	call   89fd <decomplexUeDataPdu+0x10d>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a01:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8a07:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8a0b:	c7 45 da 01 00 00 00 	movl   $0x1,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8a12:	0f b7 00             	movzwl (%eax),%eax
    8a15:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a19:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8a1f:	29 c2                	sub    %eax,%edx
    8a21:	83 fa 06             	cmp    $0x6,%edx
    8a24:	0f 86 99 06 00 00    	jbe    90c3 <decomplexUeDataPdu+0x7d3>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8a2a:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8a2d:	b9 07 00 00 00       	mov    $0x7,%ecx
    8a32:	e8 fc ff ff ff       	call   8a33 <decomplexUeDataPdu+0x143>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(skb);  //add in 20150804
    8a37:	89 d8                	mov    %ebx,%eax
    8a39:	e8 fc ff ff ff       	call   8a3a <decomplexUeDataPdu+0x14a>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8a3e:	8b 43 50             	mov    0x50(%ebx),%eax
    8a41:	c7 04 24 b0 27 00 00 	movl   $0x27b0,(%esp)
    8a48:	89 44 24 04          	mov    %eax,0x4(%esp)
    8a4c:	e8 fc ff ff ff       	call   8a4d <decomplexUeDataPdu+0x15d>
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
   	fsm_printf("decomplex function done\n");//testing code
	FOUT;
}
    8a51:	83 c4 54             	add    $0x54,%esp
    8a54:	5b                   	pop    %ebx
    8a55:	5e                   	pop    %esi
    8a56:	5f                   	pop    %edi
    8a57:	5d                   	pop    %ebp
    8a58:	c3                   	ret    
    8a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8a60:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    8a67:	e8 fc ff ff ff       	call   8a68 <decomplexUeDataPdu+0x178>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8a6c:	e8 fc ff ff ff       	call   8a6d <decomplexUeDataPdu+0x17d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a71:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8a77:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8a7b:	c7 45 da 02 00 00 00 	movl   $0x2,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8a82:	0f b7 00             	movzwl (%eax),%eax
    8a85:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a89:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8a8f:	29 c2                	sub    %eax,%edx
    8a91:	83 fa 06             	cmp    $0x6,%edx
    8a94:	77 94                	ja     8a2a <decomplexUeDataPdu+0x13a>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8a96:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8a99:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    8aa0:	89 d8                	mov    %ebx,%eax
    8aa2:	e8 fc ff ff ff       	call   8aa3 <decomplexUeDataPdu+0x1b3>
			printk("ue mac_pkthandler 715\n");
    8aa7:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    8aae:	e8 fc ff ff ff       	call   8aaf <decomplexUeDataPdu+0x1bf>
			FOUT;
    8ab3:	e9 2b ff ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8ab8:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)


		//fsm_mem_cpy(&m_type,skb->data,len);//  HQ 20140502;delete m_type in 20160222
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
    8abf:	31 f6                	xor    %esi,%esi
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8ac1:	e8 fc ff ff ff       	call   8ac2 <decomplexUeDataPdu+0x1d2>
		//len=sizeof(char);
		len=0;	//modify by lxr in 20160225
		head_len=lteMacGetDlHeadLength(skb);	//SDU
    8ac6:	89 d8                	mov    %ebx,%eax
    8ac8:	e8 fc ff ff ff       	call   8ac9 <decomplexUeDataPdu+0x1d9>
    8acd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
    8ad0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
    8ad4:	e8 fc ff ff ff       	call   8ad5 <decomplexUeDataPdu+0x1e5>
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
    8ad9:	c7 04 24 e5 05 00 00 	movl   $0x5e5,(%esp)
    8ae0:	e8 fc ff ff ff       	call   8ae1 <decomplexUeDataPdu+0x1f1>
    8ae5:	8d 76 00             	lea    0x0(%esi),%esi
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
    8ae8:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8aee:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8af4:	29 d0                	sub    %edx,%eax
    8af6:	39 c6                	cmp    %eax,%esi
    8af8:	0f 84 65 04 00 00    	je     8f63 <decomplexUeDataPdu+0x673>
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8afe:	01 f2                	add    %esi,%edx
    8b00:	b9 01 00 00 00       	mov    $0x1,%ecx
    8b05:	8d 45 f2             	lea    -0xe(%ebp),%eax
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8b08:	bf 1f 00 00 00       	mov    $0x1f,%edi
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8b0d:	e8 fc ff ff ff       	call   8b0e <decomplexUeDataPdu+0x21e>
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8b12:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
    8b16:	89 c2                	mov    %eax,%edx
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8b18:	21 c7                	and    %eax,%edi
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8b1a:	c0 ea 05             	shr    $0x5,%dl
    8b1d:	88 55 d4             	mov    %dl,-0x2c(%ebp)
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
    8b20:	89 7c 24 04          	mov    %edi,0x4(%esp)
    8b24:	c7 04 24 18 06 00 00 	movl   $0x618,(%esp)
    8b2b:	e8 fc ff ff ff       	call   8b2c <decomplexUeDataPdu+0x23c>
				switch(lcid){
    8b30:	83 ff 1d             	cmp    $0x1d,%edi
    8b33:	0f 84 67 03 00 00    	je     8ea0 <decomplexUeDataPdu+0x5b0>
    8b39:	0f 87 11 02 00 00    	ja     8d50 <decomplexUeDataPdu+0x460>
    8b3f:	83 ff 1c             	cmp    $0x1c,%edi
    8b42:	0f 84 28 02 00 00    	je     8d70 <decomplexUeDataPdu+0x480>
						break;
					
				}		
			}			
		
			if(lcid>=0&&lcid<11){
    8b48:	83 ff 0a             	cmp    $0xa,%edi
    8b4b:	90                   	nop
    8b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8b50:	0f 87 fb 04 00 00    	ja     9051 <decomplexUeDataPdu+0x761>
    8b56:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    8b59:	e9 ff 00 00 00       	jmp    8c5d <decomplexUeDataPdu+0x36d>
    8b5e:	66 90                	xchg   %ax,%ax
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8b60:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8b66:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8b6c:	29 d0                	sub    %edx,%eax
    8b6e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8b71:	83 f8 02             	cmp    $0x2,%eax
    8b74:	0f 86 2d 04 00 00    	jbe    8fa7 <decomplexUeDataPdu+0x6b7>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 954\n");
							FOUT;
						}

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
    8b7a:	03 55 d4             	add    -0x2c(%ebp),%edx
    8b7d:	b9 03 00 00 00       	mov    $0x3,%ecx
    8b82:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8b85:	e8 fc ff ff ff       	call   8b86 <decomplexUeDataPdu+0x296>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8b8a:	e8 fc ff ff ff       	call   8b8b <decomplexUeDataPdu+0x29b>
	ici_msg->lcid=lcid;
    8b8f:	89 f2                	mov    %esi,%edx

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8b91:	0f b6 7d ee          	movzbl -0x12(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8b95:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8b98:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8b9f:	0f b7 00             	movzwl (%eax),%eax
    8ba2:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
    8ba6:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    8baa:	83 e0 7f             	and    $0x7f,%eax
						sdu_len=sdu_len<<8;
    8bad:	c1 e0 08             	shl    $0x8,%eax
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8bb0:	01 c7                	add    %eax,%edi
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8bb2:	8d 47 11             	lea    0x11(%edi),%eax
    8bb5:	e8 fc ff ff ff       	call   8bb6 <decomplexUeDataPdu+0x2c6>
						fsm_skb_reserve(newskb,sdu_len);
    8bba:	89 fa                	mov    %edi,%edx
						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8bbc:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8bbe:	e8 fc ff ff ff       	call   8bbf <decomplexUeDataPdu+0x2cf>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
    8bc3:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8bc9:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    8bcf:	29 c2                	sub    %eax,%edx
    8bd1:	83 fa 06             	cmp    $0x6,%edx
    8bd4:	0f 86 ab 03 00 00    	jbe    8f85 <decomplexUeDataPdu+0x695>
							printk("ue mac_pkthandler 976\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
    8bda:	b9 07 00 00 00       	mov    $0x7,%ecx
    8bdf:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8be2:	e8 fc ff ff ff       	call   8be3 <decomplexUeDataPdu+0x2f3>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8be7:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8bed:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8bf3:	39 c7                	cmp    %eax,%edi
    8bf5:	0f 87 24 03 00 00    	ja     8f1f <decomplexUeDataPdu+0x62f>
    8bfb:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8c01:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8c07:	29 d0                	sub    %edx,%eax
    8c09:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8c0c:	39 c7                	cmp    %eax,%edi
    8c0e:	0f 87 0b 03 00 00    	ja     8f1f <decomplexUeDataPdu+0x62f>

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;
    8c14:	83 45 d4 03          	addl   $0x3,-0x2c(%ebp)
							printk("ue mac_pkthandler 1026\n");
							FOUT;
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
    8c18:	03 55 d0             	add    -0x30(%ebp),%edx
    8c1b:	89 f0                	mov    %esi,%eax
    8c1d:	89 55 bc             	mov    %edx,-0x44(%ebp)
    8c20:	89 fa                	mov    %edi,%edx
    8c22:	e8 fc ff ff ff       	call   8c23 <decomplexUeDataPdu+0x333>
    8c27:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8c2a:	89 f9                	mov    %edi,%ecx
    8c2c:	e8 fc ff ff ff       	call   8c2d <decomplexUeDataPdu+0x33d>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8c31:	89 f0                	mov    %esi,%eax
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
    8c33:	01 7d d0             	add    %edi,-0x30(%ebp)
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8c36:	e8 fc ff ff ff       	call   8c37 <decomplexUeDataPdu+0x347>
						//fsm_pkt_send(newskb,STRM_TO_IPADP);

						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
    8c3b:	8b 46 50             	mov    0x50(%esi),%eax
    8c3e:	c7 04 24 b0 27 00 00 	movl   $0x27b0,(%esp)
    8c45:	89 44 24 04          	mov    %eax,0x4(%esp)
    8c49:	e8 fc ff ff ff       	call   8c4a <decomplexUeDataPdu+0x35a>
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8c4e:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
    8c52:	c0 e8 05             	shr    $0x5,%al
				}		
			}			
		
			if(lcid>=0&&lcid<11){
				continue_flag=1;
				while(continue_flag==1){
    8c55:	3c 01                	cmp    $0x1,%al
    8c57:	0f 85 73 fd ff ff    	jne    89d0 <decomplexUeDataPdu+0xe0>
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
    8c5d:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8c63:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8c69:	29 d0                	sub    %edx,%eax
    8c6b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8c6e:	83 f8 01             	cmp    $0x1,%eax
    8c71:	0f 86 ca 02 00 00    	jbe    8f41 <decomplexUeDataPdu+0x651>
						fsm_pkt_destroy(skb);
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
    8c77:	03 55 d4             	add    -0x2c(%ebp),%edx
    8c7a:	b9 02 00 00 00       	mov    $0x2,%ecx
    8c7f:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8c82:	e8 fc ff ff ff       	call   8c83 <decomplexUeDataPdu+0x393>
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8c87:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8c8b:	89 d0                	mov    %edx,%eax
    8c8d:	83 e0 1f             	and    $0x1f,%eax
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8c90:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8c94:	89 c6                	mov    %eax,%esi
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8c96:	88 55 c0             	mov    %dl,-0x40(%ebp)
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8c99:	0f 88 c1 fe ff ff    	js     8b60 <decomplexUeDataPdu+0x270>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8c9f:	e8 fc ff ff ff       	call   8ca0 <decomplexUeDataPdu+0x3b0>
	ici_msg->lcid=lcid;
    8ca4:	89 f2                	mov    %esi,%edx
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8ca6:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8caa:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8cad:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
    8cb4:	83 45 d4 02          	addl   $0x2,-0x2c(%ebp)
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8cb8:	83 e7 7f             	and    $0x7f,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    8cbb:	0f b7 00             	movzwl (%eax),%eax
    8cbe:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8cc2:	8d 47 11             	lea    0x11(%edi),%eax
    8cc5:	e8 fc ff ff ff       	call   8cc6 <decomplexUeDataPdu+0x3d6>
						fsm_skb_reserve(newskb,sdu_len);
    8cca:	89 fa                	mov    %edi,%edx
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8ccc:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8cce:	e8 fc ff ff ff       	call   8ccf <decomplexUeDataPdu+0x3df>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8cd3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8cd9:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8cdf:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8ce2:	83 f8 06             	cmp    $0x6,%eax
    8ce5:	0f 86 de 02 00 00    	jbe    8fc9 <decomplexUeDataPdu+0x6d9>
							printk("ue mac_pkthandler 1015\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);
    8ceb:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8cf1:	b9 07 00 00 00       	mov    $0x7,%ecx
    8cf6:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8cf9:	e8 fc ff ff ff       	call   8cfa <decomplexUeDataPdu+0x40a>


						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8cfe:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8d04:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8d0a:	39 c7                	cmp    %eax,%edi
    8d0c:	77 19                	ja     8d27 <decomplexUeDataPdu+0x437>
    8d0e:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8d14:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8d1a:	29 d0                	sub    %edx,%eax
    8d1c:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8d1f:	39 c7                	cmp    %eax,%edi
    8d21:	0f 86 f1 fe ff ff    	jbe    8c18 <decomplexUeDataPdu+0x328>
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8d27:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8d2a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8d31:	89 d8                	mov    %ebx,%eax
    8d33:	e8 fc ff ff ff       	call   8d34 <decomplexUeDataPdu+0x444>
							printk("ue mac_pkthandler 1026\n");
    8d38:	c7 04 24 f9 06 00 00 	movl   $0x6f9,(%esp)
    8d3f:	e8 fc ff ff ff       	call   8d40 <decomplexUeDataPdu+0x450>
							FOUT;
    8d44:	e9 9a fc ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
    8d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
    8d50:	83 ff 1e             	cmp    $0x1e,%edi
    8d53:	74 09                	je     8d5e <decomplexUeDataPdu+0x46e>
    8d55:	83 ff 1f             	cmp    $0x1f,%edi
    8d58:	0f 85 ea fd ff ff    	jne    8b48 <decomplexUeDataPdu+0x258>
					case DRX_LCID:
						from_len=from_len+len;
						break;
					case PADDING_LCID:
						padding_flag=1;
						from_len=from_len+len;
    8d5e:	83 c6 01             	add    $0x1,%esi
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
			while(continue_flag==1)
    8d61:	80 7d d4 01          	cmpb   $0x1,-0x2c(%ebp)
    8d65:	0f 84 7d fd ff ff    	je     8ae8 <decomplexUeDataPdu+0x1f8>
    8d6b:	e9 d8 fd ff ff       	jmp    8b48 <decomplexUeDataPdu+0x258>
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
					case CONTENTION_RESOLUTION_LCID:	//20140428 
						if(SV(CRTimer.flag)==true){  // 	
    8d70:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8d73:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
    8d7a:	74 e5                	je     8d61 <decomplexUeDataPdu+0x471>
							fsm_schedule_cancel(SV(CRTimer.timer_sign));  //CR  HQ 20140424
    8d7c:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    8d82:	e8 fc ff ff ff       	call   8d83 <decomplexUeDataPdu+0x493>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
    8d87:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8d8a:	c6 80 74 01 00 00 00 	movb   $0x0,0x174(%eax)
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
    8d91:	c7 80 70 01 00 00 00 	movl   $0x0,0x170(%eax)
    8d98:	00 00 00 
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
    8d9b:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8da1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8da7:	29 d0                	sub    %edx,%eax
    8da9:	39 c6                	cmp    %eax,%esi
    8dab:	0f 84 f0 02 00 00    	je     90a1 <decomplexUeDataPdu+0x7b1>
								printk("ue mac_pkthandler 834\n");
								FOUT;
							}


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
    8db1:	01 f2                	add    %esi,%edx
    8db3:	b9 01 00 00 00       	mov    $0x1,%ecx
    8db8:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8dbb:	e8 fc ff ff ff       	call   8dbc <decomplexUeDataPdu+0x4cc>
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);
    8dc0:	89 74 24 04          	mov    %esi,0x4(%esp)
    8dc4:	c7 04 24 5c 28 00 00 	movl   $0x285c,(%esp)
    8dcb:	e8 fc ff ff ff       	call   8dcc <decomplexUeDataPdu+0x4dc>

							from_len=from_len+len;
							len=sizeof(MAC_CE_content_resolution_identity);
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
    8dd0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8dd3:	c7 04 24 90 28 00 00 	movl   $0x2890,(%esp)
    8dda:	89 44 24 04          	mov    %eax,0x4(%esp)
    8dde:	e8 fc ff ff ff       	call   8ddf <decomplexUeDataPdu+0x4ef>
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
    8de3:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8de9:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8def:	29 d0                	sub    %edx,%eax
    8df1:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8df4:	83 f8 05             	cmp    $0x5,%eax
    8df7:	0f 86 82 02 00 00    	jbe    907f <decomplexUeDataPdu+0x78f>
								fsm_pkt_destroy(skb);
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
    8dfd:	03 55 d0             	add    -0x30(%ebp),%edx
    8e00:	b9 06 00 00 00       	mov    $0x6,%ecx
    8e05:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    8e08:	e8 fc ff ff ff       	call   8e09 <decomplexUeDataPdu+0x519>
							part1=m_content_resolution.m_resolusion_identity_1;
							part2=m_content_resolution.m_resolusion_identity_2;
    8e0d:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
							part1=m_content_resolution.m_resolusion_identity_1;
    8e11:	8b 4d e6             	mov    -0x1a(%ebp),%ecx
							part2=m_content_resolution.m_resolusion_identity_2;
    8e14:	66 89 55 c0          	mov    %dx,-0x40(%ebp)

							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);
    8e18:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8e1b:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8e21:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    8e25:	89 54 24 10          	mov    %edx,0x10(%esp)
    8e29:	8b 00                	mov    (%eax),%eax
    8e2b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    8e2f:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
    8e32:	c7 04 24 c0 28 00 00 	movl   $0x28c0,(%esp)
    8e39:	89 44 24 0c          	mov    %eax,0xc(%esp)
    8e3d:	0f bf 45 c0          	movswl -0x40(%ebp),%eax
    8e41:	89 44 24 08          	mov    %eax,0x8(%esp)
    8e45:	e8 fc ff ff ff       	call   8e46 <decomplexUeDataPdu+0x556>

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
    8e4a:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8e4d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    8e50:	8b 82 00 02 00 00    	mov    0x200(%edx),%eax
    8e56:	85 c0                	test   %eax,%eax
    8e58:	74 11                	je     8e6b <decomplexUeDataPdu+0x57b>
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    8e5a:	83 e8 01             	sub    $0x1,%eax
								part1=0;//
    8e5d:	31 c9                	xor    %ecx,%ecx
							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    8e5f:	89 82 00 02 00 00    	mov    %eax,0x200(%edx)
								part1=0;//
								part2=0;
    8e65:	66 c7 45 c0 00 00    	movw   $0x0,-0x40(%ebp)
							}
							/*********************************/

							if(part1==SV(m_temp_cr)->m_part_1&&part2==SV(m_temp_cr)->m_part_2){
    8e6b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8e6e:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8e74:	39 08                	cmp    %ecx,(%eax)
    8e76:	0f 85 88 00 00 00    	jne    8f04 <decomplexUeDataPdu+0x614>
    8e7c:	0f bf 55 c0          	movswl -0x40(%ebp),%edx
    8e80:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8e84:	39 c2                	cmp    %eax,%edx
    8e86:	75 7c                	jne    8f04 <decomplexUeDataPdu+0x614>
							//	SV(contention_resolution_flag)=true;	//flag
								fsm_schedule_self(0, Contention_Success);
    8e88:	ba 06 00 00 00       	mov    $0x6,%edx
    8e8d:	31 c0                	xor    %eax,%eax
    8e8f:	e8 fc ff ff ff       	call   8e90 <decomplexUeDataPdu+0x5a0>


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);

							from_len=from_len+len;
    8e94:	83 c6 01             	add    $0x1,%esi
								
								fsm_schedule_self(0, ContentionResolution_Fail);
								
								FOUT; 
							}
							head_len=head_len+len;
    8e97:	83 45 d0 06          	addl   $0x6,-0x30(%ebp)
    8e9b:	e9 c1 fe ff ff       	jmp    8d61 <decomplexUeDataPdu+0x471>
						}
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8ea0:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8ea6:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8eac:	29 d0                	sub    %edx,%eax
    8eae:	39 c6                	cmp    %eax,%esi
    8eb0:	0f 84 35 01 00 00    	je     8feb <decomplexUeDataPdu+0x6fb>
							printk("ue mac_pkthandler 896\n");
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
    8eb6:	01 f2                	add    %esi,%edx
    8eb8:	b9 01 00 00 00       	mov    $0x1,%ecx
    8ebd:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8ec0:	e8 fc ff ff ff       	call   8ec1 <decomplexUeDataPdu+0x5d1>
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
    8ec5:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8ecb:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8ed1:	29 d0                	sub    %edx,%eax
    8ed3:	39 45 d0             	cmp    %eax,-0x30(%ebp)
    8ed6:	0f 84 53 01 00 00    	je     902f <decomplexUeDataPdu+0x73f>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    8edc:	03 55 d0             	add    -0x30(%ebp),%edx
    8edf:	b9 01 00 00 00       	mov    $0x1,%ecx
    8ee4:	8d 45 f3             	lea    -0xd(%ebp),%eax
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
    8ee7:	83 c6 01             	add    $0x1,%esi
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    8eea:	e8 fc ff ff ff       	call   8eeb <decomplexUeDataPdu+0x5fb>
						head_len=head_len+len;
						timing=(m_time_advance.m_r_r_command)&63;
    8eef:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
						head_len=head_len+len;
    8ef3:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
						timing=(m_time_advance.m_r_r_command)&63;

						MACCETA_handle(timing);
    8ef7:	83 e0 3f             	and    $0x3f,%eax
    8efa:	e8 fc ff ff ff       	call   8efb <decomplexUeDataPdu+0x60b>
						break;
    8eff:	e9 5d fe ff ff       	jmp    8d61 <decomplexUeDataPdu+0x471>
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f04:	8b 45 b8             	mov    -0x48(%ebp),%eax
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    8f07:	ba 05 00 00 00       	mov    $0x5,%edx
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f0c:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    8f13:	31 c0                	xor    %eax,%eax
    8f15:	e8 fc ff ff ff       	call   8f16 <decomplexUeDataPdu+0x626>
								
								FOUT; 
    8f1a:	e9 c4 fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>

						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f1f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f22:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8f29:	89 d8                	mov    %ebx,%eax
    8f2b:	e8 fc ff ff ff       	call   8f2c <decomplexUeDataPdu+0x63c>
							printk("ue mac_pkthandler 987\n");
    8f30:	c7 04 24 ca 06 00 00 	movl   $0x6ca,(%esp)
    8f37:	e8 fc ff ff ff       	call   8f38 <decomplexUeDataPdu+0x648>
							FOUT;
    8f3c:	e9 a2 fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
				continue_flag=1;
				while(continue_flag==1){
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
						SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f41:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f44:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
						fsm_pkt_destroy(skb);
    8f4b:	89 d8                	mov    %ebx,%eax
    8f4d:	e8 fc ff ff ff       	call   8f4e <decomplexUeDataPdu+0x65e>
						printk("ue mac_pkthandler 940\n");
    8f52:	c7 04 24 85 06 00 00 	movl   $0x685,(%esp)
    8f59:	e8 fc ff ff ff       	call   8f5a <decomplexUeDataPdu+0x66a>
						FOUT;
    8f5e:	e9 80 fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
					SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f63:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f66:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
					fsm_pkt_destroy(skb);
    8f6d:	89 d8                	mov    %ebx,%eax
    8f6f:	e8 fc ff ff ff       	call   8f70 <decomplexUeDataPdu+0x680>
					printk("ue mac_pkthandler 814\n");
    8f74:	c7 04 24 01 06 00 00 	movl   $0x601,(%esp)
    8f7b:	e8 fc ff ff ff       	call   8f7c <decomplexUeDataPdu+0x68c>
					FOUT;
    8f80:	e9 5e fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f85:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f88:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8f8f:	89 d8                	mov    %ebx,%eax
    8f91:	e8 fc ff ff ff       	call   8f92 <decomplexUeDataPdu+0x6a2>
							printk("ue mac_pkthandler 976\n");
    8f96:	c7 04 24 b3 06 00 00 	movl   $0x6b3,(%esp)
    8f9d:	e8 fc ff ff ff       	call   8f9e <decomplexUeDataPdu+0x6ae>
							FOUT;
    8fa2:	e9 3c fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8fa7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8faa:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8fb1:	89 d8                	mov    %ebx,%eax
    8fb3:	e8 fc ff ff ff       	call   8fb4 <decomplexUeDataPdu+0x6c4>
							printk("ue mac_pkthandler 954\n");
    8fb8:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    8fbf:	e8 fc ff ff ff       	call   8fc0 <decomplexUeDataPdu+0x6d0>
							FOUT;
    8fc4:	e9 1a fa ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8fc9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8fcc:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8fd3:	89 d8                	mov    %ebx,%eax
    8fd5:	e8 fc ff ff ff       	call   8fd6 <decomplexUeDataPdu+0x6e6>
							printk("ue mac_pkthandler 1015\n");
    8fda:	c7 04 24 e1 06 00 00 	movl   $0x6e1,(%esp)
    8fe1:	e8 fc ff ff ff       	call   8fe2 <decomplexUeDataPdu+0x6f2>
							FOUT;
    8fe6:	e9 f8 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8feb:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8fee:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8ff5:	89 d8                	mov    %ebx,%eax
    8ff7:	e8 fc ff ff ff       	call   8ff8 <decomplexUeDataPdu+0x708>
							printk("ue mac_pkthandler 896\n");
    8ffc:	c7 04 24 57 06 00 00 	movl   $0x657,(%esp)
    9003:	e8 fc ff ff ff       	call   9004 <decomplexUeDataPdu+0x714>
							FOUT;
    9008:	e9 d6 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    900d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9010:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
		fsm_pkt_destroy(skb);
    9017:	89 d8                	mov    %ebx,%eax
    9019:	e8 fc ff ff ff       	call   901a <decomplexUeDataPdu+0x72a>
		printk("ue mac_pkthandler 701\n");
    901e:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    9025:	e8 fc ff ff ff       	call   9026 <decomplexUeDataPdu+0x736>
		FOUT;
    902a:	e9 b4 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    902f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9032:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9039:	89 d8                	mov    %ebx,%eax
    903b:	e8 fc ff ff ff       	call   903c <decomplexUeDataPdu+0x74c>
							printk("ue mac_pkthandler 908\n");
    9040:	c7 04 24 6e 06 00 00 	movl   $0x66e,(%esp)
    9047:	e8 fc ff ff ff       	call   9048 <decomplexUeDataPdu+0x758>
							FOUT;
    904c:	e9 92 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
			
			/*
			 * for test
			 */
			 else{
			 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    9051:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9054:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			 	
			 	fsm_pkt_destroy(skb);
    905b:	89 d8                	mov    %ebx,%eax
    905d:	e8 fc ff ff ff       	call   905e <decomplexUeDataPdu+0x76e>
			 	printk("ue mac_pkthandler 1052\n");
    9062:	c7 04 24 11 07 00 00 	movl   $0x711,(%esp)
    9069:	e8 fc ff ff ff       	call   906a <decomplexUeDataPdu+0x77a>
   				fsm_printf("decomplex function done\n");//testing code
    906e:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    9075:	e8 fc ff ff ff       	call   9076 <decomplexUeDataPdu+0x786>
				FOUT;
    907a:	e9 64 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    907f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9082:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    9089:	89 d8                	mov    %ebx,%eax
    908b:	e8 fc ff ff ff       	call   908c <decomplexUeDataPdu+0x79c>
								printk("ue mac_pkthandler 851\n");
    9090:	c7 04 24 40 06 00 00 	movl   $0x640,(%esp)
    9097:	e8 fc ff ff ff       	call   9098 <decomplexUeDataPdu+0x7a8>
								FOUT;
    909c:	e9 42 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90a1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    90a4:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    90ab:	89 d8                	mov    %ebx,%eax
    90ad:	e8 fc ff ff ff       	call   90ae <decomplexUeDataPdu+0x7be>
								printk("ue mac_pkthandler 834\n");
    90b2:	c7 04 24 29 06 00 00 	movl   $0x629,(%esp)
    90b9:	e8 fc ff ff ff       	call   90ba <decomplexUeDataPdu+0x7ca>
								FOUT;
    90be:	e9 20 f9 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90c3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    90c6:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    90cd:	89 d8                	mov    %ebx,%eax
    90cf:	e8 fc ff ff ff       	call   90d0 <decomplexUeDataPdu+0x7e0>
			printk("ue mac_pkthandler 740\n");
    90d4:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    90db:	e8 fc ff ff ff       	call   90dc <decomplexUeDataPdu+0x7ec>
			FOUT;
    90e0:	e9 fe f8 ff ff       	jmp    89e3 <decomplexUeDataPdu+0xf3>
    90e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    90e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000090f0 <clean_CE_tags>:
}	//ICI()
	
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
    90f0:	55                   	push   %ebp
    90f1:	89 e5                	mov    %esp,%ebp
    90f3:	56                   	push   %esi
    90f4:	53                   	push   %ebx
    90f5:	e8 fc ff ff ff       	call   90f6 <clean_CE_tags+0x6>
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    90fa:	31 db                	xor    %ebx,%ebx
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
    90fc:	e8 fc ff ff ff       	call   90fd <clean_CE_tags+0xd>
    9101:	89 c6                	mov    %eax,%esi
    9103:	90                   	nop
    9104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    9108:	8d 84 de a4 01 00 00 	lea    0x1a4(%esi,%ebx,8),%eax
    910f:	31 d2                	xor    %edx,%edx
    9111:	b9 08 00 00 00       	mov    $0x8,%ecx
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    9116:	83 c3 01             	add    $0x1,%ebx
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    9119:	e8 fc ff ff ff       	call   911a <clean_CE_tags+0x2a>
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    911e:	83 fb 08             	cmp    $0x8,%ebx
    9121:	75 e5                	jne    9108 <clean_CE_tags+0x18>
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
	FOUT;
}
    9123:	5b                   	pop    %ebx
    9124:	5e                   	pop    %esi
    9125:	5d                   	pop    %ebp
    9126:	c3                   	ret    
    9127:	89 f6                	mov    %esi,%esi
    9129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009130 <complexUeMacPdu>:

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9130:	55                   	push   %ebp
    9131:	89 e5                	mov    %esp,%ebp
    9133:	57                   	push   %edi
    9134:	56                   	push   %esi
    9135:	53                   	push   %ebx
    9136:	83 ec 70             	sub    $0x70,%esp
    9139:	e8 fc ff ff ff       	call   913a <complexUeMacPdu+0xa>
    913e:	89 c3                	mov    %eax,%ebx
	u32 bsr_flag;	//bsr
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
    9140:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    9147:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    914e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    9155:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    915c:	e8 fc ff ff ff       	call   915d <complexUeMacPdu+0x2d>

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    9161:	31 d2                	xor    %edx,%edx
    9163:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    9168:	89 c6                	mov    %eax,%esi

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    916a:	8d 45 f1             	lea    -0xf(%ebp),%eax
    916d:	e8 fc ff ff ff       	call   916e <complexUeMacPdu+0x3e>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));		//20140430
    9172:	31 d2                	xor    %edx,%edx
    9174:	b9 02 00 00 00       	mov    $0x2,%ecx
    9179:	8d 45 ed             	lea    -0x13(%ebp),%eax
    917c:	e8 fc ff ff ff       	call   917d <complexUeMacPdu+0x4d>
	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));		//20140430
    9181:	31 d2                	xor    %edx,%edx
    9183:	b9 03 00 00 00       	mov    $0x3,%ecx
    9188:	8d 45 e7             	lea    -0x19(%ebp),%eax
    918b:	e8 fc ff ff ff       	call   918c <complexUeMacPdu+0x5c>
	fsm_mem_set(&m_crnti,0,sizeof(MAC_CE_Crnti));		//20140430
    9190:	31 d2                	xor    %edx,%edx
    9192:	b9 02 00 00 00       	mov    $0x2,%ecx
    9197:	8d 45 ef             	lea    -0x11(%ebp),%eax
    919a:	e8 fc ff ff ff       	call   919b <complexUeMacPdu+0x6b>
	fsm_mem_set(&m_power_headroom,0,sizeof(MAC_CE_power_headroom));//20140430
    919f:	31 d2                	xor    %edx,%edx
    91a1:	b9 01 00 00 00       	mov    $0x1,%ecx
    91a6:	8d 45 f2             	lea    -0xe(%ebp),%eax
    91a9:	e8 fc ff ff ff       	call   91aa <complexUeMacPdu+0x7a>
	fsm_mem_set(&m_short_bsr,0,sizeof(MAC_CE_shortBSR));		//20140430
    91ae:	31 d2                	xor    %edx,%edx
    91b0:	b9 01 00 00 00       	mov    $0x1,%ecx
    91b5:	8d 45 f3             	lea    -0xd(%ebp),%eax
    91b8:	e8 fc ff ff ff       	call   91b9 <complexUeMacPdu+0x89>
	fsm_mem_set(&m_long_bsr,0,sizeof(MAC_CE_longBSR));		//20140430
    91bd:	31 d2                	xor    %edx,%edx
    91bf:	b9 03 00 00 00       	mov    $0x3,%ecx
    91c4:	8d 45 ea             	lea    -0x16(%ebp),%eax
    91c7:	e8 fc ff ff ff       	call   91c8 <complexUeMacPdu+0x98>
	//fsm_mem_set(m_rlc_type2_ici,0,sizeof(RLC_MAC_IciMsgPB));		//20140430
	fsm_mem_set(&m_rlc_type1_ici,0,sizeof(RLCtoMAC_IciMsg));		//20140430
    91cc:	31 d2                	xor    %edx,%edx
    91ce:	b9 04 00 00 00       	mov    $0x4,%ecx
    91d3:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    91d6:	e8 fc ff ff ff       	call   91d7 <complexUeMacPdu+0xa7>
	fsm_mem_set(&m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    91db:	31 d2                	xor    %edx,%edx
    91dd:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    91e2:	8d 45 a6             	lea    -0x5a(%ebp),%eax
    91e5:	e8 fc ff ff ff       	call   91e6 <complexUeMacPdu+0xb6>
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506
    91ea:	31 d2                	xor    %edx,%edx
    91ec:	b9 07 00 00 00       	mov    $0x7,%ecx
    91f1:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    91f4:	e8 fc ff ff ff       	call   91f5 <complexUeMacPdu+0xc5>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
    91f9:	8b bb ac 00 00 00    	mov    0xac(%ebx),%edi
    91ff:	2b bb a8 00 00 00    	sub    0xa8(%ebx),%edi



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    9205:	8d 47 0a             	lea    0xa(%edi),%eax
    9208:	e8 fc ff ff ff       	call   9209 <complexUeMacPdu+0xd9>

	if(!compare(skb->data-skb->head,re_len)){
    920d:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    9213:	89 45 a0             	mov    %eax,-0x60(%ebp)

	if(!compare(skb->data-skb->head,re_len)){
    9216:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    921c:	29 d0                	sub    %edx,%eax
    921e:	39 f8                	cmp    %edi,%eax
    9220:	0f 82 ca 03 00 00    	jb     95f0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(head_backup,skb->head,re_len);
    9226:	8b 45 a0             	mov    -0x60(%ebp),%eax
    9229:	89 f9                	mov    %edi,%ecx
    922b:	e8 fc ff ff ff       	call   922c <complexUeMacPdu+0xfc>
	
	
	/*
	 * for test
	 */
	SV(pkt_num_uplink)=SV(pkt_num_uplink)+1;
    9230:	83 86 08 02 00 00 01 	addl   $0x1,0x208(%esi)

	len=sizeof(RLCtoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    9237:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    923d:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9243:	29 d0                	sub    %edx,%eax
    9245:	83 f8 03             	cmp    $0x3,%eax
    9248:	0f 86 a2 03 00 00    	jbe    95f0 <complexUeMacPdu+0x4c0>
		fsm_pkt_destroy(skb);
		FOUT;
	}


	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
    924e:	b9 04 00 00 00       	mov    $0x4,%ecx
    9253:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    9256:	e8 fc ff ff ff       	call   9257 <complexUeMacPdu+0x127>
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
    925b:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    925f:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
    9263:	0f b7 c0             	movzwl %ax,%eax
    9266:	89 44 24 04          	mov    %eax,0x4(%esp)
    926a:	c7 04 24 04 29 00 00 	movl   $0x2904,(%esp)
    9271:	e8 fc ff ff ff       	call   9272 <complexUeMacPdu+0x142>
	if(skb->data==skb->tail){	//SDU,
    9276:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    927c:	89 45 98             	mov    %eax,-0x68(%ebp)
    927f:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9285:	89 45 94             	mov    %eax,-0x6c(%ebp)
	}
	else
		e=1;	//20131110modified

	total_len=SV(Tbsize_Complex);
	fsm_printf("[COMPLEX]TBSIZE:%d\n",SV(Tbsize_Complex));	
    9288:	8b 86 f4 01 00 00    	mov    0x1f4(%esi),%eax
    928e:	c7 04 24 42 07 00 00 	movl   $0x742,(%esp)
    9295:	89 44 24 04          	mov    %eax,0x4(%esp)
    9299:	e8 fc ff ff ff       	call   929a <complexUeMacPdu+0x16a>
		len=sizeof(RLCtoMAC_IciMsg);
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
    929e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    92a4:	0f b7 55 e5          	movzwl -0x1b(%ebp),%edx
    92a8:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    92ae:	01 d0                	add    %edx,%eax
    92b0:	3d fa 05 00 00       	cmp    $0x5fa,%eax
    92b5:	0f 87 5d 03 00 00    	ja     9618 <complexUeMacPdu+0x4e8>
		fsm_pkt_destroy(skb);
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
    92bb:	8d 45 ef             	lea    -0x11(%ebp),%eax
    92be:	e8 fc ff ff ff       	call   92bf <complexUeMacPdu+0x18f>
    92c3:	88 45 9c             	mov    %al,-0x64(%ebp)
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    92c6:	8d 45 f2             	lea    -0xe(%ebp),%eax
    92c9:	e8 fc ff ff ff       	call   92ca <complexUeMacPdu+0x19a>
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    92ce:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    92d1:	8d 55 dc             	lea    -0x24(%ebp),%edx
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    92d4:	88 45 9d             	mov    %al,-0x63(%ebp)
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    92d7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    92da:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    92e1:	e8 fc ff ff ff       	call   92e2 <complexUeMacPdu+0x1b2>
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    92e6:	83 f8 01             	cmp    $0x1,%eax
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    92e9:	89 c7                	mov    %eax,%edi
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    92eb:	76 0c                	jbe    92f9 <complexUeMacPdu+0x1c9>
	
		test_len++;
	
		if(con_flag)
			fsm_printf("[COMPLEX]LONG BSR CONTROL ELEMENT FOUND!\n");
    92ed:	c7 04 24 4c 29 00 00 	movl   $0x294c,(%esp)
    92f4:	e8 fc ff ff ff       	call   92f5 <complexUeMacPdu+0x1c5>
	test_rnti=test_ici.rnti;
	fsm_printf("[HEXI]LCID AND RNTI OF CCCH AFTER REALLOC:%d %d\n",test_lcid,test_rnti);*/

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
    92f9:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    92fd:	74 2f                	je     932e <complexUeMacPdu+0x1fe>
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST

		if(!compare(skb->data-skb->head,len)){
    92ff:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9305:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST
    930b:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)

		if(!compare(skb->data-skb->head,len)){
    930f:	0f 84 db 02 00 00    	je     95f0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_power_headroom,len);	//NEWSDU
    9315:	ba 01 00 00 00       	mov    $0x1,%edx
    931a:	89 d8                	mov    %ebx,%eax
    931c:	e8 fc ff ff ff       	call   931d <complexUeMacPdu+0x1ed>
    9321:	b9 01 00 00 00       	mov    $0x1,%ecx
    9326:	8d 55 f2             	lea    -0xe(%ebp),%edx
    9329:	e8 fc ff ff ff       	call   932a <complexUeMacPdu+0x1fa>
		
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti->m_crnti);
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR
    932e:	85 ff                	test   %edi,%edi
    9330:	0f 85 6a 02 00 00    	jne    95a0 <complexUeMacPdu+0x470>
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL SUBHEAD:%d\n",(skb->tail-skb->data));
	
	if(crnti_flag){
    9336:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    933a:	74 4a                	je     9386 <complexUeMacPdu+0x256>
		len=sizeof(MAC_CE_Crnti);

		if(!compare(skb->data-skb->head,len)){
    933c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9342:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    9348:	83 f8 01             	cmp    $0x1,%eax
    934b:	0f 86 9f 02 00 00    	jbe    95f0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_crnti,len);	//NEWSDU
    9351:	ba 02 00 00 00       	mov    $0x2,%edx
    9356:	89 d8                	mov    %ebx,%eax
    9358:	e8 fc ff ff ff       	call   9359 <complexUeMacPdu+0x229>
    935d:	b9 02 00 00 00       	mov    $0x2,%ecx
    9362:	8d 55 ef             	lea    -0x11(%ebp),%edx
    9365:	e8 fc ff ff ff       	call   9366 <complexUeMacPdu+0x236>
		rnti_to_ici=SV(T_C_RNTI);
    936a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
    936e:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti.m_crnti);
    9372:	0f b7 45 ef          	movzwl -0x11(%ebp),%eax
    9376:	c7 04 24 78 29 00 00 	movl   $0x2978,(%esp)
    937d:	89 44 24 04          	mov    %eax,0x4(%esp)
    9381:	e8 fc ff ff ff       	call   9382 <complexUeMacPdu+0x252>
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9386:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    938c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9392:	0f b7 4d e5          	movzwl -0x1b(%ebp),%ecx
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9396:	29 d0                	sub    %edx,%eax
    9398:	83 e8 04             	sub    $0x4,%eax
    939b:	83 f8 01             	cmp    $0x1,%eax
    939e:	0f 86 4c 02 00 00    	jbe    95f0 <complexUeMacPdu+0x4c0>
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    93a4:	0f b7 c9             	movzwl %cx,%ecx
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    93a7:	83 c2 04             	add    $0x4,%edx
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    93aa:	89 4d 90             	mov    %ecx,-0x70(%ebp)
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    93ad:	8d 45 ed             	lea    -0x13(%ebp),%eax
    93b0:	b9 02 00 00 00       	mov    $0x2,%ecx
    93b5:	e8 fc ff ff ff       	call   93b6 <complexUeMacPdu+0x286>
	m_7bit_subhead.m_f_l=m_7bit_subhead.m_f_l>>7;
    93ba:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    93be:	c0 e8 07             	shr    $0x7,%al
    93c1:	88 45 ee             	mov    %al,-0x12(%ebp)
	fsm_printf("THE TYPE OF SDU:%d\n",m_7bit_subhead.m_f_l);
    93c4:	0f b6 c0             	movzbl %al,%eax
    93c7:	89 44 24 04          	mov    %eax,0x4(%esp)
    93cb:	c7 04 24 56 07 00 00 	movl   $0x756,(%esp)
    93d2:	e8 fc ff ff ff       	call   93d3 <complexUeMacPdu+0x2a3>
	
	
	test_len+=head_len;
	//fsm_printf("[COMPLEX]THE ORIGINAL LENGTH AND LENGTH OF THE HEADS:%d,%d\n",m_rlc_type1_ici->len,head_len);
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING SDU SUBHEAD:%d\n",(skb->tail-skb->data));
	if(!compare(skb->data-skb->head-len,head_len)){
    93d7:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    93dd:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    93e3:	83 e8 04             	sub    $0x4,%eax
    93e6:	39 45 90             	cmp    %eax,-0x70(%ebp)
    93e9:	0f 87 01 02 00 00    	ja     95f0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_skb_push(skb,head_len);		
    93ef:	8b 55 90             	mov    -0x70(%ebp),%edx
    93f2:	89 d8                	mov    %ebx,%eax
    93f4:	e8 fc ff ff ff       	call   93f5 <complexUeMacPdu+0x2c5>
	fsm_mem_cpy(skb->data,(u8*)head_backup+len,head_len);	//SDUdata 	//for test
    93f9:	8b 55 a0             	mov    -0x60(%ebp),%edx
    93fc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9402:	8b 4d 90             	mov    -0x70(%ebp),%ecx
    9405:	83 c2 04             	add    $0x4,%edx
    9408:	e8 fc ff ff ff       	call   9409 <complexUeMacPdu+0x2d9>

	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
    940d:	85 ff                	test   %edi,%edi
    940f:	0f 84 bb 02 00 00    	je     96d0 <complexUeMacPdu+0x5a0>

	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
	if(skb->data==skb->tail){	//SDU,
		e=0;
    9415:	8b 45 94             	mov    -0x6c(%ebp),%eax
    9418:	39 45 98             	cmp    %eax,-0x68(%ebp)
    941b:	0f 95 c0             	setne  %al
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
    941e:	c1 e0 05             	shl    $0x5,%eax
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
    9421:	83 ff 01             	cmp    $0x1,%edi
    9424:	0f 84 46 02 00 00    	je     9670 <complexUeMacPdu+0x540>
			//fsm_printf("PUT IN THE LONG BSR HEAD!\n");


			lcid=LONG_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    942a:	83 c0 1e             	add    $0x1e,%eax
    942d:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9430:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9436:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    943c:	0f 84 ae 01 00 00    	je     95f0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9442:	ba 01 00 00 00       	mov    $0x1,%edx
    9447:	89 d8                	mov    %ebx,%eax
    9449:	e8 fc ff ff ff       	call   944a <complexUeMacPdu+0x31a>
    944e:	b9 01 00 00 00       	mov    $0x1,%ecx
	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
    9453:	31 ff                	xor    %edi,%edi
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9455:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9458:	e8 fc ff ff ff       	call   9459 <complexUeMacPdu+0x329>
			head_len=head_len+len;
		}
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    945d:	31 d2                	xor    %edx,%edx
    945f:	b9 01 00 00 00       	mov    $0x1,%ecx
    9464:	8d 45 f1             	lea    -0xf(%ebp),%eax
    9467:	e8 fc ff ff ff       	call   9468 <complexUeMacPdu+0x338>
	if(crnti_flag){
    946c:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    9470:	74 39                	je     94ab <complexUeMacPdu+0x37b>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9472:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=e<<5;
    9475:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9478:	8d 47 1b             	lea    0x1b(%edi),%eax
    947b:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    947e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9484:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    948a:	0f 84 60 01 00 00    	je     95f0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9490:	ba 01 00 00 00       	mov    $0x1,%edx
    9495:	89 d8                	mov    %ebx,%eax
    9497:	e8 fc ff ff ff       	call   9498 <complexUeMacPdu+0x368>
    949c:	b9 01 00 00 00       	mov    $0x1,%ecx
    94a1:	31 ff                	xor    %edi,%edi
    94a3:	8d 55 f1             	lea    -0xf(%ebp),%edx
    94a6:	e8 fc ff ff ff       	call   94a7 <complexUeMacPdu+0x377>
		head_len=head_len+len;
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    94ab:	31 d2                	xor    %edx,%edx
    94ad:	b9 01 00 00 00       	mov    $0x1,%ecx
    94b2:	8d 45 f1             	lea    -0xf(%ebp),%eax
    94b5:	e8 fc ff ff ff       	call   94b6 <complexUeMacPdu+0x386>
	if(ph_flag){
    94ba:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    94be:	74 37                	je     94f7 <complexUeMacPdu+0x3c7>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    94c0:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=(e<<5);
    94c3:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    94c6:	8d 47 1a             	lea    0x1a(%edi),%eax
    94c9:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    94cc:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    94d2:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    94d8:	0f 84 12 01 00 00    	je     95f0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    94de:	ba 01 00 00 00       	mov    $0x1,%edx
    94e3:	89 d8                	mov    %ebx,%eax
    94e5:	e8 fc ff ff ff       	call   94e6 <complexUeMacPdu+0x3b6>
    94ea:	b9 01 00 00 00       	mov    $0x1,%ecx
    94ef:	8d 55 f1             	lea    -0xf(%ebp),%edx
    94f2:	e8 fc ff ff ff       	call   94f3 <complexUeMacPdu+0x3c3>
		
		//fsm_printf("[COMPLEX]PH SUBHED:%c\n",m_fixed_subhead->m_lcid_e_r_r+10);
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL ELEMENTS:%d\n",(skb->tail-skb->data));
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    94f7:	0f b7 4d 9e          	movzwl -0x62(%ebp),%ecx
    94fb:	ba 02 00 00 00       	mov    $0x2,%edx
    9500:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    9503:	e8 fc ff ff ff       	call   9504 <complexUeMacPdu+0x3d4>
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 
    9508:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    950c:	89 44 24 08          	mov    %eax,0x8(%esp)
    9510:	0f b7 45 d5          	movzwl -0x2b(%ebp),%eax
    9514:	c7 04 24 9c 29 00 00 	movl   $0x299c,(%esp)
    951b:	89 44 24 04          	mov    %eax,0x4(%esp)
    951f:	e8 fc ff ff ff       	call   9520 <complexUeMacPdu+0x3f0>

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
    9524:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    952a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9530:	29 c2                	sub    %eax,%edx
    9532:	83 fa 06             	cmp    $0x6,%edx
    9535:	0f 86 b5 00 00 00    	jbe    95f0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

    	fsm_mem_cpy(skb->head,&m_phy_ici,sizeof(MACtoPHYadapter_IciMsg));//ICIsk_buf//20140506 HQ
    953b:	b9 07 00 00 00       	mov    $0x7,%ecx
    9540:	8d 55 d1             	lea    -0x2f(%ebp),%edx
    9543:	e8 fc ff ff ff       	call   9544 <complexUeMacPdu+0x414>
    		fsm_printf("%c ",*(skb->data+i)+65);
    	}*/
    	
    	//fsm_octets_print(skb->data,7);
    	
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
    9548:	ba 03 00 00 00       	mov    $0x3,%edx
    954d:	89 d8                	mov    %ebx,%eax
    954f:	e8 fc ff ff ff       	call   9550 <complexUeMacPdu+0x420>
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
    9554:	8b 43 50             	mov    0x50(%ebx),%eax
    9557:	c7 04 24 c8 29 00 00 	movl   $0x29c8,(%esp)
    955e:	89 44 24 04          	mov    %eax,0x4(%esp)
    9562:	e8 fc ff ff ff       	call   9563 <complexUeMacPdu+0x433>
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping
    9567:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    956d:	ba 50 00 00 00       	mov    $0x50,%edx
    9572:	e8 fc ff ff ff       	call   9573 <complexUeMacPdu+0x443>
	SV(Tbsize_Complex)=0;

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9577:	8b 45 a0             	mov    -0x60(%ebp),%eax
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping

	SV(Tbsize_Complex)=0;
    957a:	c7 86 f4 01 00 00 00 	movl   $0x0,0x1f4(%esi)
    9581:	00 00 00 

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9584:	e8 fc ff ff ff       	call   9585 <complexUeMacPdu+0x455>
	clean_CE_tags();// modified by HQ 20140512 
    9589:	e8 fc ff ff ff       	call   958a <complexUeMacPdu+0x45a>
	fsm_printf("complex function done\n");//testing code 
    958e:	c7 04 24 6a 07 00 00 	movl   $0x76a,(%esp)
    9595:	e8 fc ff ff ff       	call   9596 <complexUeMacPdu+0x466>
	fsm_printf("%c,\n",*(skb->data+from_len));
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
    959a:	eb 6f                	jmp    960b <complexUeMacPdu+0x4db>
    959c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
    95a0:	83 ff 01             	cmp    $0x1,%edi
    95a3:	0f 84 e7 00 00 00    	je     9690 <complexUeMacPdu+0x560>

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    95a9:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		else{
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
    95ac:	8b 45 c0             	mov    -0x40(%ebp),%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    95af:	89 ca                	mov    %ecx,%edx
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
    95b1:	c1 e0 02             	shl    $0x2,%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    95b4:	83 e2 30             	and    $0x30,%edx
    95b7:	0f b6 c0             	movzbl %al,%eax
    95ba:	01 d0                	add    %edx,%eax
    95bc:	c1 e8 04             	shr    $0x4,%eax
    95bf:	88 45 ea             	mov    %al,-0x16(%ebp)
			m_long_bsr.m_buffersize2=(longbsr_buf_sizes[1]&15);
    95c2:	89 c8                	mov    %ecx,%eax
    95c4:	83 e0 0f             	and    $0xf,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    95c7:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[2];
    95ca:	66 03 45 c8          	add    -0x38(%ebp),%ax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    95ce:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[3];
    95d1:	66 03 45 cc          	add    -0x34(%ebp),%ax
    95d5:	66 89 45 eb          	mov    %ax,-0x15(%ebp)
			//
			//fsm_printf("[COMPLEX]BSR VALUE:%c,%d\n",m_long_bsr->m_buffersize1+65,m_long_bsr->m_buffersize2);

			len=sizeof(MAC_CE_longBSR);

			if(!compare(skb->data-skb->head,len)){
    95d9:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    95df:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    95e5:	83 f8 02             	cmp    $0x2,%eax
    95e8:	77 5e                	ja     9648 <complexUeMacPdu+0x518>
    95ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
			fsm_mem_free(head_backup);
    95f0:	8b 45 a0             	mov    -0x60(%ebp),%eax
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    95f3:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
			fsm_mem_free(head_backup);
    95fa:	e8 fc ff ff ff       	call   95fb <complexUeMacPdu+0x4cb>
			clean_CE_tags();
    95ff:	e8 fc ff ff ff       	call   9600 <complexUeMacPdu+0x4d0>
			fsm_pkt_destroy(skb);
    9604:	89 d8                	mov    %ebx,%eax
    9606:	e8 fc ff ff ff       	call   9607 <complexUeMacPdu+0x4d7>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    960b:	83 c4 70             	add    $0x70,%esp
    960e:	5b                   	pop    %ebx
    960f:	5e                   	pop    %esi
    9610:	5f                   	pop    %edi
    9611:	5d                   	pop    %ebp
    9612:	c3                   	ret    
    9613:	90                   	nop
    9614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9618:	8b 45 a0             	mov    -0x60(%ebp),%eax
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    961b:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9622:	e8 fc ff ff ff       	call   9623 <complexUeMacPdu+0x4f3>
		clean_CE_tags();// modified by HQ 20140512 
    9627:	e8 fc ff ff ff       	call   9628 <complexUeMacPdu+0x4f8>
		fsm_printf("complex function done by error!\n");//testing code 
    962c:	c7 04 24 28 29 00 00 	movl   $0x2928,(%esp)
    9633:	e8 fc ff ff ff       	call   9634 <complexUeMacPdu+0x504>
		fsm_pkt_destroy(skb);
    9638:	89 d8                	mov    %ebx,%eax
    963a:	e8 fc ff ff ff       	call   963b <complexUeMacPdu+0x50b>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    963f:	83 c4 70             	add    $0x70,%esp
    9642:	5b                   	pop    %ebx
    9643:	5e                   	pop    %esi
    9644:	5f                   	pop    %edi
    9645:	5d                   	pop    %ebp
    9646:	c3                   	ret    
    9647:	90                   	nop
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_long_bsr,len);	//BSR
    9648:	ba 03 00 00 00       	mov    $0x3,%edx
    964d:	89 d8                	mov    %ebx,%eax
    964f:	e8 fc ff ff ff       	call   9650 <complexUeMacPdu+0x520>
    9654:	b9 03 00 00 00       	mov    $0x3,%ecx
    9659:	8d 55 ea             	lea    -0x16(%ebp),%edx
    965c:	e8 fc ff ff ff       	call   965d <complexUeMacPdu+0x52d>
			}
			SV(RetxBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)*100;
			SV(RetxBSRTimer).timer_sign = fsm_schedule_self(SV(RetxBSRTimer).time_value,RexBSRTimer_Expire );
			SV(RetxBSRTimer).flag = true; */			
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
    9661:	e8 fc ff ff ff       	call   9662 <complexUeMacPdu+0x532>
    9666:	e9 cb fc ff ff       	jmp    9336 <complexUeMacPdu+0x206>
    966b:	90                   	nop
    966c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9670:	83 c0 1d             	add    $0x1d,%eax
    9673:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9676:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    967c:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9682:	0f 85 ba fd ff ff    	jne    9442 <complexUeMacPdu+0x312>
    9688:	e9 63 ff ff ff       	jmp    95f0 <complexUeMacPdu+0x4c0>
    968d:	8d 76 00             	lea    0x0(%esi),%esi
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
			m_short_bsr.m_lcgid_buffersize=lcg_id;
    9690:	8b 45 d8             	mov    -0x28(%ebp),%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize<<6;
    9693:	c1 e0 06             	shl    $0x6,%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize+(shortbsr_buf_size);
    9696:	02 45 dc             	add    -0x24(%ebp),%al
    9699:	88 45 f3             	mov    %al,-0xd(%ebp)
			len=sizeof(MAC_CE_shortBSR);

			if(!compare(skb->data-skb->head,len)){
    969c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    96a2:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    96a8:	0f 84 42 ff ff ff    	je     95f0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_short_bsr,len);	//BSR
    96ae:	ba 01 00 00 00       	mov    $0x1,%edx
    96b3:	89 d8                	mov    %ebx,%eax
    96b5:	e8 fc ff ff ff       	call   96b6 <complexUeMacPdu+0x586>
    96ba:	b9 01 00 00 00       	mov    $0x1,%ecx
    96bf:	8d 55 f3             	lea    -0xd(%ebp),%edx
    96c2:	e8 fc ff ff ff       	call   96c3 <complexUeMacPdu+0x593>
    96c7:	eb 98                	jmp    9661 <complexUeMacPdu+0x531>
    96c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
	bool crnti_flag=false, ph_flag=false,first_flag=true,con_flag=true;	//crnti; 
    96d0:	bf 01 00 00 00       	mov    $0x1,%edi
    96d5:	e9 83 fd ff ff       	jmp    945d <complexUeMacPdu+0x32d>
    96da:	90                   	nop
    96db:	90                   	nop
    96dc:	90                   	nop
    96dd:	90                   	nop
    96de:	90                   	nop
    96df:	90                   	nop

000096e0 <Init_Uemac_Scheduler>:
->output:
->Special:
*******************************
*/
void Init_Uemac_Scheduler(void)
{
    96e0:	55                   	push   %ebp
    96e1:	89 e5                	mov    %esp,%ebp
    96e3:	53                   	push   %ebx
    96e4:	e8 fc ff ff ff       	call   96e5 <Init_Uemac_Scheduler+0x5>
	FIN(Init_Uemac_Scheduler(void));
	SV_PTR_GET(rlc_mac_sv);
    96e9:	e8 fc ff ff ff       	call   96ea <Init_Uemac_Scheduler+0xa>
    96ee:	89 c3                	mov    %eax,%ebx
	SV(LCGZeroToData)=false;
    96f0:	c6 80 58 01 00 00 00 	movb   $0x0,0x158(%eax)
	SV(m_freshUlBsr)=false;
    96f7:	c6 80 59 01 00 00 00 	movb   $0x0,0x159(%eax)
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;
    96fe:	c6 80 5a 01 00 00 00 	movb   $0x0,0x15a(%eax)

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9705:	b8 1a 00 00 00       	mov    $0x1a,%eax
    970a:	e8 fc ff ff ff       	call   970b <Init_Uemac_Scheduler+0x2b>
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    970f:	31 d2                	xor    %edx,%edx
    9711:	b9 1a 00 00 00       	mov    $0x1a,%ecx
	SV(LCGZeroToData)=false;
	SV(m_freshUlBsr)=false;
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9716:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    971c:	e8 fc ff ff ff       	call   971d <Init_Uemac_Scheduler+0x3d>
	SV(Periodicbsr)=NULL;
	SV(Regularbsr)=NULL;
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9721:	b8 0d 00 00 00       	mov    $0xd,%eax
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
	SV(Periodicbsr)=NULL;
    9726:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    972d:	00 00 00 
	SV(Regularbsr)=NULL;
    9730:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    9737:	00 00 00 
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    973a:	e8 fc ff ff ff       	call   973b <Init_Uemac_Scheduler+0x5b>
    973f:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
	SV(LogicalChannel_Bj)=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    9745:	b8 0d 00 00 00       	mov    $0xd,%eax
    974a:	e8 fc ff ff ff       	call   974b <Init_Uemac_Scheduler+0x6b>
    974f:	89 83 44 01 00 00    	mov    %eax,0x144(%ebx)
	SV(LogicalChannel_Config)=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9755:	b8 19 00 00 00       	mov    $0x19,%eax
    975a:	e8 fc ff ff ff       	call   975b <Init_Uemac_Scheduler+0x7b>
    975f:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
	INIT_LIST_HEAD(&(SV(MacBuffer_RLC)->list));
    9765:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    976b:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    976e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9771:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Bj)->list));
    9774:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
    977a:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    977d:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9780:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Config)->list));
    9783:	8b 83 40 01 00 00    	mov    0x140(%ebx),%eax
    9789:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    978c:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    978f:	89 50 15             	mov    %edx,0x15(%eax)
	FOUT;
}
    9792:	5b                   	pop    %ebx
    9793:	5d                   	pop    %ebp
    9794:	c3                   	ret    
    9795:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000097a0 <RlcRequest_arraytolist>:
->Output:RlcBufferRequest 
->Special:
*******************************
*/
RlcBufferRequest * RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num)//num
{
    97a0:	55                   	push   %ebp
    97a1:	89 e5                	mov    %esp,%ebp
    97a3:	57                   	push   %edi
    97a4:	56                   	push   %esi
    97a5:	53                   	push   %ebx
    97a6:	83 ec 18             	sub    $0x18,%esp
    97a9:	e8 fc ff ff ff       	call   97aa <RlcRequest_arraytolist+0xa>
    97ae:	89 55 e8             	mov    %edx,-0x18(%ebp)
    97b1:	89 c6                	mov    %eax,%esi
	LogicalChannelConfigInfo *temp_lcc_info;
	u8 lcid;
	u32 flag;

	FIN(RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num));
	SV_PTR_GET(rlc_mac_sv);
    97b3:	e8 fc ff ff ff       	call   97b4 <RlcRequest_arraytolist+0x14>
    97b8:	89 c7                	mov    %eax,%edi
	rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    97ba:	b8 1b 00 00 00       	mov    $0x1b,%eax
    97bf:	e8 fc ff ff ff       	call   97c0 <RlcRequest_arraytolist+0x20>
    97c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    97c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
    97ca:	83 c0 13             	add    $0x13,%eax
    97cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    97d0:	89 42 13             	mov    %eax,0x13(%edx)
	list->prev = list;
    97d3:	89 42 17             	mov    %eax,0x17(%edx)
	for(i=0;i<num;i++)
    97d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    97d9:	85 c0                	test   %eax,%eax
    97db:	74 52                	je     982f <RlcRequest_arraytolist+0x8f>
    97dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    97e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    97e8:	8b 87 40 01 00 00    	mov    0x140(%edi),%eax
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
    97ee:	0f b6 56 02          	movzbl 0x2(%esi),%edx
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    97f2:	8b 58 11             	mov    0x11(%eax),%ebx
    97f5:	83 eb 11             	sub    $0x11,%ebx
    97f8:	39 d8                	cmp    %ebx,%eax
    97fa:	74 12                	je     980e <RlcRequest_arraytolist+0x6e>
		{
			if(lcid==temp_lcc_info->lcid)
    97fc:	38 13                	cmp    %dl,(%ebx)
    97fe:	74 48                	je     9848 <RlcRequest_arraytolist+0xa8>
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9800:	8b 5b 11             	mov    0x11(%ebx),%ebx
    9803:	83 eb 11             	sub    $0x11,%ebx
    9806:	39 9f 40 01 00 00    	cmp    %ebx,0x140(%edi)
    980c:	75 ee                	jne    97fc <RlcRequest_arraytolist+0x5c>
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
    980e:	c7 04 24 30 2a 00 00 	movl   $0x2a30,(%esp)
    9815:	e8 fc ff ff ff       	call   9816 <RlcRequest_arraytolist+0x76>
    981a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
    9820:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9824:	83 c6 13             	add    $0x13,%esi
    9827:	8b 55 e8             	mov    -0x18(%ebp),%edx
    982a:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    982d:	75 b9                	jne    97e8 <RlcRequest_arraytolist+0x48>
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    982f:	8b 55 e8             	mov    -0x18(%ebp),%edx
	FRET(rlcrequest);
}
    9832:	8b 45 ec             	mov    -0x14(%ebp),%eax
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    9835:	89 97 5c 01 00 00    	mov    %edx,0x15c(%edi)
	FRET(rlcrequest);
}
    983b:	83 c4 18             	add    $0x18,%esp
    983e:	5b                   	pop    %ebx
    983f:	5e                   	pop    %esi
    9840:	5f                   	pop    %edi
    9841:	5d                   	pop    %ebp
    9842:	c3                   	ret    
    9843:	90                   	nop
    9844:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			if(lcid==temp_lcc_info->lcid)
			{
				if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9848:	83 7b 0d 03          	cmpl   $0x3,0xd(%ebx)
    984c:	77 6a                	ja     98b8 <RlcRequest_arraytolist+0x118>
				}
			}
		}
		if(flag==1)//requestMAC 
		{		
			rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    984e:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9853:	e8 fc ff ff ff       	call   9854 <RlcRequest_arraytolist+0xb4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9858:	8b 5d ec             	mov    -0x14(%ebp),%ebx
			/*while(rlcrequest_temp==0)//
			{
				rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
			}*/
			INIT_LIST_HEAD(&(rlcrequest_temp->list));
    985b:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    985e:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9861:	89 50 17             	mov    %edx,0x17(%eax)
			rlcrequest_temp->rnti=rlc_request_array[i].rnti;
    9864:	0f b7 0e             	movzwl (%esi),%ecx
    9867:	66 89 08             	mov    %cx,(%eax)
			rlcrequest_temp->lcid=rlc_request_array[i].lcid;
    986a:	0f b6 4e 02          	movzbl 0x2(%esi),%ecx
    986e:	88 48 02             	mov    %cl,0x2(%eax)
			rlcrequest_temp->txQueueSize=rlc_request_array[i].txQueueSize;
    9871:	8b 4e 03             	mov    0x3(%esi),%ecx
    9874:	89 48 03             	mov    %ecx,0x3(%eax)
			rlcrequest_temp->txQueueHeader=rlc_request_array[i].txQueueHeader;
    9877:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    987b:	66 89 48 07          	mov    %cx,0x7(%eax)
			rlcrequest_temp->retxQueueSize=rlc_request_array[i].retxQueueSize;
    987f:	8b 4e 09             	mov    0x9(%esi),%ecx
    9882:	89 48 09             	mov    %ecx,0x9(%eax)
			rlcrequest_temp->retxQueueHeader=rlc_request_array[i].retxQueueHeader;
    9885:	0f b7 4e 0d          	movzwl 0xd(%esi),%ecx
    9889:	66 89 48 0d          	mov    %cx,0xd(%eax)
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
    988d:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    9891:	66 89 48 0f          	mov    %cx,0xf(%eax)
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
    9895:	0f b7 4e 11          	movzwl 0x11(%esi),%ecx
    9899:	66 89 48 11          	mov    %cx,0x11(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    989d:	8b 4b 17             	mov    0x17(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    98a0:	89 53 17             	mov    %edx,0x17(%ebx)
	new->next = next;
    98a3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	new->prev = prev;
    98a6:	89 48 17             	mov    %ecx,0x17(%eax)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    98a9:	89 58 13             	mov    %ebx,0x13(%eax)
	new->prev = prev;
	prev->next = new;
    98ac:	89 11                	mov    %edx,(%ecx)
    98ae:	e9 6d ff ff ff       	jmp    9820 <RlcRequest_arraytolist+0x80>
    98b3:	90                   	nop
    98b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					flag=1;
					break;
				}
				else
				{
					fsm_printf("[UEMAC][RLCreq_tolist]:lc_group error ,maybe it's rrc's mistake\n");
    98b8:	88 55 e0             	mov    %dl,-0x20(%ebp)
    98bb:	c7 04 24 ec 29 00 00 	movl   $0x29ec,(%esp)
    98c2:	e8 fc ff ff ff       	call   98c3 <RlcRequest_arraytolist+0x123>
    98c7:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
					continue;
    98cb:	e9 30 ff ff ff       	jmp    9800 <RlcRequest_arraytolist+0x60>

000098d0 <RlcRequest_listtoarray>:
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    98d0:	55                   	push   %ebp
    98d1:	89 e5                	mov    %esp,%ebp
    98d3:	57                   	push   %edi
    98d4:	56                   	push   %esi
    98d5:	53                   	push   %ebx
    98d6:	83 ec 10             	sub    $0x10,%esp
    98d9:	e8 fc ff ff ff       	call   98da <RlcRequest_listtoarray+0xa>
	/*while(rlc_report==0)//
	{
		rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(int));
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;
    98de:	31 db                	xor    %ebx,%ebx
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    98e0:	89 55 e8             	mov    %edx,-0x18(%ebp)
    98e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void *rlc_report;
	u32 *temp_num;
	RLC_Request *rlc_report_temp;

	FIN(RlcRequest_listtoarray( RlcBufferRequest *rlc_request,int *num));
	SV_PTR_GET(rlc_mac_sv);
    98e6:	e8 fc ff ff ff       	call   98e7 <RlcRequest_listtoarray+0x17>
	rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(u32));//report
    98eb:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
    98f1:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    98f4:	8d 44 50 04          	lea    0x4(%eax,%edx,2),%eax
    98f8:	e8 fc ff ff ff       	call   98f9 <RlcRequest_listtoarray+0x29>
    98fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9900:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9903:	8b 50 13             	mov    0x13(%eax),%edx
    9906:	89 c7                	mov    %eax,%edi
    9908:	b8 04 00 00 00       	mov    $0x4,%eax
    990d:	83 c7 13             	add    $0x13,%edi
    9910:	39 fa                	cmp    %edi,%edx
    9912:	8b 0a                	mov    (%edx),%ecx
    9914:	74 62                	je     9978 <RlcRequest_listtoarray+0xa8>
    9916:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9919:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    991c:	eb 06                	jmp    9924 <RlcRequest_listtoarray+0x54>
    991e:	66 90                	xchg   %ax,%ax
    9920:	89 ca                	mov    %ecx,%edx
    9922:	89 f1                	mov    %esi,%ecx
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    9924:	0f b7 72 ed          	movzwl -0x13(%edx),%esi
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
    9928:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    992c:	66 89 70 04          	mov    %si,0x4(%eax)
		rlc_report_temp[i].lcid=temp->lcid;
    9930:	0f b6 72 ef          	movzbl -0x11(%edx),%esi
    9934:	89 f3                	mov    %esi,%ebx
    9936:	88 58 06             	mov    %bl,0x6(%eax)
		rlc_report_temp[i].txQueueSize=temp->txQueueSize;
    9939:	8b 72 f0             	mov    -0x10(%edx),%esi
    993c:	89 70 07             	mov    %esi,0x7(%eax)
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
    993f:	0f b7 72 f4          	movzwl -0xc(%edx),%esi
    9943:	66 89 70 0b          	mov    %si,0xb(%eax)
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
    9947:	8b 72 f6             	mov    -0xa(%edx),%esi
    994a:	89 70 0d             	mov    %esi,0xd(%eax)
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
    994d:	0f b7 72 fa          	movzwl -0x6(%edx),%esi
    9951:	66 89 70 11          	mov    %si,0x11(%eax)
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
    9955:	0f b7 72 fc          	movzwl -0x4(%edx),%esi
    9959:	66 89 70 13          	mov    %si,0x13(%eax)
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
    995d:	0f b7 52 fe          	movzwl -0x2(%edx),%edx
    9961:	66 89 50 15          	mov    %dx,0x15(%eax)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9965:	83 c0 13             	add    $0x13,%eax
    9968:	39 cf                	cmp    %ecx,%edi
    996a:	8b 31                	mov    (%ecx),%esi
    996c:	75 b2                	jne    9920 <RlcRequest_listtoarray+0x50>
    996e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    9971:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    9974:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
    9978:	8b 55 ec             	mov    -0x14(%ebp),%edx
    997b:	89 1a                	mov    %ebx,(%edx)
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
    997d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9980:	89 02                	mov    %eax,(%edx)
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9982:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9985:	8b 50 13             	mov    0x13(%eax),%edx
    9988:	39 d7                	cmp    %edx,%edi
    998a:	8b 1a                	mov    (%edx),%ebx
    998c:	75 04                	jne    9992 <RlcRequest_listtoarray+0xc2>
    998e:	eb 1f                	jmp    99af <RlcRequest_listtoarray+0xdf>
    9990:	89 f2                	mov    %esi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    9992:	8b 4a 04             	mov    0x4(%edx),%ecx
    9995:	89 de                	mov    %ebx,%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    9997:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    999a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    999d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    999f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    99a1:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);//
    99a4:	e8 fc ff ff ff       	call   99a5 <RlcRequest_listtoarray+0xd5>
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    99a9:	39 fe                	cmp    %edi,%esi
    99ab:	8b 1b                	mov    (%ebx),%ebx
    99ad:	75 e1                	jne    9990 <RlcRequest_listtoarray+0xc0>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);//
	}
	fsm_mem_free(rlc_request);
    99af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    99b2:	e8 fc ff ff ff       	call   99b3 <RlcRequest_listtoarray+0xe3>
	FRET(rlc_report);
}
    99b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    99ba:	83 c4 10             	add    $0x10,%esp
    99bd:	5b                   	pop    %ebx
    99be:	5e                   	pop    %esi
    99bf:	5f                   	pop    %edi
    99c0:	5d                   	pop    %ebp
    99c1:	c3                   	ret    
    99c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    99c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000099d0 <Rlc_MacRequest_copy>:
->Output:RLC_Request
->Special:
*******************************
*/
RLC_Request* Rlc_MacRequest_copy(RlcBufferRequest *temp)
{
    99d0:	55                   	push   %ebp
    99d1:	89 e5                	mov    %esp,%ebp
    99d3:	53                   	push   %ebx
    99d4:	e8 fc ff ff ff       	call   99d5 <Rlc_MacRequest_copy+0x5>
    99d9:	89 c3                	mov    %eax,%ebx
	FIN(Rlc_MacRequest_copy(RlcBufferRequest *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    99db:	b8 13 00 00 00       	mov    $0x13,%eax
    99e0:	e8 fc ff ff ff       	call   99e1 <Rlc_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    99e5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    99e9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    99ec:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    99f0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    99f4:	8b 53 09             	mov    0x9(%ebx),%edx
    99f7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    99fa:	0f b7 13             	movzwl (%ebx),%edx
    99fd:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9a00:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9a04:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9a08:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9a0c:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9a10:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9a14:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9a18:	8b 53 03             	mov    0x3(%ebx),%edx
    9a1b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9a1e:	5b                   	pop    %ebx
    9a1f:	5d                   	pop    %ebp
    9a20:	c3                   	ret    
    9a21:	eb 0d                	jmp    9a30 <LogicalChannel_ConfigInfo_copy>
    9a23:	90                   	nop
    9a24:	90                   	nop
    9a25:	90                   	nop
    9a26:	90                   	nop
    9a27:	90                   	nop
    9a28:	90                   	nop
    9a29:	90                   	nop
    9a2a:	90                   	nop
    9a2b:	90                   	nop
    9a2c:	90                   	nop
    9a2d:	90                   	nop
    9a2e:	90                   	nop
    9a2f:	90                   	nop

00009a30 <LogicalChannel_ConfigInfo_copy>:
->Output:LogicalChannelConfigInfo:MAC
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp)
{
    9a30:	55                   	push   %ebp
    9a31:	89 e5                	mov    %esp,%ebp
    9a33:	53                   	push   %ebx
    9a34:	e8 fc ff ff ff       	call   9a35 <LogicalChannel_ConfigInfo_copy+0x5>
    9a39:	89 c3                	mov    %eax,%ebx
	FIN(LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp));
	LogicalChannelConfigInfo *copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9a3b:	b8 19 00 00 00       	mov    $0x19,%eax
    9a40:	e8 fc ff ff ff       	call   9a41 <LogicalChannel_ConfigInfo_copy+0x11>
	/*while(copy==0)//
	{
		copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9a45:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a48:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9a4b:	89 50 15             	mov    %edx,0x15(%eax)
	copy->lcid=temp->logicalChannelIdentity;
    9a4e:	8b 13                	mov    (%ebx),%edx
    9a50:	88 10                	mov    %dl,(%eax)
	copy->priority=(temp->logicalChannelConfig).ul_SpecificParameters.priority;
    9a52:	8b 53 05             	mov    0x5(%ebx),%edx
    9a55:	89 50 01             	mov    %edx,0x1(%eax)
	copy->prioritizedBitRateKbps=(temp->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    9a58:	8b 53 09             	mov    0x9(%ebx),%edx
    9a5b:	89 50 05             	mov    %edx,0x5(%eax)
	copy->bucketSizeDurationMs=(temp->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    9a5e:	8b 53 0d             	mov    0xd(%ebx),%edx
    9a61:	89 50 09             	mov    %edx,0x9(%eax)
	copy->logicalChannelGroup=(temp->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    9a64:	8b 53 11             	mov    0x11(%ebx),%edx
    9a67:	89 50 0d             	mov    %edx,0xd(%eax)
	FRET(copy);
}
    9a6a:	5b                   	pop    %ebx
    9a6b:	5d                   	pop    %ebp
    9a6c:	c3                   	ret    
    9a6d:	8d 76 00             	lea    0x0(%esi),%esi

00009a70 <Mac_RlcRequest_copy>:
->Output:RlcBufferRequest:MACRLC request
->Special:
*******************************
*/
RlcBufferRequest* Mac_RlcRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9a70:	55                   	push   %ebp
    9a71:	89 e5                	mov    %esp,%ebp
    9a73:	53                   	push   %ebx
    9a74:	e8 fc ff ff ff       	call   9a75 <Mac_RlcRequest_copy+0x5>
    9a79:	89 c3                	mov    %eax,%ebx
	FIN(Mac_RlcRequest_copy(RLC_Request *temp));
	RlcBufferRequest *copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9a7b:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9a80:	e8 fc ff ff ff       	call   9a81 <Mac_RlcRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9a85:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a88:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9a8b:	89 50 17             	mov    %edx,0x17(%eax)
	copy->lcid=temp->lcid;
    9a8e:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9a92:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9a95:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9a99:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9a9d:	8b 53 09             	mov    0x9(%ebx),%edx
    9aa0:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9aa3:	0f b7 13             	movzwl (%ebx),%edx
    9aa6:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9aa9:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9aad:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9ab1:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9ab5:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9ab9:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9abd:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9ac1:	8b 53 03             	mov    0x3(%ebx),%edx
    9ac4:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9ac7:	5b                   	pop    %ebx
    9ac8:	5d                   	pop    %ebp
    9ac9:	c3                   	ret    
    9aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00009ad0 <Mac_MacRequest_copy>:
->Output:RLC_Request *
->Special:
*******************************
*/
RLC_Request* Mac_MacRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9ad0:	55                   	push   %ebp
    9ad1:	89 e5                	mov    %esp,%ebp
    9ad3:	53                   	push   %ebx
    9ad4:	e8 fc ff ff ff       	call   9ad5 <Mac_MacRequest_copy+0x5>
    9ad9:	89 c3                	mov    %eax,%ebx
	FIN(Mac_MacRequest_copy(RLC_Request *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9adb:	b8 13 00 00 00       	mov    $0x13,%eax
    9ae0:	e8 fc ff ff ff       	call   9ae1 <Mac_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9ae5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9ae9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9aec:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9af0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9af4:	8b 53 09             	mov    0x9(%ebx),%edx
    9af7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9afa:	0f b7 13             	movzwl (%ebx),%edx
    9afd:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9b00:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9b04:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9b08:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9b0c:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9b10:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9b14:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9b18:	8b 53 03             	mov    0x3(%ebx),%edx
    9b1b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9b1e:	5b                   	pop    %ebx
    9b1f:	5d                   	pop    %ebp
    9b20:	c3                   	ret    
    9b21:	eb 0d                	jmp    9b30 <MacBufferStatus_BSR_Info_copy>
    9b23:	90                   	nop
    9b24:	90                   	nop
    9b25:	90                   	nop
    9b26:	90                   	nop
    9b27:	90                   	nop
    9b28:	90                   	nop
    9b29:	90                   	nop
    9b2a:	90                   	nop
    9b2b:	90                   	nop
    9b2c:	90                   	nop
    9b2d:	90                   	nop
    9b2e:	90                   	nop
    9b2f:	90                   	nop

00009b30 <MacBufferStatus_BSR_Info_copy>:
->Output:MacBufferStatus_BSR_Info *
->Special:
*******************************
*/
MacBufferStatus_BSR_Info* MacBufferStatus_BSR_Info_copy(void)//BSR
{
    9b30:	55                   	push   %ebp
    9b31:	89 e5                	mov    %esp,%ebp
    9b33:	53                   	push   %ebx
    9b34:	e8 fc ff ff ff       	call   9b35 <MacBufferStatus_BSR_Info_copy+0x5>
	FIN(MacBufferStatus_BSR_Info_copy(void));
	SV_PTR_GET(rlc_mac_sv);
    9b39:	e8 fc ff ff ff       	call   9b3a <MacBufferStatus_BSR_Info_copy+0xa>
    9b3e:	89 c3                	mov    %eax,%ebx
	u32 j=0;
	MacBufferStatus_BSR_Info* copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9b40:	b8 1a 00 00 00       	mov    $0x1a,%eax
    9b45:	e8 fc ff ff ff       	call   9b46 <MacBufferStatus_BSR_Info_copy+0x16>
	/*while(copy==0)//
	{
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
    9b4a:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9b50:	8b 52 02             	mov    0x2(%edx),%edx
    9b53:	89 50 02             	mov    %edx,0x2(%eax)
	copy->m_rnti=SV(bsr)->m_rnti;
    9b56:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9b5c:	0f b7 12             	movzwl (%edx),%edx
    9b5f:	66 89 10             	mov    %dx,(%eax)
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
    9b62:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9b68:	8b 52 06             	mov    0x6(%edx),%edx
    9b6b:	89 50 06             	mov    %edx,0x6(%eax)
	for(j=0;j<LCG;j++)
    9b6e:	31 d2                	xor    %edx,%edx
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
    9b70:	8b 8b 54 01 00 00    	mov    0x154(%ebx),%ecx
    9b76:	8b 4c 91 0a          	mov    0xa(%ecx,%edx,4),%ecx
    9b7a:	89 4c 90 0a          	mov    %ecx,0xa(%eax,%edx,4)
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
	copy->m_rnti=SV(bsr)->m_rnti;
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
	for(j=0;j<LCG;j++)
    9b7e:	83 c2 01             	add    $0x1,%edx
    9b81:	83 fa 04             	cmp    $0x4,%edx
    9b84:	75 ea                	jne    9b70 <MacBufferStatus_BSR_Info_copy+0x40>
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
	FRET(copy);
}
    9b86:	5b                   	pop    %ebx
    9b87:	5d                   	pop    %ebp
    9b88:	c3                   	ret    
    9b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009b90 <FlushBj>:
->Output:SV(LogicalChannel_Config)lcbj
->Special:lcbjMAX_BJ/8+1:
*******************************
*/
void FlushBj(void)
{
    9b90:	55                   	push   %ebp
    9b91:	89 e5                	mov    %esp,%ebp
    9b93:	57                   	push   %edi
    9b94:	56                   	push   %esi
    9b95:	53                   	push   %ebx
    9b96:	83 ec 04             	sub    $0x4,%esp
    9b99:	e8 fc ff ff ff       	call   9b9a <FlushBj+0xa>
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
    9b9e:	e8 fc ff ff ff       	call   9b9f <FlushBj+0xf>
    9ba3:	89 c7                	mov    %eax,%edi
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9ba5:	8b 80 44 01 00 00    	mov    0x144(%eax),%eax
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9bab:	8b 70 05             	mov    0x5(%eax),%esi
{
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9bb1:	83 ee 05             	sub    $0x5,%esi
    9bb4:	39 f0                	cmp    %esi,%eax
    9bb6:	74 63                	je     9c1b <FlushBj+0x8b>
	{
		temp_Bj_lcid=temp->lcid;
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9bb8:	8b 8f 40 01 00 00    	mov    0x140(%edi),%ecx
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
	{
		temp_Bj_lcid=temp->lcid;
    9bbe:	0f b6 1e             	movzbl (%esi),%ebx
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9bc1:	8b 51 11             	mov    0x11(%ecx),%edx
    9bc4:	8d 42 ef             	lea    -0x11(%edx),%eax
    9bc7:	39 c1                	cmp    %eax,%ecx
    9bc9:	75 0f                	jne    9bda <FlushBj+0x4a>
    9bcb:	eb 43                	jmp    9c10 <FlushBj+0x80>
    9bcd:	8d 76 00             	lea    0x0(%esi),%esi
    9bd0:	8b 50 11             	mov    0x11(%eax),%edx
    9bd3:	8d 42 ef             	lea    -0x11(%edx),%eax
    9bd6:	39 c1                	cmp    %eax,%ecx
    9bd8:	74 36                	je     9c10 <FlushBj+0x80>
		{
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
    9bda:	38 5a ef             	cmp    %bl,-0x11(%edx)
    9bdd:	75 f1                	jne    9bd0 <FlushBj+0x40>
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
    9bdf:	8b 50 05             	mov    0x5(%eax),%edx
    9be2:	83 fa ff             	cmp    $0xffffffff,%edx
    9be5:	74 49                	je     9c30 <FlushBj+0xa0>
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9be7:	8b 40 09             	mov    0x9(%eax),%eax
					if(temp->lcbj < BucketSize)
    9bea:	8b 4e 01             	mov    0x1(%esi),%ecx
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9bed:	0f af c2             	imul   %edx,%eax
    9bf0:	c1 e8 03             	shr    $0x3,%eax
					if(temp->lcbj < BucketSize)
    9bf3:	0f b6 c0             	movzbl %al,%eax
    9bf6:	39 c1                	cmp    %eax,%ecx
    9bf8:	73 2e                	jae    9c28 <FlushBj+0x98>
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
    9bfa:	85 d2                	test   %edx,%edx
    9bfc:	8d 42 07             	lea    0x7(%edx),%eax
    9bff:	0f 48 d0             	cmovs  %eax,%edx
    9c02:	c1 fa 03             	sar    $0x3,%edx
    9c05:	01 ca                	add    %ecx,%edx
    9c07:	89 56 01             	mov    %edx,0x1(%esi)
    9c0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9c10:	8b 76 05             	mov    0x5(%esi),%esi
    9c13:	83 ee 05             	sub    $0x5,%esi
    9c16:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    9c19:	75 9d                	jne    9bb8 <FlushBj+0x28>
		if(flag_tail==false)
			//fsm_printf("[UEMAC][FlushBj]FlushBj ERROR");//LogicalChannelConfigLogicalChannelConfigBj
		flag_tail=false;
	}
	FOUT;
}
    9c1b:	83 c4 04             	add    $0x4,%esp
    9c1e:	5b                   	pop    %ebx
    9c1f:	5e                   	pop    %esi
    9c20:	5f                   	pop    %edi
    9c21:	5d                   	pop    %ebp
    9c22:	c3                   	ret    
    9c23:	90                   	nop
    9c24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
					if(temp->lcbj < BucketSize)
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
					else
						temp->lcbj=BucketSize;
    9c28:	89 46 01             	mov    %eax,0x1(%esi)
    9c2b:	eb e3                	jmp    9c10 <FlushBj+0x80>
    9c2d:	8d 76 00             	lea    0x0(%esi),%esi
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
				{
					temp->lcbj=MAX_BJ/8+1;//1
    9c30:	c7 46 01 01 7d 00 00 	movl   $0x7d01,0x1(%esi)
    9c37:	eb d7                	jmp    9c10 <FlushBj+0x80>
    9c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009c40 <BufferSize2BsrSize>:
->Output:BufferSizeLevelBsrTableindex
->Special:
*******************************
*/
u32 BufferSize2BsrSize(u32 buffersize)
{
    9c40:	55                   	push   %ebp
    9c41:	89 e5                	mov    %esp,%ebp
    9c43:	53                   	push   %ebx
    9c44:	e8 fc ff ff ff       	call   9c45 <BufferSize2BsrSize+0x5>
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
    9c49:	31 d2                	xor    %edx,%edx
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9c4b:	85 c0                	test   %eax,%eax
    9c4d:	74 2b                	je     9c7a <BufferSize2BsrSize+0x3a>
    9c4f:	b2 01                	mov    $0x1,%dl
    9c51:	31 c9                	xor    %ecx,%ecx
    9c53:	eb 05                	jmp    9c5a <BufferSize2BsrSize+0x1a>
    9c55:	8d 76 00             	lea    0x0(%esi),%esi
    9c58:	89 da                	mov    %ebx,%edx
			FRET(i);
		if(BufferSizeLevelBsrTable[i]< buffersize && BufferSizeLevelBsrTable[i+1]>= buffersize)
    9c5a:	39 c8                	cmp    %ecx,%eax
    9c5c:	76 09                	jbe    9c67 <BufferSize2BsrSize+0x27>
    9c5e:	3b 04 95 40 33 00 00 	cmp    0x3340(,%edx,4),%eax
    9c65:	76 13                	jbe    9c7a <BufferSize2BsrSize+0x3a>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
    9c67:	83 fa 3f             	cmp    $0x3f,%edx
    9c6a:	74 0e                	je     9c7a <BufferSize2BsrSize+0x3a>
    9c6c:	8d 5a 01             	lea    0x1(%edx),%ebx
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9c6f:	8b 0c 9d 3c 33 00 00 	mov    0x333c(,%ebx,4),%ecx
    9c76:	39 c1                	cmp    %eax,%ecx
    9c78:	75 de                	jne    9c58 <BufferSize2BsrSize+0x18>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
			FRET(BSRTABLEINDEX-1);
	}
	FRET(-1);
}
    9c7a:	89 d0                	mov    %edx,%eax
    9c7c:	5b                   	pop    %ebx
    9c7d:	5d                   	pop    %ebp
    9c7e:	c3                   	ret    
    9c7f:	90                   	nop

00009c80 <RefreshBufferStatusForBSR>:
->Output:SV(bsr)
->Special:
*******************************
*/
void RefreshBufferStatusForBSR(void)
{
    9c80:	55                   	push   %ebp
    9c81:	89 e5                	mov    %esp,%ebp
    9c83:	57                   	push   %edi
    9c84:	56                   	push   %esi
    9c85:	53                   	push   %ebx
    9c86:	83 ec 24             	sub    $0x24,%esp
    9c89:	e8 fc ff ff ff       	call   9c8a <RefreshBufferStatusForBSR+0xa>
	LogicalChannelConfigInfo *temp_lcc_info=NULL;
	MacBufferStatus *temp=NULL;
	struct list_head *pos1=NULL,*p1=NULL;
	struct list_head *pos=NULL,*p=NULL;
	u32 queue[LCG]={0,0,0,0};//LCG
    9c8e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    9c95:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    9c9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    9ca3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	u32 logicalchannelgroup;
	u32 i;
	bool flag_find=false;

	FIN(RefreshBufferStatusForBSR(void));
	SV_PTR_GET(rlc_mac_sv);
    9caa:	e8 fc ff ff ff       	call   9cab <RefreshBufferStatusForBSR+0x2b>
    9caf:	89 c3                	mov    %eax,%ebx
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9cb1:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9cb7:	8d 50 05             	lea    0x5(%eax),%edx
    9cba:	39 50 05             	cmp    %edx,0x5(%eax)
	{
		SV(bsr)->m_lcgnum=0;
    9cbd:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9cc3:	0f 84 4e 01 00 00    	je     9e17 <RefreshBufferStatusForBSR+0x197>
	{
		SV(bsr)->m_lcgnum=0;
		//printk(KERN_INFO"No BSR report to transmit\n");
		FOUT;
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
    9cc9:	0f b7 13             	movzwl (%ebx),%edx
    9ccc:	66 89 10             	mov    %dx,(%eax)
	SV(bsr)->m_lcgnum=0;
    9ccf:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9cd5:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	SV(bsr)->m_TotalLcgData=0;		
    9cdc:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9ce2:	c7 40 06 00 00 00 00 	movl   $0x0,0x6(%eax)
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9ce9:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    9cef:	8b 48 05             	mov    0x5(%eax),%ecx
    9cf2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9cf5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9cf8:	31 c0                	xor    %eax,%eax
    9cfa:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    9cfd:	8b 09                	mov    (%ecx),%ecx
    9cff:	83 c2 05             	add    $0x5,%edx
    9d02:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    9d05:	0f 84 a1 00 00 00    	je     9dac <RefreshBufferStatusForBSR+0x12c>
    9d0b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    9d0e:	89 cb                	mov    %ecx,%ebx
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9d10:	8b 45 d8             	mov    -0x28(%ebp),%eax
    9d13:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
    9d19:	8b 4e 11             	mov    0x11(%esi),%ecx
    9d1c:	83 c6 11             	add    $0x11,%esi
    9d1f:	8b 01                	mov    (%ecx),%eax
    9d21:	39 f1                	cmp    %esi,%ecx
    9d23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    9d26:	74 43                	je     9d6b <RefreshBufferStatusForBSR+0xeb>
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9d28:	8b 51 fc             	mov    -0x4(%ecx),%edx
    9d2b:	83 fa 03             	cmp    $0x3,%edx
    9d2e:	77 52                	ja     9d82 <RefreshBufferStatusForBSR+0x102>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9d30:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9d33:	0f b6 78 fb          	movzbl -0x5(%eax),%edi
    9d37:	89 f8                	mov    %edi,%eax
    9d39:	3a 41 ef             	cmp    -0x11(%ecx),%al
    9d3c:	0f 84 a8 00 00 00    	je     9dea <RefreshBufferStatusForBSR+0x16a>
    9d42:	89 fa                	mov    %edi,%edx
    9d44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9d47:	89 df                	mov    %ebx,%edi
    9d49:	89 d3                	mov    %edx,%ebx
    9d4b:	eb 16                	jmp    9d63 <RefreshBufferStatusForBSR+0xe3>
    9d4d:	8d 76 00             	lea    0x0(%esi),%esi
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9d50:	8b 50 fc             	mov    -0x4(%eax),%edx
    9d53:	83 fa 03             	cmp    $0x3,%edx
    9d56:	77 28                	ja     9d80 <RefreshBufferStatusForBSR+0x100>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9d58:	38 58 ef             	cmp    %bl,-0x11(%eax)
    9d5b:	0f 84 87 00 00 00    	je     9de8 <RefreshBufferStatusForBSR+0x168>
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9d61:	89 c8                	mov    %ecx,%eax
    9d63:	39 c6                	cmp    %eax,%esi
    9d65:	8b 08                	mov    (%eax),%ecx
    9d67:	75 e7                	jne    9d50 <RefreshBufferStatusForBSR+0xd0>
    9d69:	89 fb                	mov    %edi,%ebx
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9d6b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9d6e:	8b 13                	mov    (%ebx),%edx
    9d70:	83 c0 05             	add    $0x5,%eax
    9d73:	39 c3                	cmp    %eax,%ebx
    9d75:	74 2f                	je     9da6 <RefreshBufferStatusForBSR+0x126>
    9d77:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    9d7a:	89 d3                	mov    %edx,%ebx
    9d7c:	eb 92                	jmp    9d10 <RefreshBufferStatusForBSR+0x90>
    9d7e:	66 90                	xchg   %ax,%ax
    9d80:	89 fb                	mov    %edi,%ebx
					break;
				}
			}
			else
			{
				fsm_printf("[UEMAC][refreshBSR]:lc_group error\n");
    9d82:	c7 04 24 68 2a 00 00 	movl   $0x2a68,(%esp)
    9d89:	e8 fc ff ff ff       	call   9d8a <RefreshBufferStatusForBSR+0x10a>
    9d8e:	8b 45 d8             	mov    -0x28(%ebp),%eax
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9d91:	8b 13                	mov    (%ebx),%edx
    9d93:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9d99:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9d9c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9d9f:	83 c0 05             	add    $0x5,%eax
    9da2:	39 c3                	cmp    %eax,%ebx
    9da4:	75 d1                	jne    9d77 <RefreshBufferStatusForBSR+0xf7>
    9da6:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    9da9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9dac:	31 f6                	xor    %esi,%esi
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
	{
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
    9dae:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9db4:	01 42 06             	add    %eax,0x6(%edx)
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
    9db7:	8b bb 54 01 00 00    	mov    0x154(%ebx),%edi
    9dbd:	e8 fc ff ff ff       	call   9dbe <RefreshBufferStatusForBSR+0x13e>
    9dc2:	89 44 b7 0a          	mov    %eax,0xa(%edi,%esi,4)
		if((SV(bsr)->m_bufferStatus[i])!=0)
    9dc6:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9dcc:	8b 54 b0 0a          	mov    0xa(%eax,%esi,4),%edx
    9dd0:	85 d2                	test   %edx,%edx
    9dd2:	74 04                	je     9dd8 <RefreshBufferStatusForBSR+0x158>
			SV(bsr)->m_lcgnum++;
    9dd4:	83 40 02 01          	addl   $0x1,0x2(%eax)
		
		if(flag_find==false)
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
    9dd8:	83 c6 01             	add    $0x1,%esi
    9ddb:	83 fe 04             	cmp    $0x4,%esi
    9dde:	74 40                	je     9e20 <RefreshBufferStatusForBSR+0x1a0>
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9de0:	8b 44 b5 e4          	mov    -0x1c(%ebp,%esi,4),%eax
    9de4:	eb c8                	jmp    9dae <RefreshBufferStatusForBSR+0x12e>
    9de6:	66 90                	xchg   %ax,%ax
    9de8:	89 fb                	mov    %edi,%ebx
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
			{
				if(temp->lcid==temp_lcc_info->lcid)
				{
					logicalchannelgroup=temp_lcc_info->logicalChannelGroup;
					queue[logicalchannelgroup] =queue[logicalchannelgroup] + temp->RlcRequestparams->retxQueueHeader + temp->RlcRequestparams->retxQueueSize + temp->RlcRequestparams->statusPduHeader \
    9dea:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    9ded:	8b 41 fc             	mov    -0x4(%ecx),%eax
    9df0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
    9df4:	8b 48 03             	mov    0x3(%eax),%ecx
    9df7:	03 48 09             	add    0x9(%eax),%ecx
    9dfa:	01 f1                	add    %esi,%ecx
    9dfc:	0f b7 70 11          	movzwl 0x11(%eax),%esi
    9e00:	01 f1                	add    %esi,%ecx
					+ temp->RlcRequestparams->statusPduSize + temp->RlcRequestparams->txQueueHeader + temp->RlcRequestparams->txQueueSize;
    9e02:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    9e06:	0f b7 40 07          	movzwl 0x7(%eax),%eax
    9e0a:	01 f1                	add    %esi,%ecx
    9e0c:	01 c1                	add    %eax,%ecx
    9e0e:	01 4c 95 e4          	add    %ecx,-0x1c(%ebp,%edx,4)
					flag_find=true;
					break;
    9e12:	e9 54 ff ff ff       	jmp    9d6b <RefreshBufferStatusForBSR+0xeb>
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
	{
		SV(bsr)->m_lcgnum=0;
    9e17:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
    9e1e:	66 90                	xchg   %ax,%ax
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
		if((SV(bsr)->m_bufferStatus[i])!=0)
			SV(bsr)->m_lcgnum++;
	}
}
    9e20:	83 c4 24             	add    $0x24,%esp
    9e23:	5b                   	pop    %ebx
    9e24:	5e                   	pop    %esi
    9e25:	5f                   	pop    %edi
    9e26:	5d                   	pop    %ebp
    9e27:	c3                   	ret    
    9e28:	90                   	nop
    9e29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009e30 <GetTBsize_Allocation>:
->Output:
->Special:
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
    9e30:	55                   	push   %ebp
    9e31:	89 e5                	mov    %esp,%ebp
    9e33:	83 ec 08             	sub    $0x8,%esp
    9e36:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    9e39:	89 75 fc             	mov    %esi,-0x4(%ebp)
    9e3c:	e8 fc ff ff ff       	call   9e3d <GetTBsize_Allocation+0xd>
    9e41:	89 c3                	mov    %eax,%ebx
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    9e43:	e8 fc ff ff ff       	call   9e44 <GetTBsize_Allocation+0x14>
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    9e48:	c1 eb 03             	shr    $0x3,%ebx
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    9e4b:	89 c6                	mov    %eax,%esi
	RefreshBufferStatusForBSR();
    9e4d:	e8 fc ff ff ff       	call   9e4e <GetTBsize_Allocation+0x1e>
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    9e52:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
    9e58:	3b 58 06             	cmp    0x6(%eax),%ebx
    9e5b:	72 13                	jb     9e70 <GetTBsize_Allocation+0x40>
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
	}
	else
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
    9e5d:	c6 86 59 01 00 00 00 	movb   $0x0,0x159(%esi)
		FRET((tbsize)/8);
	}
}
    9e64:	89 d8                	mov    %ebx,%eax
    9e66:	8b 75 fc             	mov    -0x4(%ebp),%esi
    9e69:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    9e6c:	89 ec                	mov    %ebp,%esp
    9e6e:	5d                   	pop    %ebp
    9e6f:	c3                   	ret    
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=true;
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
    9e70:	83 eb 04             	sub    $0x4,%ebx
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
		FRET((tbsize)/8);
	}
}
    9e73:	8b 75 fc             	mov    -0x4(%ebp),%esi
    9e76:	89 d8                	mov    %ebx,%eax
    9e78:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    9e7b:	89 ec                	mov    %ebp,%esp
    9e7d:	5d                   	pop    %ebp
    9e7e:	c3                   	ret    
    9e7f:	90                   	nop

00009e80 <DoRefreshRLCBuffserRequest>:
->Output:SV(MacBuffer_RLC) :MAC
->Special:
*******************************
*/
void DoRefreshRLCBuffserRequest (RlcBufferRequest* params)	//
{
    9e80:	55                   	push   %ebp
    9e81:	89 e5                	mov    %esp,%ebp
    9e83:	57                   	push   %edi
    9e84:	56                   	push   %esi
    9e85:	53                   	push   %ebx
    9e86:	83 ec 14             	sub    $0x14,%esp
    9e89:	e8 fc ff ff ff       	call   9e8a <DoRefreshRLCBuffserRequest+0xa>
    9e8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos,*p;
	u8 temp_lcid,temp_mac_bufferstatus_lcid;
	FIN(DoRefreshRLCBuffserRequest(RlcBufferRequest* params));
	
	SV_PTR_GET(rlc_mac_sv);
    9e91:	e8 fc ff ff ff       	call   9e92 <DoRefreshRLCBuffserRequest+0x12>
    9e96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	MacBufferStatus *temp_mac_bufferstatus=NULL;
	MacBufferStatus *temp_mac_findno=NULL;	
	bool flag=false;

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
    9e99:	e8 fc ff ff ff       	call   9e9a <DoRefreshRLCBuffserRequest+0x1a>
	if (SV(bsr)->m_lcgnum==0)
    9e9e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ea1:	8b 82 54 01 00 00    	mov    0x154(%edx),%eax
    9ea7:	8b 48 02             	mov    0x2(%eax),%ecx
    9eaa:	85 c9                	test   %ecx,%ecx
    9eac:	75 07                	jne    9eb5 <DoRefreshRLCBuffserRequest+0x35>
		SV(LCGZeroToData)=true;
    9eae:	c6 82 58 01 00 00 01 	movb   $0x1,0x158(%edx)
	SV(DATA_WAIT_ALLOCATION)=true;
    9eb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
	list_for_each_safe(pos,p,&(RLChead->list))//
    9eb8:	8b 55 e4             	mov    -0x1c(%ebp),%edx

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
    9ebb:	c6 80 5a 01 00 00 01 	movb   $0x1,0x15a(%eax)
	list_for_each_safe(pos,p,&(RLChead->list))//
    9ec2:	8b 42 13             	mov    0x13(%edx),%eax
    9ec5:	83 c2 13             	add    $0x13,%edx
    9ec8:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9ecb:	39 d0                	cmp    %edx,%eax
    9ecd:	8b 38                	mov    (%eax),%edi
    9ecf:	0f 84 ea 00 00 00    	je     9fbf <DoRefreshRLCBuffserRequest+0x13f>
    9ed5:	8d 76 00             	lea    0x0(%esi),%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    9ed8:	8d 48 ed             	lea    -0x13(%eax),%ecx
		temp_lcid=temp->lcid;
    9edb:	0f b6 58 ef          	movzbl -0x11(%eax),%ebx
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    9edf:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    9ee2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		temp_lcid=temp->lcid;
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    9ee5:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    9eeb:	8b 42 05             	mov    0x5(%edx),%eax
    9eee:	8d 70 fb             	lea    -0x5(%eax),%esi
    9ef1:	39 f2                	cmp    %esi,%edx
    9ef3:	75 0d                	jne    9f02 <DoRefreshRLCBuffserRequest+0x82>
    9ef5:	eb 39                	jmp    9f30 <DoRefreshRLCBuffserRequest+0xb0>
    9ef7:	90                   	nop
    9ef8:	8b 46 05             	mov    0x5(%esi),%eax
    9efb:	8d 70 fb             	lea    -0x5(%eax),%esi
    9efe:	39 f2                	cmp    %esi,%edx
    9f00:	74 2e                	je     9f30 <DoRefreshRLCBuffserRequest+0xb0>
		{
			temp_mac_bufferstatus_lcid=temp_mac_bufferstatus->lcid;
			if(temp_lcid==temp_mac_bufferstatus_lcid)
    9f02:	3a 58 fb             	cmp    -0x5(%eax),%bl
    9f05:	75 f1                	jne    9ef8 <DoRefreshRLCBuffserRequest+0x78>
			{
				temp_mac_bufferstatus->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9f07:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9f0a:	e8 fc ff ff ff       	call   9f0b <DoRefreshRLCBuffserRequest+0x8b>
    9f0f:	89 46 01             	mov    %eax,0x1(%esi)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    9f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f15:	39 7d e8             	cmp    %edi,-0x18(%ebp)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    9f18:	c6 80 59 01 00 00 01 	movb   $0x1,0x159(%eax)
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f1f:	8b 17                	mov    (%edi),%edx
    9f21:	74 65                	je     9f88 <DoRefreshRLCBuffserRequest+0x108>
    9f23:	89 f8                	mov    %edi,%eax
    9f25:	89 d7                	mov    %edx,%edi
    9f27:	eb af                	jmp    9ed8 <DoRefreshRLCBuffserRequest+0x58>
    9f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9f30:	b8 0d 00 00 00       	mov    $0xd,%eax
    9f35:	e8 fc ff ff ff       	call   9f36 <DoRefreshRLCBuffserRequest+0xb6>
			while(temp_mac_findno==0)//
    9f3a:	85 c0                	test   %eax,%eax
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9f3c:	89 c6                	mov    %eax,%esi
			while(temp_mac_findno==0)//
    9f3e:	75 10                	jne    9f50 <DoRefreshRLCBuffserRequest+0xd0>
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9f40:	b8 0d 00 00 00       	mov    $0xd,%eax
    9f45:	e8 fc ff ff ff       	call   9f46 <DoRefreshRLCBuffserRequest+0xc6>
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
    9f4a:	85 c0                	test   %eax,%eax
    9f4c:	74 f2                	je     9f40 <DoRefreshRLCBuffserRequest+0xc0>
    9f4e:	89 c6                	mov    %eax,%esi
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9f50:	8b 45 ec             	mov    -0x14(%ebp),%eax
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
    9f53:	8d 56 05             	lea    0x5(%esi),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9f56:	89 56 05             	mov    %edx,0x5(%esi)
	list->prev = list;
    9f59:	89 56 09             	mov    %edx,0x9(%esi)
			temp_mac_findno->lcid=temp_lcid;
    9f5c:	88 1e                	mov    %bl,(%esi)
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9f5e:	89 55 e0             	mov    %edx,-0x20(%ebp)
    9f61:	e8 fc ff ff ff       	call   9f62 <DoRefreshRLCBuffserRequest+0xe2>
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    9f66:	8b 4d f0             	mov    -0x10(%ebp),%ecx
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9f69:	89 46 01             	mov    %eax,0x1(%esi)
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    9f6c:	8b 81 48 01 00 00    	mov    0x148(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9f72:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9f75:	8b 48 09             	mov    0x9(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9f78:	89 50 09             	mov    %edx,0x9(%eax)
    9f7b:	83 c0 05             	add    $0x5,%eax
    9f7e:	89 46 05             	mov    %eax,0x5(%esi)
	new->next = next;
	new->prev = prev;
    9f81:	89 4e 09             	mov    %ecx,0x9(%esi)
	prev->next = new;
    9f84:	89 11                	mov    %edx,(%ecx)
    9f86:	eb 8a                	jmp    9f12 <DoRefreshRLCBuffserRequest+0x92>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9f8b:	8b 50 13             	mov    0x13(%eax),%edx
    9f8e:	3b 55 e8             	cmp    -0x18(%ebp),%edx
    9f91:	8b 1a                	mov    (%edx),%ebx
    9f93:	74 2a                	je     9fbf <DoRefreshRLCBuffserRequest+0x13f>
    9f95:	89 d9                	mov    %ebx,%ecx
    9f97:	8b 75 e8             	mov    -0x18(%ebp),%esi
    9f9a:	eb 08                	jmp    9fa4 <DoRefreshRLCBuffserRequest+0x124>
    9f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9fa0:	89 da                	mov    %ebx,%edx
    9fa2:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    9fa4:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    9fa7:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    9faa:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    9fad:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9faf:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    9fb1:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);
    9fb4:	e8 fc ff ff ff       	call   9fb5 <DoRefreshRLCBuffserRequest+0x135>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9fb9:	39 f3                	cmp    %esi,%ebx
    9fbb:	8b 0b                	mov    (%ebx),%ecx
    9fbd:	75 e1                	jne    9fa0 <DoRefreshRLCBuffserRequest+0x120>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);
	}
	fsm_mem_free(RLChead);
    9fbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9fc2:	e8 fc ff ff ff       	call   9fc3 <DoRefreshRLCBuffserRequest+0x143>
	FOUT;
}
    9fc7:	83 c4 14             	add    $0x14,%esp
    9fca:	5b                   	pop    %ebx
    9fcb:	5e                   	pop    %esi
    9fcc:	5f                   	pop    %edi
    9fcd:	5d                   	pop    %ebp
    9fce:	c3                   	ret    
    9fcf:	90                   	nop

00009fd0 <LogicalChannel_ConfigInfo_Rank_Priority>:
->Output:LogicalChannelConfigInfo 
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_Rank_Priority()
{
    9fd0:	55                   	push   %ebp
    9fd1:	89 e5                	mov    %esp,%ebp
    9fd3:	57                   	push   %edi
    9fd4:	56                   	push   %esi
    9fd5:	53                   	push   %ebx
    9fd6:	83 ec 0c             	sub    $0xc,%esp
    9fd9:	e8 fc ff ff ff       	call   9fda <LogicalChannel_ConfigInfo_Rank_Priority+0xa>
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
    9fde:	e8 fc ff ff ff       	call   9fdf <LogicalChannel_ConfigInfo_Rank_Priority+0xf>
    9fe3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    9fe6:	b8 19 00 00 00       	mov    $0x19,%eax
    9feb:	e8 fc ff ff ff       	call   9fec <LogicalChannel_ConfigInfo_Rank_Priority+0x1c>
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    9ff0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    9ff3:	8d 50 11             	lea    0x11(%eax),%edx
{
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    9ff6:	89 c3                	mov    %eax,%ebx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9ff8:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9ffb:	89 50 15             	mov    %edx,0x15(%eax)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    9ffe:	8b 81 40 01 00 00    	mov    0x140(%ecx),%eax
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a004:	89 55 ec             	mov    %edx,-0x14(%ebp)
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a007:	8b 70 11             	mov    0x11(%eax),%esi
    a00a:	83 ee 11             	sub    $0x11,%esi
    a00d:	39 f0                	cmp    %esi,%eax
    a00f:	0f 84 7f 00 00 00    	je     a094 <LogicalChannel_ConfigInfo_Rank_Priority+0xc4>
    a015:	8d 76 00             	lea    0x0(%esi),%esi
	{
		next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a018:	b8 19 00 00 00       	mov    $0x19,%eax
    a01d:	e8 fc ff ff ff       	call   a01e <LogicalChannel_ConfigInfo_Rank_Priority+0x4e>
		/*while(next_node==0)//
		{
			next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
		}*/
		next_node->lcid=temp->lcid;
    a022:	0f b6 16             	movzbl (%esi),%edx
    a025:	88 10                	mov    %dl,(%eax)
		next_node->priority=temp->priority;
    a027:	8b 7e 01             	mov    0x1(%esi),%edi
    a02a:	89 78 01             	mov    %edi,0x1(%eax)
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
    a02d:	8b 56 05             	mov    0x5(%esi),%edx
    a030:	89 50 05             	mov    %edx,0x5(%eax)
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
    a033:	8b 56 09             	mov    0x9(%esi),%edx
    a036:	89 50 09             	mov    %edx,0x9(%eax)
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
    a039:	8b 56 0d             	mov    0xd(%esi),%edx
    a03c:	89 50 0d             	mov    %edx,0xd(%eax)
		INIT_LIST_HEAD(&(next_node->list));
    a03f:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a042:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a045:	89 50 15             	mov    %edx,0x15(%eax)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    a048:	8b 4b 11             	mov    0x11(%ebx),%ecx
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a04b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
		next_node->lcid=temp->lcid;
		next_node->priority=temp->priority;
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
		INIT_LIST_HEAD(&(next_node->list));
    a04e:	89 55 f0             	mov    %edx,-0x10(%ebp)
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a051:	74 4d                	je     a0a0 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			else
			{
				flag_add=false;
				list_for_each_entry(temp_next, &(lcc_info_priority->list),list)//
    a053:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a056:	39 d3                	cmp    %edx,%ebx
    a058:	75 10                	jne    a06a <LogicalChannel_ConfigInfo_Rank_Priority+0x9a>
    a05a:	eb 44                	jmp    a0a0 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
    a05c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a060:	8b 4a 11             	mov    0x11(%edx),%ecx
    a063:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a066:	39 d3                	cmp    %edx,%ebx
    a068:	74 36                	je     a0a0 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				{
					//  if(temp_next->prioritizedBitRateKbps==-1)
						//  continue;
					if ((next_node->priority) <= (temp_next->priority))
    a06a:	3b 79 f0             	cmp    -0x10(%ecx),%edi
    a06d:	7f f1                	jg     a060 <LogicalChannel_ConfigInfo_Rank_Priority+0x90>
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a06f:	8b 7d f0             	mov    -0x10(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a072:	8b 4a 15             	mov    0x15(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a075:	89 7a 15             	mov    %edi,0x15(%edx)
					{
						list_add_tail(&(next_node->list), &(temp_next->list));
    a078:	83 c2 11             	add    $0x11,%edx
    a07b:	89 50 11             	mov    %edx,0x11(%eax)
	new->next = next;
	new->prev = prev;
    a07e:	89 48 15             	mov    %ecx,0x15(%eax)
	prev->next = new;
    a081:	89 39                	mov    %edi,(%ecx)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a083:	8b 76 11             	mov    0x11(%esi),%esi
    a086:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a089:	83 ee 11             	sub    $0x11,%esi
    a08c:	39 b0 40 01 00 00    	cmp    %esi,0x140(%eax)
    a092:	75 84                	jne    a018 <LogicalChannel_ConfigInfo_Rank_Priority+0x48>
					list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			}

	}
	FRET(lcc_info_priority);
}
    a094:	83 c4 0c             	add    $0xc,%esp
    a097:	89 d8                	mov    %ebx,%eax
    a099:	5b                   	pop    %ebx
    a09a:	5e                   	pop    %esi
    a09b:	5f                   	pop    %edi
    a09c:	5d                   	pop    %ebp
    a09d:	c3                   	ret    
    a09e:	66 90                	xchg   %ax,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a0a0:	8b 53 15             	mov    0x15(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a0a3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	new->next = next;
    a0a6:	8b 7d ec             	mov    -0x14(%ebp),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a0a9:	89 4b 15             	mov    %ecx,0x15(%ebx)
	new->next = next;
    a0ac:	89 78 11             	mov    %edi,0x11(%eax)
	new->prev = prev;
    a0af:	89 50 15             	mov    %edx,0x15(%eax)
	prev->next = new;
    a0b2:	89 0a                	mov    %ecx,(%edx)
    a0b4:	eb cd                	jmp    a083 <LogicalChannel_ConfigInfo_Rank_Priority+0xb3>
    a0b6:	8d 76 00             	lea    0x0(%esi),%esi
    a0b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a0c0 <PrioritySort>:
->Output:MacBufferStatus *:SV(MacBuffer_RLC)
->Special:
*******************************
*/
MacBufferStatus* PrioritySort(void)
{
    a0c0:	55                   	push   %ebp
    a0c1:	89 e5                	mov    %esp,%ebp
    a0c3:	57                   	push   %edi
    a0c4:	56                   	push   %esi
    a0c5:	53                   	push   %ebx
    a0c6:	83 ec 14             	sub    $0x14,%esp
    a0c9:	e8 fc ff ff ff       	call   a0ca <PrioritySort+0xa>
	u8 temp_Bj_lcid;
	MacBufferStatus *temp_node;
	struct list_head *pos,*p;

	FIN(PrioritySort(void));
	SV_PTR_GET(rlc_mac_sv);
    a0ce:	e8 fc ff ff ff       	call   a0cf <PrioritySort+0xf>
    a0d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *Priority_logicalChannel=NULL,*temp_logicalChannel=NULL;
	MacBufferStatus *PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus)),*temp_mbs=NULL;
    a0d6:	b8 0d 00 00 00       	mov    $0xd,%eax
    a0db:	e8 fc ff ff ff       	call   a0dc <PrioritySort+0x1c>
    a0e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a0e3:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(PriorityMacBufferStatus==0)//
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
    a0e6:	83 c0 05             	add    $0x5,%eax
    a0e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a0ec:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    a0ef:	89 42 09             	mov    %eax,0x9(%edx)
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a0f2:	e8 fc ff ff ff       	call   a0f3 <PrioritySort+0x33>
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a0f7:	8b 50 11             	mov    0x11(%eax),%edx
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a0fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a0fd:	8d 72 ef             	lea    -0x11(%edx),%esi
    a100:	39 f0                	cmp    %esi,%eax
    a102:	74 7b                	je     a17f <PrioritySort+0xbf>
    a104:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a108:	8b 45 e8             	mov    -0x18(%ebp),%eax
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
    a10b:	0f b6 0e             	movzbl (%esi),%ecx
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a10e:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a114:	8b 42 05             	mov    0x5(%edx),%eax
    a117:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a11a:	39 da                	cmp    %ebx,%edx
    a11c:	75 0c                	jne    a12a <PrioritySort+0x6a>
    a11e:	eb 4e                	jmp    a16e <PrioritySort+0xae>
    a120:	8b 43 05             	mov    0x5(%ebx),%eax
    a123:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a126:	39 da                	cmp    %ebx,%edx
    a128:	74 44                	je     a16e <PrioritySort+0xae>
		{
			if(temp_Bj_lcid==temp_node->lcid)
    a12a:	38 48 fb             	cmp    %cl,-0x5(%eax)
    a12d:	75 f1                	jne    a120 <PrioritySort+0x60>
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a12f:	b8 0d 00 00 00       	mov    $0xd,%eax
    a134:	e8 fc ff ff ff       	call   a135 <PrioritySort+0x75>
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
    a139:	8d 50 05             	lea    0x5(%eax),%edx
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
		{
			if(temp_Bj_lcid==temp_node->lcid)
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a13c:	89 c7                	mov    %eax,%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a13e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a141:	89 50 09             	mov    %edx,0x9(%eax)
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
				temp_mbs->lcid=temp_node->lcid;
    a144:	0f b6 03             	movzbl (%ebx),%eax
    a147:	88 07                	mov    %al,(%edi)
				temp_mbs->RlcRequestparams=Mac_MacRequest_copy(temp_node->RlcRequestparams);
    a149:	8b 43 01             	mov    0x1(%ebx),%eax
    a14c:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a14f:	e8 fc ff ff ff       	call   a150 <PrioritySort+0x90>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a154:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a157:	89 47 01             	mov    %eax,0x1(%edi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a15a:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a15d:	8b 41 09             	mov    0x9(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a160:	89 51 09             	mov    %edx,0x9(%ecx)
	new->next = next;
    a163:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	new->prev = prev;
    a166:	89 47 09             	mov    %eax,0x9(%edi)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    a169:	89 4f 05             	mov    %ecx,0x5(%edi)
	new->prev = prev;
	prev->next = new;
    a16c:	89 10                	mov    %edx,(%eax)
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a16e:	8b 76 11             	mov    0x11(%esi),%esi
    a171:	83 ee 11             	sub    $0x11,%esi
    a174:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a177:	75 8f                	jne    a108 <PrioritySort+0x48>
    a179:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a17c:	8b 50 11             	mov    0x11(%eax),%edx
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a17f:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a182:	8b 1a                	mov    (%edx),%ebx
    a184:	83 c6 11             	add    $0x11,%esi
    a187:	39 f2                	cmp    %esi,%edx
    a189:	89 d9                	mov    %ebx,%ecx
    a18b:	75 07                	jne    a194 <PrioritySort+0xd4>
    a18d:	eb 20                	jmp    a1af <PrioritySort+0xef>
    a18f:	90                   	nop
    a190:	89 da                	mov    %ebx,%edx
    a192:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a194:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
    a197:	8d 42 ef             	lea    -0x11(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a19a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a19d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a19f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a1a1:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp_logicalChannel);//
    a1a4:	e8 fc ff ff ff       	call   a1a5 <PrioritySort+0xe5>
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a1a9:	39 de                	cmp    %ebx,%esi
    a1ab:	8b 0b                	mov    (%ebx),%ecx
    a1ad:	75 e1                	jne    a190 <PrioritySort+0xd0>
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
		fsm_mem_free(temp_logicalChannel);//
	}
	fsm_mem_free(Priority_logicalChannel);
    a1af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a1b2:	e8 fc ff ff ff       	call   a1b3 <PrioritySort+0xf3>
	FRET(PriorityMacBufferStatus);
}
    a1b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a1ba:	83 c4 14             	add    $0x14,%esp
    a1bd:	5b                   	pop    %ebx
    a1be:	5e                   	pop    %esi
    a1bf:	5f                   	pop    %edi
    a1c0:	5d                   	pop    %ebp
    a1c1:	c3                   	ret    
    a1c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    a1c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a1d0 <DoProduceBsr_LCGZeroToData>:
->Output: SV(Regularbsr) :BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
    a1d0:	55                   	push   %ebp
    a1d1:	89 e5                	mov    %esp,%ebp
    a1d3:	53                   	push   %ebx
    a1d4:	e8 fc ff ff ff       	call   a1d5 <DoProduceBsr_LCGZeroToData+0x5>
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a1d9:	e8 fc ff ff ff       	call   a1da <DoProduceBsr_LCGZeroToData+0xa>
	if(SV(LCGZeroToData) == true)
    a1de:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a1e5:	89 c3                	mov    %eax,%ebx
	if(SV(LCGZeroToData) == true)
    a1e7:	75 0f                	jne    a1f8 <DoProduceBsr_LCGZeroToData+0x28>
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a1e9:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a1f0:	5b                   	pop    %ebx
    a1f1:	5d                   	pop    %ebp
    a1f2:	c3                   	ret    
    a1f3:	90                   	nop
    a1f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(LCGZeroToData) == true)
	{
		RefreshBufferStatusForBSR();
    a1f8:	e8 fc ff ff ff       	call   a1f9 <DoProduceBsr_LCGZeroToData+0x29>
		if (SV(bsr)!=NULL)
    a1fd:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a203:	85 c0                	test   %eax,%eax
    a205:	74 e2                	je     a1e9 <DoProduceBsr_LCGZeroToData+0x19>
		{
			//fsm_printf("[UEMAC][BSR]have BSR\n");
			if(SV(Regularbsr)!=NULL)
    a207:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a20d:	85 c0                	test   %eax,%eax
    a20f:	74 0f                	je     a220 <DoProduceBsr_LCGZeroToData+0x50>
			{
				fsm_mem_free(SV(Regularbsr));//Regularbsr
    a211:	e8 fc ff ff ff       	call   a212 <DoProduceBsr_LCGZeroToData+0x42>
				SV(Regularbsr)=NULL;
    a216:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a21d:	00 00 00 
			}
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a220:	e8 fc ff ff ff       	call   a221 <DoProduceBsr_LCGZeroToData+0x51>
    a225:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
			if((SV(Regularbsr)->m_lcgnum) >1)
    a22b:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a22f:	76 1f                	jbe    a250 <DoProduceBsr_LCGZeroToData+0x80>
			{
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a231:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a238:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a23f:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a245:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a24c:	5b                   	pop    %ebx
    a24d:	5d                   	pop    %ebp
    a24e:	c3                   	ret    
    a24f:	90                   	nop
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR long:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
			else if((SV(Regularbsr)->m_lcgnum) ==1)
    a250:	75 97                	jne    a1e9 <DoProduceBsr_LCGZeroToData+0x19>
			{
				SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a252:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a259:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a260:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
    a266:	eb 81                	jmp    a1e9 <DoProduceBsr_LCGZeroToData+0x19>
    a268:	90                   	nop
    a269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a270 <DoProduceBsr_PeriodicBSRTimer>:
->Output: SV(Periodicbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
    a270:	55                   	push   %ebp
    a271:	89 e5                	mov    %esp,%ebp
    a273:	53                   	push   %ebx
    a274:	e8 fc ff ff ff       	call   a275 <DoProduceBsr_PeriodicBSRTimer+0x5>
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a279:	e8 fc ff ff ff       	call   a27a <DoProduceBsr_PeriodicBSRTimer+0xa>
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a27e:	80 b8 59 01 00 00 00 	cmpb   $0x0,0x159(%eax)
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a285:	89 c3                	mov    %eax,%ebx
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a287:	75 07                	jne    a290 <DoProduceBsr_PeriodicBSRTimer+0x20>
			}
		}
		SV(m_freshUlBsr)=false;
	}
	FOUT;
}
    a289:	5b                   	pop    %ebx
    a28a:	5d                   	pop    %ebp
    a28b:	c3                   	ret    
    a28c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
	{
		RefreshBufferStatusForBSR ();
    a290:	e8 fc ff ff ff       	call   a291 <DoProduceBsr_PeriodicBSRTimer+0x21>
		if (SV(bsr)!=NULL)
    a295:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a29b:	85 c0                	test   %eax,%eax
    a29d:	74 34                	je     a2d3 <DoProduceBsr_PeriodicBSRTimer+0x63>
		{
			if(SV(Periodicbsr)==NULL)
    a29f:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a2a5:	85 c0                	test   %eax,%eax
    a2a7:	74 05                	je     a2ae <DoProduceBsr_PeriodicBSRTimer+0x3e>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();
			else
			{
				fsm_mem_free(SV(Periodicbsr));//Regularbsr
    a2a9:	e8 fc ff ff ff       	call   a2aa <DoProduceBsr_PeriodicBSRTimer+0x3a>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();//
    a2ae:	e8 fc ff ff ff       	call   a2af <DoProduceBsr_PeriodicBSRTimer+0x3f>
    a2b3:	89 83 50 01 00 00    	mov    %eax,0x150(%ebx)
			}
			// if(SV(ALLOCATION_RESOURCE_BSR_INFO)==true)
			// {
			if((SV(Periodicbsr)->m_lcgnum) >1)
    a2b9:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a2bd:	76 21                	jbe    a2e0 <DoProduceBsr_PeriodicBSRTimer+0x70>
			{
				SV(MAC_CE_Tags)[period_longBSR_CE].addinPDU_flag=true;
    a2bf:	c6 83 dc 01 00 00 01 	movb   $0x1,0x1dc(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
    a2c6:	c6 83 dd 01 00 00 1e 	movb   $0x1e,0x1dd(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a2cd:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
		}
		SV(m_freshUlBsr)=false;
    a2d3:	c6 83 59 01 00 00 00 	movb   $0x0,0x159(%ebx)
	}
	FOUT;
}
    a2da:	5b                   	pop    %ebx
    a2db:	5d                   	pop    %ebp
    a2dc:	c3                   	ret    
    a2dd:	8d 76 00             	lea    0x0(%esi),%esi
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
			else
			{
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
    a2e0:	c6 83 d4 01 00 00 01 	movb   $0x1,0x1d4(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a2e7:	c6 83 d5 01 00 00 1d 	movb   $0x1d,0x1d5(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a2ee:	89 83 d8 01 00 00    	mov    %eax,0x1d8(%ebx)
    a2f4:	eb dd                	jmp    a2d3 <DoProduceBsr_PeriodicBSRTimer+0x63>
    a2f6:	8d 76 00             	lea    0x0(%esi),%esi
    a2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a300 <DoProduceBsr_RetxBSRTimer>:
->Output: SV(Regularbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_RetxBSRTimer(void)
{
    a300:	55                   	push   %ebp
    a301:	89 e5                	mov    %esp,%ebp
    a303:	53                   	push   %ebx
    a304:	e8 fc ff ff ff       	call   a305 <DoProduceBsr_RetxBSRTimer+0x5>
	FIN(DoProduceBsr_RetxBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a309:	e8 fc ff ff ff       	call   a30a <DoProduceBsr_RetxBSRTimer+0xa>
    a30e:	89 c3                	mov    %eax,%ebx
	if(list_empty((&(SV(MacBuffer_RLC)->list))))//BSRTTI BSR
    a310:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    a316:	8d 50 05             	lea    0x5(%eax),%edx
    a319:	39 50 05             	cmp    %edx,0x5(%eax)
    a31c:	74 43                	je     a361 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		FOUT;
	}
	RefreshBufferStatusForBSR ();
    a31e:	e8 fc ff ff ff       	call   a31f <DoProduceBsr_RetxBSRTimer+0x1f>
	if (SV(bsr)!=NULL)
    a323:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a329:	85 c0                	test   %eax,%eax
    a32b:	74 34                	je     a361 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		if(SV(Regularbsr)==NULL)//Regularbsr
    a32d:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a333:	85 c0                	test   %eax,%eax
    a335:	74 05                	je     a33c <DoProduceBsr_RetxBSRTimer+0x3c>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();
		else
		{
			fsm_mem_free(SV(Regularbsr));//Regularbsr
    a337:	e8 fc ff ff ff       	call   a338 <DoProduceBsr_RetxBSRTimer+0x38>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a33c:	e8 fc ff ff ff       	call   a33d <DoProduceBsr_RetxBSRTimer+0x3d>
    a341:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
		}
		if((SV(Regularbsr)->m_lcgnum) >1)
    a347:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a34b:	76 1b                	jbe    a368 <DoProduceBsr_RetxBSRTimer+0x68>
		{
			SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a34d:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a354:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a35b:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
	}
	FOUT;
}
    a361:	5b                   	pop    %ebx
    a362:	5d                   	pop    %ebp
    a363:	c3                   	ret    
    a364:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
		else
		{
			SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a368:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a36f:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a376:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
		}
	}
	FOUT;
}
    a37c:	5b                   	pop    %ebx
    a37d:	5d                   	pop    %ebp
    a37e:	c3                   	ret    
    a37f:	90                   	nop

0000a380 <Free_Bsr_Info>:
->Output: 
->Special:
*******************************
*/
void Free_Bsr_Info(void)
{
    a380:	55                   	push   %ebp
    a381:	89 e5                	mov    %esp,%ebp
    a383:	53                   	push   %ebx
    a384:	e8 fc ff ff ff       	call   a385 <Free_Bsr_Info+0x5>
	FIN(Free_Bsr_Info(void));
	SV_PTR_GET(rlc_mac_sv);
    a389:	e8 fc ff ff ff       	call   a38a <Free_Bsr_Info+0xa>
    a38e:	89 c3                	mov    %eax,%ebx
	if(SV(Regularbsr)!=NULL)
    a390:	8b 80 4c 01 00 00    	mov    0x14c(%eax),%eax
    a396:	85 c0                	test   %eax,%eax
    a398:	74 0f                	je     a3a9 <Free_Bsr_Info+0x29>
	{
		fsm_mem_free(SV(Regularbsr));
    a39a:	e8 fc ff ff ff       	call   a39b <Free_Bsr_Info+0x1b>
		SV(Regularbsr)=NULL;
    a39f:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a3a6:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    a3a9:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a3af:	85 c0                	test   %eax,%eax
    a3b1:	74 0f                	je     a3c2 <Free_Bsr_Info+0x42>
	{
		fsm_mem_free(SV(Periodicbsr));
    a3b3:	e8 fc ff ff ff       	call   a3b4 <Free_Bsr_Info+0x34>
		SV(Periodicbsr)=NULL;
    a3b8:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    a3bf:	00 00 00 
	}
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    a3c2:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a3c8:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    a3cd:	31 d2                	xor    %edx,%edx
    a3cf:	e8 fc ff ff ff       	call   a3d0 <Free_Bsr_Info+0x50>
	FOUT;
}
    a3d4:	5b                   	pop    %ebx
    a3d5:	5d                   	pop    %ebp
    a3d6:	c3                   	ret    
    a3d7:	89 f6                	mov    %esi,%esi
    a3d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a3e0 <Zero_LogicalChannel_Bj_Reset>:
->Output: SV(LogicalChannel_Bj)lcbj0
->Special:
*******************************
*/
void Zero_LogicalChannel_Bj_Reset()
{
    a3e0:	55                   	push   %ebp
    a3e1:	89 e5                	mov    %esp,%ebp
    a3e3:	56                   	push   %esi
    a3e4:	53                   	push   %ebx
    a3e5:	e8 fc ff ff ff       	call   a3e6 <Zero_LogicalChannel_Bj_Reset+0x6>
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
    a3ea:	e8 fc ff ff ff       	call   a3eb <Zero_LogicalChannel_Bj_Reset+0xb>
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a3ef:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
    a3f5:	8b 4b 05             	mov    0x5(%ebx),%ecx
    a3f8:	8d 73 05             	lea    0x5(%ebx),%esi
    a3fb:	39 f1                	cmp    %esi,%ecx
    a3fd:	8b 11                	mov    (%ecx),%edx
    a3ff:	75 0b                	jne    a40c <Zero_LogicalChannel_Bj_Reset+0x2c>
    a401:	eb 28                	jmp    a42b <Zero_LogicalChannel_Bj_Reset+0x4b>
    a403:	90                   	nop
    a404:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a408:	89 d1                	mov    %edx,%ecx
    a40a:	89 f2                	mov    %esi,%edx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
    a40c:	81 79 fc 01 7d 00 00 	cmpl   $0x7d01,-0x4(%ecx)
    a413:	74 0d                	je     a422 <Zero_LogicalChannel_Bj_Reset+0x42>
			temp->lcbj=0;//BJ0			
    a415:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
    a41c:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a422:	8d 4b 05             	lea    0x5(%ebx),%ecx
    a425:	8b 32                	mov    (%edx),%esi
    a427:	39 ca                	cmp    %ecx,%edx
    a429:	75 dd                	jne    a408 <Zero_LogicalChannel_Bj_Reset+0x28>
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
			temp->lcbj=0;//BJ0			
	}
	FOUT;
}
    a42b:	5b                   	pop    %ebx
    a42c:	5e                   	pop    %esi
    a42d:	5d                   	pop    %ebp
    a42e:	c3                   	ret    
    a42f:	90                   	nop

0000a430 <Init_LogicalChannel_ConfigInfo>:
->Output: SV(LogicalChannel_Bj)
->Special:
*******************************
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
    a430:	55                   	push   %ebp
    a431:	89 e5                	mov    %esp,%ebp
    a433:	57                   	push   %edi
    a434:	56                   	push   %esi
    a435:	53                   	push   %ebx
    a436:	83 ec 04             	sub    $0x4,%esp
    a439:	e8 fc ff ff ff       	call   a43a <Init_LogicalChannel_ConfigInfo+0xa>
    a43e:	89 c3                	mov    %eax,%ebx
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a440:	e8 fc ff ff ff       	call   a441 <Init_LogicalChannel_ConfigInfo+0x11>
	bool flag=false;
	struct list_head *pos=NULL,*p=NULL;
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
    a445:	0f b6 3b             	movzbl (%ebx),%edi
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a448:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a44e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a451:	8b 56 11             	mov    0x11(%esi),%edx
    a454:	83 c6 11             	add    $0x11,%esi
    a457:	39 f2                	cmp    %esi,%edx
    a459:	8b 02                	mov    (%edx),%eax
    a45b:	75 0d                	jne    a46a <Init_LogicalChannel_ConfigInfo+0x3a>
    a45d:	eb 39                	jmp    a498 <Init_LogicalChannel_ConfigInfo+0x68>
    a45f:	90                   	nop
    a460:	39 c6                	cmp    %eax,%esi
    a462:	8b 08                	mov    (%eax),%ecx
    a464:	74 32                	je     a498 <Init_LogicalChannel_ConfigInfo+0x68>
    a466:	89 c2                	mov    %eax,%edx
    a468:	89 c8                	mov    %ecx,%eax
	{
		temp_lc_config=list_entry(pos,LogicalChannelConfigInfo,list);
		temp_lc_config_lcid=temp_lc_config->lcid;
		if(temp_lcid==temp_lc_config_lcid)
    a46a:	89 f9                	mov    %edi,%ecx
    a46c:	3a 4a ef             	cmp    -0x11(%edx),%cl
    a46f:	75 ef                	jne    a460 <Init_LogicalChannel_ConfigInfo+0x30>
		{
			if((lc_info->logicalChannelConfig).haveUl_SpecificParameters==true)
    a471:	80 7b 04 00          	cmpb   $0x0,0x4(%ebx)
    a475:	74 e9                	je     a460 <Init_LogicalChannel_ConfigInfo+0x30>
			{
				temp_lc_config->priority=(lc_info->logicalChannelConfig).ul_SpecificParameters.priority;
    a477:	8b 43 05             	mov    0x5(%ebx),%eax
    a47a:	89 42 f0             	mov    %eax,-0x10(%edx)
				temp_lc_config->prioritizedBitRateKbps=(lc_info->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    a47d:	8b 43 09             	mov    0x9(%ebx),%eax
    a480:	89 42 f4             	mov    %eax,-0xc(%edx)
				temp_lc_config->bucketSizeDurationMs=(lc_info->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    a483:	8b 43 0d             	mov    0xd(%ebx),%eax
    a486:	89 42 f8             	mov    %eax,-0x8(%edx)
				temp_lc_config->logicalChannelGroup=(lc_info->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    a489:	8b 43 11             	mov    0x11(%ebx),%eax
    a48c:	89 42 fc             	mov    %eax,-0x4(%edx)
			temp_bj->lcbj=0;
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a48f:	83 c4 04             	add    $0x4,%esp
    a492:	5b                   	pop    %ebx
    a493:	5e                   	pop    %esi
    a494:	5f                   	pop    %edi
    a495:	5d                   	pop    %ebp
    a496:	c3                   	ret    
    a497:	90                   	nop
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a498:	89 d8                	mov    %ebx,%eax
    a49a:	e8 fc ff ff ff       	call   a49b <Init_LogicalChannel_ConfigInfo+0x6b>
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a49f:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a4a2:	89 c6                	mov    %eax,%esi
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a4a4:	8b 82 40 01 00 00    	mov    0x140(%edx),%eax
    a4aa:	8d 4e 11             	lea    0x11(%esi),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a4ad:	8b 50 15             	mov    0x15(%eax),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a4b0:	89 48 15             	mov    %ecx,0x15(%eax)
    a4b3:	83 c0 11             	add    $0x11,%eax
    a4b6:	89 46 11             	mov    %eax,0x11(%esi)
		temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    a4b9:	b8 0d 00 00 00       	mov    $0xd,%eax
	new->next = next;
	new->prev = prev;
    a4be:	89 56 15             	mov    %edx,0x15(%esi)
	prev->next = new;
    a4c1:	89 0a                	mov    %ecx,(%edx)
    a4c3:	e8 fc ff ff ff       	call   a4c4 <Init_LogicalChannel_ConfigInfo+0x94>
		/*while(temp_bj==0)//
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
    a4c8:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a4cb:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a4ce:	89 50 09             	mov    %edx,0x9(%eax)
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a4d1:	8b 0b                	mov    (%ebx),%ecx
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a4d3:	bb 01 7d 00 00       	mov    $0x7d01,%ebx
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a4d8:	88 08                	mov    %cl,(%eax)
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a4da:	31 c9                	xor    %ecx,%ecx
    a4dc:	83 7e 05 ff          	cmpl   $0xffffffff,0x5(%esi)
    a4e0:	0f 44 cb             	cmove  %ebx,%ecx
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a4e3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a4e6:	89 48 01             	mov    %ecx,0x1(%eax)
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a4e9:	8b 8b 44 01 00 00    	mov    0x144(%ebx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a4ef:	8b 59 09             	mov    0x9(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a4f2:	89 51 09             	mov    %edx,0x9(%ecx)
    a4f5:	83 c1 05             	add    $0x5,%ecx
    a4f8:	89 48 05             	mov    %ecx,0x5(%eax)
	new->next = next;
	new->prev = prev;
    a4fb:	89 58 09             	mov    %ebx,0x9(%eax)
	prev->next = new;
    a4fe:	89 13                	mov    %edx,(%ebx)
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a500:	83 c4 04             	add    $0x4,%esp
    a503:	5b                   	pop    %ebx
    a504:	5e                   	pop    %esi
    a505:	5f                   	pop    %edi
    a506:	5d                   	pop    %ebp
    a507:	c3                   	ret    
    a508:	90                   	nop
    a509:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a510 <leftresource_morethan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a510:	55                   	push   %ebp
    a511:	89 e5                	mov    %esp,%ebp
    a513:	83 ec 18             	sub    $0x18,%esp
    a516:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a519:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a51c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a51f:	e8 fc ff ff ff       	call   a520 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x10>
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a524:	8b 71 01             	mov    0x1(%ecx),%esi
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a527:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a52a:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a52d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a530:	8b 45 14             	mov    0x14(%ebp),%eax
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a533:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a537:	66 89 72 0d          	mov    %si,0xd(%edx)
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a53b:	8b 71 01             	mov    0x1(%ecx),%esi
    a53e:	8b 76 09             	mov    0x9(%esi),%esi
    a541:	89 72 09             	mov    %esi,0x9(%edx)
	*res_length=*res_length-retxlength;
    a544:	29 38                	sub    %edi,(%eax)
	temp_logicalchannel_bj->lcbj-=retxlength;
    a546:	29 7b 01             	sub    %edi,0x1(%ebx)
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a549:	8b 30                	mov    (%eax),%esi
    a54b:	8b 7d 10             	mov    0x10(%ebp),%edi
    a54e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    a551:	39 fe                	cmp    %edi,%esi
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a553:	8b 71 01             	mov    0x1(%ecx),%esi
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
	*res_length=*res_length-retxlength;
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a556:	0f 83 b4 00 00 00    	jae    a610 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x100>
		*res_length-=txlength;
		//  break;
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
    a55c:	0f b7 7e 07          	movzwl 0x7(%esi),%edi
    a560:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    a564:	0f b7 ff             	movzwl %di,%edi
    a567:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    a56a:	73 4c                	jae    a5b8 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xa8>
			// break;
		}
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
    a56c:	8b 76 03             	mov    0x3(%esi),%esi
    a56f:	39 75 e8             	cmp    %esi,-0x18(%ebp)
    a572:	0f 83 d8 00 00 00    	jae    a650 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x140>
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a578:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a57b:	8b 7d ec             	mov    -0x14(%ebp),%edi
				temp_rlc_report->txQueueHeader=0;
    a57e:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a584:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
    a587:	8b 08                	mov    (%eax),%ecx
    a589:	29 4b 01             	sub    %ecx,0x1(%ebx)
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a58c:	89 fb                	mov    %edi,%ebx
    a58e:	8d 4a 13             	lea    0x13(%edx),%ecx
    a591:	83 c3 13             	add    $0x13,%ebx
			{
				temp_rlc_report->txQueueSize=*res_length;
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
    a594:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a59a:	8b 47 17             	mov    0x17(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a59d:	89 4f 17             	mov    %ecx,0x17(%edi)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a5a0:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a5a3:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a5a6:	89 08                	mov    %ecx,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a5a8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a5ab:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a5ae:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a5b1:	89 ec                	mov    %ebp,%esp
    a5b3:	5d                   	pop    %ebp
    a5b4:	c3                   	ret    
    a5b5:	8d 76 00             	lea    0x0(%esi),%esi
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a5b8:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
    a5bc:	66 89 72 07          	mov    %si,0x7(%edx)
			*res_length=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    a5c0:	8b 71 01             	mov    0x1(%ecx),%esi
    a5c3:	8b 38                	mov    (%eax),%edi
    a5c5:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a5c9:	29 f7                	sub    %esi,%edi
    a5cb:	89 38                	mov    %edi,(%eax)
			temp_rlc_report->txQueueSize=*res_length;
    a5cd:	89 7a 03             	mov    %edi,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=(temp_mac_buffer->RlcRequestparams->txQueueHeader+temp_rlc_report->txQueueSize);
    a5d0:	8b 49 01             	mov    0x1(%ecx),%ecx
    a5d3:	0f b7 71 07          	movzwl 0x7(%ecx),%esi
    a5d7:	8b 4b 01             	mov    0x1(%ebx),%ecx
    a5da:	29 f1                	sub    %esi,%ecx
    a5dc:	29 f9                	sub    %edi,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a5de:	8b 7d ec             	mov    -0x14(%ebp),%edi
    a5e1:	89 4b 01             	mov    %ecx,0x1(%ebx)
			// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
			// temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a5e4:	8d 5a 13             	lea    0x13(%edx),%ebx
    a5e7:	8b 4f 17             	mov    0x17(%edi),%ecx
    a5ea:	89 fe                	mov    %edi,%esi
    a5ec:	83 c6 13             	add    $0x13,%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a5ef:	89 5f 17             	mov    %ebx,0x17(%edi)
    a5f2:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a5f5:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a5f8:	89 19                	mov    %ebx,(%ecx)
			*res_length=0;
    a5fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a600:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a603:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a606:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a609:	89 ec                	mov    %ebp,%esp
    a60b:	5d                   	pop    %ebp
    a60c:	c3                   	ret    
    a60d:	8d 76 00             	lea    0x0(%esi),%esi
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a610:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a614:	66 89 72 07          	mov    %si,0x7(%edx)
		temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a618:	8b 49 01             	mov    0x1(%ecx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a61b:	8b 75 ec             	mov    -0x14(%ebp),%esi
    a61e:	8b 49 03             	mov    0x3(%ecx),%ecx
    a621:	89 4a 03             	mov    %ecx,0x3(%edx)
		temp_logicalchannel_bj->lcbj-=txlength;
    a624:	29 7b 01             	sub    %edi,0x1(%ebx)
    a627:	8b 4e 17             	mov    0x17(%esi),%ecx
		// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a62a:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a62d:	89 5e 17             	mov    %ebx,0x17(%esi)
    a630:	83 c6 13             	add    $0x13,%esi
    a633:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a636:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a639:	89 19                	mov    %ebx,(%ecx)
		*res_length-=txlength;
    a63b:	29 38                	sub    %edi,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a63d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a640:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a643:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a646:	89 ec                	mov    %ebp,%esp
    a648:	5d                   	pop    %ebp
    a649:	c3                   	ret    
    a64a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
			{
				temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a650:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);
    a653:	8b 49 01             	mov    0x1(%ecx),%ecx
    a656:	8b 30                	mov    (%eax),%esi
    a658:	66 2b 71 03          	sub    0x3(%ecx),%si
    a65c:	66 89 72 07          	mov    %si,0x7(%edx)

				temp_logicalchannel_bj->lcbj-=*res_length;
    a660:	8b 08                	mov    (%eax),%ecx
    a662:	29 4b 01             	sub    %ecx,0x1(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a665:	8b 5d ec             	mov    -0x14(%ebp),%ebx
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a668:	8d 4a 13             	lea    0x13(%edx),%ecx
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);

				temp_logicalchannel_bj->lcbj-=*res_length;
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
    a66b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a671:	8b 43 17             	mov    0x17(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a674:	89 4b 17             	mov    %ecx,0x17(%ebx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a677:	83 c3 13             	add    $0x13,%ebx
    a67a:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a67d:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a680:	89 08                	mov    %ecx,(%eax)
    a682:	e9 79 ff ff ff       	jmp    a600 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xf0>
    a687:	89 f6                	mov    %esi,%esi
    a689:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a690 <leftresource_lessthan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a690:	55                   	push   %ebp
    a691:	89 e5                	mov    %esp,%ebp
    a693:	83 ec 10             	sub    $0x10,%esp
    a696:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a699:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a69c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a69f:	e8 fc ff ff ff       	call   a6a0 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x10>
    a6a4:	8b 5d 14             	mov    0x14(%ebp),%ebx
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
    a6a7:	8b 33                	mov    (%ebx),%esi
    a6a9:	89 75 f0             	mov    %esi,-0x10(%ebp)
    a6ac:	8b 71 01             	mov    0x1(%ecx),%esi
    a6af:	0f b7 7e 0d          	movzwl 0xd(%esi),%edi
    a6b3:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    a6b6:	73 58                	jae    a710 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x80>
		*res_length=0;
		// break;
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
    a6b8:	8b 76 09             	mov    0x9(%esi),%esi
    a6bb:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a6be:	0f 83 ac 00 00 00    	jae    a770 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0xe0>
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a6c4:	8b 7d f0             	mov    -0x10(%ebp),%edi
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
			temp_logicalchannel_bj->lcbj-=*res_length;
    a6c7:	8b 75 08             	mov    0x8(%ebp),%esi
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
			temp_rlc_report->retxQueueHeader=0;
    a6ca:	66 c7 42 0d 00 00    	movw   $0x0,0xd(%edx)
			temp_rlc_report->txQueueHeader=0;
    a6d0:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a6d6:	89 7a 09             	mov    %edi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
    a6d9:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=*res_length;
    a6e0:	8b 0b                	mov    (%ebx),%ecx
    a6e2:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
			*res_length=0;
    a6e5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a6eb:	8b 48 17             	mov    0x17(%eax),%ecx
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a6ee:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a6f1:	89 58 17             	mov    %ebx,0x17(%eax)
    a6f4:	83 c0 13             	add    $0x13,%eax
    a6f7:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a6fa:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a6fd:	89 19                	mov    %ebx,(%ecx)
			//break;
		}
	}
	FOUT;
}
    a6ff:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a702:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a705:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a708:	89 ec                	mov    %ebp,%esp
    a70a:	5d                   	pop    %ebp
    a70b:	c3                   	ret    
    a70c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
    a710:	8b 7d 08             	mov    0x8(%ebp),%edi
    a713:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a716:	29 77 01             	sub    %esi,0x1(%edi)
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a719:	89 df                	mov    %ebx,%edi
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a71b:	8b 71 01             	mov    0x1(%ecx),%esi
    a71e:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a722:	66 89 72 0d          	mov    %si,0xd(%edx)
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a726:	8b 49 01             	mov    0x1(%ecx),%ecx
		temp_rlc_report->retxQueueSize=*res_length;
		temp_rlc_report->txQueueHeader=0;
		temp_rlc_report->txQueueSize=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a729:	8d 72 13             	lea    0x13(%edx),%esi
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a72c:	0f b7 49 0d          	movzwl 0xd(%ecx),%ecx
    a730:	c1 e1 02             	shl    $0x2,%ecx
    a733:	29 cf                	sub    %ecx,%edi
    a735:	89 3b                	mov    %edi,(%ebx)
		temp_rlc_report->retxQueueSize=*res_length;
    a737:	89 7a 09             	mov    %edi,0x9(%edx)
		temp_rlc_report->txQueueHeader=0;
    a73a:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
		temp_rlc_report->txQueueSize=0;
    a740:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a747:	8b 48 17             	mov    0x17(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a74a:	89 70 17             	mov    %esi,0x17(%eax)
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a74d:	83 c0 13             	add    $0x13,%eax
    a750:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a753:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a756:	89 31                	mov    %esi,(%ecx)
		*res_length=0;
    a758:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			//break;
		}
	}
	FOUT;
}
    a75e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a761:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a764:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a767:	89 ec                	mov    %ebp,%esp
    a769:	5d                   	pop    %ebp
    a76a:	c3                   	ret    
    a76b:	90                   	nop
    a76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
		{
			temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a770:	89 72 09             	mov    %esi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->retxQueueSize);
    a773:	8b 49 01             	mov    0x1(%ecx),%ecx
    a776:	8b 33                	mov    (%ebx),%esi
    a778:	66 2b 71 09          	sub    0x9(%ecx),%si
    a77c:	66 89 72 0d          	mov    %si,0xd(%edx)

			temp_logicalchannel_bj->lcbj-=*res_length;
    a780:	8b 75 08             	mov    0x8(%ebp),%esi
    a783:	8b 0b                	mov    (%ebx),%ecx
    a785:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueHeader-=temp_rlc_report->retxQueueHeader;
			//temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
			temp_rlc_report->txQueueHeader=0;
    a788:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			temp_rlc_report->txQueueSize=0;
    a78e:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
    a795:	e9 4b ff ff ff       	jmp    a6e5 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x55>
    a79a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a7a0 <ResourceAllocation_logicalchannel_firstretxbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a7a0:	55                   	push   %ebp
    a7a1:	89 e5                	mov    %esp,%ebp
    a7a3:	83 ec 24             	sub    $0x24,%esp
    a7a6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a7a9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a7ac:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a7af:	e8 fc ff ff ff       	call   a7b0 <ResourceAllocation_logicalchannel_firstretxbuffer+0x10>
    a7b4:	8b 7d 10             	mov    0x10(%ebp),%edi
    a7b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a7ba:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a7bf:	89 d6                	mov    %edx,%esi
    a7c1:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a7c4:	e8 fc ff ff ff       	call   a7c5 <ResourceAllocation_logicalchannel_firstretxbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a7c9:	31 d2                	xor    %edx,%edx
    a7cb:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a7d0:	89 c3                	mov    %eax,%ebx
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a7d2:	e8 fc ff ff ff       	call   a7d3 <ResourceAllocation_logicalchannel_firstretxbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
    a7d7:	8d 43 13             	lea    0x13(%ebx),%eax
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a7da:	89 f1                	mov    %esi,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a7dc:	89 43 13             	mov    %eax,0x13(%ebx)
    a7df:	89 da                	mov    %ebx,%edx
	list->prev = list;
    a7e1:	89 43 17             	mov    %eax,0x17(%ebx)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    a7e4:	8b 46 01             	mov    0x1(%esi),%eax
    a7e7:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    a7eb:	88 43 02             	mov    %al,0x2(%ebx)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a7ee:	8b 46 01             	mov    0x1(%esi),%eax
    a7f1:	0f b7 00             	movzwl (%eax),%eax
	temp_rlc_report->statusPduHeader=0;
    a7f4:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
	temp_rlc_report->statusPduSize=0;//PDU
    a7fa:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a800:	66 89 03             	mov    %ax,(%ebx)
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    a803:	8b 45 08             	mov    0x8(%ebp),%eax
    a806:	39 07                	cmp    %eax,(%edi)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a808:	8b 45 0c             	mov    0xc(%ebp),%eax
    a80b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    a80f:	89 44 24 08          	mov    %eax,0x8(%esp)
    a813:	8b 45 08             	mov    0x8(%ebp),%eax
    a816:	89 44 24 04          	mov    %eax,0x4(%esp)
    a81a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a81d:	89 04 24             	mov    %eax,(%esp)
    a820:	8b 45 f0             	mov    -0x10(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    a823:	73 13                	jae    a838 <ResourceAllocation_logicalchannel_firstretxbuffer+0x98>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    a825:	e8 fc ff ff ff       	call   a826 <ResourceAllocation_logicalchannel_firstretxbuffer+0x86>
	}
	FOUT;
}
    a82a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a82d:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a830:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a833:	89 ec                	mov    %ebp,%esp
    a835:	5d                   	pop    %ebp
    a836:	c3                   	ret    
    a837:	90                   	nop
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a838:	e8 fc ff ff ff       	call   a839 <ResourceAllocation_logicalchannel_firstretxbuffer+0x99>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    a83d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a840:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a843:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a846:	89 ec                	mov    %ebp,%esp
    a848:	5d                   	pop    %ebp
    a849:	c3                   	ret    
    a84a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a850 <ResourceAllocation_logicalchannel_firststatusbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a850:	55                   	push   %ebp
    a851:	89 e5                	mov    %esp,%ebp
    a853:	83 ec 24             	sub    $0x24,%esp
    a856:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a859:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a85c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a85f:	e8 fc ff ff ff       	call   a860 <ResourceAllocation_logicalchannel_firststatusbuffer+0x10>
    a864:	8b 7d 14             	mov    0x14(%ebp),%edi
    a867:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a86a:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a86f:	89 d3                	mov    %edx,%ebx
    a871:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a874:	e8 fc ff ff ff       	call   a875 <ResourceAllocation_logicalchannel_firststatusbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a879:	31 d2                	xor    %edx,%edx
    a87b:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a880:	89 c6                	mov    %eax,%esi
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a882:	e8 fc ff ff ff       	call   a883 <ResourceAllocation_logicalchannel_firststatusbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));
    a887:	8d 46 13             	lea    0x13(%esi),%eax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a88a:	89 d9                	mov    %ebx,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a88c:	89 46 13             	mov    %eax,0x13(%esi)
    a88f:	89 f2                	mov    %esi,%edx
	list->prev = list;
    a891:	89 46 17             	mov    %eax,0x17(%esi)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    a894:	8b 43 01             	mov    0x1(%ebx),%eax
    a897:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    a89b:	88 46 02             	mov    %al,0x2(%esi)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a89e:	8b 43 01             	mov    0x1(%ebx),%eax
    a8a1:	0f b7 00             	movzwl (%eax),%eax
    a8a4:	66 89 06             	mov    %ax,(%esi)
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
    a8a7:	8b 43 01             	mov    0x1(%ebx),%eax
    a8aa:	0f b7 40 11          	movzwl 0x11(%eax),%eax
    a8ae:	66 89 46 11          	mov    %ax,0x11(%esi)
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
    a8b2:	8b 43 01             	mov    0x1(%ebx),%eax
    a8b5:	0f b7 40 0f          	movzwl 0xf(%eax),%eax
    a8b9:	66 89 46 0f          	mov    %ax,0xf(%esi)
	*res_length=*res_length-statuslength;        
    a8bd:	8b 07                	mov    (%edi),%eax
    a8bf:	2b 45 08             	sub    0x8(%ebp),%eax
	if(*res_length >= retxlength)
    a8c2:	3b 45 0c             	cmp    0xc(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
    a8c5:	89 07                	mov    %eax,(%edi)
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a8c7:	8b 45 10             	mov    0x10(%ebp),%eax
    a8ca:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    a8ce:	89 44 24 08          	mov    %eax,0x8(%esp)
    a8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8d5:	89 44 24 04          	mov    %eax,0x4(%esp)
    a8d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a8dc:	89 04 24             	mov    %eax,(%esp)
    a8df:	8b 45 f0             	mov    -0x10(%ebp),%eax
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
    a8e2:	73 14                	jae    a8f8 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa8>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    a8e4:	e8 fc ff ff ff       	call   a8e5 <ResourceAllocation_logicalchannel_firststatusbuffer+0x95>
	}
	FOUT;
}
    a8e9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a8ec:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a8ef:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8f2:	89 ec                	mov    %ebp,%esp
    a8f4:	5d                   	pop    %ebp
    a8f5:	c3                   	ret    
    a8f6:	66 90                	xchg   %ax,%ax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a8f8:	e8 fc ff ff ff       	call   a8f9 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa9>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    a8fd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a900:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a903:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a906:	89 ec                	mov    %ebp,%esp
    a908:	5d                   	pop    %ebp
    a909:	c3                   	ret    
    a90a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a910 <ResourceAllocation_foreach_logicalchannel>:
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a910:	55                   	push   %ebp
    a911:	89 e5                	mov    %esp,%ebp
    a913:	83 ec 30             	sub    $0x30,%esp
    a916:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a919:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a91c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a91f:	e8 fc ff ff ff       	call   a920 <ResourceAllocation_foreach_logicalchannel+0x10>
    a924:	8b 75 14             	mov    0x14(%ebp),%esi
    a927:	8b 5d 08             	mov    0x8(%ebp),%ebx
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    a92a:	89 55 e8             	mov    %edx,-0x18(%ebp)
    a92d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a930:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    a933:	e8 fc ff ff ff       	call   a934 <ResourceAllocation_foreach_logicalchannel+0x24>
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    a938:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a93b:	8b 06                	mov    (%esi),%eax
    a93d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a940:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a943:	01 df                	add    %ebx,%edi
    a945:	03 7d 10             	add    0x10(%ebp),%edi
    a948:	39 f8                	cmp    %edi,%eax
    a94a:	73 2c                	jae    a978 <ResourceAllocation_foreach_logicalchannel+0x68>
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
		*res_length=*res_length-(statuslength+retxlength+txlength);
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
    a94c:	39 d8                	cmp    %ebx,%eax
    a94e:	73 70                	jae    a9c0 <ResourceAllocation_foreach_logicalchannel+0xb0>
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
	}
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    a950:	8b 5d 10             	mov    0x10(%ebp),%ebx
    a953:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a956:	89 74 24 08          	mov    %esi,0x8(%esp)
    a95a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    a95e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a961:	89 1c 24             	mov    %ebx,(%esp)
    a964:	e8 fc ff ff ff       	call   a965 <ResourceAllocation_foreach_logicalchannel+0x55>
	}
	FOUT;
}
    a969:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a96c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a96f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a972:	89 ec                	mov    %ebp,%esp
    a974:	5d                   	pop    %ebp
    a975:	c3                   	ret    
    a976:	66 90                	xchg   %ax,%ax
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
	{
		temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    a978:	8b 42 01             	mov    0x1(%edx),%eax
    a97b:	e8 fc ff ff ff       	call   a97c <ResourceAllocation_foreach_logicalchannel+0x6c>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a980:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    a983:	8b 5b 17             	mov    0x17(%ebx),%ebx
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a986:	8d 50 13             	lea    0x13(%eax),%edx
    a989:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    a98c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a98f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    a992:	89 53 17             	mov    %edx,0x17(%ebx)
    a995:	83 c3 13             	add    $0x13,%ebx
	new->next = next;
	new->prev = prev;
    a998:	8b 55 e0             	mov    -0x20(%ebp),%edx
    a99b:	89 58 13             	mov    %ebx,0x13(%eax)
	prev->next = new;
    a99e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    a9a1:	89 50 17             	mov    %edx,0x17(%eax)
	prev->next = new;
    a9a4:	89 1a                	mov    %ebx,(%edx)
		*res_length=*res_length-(statuslength+retxlength+txlength);
    a9a6:	29 3e                	sub    %edi,(%esi)
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
    a9a8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a9ab:	29 79 01             	sub    %edi,0x1(%ecx)
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    a9ae:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a9b1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a9b4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a9b7:	89 ec                	mov    %ebp,%esp
    a9b9:	5d                   	pop    %ebp
    a9ba:	c3                   	ret    
    a9bb:	90                   	nop
    a9bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    a9c0:	8b 45 10             	mov    0x10(%ebp),%eax
    a9c3:	89 74 24 0c          	mov    %esi,0xc(%esp)
    a9c7:	89 1c 24             	mov    %ebx,(%esp)
    a9ca:	89 44 24 08          	mov    %eax,0x8(%esp)
    a9ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9d1:	89 44 24 04          	mov    %eax,0x4(%esp)
    a9d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a9d8:	e8 fc ff ff ff       	call   a9d9 <ResourceAllocation_foreach_logicalchannel+0xc9>
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    a9dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a9e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a9e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a9e6:	89 ec                	mov    %ebp,%esp
    a9e8:	5d                   	pop    %ebp
    a9e9:	c3                   	ret    
    a9ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a9f0 <Delete_LogicalChannel_ConfigInfo>:
->Output:int *num:reportvoid *:RLC report
->Special:
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
    a9f0:	55                   	push   %ebp
    a9f1:	89 e5                	mov    %esp,%ebp
    a9f3:	57                   	push   %edi
    a9f4:	56                   	push   %esi
    a9f5:	53                   	push   %ebx
    a9f6:	83 ec 04             	sub    $0x4,%esp
    a9f9:	e8 fc ff ff ff       	call   a9fa <Delete_LogicalChannel_ConfigInfo+0xa>
    a9fe:	89 c6                	mov    %eax,%esi
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    aa00:	e8 fc ff ff ff       	call   aa01 <Delete_LogicalChannel_ConfigInfo+0x11>
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aa05:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    aa0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aa0e:	8b 51 11             	mov    0x11(%ecx),%edx
    aa11:	8d 41 11             	lea    0x11(%ecx),%eax
    aa14:	39 c2                	cmp    %eax,%edx
    aa16:	8b 1a                	mov    (%edx),%ebx
    aa18:	75 13                	jne    aa2d <Delete_LogicalChannel_ConfigInfo+0x3d>
    aa1a:	eb 44                	jmp    aa60 <Delete_LogicalChannel_ConfigInfo+0x70>
    aa1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    aa20:	8d 51 11             	lea    0x11(%ecx),%edx
    aa23:	8b 03                	mov    (%ebx),%eax
    aa25:	39 d3                	cmp    %edx,%ebx
    aa27:	74 37                	je     aa60 <Delete_LogicalChannel_ConfigInfo+0x70>
    aa29:	89 da                	mov    %ebx,%edx
    aa2b:	89 c3                	mov    %eax,%ebx
	{
		temp_free=list_entry(pos,LogicalChannelConfigInfo,list);
		if(temp_free->lcid==lcid_delete)
    aa2d:	0f b6 42 ef          	movzbl -0x11(%edx),%eax
    aa31:	66 39 f0             	cmp    %si,%ax
    aa34:	75 ea                	jne    aa20 <Delete_LogicalChannel_ConfigInfo+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    aa36:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
    aa39:	8d 42 ef             	lea    -0x11(%edx),%eax
    aa3c:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aa3e:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    aa41:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aa43:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    aa45:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp_free);
    aa48:	e8 fc ff ff ff       	call   aa49 <Delete_LogicalChannel_ConfigInfo+0x59>
    aa4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aa50:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aa56:	8b 03                	mov    (%ebx),%eax
    aa58:	8d 51 11             	lea    0x11(%ecx),%edx
    aa5b:	39 d3                	cmp    %edx,%ebx
    aa5d:	75 ca                	jne    aa29 <Delete_LogicalChannel_ConfigInfo+0x39>
    aa5f:	90                   	nop
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    aa60:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aa63:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
    aa69:	8b 51 05             	mov    0x5(%ecx),%edx
    aa6c:	8d 41 05             	lea    0x5(%ecx),%eax
    aa6f:	39 c2                	cmp    %eax,%edx
    aa71:	8b 1a                	mov    (%edx),%ebx
    aa73:	75 10                	jne    aa85 <Delete_LogicalChannel_ConfigInfo+0x95>
    aa75:	eb 41                	jmp    aab8 <Delete_LogicalChannel_ConfigInfo+0xc8>
    aa77:	90                   	nop
    aa78:	8d 51 05             	lea    0x5(%ecx),%edx
    aa7b:	8b 03                	mov    (%ebx),%eax
    aa7d:	39 d3                	cmp    %edx,%ebx
    aa7f:	74 37                	je     aab8 <Delete_LogicalChannel_ConfigInfo+0xc8>
    aa81:	89 da                	mov    %ebx,%edx
    aa83:	89 c3                	mov    %eax,%ebx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcid==lcid_delete)
    aa85:	0f b6 42 fb          	movzbl -0x5(%edx),%eax
    aa89:	66 39 f0             	cmp    %si,%ax
    aa8c:	75 ea                	jne    aa78 <Delete_LogicalChannel_ConfigInfo+0x88>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    aa8e:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
    aa91:	8d 42 fb             	lea    -0x5(%edx),%eax
    aa94:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aa96:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    aa99:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aa9b:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    aa9d:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp);
    aaa0:	e8 fc ff ff ff       	call   aaa1 <Delete_LogicalChannel_ConfigInfo+0xb1>
    aaa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aaa8:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    aaae:	8b 03                	mov    (%ebx),%eax
    aab0:	8d 51 05             	lea    0x5(%ecx),%edx
    aab3:	39 d3                	cmp    %edx,%ebx
    aab5:	75 ca                	jne    aa81 <Delete_LogicalChannel_ConfigInfo+0x91>
    aab7:	90                   	nop
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
			fsm_mem_free(temp);
		}
	}
	FOUT;
}
    aab8:	83 c4 04             	add    $0x4,%esp
    aabb:	5b                   	pop    %ebx
    aabc:	5e                   	pop    %esi
    aabd:	5f                   	pop    %edi
    aabe:	5d                   	pop    %ebp
    aabf:	c3                   	ret    

0000aac0 <Empty_MACBuffer_Rlc>:
->Output:
->Special:
*******************************
*/
void Empty_MACBuffer_Rlc(void)
{
    aac0:	55                   	push   %ebp
    aac1:	89 e5                	mov    %esp,%ebp
    aac3:	57                   	push   %edi
    aac4:	56                   	push   %esi
    aac5:	53                   	push   %ebx
    aac6:	e8 fc ff ff ff       	call   aac7 <Empty_MACBuffer_Rlc+0x7>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
    aacb:	e8 fc ff ff ff       	call   aacc <Empty_MACBuffer_Rlc+0xc>
    aad0:	89 c7                	mov    %eax,%edi
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    aad2:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    aad8:	8b 58 05             	mov    0x5(%eax),%ebx
    aadb:	83 c0 05             	add    $0x5,%eax
    aade:	39 c3                	cmp    %eax,%ebx
    aae0:	8b 33                	mov    (%ebx),%esi
    aae2:	75 08                	jne    aaec <Empty_MACBuffer_Rlc+0x2c>
    aae4:	eb 34                	jmp    ab1a <Empty_MACBuffer_Rlc+0x5a>
    aae6:	66 90                	xchg   %ax,%ax
    aae8:	89 f3                	mov    %esi,%ebx
    aaea:	89 d6                	mov    %edx,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    aaec:	8b 43 fc             	mov    -0x4(%ebx),%eax
    aaef:	e8 fc ff ff ff       	call   aaf0 <Empty_MACBuffer_Rlc+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    aaf4:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_free->list));
    aaf7:	8d 43 fb             	lea    -0x5(%ebx),%eax
    aafa:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aafc:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    aaff:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab01:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ab03:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ab06:	e8 fc ff ff ff       	call   ab07 <Empty_MACBuffer_Rlc+0x47>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    ab0b:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
    ab11:	8b 16                	mov    (%esi),%edx
    ab13:	83 c0 05             	add    $0x5,%eax
    ab16:	39 c6                	cmp    %eax,%esi
    ab18:	75 ce                	jne    aae8 <Empty_MACBuffer_Rlc+0x28>
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}	
	FOUT;
}
    ab1a:	5b                   	pop    %ebx
    ab1b:	5e                   	pop    %esi
    ab1c:	5f                   	pop    %edi
    ab1d:	5d                   	pop    %ebp
    ab1e:	c3                   	ret    
    ab1f:	90                   	nop

0000ab20 <ResourceAllocation_Algorithm>:
->Special:
*******************************
*/

void * ResourceAllocation_Algorithm(u32 resource_len,u32 *num)//numreport
{
    ab20:	55                   	push   %ebp
    ab21:	89 e5                	mov    %esp,%ebp
    ab23:	57                   	push   %edi
    ab24:	56                   	push   %esi
    ab25:	53                   	push   %ebx
    ab26:	83 ec 3c             	sub    $0x3c,%esp
    ab29:	e8 fc ff ff ff       	call   ab2a <ResourceAllocation_Algorithm+0xa>
    ab2e:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ab31:	89 45 f0             	mov    %eax,-0x10(%ebp)
	u32 *res_length;
	u32 statuslength,retxlength,txlength;
	struct list_head *pos,*p;

	FIN(ResourceAllocation_Algorithm(int resource_len));
	SV_PTR_GET(rlc_mac_sv);
    ab34:	e8 fc ff ff ff       	call   ab35 <ResourceAllocation_Algorithm+0x15>
    ab39:	89 45 dc             	mov    %eax,-0x24(%ebp)
	priority_mac_buffer=NULL;
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ab3c:	b8 1b 00 00 00       	mov    $0x1b,%eax
    ab41:	e8 fc ff ff ff       	call   ab42 <ResourceAllocation_Algorithm+0x22>
    ab46:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ab49:	b8 0d 00 00 00       	mov    $0xd,%eax
    ab4e:	e8 fc ff ff ff       	call   ab4f <ResourceAllocation_Algorithm+0x2f>
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
    ab53:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ab56:	83 c6 13             	add    $0x13,%esi
    ab59:	89 75 cc             	mov    %esi,-0x34(%ebp)
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ab5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab5f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
    ab62:	83 c0 05             	add    $0x5,%eax
    ab65:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ab68:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    ab6b:	89 42 09             	mov    %eax,0x9(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ab71:	89 70 13             	mov    %esi,0x13(%eax)
	list->prev = list;
    ab74:	89 70 17             	mov    %esi,0x17(%eax)
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ab77:	e8 fc ff ff ff       	call   ab78 <ResourceAllocation_Algorithm+0x58>
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ab7c:	89 c2                	mov    %eax,%edx
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ab7e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ab81:	8b 40 05             	mov    0x5(%eax),%eax
    ab84:	8d 78 fb             	lea    -0x5(%eax),%edi
    ab87:	39 fa                	cmp    %edi,%edx
    ab89:	0f 84 cc 02 00 00    	je     ae5b <ResourceAllocation_Algorithm+0x33b>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ab8f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ab92:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ab96:	85 c9                	test   %ecx,%ecx
    ab98:	0f 84 e5 00 00 00    	je     ac83 <ResourceAllocation_Algorithm+0x163>
    ab9e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    aba5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    abac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    abb3:	90                   	nop
    abb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    abb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    abbb:	8b b0 44 01 00 00    	mov    0x144(%eax),%esi
    abc1:	8b 46 05             	mov    0x5(%esi),%eax
    abc4:	8d 58 fb             	lea    -0x5(%eax),%ebx
    abc7:	39 de                	cmp    %ebx,%esi
    abc9:	75 13                	jne    abde <ResourceAllocation_Algorithm+0xbe>
    abcb:	e9 68 01 00 00       	jmp    ad38 <ResourceAllocation_Algorithm+0x218>
    abd0:	8b 43 05             	mov    0x5(%ebx),%eax
    abd3:	8d 58 fb             	lea    -0x5(%eax),%ebx
    abd6:	39 de                	cmp    %ebx,%esi
    abd8:	0f 84 5a 01 00 00    	je     ad38 <ResourceAllocation_Algorithm+0x218>
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
    abde:	38 50 fb             	cmp    %dl,-0x5(%eax)
    abe1:	75 ed                	jne    abd0 <ResourceAllocation_Algorithm+0xb0>
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    abe3:	8b 47 01             	mov    0x1(%edi),%eax
    abe6:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    abea:	0f b7 50 11          	movzwl 0x11(%eax),%edx
    abee:	01 f2                	add    %esi,%edx
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    abf0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    abf4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    abf7:	8b 50 09             	mov    0x9(%eax),%edx
    abfa:	01 d6                	add    %edx,%esi
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    abfc:	8b 50 03             	mov    0x3(%eax),%edx
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    abff:	89 75 ec             	mov    %esi,-0x14(%ebp)
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ac02:	0f b7 70 07          	movzwl 0x7(%eax),%esi
    ac06:	01 d6                	add    %edx,%esi
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    ac08:	81 7b 01 01 7d 00 00 	cmpl   $0x7d01,0x1(%ebx)
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ac0f:	89 75 e8             	mov    %esi,-0x18(%ebp)
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    ac12:	0f 85 a0 01 00 00    	jne    adb8 <ResourceAllocation_Algorithm+0x298>
    ac18:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ac1b:	09 f2                	or     %esi,%edx
    ac1d:	0b 55 e4             	or     -0x1c(%ebp),%edx
    ac20:	0f 84 92 01 00 00    	je     adb8 <ResourceAllocation_Algorithm+0x298>
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    ac26:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ac29:	01 f2                	add    %esi,%edx
    ac2b:	03 55 e4             	add    -0x1c(%ebp),%edx
    ac2e:	39 ca                	cmp    %ecx,%edx
    ac30:	0f 86 b3 01 00 00    	jbe    ade9 <ResourceAllocation_Algorithm+0x2c9>
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    ac36:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ac39:	8d 45 f0             	lea    -0x10(%ebp),%eax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    ac3c:	0f 86 eb 01 00 00    	jbe    ae2d <ResourceAllocation_Algorithm+0x30d>
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ac42:	8b 75 e8             	mov    -0x18(%ebp),%esi
    ac45:	89 d9                	mov    %ebx,%ecx
    ac47:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ac49:	89 44 24 08          	mov    %eax,0x8(%esp)
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ac4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ac50:	89 74 24 04          	mov    %esi,0x4(%esp)
    ac54:	8b 75 ec             	mov    -0x14(%ebp),%esi
    ac57:	89 34 24             	mov    %esi,(%esp)
						break;
    ac5a:	89 de                	mov    %ebx,%esi
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ac5c:	e8 fc ff ff ff       	call   ac5d <ResourceAllocation_Algorithm+0x13d>
    ac61:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ac64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ac68:	8b 47 05             	mov    0x5(%edi),%eax
    ac6b:	8d 78 fb             	lea    -0x5(%eax),%edi
    ac6e:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    ac71:	0f 84 d3 00 00 00    	je     ad4a <ResourceAllocation_Algorithm+0x22a>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ac77:	85 c9                	test   %ecx,%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ac79:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ac7d:	0f 85 35 ff ff ff    	jne    abb8 <ResourceAllocation_Algorithm+0x98>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
    ac83:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ac86:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ac89:	e8 fc ff ff ff       	call   ac8a <ResourceAllocation_Algorithm+0x16a>
    ac8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    ac91:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ac94:	8b 58 05             	mov    0x5(%eax),%ebx
    ac97:	89 c7                	mov    %eax,%edi
    ac99:	83 c7 05             	add    $0x5,%edi
    ac9c:	39 fb                	cmp    %edi,%ebx
    ac9e:	8b 33                	mov    (%ebx),%esi
    aca0:	75 0a                	jne    acac <ResourceAllocation_Algorithm+0x18c>
    aca2:	eb 2d                	jmp    acd1 <ResourceAllocation_Algorithm+0x1b1>
    aca4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    aca8:	89 f3                	mov    %esi,%ebx
    acaa:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    acac:	8b 43 fc             	mov    -0x4(%ebx),%eax
    acaf:	e8 fc ff ff ff       	call   acb0 <ResourceAllocation_Algorithm+0x190>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    acb4:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    acb6:	8d 43 fb             	lea    -0x5(%ebx),%eax
    acb9:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    acbc:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    acbf:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    acc1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    acc3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    acc6:	e8 fc ff ff ff       	call   acc7 <ResourceAllocation_Algorithm+0x1a7>
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    accb:	39 fe                	cmp    %edi,%esi
    accd:	8b 06                	mov    (%esi),%eax
    accf:	75 d7                	jne    aca8 <ResourceAllocation_Algorithm+0x188>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
    acd1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    acd4:	e8 fc ff ff ff       	call   acd5 <ResourceAllocation_Algorithm+0x1b5>
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    acd9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    acdc:	8b 7d d0             	mov    -0x30(%ebp),%edi
    acdf:	8b 58 05             	mov    0x5(%eax),%ebx
    ace2:	39 5d d0             	cmp    %ebx,-0x30(%ebp)
    ace5:	8b 33                	mov    (%ebx),%esi
    ace7:	75 0b                	jne    acf4 <ResourceAllocation_Algorithm+0x1d4>
    ace9:	eb 2e                	jmp    ad19 <ResourceAllocation_Algorithm+0x1f9>
    aceb:	90                   	nop
    acec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    acf0:	89 f3                	mov    %esi,%ebx
    acf2:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    acf4:	8b 43 fc             	mov    -0x4(%ebx),%eax
    acf7:	e8 fc ff ff ff       	call   acf8 <ResourceAllocation_Algorithm+0x1d8>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    acfc:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    acfe:	8d 43 fb             	lea    -0x5(%ebx),%eax
    ad01:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ad04:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    ad07:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad09:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ad0b:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ad0e:	e8 fc ff ff ff       	call   ad0f <ResourceAllocation_Algorithm+0x1ef>
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    ad13:	39 f7                	cmp    %esi,%edi
    ad15:	8b 06                	mov    (%esi),%eax
    ad17:	75 d7                	jne    acf0 <ResourceAllocation_Algorithm+0x1d0>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(lcbj_lessthan_zero);
    ad19:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ad1c:	e8 fc ff ff ff       	call   ad1d <ResourceAllocation_Algorithm+0x1fd>
	Empty_MACBuffer_Rlc();//MacBufferStatus
    ad21:	e8 fc ff ff ff       	call   ad22 <ResourceAllocation_Algorithm+0x202>
	FRET(report_array);
}
    ad26:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ad29:	83 c4 3c             	add    $0x3c,%esp
    ad2c:	5b                   	pop    %ebx
    ad2d:	5e                   	pop    %esi
    ad2e:	5f                   	pop    %edi
    ad2f:	5d                   	pop    %ebp
    ad30:	c3                   	ret    
    ad31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ad38:	8b 47 05             	mov    0x5(%edi),%eax
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    ad3b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ad3e:	8d 78 fb             	lea    -0x5(%eax),%edi
    ad41:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    ad44:	0f 85 2d ff ff ff    	jne    ac77 <ResourceAllocation_Algorithm+0x157>
				}			
				break;
			}
		}
	}
	if(*res_length>0)
    ad4a:	85 c9                	test   %ecx,%ecx
    ad4c:	0f 84 31 ff ff ff    	je     ac83 <ResourceAllocation_Algorithm+0x163>
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    ad52:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ad55:	8b 58 05             	mov    0x5(%eax),%ebx
    ad58:	83 eb 05             	sub    $0x5,%ebx
    ad5b:	39 d8                	cmp    %ebx,%eax
    ad5d:	0f 84 20 ff ff ff    	je     ac83 <ResourceAllocation_Algorithm+0x163>
    ad63:	8b 7d e8             	mov    -0x18(%ebp),%edi
    ad66:	0b 7d ec             	or     -0x14(%ebp),%edi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ad69:	89 75 dc             	mov    %esi,-0x24(%ebp)
    ad6c:	89 c6                	mov    %eax,%esi
		}
	}
	if(*res_length>0)
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    ad6e:	0b 7d e4             	or     -0x1c(%ebp),%edi
    ad71:	eb 13                	jmp    ad86 <ResourceAllocation_Algorithm+0x266>
    ad73:	90                   	nop
    ad74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ad78:	8b 5b 05             	mov    0x5(%ebx),%ebx
    ad7b:	83 eb 05             	sub    $0x5,%ebx
    ad7e:	39 de                	cmp    %ebx,%esi
    ad80:	0f 84 fd fe ff ff    	je     ac83 <ResourceAllocation_Algorithm+0x163>
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
    ad86:	85 ff                	test   %edi,%edi
    ad88:	74 ee                	je     ad78 <ResourceAllocation_Algorithm+0x258>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    ad8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ad8d:	8d 55 f0             	lea    -0x10(%ebp),%edx
    ad90:	89 54 24 0c          	mov    %edx,0xc(%esp)
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    ad94:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ad97:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ad9a:	89 44 24 08          	mov    %eax,0x8(%esp)
    ad9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ada1:	89 54 24 04          	mov    %edx,0x4(%esp)
    ada5:	89 da                	mov    %ebx,%edx
    ada7:	89 04 24             	mov    %eax,(%esp)
    adaa:	8b 45 d8             	mov    -0x28(%ebp),%eax
    adad:	e8 fc ff ff ff       	call   adae <ResourceAllocation_Algorithm+0x28e>
    adb2:	eb c4                	jmp    ad78 <ResourceAllocation_Algorithm+0x258>
    adb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    adb8:	8b 75 e8             	mov    -0x18(%ebp),%esi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    adbb:	8d 45 f0             	lea    -0x10(%ebp),%eax
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    adbe:	89 d9                	mov    %ebx,%ecx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    adc0:	89 44 24 0c          	mov    %eax,0xc(%esp)
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    adc4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    adc7:	89 fa                	mov    %edi,%edx
    adc9:	89 74 24 08          	mov    %esi,0x8(%esp)
    adcd:	8b 75 ec             	mov    -0x14(%ebp),%esi
    add0:	89 74 24 04          	mov    %esi,0x4(%esp)
    add4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    add7:	89 34 24             	mov    %esi,(%esp)
					break;
    adda:	89 de                	mov    %ebx,%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    addc:	e8 fc ff ff ff       	call   addd <ResourceAllocation_Algorithm+0x2bd>
    ade1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					break;
    ade4:	e9 7f fe ff ff       	jmp    ac68 <ResourceAllocation_Algorithm+0x148>
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    ade9:	e8 fc ff ff ff       	call   adea <ResourceAllocation_Algorithm+0x2ca>
    adee:	89 c2                	mov    %eax,%edx
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    adf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    adf3:	66 03 42 0f          	add    0xf(%edx),%ax
    adf7:	66 2b 45 ec          	sub    -0x14(%ebp),%ax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    adfb:	8d 4a 13             	lea    0x13(%edx),%ecx
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    adfe:	66 29 f0             	sub    %si,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ae01:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ae04:	66 2b 45 e4          	sub    -0x1c(%ebp),%ax
    ae08:	66 89 42 0f          	mov    %ax,0xf(%edx)
    ae0c:	8b 46 17             	mov    0x17(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ae0f:	89 4e 17             	mov    %ecx,0x17(%esi)
	new->next = next;
    ae12:	8b 75 cc             	mov    -0x34(%ebp),%esi
	new->prev = prev;
    ae15:	89 42 17             	mov    %eax,0x17(%edx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    ae18:	89 72 13             	mov    %esi,0x13(%edx)
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    ae1b:	89 de                	mov    %ebx,%esi
	new->prev = prev;
	prev->next = new;
    ae1d:	89 08                	mov    %ecx,(%eax)
    ae1f:	31 c9                	xor    %ecx,%ecx
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
    ae21:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    ae28:	e9 3b fe ff ff       	jmp    ac68 <ResourceAllocation_Algorithm+0x148>
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae2d:	8b 75 e8             	mov    -0x18(%ebp),%esi
    ae30:	89 d9                	mov    %ebx,%ecx
    ae32:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae34:	89 44 24 0c          	mov    %eax,0xc(%esp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae38:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae3b:	89 74 24 08          	mov    %esi,0x8(%esp)
    ae3f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    ae42:	89 74 24 04          	mov    %esi,0x4(%esp)
    ae46:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    ae49:	89 34 24             	mov    %esi,(%esp)
						break;
    ae4c:	89 de                	mov    %ebx,%esi
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae4e:	e8 fc ff ff ff       	call   ae4f <ResourceAllocation_Algorithm+0x32f>
    ae53:	8b 4d f0             	mov    -0x10(%ebp),%ecx
						break;
    ae56:	e9 0d fe ff ff       	jmp    ac68 <ResourceAllocation_Algorithm+0x148>
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ae5b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
    ae5e:	31 f6                	xor    %esi,%esi
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
    ae60:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ae67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ae6e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ae75:	e9 d0 fe ff ff       	jmp    ad4a <ResourceAllocation_Algorithm+0x22a>
    ae7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000ae80 <DoResourceAllocation>:
->Output: RLC report
->Special:
*******************************
*/
void DoResourceAllocation(u32 tb_size)//
{
    ae80:	55                   	push   %ebp
    ae81:	89 e5                	mov    %esp,%ebp
    ae83:	83 ec 10             	sub    $0x10,%esp
    ae86:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    ae89:	89 75 f8             	mov    %esi,-0x8(%ebp)
    ae8c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    ae8f:	e8 fc ff ff ff       	call   ae90 <DoResourceAllocation+0x10>
    ae94:	89 c7                	mov    %eax,%edi
	u32 num;
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
    ae96:	b8 04 00 00 00       	mov    $0x4,%eax
    ae9b:	e8 fc ff ff ff       	call   ae9c <DoResourceAllocation+0x1c>
    aea0:	89 c3                	mov    %eax,%ebx
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    aea2:	e8 fc ff ff ff       	call   aea3 <DoResourceAllocation+0x23>
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    aea7:	89 da                	mov    %ebx,%edx
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    aea9:	89 c6                	mov    %eax,%esi
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    aeab:	89 f8                	mov    %edi,%eax
    aead:	e8 fc ff ff ff       	call   aeae <DoResourceAllocation+0x2e>
	SV(DATA_WAIT_ALLOCATION)=false;
    aeb2:	c6 86 5a 01 00 00 00 	movb   $0x0,0x15a(%esi)

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    aeb9:	89 c7                	mov    %eax,%edi
		printk(KERN_INFO" rlc_Report_statusPduSize:%d\n",rlc_temp[j].statusPduSize);
		printk(KERN_INFO" rlc_Report_statusPduHeader:%d\n",rlc_temp[j].statusPduHeader);
	}*/
	//fsm_printf("MAC :%d\n",sizeof(RLC_Request));
	//fsm_do_ioctrl(STRM_TO_RLC,IOCCMD_MACtoRLC_datasend_Allow,UEmac_Rlc_Report,*rlc_report_num);//MACRLC
	fsm_printf("[UEMAC][SCHEDULER]SEND DATA ALLOW IOCTL\n");
    aebb:	c7 04 24 8c 2a 00 00 	movl   $0x2a8c,(%esp)
    aec2:	e8 fc ff ff ff       	call   aec3 <DoResourceAllocation+0x43>
	
	PMRLC_TRANSOP_IND ((void *)UEmac_Rlc_Report); 	//modify in 20150804
    aec7:	89 f8                	mov    %edi,%eax
    aec9:	e8 fc ff ff ff       	call   aeca <DoResourceAllocation+0x4a>
	//fsm_mem_free(UEmac_Rlc_Report);//report 
	fsm_mem_free(rlc_report_num);
    aece:	89 d8                	mov    %ebx,%eax
    aed0:	e8 fc ff ff ff       	call   aed1 <DoResourceAllocation+0x51>
	FOUT;

}
    aed5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aed8:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aedb:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aede:	89 ec                	mov    %ebp,%esp
    aee0:	5d                   	pop    %ebp
    aee1:	c3                   	ret    
    aee2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    aee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000aef0 <Free_Uemac_Scheduler_Resource>:
->Output:
->Special:
*******************************
*/
void Free_Uemac_Scheduler_Resource(void)
{
    aef0:	55                   	push   %ebp
    aef1:	89 e5                	mov    %esp,%ebp
    aef3:	57                   	push   %edi
    aef4:	56                   	push   %esi
    aef5:	53                   	push   %ebx
    aef6:	e8 fc ff ff ff       	call   aef7 <Free_Uemac_Scheduler_Resource+0x7>
	struct list_head *pos,*p;
	MacBufferStatus *temp_rlc_free=NULL;
	LogicalChannelBj *temp_bj_free=NULL;
	LogicalChannelConfigInfo *temp_lcginfo_free=NULL;//

	SV_PTR_GET(rlc_mac_sv);
    aefb:	e8 fc ff ff ff       	call   aefc <Free_Uemac_Scheduler_Resource+0xc>
    af00:	89 c6                	mov    %eax,%esi
	fsm_mem_free(SV(bsr));
    af02:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
    af08:	e8 fc ff ff ff       	call   af09 <Free_Uemac_Scheduler_Resource+0x19>
	//fsm_mem_free(Frame_No_Allocation);
	if(SV(Regularbsr)!=NULL)
    af0d:	8b 86 4c 01 00 00    	mov    0x14c(%esi),%eax
    af13:	85 c0                	test   %eax,%eax
    af15:	74 0f                	je     af26 <Free_Uemac_Scheduler_Resource+0x36>
	{
		fsm_mem_free(SV(Regularbsr));
    af17:	e8 fc ff ff ff       	call   af18 <Free_Uemac_Scheduler_Resource+0x28>
		SV(Regularbsr)=NULL;
    af1c:	c7 86 4c 01 00 00 00 	movl   $0x0,0x14c(%esi)
    af23:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    af26:	8b 86 50 01 00 00    	mov    0x150(%esi),%eax
    af2c:	85 c0                	test   %eax,%eax
    af2e:	74 0f                	je     af3f <Free_Uemac_Scheduler_Resource+0x4f>
	{
		fsm_mem_free(SV(Periodicbsr));
    af30:	e8 fc ff ff ff       	call   af31 <Free_Uemac_Scheduler_Resource+0x41>
		SV(Periodicbsr)=NULL;
    af35:	c7 86 50 01 00 00 00 	movl   $0x0,0x150(%esi)
    af3c:	00 00 00 
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    af3f:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    af45:	8b 58 05             	mov    0x5(%eax),%ebx
    af48:	83 c0 05             	add    $0x5,%eax
    af4b:	39 c3                	cmp    %eax,%ebx
    af4d:	8b 3b                	mov    (%ebx),%edi
    af4f:	75 0b                	jne    af5c <Free_Uemac_Scheduler_Resource+0x6c>
    af51:	eb 37                	jmp    af8a <Free_Uemac_Scheduler_Resource+0x9a>
    af53:	90                   	nop
    af54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    af58:	89 fb                	mov    %edi,%ebx
    af5a:	89 d7                	mov    %edx,%edi
	{
		temp_rlc_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_rlc_free->RlcRequestparams);
    af5c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    af5f:	e8 fc ff ff ff       	call   af60 <Free_Uemac_Scheduler_Resource+0x70>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    af64:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_rlc_free->list));
    af67:	8d 43 fb             	lea    -0x5(%ebx),%eax
    af6a:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    af6c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    af6f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    af71:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    af73:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_rlc_free);
    af76:	e8 fc ff ff ff       	call   af77 <Free_Uemac_Scheduler_Resource+0x87>
	if(SV(Periodicbsr)!=NULL)
	{
		fsm_mem_free(SV(Periodicbsr));
		SV(Periodicbsr)=NULL;
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    af7b:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    af81:	8b 17                	mov    (%edi),%edx
    af83:	83 c0 05             	add    $0x5,%eax
    af86:	39 c7                	cmp    %eax,%edi
    af88:	75 ce                	jne    af58 <Free_Uemac_Scheduler_Resource+0x68>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    af8a:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    af90:	8b 50 05             	mov    0x5(%eax),%edx
    af93:	83 c0 05             	add    $0x5,%eax
    af96:	39 c2                	cmp    %eax,%edx
    af98:	8b 1a                	mov    (%edx),%ebx
    af9a:	75 06                	jne    afa2 <Free_Uemac_Scheduler_Resource+0xb2>
    af9c:	eb 2a                	jmp    afc8 <Free_Uemac_Scheduler_Resource+0xd8>
    af9e:	66 90                	xchg   %ax,%ax
    afa0:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    afa2:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
    afa5:	8d 42 fb             	lea    -0x5(%edx),%eax
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    afa8:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    afaa:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    afad:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    afaf:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    afb1:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
    afb4:	e8 fc ff ff ff       	call   afb5 <Free_Uemac_Scheduler_Resource+0xc5>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    afb9:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    afbf:	8b 1b                	mov    (%ebx),%ebx
    afc1:	83 c0 05             	add    $0x5,%eax
    afc4:	39 c7                	cmp    %eax,%edi
    afc6:	75 d8                	jne    afa0 <Free_Uemac_Scheduler_Resource+0xb0>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    afc8:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    afce:	8b 50 11             	mov    0x11(%eax),%edx
    afd1:	83 c0 11             	add    $0x11,%eax
    afd4:	39 c2                	cmp    %eax,%edx
    afd6:	8b 1a                	mov    (%edx),%ebx
    afd8:	75 08                	jne    afe2 <Free_Uemac_Scheduler_Resource+0xf2>
    afda:	eb 2c                	jmp    b008 <Free_Uemac_Scheduler_Resource+0x118>
    afdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    afe0:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    afe2:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
    afe5:	8d 42 ef             	lea    -0x11(%edx),%eax
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    afe8:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    afea:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    afed:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    afef:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    aff1:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
    aff4:	e8 fc ff ff ff       	call   aff5 <Free_Uemac_Scheduler_Resource+0x105>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    aff9:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    afff:	8b 1b                	mov    (%ebx),%ebx
    b001:	83 c0 11             	add    $0x11,%eax
    b004:	39 c7                	cmp    %eax,%edi
    b006:	75 d8                	jne    afe0 <Free_Uemac_Scheduler_Resource+0xf0>
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
	}
	fsm_mem_free(SV(MacBuffer_RLC));
    b008:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b00e:	e8 fc ff ff ff       	call   b00f <Free_Uemac_Scheduler_Resource+0x11f>
	fsm_mem_free(SV(LogicalChannel_Bj));
    b013:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b019:	e8 fc ff ff ff       	call   b01a <Free_Uemac_Scheduler_Resource+0x12a>
	fsm_mem_free(SV(LogicalChannel_Config));
    b01e:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b024:	e8 fc ff ff ff       	call   b025 <Free_Uemac_Scheduler_Resource+0x135>
	
	FOUT;
}
    b029:	5b                   	pop    %ebx
    b02a:	5e                   	pop    %esi
    b02b:	5f                   	pop    %edi
    b02c:	5d                   	pop    %ebp
    b02d:	c3                   	ret    
    b02e:	66 90                	xchg   %ax,%ax

0000b030 <GetRbsize>:
->Output:
->Special:
*******************************
*/
u32 GetRbsize(u32  channel_bandwidth)
{
    b030:	55                   	push   %ebp
    b031:	89 e5                	mov    %esp,%ebp
    b033:	83 ec 04             	sub    $0x4,%esp
    b036:	e8 fc ff ff ff       	call   b037 <GetRbsize+0x7>

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b03b:	83 e8 03             	sub    $0x3,%eax
    b03e:	83 f8 11             	cmp    $0x11,%eax
    b041:	76 15                	jbe    b058 <GetRbsize+0x28>
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
    b043:	c7 04 24 b8 2a 00 00 	movl   $0x2ab8,(%esp)
    b04a:	e8 fc ff ff ff       	call   b04b <GetRbsize+0x1b>
    b04f:	31 c0                	xor    %eax,%eax
	}
	//}
	FRET(rbsize);
}
    b051:	c9                   	leave  
    b052:	c3                   	ret    
    b053:	90                   	nop
    b054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b058:	ff 24 85 e0 03 00 00 	jmp    *0x3e0(,%eax,4)
    b05f:	90                   	nop
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
    b060:	b8 64 00 00 00       	mov    $0x64,%eax
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b065:	c9                   	leave  
    b066:	c3                   	ret    
    b067:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b068:	b8 0f 00 00 00       	mov    $0xf,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b06d:	c9                   	leave  
    b06e:	c3                   	ret    
    b06f:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b070:	b8 19 00 00 00       	mov    $0x19,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b075:	c9                   	leave  
    b076:	c3                   	ret    
    b077:	90                   	nop
	// {
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
    b078:	b8 32 00 00 00       	mov    $0x32,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b07d:	c9                   	leave  
    b07e:	c3                   	ret    
    b07f:	90                   	nop
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
    b080:	b8 4b 00 00 00       	mov    $0x4b,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b085:	c9                   	leave  
    b086:	c3                   	ret    
    b087:	89 f6                	mov    %esi,%esi
    b089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b090 <DoReceiveULgrant_Tbsize>:
    //???????????????? delay
    FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    b090:	55                   	push   %ebp
    b091:	89 e5                	mov    %esp,%ebp
    b093:	83 ec 20             	sub    $0x20,%esp
    b096:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b099:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b09c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b09f:	e8 fc ff ff ff       	call   b0a0 <DoReceiveULgrant_Tbsize+0x10>
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b0a4:	89 c7                	mov    %eax,%edi
    u16 mcs=receive_ulgrant.m_mcs;//20140725
    b0a6:	c1 e8 0f             	shr    $0xf,%eax
    b0a9:	83 e0 1f             	and    $0x1f,%eax
    b0ac:	88 45 e4             	mov    %al,-0x1c(%ebp)
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b0af:	c1 ef 02             	shr    $0x2,%edi
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b0b2:	e8 fc ff ff ff       	call   b0b3 <DoReceiveULgrant_Tbsize+0x23>
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b0b7:	66 81 e7 ff 1f       	and    $0x1fff,%di
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b0bc:	89 c3                	mov    %eax,%ebx
    rb_number=GetRbsize(BANDWIDTH);
    b0be:	b8 14 00 00 00       	mov    $0x14,%eax
    b0c3:	e8 fc ff ff ff       	call   b0c4 <DoReceiveULgrant_Tbsize+0x34>
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b0c8:	31 d2                	xor    %edx,%edx
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    b0ca:	89 c6                	mov    %eax,%esi
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b0cc:	89 f8                	mov    %edi,%eax
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b0ce:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b0d2:	66 f7 f6             	div    %si
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b0d5:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b0db:	8d 4e 01             	lea    0x1(%esi),%ecx
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b0de:	01 c2                	add    %eax,%edx
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b0e0:	66 29 c1             	sub    %ax,%cx
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    b0e3:	83 c0 01             	add    $0x1,%eax
    b0e6:	66 39 d6             	cmp    %dx,%si
    b0e9:	0f 47 c8             	cmova  %eax,%ecx
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b0ec:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b0f0:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME2 && (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME7)
    b0f6:	8d 50 01             	lea    0x1(%eax),%edx
    b0f9:	83 fa 04             	cmp    $0x4,%edx
    b0fc:	77 3a                	ja     b138 <DoReceiveULgrant_Tbsize+0xa8>
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
    b0fe:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b102:	66 c7 43 10 07 00    	movw   $0x7,0x10(%ebx)
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b108:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b10c:	0f b7 c9             	movzwl %cx,%ecx
    b10f:	8d 44 49 fd          	lea    -0x3(%ecx,%ecx,2),%eax
    b113:	8d 04 c0             	lea    (%eax,%eax,8),%eax
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b116:	83 e2 1f             	and    $0x1f,%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b119:	03 04 95 40 04 00 00 	add    0x440(,%edx,4),%eax
    b120:	8b 34 85 c0 04 00 00 	mov    0x4c0(,%eax,4),%esi
    //FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}
    b127:	89 f0                	mov    %esi,%eax
    b129:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b12c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b12f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b132:	89 ec                	mov    %ebp,%esp
    b134:	5d                   	pop    %ebp
    b135:	c3                   	ret    
    b136:	66 90                	xchg   %ax,%ax
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME7 && (SCHEDULE_ADVANCE+temp_subframe)<=9)
    b138:	8d 50 fc             	lea    -0x4(%eax),%edx
    b13b:	83 fa 01             	cmp    $0x1,%edx
    b13e:	76 26                	jbe    b166 <DoReceiveULgrant_Tbsize+0xd6>
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b140:	83 c0 04             	add    $0x4,%eax
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
    b143:	31 f6                	xor    %esi,%esi
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b145:	83 f8 09             	cmp    $0x9,%eax
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b148:	89 45 e0             	mov    %eax,-0x20(%ebp)
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b14b:	7e da                	jle    b127 <DoReceiveULgrant_Tbsize+0x97>
    b14d:	ba 67 66 66 66       	mov    $0x66666667,%edx
    b152:	f7 ea                	imul   %edx
    b154:	c1 ea 02             	shr    $0x2,%edx
    b157:	8d 04 92             	lea    (%edx,%edx,4),%eax
    b15a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b15d:	01 c0                	add    %eax,%eax
    b15f:	29 c2                	sub    %eax,%edx
    b161:	83 fa 02             	cmp    $0x2,%edx
    b164:	7f c1                	jg     b127 <DoReceiveULgrant_Tbsize+0x97>
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b166:	83 c7 01             	add    $0x1,%edi
    b169:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b16d:	66 c7 43 10 02 00    	movw   $0x2,0x10(%ebx)
    b173:	eb 93                	jmp    b108 <DoReceiveULgrant_Tbsize+0x78>
    b175:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b180 <My_Pow>:
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b180:	55                   	push   %ebp
    b181:	89 e5                	mov    %esp,%ebp
    b183:	53                   	push   %ebx
    b184:	e8 fc ff ff ff       	call   b185 <My_Pow+0x5>
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b189:	85 d2                	test   %edx,%edx
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b18b:	89 c1                	mov    %eax,%ecx
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b18d:	b8 01 00 00 00       	mov    $0x1,%eax
    b192:	74 16                	je     b1aa <My_Pow+0x2a>
    b194:	bb 01 00 00 00       	mov    $0x1,%ebx
    b199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b1a0:	83 c3 01             	add    $0x1,%ebx
		powint*=num;
    b1a3:	0f af c1             	imul   %ecx,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b1a6:	39 da                	cmp    %ebx,%edx
    b1a8:	73 f6                	jae    b1a0 <My_Pow+0x20>
		powint*=num;
	FRET(powint);
}
    b1aa:	5b                   	pop    %ebx
    b1ab:	5d                   	pop    %ebp
    b1ac:	c3                   	ret    
    b1ad:	8d 76 00             	lea    0x0(%esi),%esi

0000b1b0 <My_Log2>:
->Output:log2(rb)
->Special:
*******************************
*/
u32 My_Log2(u32 rb)
{
    b1b0:	55                   	push   %ebp
    b1b1:	89 e5                	mov    %esp,%ebp
    b1b3:	83 ec 04             	sub    $0x4,%esp
    b1b6:	e8 fc ff ff ff       	call   b1b7 <My_Log2+0x7>
	ret=0;
	switch(rb)//20140514modified by lhl float
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
    b1bb:	ba 98 20 00 00       	mov    $0x2098,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b1c0:	83 f8 19             	cmp    $0x19,%eax
    b1c3:	74 23                	je     b1e8 <My_Log2+0x38>
    b1c5:	76 29                	jbe    b1f0 <My_Log2+0x40>
    b1c7:	83 f8 4b             	cmp    $0x4b,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
    b1ca:	ba d5 2c 00 00       	mov    $0x2cd5,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b1cf:	74 17                	je     b1e8 <My_Log2+0x38>
    b1d1:	83 f8 64             	cmp    $0x64,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
    b1d4:	66 ba 0e 30          	mov    $0x300e,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b1d8:	74 0e                	je     b1e8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b1da:	c7 04 24 ec 2a 00 00 	movl   $0x2aec,(%esp)
    b1e1:	e8 fc ff ff ff       	call   b1e2 <My_Log2+0x32>
    b1e6:	31 d2                	xor    %edx,%edx
	}
	FRET(ret);
}//2
    b1e8:	89 d0                	mov    %edx,%eax
    b1ea:	c9                   	leave  
    b1eb:	c3                   	ret    
    b1ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b1f0:	83 f8 06             	cmp    $0x6,%eax
	{
		case 6   : ret=4392 ;break;
    b1f3:	66 ba 28 11          	mov    $0x1128,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b1f7:	74 ef                	je     b1e8 <My_Log2+0x38>
    b1f9:	83 f8 0f             	cmp    $0xf,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
    b1fc:	66 ba fb 1a          	mov    $0x1afb,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b200:	74 e6                	je     b1e8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b202:	c7 04 24 ec 2a 00 00 	movl   $0x2aec,(%esp)
    b209:	e8 fc ff ff ff       	call   b20a <My_Log2+0x5a>
    b20e:	31 d2                	xor    %edx,%edx
    b210:	eb d6                	jmp    b1e8 <My_Log2+0x38>
    b212:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b220 <DoReceiveRARULgrant_Tbsize>:
->Output:
->Special:
*******************************
*/
u32 DoReceiveRARULgrant_Tbsize(RAR_ULgrant *receive_rar_ulgrant)
{
    b220:	55                   	push   %ebp
    b221:	89 e5                	mov    %esp,%ebp
    b223:	57                   	push   %edi
    b224:	56                   	push   %esi
    b225:	53                   	push   %ebx
    b226:	83 ec 1c             	sub    $0x1c,%esp
    b229:	e8 fc ff ff ff       	call   b22a <DoReceiveRARULgrant_Tbsize+0xa>
    b22e:	89 c6                	mov    %eax,%esi
	u16 rb_number;
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
    b230:	e8 fc ff ff ff       	call   b231 <DoReceiveRARULgrant_Tbsize+0x11>
    b235:	89 c7                	mov    %eax,%edi
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
    b237:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b23b:	c0 e8 03             	shr    $0x3,%al
    b23e:	83 e0 0f             	and    $0xf,%eax
    b241:	88 45 f1             	mov    %al,-0xf(%ebp)
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b244:	0f b6 06             	movzbl (%esi),%eax
    b247:	89 c3                	mov    %eax,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b249:	d0 e8                	shr    %al
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b24b:	83 e3 01             	and    $0x1,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b24e:	0f b6 d0             	movzbl %al,%edx
    b251:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b255:	83 e0 07             	and    $0x7,%eax
    b258:	c1 e0 07             	shl    $0x7,%eax
    b25b:	09 d0                	or     %edx,%eax
    b25d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b261:	0f b6 56 02          	movzbl 0x2(%esi),%edx
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b265:	b8 14 00 00 00       	mov    $0x14,%eax
	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b26a:	c0 ea 02             	shr    $0x2,%dl
    b26d:	83 e2 01             	and    $0x1,%edx
    b270:	88 55 f0             	mov    %dl,-0x10(%ebp)
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b273:	e8 fc ff ff ff       	call   b274 <DoReceiveRARULgrant_Tbsize+0x54>
	if(rb_number<=44)
    b278:	66 83 f8 2c          	cmp    $0x2c,%ax
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b27c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	if(rb_number<=44)
    b280:	0f 86 6a 01 00 00    	jbe    b3f0 <DoReceiveRARULgrant_Tbsize+0x1d0>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b286:	84 db                	test   %bl,%bl
    b288:	0f 85 b2 00 00 00    	jne    b340 <DoReceiveRARULgrant_Tbsize+0x120>
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b28e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b292:	bb 0a 00 00 00       	mov    $0xa,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b297:	e8 fc ff ff ff       	call   b298 <DoReceiveRARULgrant_Tbsize+0x78>
    b29c:	31 d2                	xor    %edx,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b29e:	b8 01 00 00 00       	mov    $0x1,%eax
    b2a3:	b9 01 00 00 00       	mov    $0x1,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b2a8:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b2ab:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b2ad:	39 d8                	cmp    %ebx,%eax
    b2af:	76 f7                	jbe    b2a8 <DoReceiveRARULgrant_Tbsize+0x88>
    b2b1:	83 e9 01             	sub    $0x1,%ecx
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
    b2b4:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b2b8:	09 d1                	or     %edx,%ecx
    b2ba:	31 d2                	xor    %edx,%edx
    b2bc:	89 c8                	mov    %ecx,%eax
    b2be:	66 f7 75 f2          	divw   -0xe(%ebp)
    b2c2:	89 d3                	mov    %edx,%ebx
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b2c4:	89 c8                	mov    %ecx,%eax
    b2c6:	31 d2                	xor    %edx,%edx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b2c8:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b2cc:	66 f7 75 f2          	divw   -0xe(%ebp)
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b2d0:	83 c1 01             	add    $0x1,%ecx
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b2d3:	66 29 c1             	sub    %ax,%cx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b2d6:	01 c3                	add    %eax,%ebx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b2d8:	66 39 5d f2          	cmp    %bx,-0xe(%ebp)
    b2dc:	8d 50 01             	lea    0x1(%eax),%edx
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b2df:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b2e3:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b2e9:	0f 46 d1             	cmovbe %ecx,%edx
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b2ec:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if(ulDelay == true)//?????????????????????????????,delay
    b2f0:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b2f4:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
	if(ulDelay == true)//?????????????????????????????,delay
    b2fa:	0f 84 b8 00 00 00    	je     b3b8 <DoReceiveRARULgrant_Tbsize+0x198>
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b300:	66 83 f8 01          	cmp    $0x1,%ax
    b304:	76 19                	jbe    b31f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b306:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b309:	66 83 fb 04          	cmp    $0x4,%bx
    b30d:	0f 86 c5 00 00 00    	jbe    b3d8 <DoReceiveRARULgrant_Tbsize+0x1b8>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b313:	83 e8 07             	sub    $0x7,%eax
    b316:	66 83 f8 02          	cmp    $0x2,%ax
    b31a:	77 0d                	ja     b329 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b31c:	83 c1 01             	add    $0x1,%ecx
    b31f:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b323:	66 c7 47 10 07 00    	movw   $0x7,0x10(%edi)
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b329:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    b32d:	0f b7 d2             	movzwl %dx,%edx
}
    b330:	83 c4 1c             	add    $0x1c,%esp
    b333:	5b                   	pop    %ebx
    b334:	5e                   	pop    %esi
    b335:	5f                   	pop    %edi
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b336:	6b c0 54             	imul   $0x54,%eax,%eax
}
    b339:	5d                   	pop    %ebp
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b33a:	0f af c2             	imul   %edx,%eax
}
    b33d:	c3                   	ret    
    b33e:	66 90                	xchg   %ax,%ax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b340:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b345:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b349:	19 c9                	sbb    %ecx,%ecx
    b34b:	f7 d1                	not    %ecx
    b34d:	83 c1 09             	add    $0x9,%ecx
    b350:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
    b355:	89 cb                	mov    %ecx,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b357:	89 4d d8             	mov    %ecx,-0x28(%ebp)
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b35a:	19 f6                	sbb    %esi,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b35c:	e8 fc ff ff ff       	call   b35d <DoReceiveRARULgrant_Tbsize+0x13d>
    b361:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b366:	8b 4d d8             	mov    -0x28(%ebp),%ecx
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b369:	83 c6 02             	add    $0x2,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b36c:	f7 e2                	mul    %edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b36e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b372:	c1 ea 06             	shr    $0x6,%edx
    b375:	83 ea 09             	sub    $0x9,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b378:	d3 f8                	sar    %cl,%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b37a:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b37e:	ba 01 00 00 00       	mov    $0x1,%edx
    b383:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    b387:	b8 01 00 00 00       	mov    $0x1,%eax
    b38c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b390:	83 c2 01             	add    $0x1,%edx
		powint*=num;
    b393:	01 c0                	add    %eax,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b395:	39 d6                	cmp    %edx,%esi
    b397:	73 f7                	jae    b390 <DoReceiveRARULgrant_Tbsize+0x170>
    b399:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
    b39d:	83 e8 01             	sub    $0x1,%eax
    b3a0:	66 23 45 dc          	and    -0x24(%ebp),%ax
    b3a4:	29 f2                	sub    %esi,%edx
    b3a6:	0f b7 c0             	movzwl %ax,%eax
    b3a9:	8d 4a 0a             	lea    0xa(%edx),%ecx
    b3ac:	89 c2                	mov    %eax,%edx
    b3ae:	d3 e2                	shl    %cl,%edx
    b3b0:	e9 e9 fe ff ff       	jmp    b29e <DoReceiveRARULgrant_Tbsize+0x7e>
    b3b5:	8d 76 00             	lea    0x0(%esi),%esi
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
	}
	else
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b3b8:	66 83 f8 01          	cmp    $0x1,%ax
    b3bc:	76 1d                	jbe    b3db <DoReceiveRARULgrant_Tbsize+0x1bb>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b3be:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b3c1:	66 83 fb 04          	cmp    $0x4,%bx
    b3c5:	0f 86 54 ff ff ff    	jbe    b31f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b3cb:	83 e8 07             	sub    $0x7,%eax
    b3ce:	66 83 f8 02          	cmp    $0x2,%ax
    b3d2:	0f 87 51 ff ff ff    	ja     b329 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b3d8:	83 c1 01             	add    $0x1,%ecx
    b3db:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b3df:	66 c7 47 10 02 00    	movw   $0x2,0x10(%edi)
    b3e5:	e9 3f ff ff ff       	jmp    b329 <DoReceiveRARULgrant_Tbsize+0x109>
    b3ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
    b3f0:	0f b7 c0             	movzwl %ax,%eax
    b3f3:	e8 fc ff ff ff       	call   b3f4 <DoReceiveRARULgrant_Tbsize+0x1d4>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b3f8:	b9 01 00 00 00       	mov    $0x1,%ecx
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b3fd:	66 c1 e8 03          	shr    $0x3,%ax
    b401:	0f b7 d0             	movzwl %ax,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b404:	b8 01 00 00 00       	mov    $0x1,%eax
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b409:	69 d2 c5 20 00 00    	imul   $0x20c5,%edx,%edx
    b40f:	c1 ea 14             	shr    $0x14,%edx
    b412:	83 c2 01             	add    $0x1,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b415:	0f b7 d2             	movzwl %dx,%edx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b418:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b41b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b41d:	39 c2                	cmp    %eax,%edx
    b41f:	73 f7                	jae    b418 <DoReceiveRARULgrant_Tbsize+0x1f8>
    b421:	83 e9 01             	sub    $0x1,%ecx
    b424:	31 d2                	xor    %edx,%edx
    b426:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b42a:	89 c8                	mov    %ecx,%eax
    b42c:	66 f7 75 f2          	divw   -0xe(%ebp)
    b430:	89 d3                	mov    %edx,%ebx
    b432:	e9 8d fe ff ff       	jmp    b2c4 <DoReceiveRARULgrant_Tbsize+0xa4>
    b437:	90                   	nop
    b438:	90                   	nop
    b439:	90                   	nop
    b43a:	90                   	nop
    b43b:	90                   	nop
    b43c:	90                   	nop
    b43d:	90                   	nop
    b43e:	90                   	nop
    b43f:	90                   	nop

0000b440 <creat_subhead.isra.0>:
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b440:	55                   	push   %ebp
    b441:	89 e5                	mov    %esp,%ebp
    b443:	83 ec 10             	sub    $0x10,%esp
    b446:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b449:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b44c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b44f:	e8 fc ff ff ff       	call   b450 <creat_subhead.isra.0+0x10>
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b454:	83 38 7f             	cmpl   $0x7f,(%eax)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b457:	8b 75 0c             	mov    0xc(%ebp),%esi
    b45a:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
    b45e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b461:	76 3d                	jbe    b4a0 <creat_subhead.isra.0+0x60>
		*data += 2;
		//fsm_printf("the data is %d\n",  *data);
	}
	else
	{
		subfif= (MRLC_subHead_fif_IciMsg *)*ptr;
    b463:	8b 1a                	mov    (%edx),%ebx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
    b465:	83 e7 1f             	and    $0x1f,%edi
    b468:	83 cf 20             	or     $0x20,%edi
    b46b:	89 f9                	mov    %edi,%ecx
    b46d:	88 0b                	mov    %cl,(%ebx)
		subfif->fandl1 = skb->len>>8;
    b46f:	8b 38                	mov    (%eax),%edi
    b471:	c1 ef 08             	shr    $0x8,%edi
		subfif->fandl1 |= 0x80;
    b474:	83 cf 80             	or     $0xffffff80,%edi
    b477:	89 f9                	mov    %edi,%ecx
    b479:	88 4b 01             	mov    %cl,0x1(%ebx)
		subfif->fandl2 = skb->len&0xff;
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b47c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
		subfif->fandl1 = skb->len>>8;
		subfif->fandl1 |= 0x80;
		subfif->fandl2 = skb->len&0xff;
    b47f:	8b 00                	mov    (%eax),%eax
    b481:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b484:	89 19                	mov    %ebx,(%ecx)
		*ptr = subfif + 1;
    b486:	83 c3 03             	add    $0x3,%ebx
    b489:	89 1a                	mov    %ebx,(%edx)
		*data += 3;
    b48b:	83 06 03             	addl   $0x3,(%esi)
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b48e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b491:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b494:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b497:	89 ec                	mov    %ebp,%esp
    b499:	5d                   	pop    %ebp
    b49a:	c3                   	ret    
    b49b:	90                   	nop
    b49c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
	{
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
    b4a0:	8b 0a                	mov    (%edx),%ecx
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
    b4a2:	83 e7 1f             	and    $0x1f,%edi
    b4a5:	83 cf 20             	or     $0x20,%edi
    b4a8:	89 fb                	mov    %edi,%ebx
    b4aa:	88 19                	mov    %bl,(%ecx)
		subsev->fandl = skb->len;
    b4ac:	8b 00                	mov    (%eax),%eax
		subsev->fandl  &= 0x7f;
		*preptr = subsev;
		*ptr = subsev+1;
    b4ae:	8d 59 02             	lea    0x2(%ecx),%ebx
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
		subsev->fandl = skb->len;
		subsev->fandl  &= 0x7f;
    b4b1:	83 e0 7f             	and    $0x7f,%eax
    b4b4:	88 41 01             	mov    %al,0x1(%ecx)
		*preptr = subsev;
    b4b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b4ba:	89 08                	mov    %ecx,(%eax)
		*ptr = subsev+1;
    b4bc:	89 1a                	mov    %ebx,(%edx)
		*data += 2;
    b4be:	83 06 02             	addl   $0x2,(%esi)
		*preptr = subfif;
		*ptr = subfif + 1;
		*data += 3;
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b4c1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b4c4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b4c7:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b4ca:	89 ec                	mov    %ebp,%esp
    b4cc:	5d                   	pop    %ebp
    b4cd:	c3                   	ret    
    b4ce:	66 90                	xchg   %ax,%ax

0000b4d0 <PCRLC_CONFIG_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_CONFIG_REQ(void)
{
    b4d0:	55                   	push   %ebp
    b4d1:	89 e5                	mov    %esp,%ebp
    b4d3:	56                   	push   %esi
    b4d4:	53                   	push   %ebx
    b4d5:	83 ec 10             	sub    $0x10,%esp
    b4d8:	e8 fc ff ff ff       	call   b4d9 <PCRLC_CONFIG_REQ+0x9>
	CRLC_ReConfigReq_IoctrlMsg *cIoctrl = (CRLC_ReConfigReq_IoctrlMsg*)fsm_data_get();
    b4dd:	e8 fc ff ff ff       	call   b4de <PCRLC_CONFIG_REQ+0xe>
    b4e2:	89 c3                	mov    %eax,%ebx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b4e4:	e8 fc ff ff ff       	call   b4e5 <PCRLC_CONFIG_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b4e9:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b4ec:	89 c6                	mov    %eax,%esi
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b4ee:	0f b6 03             	movzbl (%ebx),%eax
    b4f1:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    b4f7:	89 14 24             	mov    %edx,(%esp)
    b4fa:	8d 55 f0             	lea    -0x10(%ebp),%edx
    b4fd:	e8 fc ff ff ff       	call   b4fe <PCRLC_CONFIG_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
    b502:	c7 04 24 10 2b 00 00 	movl   $0x2b10,(%esp)
    b509:	e8 fc ff ff ff       	call   b50a <PCRLC_CONFIG_REQ+0x3a>
	switch(cIoctrl->Mode)
    b50e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
    b512:	66 83 f8 02          	cmp    $0x2,%ax
    b516:	0f 84 b4 00 00 00    	je     b5d0 <PCRLC_CONFIG_REQ+0x100>
    b51c:	77 2a                	ja     b548 <PCRLC_CONFIG_REQ+0x78>
    b51e:	66 83 f8 01          	cmp    $0x1,%ax
    b522:	0f 84 e0 00 00 00    	je     b608 <PCRLC_CONFIG_REQ+0x138>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
		}
		break;

	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
    b528:	c7 04 24 70 2d 00 00 	movl   $0x2d70,(%esp)
    b52f:	e8 fc ff ff ff       	call   b530 <PCRLC_CONFIG_REQ+0x60>
		break;

	}
	fsm_data_destroy(cIoctrl);
    b534:	89 d8                	mov    %ebx,%eax
    b536:	e8 fc ff ff ff       	call   b537 <PCRLC_CONFIG_REQ+0x67>
	cIoctrl = NULL;
	FOUT;
}
    b53b:	83 c4 10             	add    $0x10,%esp
    b53e:	5b                   	pop    %ebx
    b53f:	5e                   	pop    %esi
    b540:	5d                   	pop    %ebp
    b541:	c3                   	ret    
    b542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
    b548:	66 83 f8 03          	cmp    $0x3,%ax
    b54c:	74 4a                	je     b598 <PCRLC_CONFIG_REQ+0xc8>
    b54e:	66 83 f8 04          	cmp    $0x4,%ax
    b552:	75 d4                	jne    b528 <PCRLC_CONFIG_REQ+0x58>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
		}
		break;

	case UM_DOWN:			//UM
		if(SV(ins_mode) == UM_MODE)
    b554:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b55b:	0f 85 3f 01 00 00    	jne    b6a0 <PCRLC_CONFIG_REQ+0x1d0>
		{
			if(insptrd == NULL)
    b561:	8b 75 f4             	mov    -0xc(%ebp),%esi
    b564:	85 f6                	test   %esi,%esi
    b566:	74 cc                	je     b534 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b568:	0f b6 03             	movzbl (%ebx),%eax
    b56b:	c7 04 24 34 2c 00 00 	movl   $0x2c34,(%esp)
    b572:	89 44 24 04          	mov    %eax,0x4(%esp)
    b576:	e8 fc ff ff ff       	call   b577 <PCRLC_CONFIG_REQ+0xa7>
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b57b:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
    b57f:	66 89 46 06          	mov    %ax,0x6(%esi)
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
    b583:	8b 43 08             	mov    0x8(%ebx),%eax
    b586:	89 46 10             	mov    %eax,0x10(%esi)
	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
		break;

	}
	fsm_data_destroy(cIoctrl);
    b589:	89 d8                	mov    %ebx,%eax
    b58b:	e8 fc ff ff ff       	call   b58c <PCRLC_CONFIG_REQ+0xbc>
	cIoctrl = NULL;
	FOUT;
}
    b590:	83 c4 10             	add    $0x10,%esp
    b593:	5b                   	pop    %ebx
    b594:	5e                   	pop    %esi
    b595:	5d                   	pop    %ebp
    b596:	c3                   	ret    
    b597:	90                   	nop
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
		}
		break;

	case UM_UP:			//UM
		if(SV(ins_mode) ==  UM_MODE)
    b598:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b59f:	0f 85 e3 00 00 00    	jne    b688 <PCRLC_CONFIG_REQ+0x1b8>
		{
			if(insptru == NULL)
    b5a5:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b5a8:	85 f6                	test   %esi,%esi
    b5aa:	74 88                	je     b534 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b5ac:	0f b6 03             	movzbl (%ebx),%eax
    b5af:	c7 04 24 e0 2b 00 00 	movl   $0x2be0,(%esp)
    b5b6:	89 44 24 04          	mov    %eax,0x4(%esp)
    b5ba:	e8 fc ff ff ff       	call   b5bb <PCRLC_CONFIG_REQ+0xeb>
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b5bf:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b5c3:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b5c7:	e9 68 ff ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b5cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
		}
		break;

	case UM_UPDOWN:              	 //UM
		if(SV(ins_mode) == UM_MODE)
    b5d0:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b5d7:	0f 85 93 00 00 00    	jne    b670 <PCRLC_CONFIG_REQ+0x1a0>
		{
			if(insptru != NULL)
    b5dd:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b5e0:	85 f6                	test   %esi,%esi
    b5e2:	0f 84 79 ff ff ff    	je     b561 <PCRLC_CONFIG_REQ+0x91>
			{
				umTxIns = (UM_TX_Instance *)insptru;
				fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b5e8:	0f b6 03             	movzbl (%ebx),%eax
    b5eb:	c7 04 24 e0 2b 00 00 	movl   $0x2be0,(%esp)
    b5f2:	89 44 24 04          	mov    %eax,0x4(%esp)
    b5f6:	e8 fc ff ff ff       	call   b5f7 <PCRLC_CONFIG_REQ+0x127>
				umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b5fb:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b5ff:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b603:	e9 59 ff ff ff       	jmp    b561 <PCRLC_CONFIG_REQ+0x91>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		if(SV(ins_mode) == AM_MODE)
    b608:	83 be 18 02 00 00 03 	cmpl   $0x3,0x218(%esi)
    b60f:	0f 85 a3 00 00 00    	jne    b6b8 <PCRLC_CONFIG_REQ+0x1e8>
		{
			if(insptru == NULL)
    b615:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b618:	85 f6                	test   %esi,%esi
    b61a:	0f 84 14 ff ff ff    	je     b534 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			amIns = (AM_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:am instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b620:	0f b6 03             	movzbl (%ebx),%eax
    b623:	c7 04 24 44 2b 00 00 	movl   $0x2b44,(%esp)
    b62a:	89 44 24 04          	mov    %eax,0x4(%esp)
    b62e:	e8 fc ff ff ff       	call   b62f <PCRLC_CONFIG_REQ+0x15f>
			amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
    b633:	8b 43 14             	mov    0x14(%ebx),%eax
    b636:	89 46 1c             	mov    %eax,0x1c(%esi)
			amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
    b639:	8b 43 10             	mov    0x10(%ebx),%eax
    b63c:	89 46 28             	mov    %eax,0x28(%esi)
			amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
    b63f:	8b 43 18             	mov    0x18(%ebx),%eax
    b642:	89 46 10             	mov    %eax,0x10(%esi)
			amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    b645:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
    b649:	66 89 86 f6 22 00 00 	mov    %ax,0x22f6(%esi)
			amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    b650:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
    b654:	66 89 86 f8 22 00 00 	mov    %ax,0x22f8(%esi)
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    b65b:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
    b65f:	66 89 86 fa 22 00 00 	mov    %ax,0x22fa(%esi)
			break;
    b666:	e9 c9 fe ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b66b:	90                   	nop
    b66c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
    b670:	c7 04 24 88 2c 00 00 	movl   $0x2c88,(%esp)
    b677:	e8 fc ff ff ff       	call   b678 <PCRLC_CONFIG_REQ+0x1a8>
    b67c:	e9 b3 fe ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b681:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
    b688:	c7 04 24 d4 2c 00 00 	movl   $0x2cd4,(%esp)
    b68f:	e8 fc ff ff ff       	call   b690 <PCRLC_CONFIG_REQ+0x1c0>
    b694:	e9 9b fe ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b699:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
    b6a0:	c7 04 24 20 2d 00 00 	movl   $0x2d20,(%esp)
    b6a7:	e8 fc ff ff ff       	call   b6a8 <PCRLC_CONFIG_REQ+0x1d8>
    b6ac:	e9 83 fe ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b6b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
			break;
		}
		else
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
    b6b8:	c7 04 24 94 2b 00 00 	movl   $0x2b94,(%esp)
    b6bf:	e8 fc ff ff ff       	call   b6c0 <PCRLC_CONFIG_REQ+0x1f0>
		}
		break;
    b6c4:	e9 6b fe ff ff       	jmp    b534 <PCRLC_CONFIG_REQ+0x64>
    b6c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000b6d0 <PCRLC_BULID_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_BULID_REQ(void)
{
    b6d0:	55                   	push   %ebp
    b6d1:	89 e5                	mov    %esp,%ebp
    b6d3:	57                   	push   %edi
    b6d4:	56                   	push   %esi
    b6d5:	53                   	push   %ebx
    b6d6:	83 ec 0c             	sub    $0xc,%esp
    b6d9:	e8 fc ff ff ff       	call   b6da <PCRLC_BULID_REQ+0xa>
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
	
	SV_PTR_GET(rlc_mac_sv);
    b6de:	e8 fc ff ff ff       	call   b6df <PCRLC_BULID_REQ+0xf>
    b6e3:	89 c6                	mov    %eax,%esi
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
    b6e5:	c7 04 24 a0 2d 00 00 	movl   $0x2da0,(%esp)
    b6ec:	e8 fc ff ff ff       	call   b6ed <PCRLC_BULID_REQ+0x1d>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
    b6f1:	e8 fc ff ff ff       	call   b6f2 <PCRLC_BULID_REQ+0x22>
    b6f6:	89 c7                	mov    %eax,%edi
	switch(cIoctrl->Mode)
    b6f8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b6fc:	66 83 f8 02          	cmp    $0x2,%ax
    b700:	0f 84 e2 01 00 00    	je     b8e8 <PCRLC_BULID_REQ+0x218>
    b706:	77 38                	ja     b740 <PCRLC_BULID_REQ+0x70>
    b708:	66 83 f8 01          	cmp    $0x1,%ax
    b70c:	0f 84 4f 03 00 00    	je     ba61 <PCRLC_BULID_REQ+0x391>
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
		break;

	default:
		fsm_printf("[RLC][PCRLC_BULID_REQ] wrong CRLC_BULID_REQ");
    b712:	c7 04 24 cc 2f 00 00 	movl   $0x2fcc,(%esp)
    b719:	e8 fc ff ff ff       	call   b71a <PCRLC_BULID_REQ+0x4a>
		break;

	}
	
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    b71e:	b8 01 00 00 00       	mov    $0x1,%eax
    b723:	e8 fc ff ff ff       	call   b724 <PCRLC_BULID_REQ+0x54>
	cItrl->V_Flag = true;
    b728:	c6 00 01             	movb   $0x1,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    b72b:	e8 fc ff ff ff       	call   b72c <PCRLC_BULID_REQ+0x5c>
	cItrl = NULL;
	fsm_data_destroy(cIoctrl);
    b730:	89 f8                	mov    %edi,%eax
    b732:	e8 fc ff ff ff       	call   b733 <PCRLC_BULID_REQ+0x63>
	cIoctrl = NULL;
	FOUT;
}
    b737:	83 c4 0c             	add    $0xc,%esp
    b73a:	5b                   	pop    %ebx
    b73b:	5e                   	pop    %esi
    b73c:	5f                   	pop    %edi
    b73d:	5d                   	pop    %ebp
    b73e:	c3                   	ret    
    b73f:	90                   	nop
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
    b740:	66 83 f8 03          	cmp    $0x3,%ax
    b744:	0f 84 22 01 00 00    	je     b86c <PCRLC_BULID_REQ+0x19c>
    b74a:	66 83 f8 04          	cmp    $0x4,%ax
    b74e:	75 c2                	jne    b712 <PCRLC_BULID_REQ+0x42>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    b750:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    b755:	e8 fc ff ff ff       	call   b756 <PCRLC_BULID_REQ+0x86>
    b75a:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b75c:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    b760:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b764:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    b768:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b76f:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    b772:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    b776:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    b779:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b77c:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    b783:	00 00 
    b785:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    b78c:	00 00 
    b78e:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    b795:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    b797:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    b79a:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b79c:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    b7a2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    b7a9:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    b7b0:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    b7b6:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    b7bc:	eb 0d                	jmp    b7cb <PCRLC_BULID_REQ+0xfb>
    b7be:	66 90                	xchg   %ax,%ax
    b7c0:	83 fa 32             	cmp    $0x32,%edx
    b7c3:	0f 84 52 05 00 00    	je     bd1b <PCRLC_BULID_REQ+0x64b>
    b7c9:	89 d0                	mov    %edx,%eax
    b7cb:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    b7d2:	ff 
    b7d3:	8d 50 01             	lea    0x1(%eax),%edx
    b7d6:	74 e8                	je     b7c0 <PCRLC_BULID_REQ+0xf0>
		if(i >= MAX_CODE) 
    b7d8:	83 fa 32             	cmp    $0x32,%edx
    b7db:	0f 84 3a 05 00 00    	je     bd1b <PCRLC_BULID_REQ+0x64b>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    b7e1:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    b7e4:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    b7eb:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    b7ef:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b7f2:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    b7f5:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b7f8:	31 c0                	xor    %eax,%eax
    b7fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    b800:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    b807:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b808:	83 c0 01             	add    $0x1,%eax
    b80b:	83 f8 20             	cmp    $0x20,%eax
    b80e:	75 f0                	jne    b800 <PCRLC_BULID_REQ+0x130>
    b810:	30 c0                	xor    %al,%al
    b812:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    b818:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    b81f:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    b823:	83 c0 01             	add    $0x1,%eax
    b826:	3d 00 04 00 00       	cmp    $0x400,%eax
    b82b:	75 eb                	jne    b818 <PCRLC_BULID_REQ+0x148>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b82d:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    b833:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b839:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    b83f:	81 c6 c0 36 00 00    	add    $0x36c0,%esi
    b845:	89 b3 c4 10 00 00    	mov    %esi,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    b84b:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    b851:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
    b853:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    b857:	c7 04 24 74 2f 00 00 	movl   $0x2f74,(%esp)
    b85e:	89 44 24 04          	mov    %eax,0x4(%esp)
    b862:	e8 fc ff ff ff       	call   b863 <PCRLC_BULID_REQ+0x193>
		break;
    b867:	e9 b2 fe ff ff       	jmp    b71e <PCRLC_BULID_REQ+0x4e>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
    b86c:	b8 38 00 00 00       	mov    $0x38,%eax
    b871:	e8 fc ff ff ff       	call   b872 <PCRLC_BULID_REQ+0x1a2>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b876:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    b87a:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    b87e:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    b882:	8d 48 30             	lea    0x30(%eax),%ecx
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    b885:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    b888:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    b88b:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    b88f:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    b895:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    b89c:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    b89f:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    b8a2:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b8a9:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    b8ac:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b8af:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b8b5:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    b8bb:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    b8c1:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    b8c4:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    b8c7:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
    b8c9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    b8cd:	c7 04 24 1c 2f 00 00 	movl   $0x2f1c,(%esp)
    b8d4:	89 44 24 04          	mov    %eax,0x4(%esp)
    b8d8:	e8 fc ff ff ff       	call   b8d9 <PCRLC_BULID_REQ+0x209>
		break;
    b8dd:	e9 3c fe ff ff       	jmp    b71e <PCRLC_BULID_REQ+0x4e>
    b8e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    b8e8:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    b8ed:	e8 fc ff ff ff       	call   b8ee <PCRLC_BULID_REQ+0x21e>
    b8f2:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b8f4:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    b8f8:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b8fc:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    b900:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b907:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    b90a:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    b90e:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    b911:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b914:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    b91b:	00 00 
    b91d:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    b924:	00 00 
    b926:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    b92d:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    b92f:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    b932:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b934:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    b93a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    b941:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    b948:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    b94e:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    b954:	eb 0d                	jmp    b963 <PCRLC_BULID_REQ+0x293>
    b956:	66 90                	xchg   %ax,%ax
    b958:	83 fa 32             	cmp    $0x32,%edx
    b95b:	0f 84 a9 03 00 00    	je     bd0a <PCRLC_BULID_REQ+0x63a>
    b961:	89 d0                	mov    %edx,%eax
    b963:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    b96a:	ff 
    b96b:	8d 50 01             	lea    0x1(%eax),%edx
    b96e:	74 e8                	je     b958 <PCRLC_BULID_REQ+0x288>
		if(i >= MAX_CODE) 
    b970:	83 fa 32             	cmp    $0x32,%edx
    b973:	0f 84 91 03 00 00    	je     bd0a <PCRLC_BULID_REQ+0x63a>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    b979:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    b97c:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    b983:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    b987:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b98a:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    b98d:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b990:	31 c0                	xor    %eax,%eax
    b992:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    b998:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    b99f:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b9a0:	83 c0 01             	add    $0x1,%eax
    b9a3:	83 f8 20             	cmp    $0x20,%eax
    b9a6:	75 f0                	jne    b998 <PCRLC_BULID_REQ+0x2c8>
    b9a8:	30 c0                	xor    %al,%al
    b9aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    b9b0:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    b9b7:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    b9bb:	83 c0 01             	add    $0x1,%eax
    b9be:	3d 00 04 00 00       	cmp    $0x400,%eax
    b9c3:	75 eb                	jne    b9b0 <PCRLC_BULID_REQ+0x2e0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b9c5:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    b9cb:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
    b9d1:	8d 8e c0 36 00 00    	lea    0x36c0(%esi),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b9d7:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    b9dd:	89 8b c4 10 00 00    	mov    %ecx,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    b9e3:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    b9e9:	89 10                	mov    %edx,(%eax)
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
    b9eb:	b8 38 00 00 00       	mov    $0x38,%eax
    b9f0:	e8 fc ff ff ff       	call   b9f1 <PCRLC_BULID_REQ+0x321>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b9f5:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    b9f9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    b9fd:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    ba01:	8d 48 30             	lea    0x30(%eax),%ecx
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    ba04:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba07:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    ba0a:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    ba0e:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    ba14:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba1b:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    ba1e:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    ba21:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ba28:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    ba2b:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ba2e:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ba34:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    ba3a:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    ba40:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    ba43:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    ba46:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
    ba48:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    ba4c:	c7 04 24 bc 2e 00 00 	movl   $0x2ebc,(%esp)
    ba53:	89 44 24 04          	mov    %eax,0x4(%esp)
    ba57:	e8 fc ff ff ff       	call   ba58 <PCRLC_BULID_REQ+0x388>
		break;
    ba5c:	e9 bd fc ff ff       	jmp    b71e <PCRLC_BULID_REQ+0x4e>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		amIns =  instance_create(struct AM_Instance);
    ba61:	b8 0c 23 00 00       	mov    $0x230c,%eax
    ba66:	e8 fc ff ff ff       	call   ba67 <PCRLC_BULID_REQ+0x397>
    ba6b:	89 c3                	mov    %eax,%ebx
		amIns->rbId = cIoctrl->rbIdentity;
    ba6d:	0f b6 07             	movzbl (%edi),%eax
    ba70:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
    ba73:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    ba77:	88 43 03             	mov    %al,0x3(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
    ba7a:	0f b6 c0             	movzbl %al,%eax
    ba7d:	89 44 24 04          	mov    %eax,0x4(%esp)
    ba81:	c7 04 24 d4 2d 00 00 	movl   $0x2dd4,(%esp)
    ba88:	e8 fc ff ff ff       	call   ba89 <PCRLC_BULID_REQ+0x3b9>
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    ba8d:	31 d2                	xor    %edx,%edx
		amIns =  instance_create(struct AM_Instance);
		amIns->rbId = cIoctrl->rbIdentity;
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
    ba8f:	6b 47 14 64          	imul   $0x64,0x14(%edi),%eax
    ba93:	89 43 1c             	mov    %eax,0x1c(%ebx)
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
    ba96:	6b 47 10 64          	imul   $0x64,0x10(%edi),%eax
    ba9a:	89 43 28             	mov    %eax,0x28(%ebx)
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
    ba9d:	6b 47 18 64          	imul   $0x64,0x18(%edi),%eax
    baa1:	89 43 10             	mov    %eax,0x10(%ebx)
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    baa4:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
    baa8:	66 89 83 f6 22 00 00 	mov    %ax,0x22f6(%ebx)
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    baaf:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
    bab3:	66 89 83 f8 22 00 00 	mov    %ax,0x22f8(%ebx)
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    baba:	0f b7 47 20          	movzwl 0x20(%edi),%eax
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    babe:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%ebx)
    bac5:	00 00 00 
    bac8:	c7 83 b8 01 00 00 00 	movl   $0x0,0x1b8(%ebx)
    bacf:	00 00 00 
    bad2:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bad9:	66 89 83 fa 22 00 00 	mov    %ax,0x22fa(%ebx)
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bae0:	c7 83 a4 01 00 00 00 	movl   $0x0,0x1a4(%ebx)
    bae7:	00 00 00 
		amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = amIns->amTransmittedBufferNum = 0;
    baea:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
    baf1:	00 00 00 
    baf4:	c7 83 bc 01 00 00 00 	movl   $0x0,0x1bc(%ebx)
    bafb:	00 00 00 
    bafe:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
    bb05:	c7 83 a8 01 00 00 00 	movl   $0x0,0x1a8(%ebx)
    bb0c:	00 00 00 
		amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
    bb0f:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    bb16:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    bb1d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		amIns->currentStatVar = ST_TRAN;
    bb24:	66 c7 43 2c 08 00    	movw   $0x8,0x2c(%ebx)
		amIns->pduLft.sduLeft = NULL;
    bb2a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
		amIns->pduLft.SN_Left = -1;
    bb31:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
		amIns->pduLft.SN5_Left = -1;
    bb37:	66 c7 43 30 ff ff    	movw   $0xffff,0x30(%ebx)
		//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
		//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    bb3d:	eb 0c                	jmp    bb4b <PCRLC_BULID_REQ+0x47b>
    bb3f:	90                   	nop
    bb40:	83 f8 32             	cmp    $0x32,%eax
    bb43:	0f 84 ab 01 00 00    	je     bcf4 <PCRLC_BULID_REQ+0x624>
    bb49:	89 c2                	mov    %eax,%edx
    bb4b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bb52:	ff 
    bb53:	8d 42 01             	lea    0x1(%edx),%eax
    bb56:	74 e8                	je     bb40 <PCRLC_BULID_REQ+0x470>
		if(i >= MAX_CODE) 
    bb58:	83 f8 32             	cmp    $0x32,%eax
    bb5b:	0f 84 93 01 00 00    	je     bcf4 <PCRLC_BULID_REQ+0x624>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->pollRetxTimerCode = i - 1;
    bb61:	89 53 0c             	mov    %edx,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bb64:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bb6b:	ff ff ff ff 
    bb6f:	eb 09                	jmp    bb7a <PCRLC_BULID_REQ+0x4aa>
    bb71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bb78:	89 d0                	mov    %edx,%eax
    bb7a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bb81:	ff 
    bb82:	8d 50 01             	lea    0x1(%eax),%edx
    bb85:	0f 85 a1 01 00 00    	jne    bd2c <PCRLC_BULID_REQ+0x65c>
    bb8b:	83 fa 31             	cmp    $0x31,%edx
    bb8e:	7e e8                	jle    bb78 <PCRLC_BULID_REQ+0x4a8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bb90:	89 55 f0             	mov    %edx,-0x10(%ebp)
    bb93:	c7 04 24 0c 2e 00 00 	movl   $0x2e0c,(%esp)
    bb9a:	e8 fc ff ff ff       	call   bb9b <PCRLC_BULID_REQ+0x4cb>
    bb9f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bba2:	eb 06                	jmp    bbaa <PCRLC_BULID_REQ+0x4da>
    bba4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		else
		{
			amIns->reorderTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bba8:	89 c2                	mov    %eax,%edx
    bbaa:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bbb1:	ff 
    bbb2:	8d 42 01             	lea    0x1(%edx),%eax
    bbb5:	0f 85 8d 01 00 00    	jne    bd48 <PCRLC_BULID_REQ+0x678>
    bbbb:	83 f8 31             	cmp    $0x31,%eax
    bbbe:	7e e8                	jle    bba8 <PCRLC_BULID_REQ+0x4d8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bbc0:	c7 04 24 0c 2e 00 00 	movl   $0x2e0c,(%esp)
    bbc7:	e8 fc ff ff ff       	call   bbc8 <PCRLC_BULID_REQ+0x4f8>
		else
		{
			amIns->statProhTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
    bbcc:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
    bbd3:	00 00 
    bbd5:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
    bbdc:	00 00 
    bbde:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
    bbe5:	00 00 
    bbe7:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
    bbee:	00 00 
    bbf0:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
    bbf7:	00 00 
    bbf9:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
    bc00:	00 00 
		amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
    bc02:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
    bc09:	00 02 
    bc0b:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
    bc12:	00 02 
		amIns->SN = 0;
    bc14:	66 c7 43 2e 00 00    	movw   $0x0,0x2e(%ebx)
		amIns->statFlag = false;
    bc1a:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] init SN is %d\n",amIns->SN);
    bc1e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    bc25:	00 
    bc26:	c7 04 24 40 2e 00 00 	movl   $0x2e40,(%esp)
    bc2d:	e8 fc ff ff ff       	call   bc2e <PCRLC_BULID_REQ+0x55e>
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
    bc32:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc35:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
    bc38:	89 43 48             	mov    %eax,0x48(%ebx)
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
    bc3b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc41:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
    bc47:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
    bc4d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc53:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
    bc59:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
    bc5f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc65:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
    bc6b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
    bc71:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc77:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
    bc7d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
		for(i = 0;  i < 1024; ++i )
    bc83:	31 c0                	xor    %eax,%eax
    bc85:	8d 76 00             	lea    0x0(%esi),%esi
		{
			amIns->amRecvWindow[i] = NULL;
    bc88:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
    bc8f:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
    bc93:	83 c0 01             	add    $0x1,%eax
    bc96:	3d 00 04 00 00       	cmp    $0x400,%eax
    bc9b:	75 eb                	jne    bc88 <PCRLC_BULID_REQ+0x5b8>
    bc9d:	66 31 c0             	xor    %ax,%ax
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amTranWindow[i]= NULL;
    bca0:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
    bca7:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
    bcab:	83 c0 01             	add    $0x1,%eax
    bcae:	3d 00 04 00 00       	cmp    $0x400,%eax
    bcb3:	75 eb                	jne    bca0 <PCRLC_BULID_REQ+0x5d0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bcb5:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		{
			amIns->amTranWindow[i]= NULL;
		}
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
    bcbb:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bcc1:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
    bcc7:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
    bccd:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
    bcd3:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
    bcd9:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
    bcdb:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    bcdf:	c7 04 24 68 2e 00 00 	movl   $0x2e68,(%esp)
    bce6:	89 44 24 04          	mov    %eax,0x4(%esp)
    bcea:	e8 fc ff ff ff       	call   bceb <PCRLC_BULID_REQ+0x61b>
		break;
    bcef:	e9 2a fa ff ff       	jmp    b71e <PCRLC_BULID_REQ+0x4e>
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bcf4:	c7 04 24 0c 2e 00 00 	movl   $0x2e0c,(%esp)
    bcfb:	e8 fc ff ff ff       	call   bcfc <PCRLC_BULID_REQ+0x62c>
    bd00:	b8 32 00 00 00       	mov    $0x32,%eax
    bd05:	e9 70 fe ff ff       	jmp    bb7a <PCRLC_BULID_REQ+0x4aa>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd0a:	c7 04 24 0c 2e 00 00 	movl   $0x2e0c,(%esp)
    bd11:	e8 fc ff ff ff       	call   bd12 <PCRLC_BULID_REQ+0x642>
    bd16:	e9 6c fc ff ff       	jmp    b987 <PCRLC_BULID_REQ+0x2b7>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd1b:	c7 04 24 0c 2e 00 00 	movl   $0x2e0c,(%esp)
    bd22:	e8 fc ff ff ff       	call   bd23 <PCRLC_BULID_REQ+0x653>
    bd27:	e9 c3 fa ff ff       	jmp    b7ef <PCRLC_BULID_REQ+0x11f>
		{
			amIns->pollRetxTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bd2c:	83 fa 31             	cmp    $0x31,%edx
    bd2f:	0f 8f 5b fe ff ff    	jg     bb90 <PCRLC_BULID_REQ+0x4c0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->reorderTimerCode = i - 1;
    bd35:	89 43 18             	mov    %eax,0x18(%ebx)
			SV(allocCode[i - 1]) = -1;
    bd38:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    bd3f:	ff ff ff ff 
    bd43:	e9 62 fe ff ff       	jmp    bbaa <PCRLC_BULID_REQ+0x4da>
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bd48:	83 f8 31             	cmp    $0x31,%eax
    bd4b:	0f 8f 6f fe ff ff    	jg     bbc0 <PCRLC_BULID_REQ+0x4f0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->statProhTimerCode = i - 1;
    bd51:	89 53 24             	mov    %edx,0x24(%ebx)
			SV(allocCode[i - 1]) = -1;
    bd54:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bd5b:	ff ff ff ff 
    bd5f:	e9 68 fe ff ff       	jmp    bbcc <PCRLC_BULID_REQ+0x4fc>
    bd64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    bd6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0000bd70 <PCRLC_DEACT_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_DEACT_REQ(void)
{
    bd70:	55                   	push   %ebp
    bd71:	89 e5                	mov    %esp,%ebp
    bd73:	57                   	push   %edi
    bd74:	56                   	push   %esi
    bd75:	53                   	push   %ebx
    bd76:	83 ec 20             	sub    $0x20,%esp
    bd79:	e8 fc ff ff ff       	call   bd7a <PCRLC_DEACT_REQ+0xa>
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
    bd7e:	e8 fc ff ff ff       	call   bd7f <PCRLC_DEACT_REQ+0xf>
    bd83:	89 c3                	mov    %eax,%ebx
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    bd85:	e8 fc ff ff ff       	call   bd86 <PCRLC_DEACT_REQ+0x16>
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    bd8a:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    bd90:	8d 4d f0             	lea    -0x10(%ebp),%ecx
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    bd93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    bd96:	0f b6 00             	movzbl (%eax),%eax
    bd99:	89 14 24             	mov    %edx,(%esp)
    bd9c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    bd9f:	e8 fc ff ff ff       	call   bda0 <PCRLC_DEACT_REQ+0x30>
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
    bda4:	c7 04 24 f8 2f 00 00 	movl   $0x2ff8,(%esp)
    bdab:	e8 fc ff ff ff       	call   bdac <PCRLC_DEACT_REQ+0x3c>
	switch(SV(ins_mode))
    bdb0:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    bdb6:	83 f8 02             	cmp    $0x2,%eax
    bdb9:	74 3d                	je     bdf8 <PCRLC_DEACT_REQ+0x88>
    bdbb:	83 f8 03             	cmp    $0x3,%eax
    bdbe:	0f 84 a4 01 00 00    	je     bf68 <PCRLC_DEACT_REQ+0x1f8>
		//AM
		fsm_mem_free(amIns);
		amIns = NULL;
		break;
	default:
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:cannot distinguish the instance to distinguish.\n");
    bdc4:	c7 04 24 30 31 00 00 	movl   $0x3130,(%esp)
    bdcb:	e8 fc ff ff ff       	call   bdcc <PCRLC_DEACT_REQ+0x5c>
		break;
	}
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    bdd0:	b8 01 00 00 00       	mov    $0x1,%eax
    bdd5:	e8 fc ff ff ff       	call   bdd6 <PCRLC_DEACT_REQ+0x66>
	cItrl->V_Flag = false;
    bdda:	c6 00 00             	movb   $0x0,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    bddd:	e8 fc ff ff ff       	call   bdde <PCRLC_DEACT_REQ+0x6e>
	cItrl = NULL;
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    bde2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bde5:	e8 fc ff ff ff       	call   bde6 <PCRLC_DEACT_REQ+0x76>
	cIoctrl = NULL;

	FOUT;
}
    bdea:	83 c4 20             	add    $0x20,%esp
    bded:	5b                   	pop    %ebx
    bdee:	5e                   	pop    %esi
    bdef:	5f                   	pop    %edi
    bdf0:	5d                   	pop    %ebp
    bdf1:	c3                   	ret    
    bdf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    bdf8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bdfb:	85 d2                	test   %edx,%edx
    bdfd:	0f 84 b7 00 00 00    	je     beba <PCRLC_DEACT_REQ+0x14a>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    be03:	8b 8a c4 10 00 00    	mov    0x10c4(%edx),%ecx
    be09:	8b 82 c8 10 00 00    	mov    0x10c8(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    be0f:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
    be12:	89 08                	mov    %ecx,(%eax)
		{
			umRxIns = (UM_RX_Instance *)insptrd;
			//UM
			list_del(&umRxIns->umRxList);
			fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um recv instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    be14:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    be17:	c7 82 c4 10 00 00 00 	movl   $0x100100,0x10c4(%edx)
    be1e:	01 10 00 
	entry->prev = LIST_POISON2;
    be21:	c7 82 c8 10 00 00 00 	movl   $0x200200,0x10c8(%edx)
    be28:	02 20 00 
    be2b:	0f b6 01             	movzbl (%ecx),%eax
    be2e:	89 55 dc             	mov    %edx,-0x24(%ebp)
    be31:	c7 04 24 2c 30 00 00 	movl   $0x302c,(%esp)
    be38:	89 44 24 04          	mov    %eax,0x4(%esp)
    be3c:	e8 fc ff ff ff       	call   be3d <PCRLC_DEACT_REQ+0xcd>
			//
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    be41:	8b 55 dc             	mov    -0x24(%ebp),%edx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    be44:	8b 72 30             	mov    0x30(%edx),%esi
    be47:	8d 4a 30             	lea    0x30(%edx),%ecx
    be4a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    be4d:	39 f1                	cmp    %esi,%ecx
    be4f:	74 62                	je     beb3 <PCRLC_DEACT_REQ+0x143>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    be51:	8b 06                	mov    (%esi),%eax
    be53:	83 ee 10             	sub    $0x10,%esi
    be56:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    be59:	89 d3                	mov    %edx,%ebx
    be5b:	8d 78 f0             	lea    -0x10(%eax),%edi
    be5e:	eb 12                	jmp    be72 <PCRLC_DEACT_REQ+0x102>
    be60:	8b 47 10             	mov    0x10(%edi),%eax
    be63:	8d 4f 10             	lea    0x10(%edi),%ecx
    be66:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    be69:	8d 50 f0             	lea    -0x10(%eax),%edx
    be6c:	74 43                	je     beb1 <PCRLC_DEACT_REQ+0x141>
    be6e:	89 fe                	mov    %edi,%esi
    be70:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    be72:	8b 56 14             	mov    0x14(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    be75:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    be78:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
    be7a:	8b 55 e0             	mov    -0x20(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    be7d:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    be84:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    be8b:	8b 43 0c             	mov    0xc(%ebx),%eax
    be8e:	89 84 82 28 02 00 00 	mov    %eax,0x228(%edx,%eax,4)
					fsm_pkt_destroy(umBuffer->pkt);
    be95:	8b 06                	mov    (%esi),%eax
    be97:	e8 fc ff ff ff       	call   be98 <PCRLC_DEACT_REQ+0x128>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    be9c:	89 f0                	mov    %esi,%eax
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    be9e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(umBuffer);
    bea4:	e8 fc ff ff ff       	call   bea5 <PCRLC_DEACT_REQ+0x135>
					umBuffer = NULL;
					if(list_empty(&umRxIns->umRecvBuffer.list))
    bea9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    beac:	3b 4b 30             	cmp    0x30(%ebx),%ecx
    beaf:	75 af                	jne    be60 <PCRLC_DEACT_REQ+0xf0>
    beb1:	89 da                	mov    %ebx,%edx
						break;
					}
				}
			}
			//UM
			fsm_mem_free(umRxIns);
    beb3:	89 d0                	mov    %edx,%eax
    beb5:	e8 fc ff ff ff       	call   beb6 <PCRLC_DEACT_REQ+0x146>
			umRxIns = NULL;
		}
		if(insptru == NULL)
    beba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bebd:	85 c0                	test   %eax,%eax
    bebf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bec2:	0f 84 08 ff ff ff    	je     bdd0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bec8:	8b 50 30             	mov    0x30(%eax),%edx
    becb:	89 c1                	mov    %eax,%ecx
    becd:	8b 40 34             	mov    0x34(%eax),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bed0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    bed3:	89 10                	mov    %edx,(%eax)
		}
		umTxIns = (UM_TX_Instance *)insptru;

		//UM
		list_del(&umTxIns->umTxList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um tran instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    bed5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bed8:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    bedf:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    bee6:	0f b6 02             	movzbl (%edx),%eax
    bee9:	c7 04 24 84 30 00 00 	movl   $0x3084,(%esp)
    bef0:	89 44 24 04          	mov    %eax,0x4(%esp)
    bef4:	e8 fc ff ff ff       	call   bef5 <PCRLC_DEACT_REQ+0x185>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    bef9:	8b 45 e8             	mov    -0x18(%ebp),%eax
		//UM
		if(!list_empty(&umTxIns->umSduBuffer.list))
    befc:	8b 7d e8             	mov    -0x18(%ebp),%edi
    beff:	8b 58 18             	mov    0x18(%eax),%ebx
    bf02:	83 c7 18             	add    $0x18,%edi
    bf05:	39 df                	cmp    %ebx,%edi
    bf07:	74 52                	je     bf5b <PCRLC_DEACT_REQ+0x1eb>
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    bf09:	8b 03                	mov    (%ebx),%eax
    bf0b:	83 eb 10             	sub    $0x10,%ebx
    bf0e:	8d 70 f0             	lea    -0x10(%eax),%esi
    bf11:	eb 16                	jmp    bf29 <PCRLC_DEACT_REQ+0x1b9>
    bf13:	90                   	nop
    bf14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    bf18:	8b 46 10             	mov    0x10(%esi),%eax
    bf1b:	8d 4e 10             	lea    0x10(%esi),%ecx
    bf1e:	39 cf                	cmp    %ecx,%edi
    bf20:	8d 50 f0             	lea    -0x10(%eax),%edx
    bf23:	74 36                	je     bf5b <PCRLC_DEACT_REQ+0x1eb>
    bf25:	89 f3                	mov    %esi,%ebx
    bf27:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bf29:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bf2c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    bf2f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
    bf31:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bf33:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    bf3a:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    bf41:	e8 fc ff ff ff       	call   bf42 <PCRLC_DEACT_REQ+0x1d2>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    bf46:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    bf48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    bf4e:	e8 fc ff ff ff       	call   bf4f <PCRLC_DEACT_REQ+0x1df>
				umBuffer = NULL;
				if(list_empty(&umTxIns->umSduBuffer.list))
    bf53:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf56:	3b 78 18             	cmp    0x18(%eax),%edi
    bf59:	75 bd                	jne    bf18 <PCRLC_DEACT_REQ+0x1a8>
					break;
				}
			}
		}
		//UM
		fsm_mem_free(umTxIns);
    bf5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf5e:	e8 fc ff ff ff       	call   bf5f <PCRLC_DEACT_REQ+0x1ef>
		umTxIns = NULL;
		break;
    bf63:	e9 68 fe ff ff       	jmp    bdd0 <PCRLC_DEACT_REQ+0x60>
	case AM_MODE:
		amIns = (AM_Instance *)insptru;
    bf68:	8b 75 ec             	mov    -0x14(%ebp),%esi
		if(amIns == NULL)
    bf6b:	85 f6                	test   %esi,%esi
    bf6d:	0f 84 5d fe ff ff    	je     bdd0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bf73:	8b 96 04 23 00 00    	mov    0x2304(%esi),%edx
    bf79:	8b 86 08 23 00 00    	mov    0x2308(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bf7f:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    bf82:	89 10                	mov    %edx,(%eax)
		{
			break;
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    bf84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bf87:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    bf8e:	01 10 00 
	entry->prev = LIST_POISON2;
    bf91:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    bf98:	02 20 00 
    bf9b:	0f b6 02             	movzbl (%edx),%eax
    bf9e:	c7 04 24 dc 30 00 00 	movl   $0x30dc,(%esp)
    bfa5:	89 44 24 04          	mov    %eax,0x4(%esp)
    bfa9:	e8 fc ff ff ff       	call   bfaa <PCRLC_DEACT_REQ+0x23a>
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    bfae:	8b 46 0c             	mov    0xc(%esi),%eax
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    bfb1:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    bfb7:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
    bfbe:	8b 46 18             	mov    0x18(%esi),%eax
    bfc1:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
    bfc8:	8b 46 24             	mov    0x24(%esi),%eax
    bfcb:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    bfd2:	8b 9e 9c 01 00 00    	mov    0x19c(%esi),%ebx
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    bfd8:	39 da                	cmp    %ebx,%edx
    bfda:	74 77                	je     c053 <PCRLC_DEACT_REQ+0x2e3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    bfdc:	8b 03                	mov    (%ebx),%eax
    bfde:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    bfe4:	89 75 e8             	mov    %esi,-0x18(%ebp)
    bfe7:	89 d6                	mov    %edx,%esi
    bfe9:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    bfef:	eb 21                	jmp    c012 <PCRLC_DEACT_REQ+0x2a2>
    bff1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    bff8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    bffe:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c004:	39 ce                	cmp    %ecx,%esi
    c006:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c00c:	74 42                	je     c050 <PCRLC_DEACT_REQ+0x2e0>
    c00e:	89 fb                	mov    %edi,%ebx
    c010:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c012:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c018:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c01b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c01d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c01f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c026:	01 10 00 
	entry->prev = LIST_POISON2;
    c029:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c030:	02 20 00 
    c033:	e8 fc ff ff ff       	call   c034 <PCRLC_DEACT_REQ+0x2c4>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c038:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c03a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c040:	e8 fc ff ff ff       	call   c041 <PCRLC_DEACT_REQ+0x2d1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRetxBuffer.list))
    c045:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c048:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    c04e:	75 a8                	jne    bff8 <PCRLC_DEACT_REQ+0x288>
    c050:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c053:	8b 9e f0 00 00 00    	mov    0xf0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amTransmittedBuffer.list))
    c059:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    c05f:	39 da                	cmp    %ebx,%edx
    c061:	74 70                	je     c0d3 <PCRLC_DEACT_REQ+0x363>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    c063:	8b 03                	mov    (%ebx),%eax
    c065:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c06b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c06e:	89 d6                	mov    %edx,%esi
    c070:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c076:	eb 1a                	jmp    c092 <PCRLC_DEACT_REQ+0x322>
    c078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c07e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c084:	39 ce                	cmp    %ecx,%esi
    c086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c08c:	74 42                	je     c0d0 <PCRLC_DEACT_REQ+0x360>
    c08e:	89 fb                	mov    %edi,%ebx
    c090:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c092:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c098:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c09b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c09d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c09f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c0a6:	01 10 00 
	entry->prev = LIST_POISON2;
    c0a9:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c0b0:	02 20 00 
    c0b3:	e8 fc ff ff ff       	call   c0b4 <PCRLC_DEACT_REQ+0x344>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c0b8:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c0ba:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c0c0:	e8 fc ff ff ff       	call   c0c1 <PCRLC_DEACT_REQ+0x351>
				amBuffer = NULL;
				if(list_empty(&amIns->amTransmittedBuffer.list))
    c0c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c0c8:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    c0ce:	75 a8                	jne    c078 <PCRLC_DEACT_REQ+0x308>
    c0d0:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c0d3:	8b 5e 44             	mov    0x44(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amSduBuffer.list))
    c0d6:	8d 56 44             	lea    0x44(%esi),%edx
    c0d9:	39 da                	cmp    %ebx,%edx
    c0db:	74 59                	je     c136 <PCRLC_DEACT_REQ+0x3c6>
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    c0dd:	8b 03                	mov    (%ebx),%eax
    c0df:	83 eb 0c             	sub    $0xc,%ebx
    c0e2:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c0e5:	89 d6                	mov    %edx,%esi
    c0e7:	8d 78 f4             	lea    -0xc(%eax),%edi
    c0ea:	eb 15                	jmp    c101 <PCRLC_DEACT_REQ+0x391>
    c0ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c0f0:	8b 47 0c             	mov    0xc(%edi),%eax
    c0f3:	8d 4f 0c             	lea    0xc(%edi),%ecx
    c0f6:	39 ce                	cmp    %ecx,%esi
    c0f8:	8d 50 f4             	lea    -0xc(%eax),%edx
    c0fb:	74 36                	je     c133 <PCRLC_DEACT_REQ+0x3c3>
    c0fd:	89 fb                	mov    %edi,%ebx
    c0ff:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c101:	8b 53 10             	mov    0x10(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c104:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c107:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
    c109:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c10b:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    c112:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
    c119:	e8 fc ff ff ff       	call   c11a <PCRLC_DEACT_REQ+0x3aa>
				amsBuffer->pkt = NULL;
				fsm_mem_free(amsBuffer);
    c11e:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
				amsBuffer->pkt = NULL;
    c120:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amsBuffer);
    c126:	e8 fc ff ff ff       	call   c127 <PCRLC_DEACT_REQ+0x3b7>
				amsBuffer = NULL;
				if(list_empty(&amIns->amSduBuffer.list))
    c12b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c12e:	3b 70 44             	cmp    0x44(%eax),%esi
    c131:	75 bd                	jne    c0f0 <PCRLC_DEACT_REQ+0x380>
    c133:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c136:	8b 9e b0 01 00 00    	mov    0x1b0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->ctrlPduBuffer.list))
    c13c:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    c142:	39 da                	cmp    %ebx,%edx
    c144:	74 5b                	je     c1a1 <PCRLC_DEACT_REQ+0x431>
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    c146:	8b 03                	mov    (%ebx),%eax
    c148:	83 eb 04             	sub    $0x4,%ebx
    c14b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c14e:	89 d6                	mov    %edx,%esi
    c150:	8d 78 fc             	lea    -0x4(%eax),%edi
    c153:	eb 14                	jmp    c169 <PCRLC_DEACT_REQ+0x3f9>
    c155:	8d 76 00             	lea    0x0(%esi),%esi
    c158:	8b 47 04             	mov    0x4(%edi),%eax
    c15b:	8d 4f 04             	lea    0x4(%edi),%ecx
    c15e:	39 ce                	cmp    %ecx,%esi
    c160:	8d 50 fc             	lea    -0x4(%eax),%edx
    c163:	74 39                	je     c19e <PCRLC_DEACT_REQ+0x42e>
    c165:	89 fb                	mov    %edi,%ebx
    c167:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c169:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c16c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c16f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
    c171:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c173:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    c17a:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    c181:	e8 fc ff ff ff       	call   c182 <PCRLC_DEACT_REQ+0x412>
				buffer->pkt = NULL;
				fsm_mem_free(buffer);
    c186:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
				buffer->pkt = NULL;
    c188:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(buffer);
    c18e:	e8 fc ff ff ff       	call   c18f <PCRLC_DEACT_REQ+0x41f>
				buffer = NULL;
				if(list_empty(&amIns->ctrlPduBuffer.list))
    c193:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c196:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    c19c:	75 ba                	jne    c158 <PCRLC_DEACT_REQ+0x3e8>
    c19e:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c1a1:	8b 9e 5c 02 00 00    	mov    0x25c(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amRecvBuffer.list))
    c1a7:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    c1ad:	39 da                	cmp    %ebx,%edx
    c1af:	74 72                	je     c223 <PCRLC_DEACT_REQ+0x4b3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    c1b1:	8b 03                	mov    (%ebx),%eax
    c1b3:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c1b9:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c1bc:	89 d6                	mov    %edx,%esi
    c1be:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c1c4:	eb 1c                	jmp    c1e2 <PCRLC_DEACT_REQ+0x472>
    c1c6:	66 90                	xchg   %ax,%ax
    c1c8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c1ce:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c1d4:	39 ce                	cmp    %ecx,%esi
    c1d6:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c1dc:	74 42                	je     c220 <PCRLC_DEACT_REQ+0x4b0>
    c1de:	89 fb                	mov    %edi,%ebx
    c1e0:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c1e2:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c1e8:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c1eb:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c1ed:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c1ef:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c1f6:	01 10 00 
	entry->prev = LIST_POISON2;
    c1f9:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c200:	02 20 00 
    c203:	e8 fc ff ff ff       	call   c204 <PCRLC_DEACT_REQ+0x494>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c208:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c20a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c210:	e8 fc ff ff ff       	call   c211 <PCRLC_DEACT_REQ+0x4a1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRecvBuffer.list))
    c215:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c218:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    c21e:	75 a8                	jne    c1c8 <PCRLC_DEACT_REQ+0x458>
    c220:	8b 75 e8             	mov    -0x18(%ebp),%esi
					break;
				}
			}
		}
		//AM
		fsm_mem_free(amIns);
    c223:	89 f0                	mov    %esi,%eax
    c225:	e8 fc ff ff ff       	call   c226 <PCRLC_DEACT_REQ+0x4b6>
		amIns = NULL;
		break;
    c22a:	e9 a1 fb ff ff       	jmp    bdd0 <PCRLC_DEACT_REQ+0x60>
    c22f:	90                   	nop

0000c230 <PCRLC_SUSPEND_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_SUSPEND_REQ(void)
{
    c230:	55                   	push   %ebp
    c231:	89 e5                	mov    %esp,%ebp
    c233:	56                   	push   %esi
    c234:	53                   	push   %ebx
    c235:	83 ec 14             	sub    $0x14,%esp
    c238:	e8 fc ff ff ff       	call   c239 <PCRLC_SUSPEND_REQ+0x9>
	CRLC_SuspendReq_IoctrlMsg *cIoctrl = (CRLC_SuspendReq_IoctrlMsg*) fsm_data_get();
    c23d:	e8 fc ff ff ff       	call   c23e <PCRLC_SUSPEND_REQ+0xe>
    c242:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c244:	e8 fc ff ff ff       	call   c245 <PCRLC_SUSPEND_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c249:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c24c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c24e:	0f b6 06             	movzbl (%esi),%eax
    c251:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c257:	89 14 24             	mov    %edx,(%esp)
    c25a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c25d:	e8 fc ff ff ff       	call   c25e <PCRLC_SUSPEND_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
    c262:	0f b6 06             	movzbl (%esi),%eax
    c265:	89 44 24 08          	mov    %eax,0x8(%esp)
    c269:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c26f:	c7 04 24 88 31 00 00 	movl   $0x3188,(%esp)
    c276:	89 44 24 04          	mov    %eax,0x4(%esp)
    c27a:	e8 fc ff ff ff       	call   c27b <PCRLC_SUSPEND_REQ+0x4b>
	switch(SV(ins_mode))
    c27f:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c285:	83 f8 02             	cmp    $0x2,%eax
    c288:	74 26                	je     c2b0 <PCRLC_SUSPEND_REQ+0x80>
    c28a:	83 f8 03             	cmp    $0x3,%eax
    c28d:	0f 84 85 00 00 00    	je     c318 <PCRLC_SUSPEND_REQ+0xe8>
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
		}
		break;
	default:
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:cannot distinguish the instance \n");
    c293:	c7 04 24 f0 32 00 00 	movl   $0x32f0,(%esp)
    c29a:	e8 fc ff ff ff       	call   c29b <PCRLC_SUSPEND_REQ+0x6b>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c29f:	89 f0                	mov    %esi,%eax
    c2a1:	e8 fc ff ff ff       	call   c2a2 <PCRLC_SUSPEND_REQ+0x72>
	cIoctrl = NULL;
	FOUT;
}
    c2a6:	83 c4 14             	add    $0x14,%esp
    c2a9:	5b                   	pop    %ebx
    c2aa:	5e                   	pop    %esi
    c2ab:	5d                   	pop    %ebp
    c2ac:	c3                   	ret    
    c2ad:	8d 76 00             	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    c2b0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c2b3:	85 db                	test   %ebx,%ebx
    c2b5:	74 2e                	je     c2e5 <PCRLC_SUSPEND_REQ+0xb5>
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c2b7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
	case UM_MODE:
		if(insptrd != NULL)
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
    c2bb:	c6 83 c2 10 00 00 09 	movb   $0x9,0x10c2(%ebx)
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c2c2:	c7 04 24 ec 31 00 00 	movl   $0x31ec,(%esp)
    c2c9:	89 44 24 04          	mov    %eax,0x4(%esp)
    c2cd:	e8 fc ff ff ff       	call   c2ce <PCRLC_SUSPEND_REQ+0x9e>
			if(umRxIns->reorderTimer)
    c2d2:	8b 43 08             	mov    0x8(%ebx),%eax
    c2d5:	85 c0                	test   %eax,%eax
    c2d7:	74 0c                	je     c2e5 <PCRLC_SUSPEND_REQ+0xb5>
			{
				fsm_schedule_cancel(umRxIns->reorderTimer);
    c2d9:	e8 fc ff ff ff       	call   c2da <PCRLC_SUSPEND_REQ+0xaa>
				umRxIns->reorderTimer = 0;
    c2de:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			}
		}
		if(insptru == NULL)
    c2e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c2e8:	85 c0                	test   %eax,%eax
    c2ea:	74 b3                	je     c29f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		umTxIns = (UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_SUSPEND;
    c2ec:	c6 40 2c 09          	movb   $0x9,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
    c2f0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    c2f4:	c7 04 24 44 32 00 00 	movl   $0x3244,(%esp)
    c2fb:	89 44 24 04          	mov    %eax,0x4(%esp)
    c2ff:	e8 fc ff ff ff       	call   c300 <PCRLC_SUSPEND_REQ+0xd0>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c304:	89 f0                	mov    %esi,%eax
    c306:	e8 fc ff ff ff       	call   c307 <PCRLC_SUSPEND_REQ+0xd7>
	cIoctrl = NULL;
	FOUT;
}
    c30b:	83 c4 14             	add    $0x14,%esp
    c30e:	5b                   	pop    %ebx
    c30f:	5e                   	pop    %esi
    c310:	5d                   	pop    %ebp
    c311:	c3                   	ret    
    c312:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c318:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    c31b:	85 db                	test   %ebx,%ebx
    c31d:	0f 84 7c ff ff ff    	je     c29f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c323:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
		if(insptru == NULL)
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
    c327:	66 c7 43 2c 09 00    	movw   $0x9,0x2c(%ebx)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c32d:	c7 04 24 9c 32 00 00 	movl   $0x329c,(%esp)
    c334:	89 44 24 04          	mov    %eax,0x4(%esp)
    c338:	e8 fc ff ff ff       	call   c339 <PCRLC_SUSPEND_REQ+0x109>
		if(amIns->pollRetxTimer)
    c33d:	8b 43 08             	mov    0x8(%ebx),%eax
    c340:	85 c0                	test   %eax,%eax
    c342:	74 0c                	je     c350 <PCRLC_SUSPEND_REQ+0x120>
		{
			fsm_schedule_cancel(amIns->pollRetxTimer);
    c344:	e8 fc ff ff ff       	call   c345 <PCRLC_SUSPEND_REQ+0x115>
			amIns->pollRetxTimer = 0;
    c349:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		}
		if(amIns->reorderTimer)
    c350:	8b 43 14             	mov    0x14(%ebx),%eax
    c353:	85 c0                	test   %eax,%eax
    c355:	74 0c                	je     c363 <PCRLC_SUSPEND_REQ+0x133>
		{
			fsm_schedule_cancel(amIns->reorderTimer);
    c357:	e8 fc ff ff ff       	call   c358 <PCRLC_SUSPEND_REQ+0x128>
			amIns->reorderTimer = 0;
    c35c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		}
		if(amIns->statProhTimer)
    c363:	8b 43 20             	mov    0x20(%ebx),%eax
    c366:	85 c0                	test   %eax,%eax
    c368:	0f 84 31 ff ff ff    	je     c29f <PCRLC_SUSPEND_REQ+0x6f>
		{
			fsm_schedule_cancel(amIns->statProhTimer);
    c36e:	e8 fc ff ff ff       	call   c36f <PCRLC_SUSPEND_REQ+0x13f>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c373:	89 f0                	mov    %esi,%eax
			amIns->reorderTimer = 0;
		}
		if(amIns->statProhTimer)
		{
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
    c375:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c37c:	e8 fc ff ff ff       	call   c37d <PCRLC_SUSPEND_REQ+0x14d>
	cIoctrl = NULL;
	FOUT;
}
    c381:	83 c4 14             	add    $0x14,%esp
    c384:	5b                   	pop    %ebx
    c385:	5e                   	pop    %esi
    c386:	5d                   	pop    %ebp
    c387:	c3                   	ret    
    c388:	90                   	nop
    c389:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c390 <PCRLC_RESUME_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_RESUME_REQ(void)
{
    c390:	55                   	push   %ebp
    c391:	89 e5                	mov    %esp,%ebp
    c393:	56                   	push   %esi
    c394:	53                   	push   %ebx
    c395:	83 ec 10             	sub    $0x10,%esp
    c398:	e8 fc ff ff ff       	call   c399 <PCRLC_RESUME_REQ+0x9>
	CRLC_ResumeReq_IoctrlMsg *cIoctrl = (CRLC_ResumeReq_IoctrlMsg*) fsm_data_get();
    c39d:	e8 fc ff ff ff       	call   c39e <PCRLC_RESUME_REQ+0xe>
    c3a2:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c3a4:	e8 fc ff ff ff       	call   c3a5 <PCRLC_RESUME_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c3a9:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c3ac:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c3ae:	0f b6 06             	movzbl (%esi),%eax
    c3b1:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c3b7:	89 14 24             	mov    %edx,(%esp)
    c3ba:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c3bd:	e8 fc ff ff ff       	call   c3be <PCRLC_RESUME_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
    c3c2:	c7 04 24 40 33 00 00 	movl   $0x3340,(%esp)
    c3c9:	e8 fc ff ff ff       	call   c3ca <PCRLC_RESUME_REQ+0x3a>
	switch(SV(ins_mode))
    c3ce:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c3d4:	83 f8 02             	cmp    $0x2,%eax
    c3d7:	74 1f                	je     c3f8 <PCRLC_RESUME_REQ+0x68>
    c3d9:	83 f8 03             	cmp    $0x3,%eax
    c3dc:	74 6a                	je     c448 <PCRLC_RESUME_REQ+0xb8>
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
    c3de:	c7 04 24 81 07 00 00 	movl   $0x781,(%esp)
    c3e5:	e8 fc ff ff ff       	call   c3e6 <PCRLC_RESUME_REQ+0x56>
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c3ea:	89 f0                	mov    %esi,%eax
    c3ec:	e8 fc ff ff ff       	call   c3ed <PCRLC_RESUME_REQ+0x5d>
	FOUT;
}
    c3f1:	83 c4 10             	add    $0x10,%esp
    c3f4:	5b                   	pop    %ebx
    c3f5:	5e                   	pop    %esi
    c3f6:	5d                   	pop    %ebp
    c3f7:	c3                   	ret    
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd == NULL)
    c3f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3fb:	85 c0                	test   %eax,%eax
    c3fd:	74 eb                	je     c3ea <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umRxIns = ( UM_RX_Instance *)insptrd;
		umRxIns->currentStatVar = ST_TRAN;
    c3ff:	c6 80 c2 10 00 00 08 	movb   $0x8,0x10c2(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um recv instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c406:	0f b6 06             	movzbl (%esi),%eax
    c409:	c7 04 24 74 33 00 00 	movl   $0x3374,(%esp)
    c410:	89 44 24 04          	mov    %eax,0x4(%esp)
    c414:	e8 fc ff ff ff       	call   c415 <PCRLC_RESUME_REQ+0x85>

		if(insptru == NULL)
    c419:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c41c:	85 c0                	test   %eax,%eax
    c41e:	74 ca                	je     c3ea <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umTxIns = ( UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_TRAN;
    c420:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c424:	0f b6 06             	movzbl (%esi),%eax
    c427:	c7 04 24 c8 33 00 00 	movl   $0x33c8,(%esp)
    c42e:	89 44 24 04          	mov    %eax,0x4(%esp)
    c432:	e8 fc ff ff ff       	call   c433 <PCRLC_RESUME_REQ+0xa3>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c437:	89 f0                	mov    %esi,%eax
    c439:	e8 fc ff ff ff       	call   c43a <PCRLC_RESUME_REQ+0xaa>
	FOUT;
}
    c43e:	83 c4 10             	add    $0x10,%esp
    c441:	5b                   	pop    %ebx
    c442:	5e                   	pop    %esi
    c443:	5d                   	pop    %ebp
    c444:	c3                   	ret    
    c445:	8d 76 00             	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c448:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c44b:	85 c0                	test   %eax,%eax
    c44d:	74 9b                	je     c3ea <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
    c44f:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c455:	0f b6 06             	movzbl (%esi),%eax
    c458:	c7 04 24 1c 34 00 00 	movl   $0x341c,(%esp)
    c45f:	89 44 24 04          	mov    %eax,0x4(%esp)
    c463:	e8 fc ff ff ff       	call   c464 <PCRLC_RESUME_REQ+0xd4>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c468:	89 f0                	mov    %esi,%eax
    c46a:	e8 fc ff ff ff       	call   c46b <PCRLC_RESUME_REQ+0xdb>
	FOUT;
}
    c46f:	83 c4 10             	add    $0x10,%esp
    c472:	5b                   	pop    %ebx
    c473:	5e                   	pop    %esi
    c474:	5d                   	pop    %ebp
    c475:	c3                   	ret    
    c476:	8d 76 00             	lea    0x0(%esi),%esi
    c479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c480 <PCRLC_STATUS_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c480:	55                   	push   %ebp
    c481:	89 e5                	mov    %esp,%ebp
    c483:	83 ec 10             	sub    $0x10,%esp
    c486:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    c489:	89 75 f8             	mov    %esi,-0x8(%ebp)
    c48c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    c48f:	e8 fc ff ff ff       	call   c490 <PCRLC_STATUS_IND+0x10>
    c494:	89 c6                	mov    %eax,%esi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c496:	b8 04 00 00 00       	mov    $0x4,%eax
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c49b:	89 d7                	mov    %edx,%edi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c49d:	e8 fc ff ff ff       	call   c49e <PCRLC_STATUS_IND+0x1e>
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c4a2:	ba 51 00 00 00       	mov    $0x51,%edx
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c4a7:	89 c3                	mov    %eax,%ebx
	cioctrl->eventCode = evCode;
    c4a9:	66 89 38             	mov    %di,(%eax)
	cioctrl->rbIdentity = rbid;
    c4ac:	89 f0                	mov    %esi,%eax
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c4ae:	89 d9                	mov    %ebx,%ecx
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
    c4b0:	88 43 02             	mov    %al,0x2(%ebx)
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c4b3:	b8 05 00 00 00       	mov    $0x5,%eax
    c4b8:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    c4bf:	e8 fc ff ff ff       	call   c4c0 <PCRLC_STATUS_IND+0x40>
	fsm_mem_free(cioctrl);
    c4c4:	89 d8                	mov    %ebx,%eax
    c4c6:	e8 fc ff ff ff       	call   c4c7 <PCRLC_STATUS_IND+0x47>
	//fsm_data_destroy(cioctrl);
	cioctrl = NULL;
	FOUT;
}
    c4cb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c4ce:	8b 75 f8             	mov    -0x8(%ebp),%esi
    c4d1:	8b 7d fc             	mov    -0x4(%ebp),%edi
    c4d4:	89 ec                	mov    %ebp,%esp
    c4d6:	5d                   	pop    %ebp
    c4d7:	c3                   	ret    
    c4d8:	90                   	nop
    c4d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c4e0 <PPRLC_DISC_REQ>:

//
inline void PPRLC_DISC_REQ(void)  {}
    c4e0:	55                   	push   %ebp
    c4e1:	89 e5                	mov    %esp,%ebp
    c4e3:	5d                   	pop    %ebp
    c4e4:	c3                   	ret    
    c4e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c4e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c4f0 <PMRLC_BUFFERREP_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void* PMRLC_BUFFERREP_REQ(void)
{
    c4f0:	55                   	push   %ebp
    c4f1:	89 e5                	mov    %esp,%ebp
    c4f3:	57                   	push   %edi
    c4f4:	56                   	push   %esi
    c4f5:	53                   	push   %ebx
    c4f6:	83 ec 20             	sub    $0x20,%esp
    c4f9:	e8 fc ff ff ff       	call   c4fa <PMRLC_BUFFERREP_REQ+0xa>
	struct AM_Instance * amIns;
	struct UM_TX_Instance *umTxIns;
	struct TM_TX_Instance *tmTxIns;
	struct AmBuffer *amBuffer;
	CtrlBuffer *ctrlBf;
	u32 num = 0,*nump;  //
    c4fe:	31 db                	xor    %ebx,%ebx

	SV_PTR_GET(rlc_mac_sv);
    c500:	e8 fc ff ff ff       	call   c501 <PMRLC_BUFFERREP_REQ+0x11>
    c505:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c508:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c50b:	05 f4 25 00 00       	add    $0x25f4,%eax
    c510:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c513:	8b 82 f4 25 00 00    	mov    0x25f4(%edx),%eax
    c519:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    c51c:	74 33                	je     c551 <PMRLC_BUFFERREP_REQ+0x61>
    c51e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c521:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c528:	8b b8 48 dd ff ff    	mov    -0x22b8(%eax),%edi
    c52e:	85 ff                	test   %edi,%edi
    c530:	75 16                	jne    c548 <PMRLC_BUFFERREP_REQ+0x58>
    c532:	8b b0 a0 de ff ff    	mov    -0x2160(%eax),%esi
    c538:	85 f6                	test   %esi,%esi
    c53a:	75 0c                	jne    c548 <PMRLC_BUFFERREP_REQ+0x58>
    c53c:	8b 88 b4 de ff ff    	mov    -0x214c(%eax),%ecx
    c542:	85 c9                	test   %ecx,%ecx
    c544:	74 05                	je     c54b <PMRLC_BUFFERREP_REQ+0x5b>
    c546:	66 90                	xchg   %ax,%ax
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] am instance (rbid is %d) has data to report\n", amIns->rbId);
				num++;
    c548:	83 c3 01             	add    $0x1,%ebx

	SV_PTR_GET(rlc_mac_sv);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c54b:	8b 00                	mov    (%eax),%eax
    c54d:	39 c2                	cmp    %eax,%edx
    c54f:	75 d7                	jne    c528 <PMRLC_BUFFERREP_REQ+0x38>
				num++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c551:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c554:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c557:	05 f8 36 00 00       	add    $0x36f8,%eax
    c55c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c55f:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
    c565:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c568:	74 13                	je     c57d <PMRLC_BUFFERREP_REQ+0x8d>
    c56a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c56d:	8d 76 00             	lea    0x0(%esi),%esi
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c570:	83 78 f0 01          	cmpl   $0x1,-0x10(%eax)
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c574:	8b 00                	mov    (%eax),%eax
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c576:	83 db ff             	sbb    $0xffffffff,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c579:	39 c2                	cmp    %eax,%edx
    c57b:	75 f3                	jne    c570 <PMRLC_BUFFERREP_REQ+0x80>
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c57d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c580:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c583:	05 2c 37 00 00       	add    $0x372c,%eax
    c588:	89 45 dc             	mov    %eax,-0x24(%ebp)
    c58b:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
    c591:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c594:	74 17                	je     c5ad <PMRLC_BUFFERREP_REQ+0xbd>
    c596:	8b 55 dc             	mov    -0x24(%ebp),%edx
    c599:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c5a0:	83 78 f8 01          	cmpl   $0x1,-0x8(%eax)
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c5a4:	8b 00                	mov    (%eax),%eax
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c5a6:	83 db ff             	sbb    $0xffffffff,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c5a9:	39 c2                	cmp    %eax,%edx
    c5ab:	75 f3                	jne    c5a0 <PMRLC_BUFFERREP_REQ+0xb0>
				num++;
			}
		}
	}
	
	if(num == 0)
    c5ad:	85 db                	test   %ebx,%ebx
    c5af:	0f 84 9f 02 00 00    	je     c854 <PMRLC_BUFFERREP_REQ+0x364>
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c5b5:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    c5b8:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
    c5bc:	e8 fc ff ff ff       	call   c5bd <PMRLC_BUFFERREP_REQ+0xcd>
	*nump = num;
    c5c1:	89 18                	mov    %ebx,(%eax)
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c5c3:	89 c3                	mov    %eax,%ebx
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c5c5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    c5c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c5cb:	83 c3 04             	add    $0x4,%ebx
    c5ce:	8b b8 f4 25 00 00    	mov    0x25f4(%eax),%edi
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c5d4:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c5d7:	0f 84 47 01 00 00    	je     c724 <PMRLC_BUFFERREP_REQ+0x234>
    c5dd:	8d 76 00             	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c5e0:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    c5e6:	8d 97 fc dc ff ff    	lea    -0x2304(%edi),%edx
    c5ec:	89 55 f0             	mov    %edx,-0x10(%ebp)
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c5ef:	85 c0                	test   %eax,%eax
    c5f1:	75 1d                	jne    c610 <PMRLC_BUFFERREP_REQ+0x120>
    c5f3:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
    c5f9:	85 c0                	test   %eax,%eax
    c5fb:	75 13                	jne    c610 <PMRLC_BUFFERREP_REQ+0x120>
    c5fd:	8b b7 b4 de ff ff    	mov    -0x214c(%edi),%esi
    c603:	85 f6                	test   %esi,%esi
    c605:	0f 84 0e 01 00 00    	je     c719 <PMRLC_BUFFERREP_REQ+0x229>
    c60b:	90                   	nop
    c60c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			{
				mioctrl->rnti = 0;
    c610:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = amIns->lcId;
    c615:	0f b6 87 ff dc ff ff 	movzbl -0x2301(%edi),%eax
    c61c:	88 43 02             	mov    %al,0x2(%ebx)
				mioctrl->txQueueSize = amIns->amSduBufferSize;
    c61f:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
    c625:	89 43 03             	mov    %eax,0x3(%ebx)
				mioctrl->txQueueHeader = 2 + 2* amIns->amSduBufferNum;
    c628:	8b 97 4c dd ff ff    	mov    -0x22b4(%edi),%edx
    c62e:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
    c632:	66 89 53 07          	mov    %dx,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c636:	0f b7 d2             	movzwl %dx,%edx
    c639:	01 c2                	add    %eax,%edx
    c63b:	83 fa 7f             	cmp    $0x7f,%edx
    c63e:	0f 87 6c 01 00 00    	ja     c7b0 <PMRLC_BUFFERREP_REQ+0x2c0>
				{
					mioctrl->txQueueSize += 2;
    c644:	83 c0 02             	add    $0x2,%eax
    c647:	89 43 03             	mov    %eax,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c64a:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
				mioctrl->retxQueueHeader = 2;
    c650:	66 c7 43 0d 02 00    	movw   $0x2,0xd(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c656:	89 43 09             	mov    %eax,0x9(%ebx)
    c659:	8b b7 98 de ff ff    	mov    -0x2168(%edi),%esi
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
    c65f:	8d 87 98 de ff ff    	lea    -0x2168(%edi),%eax
    c665:	39 f0                	cmp    %esi,%eax
    c667:	74 55                	je     c6be <PMRLC_BUFFERREP_REQ+0x1ce>
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c669:	89 7d e8             	mov    %edi,-0x18(%ebp)
    c66c:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
    c672:	89 c7                	mov    %eax,%edi
    c674:	eb 16                	jmp    c68c <PMRLC_BUFFERREP_REQ+0x19c>
    c676:	66 90                	xchg   %ax,%ax
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
						{
							if( amBuffer->pkt->len < 128 )
							{
								mioctrl->retxQueueSize += 2;
    c678:	83 43 09 02          	addl   $0x2,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c67c:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c682:	39 c7                	cmp    %eax,%edi
    c684:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c68a:	74 2f                	je     c6bb <PMRLC_BUFFERREP_REQ+0x1cb>
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
    c68c:	0f bf 96 94 00 00 00 	movswl 0x94(%esi),%edx
    c693:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c696:	e8 fc ff ff ff       	call   c697 <PMRLC_BUFFERREP_REQ+0x1a7>
    c69b:	84 c0                	test   %al,%al
    c69d:	74 dd                	je     c67c <PMRLC_BUFFERREP_REQ+0x18c>
						{
							if( amBuffer->pkt->len < 128 )
    c69f:	8b 06                	mov    (%esi),%eax
    c6a1:	83 78 50 7f          	cmpl   $0x7f,0x50(%eax)
    c6a5:	76 d1                	jbe    c678 <PMRLC_BUFFERREP_REQ+0x188>
							{
								mioctrl->retxQueueSize += 2;
							}
							else
							{
								mioctrl->retxQueueSize += 3;
    c6a7:	83 43 09 03          	addl   $0x3,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c6ab:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c6b1:	39 c7                	cmp    %eax,%edi
    c6b3:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c6b9:	75 d1                	jne    c68c <PMRLC_BUFFERREP_REQ+0x19c>
    c6bb:	8b 7d e8             	mov    -0x18(%ebp),%edi
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c6be:	8b 87 b4 de ff ff    	mov    -0x214c(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c6c4:	8d b7 ac de ff ff    	lea    -0x2154(%edi),%esi
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
    c6ca:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c6d0:	89 c2                	mov    %eax,%edx
    c6d2:	66 89 43 0f          	mov    %ax,0xf(%ebx)
    c6d6:	8b 87 ac de ff ff    	mov    -0x2154(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c6dc:	39 c6                	cmp    %eax,%esi
    c6de:	74 36                	je     c716 <PMRLC_BUFFERREP_REQ+0x226>
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c6e0:	83 e8 04             	sub    $0x4,%eax
    c6e3:	eb 18                	jmp    c6fd <PMRLC_BUFFERREP_REQ+0x20d>
    c6e5:	8d 76 00             	lea    0x0(%esi),%esi
					{
						if( ctrlBf->pkt->len < 128 )
						{
							mioctrl->statusPduSize += 2;
    c6e8:	83 c2 02             	add    $0x2,%edx
    c6eb:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c6ef:	8b 50 04             	mov    0x4(%eax),%edx
    c6f2:	39 d6                	cmp    %edx,%esi
    c6f4:	8d 42 fc             	lea    -0x4(%edx),%eax
    c6f7:	74 1d                	je     c716 <PMRLC_BUFFERREP_REQ+0x226>
    c6f9:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
					{
						if( ctrlBf->pkt->len < 128 )
    c6fd:	8b 08                	mov    (%eax),%ecx
    c6ff:	83 79 50 7f          	cmpl   $0x7f,0x50(%ecx)
    c703:	76 e3                	jbe    c6e8 <PMRLC_BUFFERREP_REQ+0x1f8>
						{
							mioctrl->statusPduSize += 2;
						}
						else
						{
							mioctrl->statusPduSize += 3;
    c705:	83 c2 03             	add    $0x3,%edx
    c708:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c70c:	8b 50 04             	mov    0x4(%eax),%edx
    c70f:	39 d6                	cmp    %edx,%esi
    c711:	8d 42 fc             	lea    -0x4(%edx),%eax
    c714:	75 e3                	jne    c6f9 <PMRLC_BUFFERREP_REQ+0x209>
				}
				else
				{
					mioctrl->statusPduSize += 3;
				}*/
				mioctrl++;
    c716:	83 c3 13             	add    $0x13,%ebx
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c719:	8b 3f                	mov    (%edi),%edi
    c71b:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c71e:	0f 85 bc fe ff ff    	jne    c5e0 <PMRLC_BUFFERREP_REQ+0xf0>
    c724:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c727:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
				mioctrl++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c72d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c730:	0f 84 b2 00 00 00    	je     c7e8 <PMRLC_BUFFERREP_REQ+0x2f8>
    c736:	8b 75 e0             	mov    -0x20(%ebp),%esi
    c739:	eb 18                	jmp    c753 <PMRLC_BUFFERREP_REQ+0x263>
    c73b:	90                   	nop
    c73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c740:	83 c2 02             	add    $0x2,%edx
    c743:	89 53 03             	mov    %edx,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
    c746:	83 c3 13             	add    $0x13,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c749:	8b 00                	mov    (%eax),%eax
    c74b:	39 c6                	cmp    %eax,%esi
    c74d:	0f 84 95 00 00 00    	je     c7e8 <PMRLC_BUFFERREP_REQ+0x2f8>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
    c753:	8b 48 f0             	mov    -0x10(%eax),%ecx
    c756:	85 c9                	test   %ecx,%ecx
    c758:	74 ef                	je     c749 <PMRLC_BUFFERREP_REQ+0x259>
			{
				mioctrl->rnti = 0;
    c75a:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = umTxIns->lcid;
    c75f:	0f b6 50 d3          	movzbl -0x2d(%eax),%edx
    c763:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c766:	8b 50 f0             	mov    -0x10(%eax),%edx
				mioctrl->retxQueueSize = 0;
    c769:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->retxQueueHeader = 0;
    c770:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				mioctrl->statusPduSize = 0;
    c776:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = umTxIns->lcid;
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c77c:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->retxQueueSize = 0;
				mioctrl->retxQueueHeader = 0;
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;
    c77f:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)

				if(umTxIns->snFiledLength == 5)
    c785:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c789:	66 83 f9 05          	cmp    $0x5,%cx
    c78d:	74 41                	je     c7d0 <PMRLC_BUFFERREP_REQ+0x2e0>
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
    c78f:	66 83 f9 0a          	cmp    $0xa,%cx
    c793:	74 2b                	je     c7c0 <PMRLC_BUFFERREP_REQ+0x2d0>
    c795:	0f b7 4b 07          	movzwl 0x7(%ebx),%ecx
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c799:	0f b7 c9             	movzwl %cx,%ecx
    c79c:	01 d1                	add    %edx,%ecx
    c79e:	83 f9 7f             	cmp    $0x7f,%ecx
    c7a1:	76 9d                	jbe    c740 <PMRLC_BUFFERREP_REQ+0x250>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c7a3:	83 c2 03             	add    $0x3,%edx
    c7a6:	89 53 03             	mov    %edx,0x3(%ebx)
    c7a9:	eb 9b                	jmp    c746 <PMRLC_BUFFERREP_REQ+0x256>
    c7ab:	90                   	nop
    c7ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c7b0:	83 c0 03             	add    $0x3,%eax
    c7b3:	89 43 03             	mov    %eax,0x3(%ebx)
    c7b6:	e9 8f fe ff ff       	jmp    c64a <PMRLC_BUFFERREP_REQ+0x15a>
    c7bb:	90                   	nop
    c7bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
    c7c0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c7c3:	8d 4c 09 02          	lea    0x2(%ecx,%ecx,1),%ecx
    c7c7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c7cb:	eb cc                	jmp    c799 <PMRLC_BUFFERREP_REQ+0x2a9>
    c7cd:	8d 76 00             	lea    0x0(%esi),%esi
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;

				if(umTxIns->snFiledLength == 5)
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
    c7d0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c7d3:	8d 4c 09 01          	lea    0x1(%ecx,%ecx,1),%ecx
    c7d7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c7db:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c7df:	eb ae                	jmp    c78f <PMRLC_BUFFERREP_REQ+0x29f>
    c7e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c7e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c7eb:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c7f1:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c7f4:	74 72                	je     c868 <PMRLC_BUFFERREP_REQ+0x378>
    c7f6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    c7f9:	eb 2d                	jmp    c828 <PMRLC_BUFFERREP_REQ+0x338>
    c7fb:	90                   	nop
    c7fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c800:	83 c2 02             	add    $0x2,%edx
    c803:	89 53 03             	mov    %edx,0x3(%ebx)
				}
				else
				{
					mioctrl->txQueueSize += 3;
				}
				mioctrl->retxQueueSize = 0;
    c806:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->statusPduSize = 0;
    c80d:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
				mioctrl->statusPduHeader = 0;
    c813:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
				mioctrl->retxQueueHeader = 0;
    c819:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				//fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize, mioctrl->lcid);
				mioctrl++;
    c81f:	83 c3 13             	add    $0x13,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c822:	8b 00                	mov    (%eax),%eax
    c824:	39 c1                	cmp    %eax,%ecx
    c826:	74 40                	je     c868 <PMRLC_BUFFERREP_REQ+0x378>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
    c828:	8b 50 f8             	mov    -0x8(%eax),%edx
    c82b:	85 d2                	test   %edx,%edx
    c82d:	74 f3                	je     c822 <PMRLC_BUFFERREP_REQ+0x332>
			{
				mioctrl->rnti = 0;
    c82f:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = tmTxIns->lcId;
    c834:	0f b6 50 e7          	movzbl -0x19(%eax),%edx
    c838:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    c83b:	8b 50 f8             	mov    -0x8(%eax),%edx
				mioctrl->txQueueHeader = 0;
    c83e:	66 c7 43 07 00 00    	movw   $0x0,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c844:	83 fa 7f             	cmp    $0x7f,%edx
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    c847:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c84a:	76 b4                	jbe    c800 <PMRLC_BUFFERREP_REQ+0x310>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c84c:	83 c2 03             	add    $0x3,%edx
    c84f:	89 53 03             	mov    %edx,0x3(%ebx)
    c852:	eb b2                	jmp    c806 <PMRLC_BUFFERREP_REQ+0x316>
		}
	}
	
	if(num == 0)
	{
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] There is no data to report\n");
    c854:	c7 04 24 6c 34 00 00 	movl   $0x346c,(%esp)
    c85b:	e8 fc ff ff ff       	call   c85c <PMRLC_BUFFERREP_REQ+0x36c>
		if( SV(bufferReqTimer) )
		{
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}*/
		return NULL; 	//modify 20150901
    c860:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    c867:	90                   	nop
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    c868:	8b 45 d8             	mov    -0x28(%ebp),%eax
    c86b:	83 c4 20             	add    $0x20,%esp
    c86e:	5b                   	pop    %ebx
    c86f:	5e                   	pop    %esi
    c870:	5f                   	pop    %edi
    c871:	5d                   	pop    %ebp
    c872:	c3                   	ret    
    c873:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    c879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c880 <PMRLC_TRANSOP_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
{
    c880:	55                   	push   %ebp
    c881:	89 e5                	mov    %esp,%ebp
    c883:	57                   	push   %edi
    c884:	56                   	push   %esi
    c885:	53                   	push   %ebx
    c886:	83 ec 70             	sub    $0x70,%esp
    c889:	e8 fc ff ff ff       	call   c88a <PMRLC_TRANSOP_IND+0xa>
    c88e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	u32 subHeadLen;
	u32 size = 0;     //the total size in a buffer to transimit	
	u16 rnti;
	//int i=0;  //FOR TEST
	
	SV_PTR_GET(rlc_mac_sv);
    c891:	e8 fc ff ff ff       	call   c892 <PMRLC_TRANSOP_IND+0x12>
    c896:	89 45 cc             	mov    %eax,-0x34(%ebp)
	SV(isBufferReq) = 0;
    c899:	c6 80 24 02 00 00 00 	movb   $0x0,0x224(%eax)
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    c8a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	if(hptr == NULL)
    c8a3:	85 c0                	test   %eax,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	SV(isBufferReq) = 0;
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    c8a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(hptr == NULL)
    c8a8:	0f 84 d4 01 00 00    	je     ca82 <PMRLC_TRANSOP_IND+0x202>
	{
		FOUT;
	}	
	nump = (u32*)hptr;
	num = *nump;
    c8ae:	89 c2                	mov    %eax,%edx
    c8b0:	8b 00                	mov    (%eax),%eax
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
    c8b2:	85 c0                	test   %eax,%eax
    c8b4:	0f 84 40 0a 00 00    	je     d2fa <PMRLC_TRANSOP_IND+0xa7a>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c8ba:	8b 75 b4             	mov    -0x4c(%ebp),%esi
    c8bd:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    c8c0:	8d 04 50             	lea    (%eax,%edx,2),%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c8c3:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	subhead = data = sevNum = fifNum = 0;
    c8c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    c8cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c8d4:	83 ee 0f             	sub    $0xf,%esi
    c8d7:	01 f0                	add    %esi,%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c8d9:	83 c1 04             	add    $0x4,%ecx
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c8dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
    c8df:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c8e2:	89 75 ac             	mov    %esi,-0x54(%ebp)
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c8e5:	89 ce                	mov    %ecx,%esi
    c8e7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    c8ea:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    c8ed:	05 18 02 00 00       	add    $0x218,%eax
    c8f2:	89 45 c0             	mov    %eax,-0x40(%ebp)
    c8f5:	8d 76 00             	lea    0x0(%esi),%esi
	subhead = data = sevNum = fifNum = 0;
	//controlelm = 14 + 10;
	while(num > 0)
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    c8f8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    c8fb:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    c8fe:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    c902:	89 14 24             	mov    %edx,(%esp)
    c905:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    c908:	e8 fc ff ff ff       	call   c909 <PMRLC_TRANSOP_IND+0x89>
		switch(SV(ins_mode))
    c90d:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    c910:	8b 81 18 02 00 00    	mov    0x218(%ecx),%eax
    c916:	83 f8 02             	cmp    $0x2,%eax
    c919:	0f 84 b9 08 00 00    	je     d1d8 <PMRLC_TRANSOP_IND+0x958>
    c91f:	83 f8 03             	cmp    $0x3,%eax
    c922:	0f 84 58 07 00 00    	je     d080 <PMRLC_TRANSOP_IND+0x800>
    c928:	83 f8 01             	cmp    $0x1,%eax
    c92b:	0f 84 bf 06 00 00    	je     cff0 <PMRLC_TRANSOP_IND+0x770>
			}

			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    c931:	c7 04 24 a4 34 00 00 	movl   $0x34a4,(%esp)
    c938:	e8 fc ff ff ff       	call   c939 <PMRLC_TRANSOP_IND+0xb9>
			break;
		}	
		num--;
		if(num>0)
    c93d:	3b 75 d0             	cmp    -0x30(%ebp),%esi
    c940:	74 06                	je     c948 <PMRLC_TRANSOP_IND+0xc8>
		{
			mIoctrl++;
    c942:	83 c6 13             	add    $0x13,%esi
    c945:	eb b1                	jmp    c8f8 <PMRLC_TRANSOP_IND+0x78>
    c947:	90                   	nop
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    c948:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c94b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    c94e:	83 c0 04             	add    $0x4,%eax
    c951:	e8 fc ff ff ff       	call   c952 <PMRLC_TRANSOP_IND+0xd2>
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c956:	8b 75 dc             	mov    -0x24(%ebp),%esi
    c959:	83 c6 04             	add    $0x4,%esi
			mIoctrl++;
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    c95c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c95f:	89 f0                	mov    %esi,%eax
    c961:	e8 fc ff ff ff       	call   c962 <PMRLC_TRANSOP_IND+0xe2>
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    c966:	89 f2                	mov    %esi,%edx
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c968:	89 45 b8             	mov    %eax,-0x48(%ebp)
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    c96b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c96e:	e8 fc ff ff ff       	call   c96f <PMRLC_TRANSOP_IND+0xef>

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    c973:	8b 45 b8             	mov    -0x48(%ebp),%eax
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    c976:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
	data = 0;     //
    c979:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    c980:	83 c0 04             	add    $0x4,%eax
    c983:	89 45 ec             	mov    %eax,-0x14(%ebp)
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    c986:	8b 01                	mov    (%ecx),%eax
	while(num > 0)
    c988:	85 c0                	test   %eax,%eax
    c98a:	74 60                	je     c9ec <PMRLC_TRANSOP_IND+0x16c>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c98c:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    c98f:	8d 04 50             	lea    (%eax,%edx,2),%eax
    c992:	03 45 ac             	add    -0x54(%ebp),%eax
    c995:	89 45 bc             	mov    %eax,-0x44(%ebp)
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
	while(num > 0)
	{
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] number %d:\n", num);
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    c998:	8b 75 d8             	mov    -0x28(%ebp),%esi
    c99b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    c99e:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    c9a1:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    c9a5:	8b 75 c0             	mov    -0x40(%ebp),%esi
    c9a8:	89 34 24             	mov    %esi,(%esp)
    c9ab:	e8 fc ff ff ff       	call   c9ac <PMRLC_TRANSOP_IND+0x12c>
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
    c9b0:	8b 55 cc             	mov    -0x34(%ebp),%edx
    c9b3:	8b 82 18 02 00 00    	mov    0x218(%edx),%eax
    c9b9:	83 f8 02             	cmp    $0x2,%eax
    c9bc:	0f 84 5e 04 00 00    	je     ce20 <PMRLC_TRANSOP_IND+0x5a0>
    c9c2:	83 f8 03             	cmp    $0x3,%eax
    c9c5:	0f 84 dd 01 00 00    	je     cba8 <PMRLC_TRANSOP_IND+0x328>
    c9cb:	83 f8 01             	cmp    $0x1,%eax
    c9ce:	0f 84 cc 00 00 00    	je     caa0 <PMRLC_TRANSOP_IND+0x220>
				}          
            }
			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    c9d4:	c7 04 24 a4 34 00 00 	movl   $0x34a4,(%esp)
    c9db:	e8 fc ff ff ff       	call   c9dc <PMRLC_TRANSOP_IND+0x15c>
			break;
		}
	
		num--;
		if(num>0)
    c9e0:	8b 75 bc             	mov    -0x44(%ebp),%esi
    c9e3:	39 75 d8             	cmp    %esi,-0x28(%ebp)
    c9e6:	0f 85 a4 00 00 00    	jne    ca90 <PMRLC_TRANSOP_IND+0x210>
		{
			mIoctrl++;
		}
	}
		
	if(0 == pkptr->len)
    c9ec:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c9ef:	8b 48 50             	mov    0x50(%eax),%ecx
    c9f2:	85 c9                	test   %ecx,%ecx
    c9f4:	0f 84 7d 08 00 00    	je     d277 <PMRLC_TRANSOP_IND+0x9f7>
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
		SV(bufferReqTimer) = 0;
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
    c9fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
	fix->E = 0;    //E0
    c9fd:	80 20 df             	andb   $0xdf,(%eax)
	icimsg->len = data;
    ca00:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ca03:	8b 55 b8             	mov    -0x48(%ebp),%edx
	icimsg->rnti = mIoctrl->rnti;
    ca06:	8b 75 d8             	mov    -0x28(%ebp),%esi
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
	fix->E = 0;    //E0
	icimsg->len = data;
    ca09:	66 89 42 02          	mov    %ax,0x2(%edx)
	icimsg->rnti = mIoctrl->rnti;
    ca0d:	0f b7 06             	movzwl (%esi),%eax
    ca10:	66 89 02             	mov    %ax,(%edx)
	fsm_mem_cpy(pkptr->head, head,  data + sizeof(MRLC_toMac_IciMsg));
    ca13:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ca16:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    ca19:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
    ca1f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ca22:	83 c1 04             	add    $0x4,%ecx
    ca25:	e8 fc ff ff ff       	call   ca26 <PMRLC_TRANSOP_IND+0x1a6>
	fsm_mem_free(head);
    ca2a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca2d:	e8 fc ff ff ff       	call   ca2e <PMRLC_TRANSOP_IND+0x1ae>
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    ca32:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ca35:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
	{
		send_msg3(pkptr);
    ca3a:	8b 45 d0             	mov    -0x30(%ebp),%eax
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    ca3d:	0f 85 d9 08 00 00    	jne    d31c <PMRLC_TRANSOP_IND+0xa9c>
		send_msg3(pkptr);
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
		FOUT;
	}
	else{
		complexUeMacPdu(pkptr); //add in 20150804
    ca43:	e8 fc ff ff ff       	call   ca44 <PMRLC_TRANSOP_IND+0x1c4>
		if(SV(Tbsize_Complex)!=0)
    ca48:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ca4b:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    ca51:	85 d2                	test   %edx,%edx
    ca53:	74 0a                	je     ca5f <PMRLC_TRANSOP_IND+0x1df>
				SV(Tbsize_Complex)=0;
    ca55:	c7 80 f4 01 00 00 00 	movl   $0x0,0x1f4(%eax)
    ca5c:	00 00 00 
		
		fsm_printf("[RLC][PMRLC_TRANSOP_IND][<--] send to MAC\n");
    ca5f:	c7 04 24 fc 36 00 00 	movl   $0x36fc,(%esp)
    ca66:	e8 fc ff ff ff       	call   ca67 <PMRLC_TRANSOP_IND+0x1e7>
		SV(countSentToLower)++;
    ca6b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ca6e:	83 80 98 5a 00 00 01 	addl   $0x1,0x5a98(%eax)
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] bufferReqTimer restart\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));*/
		fsm_data_destroy(hptr);
    ca75:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    ca78:	e8 fc ff ff ff       	call   ca79 <PMRLC_TRANSOP_IND+0x1f9>
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
    ca7d:	e8 fc ff ff ff       	call   ca7e <PMRLC_TRANSOP_IND+0x1fe>
		FOUT;
	}
}
    ca82:	83 c4 70             	add    $0x70,%esp
    ca85:	5b                   	pop    %ebx
    ca86:	5e                   	pop    %esi
    ca87:	5f                   	pop    %edi
    ca88:	5d                   	pop    %ebp
    ca89:	c3                   	ret    
    ca8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
	
		num--;
		if(num>0)
		{
			mIoctrl++;
    ca90:	83 45 d8 13          	addl   $0x13,-0x28(%ebp)
    ca94:	e9 ff fe ff ff       	jmp    c998 <PMRLC_TRANSOP_IND+0x118>
    ca99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    caa0:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    caa3:	85 f6                	test   %esi,%esi
    caa5:	0f 84 35 ff ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
    caab:	8b 46 0c             	mov    0xc(%esi),%eax
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    caae:	8d 4e 0c             	lea    0xc(%esi),%ecx
    cab1:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    cab4:	39 c1                	cmp    %eax,%ecx
    cab6:	0f 84 24 ff ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
    cabc:	8b 38                	mov    (%eax),%edi
    cabe:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cac1:	83 ef 04             	sub    $0x4,%edi
    cac4:	eb 18                	jmp    cade <PMRLC_TRANSOP_IND+0x25e>
    cac6:	66 90                	xchg   %ax,%ax
    cac8:	8b 47 04             	mov    0x4(%edi),%eax
    cacb:	8d 57 04             	lea    0x4(%edi),%edx
    cace:	89 fb                	mov    %edi,%ebx
    cad0:	83 e8 04             	sub    $0x4,%eax
    cad3:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cad6:	0f 84 04 ff ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
    cadc:	89 c7                	mov    %eax,%edi
				{
					if(buffer->pkt->len < 128)
    cade:	8b 03                	mov    (%ebx),%eax
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cae0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
    cae3:	8b 40 50             	mov    0x50(%eax),%eax
					{
						subHeadLen = 2;
    cae6:	3d 80 00 00 00       	cmp    $0x80,%eax
    caeb:	19 d2                	sbb    %edx,%edx
    caed:	83 c2 03             	add    $0x3,%edx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    caf0:	01 d0                	add    %edx,%eax
    caf2:	3b 41 03             	cmp    0x3(%ecx),%eax
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
					{
						subHeadLen = 2;
    caf5:	89 55 dc             	mov    %edx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    caf8:	0f 87 e2 fe ff ff    	ja     c9e0 <PMRLC_TRANSOP_IND+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cafe:	8b 53 04             	mov    0x4(%ebx),%edx
    cb01:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cb04:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cb07:	89 10                	mov    %edx,(%eax)
						break;
					}
					else
					{
						list_del(&buffer->list);
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
    cb09:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cb0b:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cb12:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cb19:	8b 40 50             	mov    0x50(%eax),%eax
    cb1c:	29 46 14             	sub    %eax,0x14(%esi)
						tmTxIns->tmSduBufferNum--;
    cb1f:	83 6e 18 01          	subl   $0x1,0x18(%esi)
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
    cb23:	8b 03                	mov    (%ebx),%eax
    cb25:	8b 48 50             	mov    0x50(%eax),%ecx
    cb28:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cb2e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cb31:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cb37:	89 45 a0             	mov    %eax,-0x60(%ebp)
    cb3a:	e8 fc ff ff ff       	call   cb3b <PMRLC_TRANSOP_IND+0x2bb>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cb3f:	8b 03                	mov    (%ebx),%eax
    cb41:	8b 50 50             	mov    0x50(%eax),%edx
    cb44:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cb47:	e8 fc ff ff ff       	call   cb48 <PMRLC_TRANSOP_IND+0x2c8>

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cb4c:	8d 55 e0             	lea    -0x20(%ebp),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cb4f:	8b 03                	mov    (%ebx),%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cb51:	8d 4d f0             	lea    -0x10(%ebp),%ecx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cb54:	83 c0 50             	add    $0x50,%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cb57:	89 54 24 04          	mov    %edx,0x4(%esp)
    cb5b:	0f b6 56 03          	movzbl 0x3(%esi),%edx
    cb5f:	89 14 24             	mov    %edx,(%esp)
    cb62:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cb65:	e8 d6 e8 ff ff       	call   b440 <creat_subhead.isra.0>
						mIoctrl->txQueueSize -= subHeadLen + buffer->pkt->len;
    cb6a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cb6d:	8b 13                	mov    (%ebx),%edx
    cb6f:	8b 41 03             	mov    0x3(%ecx),%eax
    cb72:	2b 42 50             	sub    0x50(%edx),%eax
    cb75:	2b 45 dc             	sub    -0x24(%ebp),%eax
    cb78:	89 41 03             	mov    %eax,0x3(%ecx)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
    cb7b:	8b 03                	mov    (%ebx),%eax
    cb7d:	e8 fc ff ff ff       	call   cb7e <PMRLC_TRANSOP_IND+0x2fe>
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
    cb82:	89 d8                	mov    %ebx,%eax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
    cb84:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(buffer);  //20140922
    cb8a:	e8 fc ff ff ff       	call   cb8b <PMRLC_TRANSOP_IND+0x30b>
						buffer = NULL;
						if(list_empty(&tmTxIns->tmSduBuffer.list))
    cb8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cb92:	3b 46 0c             	cmp    0xc(%esi),%eax
    cb95:	0f 85 2d ff ff ff    	jne    cac8 <PMRLC_TRANSOP_IND+0x248>
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
						buffer = NULL;
    cb9b:	31 db                	xor    %ebx,%ebx
    cb9d:	e9 3e fe ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
    cba2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
				break;
			}

		case AM_MODE:
			if(insptru == NULL)
    cba8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cbab:	85 f6                	test   %esi,%esi
    cbad:	0f 84 2d fe ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cbb3:	8b 86 b0 01 00 00    	mov    0x1b0(%esi),%eax
				break;
			}*/

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    cbb9:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    cbbf:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    cbc2:	39 c2                	cmp    %eax,%edx
    cbc4:	0f 84 10 01 00 00    	je     ccda <PMRLC_TRANSOP_IND+0x45a>
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cbca:	8b 38                	mov    (%eax),%edi
    cbcc:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cbcf:	83 ef 04             	sub    $0x4,%edi
    cbd2:	e9 c0 00 00 00       	jmp    cc97 <PMRLC_TRANSOP_IND+0x417>
    cbd7:	90                   	nop
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cbd8:	8b 53 04             	mov    0x4(%ebx),%edx
    cbdb:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cbde:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cbe1:	89 10                	mov    %edx,(%eax)
					else
					{
						list_del(&buffer->list);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu has been remove from list\n");
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] buffer->pkt->len=%d\n",buffer->pkt->len);
						SV(countSendCtrlPdu)++;
    cbe3:	8b 45 cc             	mov    -0x34(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cbe6:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cbed:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cbf4:	83 80 a0 5a 00 00 01 	addl   $0x1,0x5aa0(%eax)
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
    cbfb:	8b 03                	mov    (%ebx),%eax
    cbfd:	8b 40 50             	mov    0x50(%eax),%eax
    cc00:	29 86 b8 01 00 00    	sub    %eax,0x1b8(%esi)
						amIns->ctrlPduBufferNum--;
    cc06:	83 ae bc 01 00 00 01 	subl   $0x1,0x1bc(%esi)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
    cc0d:	8b 03                	mov    (%ebx),%eax
    cc0f:	8b 48 50             	mov    0x50(%eax),%ecx
    cc12:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cc18:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cc1b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cc21:	89 45 98             	mov    %eax,-0x68(%ebp)
    cc24:	e8 fc ff ff ff       	call   cc25 <PMRLC_TRANSOP_IND+0x3a5>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cc29:	8b 03                	mov    (%ebx),%eax
    cc2b:	8b 50 50             	mov    0x50(%eax),%edx
    cc2e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cc31:	e8 fc ff ff ff       	call   cc32 <PMRLC_TRANSOP_IND+0x3b2>
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    cc36:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cc39:	8b 13                	mov    (%ebx),%edx
    cc3b:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    cc3f:	66 2b 42 50          	sub    0x50(%edx),%ax
    cc43:	66 2b 45 dc          	sub    -0x24(%ebp),%ax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cc47:	8d 55 e0             	lea    -0x20(%ebp),%edx
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
						amIns->ctrlPduBufferNum--;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    cc4a:	66 89 41 0f          	mov    %ax,0xf(%ecx)
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cc4e:	8b 03                	mov    (%ebx),%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cc50:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cc53:	89 54 24 04          	mov    %edx,0x4(%esp)
    cc57:	0f b6 56 03          	movzbl 0x3(%esi),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cc5b:	83 c0 50             	add    $0x50,%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cc5e:	89 14 24             	mov    %edx,(%esp)
    cc61:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cc64:	e8 d7 e7 ff ff       	call   b440 <creat_subhead.isra.0>
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] am instance mIoctrl->statusPduSize is %d, buffer->pkt->len is %d\n", \
						//	mIoctrl->statusPduSize, buffer->pkt->len);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] ctrl data transport\n");
						//fsm_octets_print(buffer->pkt->data,10);
						
						if(buffer->pkt != NULL)
    cc69:	8b 03                	mov    (%ebx),%eax
    cc6b:	85 c0                	test   %eax,%eax
    cc6d:	74 0b                	je     cc7a <PMRLC_TRANSOP_IND+0x3fa>
						{
							fsm_pkt_destroy(buffer->pkt);  //20140922
    cc6f:	e8 fc ff ff ff       	call   cc70 <PMRLC_TRANSOP_IND+0x3f0>
							buffer->pkt = NULL;
    cc74:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						}
						if(buffer != NULL)
    cc7a:	85 db                	test   %ebx,%ebx
    cc7c:	74 07                	je     cc85 <PMRLC_TRANSOP_IND+0x405>
						{
							fsm_mem_free(buffer);  //20140922
    cc7e:	89 d8                	mov    %ebx,%eax
    cc80:	e8 fc ff ff ff       	call   cc81 <PMRLC_TRANSOP_IND+0x401>

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cc85:	8b 47 04             	mov    0x4(%edi),%eax
    cc88:	8d 57 04             	lea    0x4(%edi),%edx
    cc8b:	89 fb                	mov    %edi,%ebx
    cc8d:	83 e8 04             	sub    $0x4,%eax
    cc90:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cc93:	74 3a                	je     cccf <PMRLC_TRANSOP_IND+0x44f>
    cc95:	89 c7                	mov    %eax,%edi
				{
					if( buffer->pkt->len < 128 )
    cc97:	8b 03                	mov    (%ebx),%eax
    cc99:	8b 50 50             	mov    0x50(%eax),%edx
					{
						subHeadLen = 2;
    cc9c:	81 fa 80 00 00 00    	cmp    $0x80,%edx
    cca2:	19 c9                	sbb    %ecx,%ecx
    cca4:	83 c1 03             	add    $0x3,%ecx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    cca7:	01 ca                	add    %ecx,%edx
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
				{
					if( buffer->pkt->len < 128 )
					{
						subHeadLen = 2;
    cca9:	89 4d dc             	mov    %ecx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    ccac:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ccaf:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    ccb3:	39 c2                	cmp    %eax,%edx
    ccb5:	0f 86 1d ff ff ff    	jbe    cbd8 <PMRLC_TRANSOP_IND+0x358>
					{
						fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->statusPduSize is %d, data is %d\n", \
    ccbb:	89 54 24 08          	mov    %edx,0x8(%esp)
    ccbf:	89 44 24 04          	mov    %eax,0x4(%esp)
    ccc3:	c7 04 24 5c 35 00 00 	movl   $0x355c,(%esp)
    ccca:	e8 fc ff ff ff       	call   cccb <PMRLC_TRANSOP_IND+0x44b>
							break;
						}*/
					}
				}
				//
				if( !amIns->statProhTimer )
    cccf:	8b 7e 20             	mov    0x20(%esi),%edi
    ccd2:	85 ff                	test   %edi,%edi
    ccd4:	0f 84 2f 06 00 00    	je     d309 <PMRLC_TRANSOP_IND+0xa89>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    ccda:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ccdd:	8b 48 09             	mov    0x9(%eax),%ecx
    cce0:	0f b7 50 0d          	movzwl 0xd(%eax),%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cce4:	8d 86 9c 01 00 00    	lea    0x19c(%esi),%eax
    ccea:	89 45 c8             	mov    %eax,-0x38(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cced:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
    ccf3:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    ccf6:	0f 84 cf 01 00 00    	je     cecb <PMRLC_TRANSOP_IND+0x64b>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    ccfc:	0f b7 d2             	movzwl %dx,%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    ccff:	01 ca                	add    %ecx,%edx
    cd01:	89 55 dc             	mov    %edx,-0x24(%ebp)
    cd04:	0f 84 c1 01 00 00    	je     cecb <PMRLC_TRANSOP_IND+0x64b>
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    cd0a:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    cd10:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    cd13:	e9 b8 00 00 00       	jmp    cdd0 <PMRLC_TRANSOP_IND+0x550>
						}
						if( subHeadLen < size )
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
    cd18:	ba 78 05 00 00       	mov    $0x578,%edx
    cd1d:	89 f8                	mov    %edi,%eax
    cd1f:	e8 fc ff ff ff       	call   cd20 <PMRLC_TRANSOP_IND+0x4a0>
    cd24:	89 c3                	mov    %eax,%ebx
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
							}

							if( amIns->pduWithoutPoll >= amIns->pollPDU || amIns->byteWithoutPoll >= amIns->pollBYTE )
    cd26:	0f b7 86 f6 22 00 00 	movzwl 0x22f6(%esi),%eax
    cd2d:	66 39 86 fc 22 00 00 	cmp    %ax,0x22fc(%esi)
    cd34:	73 10                	jae    cd46 <PMRLC_TRANSOP_IND+0x4c6>
    cd36:	0f b7 96 f8 22 00 00 	movzwl 0x22f8(%esi),%edx
    cd3d:	66 39 96 fe 22 00 00 	cmp    %dx,0x22fe(%esi)
    cd44:	72 09                	jb     cd4f <PMRLC_TRANSOP_IND+0x4cf>
							{
								rlc_poll(amIns, pkp);
    cd46:	89 da                	mov    %ebx,%edx
    cd48:	89 f0                	mov    %esi,%eax
    cd4a:	e8 fc ff ff ff       	call   cd4b <PMRLC_TRANSOP_IND+0x4cb>
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
    cd4f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cd52:	8b 4b 50             	mov    0x50(%ebx),%ecx
    cd55:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    cd5b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cd61:	89 45 94             	mov    %eax,-0x6c(%ebp)
    cd64:	e8 fc ff ff ff       	call   cd65 <PMRLC_TRANSOP_IND+0x4e5>
							fsm_skb_put( pkptr,pkp->len);
    cd69:	8b 53 50             	mov    0x50(%ebx),%edx
    cd6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cd6f:	e8 fc ff ff ff       	call   cd70 <PMRLC_TRANSOP_IND+0x4f0>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cd74:	8d 43 50             	lea    0x50(%ebx),%eax
    cd77:	89 45 c4             	mov    %eax,-0x3c(%ebp)
								rlc_poll(amIns, pkp);
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
    cd7a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    cd7d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cd80:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cd83:	89 44 24 04          	mov    %eax,0x4(%esp)
    cd87:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    cd8b:	89 04 24             	mov    %eax,(%esp)
    cd8e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    cd91:	e8 aa e6 ff ff       	call   b440 <creat_subhead.isra.0>
							size -= pkp->len + subHeadLen;
    cd96:	8b 53 50             	mov    0x50(%ebx),%edx
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND] am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, pkp->len);

							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
    cd99:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    cda0:	01 
							amIns->byteWithoutPoll += pkp->len;  //??
    cda1:	8b 43 50             	mov    0x50(%ebx),%eax
    cda4:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    cdab:	89 d8                	mov    %ebx,%eax
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
							size -= pkp->len + subHeadLen;
    cdad:	29 55 dc             	sub    %edx,-0x24(%ebp)
    cdb0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    cdb3:	29 4d dc             	sub    %ecx,-0x24(%ebp)
							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
							amIns->byteWithoutPoll += pkp->len;  //??
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    cdb6:	e8 fc ff ff ff       	call   cdb7 <PMRLC_TRANSOP_IND+0x537>
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    cdbb:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    cdc1:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    cdc4:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    cdca:	0f 84 f8 00 00 00    	je     cec8 <PMRLC_TRANSOP_IND+0x648>
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
    cdd0:	0f bf 97 94 00 00 00 	movswl 0x94(%edi),%edx
    cdd7:	89 f0                	mov    %esi,%eax
    cdd9:	e8 fc ff ff ff       	call   cdda <PMRLC_TRANSOP_IND+0x55a>
    cdde:	84 c0                	test   %al,%al
    cde0:	74 d9                	je     cdbb <PMRLC_TRANSOP_IND+0x53b>
					{
						if( amBuffer->pkt->len < 128 )
    cde2:	8b 07                	mov    (%edi),%eax
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cde4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
    cde7:	8b 40 50             	mov    0x50(%eax),%eax
						{
							subHeadLen = 2;
    cdea:	3d 80 00 00 00       	cmp    $0x80,%eax
    cdef:	19 d2                	sbb    %edx,%edx
    cdf1:	83 c2 03             	add    $0x3,%edx
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cdf4:	39 ca                	cmp    %ecx,%edx
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
						{
							subHeadLen = 2;
    cdf6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cdf9:	0f 83 a1 04 00 00    	jae    d2a0 <PMRLC_TRANSOP_IND+0xa20>
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
    cdff:	89 ca                	mov    %ecx,%edx
    ce01:	2b 55 d4             	sub    -0x2c(%ebp),%edx
    ce04:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    ce0a:	0f 87 08 ff ff ff    	ja     cd18 <PMRLC_TRANSOP_IND+0x498>
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
							}
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
    ce10:	89 f8                	mov    %edi,%eax
    ce12:	e8 fc ff ff ff       	call   ce13 <PMRLC_TRANSOP_IND+0x593>
    ce17:	89 c3                	mov    %eax,%ebx
    ce19:	e9 08 ff ff ff       	jmp    cd26 <PMRLC_TRANSOP_IND+0x4a6>
    ce1e:	66 90                	xchg   %ax,%ax
				}
			}
			break;

		case UM_MODE:
			if(insptru == NULL)
    ce20:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    ce23:	85 ff                	test   %edi,%edi
    ce25:	0f 84 b5 fb ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ce2b:	8b 75 d8             	mov    -0x28(%ebp),%esi
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    ce2e:	81 7f 20 80 00 00 00 	cmpl   $0x80,0x20(%edi)
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ce35:	8b 4e 03             	mov    0x3(%esi),%ecx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    ce38:	19 c0                	sbb    %eax,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ce3a:	0f b7 56 07          	movzwl 0x7(%esi),%edx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    ce3e:	83 c0 03             	add    $0x3,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ce41:	01 ca                	add    %ecx,%edx
    ce43:	39 d0                	cmp    %edx,%eax
    ce45:	0f 83 cd 03 00 00    	jae    d218 <PMRLC_TRANSOP_IND+0x998>
			{
				//pkp = rlc_UM_segment(umTxIns , mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);//mIoctrl->txQueueHeader,  /20140726
				if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen > MAX_PDU_SIZE )
    ce4b:	29 c2                	sub    %eax,%edx
    ce4d:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    ce53:	0f 86 af 03 00 00    	jbe    d208 <PMRLC_TRANSOP_IND+0x988>
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
    ce59:	ba 78 05 00 00       	mov    $0x578,%edx
    ce5e:	89 f8                	mov    %edi,%eax
    ce60:	e8 fc ff ff ff       	call   ce61 <PMRLC_TRANSOP_IND+0x5e1>
    ce65:	89 c6                	mov    %eax,%esi
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
    ce67:	85 f6                	test   %esi,%esi
    ce69:	0f 84 e2 04 00 00    	je     d351 <PMRLC_TRANSOP_IND+0xad1>
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    ce6f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ce72:	8b 4e 50             	mov    0x50(%esi),%ecx
    ce75:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    ce7b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ce81:	89 45 9c             	mov    %eax,-0x64(%ebp)
    ce84:	e8 fc ff ff ff       	call   ce85 <PMRLC_TRANSOP_IND+0x605>
				fsm_skb_put( pkptr,pkp->len);
    ce89:	8b 56 50             	mov    0x50(%esi),%edx
    ce8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ce8f:	e8 fc ff ff ff       	call   ce90 <PMRLC_TRANSOP_IND+0x610>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ce94:	8d 46 50             	lea    0x50(%esi),%eax
    ce97:	89 45 dc             	mov    %eax,-0x24(%ebp)
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
				fsm_skb_put( pkptr,pkp->len);
				creat_subhead(pkp, &ptr,  &preptr, umTxIns->lcid, &data);
    ce9a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ce9d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cea0:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cea3:	89 44 24 04          	mov    %eax,0x4(%esp)
    cea7:	0f b6 47 03          	movzbl 0x3(%edi),%eax
    ceab:	89 04 24             	mov    %eax,(%esp)
    ceae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ceb1:	e8 8a e5 ff ff       	call   b440 <creat_subhead.isra.0>

				fsm_pkt_destroy(pkp);  //20140922
    ceb6:	89 f0                	mov    %esi,%eax
    ceb8:	e8 fc ff ff ff       	call   ceb9 <PMRLC_TRANSOP_IND+0x639>
				pkp = NULL;
				break;
    cebd:	e9 1e fb ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
    cec2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    cec8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    cecb:	8b 55 d8             	mov    -0x28(%ebp),%edx
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cece:	89 f0                	mov    %esi,%eax
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    ced0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ced3:	8b 52 03             	mov    0x3(%edx),%edx
    ced6:	0f b7 79 07          	movzwl 0x7(%ecx),%edi
    ceda:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cedd:	0f bf 56 2e          	movswl 0x2e(%esi),%edx
    cee1:	e8 fc ff ff ff       	call   cee2 <PMRLC_TRANSOP_IND+0x662>
    cee6:	84 c0                	test   %al,%al
    cee8:	0f 84 f2 fa ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    ceee:	0f b7 ff             	movzwl %di,%edi
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cef1:	03 7d dc             	add    -0x24(%ebp),%edi
    cef4:	0f 84 e6 fa ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
    cefa:	8d 46 44             	lea    0x44(%esi),%eax
    cefd:	39 46 44             	cmp    %eax,0x44(%esi)
    cf00:	0f 84 da fa ff ff    	je     c9e0 <PMRLC_TRANSOP_IND+0x160>
			//if(((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
			{
				//fsm_printf("[RLC][PMRLC_TRANSOP_IND] run to am sdu transport\n");
				if( amIns->amSduBufferSize < 128 )
				{
					subHeadLen = 2;
    cf06:	81 7e 4c 80 00 00 00 	cmpl   $0x80,0x4c(%esi)
    cf0d:	19 c0                	sbb    %eax,%eax
    cf0f:	83 c0 03             	add    $0x3,%eax
				}
				else
				{
					subHeadLen = 3;
				}
				if( size > subHeadLen )
    cf12:	39 f8                	cmp    %edi,%eax
    cf14:	0f 83 b8 03 00 00    	jae    d2d2 <PMRLC_TRANSOP_IND+0xa52>
				{
					if( size - subHeadLen > MAX_PDU_SIZE )
    cf1a:	29 c7                	sub    %eax,%edi
    cf1c:	81 ff 78 05 00 00    	cmp    $0x578,%edi
    cf22:	0f 86 9a 03 00 00    	jbe    d2c2 <PMRLC_TRANSOP_IND+0xa42>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
    cf28:	ba 78 05 00 00       	mov    $0x578,%edx
    cf2d:	89 f0                	mov    %esi,%eax
    cf2f:	e8 fc ff ff ff       	call   cf30 <PMRLC_TRANSOP_IND+0x6b0>
    cf34:	89 c7                	mov    %eax,%edi
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
    cf36:	85 ff                	test   %edi,%edi
    cf38:	0f 84 02 04 00 00    	je     d340 <PMRLC_TRANSOP_IND+0xac0>
						//fsm_printf("[RLC] pduWithoutPoll is %d\n",amIns->pduWithoutPoll);
						//fsm_printf("[RLC] byteWithoutPoll is %d\n",amIns->byteWithoutPoll);
						rlc_poll(amIns,pkp);
					}*/
					//printk("[RLC][PMRLC_TRANSOP_IND] size=%d, pkp->len=%d, subHeadLen=%d\n",size,pkp->len,subHeadLen);
					fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    cf3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf41:	8b 4f 50             	mov    0x50(%edi),%ecx
    cf44:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    cf4a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cf50:	89 45 90             	mov    %eax,-0x70(%ebp)
    cf53:	e8 fc ff ff ff       	call   cf54 <PMRLC_TRANSOP_IND+0x6d4>
					if(pkptr->tail+pkp->len > pkptr->end)
    cf58:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    cf5b:	8b 57 50             	mov    0x50(%edi),%edx
    cf5e:	89 d0                	mov    %edx,%eax
    cf60:	03 81 a0 00 00 00    	add    0xa0(%ecx),%eax
    cf66:	39 81 a4 00 00 00    	cmp    %eax,0xa4(%ecx)
    cf6c:	0f 82 10 fb ff ff    	jb     ca82 <PMRLC_TRANSOP_IND+0x202>
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
    cf72:	89 c8                	mov    %ecx,%eax
    cf74:	e8 fc ff ff ff       	call   cf75 <PMRLC_TRANSOP_IND+0x6f5>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cf79:	8d 47 50             	lea    0x50(%edi),%eax
    cf7c:	89 45 dc             	mov    %eax,-0x24(%ebp)
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
    cf7f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    cf82:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cf85:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cf88:	89 44 24 04          	mov    %eax,0x4(%esp)
    cf8c:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    cf90:	89 04 24             	mov    %eax,(%esp)
    cf93:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cf96:	e8 a5 e4 ff ff       	call   b440 <creat_subhead.isra.0>
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    cf9b:	0f bf 86 64 12 00 00 	movswl 0x1264(%esi),%eax
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
    cfa2:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    cfa9:	01 
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    cfaa:	83 c0 01             	add    $0x1,%eax
    cfad:	89 c2                	mov    %eax,%edx
    cfaf:	c1 fa 1f             	sar    $0x1f,%edx
    cfb2:	c1 ea 16             	shr    $0x16,%edx
    cfb5:	01 d0                	add    %edx,%eax
    cfb7:	25 ff 03 00 00       	and    $0x3ff,%eax
    cfbc:	29 d0                	sub    %edx,%eax

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    cfbe:	ba 0a 00 00 00       	mov    $0xa,%edx
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    cfc3:	66 89 86 64 12 00 00 	mov    %ax,0x1264(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
    cfca:	8b 47 50             	mov    0x50(%edi),%eax
    cfcd:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    cfd4:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    cfda:	e8 fc ff ff ff       	call   cfdb <PMRLC_TRANSOP_IND+0x75b>

					fsm_pkt_destroy(pkp);  //20140922
    cfdf:	89 f8                	mov    %edi,%eax
    cfe1:	e8 fc ff ff ff       	call   cfe2 <PMRLC_TRANSOP_IND+0x762>
    cfe6:	e9 f5 f9 ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
    cfeb:	90                   	nop
    cfec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    cff0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    cff3:	85 c0                	test   %eax,%eax
    cff5:	0f 84 42 f9 ff ff    	je     c93d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    cffb:	8b 5d e0             	mov    -0x20(%ebp),%ebx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    cffe:	8d 78 0c             	lea    0xc(%eax),%edi
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d001:	8b 56 03             	mov    0x3(%esi),%edx
    d004:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    d008:	01 d3                	add    %edx,%ebx
    d00a:	01 d9                	add    %ebx,%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d00c:	31 db                	xor    %ebx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d00e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d011:	8b 48 0c             	mov    0xc(%eax),%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d014:	39 cf                	cmp    %ecx,%edi
    d016:	74 5c                	je     d074 <PMRLC_TRANSOP_IND+0x7f4>
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
    d018:	8b 41 fc             	mov    -0x4(%ecx),%eax
    d01b:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d01e:	29 c2                	sub    %eax,%edx
    d020:	78 52                	js     d074 <PMRLC_TRANSOP_IND+0x7f4>
    d022:	89 75 c8             	mov    %esi,-0x38(%ebp)
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d025:	83 e9 04             	sub    $0x4,%ecx
    d028:	31 f6                	xor    %esi,%esi
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
    d02a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    d031:	eb 20                	jmp    d053 <PMRLC_TRANSOP_IND+0x7d3>
    d033:	90                   	nop
    d034:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d038:	8b 41 04             	mov    0x4(%ecx),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
			{
				if(txBuffer->pkt->len < 127)
				{
					(*sevNum)++;
    d03b:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d03e:	39 c7                	cmp    %eax,%edi
    d040:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d043:	74 20                	je     d065 <PMRLC_TRANSOP_IND+0x7e5>
		{
			size -= txBuffer->pkt->len;
    d045:	8b 40 fc             	mov    -0x4(%eax),%eax
    d048:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d04b:	29 c2                	sub    %eax,%edx
    d04d:	0f 88 e5 01 00 00    	js     d238 <PMRLC_TRANSOP_IND+0x9b8>
			{
				if(txBuffer->pkt->len < 127)
    d053:	83 f8 7e             	cmp    $0x7e,%eax
    d056:	76 e0                	jbe    d038 <PMRLC_TRANSOP_IND+0x7b8>
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d058:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d05b:	83 c3 01             	add    $0x1,%ebx
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d05e:	39 c7                	cmp    %eax,%edi
    d060:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d063:	75 e0                	jne    d045 <PMRLC_TRANSOP_IND+0x7c5>
    d065:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    d068:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d06b:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d06e:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d071:	8d 1c 48             	lea    (%eax,%ecx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d074:	01 5d dc             	add    %ebx,-0x24(%ebp)
			break;
    d077:	e9 c1 f8 ff ff       	jmp    c93d <PMRLC_TRANSOP_IND+0xbd>
    d07c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			//fsm_printf("[RLC][PMRLC_TRANSOP_IND] um instance(lcid is %d)'s buffer's subhead is %d \n",umTxIns->lcid,subhead);
			break;

		case AM_MODE:
			if(insptru == NULL)
    d080:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d083:	85 ff                	test   %edi,%edi
    d085:	0f 84 b2 f8 ff ff    	je     c93d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d08b:	8b 56 03             	mov    0x3(%esi),%edx
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d08e:	8d 9f 9c 01 00 00    	lea    0x19c(%edi),%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d094:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d098:	8b 4d e0             	mov    -0x20(%ebp),%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d09b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    d0a2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d0a9:	01 d0                	add    %edx,%eax
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d0ab:	8b 56 09             	mov    0x9(%esi),%edx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d0ae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    d0b1:	0f b7 46 0d          	movzwl 0xd(%esi),%eax
    d0b5:	01 d1                	add    %edx,%ecx
    d0b7:	01 c1                	add    %eax,%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d0b9:	0f b7 46 11          	movzwl 0x11(%esi),%eax
    d0bd:	01 c8                	add    %ecx,%eax
    d0bf:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    d0c3:	01 c8                	add    %ecx,%eax
    d0c5:	89 4d bc             	mov    %ecx,-0x44(%ebp)
    d0c8:	8b 8f 9c 01 00 00    	mov    0x19c(%edi),%ecx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d0ce:	03 45 d4             	add    -0x2c(%ebp),%eax
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d0d1:	39 cb                	cmp    %ecx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d0d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d0d6:	74 78                	je     d150 <PMRLC_TRANSOP_IND+0x8d0>
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d0d8:	8b 81 64 ff ff ff    	mov    -0x9c(%ecx),%eax
    d0de:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d0e1:	29 c2                	sub    %eax,%edx
    d0e3:	0f 88 4c 02 00 00    	js     d335 <PMRLC_TRANSOP_IND+0xab5>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d0e9:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
    d0ef:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
    d0f2:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
    d0f5:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d0f8:	31 f6                	xor    %esi,%esi
    d0fa:	89 7d a8             	mov    %edi,-0x58(%ebp)
    d0fd:	31 ff                	xor    %edi,%edi
    d0ff:	eb 2b                	jmp    d12c <PMRLC_TRANSOP_IND+0x8ac>
    d101:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    d108:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
			size -= amBuffer->pkt->len;
			if(0 <= size)
			{
				if(amBuffer->pkt->len  <  128)
				{
					(*sevNum)++;
    d10e:	83 c7 01             	add    $0x1,%edi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d111:	39 c3                	cmp    %eax,%ebx
    d113:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d119:	74 29                	je     d144 <PMRLC_TRANSOP_IND+0x8c4>
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d11b:	8b 80 64 ff ff ff    	mov    -0x9c(%eax),%eax
    d121:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d124:	29 c2                	sub    %eax,%edx
    d126:	0f 88 24 01 00 00    	js     d250 <PMRLC_TRANSOP_IND+0x9d0>
			{
				if(amBuffer->pkt->len  <  128)
    d12c:	83 f8 7f             	cmp    $0x7f,%eax
    d12f:	76 d7                	jbe    d108 <PMRLC_TRANSOP_IND+0x888>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d131:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d137:	83 c6 01             	add    $0x1,%esi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d13a:	39 c3                	cmp    %eax,%ebx
    d13c:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d142:	75 d7                	jne    d11b <PMRLC_TRANSOP_IND+0x89b>
    d144:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d147:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d14a:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d14d:	8b 7d a8             	mov    -0x58(%ebp),%edi
    d150:	8b 8f b0 01 00 00    	mov    0x1b0(%edi),%ecx
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d156:	8d 9f b0 01 00 00    	lea    0x1b0(%edi),%ebx

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
    d15c:	31 ff                	xor    %edi,%edi
    d15e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d165:	39 cb                	cmp    %ecx,%ebx
    d167:	74 46                	je     d1af <PMRLC_TRANSOP_IND+0x92f>
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d169:	8b 41 fc             	mov    -0x4(%ecx),%eax
			if(0 <= size)
    d16c:	8b 55 bc             	mov    -0x44(%ebp),%edx
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d16f:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d172:	29 c2                	sub    %eax,%edx
    d174:	78 39                	js     d1af <PMRLC_TRANSOP_IND+0x92f>
    d176:	89 75 bc             	mov    %esi,-0x44(%ebp)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d179:	83 e9 04             	sub    $0x4,%ecx
    d17c:	31 f6                	xor    %esi,%esi
    d17e:	eb 17                	jmp    d197 <PMRLC_TRANSOP_IND+0x917>
    d180:	8b 41 04             	mov    0x4(%ecx),%eax
			size -= statBuffer->pkt->len;
			if(0 <= size)
			{
				if(statBuffer->pkt->len< 128)
				{
					(*sevNum)++;
    d183:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d186:	39 c3                	cmp    %eax,%ebx
    d188:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d18b:	74 1c                	je     d1a9 <PMRLC_TRANSOP_IND+0x929>
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d18d:	8b 40 fc             	mov    -0x4(%eax),%eax
    d190:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d193:	29 c2                	sub    %eax,%edx
    d195:	78 12                	js     d1a9 <PMRLC_TRANSOP_IND+0x929>
			{
				if(statBuffer->pkt->len< 128)
    d197:	83 f8 7f             	cmp    $0x7f,%eax
    d19a:	76 e4                	jbe    d180 <PMRLC_TRANSOP_IND+0x900>
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d19c:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					( *fifNum)++;
    d19f:	83 c7 01             	add    $0x1,%edi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d1a2:	39 c3                	cmp    %eax,%ebx
    d1a4:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d1a7:	75 e4                	jne    d18d <PMRLC_TRANSOP_IND+0x90d>
    d1a9:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d1ac:	8b 75 bc             	mov    -0x44(%ebp),%esi
    d1af:	03 7d c8             	add    -0x38(%ebp),%edi
    d1b2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d1b5:	03 45 c4             	add    -0x3c(%ebp),%eax
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d1b8:	8d 14 7f             	lea    (%edi,%edi,2),%edx
    d1bb:	8d 04 42             	lea    (%edx,%eax,2),%eax
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
			check_stat_num(amIns,mIoctrl->statusPduSize, &sevNum, &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d1be:	03 45 dc             	add    -0x24(%ebp),%eax
			//fsm_printf("am instance(lcid is %d)'s status buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{				
				subhead += 2;
    d1c1:	8d 50 02             	lea    0x2(%eax),%edx
    d1c4:	83 c0 03             	add    $0x3,%eax
    d1c7:	83 7d d4 7f          	cmpl   $0x7f,-0x2c(%ebp)
    d1cb:	0f 46 c2             	cmovbe %edx,%eax
    d1ce:	89 45 dc             	mov    %eax,-0x24(%ebp)
    d1d1:	e9 67 f7 ff ff       	jmp    c93d <PMRLC_TRANSOP_IND+0xbd>
    d1d6:	66 90                	xchg   %ax,%ax
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			break;

		case UM_MODE:
			if(insptru == NULL)
    d1d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d1db:	85 c0                	test   %eax,%eax
    d1dd:	0f 84 5a f7 ff ff    	je     c93d <PMRLC_TRANSOP_IND+0xbd>
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d1e3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d1e6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d1e9:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d1ed:	03 46 03             	add    0x3(%esi),%eax
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d1f0:	83 c2 02             	add    $0x2,%edx
    d1f3:	83 c1 03             	add    $0x3,%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d1f6:	01 45 e0             	add    %eax,-0x20(%ebp)
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d1f9:	83 f8 7f             	cmp    $0x7f,%eax
    d1fc:	0f 47 d1             	cmova  %ecx,%edx
    d1ff:	89 55 dc             	mov    %edx,-0x24(%ebp)
    d202:	e9 36 f7 ff ff       	jmp    c93d <PMRLC_TRANSOP_IND+0xbd>
    d207:	90                   	nop
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
				}
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
    d208:	89 f8                	mov    %edi,%eax
    d20a:	e8 fc ff ff ff       	call   d20b <PMRLC_TRANSOP_IND+0x98b>
    d20f:	89 c6                	mov    %eax,%esi
    d211:	e9 51 fc ff ff       	jmp    ce67 <PMRLC_TRANSOP_IND+0x5e7>
    d216:	66 90                	xchg   %ax,%ax
				pkp = NULL;
				break;
			}
			else
			{
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
    d218:	8b 13                	mov    (%ebx),%edx
    d21a:	03 42 50             	add    0x50(%edx),%eax
    d21d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    d221:	c7 04 24 04 35 00 00 	movl   $0x3504,(%esp)
    d228:	89 44 24 08          	mov    %eax,0x8(%esp)
    d22c:	e8 fc ff ff ff       	call   d22d <PMRLC_TRANSOP_IND+0x9ad>
				break;
    d231:	e9 aa f7 ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
    d236:	66 90                	xchg   %ax,%ax
    d238:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d23b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d23e:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d241:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d244:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d247:	01 5d dc             	add    %ebx,-0x24(%ebp)
    d24a:	e9 ee f6 ff ff       	jmp    c93d <PMRLC_TRANSOP_IND+0xbd>
    d24f:	90                   	nop
    d250:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d253:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d256:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d259:	8b 7d a8             	mov    -0x58(%ebp),%edi
					(*fifNum)++;
				}
			}
			else
			{
				if(( size + amBuffer->pkt->len + 2 ) < 128)
    d25c:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    d260:	83 f8 7f             	cmp    $0x7f,%eax
    d263:	77 09                	ja     d26e <PMRLC_TRANSOP_IND+0x9ee>
				{
					(*sevNum)++;
    d265:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
    d269:	e9 e2 fe ff ff       	jmp    d150 <PMRLC_TRANSOP_IND+0x8d0>
				}
				else
				{
					(*fifNum)++;
    d26e:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
    d272:	e9 d9 fe ff ff       	jmp    d150 <PMRLC_TRANSOP_IND+0x8d0>
		}
	}
		
	if(0 == pkptr->len)
	{
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
    d277:	c7 04 24 a8 36 00 00 	movl   $0x36a8,(%esp)
    d27e:	e8 fc ff ff ff       	call   d27f <PMRLC_TRANSOP_IND+0x9ff>
		SV(bufferReqTimer) = 0;
    d283:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d286:	c7 80 34 37 00 00 00 	movl   $0x0,0x3734(%eax)
    d28d:	00 00 00 
		fsm_data_destroy(hptr);
    d290:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d293:	e8 fc ff ff ff       	call   d294 <PMRLC_TRANSOP_IND+0xa14>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d298:	83 c4 70             	add    $0x70,%esp
    d29b:	5b                   	pop    %ebx
    d29c:	5e                   	pop    %esi
    d29d:	5f                   	pop    %edi
    d29e:	5d                   	pop    %ebp
    d29f:	c3                   	ret    
							fsm_pkt_destroy(pkp);  //20140922
							pkp = NULL;
						}
						else
						{
							fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] break:am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, amBuffer->pkt->len+subHeadLen);
    d2a0:	03 45 d4             	add    -0x2c(%ebp),%eax
    d2a3:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    d2a6:	c7 04 24 b4 35 00 00 	movl   $0x35b4,(%esp)
    d2ad:	89 44 24 08          	mov    %eax,0x8(%esp)
    d2b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d2b4:	89 44 24 04          	mov    %eax,0x4(%esp)
    d2b8:	e8 fc ff ff ff       	call   d2b9 <PMRLC_TRANSOP_IND+0xa39>
							break;
    d2bd:	e9 09 fc ff ff       	jmp    cecb <PMRLC_TRANSOP_IND+0x64b>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
    d2c2:	89 fa                	mov    %edi,%edx
    d2c4:	89 f0                	mov    %esi,%eax
    d2c6:	e8 fc ff ff ff       	call   d2c7 <PMRLC_TRANSOP_IND+0xa47>
    d2cb:	89 c7                	mov    %eax,%edi
    d2cd:	e9 64 fc ff ff       	jmp    cf36 <PMRLC_TRANSOP_IND+0x6b6>
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
    d2d2:	8b 13                	mov    (%ebx),%edx
					fsm_pkt_destroy(pkp);  //20140922
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
    d2d4:	8b 75 d8             	mov    -0x28(%ebp),%esi
    d2d7:	03 42 50             	add    0x50(%edx),%eax
    d2da:	89 44 24 08          	mov    %eax,0x8(%esp)
    d2de:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d2e2:	03 46 03             	add    0x3(%esi),%eax
    d2e5:	c7 04 24 3c 36 00 00 	movl   $0x363c,(%esp)
    d2ec:	89 44 24 04          	mov    %eax,0x4(%esp)
    d2f0:	e8 fc ff ff ff       	call   d2f1 <PMRLC_TRANSOP_IND+0xa71>
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
					break;
    d2f5:	e9 e6 f6 ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
	nump = (u32*)hptr;
	num = *nump;
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
	{
		fsm_data_destroy(hptr);
    d2fa:	89 d0                	mov    %edx,%eax
    d2fc:	e8 fc ff ff ff       	call   d2fd <PMRLC_TRANSOP_IND+0xa7d>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d301:	83 c4 70             	add    $0x70,%esp
    d304:	5b                   	pop    %ebx
    d305:	5e                   	pop    %esi
    d306:	5f                   	pop    %edi
    d307:	5d                   	pop    %ebp
    d308:	c3                   	ret    
				}
				//
				if( !amIns->statProhTimer )
				{
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] the statProhTimer start\n");
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    d309:	8b 56 24             	mov    0x24(%esi),%edx
    d30c:	8b 46 28             	mov    0x28(%esi),%eax
    d30f:	e8 fc ff ff ff       	call   d310 <PMRLC_TRANSOP_IND+0xa90>
    d314:	89 46 20             	mov    %eax,0x20(%esi)
    d317:	e9 be f9 ff ff       	jmp    ccda <PMRLC_TRANSOP_IND+0x45a>
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
	{
		send_msg3(pkptr);
    d31c:	e8 fc ff ff ff       	call   d31d <PMRLC_TRANSOP_IND+0xa9d>
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
    d321:	c7 04 24 dc 36 00 00 	movl   $0x36dc,(%esp)
    d328:	e8 fc ff ff ff       	call   d329 <PMRLC_TRANSOP_IND+0xaa9>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d32d:	83 c4 70             	add    $0x70,%esp
    d330:	5b                   	pop    %ebx
    d331:	5e                   	pop    %esi
    d332:	5f                   	pop    %edi
    d333:	5d                   	pop    %ebp
    d334:	c3                   	ret    
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d335:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d338:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d33b:	e9 1c ff ff ff       	jmp    d25c <PMRLC_TRANSOP_IND+0x9dc>
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
					{
						printk("[RLC][PMRLC_TRANSOP_IND][AM] pkp == NULL\n");
    d340:	c7 04 24 10 36 00 00 	movl   $0x3610,(%esp)
    d347:	e8 fc ff ff ff       	call   d348 <PMRLC_TRANSOP_IND+0xac8>
						break;
    d34c:	e9 8f f6 ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
    d351:	c7 04 24 d8 34 00 00 	movl   $0x34d8,(%esp)
    d358:	e8 fc ff ff ff       	call   d359 <PMRLC_TRANSOP_IND+0xad9>
					break;
    d35d:	e9 7e f6 ff ff       	jmp    c9e0 <PMRLC_TRANSOP_IND+0x160>
    d362:	90                   	nop
    d363:	90                   	nop
    d364:	90                   	nop
    d365:	90                   	nop
    d366:	90                   	nop
    d367:	90                   	nop
    d368:	90                   	nop
    d369:	90                   	nop
    d36a:	90                   	nop
    d36b:	90                   	nop
    d36c:	90                   	nop
    d36d:	90                   	nop
    d36e:	90                   	nop
    d36f:	90                   	nop

0000d370 <get_AmPduhdExt>:
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d370:	55                   	push   %ebp
    d371:	89 e5                	mov    %esp,%ebp
    d373:	83 ec 14             	sub    $0x14,%esp
    d376:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d379:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d37c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d37f:	e8 fc ff ff ff       	call   d380 <get_AmPduhdExt+0x10>
    d384:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d387:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d38b:	89 d6                	mov    %edx,%esi
    d38d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d38f:	74 0f                	je     d3a0 <get_AmPduhdExt+0x30>
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
	}
	return count;
}
    d391:	89 d8                	mov    %ebx,%eax
    d393:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d396:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d399:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d39c:	89 ec                	mov    %ebp,%esp
    d39e:	5d                   	pop    %ebp
    d39f:	c3                   	ret    
u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d3a0:	8b 02                	mov    (%edx),%eax
    d3a2:	b9 02 00 00 00       	mov    $0x2,%ecx

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d3a7:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d3ad:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d3b3:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d3b6:	e8 fc ff ff ff       	call   d3b7 <get_AmPduhdExt+0x47>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d3bb:	8b 06                	mov    (%esi),%eax
    d3bd:	ba 02 00 00 00       	mov    $0x2,%edx
    d3c2:	e8 fc ff ff ff       	call   d3c3 <get_AmPduhdExt+0x53>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d3c7:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d3cb:	0f b7 d3             	movzwl %bx,%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
    d3ce:	83 c3 01             	add    $0x1,%ebx
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d3d1:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d3d4:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d3da:	66 25 ff 7f          	and    $0x7fff,%ax
    d3de:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d3e3:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d3e8:	89 f2                	mov    %esi,%edx
    d3ea:	89 3c 24             	mov    %edi,(%esp)
    d3ed:	e8 fc ff ff ff       	call   d3ee <get_AmPduhdExt+0x7e>
	}
	return count;
}
    d3f2:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d3f5:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d3f8:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d3fa:	89 d8                	mov    %ebx,%eax
    d3fc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d3ff:	89 ec                	mov    %ebp,%esp
    d401:	5d                   	pop    %ebp
    d402:	c3                   	ret    
    d403:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d409:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000d410 <get_UmPduhdExt>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d410:	55                   	push   %ebp
    d411:	89 e5                	mov    %esp,%ebp
    d413:	83 ec 18             	sub    $0x18,%esp
    d416:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d419:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d41c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d41f:	e8 fc ff ff ff       	call   d420 <get_UmPduhdExt+0x10>
    d424:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d427:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d42b:	89 d6                	mov    %edx,%esi
    d42d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d42f:	74 0f                	je     d440 <get_UmPduhdExt+0x30>

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
	}
	return count;
}
    d431:	89 d8                	mov    %ebx,%eax
    d433:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d436:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d439:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d43c:	89 ec                	mov    %ebp,%esp
    d43e:	5d                   	pop    %ebp
    d43f:	c3                   	ret    
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d440:	0f b7 c1             	movzwl %cx,%eax
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d443:	b9 02 00 00 00       	mov    $0x2,%ecx
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d448:	89 45 ec             	mov    %eax,-0x14(%ebp)
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d44b:	8b 02                	mov    (%edx),%eax
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
    d44d:	83 c3 01             	add    $0x1,%ebx

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d450:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d456:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d45c:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d45f:	e8 fc ff ff ff       	call   d460 <get_UmPduhdExt+0x50>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d464:	8b 06                	mov    (%esi),%eax
    d466:	ba 02 00 00 00       	mov    $0x2,%edx
    d46b:	e8 fc ff ff ff       	call   d46c <get_UmPduhdExt+0x5c>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d470:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d474:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d477:	8b 55 ec             	mov    -0x14(%ebp),%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
    d47a:	66 25 ff 7f          	and    $0x7fff,%ax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d47e:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d484:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d489:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d48e:	89 f2                	mov    %esi,%edx
    d490:	89 3c 24             	mov    %edi,(%esp)
    d493:	e8 fc ff ff ff       	call   d494 <get_UmPduhdExt+0x84>
	}
	return count;
}
    d498:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d49b:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d49e:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d4a0:	89 d8                	mov    %ebx,%eax
    d4a2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d4a5:	89 ec                	mov    %ebp,%esp
    d4a7:	5d                   	pop    %ebp
    d4a8:	c3                   	ret    
    d4a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000d4b0 <clear_left_pdu>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void clear_left_pdu(struct pduLeft *pdu_left)
{	
    d4b0:	55                   	push   %ebp
    d4b1:	89 e5                	mov    %esp,%ebp
    d4b3:	53                   	push   %ebx
    d4b4:	e8 fc ff ff ff       	call   d4b5 <clear_left_pdu+0x5>
    d4b9:	89 c3                	mov    %eax,%ebx
	pdu_left->SN_Left = -1;
    d4bb:	66 c7 40 02 ff ff    	movw   $0xffff,0x2(%eax)
	pdu_left->SN5_Left = -1;
    d4c1:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
	if(pdu_left->sduLeft != NULL)
    d4c6:	8b 40 04             	mov    0x4(%eax),%eax
    d4c9:	85 c0                	test   %eax,%eax
    d4cb:	74 0c                	je     d4d9 <clear_left_pdu+0x29>
	{
	    fsm_pkt_destroy(pdu_left->sduLeft);
    d4cd:	e8 fc ff ff ff       	call   d4ce <clear_left_pdu+0x1e>
		pdu_left->sduLeft = NULL;
    d4d2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	}               
}
    d4d9:	5b                   	pop    %ebx
    d4da:	5d                   	pop    %ebp
    d4db:	c3                   	ret    
    d4dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000d4e0 <rlc_AM_segment>:
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d4e0:	55                   	push   %ebp
    d4e1:	89 e5                	mov    %esp,%ebp
    d4e3:	57                   	push   %edi
    d4e4:	56                   	push   %esi
    d4e5:	53                   	push   %ebx
    d4e6:	83 ec 38             	sub    $0x38,%esp
    d4e9:	e8 fc ff ff ff       	call   d4ea <rlc_AM_segment+0xa>
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d4ee:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d4f2:	89 c7                	mov    %eax,%edi

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d4f4:	8b 40 50             	mov    0x50(%eax),%eax
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d4f7:	66 81 e6 00 fc       	and    $0xfc00,%si
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d4fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d4ff:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
    d503:	66 25 ff 03          	and    $0x3ff,%ax
    d507:	09 c6                	or     %eax,%esi
    d509:	66 89 75 f2          	mov    %si,-0xe(%ebp)
	fixhead->DorC=1;
    d50d:	66 c1 ee 08          	shr    $0x8,%si
	fixhead->RF=0;
    d511:	83 e6 1f             	and    $0x1f,%esi
	fixhead->P=1;
    d514:	83 ce a0             	or     $0xffffffa0,%esi
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d517:	83 fa 02             	cmp    $0x2,%edx
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
	fixhead->DorC=1;
	fixhead->RF=0;
	fixhead->P=1;
    d51a:	89 f1                	mov    %esi,%ecx
    d51c:	88 4d f3             	mov    %cl,-0xd(%ebp)
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d51f:	0f 86 e1 06 00 00    	jbe    dc06 <rlc_AM_segment+0x726>
    d525:	8b 47 44             	mov    0x44(%edi),%eax
	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
	FSM_PKT *skb;//*skb_copy;
	struct list_head *head =&(amIns->amSduBuffer.list);
    d528:	8d 5f 44             	lea    0x44(%edi),%ebx
    d52b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
    d52e:	39 c3                	cmp    %eax,%ebx
    d530:	0f 84 02 05 00 00    	je     da38 <rlc_AM_segment+0x558>
	{
		list_for_each_entry(amBuffer,head,list)
    d536:	8d 58 f4             	lea    -0xc(%eax),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d539:	8b 40 f4             	mov    -0xc(%eax),%eax
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
    d53c:	83 ea 02             	sub    $0x2,%edx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d53f:	8b 40 50             	mov    0x50(%eax),%eax
    d542:	39 c2                	cmp    %eax,%edx
    d544:	0f 82 5f 06 00 00    	jb     dba9 <rlc_AM_segment+0x6c9>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d54a:	0f 84 2a 06 00 00    	je     db7a <rlc_AM_segment+0x69a>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d550:	8d 48 02             	lea    0x2(%eax),%ecx
    d553:	39 ca                	cmp    %ecx,%edx
    d555:	0f 86 7d 06 00 00    	jbe    dbd8 <rlc_AM_segment+0x6f8>
    d55b:	89 7d e0             	mov    %edi,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    d55e:	b9 01 00 00 00       	mov    $0x1,%ecx
    d563:	bf 01 00 00 00       	mov    $0x1,%edi
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d568:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    d56e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d574:	eb 56                	jmp    d5cc <rlc_AM_segment+0xec>
    d576:	66 90                	xchg   %ax,%ax
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(amBuffer->pktstatus != FULL_SDU && flag)
    d578:	84 c9                	test   %cl,%cl
    d57a:	74 08                	je     d584 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
    d57c:	83 ce 14             	or     $0x14,%esi
    d57f:	89 f1                	mov    %esi,%ecx
    d581:	88 4d f3             	mov    %cl,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    d584:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
    d588:	74 66                	je     d5f0 <rlc_AM_segment+0x110>
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d58a:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    d58d:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
    d590:	8d 59 f4             	lea    -0xc(%ecx),%ebx
    d593:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    d596:	0f 84 a9 03 00 00    	je     d945 <rlc_AM_segment+0x465>
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d59c:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d5a1:	83 c7 01             	add    $0x1,%edi
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d5a4:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d5a6:	8b 41 f4             	mov    -0xc(%ecx),%eax
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d5a9:	01 da                	add    %ebx,%edx
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d5ab:	8b 5d dc             	mov    -0x24(%ebp),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d5ae:	8b 40 50             	mov    0x50(%eax),%eax
    d5b1:	39 d0                	cmp    %edx,%eax
    d5b3:	0f 87 98 03 00 00    	ja     d951 <rlc_AM_segment+0x471>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d5b9:	0f 84 e7 03 00 00    	je     d9a6 <rlc_AM_segment+0x4c6>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d5bf:	8d 48 02             	lea    0x2(%eax),%ecx
    d5c2:	39 d1                	cmp    %edx,%ecx
    d5c4:	0f 83 1b 04 00 00    	jae    d9e5 <rlc_AM_segment+0x505>
    d5ca:	31 c9                	xor    %ecx,%ecx
			{

				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
    d5cc:	66 01 45 ec          	add    %ax,-0x14(%ebp)
				if(amBuffer->pktstatus == FULL_SDU && flag)
    d5d0:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d5d4:	75 a2                	jne    d578 <rlc_AM_segment+0x98>
    d5d6:	84 c9                	test   %cl,%cl
    d5d8:	74 aa                	je     d584 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=0;
    d5da:	83 e6 ef             	and    $0xffffffef,%esi
					fixhead->E=1;
    d5dd:	83 ce 04             	or     $0x4,%esi
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d5e0:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
				if(amBuffer->pktstatus == FULL_SDU && flag)
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
    d5e4:	89 f1                	mov    %esi,%ecx
    d5e6:	88 4d f3             	mov    %cl,-0xd(%ebp)
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d5e9:	75 9f                	jne    d58a <rlc_AM_segment+0xaa>
    d5eb:	90                   	nop
    d5ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    d5f0:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d5f4:	8b 7d e0             	mov    -0x20(%ebp),%edi
				{
					if((amIns->amSduBufferNum)==1)
					{
						fixhead->E=0;
    d5f7:	89 f0                	mov    %esi,%eax
    d5f9:	83 e0 fb             	and    $0xfffffffb,%eax
    d5fc:	83 7f 50 01          	cmpl   $0x1,0x50(%edi)
    d600:	0f 45 c6             	cmovne %esi,%eax
					}
					fixhead->FIsecond=0;
    d603:	83 e0 f7             	and    $0xfffffff7,%eax
    d606:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=amBuffer->pkt->len;
    d609:	8b 03                	mov    (%ebx),%eax
    d60b:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    d60f:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d613:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
    d617:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d61b:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d61f:	8d 34 58             	lea    (%eax,%ebx,2),%esi
    d622:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
    d625:	0f b7 de             	movzwl %si,%ebx
    d628:	89 55 e0             	mov    %edx,-0x20(%ebp)
    d62b:	89 55 c8             	mov    %edx,-0x38(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    d62e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    d632:	0f b7 d0             	movzwl %ax,%edx
    d635:	c1 e2 08             	shl    $0x8,%edx
    d638:	66 c1 e8 08          	shr    $0x8,%ax
    d63c:	09 d0                	or     %edx,%eax
	fsm_octets_print(fixhead,2);
    d63e:	ba 02 00 00 00       	mov    $0x2,%edx
    d643:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    d647:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d64a:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d64d:	e8 fc ff ff ff       	call   d64e <rlc_AM_segment+0x16e>
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d652:	89 d8                	mov    %ebx,%eax
    d654:	e8 fc ff ff ff       	call   d655 <rlc_AM_segment+0x175>
	pos = head->next;
    d659:	8b 5f 44             	mov    0x44(%edi),%ebx
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d65c:	66 83 7d da 01       	cmpw   $0x1,-0x26(%ebp)
    d661:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
	fsm_octets_print(fixhead,2);
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d664:	89 45 e8             	mov    %eax,-0x18(%ebp)
	pos = head->next;
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d667:	0f 84 f1 03 00 00    	je     da5e <rlc_AM_segment+0x57e>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			amIns->amSduBufferSize -= lastCopyLen;
			tbuff->pktstatus = LAST_SEGMENT;
		}		
	}
	else if(count > 1)
    d66d:	0f 86 79 01 00 00    	jbe    d7ec <rlc_AM_segment+0x30c>
	{
		fsm_skb_reserve(skb,2*count);		
    d673:	8b 55 e0             	mov    -0x20(%ebp),%edx
    d676:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d679:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d67c:	e8 fc ff ff ff       	call   d67d <rlc_AM_segment+0x19d>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d681:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    d684:	83 e9 01             	sub    $0x1,%ecx
    d687:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d68a:	01 c9                	add    %ecx,%ecx
    d68c:	89 c8                	mov    %ecx,%eax
    d68e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    d691:	e8 fc ff ff ff       	call   d692 <rlc_AM_segment+0x1b2>
    d696:	89 45 d0             	mov    %eax,-0x30(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d699:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d69c:	e8 fc ff ff ff       	call   d69d <rlc_AM_segment+0x1bd>
    d6a1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		i = 0;
		u8 *des = skb->data;
    d6a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d6a7:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    d6ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d6b0:	8b 47 44             	mov    0x44(%edi),%eax
    d6b3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
    d6b6:	8b 30                	mov    (%eax),%esi
    d6b8:	8d 58 f4             	lea    -0xc(%eax),%ebx
    d6bb:	0f 84 cf 00 00 00    	je     d790 <rlc_AM_segment+0x2b0>
    d6c1:	83 ee 0c             	sub    $0xc,%esi
	else if(count > 1)
	{
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
    d6c4:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d6ca:	eb 20                	jmp    d6ec <rlc_AM_segment+0x20c>
    d6cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
			}
			else if(i==count-1)
    d6d0:	0f 84 fa 01 00 00    	je     d8d0 <rlc_AM_segment+0x3f0>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d6d6:	8b 46 0c             	mov    0xc(%esi),%eax
    d6d9:	8d 56 0c             	lea    0xc(%esi),%edx
    d6dc:	83 e8 0c             	sub    $0xc,%eax
    d6df:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d6e2:	0f 84 a8 00 00 00    	je     d790 <rlc_AM_segment+0x2b0>
    d6e8:	89 f3                	mov    %esi,%ebx
    d6ea:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    d6ec:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d6f0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    d6f3:	7e db                	jle    d6d0 <rlc_AM_segment+0x1f0>
			{
				*(LI+i) = amBuffer->pkt->len;
    d6f5:	8b 13                	mov    (%ebx),%edx
    d6f7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d6fa:	8b 52 50             	mov    0x50(%edx),%edx
    d6fd:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				*(headExt+i) = 0x8000|(*(LI+i));
    d701:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d704:	66 81 ca 00 80       	or     $0x8000,%dx
    d709:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				fsm_skb_put(skb,amBuffer->pkt->len);
    d70d:	8b 03                	mov    (%ebx),%eax
    d70f:	8b 50 50             	mov    0x50(%eax),%edx
    d712:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d715:	e8 fc ff ff ff       	call   d716 <rlc_AM_segment+0x236>
				fsm_mem_cpy(des,amBuffer->pkt->data,amBuffer->pkt->len);
    d71a:	8b 03                	mov    (%ebx),%eax
    d71c:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d722:	8b 48 50             	mov    0x50(%eax),%ecx
    d725:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d728:	e8 fc ff ff ff       	call   d729 <rlc_AM_segment+0x249>
				des = des + amBuffer->pkt->len ;
    d72d:	8b 03                	mov    (%ebx),%eax
    d72f:	8b 50 50             	mov    0x50(%eax),%edx
    d732:	01 55 dc             	add    %edx,-0x24(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    d735:	8b 43 10             	mov    0x10(%ebx),%eax
    d738:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    d73b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    d73e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    d740:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    d747:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				list_del(&amBuffer->list);
				amIns->amSduBufferNum--;
    d74e:	83 6f 50 01          	subl   $0x1,0x50(%edi)
				amIns->amSduBufferSize -= amBuffer->pkt->len;
    d752:	8b 03                	mov    (%ebx),%eax
    d754:	8b 40 50             	mov    0x50(%eax),%eax
    d757:	29 47 4c             	sub    %eax,0x4c(%edi)

				if(amBuffer->pkt != NULL)
    d75a:	8b 03                	mov    (%ebx),%eax
    d75c:	85 c0                	test   %eax,%eax
    d75e:	74 0b                	je     d76b <rlc_AM_segment+0x28b>
				{
					fsm_pkt_destroy(amBuffer->pkt);
    d760:	e8 fc ff ff ff       	call   d761 <rlc_AM_segment+0x281>
					amBuffer->pkt = NULL;
    d765:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				}
				if(amBuffer != NULL)
    d76b:	85 db                	test   %ebx,%ebx
    d76d:	74 07                	je     d776 <rlc_AM_segment+0x296>
				{
					fsm_mem_free(amBuffer);
    d76f:	89 d8                	mov    %ebx,%eax
    d771:	e8 fc ff ff ff       	call   d772 <rlc_AM_segment+0x292>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d776:	8b 46 0c             	mov    0xc(%esi),%eax
    d779:	8d 56 0c             	lea    0xc(%esi),%edx
				if(amBuffer != NULL)
				{
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
    d77c:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d781:	83 e8 0c             	sub    $0xc,%eax
    d784:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d787:	0f 85 5b ff ff ff    	jne    d6e8 <rlc_AM_segment+0x208>
    d78d:	8d 76 00             	lea    0x0(%esi),%esi
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d790:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    d794:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d797:	8b 55 cc             	mov    -0x34(%ebp),%edx
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d79a:	66 81 64 41 fc ff 7f 	andw   $0x7fff,-0x4(%ecx,%eax,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d7a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d7a4:	e8 fc ff ff ff       	call   d7a5 <rlc_AM_segment+0x2c5>
    d7a9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    d7ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d7af:	e8 fc ff ff ff       	call   d7b0 <rlc_AM_segment+0x2d0>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    d7b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d7b7:	ba 02 00 00 00       	mov    $0x2,%edx
    d7bc:	e8 fc ff ff ff       	call   d7bd <rlc_AM_segment+0x2dd>
    d7c1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    d7c4:	b9 02 00 00 00       	mov    $0x2,%ecx
    d7c9:	e8 fc ff ff ff       	call   d7ca <rlc_AM_segment+0x2ea>
		if(LI != NULL)
    d7ce:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d7d1:	85 d2                	test   %edx,%edx
    d7d3:	74 08                	je     d7dd <rlc_AM_segment+0x2fd>
		{
			fsm_mem_free(LI);
    d7d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d7d8:	e8 fc ff ff ff       	call   d7d9 <rlc_AM_segment+0x2f9>
			LI = NULL;
		}
		if(headExt != NULL)
    d7dd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d7e0:	85 c0                	test   %eax,%eax
    d7e2:	74 08                	je     d7ec <rlc_AM_segment+0x30c>
		{
			fsm_mem_free(headExt);
    d7e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d7e7:	e8 fc ff ff ff       	call   d7e8 <rlc_AM_segment+0x308>
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d7ec:	b8 a4 00 00 00       	mov    $0xa4,%eax
    d7f1:	e8 fc ff ff ff       	call   d7f2 <rlc_AM_segment+0x312>
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d7f6:	8b 55 e8             	mov    -0x18(%ebp),%edx
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d7f9:	89 c3                	mov    %eax,%ebx
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d7fb:	8b 82 b0 00 00 00    	mov    0xb0(%edx),%eax
    d801:	e8 fc ff ff ff       	call   d802 <rlc_AM_segment+0x322>
    d806:	89 03                	mov    %eax,(%ebx)
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d808:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d80b:	e8 fc ff ff ff       	call   d80c <rlc_AM_segment+0x32c>
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
    d810:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d813:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d816:	89 03                	mov    %eax,(%ebx)
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    d818:	8b 40 50             	mov    0x50(%eax),%eax
	amBuf->segnum = 0;
    d81b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
    d822:	00 00 00 
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    d825:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    d82b:	31 c0                	xor    %eax,%eax
    d82d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		amBuf->segStart[j] = -1;
    d830:	c7 44 83 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%eax,4)
    d837:	ff 
		amBuf->segEnd[j] = -1;
    d838:	c7 44 83 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%eax,4)
    d83f:	ff 
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    d840:	83 c0 01             	add    $0x1,%eax
    d843:	83 f8 10             	cmp    $0x10,%eax
    d846:	75 e8                	jne    d830 <rlc_AM_segment+0x350>
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    d848:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d84c:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
    d852:	66 c7 83 96 00 00 00 	movw   $0xffff,0x96(%ebx)
    d859:	ff ff 
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d85b:	8d 8f f0 00 00 00    	lea    0xf0(%edi),%ecx
	for( j = 0; j < segNumMax; j++ )
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    d861:	66 89 83 94 00 00 00 	mov    %ax,0x94(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    d868:	8b 87 f4 00 00 00    	mov    0xf4(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    d86e:	89 97 f4 00 00 00    	mov    %edx,0xf4(%edi)
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d874:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    d87a:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    d880:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
    d882:	8b 03                	mov    (%ebx),%eax
    d884:	8b 40 50             	mov    0x50(%eax),%eax
    d887:	01 87 f8 00 00 00    	add    %eax,0xf8(%edi)
	amIns->amTransmittedBufferNum++;
	amIns->SN++;
    d88d:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
	amIns->amTransmittedBufferNum++;
    d891:	83 87 fc 00 00 00 01 	addl   $0x1,0xfc(%edi)
	amIns->SN++;
    d898:	83 c0 01             	add    $0x1,%eax
	amIns->SN %= 1024;
    d89b:	89 c2                	mov    %eax,%edx
    d89d:	66 c1 fa 0f          	sar    $0xf,%dx
    d8a1:	66 c1 ea 06          	shr    $0x6,%dx
    d8a5:	01 d0                	add    %edx,%eax
    d8a7:	66 25 ff 03          	and    $0x3ff,%ax
    d8ab:	66 29 d0             	sub    %dx,%ax
    d8ae:	66 89 47 2e          	mov    %ax,0x2e(%edi)
	fsm_printf("[RLC][rlc_AM_segment] SN = %d\n",amIns->SN);
    d8b2:	98                   	cwtl   
    d8b3:	89 44 24 04          	mov    %eax,0x4(%esp)
    d8b7:	c7 04 24 4c 37 00 00 	movl   $0x374c,(%esp)
    d8be:	e8 fc ff ff ff       	call   d8bf <rlc_AM_segment+0x3df>
	return skb;
}
    d8c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d8c6:	83 c4 38             	add    $0x38,%esp
    d8c9:	5b                   	pop    %ebx
    d8ca:	5e                   	pop    %esi
    d8cb:	5f                   	pop    %edi
    d8cc:	5d                   	pop    %ebp
    d8cd:	c3                   	ret    
    d8ce:	66 90                	xchg   %ax,%ax
				}				
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    d8d0:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    d8d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d8d7:	89 f2                	mov    %esi,%edx
    d8d9:	e8 fc ff ff ff       	call   d8da <rlc_AM_segment+0x3fa>
				fsm_mem_cpy(des,amBuffer->pkt->data,lastCopyLen);
    d8de:	8b 03                	mov    (%ebx),%eax
    d8e0:	89 f1                	mov    %esi,%ecx
    d8e2:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d8e8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d8eb:	e8 fc ff ff ff       	call   d8ec <rlc_AM_segment+0x40c>
				
				if(amBuffer->pkt->len == lastCopyLen)
    d8f0:	8b 03                	mov    (%ebx),%eax
    d8f2:	3b 70 50             	cmp    0x50(%eax),%esi
    d8f5:	0f 85 fc 01 00 00    	jne    daf7 <rlc_AM_segment+0x617>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    d8fb:	8b 43 10             	mov    0x10(%ebx),%eax
    d8fe:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    d901:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    d904:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    d906:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    d90d:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				{
					list_del(&amBuffer->list);
					amIns->amSduBufferNum--;
    d914:	83 6f 50 01          	subl   $0x1,0x50(%edi)
					amIns->amSduBufferSize -= amBuffer->pkt->len;
    d918:	8b 03                	mov    (%ebx),%eax
    d91a:	8b 40 50             	mov    0x50(%eax),%eax
    d91d:	29 47 4c             	sub    %eax,0x4c(%edi)
					if(amBuffer->pkt != NULL)
    d920:	8b 03                	mov    (%ebx),%eax
    d922:	85 c0                	test   %eax,%eax
    d924:	74 0b                	je     d931 <rlc_AM_segment+0x451>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    d926:	e8 fc ff ff ff       	call   d927 <rlc_AM_segment+0x447>
						amBuffer->pkt = NULL;
    d92b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    d931:	85 db                	test   %ebx,%ebx
    d933:	0f 84 57 fe ff ff    	je     d790 <rlc_AM_segment+0x2b0>
					{
						fsm_mem_free(amBuffer);
    d939:	89 d8                	mov    %ebx,%eax
    d93b:	e8 fc ff ff ff       	call   d93c <rlc_AM_segment+0x45c>
    d940:	e9 4b fe ff ff       	jmp    d790 <rlc_AM_segment+0x2b0>
    d945:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d949:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d94c:	e9 c2 fc ff ff       	jmp    d613 <rlc_AM_segment+0x133>
    d951:	66 89 7d da          	mov    %di,-0x26(%ebp)
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d955:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    d959:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d95d:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d960:	01 c0                	add    %eax,%eax
    d962:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    d966:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    d969:	89 45 e0             	mov    %eax,-0x20(%ebp)
    d96c:	89 45 c8             	mov    %eax,-0x38(%ebp)
    d96f:	31 c0                	xor    %eax,%eax
			{
				if(amBuffer->pktstatus ==FULL_SDU)
    d971:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d975:	0f 84 92 01 00 00    	je     db0d <rlc_AM_segment+0x62d>
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    d97b:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    d97d:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    d97f:	0f 84 8e 01 00 00    	je     db13 <rlc_AM_segment+0x633>
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    d985:	83 e0 e3             	and    $0xffffffe3,%eax
						fixhead->FIsecond=1;
    d988:	83 c8 18             	or     $0x18,%eax
    d98b:	88 45 f3             	mov    %al,-0xd(%ebp)
    d98e:	66 90                	xchg   %ax,%ax
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
				length = length + size;
    d990:	0f b7 75 e8          	movzwl -0x18(%ebp),%esi
    d994:	66 03 75 ec          	add    -0x14(%ebp),%si
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
    d998:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    d99c:	01 d6                	add    %edx,%esi
    d99e:	0f b7 de             	movzwl %si,%ebx
				length = length + size;
				break;
    d9a1:	e9 88 fc ff ff       	jmp    d62e <rlc_AM_segment+0x14e>
    d9a6:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d9aa:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d9ae:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d9b1:	01 c9                	add    %ecx,%ecx
    d9b3:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
    d9b7:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d9bb:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    d9be:	89 45 e0             	mov    %eax,-0x20(%ebp)
    d9c1:	89 45 c8             	mov    %eax,-0x38(%ebp)
    d9c4:	31 c0                	xor    %eax,%eax
			{

				if(amBuffer->pktstatus == FULL_SDU)
    d9c6:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d9ca:	0f 84 88 01 00 00    	je     db58 <rlc_AM_segment+0x678>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    d9d0:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    d9d2:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    d9d4:	0f 84 44 01 00 00    	je     db1e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=1;
    d9da:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    d9dd:	83 e0 f3             	and    $0xfffffff3,%eax
    d9e0:	88 45 f3             	mov    %al,-0xd(%ebp)
    d9e3:	eb ab                	jmp    d990 <rlc_AM_segment+0x4b0>
    d9e5:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d9e9:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d9ed:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
    d9f1:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d9f4:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    d9f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    d9fa:	01 d2                	add    %edx,%edx
    d9fc:	89 45 c8             	mov    %eax,-0x38(%ebp)
    d9ff:	31 c0                	xor    %eax,%eax
					break;
				}				
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
    da01:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    da05:	0f 84 5e 01 00 00    	je     db69 <rlc_AM_segment+0x689>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da0b:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    da0d:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da0f:	0f 84 14 01 00 00    	je     db29 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=1;
    da15:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    da18:	83 e0 f3             	and    $0xfffffff3,%eax
    da1b:	88 45 f3             	mov    %al,-0xd(%ebp)
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    da1e:	8b 03                	mov    (%ebx),%eax
				length = length + amBuffer->pkt->len;
    da20:	0f b7 75 ec          	movzwl -0x14(%ebp),%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    da24:	0f b7 40 50          	movzwl 0x50(%eax),%eax
				length = length + amBuffer->pkt->len;
    da28:	01 d6                	add    %edx,%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    da2a:	01 c6                	add    %eax,%esi
    da2c:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    da30:	0f b7 de             	movzwl %si,%ebx
				length = length + amBuffer->pkt->len;
				break;
    da33:	e9 f6 fb ff ff       	jmp    d62e <rlc_AM_segment+0x14e>
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    da38:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    da3c:	31 c9                	xor    %ecx,%ecx
    da3e:	31 db                	xor    %ebx,%ebx
    da40:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    da47:	31 f6                	xor    %esi,%esi
    da49:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    da50:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    da56:	0f b7 d0             	movzwl %ax,%edx
    da59:	e9 d7 fb ff ff       	jmp    d635 <rlc_AM_segment+0x155>
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    da5e:	0f b7 d6             	movzwl %si,%edx
    da61:	e8 fc ff ff ff       	call   da62 <rlc_AM_segment+0x582>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    da66:	8b 43 f4             	mov    -0xc(%ebx),%eax
    da69:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    da6d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    da73:	89 f2                	mov    %esi,%edx
    da75:	89 45 ec             	mov    %eax,-0x14(%ebp)
    da78:	8b 45 e8             	mov    -0x18(%ebp),%eax
    da7b:	e8 fc ff ff ff       	call   da7c <rlc_AM_segment+0x59c>
    da80:	8b 55 ec             	mov    -0x14(%ebp),%edx
    da83:	89 f1                	mov    %esi,%ecx
    da85:	e8 fc ff ff ff       	call   da86 <rlc_AM_segment+0x5a6>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    da8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    da8d:	ba 02 00 00 00       	mov    $0x2,%edx
    da92:	e8 fc ff ff ff       	call   da93 <rlc_AM_segment+0x5b3>
    da97:	b9 02 00 00 00       	mov    $0x2,%ecx
    da9c:	8d 55 f2             	lea    -0xe(%ebp),%edx
    da9f:	e8 fc ff ff ff       	call   daa0 <rlc_AM_segment+0x5c0>
		
		if(lastCopyLen == tbuff->pkt->len)
    daa4:	8b 43 f4             	mov    -0xc(%ebx),%eax
    daa7:	3b 70 50             	cmp    0x50(%eax),%esi
    daaa:	0f 85 84 00 00 00    	jne    db34 <rlc_AM_segment+0x654>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    dab0:	8b 43 04             	mov    0x4(%ebx),%eax
    dab3:	8b 13                	mov    (%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dab5:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dab8:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    daba:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
	entry->prev = LIST_POISON2;
    dac0:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
		{
			list_del(&tbuff->list);
			amIns->amSduBufferNum--;
    dac7:	83 6f 50 01          	subl   $0x1,0x50(%edi)
			amIns->amSduBufferSize -= tbuff->pkt->len;
    dacb:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dace:	8b 40 50             	mov    0x50(%eax),%eax
    dad1:	29 47 4c             	sub    %eax,0x4c(%edi)
			if(tbuff->pkt != NULL)
    dad4:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dad7:	85 c0                	test   %eax,%eax
    dad9:	74 0c                	je     dae7 <rlc_AM_segment+0x607>
			{
				fsm_pkt_destroy(tbuff->pkt);
    dadb:	e8 fc ff ff ff       	call   dadc <rlc_AM_segment+0x5fc>
				tbuff->pkt = NULL;
    dae0:	c7 43 f4 00 00 00 00 	movl   $0x0,-0xc(%ebx)
			}
			if(tbuff != NULL)
    dae7:	89 d8                	mov    %ebx,%eax
    dae9:	83 e8 0c             	sub    $0xc,%eax
    daec:	0f 85 f5 fc ff ff    	jne    d7e7 <rlc_AM_segment+0x307>
    daf2:	e9 f5 fc ff ff       	jmp    d7ec <rlc_AM_segment+0x30c>
						amBuffer = NULL;
					}				
				}
				else
				{
					fsm_skb_pull(amBuffer->pkt,lastCopyLen);
    daf7:	89 f2                	mov    %esi,%edx
    daf9:	e8 fc ff ff ff       	call   dafa <rlc_AM_segment+0x61a>
					amIns->amSduBufferSize -= lastCopyLen;
    dafe:	29 77 4c             	sub    %esi,0x4c(%edi)
					amBuffer->pktstatus = LAST_SEGMENT;
    db01:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    db08:	e9 83 fc ff ff       	jmp    d790 <rlc_AM_segment+0x2b0>
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    db0d:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    db0f:	89 f0                	mov    %esi,%eax
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    db11:	75 37                	jne    db4a <rlc_AM_segment+0x66a>
						fixhead->FIsecond=1;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=1;
    db13:	83 c8 08             	or     $0x8,%eax
    db16:	88 45 f3             	mov    %al,-0xd(%ebp)
    db19:	e9 72 fe ff ff       	jmp    d990 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    db1e:	83 e0 f7             	and    $0xfffffff7,%eax
    db21:	88 45 f3             	mov    %al,-0xd(%ebp)
    db24:	e9 67 fe ff ff       	jmp    d990 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    db29:	83 e0 f7             	and    $0xfffffff7,%eax
    db2c:	88 45 f3             	mov    %al,-0xd(%ebp)
    db2f:	e9 ea fe ff ff       	jmp    da1e <rlc_AM_segment+0x53e>
				tbuff = NULL;
			}		
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    db34:	89 f2                	mov    %esi,%edx
    db36:	e8 fc ff ff ff       	call   db37 <rlc_AM_segment+0x657>
			amIns->amSduBufferSize -= lastCopyLen;
    db3b:	29 77 4c             	sub    %esi,0x4c(%edi)
			tbuff->pktstatus = LAST_SEGMENT;
    db3e:	c7 43 f8 02 00 00 00 	movl   $0x2,-0x8(%ebx)
    db45:	e9 a2 fc ff ff       	jmp    d7ec <rlc_AM_segment+0x30c>
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    db4a:	83 e0 eb             	and    $0xffffffeb,%eax
						fixhead->FIsecond=1;
    db4d:	83 c8 08             	or     $0x8,%eax
    db50:	88 45 f3             	mov    %al,-0xd(%ebp)
    db53:	e9 38 fe ff ff       	jmp    d990 <rlc_AM_segment+0x4b0>
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    db58:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    db5a:	89 f0                	mov    %esi,%eax
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    db5c:	74 c0                	je     db1e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    db5e:	83 e0 e3             	and    $0xffffffe3,%eax
    db61:	88 45 f3             	mov    %al,-0xd(%ebp)
    db64:	e9 27 fe ff ff       	jmp    d990 <rlc_AM_segment+0x4b0>
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    db69:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    db6b:	89 f0                	mov    %esi,%eax
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    db6d:	74 ba                	je     db29 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    db6f:	83 e0 e3             	and    $0xffffffe3,%eax
    db72:	88 45 f3             	mov    %al,-0xd(%ebp)
    db75:	e9 a4 fe ff ff       	jmp    da1e <rlc_AM_segment+0x53e>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    db7a:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    db81:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    db86:	b8 01 00 00 00       	mov    $0x1,%eax
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    db8b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    db92:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    db98:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    db9e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dba4:	e9 1d fe ff ff       	jmp    d9c6 <rlc_AM_segment+0x4e6>
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dba9:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dbb0:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dbb5:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dbba:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    dbc1:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dbc7:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dbcd:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dbd3:	e9 99 fd ff ff       	jmp    d971 <rlc_AM_segment+0x491>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    dbd8:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dbdf:	b9 01 00 00 00       	mov    $0x1,%ecx
    dbe4:	ba 02 00 00 00       	mov    $0x2,%edx
    dbe9:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dbf0:	b8 01 00 00 00       	mov    $0x1,%eax
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dbf5:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dbfb:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dc01:	e9 fb fd ff ff       	jmp    da01 <rlc_AM_segment+0x521>
	fixhead->P=1;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
    dc06:	c7 04 24 28 37 00 00 	movl   $0x3728,(%esp)
    dc0d:	e8 fc ff ff ff       	call   dc0e <rlc_AM_segment+0x72e>
		return NULL;
    dc12:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dc19:	e9 a5 fc ff ff       	jmp    d8c3 <rlc_AM_segment+0x3e3>
    dc1e:	66 90                	xchg   %ax,%ax

0000dc20 <rlc_UM_segment>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    dc20:	55                   	push   %ebp
    dc21:	89 e5                	mov    %esp,%ebp
    dc23:	57                   	push   %edi
    dc24:	56                   	push   %esi
    dc25:	53                   	push   %ebx
    dc26:	83 ec 34             	sub    $0x34,%esp
    dc29:	e8 fc ff ff ff       	call   dc2a <rlc_UM_segment+0xa>
    dc2e:	89 d3                	mov    %edx,%ebx
		u32 size;
		int num = umIns->umSduBufferNum;
    dc30:	8b 50 24             	mov    0x24(%eax),%edx
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    dc33:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		u32 size;
		int num = umIns->umSduBufferNum;
    dc36:	89 55 e8             	mov    %edx,-0x18(%ebp)
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    dc39:	0f b7 50 28          	movzwl 0x28(%eax),%edx
    dc3d:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    dc41:	c7 04 24 9c 07 00 00 	movl   $0x79c,(%esp)
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    dc48:	66 81 e2 ff 03       	and    $0x3ff,%dx
    dc4d:	66 25 00 fc          	and    $0xfc00,%ax
    dc51:	09 d0                	or     %edx,%eax
    dc53:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		fixhead->R11=0;
    dc57:	66 c1 e8 08          	shr    $0x8,%ax
		fixhead->R12=0;
		fixhead->R13=0;
    dc5b:	83 e0 1f             	and    $0x1f,%eax
    dc5e:	88 45 f3             	mov    %al,-0xd(%ebp)
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    dc61:	e8 fc ff ff ff       	call   dc62 <rlc_UM_segment+0x42>
		if(sizeFromMac <= 2)
    dc66:	83 fb 02             	cmp    $0x2,%ebx
    dc69:	0f 86 7e 05 00 00    	jbe    e1ed <rlc_UM_segment+0x5cd>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    dc6f:	8b 75 e4             	mov    -0x1c(%ebp),%esi

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
		u32 size;
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
    dc72:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    dc75:	8b 46 18             	mov    0x18(%esi),%eax
    dc78:	83 c1 18             	add    $0x18,%ecx
    dc7b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
    dc7e:	39 c1                	cmp    %eax,%ecx
    dc80:	0f 84 82 03 00 00    	je     e008 <rlc_UM_segment+0x3e8>
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
    dc86:	8d 53 fe             	lea    -0x2(%ebx),%edx
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dc89:	8d 58 f0             	lea    -0x10(%eax),%ebx
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dc8c:	8b 40 f0             	mov    -0x10(%eax),%eax
    dc8f:	8b 40 50             	mov    0x50(%eax),%eax
    dc92:	39 c2                	cmp    %eax,%edx
    dc94:	0f 82 11 05 00 00    	jb     e1ab <rlc_UM_segment+0x58b>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dc9a:	0f 84 21 05 00 00    	je     e1c1 <rlc_UM_segment+0x5a1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dca0:	8d 48 02             	lea    0x2(%eax),%ecx
    dca3:	39 ca                	cmp    %ecx,%edx
    dca5:	0f 86 2c 05 00 00    	jbe    e1d7 <rlc_UM_segment+0x5b7>
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    dcab:	31 f6                	xor    %esi,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dcad:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    dcb2:	b9 01 00 00 00       	mov    $0x1,%ecx
    dcb7:	66 89 75 e0          	mov    %si,-0x20(%ebp)
    dcbb:	eb 4c                	jmp    dd09 <rlc_UM_segment+0xe9>
    dcbd:	8d 76 00             	lea    0x0(%esi),%esi
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
						flag=false;
					}
					else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    dcc0:	84 c9                	test   %cl,%cl
    dcc2:	74 04                	je     dcc8 <rlc_UM_segment+0xa8>
					{
	
						fixhead->FIfirst=1;
						fixhead->E=1;
    dcc4:	80 4d f3 14          	orb    $0x14,-0xd(%ebp)
						flag=false;
					}
					if(num == 0)
    dcc8:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    dccb:	74 63                	je     dd30 <rlc_UM_segment+0x110>
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dccd:	8b 4b 10             	mov    0x10(%ebx),%ecx
    dcd0:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
    dcd3:	8d 59 f0             	lea    -0x10(%ecx),%ebx
    dcd6:	0f 84 b4 02 00 00    	je     df90 <rlc_UM_segment+0x370>
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dcdc:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dce1:	83 c7 01             	add    $0x1,%edi
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dce4:	29 c6                	sub    %eax,%esi
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dce6:	8b 41 f0             	mov    -0x10(%ecx),%eax
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dce9:	01 f2                	add    %esi,%edx
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dceb:	8b 40 50             	mov    0x50(%eax),%eax
    dcee:	39 d0                	cmp    %edx,%eax
    dcf0:	0f 87 aa 02 00 00    	ja     dfa0 <rlc_UM_segment+0x380>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dcf6:	0f 84 dc 02 00 00    	je     dfd8 <rlc_UM_segment+0x3b8>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dcfc:	8d 48 02             	lea    0x2(%eax),%ecx
    dcff:	39 d1                	cmp    %edx,%ecx
    dd01:	0f 83 19 03 00 00    	jae    e020 <rlc_UM_segment+0x400>
    dd07:	31 c9                	xor    %ecx,%ecx
				{
	
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
    dd09:	66 01 45 e0          	add    %ax,-0x20(%ebp)
					if(umBuffer->pktstatus==FULL_SDU &&flag)
    dd0d:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dd11:	75 ad                	jne    dcc0 <rlc_UM_segment+0xa0>
    dd13:	84 c9                	test   %cl,%cl
    dd15:	74 b1                	je     dcc8 <rlc_UM_segment+0xa8>
					{	
						fixhead->FIfirst=0;
    dd17:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    dd1b:	83 e1 ef             	and    $0xffffffef,%ecx
						fixhead->E=1;
    dd1e:	83 c9 04             	or     $0x4,%ecx
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    dd21:	39 7d e8             	cmp    %edi,-0x18(%ebp)
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
					if(umBuffer->pktstatus==FULL_SDU &&flag)
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
    dd24:	88 4d f3             	mov    %cl,-0xd(%ebp)
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    dd27:	75 a4                	jne    dccd <rlc_UM_segment+0xad>
    dd29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    dd30:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    dd34:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    dd37:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    dd3b:	89 d0                	mov    %edx,%eax
    dd3d:	83 e0 fb             	and    $0xfffffffb,%eax
    dd40:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
						fixhead->FIsecond=0;
						lastCopyLen = umBuffer->pkt->len;
    dd44:	8d 34 7e             	lea    (%esi,%edi,2),%esi
						flag=false;
					}
					if(num == 0)
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    dd47:	0f 45 c2             	cmovne %edx,%eax
						fixhead->FIsecond=0;
    dd4a:	83 e0 f7             	and    $0xfffffff7,%eax
    dd4d:	88 45 f3             	mov    %al,-0xd(%ebp)
						lastCopyLen = umBuffer->pkt->len;
    dd50:	8b 03                	mov    (%ebx),%eax
    dd52:	0f b7 de             	movzwl %si,%ebx
    dd55:	8b 40 50             	mov    0x50(%eax),%eax
    dd58:	89 45 d0             	mov    %eax,-0x30(%ebp)
    dd5b:	90                   	nop
    dd5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    dd60:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    dd64:	0f b7 d0             	movzwl %ax,%edx
    dd67:	c1 e2 08             	shl    $0x8,%edx
    dd6a:	66 c1 e8 08          	shr    $0x8,%ax
    dd6e:	09 d0                	or     %edx,%eax
		fsm_octets_print(fixhead,2);
    dd70:	ba 02 00 00 00       	mov    $0x2,%edx
    dd75:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    dd79:	8d 45 f2             	lea    -0xe(%ebp),%eax
    dd7c:	e8 fc ff ff ff       	call   dd7d <rlc_UM_segment+0x15d>
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    dd81:	89 d8                	mov    %ebx,%eax
    dd83:	e8 fc ff ff ff       	call   dd84 <rlc_UM_segment+0x164>
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    dd88:	83 ff 01             	cmp    $0x1,%edi
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    dd8b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		pos = head->next;
    dd8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dd91:	8b 58 18             	mov    0x18(%eax),%ebx
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    dd94:	0f 84 c2 02 00 00    	je     e05c <rlc_UM_segment+0x43c>
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
				umIns->umSduBufferSize -= lastCopyLen;
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
    dd9a:	0f 8e 59 01 00 00    	jle    def9 <rlc_UM_segment+0x2d9>
		{
			fsm_skb_reserve(skb,2*count);
    dda0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dda3:	8d 14 3f             	lea    (%edi,%edi,1),%edx
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    dda6:	8d 77 ff             	lea    -0x1(%edi),%esi
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
    dda9:	e8 fc ff ff ff       	call   ddaa <rlc_UM_segment+0x18a>
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    ddae:	89 75 e8             	mov    %esi,-0x18(%ebp)
    ddb1:	01 f6                	add    %esi,%esi
    ddb3:	89 f0                	mov    %esi,%eax
    ddb5:	89 75 cc             	mov    %esi,-0x34(%ebp)
    ddb8:	e8 fc ff ff ff       	call   ddb9 <rlc_UM_segment+0x199>
    ddbd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    ddc0:	89 f0                	mov    %esi,%eax
    ddc2:	e8 fc ff ff ff       	call   ddc3 <rlc_UM_segment+0x1a3>
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    ddc7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    ddca:	89 45 d8             	mov    %eax,-0x28(%ebp)
			int i = 0;
			unsigned char *des = skb->data;
    ddcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ddd0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ddd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    ddd9:	8b 42 18             	mov    0x18(%edx),%eax
    dddc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    dddf:	8b 30                	mov    (%eax),%esi
    dde1:	8d 58 f0             	lea    -0x10(%eax),%ebx
    dde4:	0f 84 c5 00 00 00    	je     deaf <rlc_UM_segment+0x28f>
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
    ddea:	31 c0                	xor    %eax,%eax
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    ddec:	83 ee 10             	sub    $0x10,%esi
    ddef:	89 7d c8             	mov    %edi,-0x38(%ebp)
    ddf2:	89 c7                	mov    %eax,%edi
    ddf4:	eb 1e                	jmp    de14 <rlc_UM_segment+0x1f4>
    ddf6:	66 90                	xchg   %ax,%ax
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
    ddf8:	0f 84 42 01 00 00    	je     df40 <rlc_UM_segment+0x320>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    ddfe:	8b 46 10             	mov    0x10(%esi),%eax
    de01:	8d 56 10             	lea    0x10(%esi),%edx
    de04:	83 e8 10             	sub    $0x10,%eax
    de07:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    de0a:	0f 84 9c 00 00 00    	je     deac <rlc_UM_segment+0x28c>
    de10:	89 f3                	mov    %esi,%ebx
    de12:	89 c6                	mov    %eax,%esi
			{
				if(i<count-1)
    de14:	3b 7d e8             	cmp    -0x18(%ebp),%edi
    de17:	7d df                	jge    ddf8 <rlc_UM_segment+0x1d8>
				{
					*(LI+i) = umBuffer->pkt->len;
    de19:	8b 03                	mov    (%ebx),%eax
    de1b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
					*(headExt+i) = 0x8000|(*(LI+i));
    de1e:	8b 55 d8             	mov    -0x28(%ebp),%edx
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
    de21:	8b 40 50             	mov    0x50(%eax),%eax
    de24:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
					*(headExt+i) = 0x8000|(*(LI+i));
    de28:	66 0d 00 80          	or     $0x8000,%ax
    de2c:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
					fsm_skb_put(skb,umBuffer->pkt->len);
    de30:	8b 03                	mov    (%ebx),%eax
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
    de32:	83 c7 01             	add    $0x1,%edi
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
    de35:	8b 50 50             	mov    0x50(%eax),%edx
    de38:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de3b:	e8 fc ff ff ff       	call   de3c <rlc_UM_segment+0x21c>
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    de40:	8b 03                	mov    (%ebx),%eax
    de42:	8b 48 50             	mov    0x50(%eax),%ecx
    de45:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    de4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    de4e:	e8 fc ff ff ff       	call   de4f <rlc_UM_segment+0x22f>
					des = des + umBuffer->pkt->len ;
    de53:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    de55:	8b 53 10             	mov    0x10(%ebx),%edx
    de58:	8b 48 50             	mov    0x50(%eax),%ecx
    de5b:	8b 43 14             	mov    0x14(%ebx),%eax
    de5e:	01 4d e0             	add    %ecx,-0x20(%ebp)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    de61:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    de64:	89 10                	mov    %edx,(%eax)
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    de66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    de69:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    de70:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    de73:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    de7a:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    de7e:	8b 03                	mov    (%ebx),%eax
    de80:	8b 40 50             	mov    0x50(%eax),%eax
    de83:	29 42 20             	sub    %eax,0x20(%edx)
					fsm_pkt_destroy(umBuffer->pkt);
    de86:	8b 03                	mov    (%ebx),%eax
    de88:	e8 fc ff ff ff       	call   de89 <rlc_UM_segment+0x269>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    de8d:	89 d8                	mov    %ebx,%eax
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    de8f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer);
    de95:	e8 fc ff ff ff       	call   de96 <rlc_UM_segment+0x276>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    de9a:	8b 46 10             	mov    0x10(%esi),%eax
    de9d:	8d 56 10             	lea    0x10(%esi),%edx
    dea0:	83 e8 10             	sub    $0x10,%eax
    dea3:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    dea6:	0f 85 64 ff ff ff    	jne    de10 <rlc_UM_segment+0x1f0>
    deac:	8b 7d c8             	mov    -0x38(%ebp),%edi
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    deaf:	8b 45 d8             	mov    -0x28(%ebp),%eax
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    deb2:	8b 55 cc             	mov    -0x34(%ebp),%edx
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    deb5:	66 81 64 78 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%edi,2)
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    debc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    debf:	e8 fc ff ff ff       	call   dec0 <rlc_UM_segment+0x2a0>
    dec4:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    dec7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    deca:	e8 fc ff ff ff       	call   decb <rlc_UM_segment+0x2ab>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    decf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ded2:	ba 02 00 00 00       	mov    $0x2,%edx
    ded7:	e8 fc ff ff ff       	call   ded8 <rlc_UM_segment+0x2b8>
    dedc:	b9 02 00 00 00       	mov    $0x2,%ecx
    dee1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    dee4:	e8 fc ff ff ff       	call   dee5 <rlc_UM_segment+0x2c5>
			fsm_mem_free(LI);
    dee9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    deec:	e8 fc ff ff ff       	call   deed <rlc_UM_segment+0x2cd>
			fsm_mem_free(headExt);
    def1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    def4:	e8 fc ff ff ff       	call   def5 <rlc_UM_segment+0x2d5>
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    def9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		umIns->SN %= 1024;
    defc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
			fsm_mem_free(headExt);
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    deff:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    df03:	83 c0 01             	add    $0x1,%eax
		umIns->SN %= 1024;
    df06:	89 c2                	mov    %eax,%edx
    df08:	66 c1 fa 0f          	sar    $0xf,%dx
    df0c:	66 c1 ea 06          	shr    $0x6,%dx
    df10:	01 d0                	add    %edx,%eax
    df12:	66 25 ff 03          	and    $0x3ff,%ax
    df16:	66 29 d0             	sub    %dx,%ax
    df19:	66 89 41 28          	mov    %ax,0x28(%ecx)
		fsm_printf("[RLC][rlc_UM_segment] SN = %d\n",umIns->SN);
    df1d:	98                   	cwtl   
    df1e:	89 44 24 04          	mov    %eax,0x4(%esp)
    df22:	c7 04 24 90 37 00 00 	movl   $0x3790,(%esp)
    df29:	e8 fc ff ff ff       	call   df2a <rlc_UM_segment+0x30a>
		return skb;

}
    df2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df31:	83 c4 34             	add    $0x34,%esp
    df34:	5b                   	pop    %ebx
    df35:	5e                   	pop    %esi
    df36:	5f                   	pop    %edi
    df37:	5d                   	pop    %ebp
    df38:	c3                   	ret    
    df39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
				{
					fsm_skb_put(skb,lastCopyLen);
    df40:	8b 55 d0             	mov    -0x30(%ebp),%edx
    df43:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df46:	8b 7d c8             	mov    -0x38(%ebp),%edi
    df49:	e8 fc ff ff ff       	call   df4a <rlc_UM_segment+0x32a>
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    df4e:	8b 03                	mov    (%ebx),%eax
    df50:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    df53:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    df59:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df5c:	e8 fc ff ff ff       	call   df5d <rlc_UM_segment+0x33d>
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    df61:	8b 55 d0             	mov    -0x30(%ebp),%edx
    df64:	8b 03                	mov    (%ebx),%eax
    df66:	e8 fc ff ff ff       	call   df67 <rlc_UM_segment+0x347>
					if(umBuffer->pkt->len == lastCopyLen)
    df6b:	8b 03                	mov    (%ebx),%eax
    df6d:	8b 75 d0             	mov    -0x30(%ebp),%esi
    df70:	39 70 50             	cmp    %esi,0x50(%eax)
    df73:	0f 84 ee 01 00 00    	je     e167 <rlc_UM_segment+0x547>
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
						umIns->umSduBufferSize -= lastCopyLen;
    df79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    df7c:	8b 75 d0             	mov    -0x30(%ebp),%esi
						fsm_mem_free(umBuffer);
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
    df7f:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
						umIns->umSduBufferSize -= lastCopyLen;
    df86:	29 70 20             	sub    %esi,0x20(%eax)
    df89:	e9 21 ff ff ff       	jmp    deaf <rlc_UM_segment+0x28f>
    df8e:	66 90                	xchg   %ax,%ax
    df90:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    df94:	8d 34 7e             	lea    (%esi,%edi,2),%esi
    df97:	0f b7 de             	movzwl %si,%ebx
    df9a:	e9 c1 fd ff ff       	jmp    dd60 <rlc_UM_segment+0x140>
    df9f:	90                   	nop
    dfa0:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dfa4:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    dfa7:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    dfa9:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dfad:	0f 84 3e 01 00 00    	je     e0f1 <rlc_UM_segment+0x4d1>
							fixhead->FIsecond=1;
						}
					}
					else
					{
						if(flag)
    dfb3:	84 c0                	test   %al,%al
    dfb5:	0f 84 0d 01 00 00    	je     e0c8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=1;
    dfbb:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    dfbf:	83 e0 e3             	and    $0xffffffe3,%eax
							fixhead->FIsecond=1;
    dfc2:	83 c8 18             	or     $0x18,%eax
    dfc5:	88 45 f3             	mov    %al,-0xd(%ebp)
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = size;
					length += size;
    dfc8:	01 ce                	add    %ecx,%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    dfca:	01 d6                	add    %edx,%esi
    dfcc:	0f b7 de             	movzwl %si,%ebx
						}
					}
					lastCopyLen = size;
					length += size;
					break;
    dfcf:	89 55 d0             	mov    %edx,-0x30(%ebp)
    dfd2:	e9 89 fd ff ff       	jmp    dd60 <rlc_UM_segment+0x140>
    dfd7:	90                   	nop
    dfd8:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dfdc:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    dfdf:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    dfe1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dfe5:	0f 84 1c 01 00 00    	je     e107 <rlc_UM_segment+0x4e7>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    dfeb:	84 c0                	test   %al,%al
    dfed:	0f 84 e5 00 00 00    	je     e0d8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=1;
    dff3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    dff7:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    dffa:	83 e0 f3             	and    $0xfffffff3,%eax
    dffd:	88 45 f3             	mov    %al,-0xd(%ebp)
    e000:	eb c6                	jmp    dfc8 <rlc_UM_segment+0x3a8>
    e002:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e008:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    e00c:	31 db                	xor    %ebx,%ebx
    e00e:	31 f6                	xor    %esi,%esi
		fixhead->SN=umIns->SN;
		fixhead->R11=0;
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
    e010:	31 ff                	xor    %edi,%edi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e012:	0f b7 d0             	movzwl %ax,%edx
    e015:	e9 4d fd ff ff       	jmp    dd67 <rlc_UM_segment+0x147>
    e01a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e020:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e024:	8d 14 3f             	lea    (%edi,%edi,1),%edx
    e027:	31 c0                	xor    %eax,%eax
						break;
					}
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e029:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e02d:	0f 84 e1 00 00 00    	je     e114 <rlc_UM_segment+0x4f4>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e033:	84 c0                	test   %al,%al
    e035:	0f 84 ad 00 00 00    	je     e0e8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=1;
    e03b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e03f:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e042:	83 e0 f3             	and    $0xfffffff3,%eax
    e045:	88 45 f3             	mov    %al,-0xd(%ebp)
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e048:	8b 03                	mov    (%ebx),%eax
					length += umBuffer->pkt->len;
    e04a:	01 d6                	add    %edx,%esi
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e04c:	8b 40 50             	mov    0x50(%eax),%eax
    e04f:	01 c6                	add    %eax,%esi
    e051:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e054:	0f b7 de             	movzwl %si,%ebx
					length += umBuffer->pkt->len;
					break;
    e057:	e9 04 fd ff ff       	jmp    dd60 <rlc_UM_segment+0x140>
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
		{
			fsm_skb_reserve(skb,length);
    e05c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e05f:	0f b7 d6             	movzwl %si,%edx
    e062:	e8 fc ff ff ff       	call   e063 <rlc_UM_segment+0x443>
			fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e067:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e06a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e06d:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e073:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e076:	e8 fc ff ff ff       	call   e077 <rlc_UM_segment+0x457>
    e07b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e07e:	89 f2                	mov    %esi,%edx
    e080:	e8 fc ff ff ff       	call   e081 <rlc_UM_segment+0x461>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e085:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e088:	ba 02 00 00 00       	mov    $0x2,%edx
    e08d:	e8 fc ff ff ff       	call   e08e <rlc_UM_segment+0x46e>
    e092:	b9 02 00 00 00       	mov    $0x2,%ecx
    e097:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e09a:	e8 fc ff ff ff       	call   e09b <rlc_UM_segment+0x47b>
			
			if(lastCopyLen == tbuff->pkt->len)
    e09f:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e0a2:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e0a5:	39 70 50             	cmp    %esi,0x50(%eax)
    e0a8:	74 77                	je     e121 <rlc_UM_segment+0x501>
				fsm_mem_free(tbuff);
				tbuff = NULL;
			}
			else
			{
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e0aa:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e0ad:	e8 fc ff ff ff       	call   e0ae <rlc_UM_segment+0x48e>
				umIns->umSduBufferSize -= lastCopyLen;
    e0b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e0b5:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e0b8:	29 70 20             	sub    %esi,0x20(%eax)
				tbuff->pktstatus = LAST_SEGMENT;
    e0bb:	c7 43 f4 02 00 00 00 	movl   $0x2,-0xc(%ebx)
    e0c2:	e9 32 fe ff ff       	jmp    def9 <rlc_UM_segment+0x2d9>
    e0c7:	90                   	nop
							fixhead->FIsecond=1;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=1;
    e0c8:	80 4d f3 08          	orb    $0x8,-0xd(%ebp)
    e0cc:	e9 f7 fe ff ff       	jmp    dfc8 <rlc_UM_segment+0x3a8>
    e0d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e0d8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e0dc:	e9 e7 fe ff ff       	jmp    dfc8 <rlc_UM_segment+0x3a8>
    e0e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e0e8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e0ec:	e9 57 ff ff ff       	jmp    e048 <rlc_UM_segment+0x428>
				num--;
				if(size < umBuffer->pkt->len)
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e0f1:	84 c0                	test   %al,%al
    e0f3:	74 d3                	je     e0c8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=0;
    e0f5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e0f9:	83 e0 eb             	and    $0xffffffeb,%eax
							fixhead->FIsecond=1;
    e0fc:	83 c8 08             	or     $0x8,%eax
    e0ff:	88 45 f3             	mov    %al,-0xd(%ebp)
    e102:	e9 c1 fe ff ff       	jmp    dfc8 <rlc_UM_segment+0x3a8>
				}
				else if(size == umBuffer->pkt->len) 
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e107:	84 c0                	test   %al,%al
    e109:	74 cd                	je     e0d8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e10b:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e10f:	e9 b4 fe ff ff       	jmp    dfc8 <rlc_UM_segment+0x3a8>
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e114:	84 c0                	test   %al,%al
    e116:	74 d0                	je     e0e8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e118:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e11c:	e9 27 ff ff ff       	jmp    e048 <rlc_UM_segment+0x428>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e121:	8b 13                	mov    (%ebx),%edx
    e123:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e126:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e129:	89 10                	mov    %edx,(%eax)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e12b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e12e:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e134:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e137:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e13e:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e142:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e145:	8b 40 50             	mov    0x50(%eax),%eax
    e148:	29 42 20             	sub    %eax,0x20(%edx)
				fsm_pkt_destroy(tbuff->pkt);
    e14b:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e14e:	e8 fc ff ff ff       	call   e14f <rlc_UM_segment+0x52f>
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
    e153:	8d 43 f0             	lea    -0x10(%ebx),%eax
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(tbuff->pkt);
				tbuff->pkt = NULL;
    e156:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
				fsm_mem_free(tbuff);
    e15d:	e8 fc ff ff ff       	call   e15e <rlc_UM_segment+0x53e>
    e162:	e9 92 fd ff ff       	jmp    def9 <rlc_UM_segment+0x2d9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e167:	8b 53 10             	mov    0x10(%ebx),%edx
    e16a:	8b 43 14             	mov    0x14(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e16d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e170:	89 10                	mov    %edx,(%eax)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e172:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e175:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e17c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e17f:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e186:	83 68 24 01          	subl   $0x1,0x24(%eax)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e18a:	8b 03                	mov    (%ebx),%eax
    e18c:	8b 40 50             	mov    0x50(%eax),%eax
    e18f:	29 42 20             	sub    %eax,0x20(%edx)
						fsm_pkt_destroy(umBuffer->pkt);
    e192:	8b 03                	mov    (%ebx),%eax
    e194:	e8 fc ff ff ff       	call   e195 <rlc_UM_segment+0x575>
						umBuffer->pkt = NULL;
						fsm_mem_free(umBuffer);
    e199:	89 d8                	mov    %ebx,%eax
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
						umIns->umSduBufferSize -= umBuffer->pkt->len;
						fsm_pkt_destroy(umBuffer->pkt);
						umBuffer->pkt = NULL;
    e19b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(umBuffer);
    e1a1:	e8 fc ff ff ff       	call   e1a2 <rlc_UM_segment+0x582>
    e1a6:	e9 04 fd ff ff       	jmp    deaf <rlc_UM_segment+0x28f>
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e1ab:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e1b0:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e1b5:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e1ba:	31 f6                	xor    %esi,%esi
    e1bc:	e9 e8 fd ff ff       	jmp    dfa9 <rlc_UM_segment+0x389>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e1c1:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e1c6:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e1cb:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e1d0:	31 f6                	xor    %esi,%esi
    e1d2:	e9 0a fe ff ff       	jmp    dfe1 <rlc_UM_segment+0x3c1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e1d7:	ba 02 00 00 00       	mov    $0x2,%edx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e1dc:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e1e1:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e1e6:	31 f6                	xor    %esi,%esi
    e1e8:	e9 3c fe ff ff       	jmp    e029 <rlc_UM_segment+0x409>
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
    e1ed:	c7 04 24 6c 37 00 00 	movl   $0x376c,(%esp)
    e1f4:	e8 fc ff ff ff       	call   e1f5 <rlc_UM_segment+0x5d5>
			return NULL;
    e1f9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    e200:	e9 29 fd ff ff       	jmp    df2e <rlc_UM_segment+0x30e>
    e205:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000e210 <rlc_UM5_segment>:
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e210:	55                   	push   %ebp
    e211:	89 e5                	mov    %esp,%ebp
    e213:	57                   	push   %edi
    e214:	56                   	push   %esi
    e215:	53                   	push   %ebx
    e216:	83 ec 38             	sub    $0x38,%esp
    e219:	e8 fc ff ff ff       	call   e21a <rlc_UM5_segment+0xa>
	u32 size;
	int num = umIns->umSduBufferNum;
    e21e:	8b 78 24             	mov    0x24(%eax),%edi
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e221:	89 d3                	mov    %edx,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e223:	0f b7 50 28          	movzwl 0x28(%eax),%edx
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e227:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e22a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e22e:	83 e2 1f             	and    $0x1f,%edx
    e231:	83 e0 e0             	and    $0xffffffe0,%eax
    e234:	09 d0                	or     %edx,%eax
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e236:	83 fb 01             	cmp    $0x1,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e239:	88 45 f3             	mov    %al,-0xd(%ebp)
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e23c:	0f 86 9f 05 00 00    	jbe    e7e1 <rlc_UM5_segment+0x5d1>
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e242:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e245:	c7 04 24 d4 37 00 00 	movl   $0x37d4,(%esp)
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e24c:	83 c0 18             	add    $0x18,%eax
    e24f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e252:	e8 fc ff ff ff       	call   e253 <rlc_UM5_segment+0x43>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    e257:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e25a:	8b 42 18             	mov    0x18(%edx),%eax
	if(!list_empty(head))
    e25d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e260:	0f 84 72 03 00 00    	je     e5d8 <rlc_UM5_segment+0x3c8>
	{
		list_for_each_entry(umBuffer,head,list)
    e266:	8d 70 f0             	lea    -0x10(%eax),%esi
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e269:	8b 40 f0             	mov    -0x10(%eax),%eax
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
    e26c:	8d 53 ff             	lea    -0x1(%ebx),%edx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e26f:	8b 40 50             	mov    0x50(%eax),%eax
    e272:	39 c2                	cmp    %eax,%edx
    e274:	0f 82 22 05 00 00    	jb     e79c <rlc_UM5_segment+0x58c>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e27a:	0f 84 33 05 00 00    	je     e7b3 <rlc_UM5_segment+0x5a3>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e280:	8d 48 02             	lea    0x2(%eax),%ecx
    e283:	39 ca                	cmp    %ecx,%edx
    e285:	0f 86 3f 05 00 00    	jbe    e7ca <rlc_UM5_segment+0x5ba>

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e28b:	31 db                	xor    %ebx,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e28d:	83 ef 01             	sub    $0x1,%edi
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e290:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e296:	b9 01 00 00 00       	mov    $0x1,%ecx
    e29b:	66 89 5d e0          	mov    %bx,-0x20(%ebp)
    e29f:	eb 54                	jmp    e2f5 <rlc_UM5_segment+0xe5>
    e2a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    e2a8:	84 c9                	test   %cl,%cl
    e2aa:	74 04                	je     e2b0 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=1;
					fixhead->E=1;
    e2ac:	80 4d f3 a0          	orb    $0xa0,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    e2b0:	85 ff                	test   %edi,%edi
    e2b2:	74 64                	je     e318 <rlc_UM5_segment+0x108>
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e2b4:	8b 4e 10             	mov    0x10(%esi),%ecx
    e2b7:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    e2ba:	8d 71 f0             	lea    -0x10(%ecx),%esi
    e2bd:	0f 84 95 02 00 00    	je     e558 <rlc_UM5_segment+0x348>
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e2c3:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e2c8:	83 ef 01             	sub    $0x1,%edi
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e2cb:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e2cd:	8b 41 f0             	mov    -0x10(%ecx),%eax
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e2d0:	01 da                	add    %ebx,%edx
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e2d2:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
			num--;
			if(size < umBuffer->pkt->len)
    e2d7:	8b 40 50             	mov    0x50(%eax),%eax
    e2da:	39 d0                	cmp    %edx,%eax
    e2dc:	0f 87 86 02 00 00    	ja     e568 <rlc_UM5_segment+0x358>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e2e2:	0f 84 c0 02 00 00    	je     e5a8 <rlc_UM5_segment+0x398>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e2e8:	8d 48 02             	lea    0x2(%eax),%ecx
    e2eb:	39 d1                	cmp    %edx,%ecx
    e2ed:	0f 83 05 03 00 00    	jae    e5f8 <rlc_UM5_segment+0x3e8>
    e2f3:	31 c9                	xor    %ecx,%ecx
			{

				size = size - umBuffer->pkt->len - 2;
				length += umBuffer->pkt->len;
    e2f5:	66 01 45 e0          	add    %ax,-0x20(%ebp)
				if(umBuffer->pktstatus==FULL_SDU &&flag)
    e2f9:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e2fd:	75 a9                	jne    e2a8 <rlc_UM5_segment+0x98>
    e2ff:	84 c9                	test   %cl,%cl
    e301:	74 ad                	je     e2b0 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=0;
    e303:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    e307:	83 e1 7f             	and    $0x7f,%ecx
					fixhead->E=1;
    e30a:	83 c9 20             	or     $0x20,%ecx

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e30d:	85 ff                	test   %edi,%edi
				length += umBuffer->pkt->len;
				if(umBuffer->pktstatus==FULL_SDU &&flag)
				{

					fixhead->FIfirst=0;
					fixhead->E=1;
    e30f:	88 4d f3             	mov    %cl,-0xd(%ebp)

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e312:	75 a0                	jne    e2b4 <rlc_UM5_segment+0xa4>
    e314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e318:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e31c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e31f:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e323:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
					flag=false;
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e327:	89 d0                	mov    %edx,%eax
    e329:	83 e0 df             	and    $0xffffffdf,%eax
    e32c:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
    e330:	0f 45 c2             	cmovne %edx,%eax
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e333:	01 ff                	add    %edi,%edi
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
					fixhead->FIsecond=0;
    e335:	83 e0 bf             	and    $0xffffffbf,%eax
    e338:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=umBuffer->pkt->len;
    e33b:	8b 06                	mov    (%esi),%eax
    e33d:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e341:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
    e345:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e348:	ba 02 00 00 00       	mov    $0x2,%edx
    e34d:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e350:	e8 fc ff ff ff       	call   e351 <rlc_UM5_segment+0x141>
	length = length + (2*count-1);
    e355:	8d 5c 3b ff          	lea    -0x1(%ebx,%edi,1),%ebx
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e359:	0f b7 db             	movzwl %bx,%ebx
    e35c:	89 d8                	mov    %ebx,%eax
    e35e:	e8 fc ff ff ff       	call   e35f <rlc_UM5_segment+0x14f>
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e363:	66 83 7d ec 01       	cmpw   $0x1,-0x14(%ebp)
	}
	
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e368:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pos = head->next;
    e36b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e36e:	8b 40 18             	mov    0x18(%eax),%eax
    e371:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e374:	0f 84 be 02 00 00    	je     e638 <rlc_UM5_segment+0x428>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			tbuff->pktstatus = LAST_SEGMENT;
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
    e37a:	0f 86 4d 01 00 00    	jbe    e4cd <rlc_UM5_segment+0x2bd>
	{
		fsm_skb_reserve(skb,(2*count-1));
    e380:	0f b7 5d ec          	movzwl -0x14(%ebp),%ebx
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
    e384:	31 ff                	xor    %edi,%edi
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e386:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e389:	8d 54 1b ff          	lea    -0x1(%ebx,%ebx,1),%edx
    e38d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e390:	83 eb 01             	sub    $0x1,%ebx
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e393:	e8 fc ff ff ff       	call   e394 <rlc_UM5_segment+0x184>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e398:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    e39b:	01 db                	add    %ebx,%ebx
    e39d:	89 d8                	mov    %ebx,%eax
    e39f:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    e3a2:	e8 fc ff ff ff       	call   e3a3 <rlc_UM5_segment+0x193>
    e3a7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e3aa:	89 d8                	mov    %ebx,%eax
    e3ac:	e8 fc ff ff ff       	call   e3ad <rlc_UM5_segment+0x19d>
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e3b1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e3b4:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int i = 0;
		unsigned char *des = skb->data;
    e3b7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e3ba:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e3c0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e3c3:	8b 42 18             	mov    0x18(%edx),%eax
    e3c6:	8b 30                	mov    (%eax),%esi
    e3c8:	8d 58 f0             	lea    -0x10(%eax),%ebx
    e3cb:	83 ee 10             	sub    $0x10,%esi
    e3ce:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e3d1:	75 21                	jne    e3f4 <rlc_UM5_segment+0x1e4>
    e3d3:	e9 b8 00 00 00       	jmp    e490 <rlc_UM5_segment+0x280>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
    e3d8:	0f 84 32 01 00 00    	je     e510 <rlc_UM5_segment+0x300>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e3de:	8b 46 10             	mov    0x10(%esi),%eax
    e3e1:	8d 56 10             	lea    0x10(%esi),%edx
    e3e4:	83 e8 10             	sub    $0x10,%eax
    e3e7:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e3ea:	0f 84 a0 00 00 00    	je     e490 <rlc_UM5_segment+0x280>
    e3f0:	89 f3                	mov    %esi,%ebx
    e3f2:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    e3f4:	3b 7d ec             	cmp    -0x14(%ebp),%edi
    e3f7:	7d df                	jge    e3d8 <rlc_UM5_segment+0x1c8>
			{
				*(LI+i) = umBuffer->pkt->len;
    e3f9:	8b 03                	mov    (%ebx),%eax
    e3fb:	8b 4d c8             	mov    -0x38(%ebp),%ecx
				*(headExt+i) = 0x80|(*(LI+i));
    e3fe:	8b 55 d8             	mov    -0x28(%ebp),%edx
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
    e401:	8b 40 50             	mov    0x50(%eax),%eax
    e404:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
				*(headExt+i) = 0x80|(*(LI+i));
    e408:	0c 80                	or     $0x80,%al
    e40a:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
				fsm_skb_put(skb,umBuffer->pkt->len);
    e40e:	8b 03                	mov    (%ebx),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
    e410:	83 c7 01             	add    $0x1,%edi
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
    e413:	8b 50 50             	mov    0x50(%eax),%edx
    e416:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e419:	e8 fc ff ff ff       	call   e41a <rlc_UM5_segment+0x20a>
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e41e:	8b 03                	mov    (%ebx),%eax
    e420:	8b 48 50             	mov    0x50(%eax),%ecx
    e423:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e429:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e42c:	e8 fc ff ff ff       	call   e42d <rlc_UM5_segment+0x21d>
				des = des + umBuffer->pkt->len ;
    e431:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e433:	8b 53 10             	mov    0x10(%ebx),%edx
    e436:	8b 48 50             	mov    0x50(%eax),%ecx
    e439:	8b 43 14             	mov    0x14(%ebx),%eax
    e43c:	01 4d dc             	add    %ecx,-0x24(%ebp)
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e43f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e442:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e445:	89 10                	mov    %edx,(%eax)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e447:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e44a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e44d:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e454:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e45b:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e45f:	8b 42 f0             	mov    -0x10(%edx),%eax
    e462:	8b 40 50             	mov    0x50(%eax),%eax
    e465:	29 41 20             	sub    %eax,0x20(%ecx)
				fsm_pkt_destroy(umBuffer->pkt);
    e468:	8b 03                	mov    (%ebx),%eax
    e46a:	e8 fc ff ff ff       	call   e46b <rlc_UM5_segment+0x25b>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    e46f:	89 d8                	mov    %ebx,%eax
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    e471:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    e477:	e8 fc ff ff ff       	call   e478 <rlc_UM5_segment+0x268>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e47c:	8b 46 10             	mov    0x10(%esi),%eax
    e47f:	8d 56 10             	lea    0x10(%esi),%edx
    e482:	83 e8 10             	sub    $0x10,%eax
    e485:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e488:	0f 85 62 ff ff ff    	jne    e3f0 <rlc_UM5_segment+0x1e0>
    e48e:	66 90                	xchg   %ax,%ax
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e490:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e493:	8b 5d cc             	mov    -0x34(%ebp),%ebx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e496:	8b 55 d0             	mov    -0x30(%ebp),%edx
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e499:	66 81 64 58 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%ebx,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e4a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e4a3:	e8 fc ff ff ff       	call   e4a4 <rlc_UM5_segment+0x294>
    e4a8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e4ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e4ae:	e8 fc ff ff ff       	call   e4af <rlc_UM5_segment+0x29f>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e4b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e4b6:	ba 01 00 00 00       	mov    $0x1,%edx
    e4bb:	e8 fc ff ff ff       	call   e4bc <rlc_UM5_segment+0x2ac>
    e4c0:	b9 01 00 00 00       	mov    $0x1,%ecx
    e4c5:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e4c8:	e8 fc ff ff ff       	call   e4c9 <rlc_UM5_segment+0x2b9>
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e4cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	umIns->SN %= 32;
    e4d0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e4d3:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e4d7:	83 c0 01             	add    $0x1,%eax
	umIns->SN %= 32;
    e4da:	89 c2                	mov    %eax,%edx
    e4dc:	66 c1 fa 0f          	sar    $0xf,%dx
    e4e0:	66 c1 ea 0b          	shr    $0xb,%dx
    e4e4:	01 d0                	add    %edx,%eax
    e4e6:	83 e0 1f             	and    $0x1f,%eax
    e4e9:	66 29 d0             	sub    %dx,%ax
    e4ec:	66 89 41 28          	mov    %ax,0x28(%ecx)
	fsm_printf("[RLC][rlc_UM5_segment] SN = %d\n",umIns->SN);
    e4f0:	98                   	cwtl   
    e4f1:	89 44 24 04          	mov    %eax,0x4(%esp)
    e4f5:	c7 04 24 f4 37 00 00 	movl   $0x37f4,(%esp)
    e4fc:	e8 fc ff ff ff       	call   e4fd <rlc_UM5_segment+0x2ed>
	return skb;
}
    e501:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e504:	83 c4 38             	add    $0x38,%esp
    e507:	5b                   	pop    %ebx
    e508:	5e                   	pop    %esi
    e509:	5f                   	pop    %edi
    e50a:	5d                   	pop    %ebp
    e50b:	c3                   	ret    
    e50c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    e510:	0f b7 75 c6          	movzwl -0x3a(%ebp),%esi
    e514:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e517:	89 f2                	mov    %esi,%edx
    e519:	e8 fc ff ff ff       	call   e51a <rlc_UM5_segment+0x30a>
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e51e:	8b 03                	mov    (%ebx),%eax
    e520:	89 f1                	mov    %esi,%ecx
    e522:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e528:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e52b:	e8 fc ff ff ff       	call   e52c <rlc_UM5_segment+0x31c>
				
				if(umBuffer->pkt->len == lastCopyLen)
    e530:	8b 03                	mov    (%ebx),%eax
    e532:	3b 70 50             	cmp    0x50(%eax),%esi
    e535:	0f 84 9e 01 00 00    	je     e6d9 <rlc_UM5_segment+0x4c9>
					fsm_mem_free(umBuffer); 
					umBuffer = NULL;
				}
				else
				{
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e53b:	89 f2                	mov    %esi,%edx
    e53d:	e8 fc ff ff ff       	call   e53e <rlc_UM5_segment+0x32e>
					umIns->umSduBufferSize -=lastCopyLen;
    e542:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e545:	29 70 20             	sub    %esi,0x20(%eax)
					umBuffer->pktstatus=LAST_SEGMENT;
    e548:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    e54f:	e9 3c ff ff ff       	jmp    e490 <rlc_UM5_segment+0x280>
    e554:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e558:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e55c:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e560:	01 ff                	add    %edi,%edi
    e562:	e9 e1 fd ff ff       	jmp    e348 <rlc_UM5_segment+0x138>
    e567:	90                   	nop
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e568:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e56c:	31 c0                	xor    %eax,%eax
    e56e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e572:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e574:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e578:	0f 84 a3 01 00 00    	je     e721 <rlc_UM5_segment+0x511>
					else
						fixhead->FIsecond=1;
				}
				else
				{
					if(flag)
    e57e:	84 c0                	test   %al,%al
    e580:	0f 84 2a 01 00 00    	je     e6b0 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=1;
    e586:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e58a:	83 e0 1f             	and    $0x1f,%eax
						fixhead->FIsecond=1;
    e58d:	83 c8 c0             	or     $0xffffffc0,%eax
    e590:	88 45 f3             	mov    %al,-0xd(%ebp)
    e593:	90                   	nop
    e594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = size;
    e598:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
				length += size;
    e59c:	01 d3                	add    %edx,%ebx
				break;
    e59e:	e9 a5 fd ff ff       	jmp    e348 <rlc_UM5_segment+0x138>
    e5a3:	90                   	nop
    e5a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e5a8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e5ac:	31 c0                	xor    %eax,%eax
    e5ae:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e5b2:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e5b4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e5b8:	0f 84 79 01 00 00    	je     e737 <rlc_UM5_segment+0x527>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e5be:	84 c0                	test   %al,%al
    e5c0:	0f 84 fa 00 00 00    	je     e6c0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=1;
    e5c6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e5ca:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e5cd:	83 e0 9f             	and    $0xffffff9f,%eax
    e5d0:	88 45 f3             	mov    %al,-0xd(%ebp)
    e5d3:	eb c3                	jmp    e598 <rlc_UM5_segment+0x388>
    e5d5:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e5d8:	ba 02 00 00 00       	mov    $0x2,%edx
    e5dd:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e5e0:	e8 fc ff ff ff       	call   e5e1 <rlc_UM5_segment+0x3d1>
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e5e5:	b8 ff ff 00 00       	mov    $0xffff,%eax
    e5ea:	e8 fc ff ff ff       	call   e5eb <rlc_UM5_segment+0x3db>
    e5ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e5f2:	e9 d6 fe ff ff       	jmp    e4cd <rlc_UM5_segment+0x2bd>
    e5f7:	90                   	nop
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e5f8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e5fc:	31 c0                	xor    %eax,%eax
    e5fe:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e602:	01 ff                	add    %edi,%edi
				}
			}
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e604:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e608:	0f 84 36 01 00 00    	je     e744 <rlc_UM5_segment+0x534>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e60e:	84 c0                	test   %al,%al
    e610:	0f 84 ba 00 00 00    	je     e6d0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=1;
    e616:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e61a:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e61d:	83 e0 9f             	and    $0xffffff9f,%eax
    e620:	88 45 f3             	mov    %al,-0xd(%ebp)
						flag=false;
					}
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = umBuffer->pkt->len ;
    e623:	8b 06                	mov    (%esi),%eax
    e625:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e629:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
				length += umBuffer->pkt->len;
    e62d:	01 c3                	add    %eax,%ebx
				break;
    e62f:	e9 14 fd ff ff       	jmp    e348 <rlc_UM5_segment+0x138>
    e634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    e638:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e63b:	89 da                	mov    %ebx,%edx
    e63d:	e8 fc ff ff ff       	call   e63e <rlc_UM5_segment+0x42e>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e642:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    e645:	0f b7 5d c6          	movzwl -0x3a(%ebp),%ebx
    e649:	8b 42 f0             	mov    -0x10(%edx),%eax
    e64c:	89 da                	mov    %ebx,%edx
    e64e:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e654:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e657:	e8 fc ff ff ff       	call   e658 <rlc_UM5_segment+0x448>
    e65c:	89 d9                	mov    %ebx,%ecx
    e65e:	89 f2                	mov    %esi,%edx
    e660:	e8 fc ff ff ff       	call   e661 <rlc_UM5_segment+0x451>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e665:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e668:	ba 01 00 00 00       	mov    $0x1,%edx
    e66d:	e8 fc ff ff ff       	call   e66e <rlc_UM5_segment+0x45e>
    e672:	b9 01 00 00 00       	mov    $0x1,%ecx
    e677:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e67a:	e8 fc ff ff ff       	call   e67b <rlc_UM5_segment+0x46b>
		
		if(lastCopyLen == tbuff->pkt->len)
    e67f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e682:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e685:	3b 58 50             	cmp    0x50(%eax),%ebx
    e688:	0f 84 c3 00 00 00    	je     e751 <rlc_UM5_segment+0x541>
			fsm_mem_free(tbuff);
			tbuff = NULL;
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e68e:	89 da                	mov    %ebx,%edx
    e690:	e8 fc ff ff ff       	call   e691 <rlc_UM5_segment+0x481>
			tbuff->pktstatus = LAST_SEGMENT;
    e695:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e698:	c7 40 f4 02 00 00 00 	movl   $0x2,-0xc(%eax)
			umIns->umSduBufferSize -=lastCopyLen;
    e69f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e6a2:	29 58 20             	sub    %ebx,0x20(%eax)
    e6a5:	e9 23 fe ff ff       	jmp    e4cd <rlc_UM5_segment+0x2bd>
    e6aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
						fixhead->E=0;
						fixhead->FIsecond=1;
						flag=false;
					}
					else
						fixhead->FIsecond=1;
    e6b0:	80 4d f3 40          	orb    $0x40,-0xd(%ebp)
    e6b4:	e9 df fe ff ff       	jmp    e598 <rlc_UM5_segment+0x388>
    e6b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
    e6c0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e6c4:	e9 cf fe ff ff       	jmp    e598 <rlc_UM5_segment+0x388>
    e6c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}
					else
						fixhead->FIsecond=0;
    e6d0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e6d4:	e9 4a ff ff ff       	jmp    e623 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e6d9:	8b 53 10             	mov    0x10(%ebx),%edx
    e6dc:	8b 43 14             	mov    0x14(%ebx),%eax
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e6df:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e6e2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e6e5:	89 10                	mov    %edx,(%eax)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e6e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e6ea:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e6ed:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e6f4:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e6fb:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e6ff:	8b 42 f0             	mov    -0x10(%edx),%eax
    e702:	8b 40 50             	mov    0x50(%eax),%eax
    e705:	29 41 20             	sub    %eax,0x20(%ecx)
					fsm_pkt_destroy(umBuffer->pkt);
    e708:	8b 03                	mov    (%ebx),%eax
    e70a:	e8 fc ff ff ff       	call   e70b <rlc_UM5_segment+0x4fb>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer); 
    e70f:	89 d8                	mov    %ebx,%eax
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    e711:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer); 
    e717:	e8 fc ff ff ff       	call   e718 <rlc_UM5_segment+0x508>
    e71c:	e9 6f fd ff ff       	jmp    e490 <rlc_UM5_segment+0x280>
			if(size < umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e721:	84 c0                	test   %al,%al
    e723:	74 8b                	je     e6b0 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=0;
    e725:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e729:	83 e0 5f             	and    $0x5f,%eax
						fixhead->FIsecond=1;
    e72c:	83 c8 40             	or     $0x40,%eax
    e72f:	88 45 f3             	mov    %al,-0xd(%ebp)
    e732:	e9 61 fe ff ff       	jmp    e598 <rlc_UM5_segment+0x388>
			else if(size == umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e737:	84 c0                	test   %al,%al
    e739:	74 85                	je     e6c0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e73b:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e73f:	e9 54 fe ff ff       	jmp    e598 <rlc_UM5_segment+0x388>
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e744:	84 c0                	test   %al,%al
    e746:	74 88                	je     e6d0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e748:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e74c:	e9 d2 fe ff ff       	jmp    e623 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e751:	8b 11                	mov    (%ecx),%edx
    e753:	8b 41 04             	mov    0x4(%ecx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e756:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e759:	89 10                	mov    %edx,(%eax)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e75b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e75e:	c7 01 00 01 10 00    	movl   $0x100100,(%ecx)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e764:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e767:	c7 41 04 00 02 20 00 	movl   $0x200200,0x4(%ecx)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e76e:	83 68 24 01          	subl   $0x1,0x24(%eax)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e772:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e775:	8b 40 50             	mov    0x50(%eax),%eax
    e778:	29 42 20             	sub    %eax,0x20(%edx)
			fsm_pkt_destroy(tbuff->pkt);
    e77b:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e77e:	e8 fc ff ff ff       	call   e77f <rlc_UM5_segment+0x56f>
			tbuff->pkt = NULL;
    e783:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e786:	89 d8                	mov    %ebx,%eax
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
    e788:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e78f:	83 e8 10             	sub    $0x10,%eax
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
			fsm_mem_free(tbuff);
    e792:	e8 fc ff ff ff       	call   e793 <rlc_UM5_segment+0x583>
    e797:	e9 31 fd ff ff       	jmp    e4cd <rlc_UM5_segment+0x2bd>
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e79c:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e7a1:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e7a6:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e7ac:	31 db                	xor    %ebx,%ebx
    e7ae:	e9 c1 fd ff ff       	jmp    e574 <rlc_UM5_segment+0x364>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e7b3:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e7b8:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e7bd:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e7c3:	31 db                	xor    %ebx,%ebx
    e7c5:	e9 ea fd ff ff       	jmp    e5b4 <rlc_UM5_segment+0x3a4>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e7ca:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e7cf:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e7d4:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e7da:	31 db                	xor    %ebx,%ebx
    e7dc:	e9 23 fe ff ff       	jmp    e604 <rlc_UM5_segment+0x3f4>
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
    e7e1:	c7 04 24 b0 37 00 00 	movl   $0x37b0,(%esp)
    e7e8:	e8 fc ff ff ff       	call   e7e9 <rlc_UM5_segment+0x5d9>
		return NULL;
    e7ed:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    e7f4:	e9 08 fd ff ff       	jmp    e501 <rlc_UM5_segment+0x2f1>
    e7f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000e800 <rlc_resegment>:
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e800:	55                   	push   %ebp
    e801:	89 e5                	mov    %esp,%ebp
    e803:	57                   	push   %edi
    e804:	56                   	push   %esi
    e805:	53                   	push   %ebx
    e806:	83 ec 20             	sub    $0x20,%esp
    e809:	e8 fc ff ff ff       	call   e80a <rlc_resegment+0xa>
	if(tbuff->segStart[0] != -1)
    e80e:	83 78 10 ff          	cmpl   $0xffffffff,0x10(%eax)
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e812:	89 c3                	mov    %eax,%ebx
    e814:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if(tbuff->segStart[0] != -1)
    e817:	0f 84 63 02 00 00    	je     ea80 <rlc_resegment+0x280>
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    e81d:	b8 02 00 00 00       	mov    $0x2,%eax
    e822:	e8 fc ff ff ff       	call   e823 <rlc_resegment+0x23>
		int start = tbuff->segStart[0];
    e827:	8b 4b 10             	mov    0x10(%ebx),%ecx
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
    e82a:	8b 73 0c             	mov    0xc(%ebx),%esi
    e82d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    e830:	83 c6 02             	add    $0x2,%esi
{
	if(tbuff->segStart[0] != -1)
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    e833:	89 c7                	mov    %eax,%edi
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    e835:	8b 43 50             	mov    0x50(%ebx),%eax
		int headLen = tbuff->headLen + 2;
    e838:	89 75 ec             	mov    %esi,-0x14(%ebp)
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    e83b:	8b b3 90 00 00 00    	mov    0x90(%ebx),%esi
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    e841:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
    e844:	29 c8                	sub    %ecx,%eax
    e846:	83 c0 01             	add    $0x1,%eax
    e849:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int retxSize = headLen + dataLen;
    e84c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e84f:	03 45 e8             	add    -0x18(%ebp),%eax
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    e852:	3b 45 f0             	cmp    -0x10(%ebp),%eax
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    e855:	89 75 e0             	mov    %esi,-0x20(%ebp)
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
    e858:	88 0f                	mov    %cl,(%edi)
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    e85a:	0f 87 48 01 00 00    	ja     e9a8 <rlc_resegment+0x1a8>
		{
			exthead->SO = start;
    e860:	0f b6 d5             	movzbl %ch,%edx
    e863:	83 e2 7f             	and    $0x7f,%edx
    e866:	89 d6                	mov    %edx,%esi
    e868:	0f b6 57 01          	movzbl 0x1(%edi),%edx
    e86c:	83 e2 80             	and    $0xffffff80,%edx
    e86f:	09 f2                	or     %esi,%edx
    e871:	88 57 01             	mov    %dl,0x1(%edi)
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
    e874:	8b 75 d8             	mov    -0x28(%ebp),%esi
    e877:	03 75 ec             	add    -0x14(%ebp),%esi
    e87a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    e87d:	8b 33                	mov    (%ebx),%esi
    e87f:	8b b6 ac 00 00 00    	mov    0xac(%esi),%esi
    e885:	01 75 e4             	add    %esi,-0x1c(%ebp)
    e888:	8b 33                	mov    (%ebx),%esi
    e88a:	8b b6 a0 00 00 00    	mov    0xa0(%esi),%esi
    e890:	83 ee 01             	sub    $0x1,%esi
    e893:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
    e896:	0f 84 d4 01 00 00    	je     ea70 <rlc_resegment+0x270>
			{
				exthead->LSF = 1;
			}
			else
			{
				exthead->LSF = 0;
    e89c:	83 e2 7f             	and    $0x7f,%edx
    e89f:	88 57 01             	mov    %dl,0x1(%edi)
			}
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    e8a2:	8b 13                	mov    (%ebx),%edx
    e8a4:	8b 92 ac 00 00 00    	mov    0xac(%edx),%edx
    e8aa:	89 55 f0             	mov    %edx,-0x10(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    e8ad:	80 4a 01 40          	orb    $0x40,0x1(%edx)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    e8b1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    e8b4:	e8 fc ff ff ff       	call   e8b5 <rlc_resegment+0xb5>
			fsm_skb_reserve(skb,headLen);
    e8b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    e8bc:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    e8be:	e8 fc ff ff ff       	call   e8bf <rlc_resegment+0xbf>
			tail = fsm_skb_put(skb,dataLen);
    e8c3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e8c6:	89 f0                	mov    %esi,%eax
    e8c8:	e8 fc ff ff ff       	call   e8c9 <rlc_resegment+0xc9>
			fsm_mem_cpy(skb->data,(tbuff->pkt->data + tbuff->headLen  + start),dataLen); 
    e8cd:	8b 03                	mov    (%ebx),%eax
    e8cf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e8d2:	8b 53 0c             	mov    0xc(%ebx),%edx
    e8d5:	01 ca                	add    %ecx,%edx
    e8d7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    e8da:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    e8e0:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    e8e6:	e8 fc ff ff ff       	call   e8e7 <rlc_resegment+0xe7>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4); //kuo zhan tou fu zhi
    e8eb:	8b 03                	mov    (%ebx),%eax
    e8ed:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    e8f0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e8f6:	83 e9 04             	sub    $0x4,%ecx
    e8f9:	89 ca                	mov    %ecx,%edx
    e8fb:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    e8fe:	83 c0 02             	add    $0x2,%eax
    e901:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e904:	89 f0                	mov    %esi,%eax
    e906:	e8 fc ff ff ff       	call   e907 <rlc_resegment+0x107>
    e90b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e90e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e911:	e8 fc ff ff ff       	call   e912 <rlc_resegment+0x112>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    e916:	ba 02 00 00 00       	mov    $0x2,%edx
    e91b:	89 f0                	mov    %esi,%eax
    e91d:	e8 fc ff ff ff       	call   e91e <rlc_resegment+0x11e>
    e922:	b9 02 00 00 00       	mov    $0x2,%ecx
    e927:	89 fa                	mov    %edi,%edx
    e929:	e8 fc ff ff ff       	call   e92a <rlc_resegment+0x12a>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e92e:	ba 02 00 00 00       	mov    $0x2,%edx
    e933:	89 f0                	mov    %esi,%eax
    e935:	e8 fc ff ff ff       	call   e936 <rlc_resegment+0x136>
    e93a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e93d:	b9 02 00 00 00       	mov    $0x2,%ecx
    e942:	e8 fc ff ff ff       	call   e943 <rlc_resegment+0x143>

			if(count == 1)
    e947:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
    e94b:	0f 84 47 01 00 00    	je     ea98 <rlc_resegment+0x298>
			{
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
    e951:	7e 3e                	jle    e991 <rlc_resegment+0x191>
			{				
				for(i=0; i < count-1; i++)
    e953:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    e956:	89 d8                	mov    %ebx,%eax
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    e958:	31 d2                	xor    %edx,%edx
    e95a:	89 75 ec             	mov    %esi,-0x14(%ebp)
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    e95d:	83 e9 01             	sub    $0x1,%ecx
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    e960:	89 ce                	mov    %ecx,%esi
    e962:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
    e968:	8b 48 14             	mov    0x14(%eax),%ecx
    e96b:	83 c2 01             	add    $0x1,%edx
    e96e:	89 48 10             	mov    %ecx,0x10(%eax)
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
    e971:	8b 48 54             	mov    0x54(%eax),%ecx
    e974:	89 48 50             	mov    %ecx,0x50(%eax)
    e977:	83 c0 04             	add    $0x4,%eax
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    e97a:	39 f2                	cmp    %esi,%edx
    e97c:	75 ea                	jne    e968 <rlc_resegment+0x168>
    e97e:	8b 75 ec             	mov    -0x14(%ebp),%esi
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
				}
				tbuff->segStart[count-1] = -1;
    e981:	c7 44 93 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%edx,4)
    e988:	ff 
				tbuff->segEnd[count-1] = -1;
    e989:	c7 44 93 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%edx,4)
    e990:	ff 
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			tbuff->segStart[0] += len;
		}
		if(exthead != NULL)
    e991:	85 ff                	test   %edi,%edi
    e993:	74 07                	je     e99c <rlc_resegment+0x19c>
		{
			fsm_mem_free(exthead);
    e995:	89 f8                	mov    %edi,%eax
    e997:	e8 fc ff ff ff       	call   e998 <rlc_resegment+0x198>
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    e99c:	83 c4 20             	add    $0x20,%esp
		if(exthead != NULL)
		{
			fsm_mem_free(exthead);
			exthead=NULL;
		}
		return skb;
    e99f:	89 f0                	mov    %esi,%eax
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    e9a1:	5b                   	pop    %ebx
    e9a2:	5e                   	pop    %esi
    e9a3:	5f                   	pop    %edi
    e9a4:	5d                   	pop    %ebp
    e9a5:	c3                   	ret    
    e9a6:	66 90                	xchg   %ax,%ax
				count--;
			}
		}
		else                    //need resegment
		{
			exthead->SO = start;
    e9a8:	0f b6 c5             	movzbl %ch,%eax
			exthead->LSF = 0;
    e9ab:	83 e0 7f             	and    $0x7f,%eax
    e9ae:	88 47 01             	mov    %al,0x1(%edi)
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    e9b1:	8b 03                	mov    (%ebx),%eax
    e9b3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e9b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    e9bc:	80 48 01 40          	orb    $0x40,0x1(%eax)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    e9c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9c3:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    e9c6:	e8 fc ff ff ff       	call   e9c7 <rlc_resegment+0x1c7>
			fsm_skb_reserve(skb,headLen);
    e9cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    e9ce:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    e9d0:	e8 fc ff ff ff       	call   e9d1 <rlc_resegment+0x1d1>
			len = sizeFromMac - headLen;
    e9d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9d8:	2b 45 ec             	sub    -0x14(%ebp),%eax
			tail = fsm_skb_put(skb,len);
    e9db:	89 c2                	mov    %eax,%edx
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
			fsm_skb_reserve(skb,headLen);
			len = sizeFromMac - headLen;
    e9dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			tail = fsm_skb_put(skb,len);
    e9e0:	89 f0                	mov    %esi,%eax
    e9e2:	e8 fc ff ff ff       	call   e9e3 <rlc_resegment+0x1e3>
			fsm_mem_cpy(skb->data,tbuff->pkt->data + tbuff->headLen  + start,len); 
    e9e7:	8b 03                	mov    (%ebx),%eax
    e9e9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e9ec:	8b 53 0c             	mov    0xc(%ebx),%edx
    e9ef:	01 ca                	add    %ecx,%edx
    e9f1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e9f4:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    e9fa:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    ea00:	e8 fc ff ff ff       	call   ea01 <rlc_resegment+0x201>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
    ea05:	8b 03                	mov    (%ebx),%eax
    ea07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    ea0a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ea10:	83 e9 02             	sub    $0x2,%ecx
    ea13:	89 ca                	mov    %ecx,%edx
    ea15:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ea18:	83 c0 02             	add    $0x2,%eax
    ea1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ea1e:	89 f0                	mov    %esi,%eax
    ea20:	e8 fc ff ff ff       	call   ea21 <rlc_resegment+0x221>
    ea25:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ea28:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ea2b:	e8 fc ff ff ff       	call   ea2c <rlc_resegment+0x22c>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    ea30:	ba 02 00 00 00       	mov    $0x2,%edx
    ea35:	89 f0                	mov    %esi,%eax
    ea37:	e8 fc ff ff ff       	call   ea38 <rlc_resegment+0x238>
    ea3c:	b9 02 00 00 00       	mov    $0x2,%ecx
    ea41:	89 fa                	mov    %edi,%edx
    ea43:	e8 fc ff ff ff       	call   ea44 <rlc_resegment+0x244>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    ea48:	ba 02 00 00 00       	mov    $0x2,%edx
    ea4d:	89 f0                	mov    %esi,%eax
    ea4f:	e8 fc ff ff ff       	call   ea50 <rlc_resegment+0x250>
    ea54:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ea57:	b9 02 00 00 00       	mov    $0x2,%ecx
    ea5c:	e8 fc ff ff ff       	call   ea5d <rlc_resegment+0x25d>
			tbuff->segStart[0] += len;
    ea61:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ea64:	01 53 10             	add    %edx,0x10(%ebx)
    ea67:	e9 25 ff ff ff       	jmp    e991 <rlc_resegment+0x191>
    ea6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
			{
				exthead->LSF = 1;
    ea70:	83 ca 80             	or     $0xffffff80,%edx
    ea73:	88 57 01             	mov    %dl,0x1(%edi)
    ea76:	e9 27 fe ff ff       	jmp    e8a2 <rlc_resegment+0xa2>
    ea7b:	90                   	nop
    ea7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		return skb;
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
    ea80:	c7 04 24 14 38 00 00 	movl   $0x3814,(%esp)
    ea87:	e8 fc ff ff ff       	call   ea88 <rlc_resegment+0x288>
	}
}
    ea8c:	83 c4 20             	add    $0x20,%esp
    ea8f:	5b                   	pop    %ebx
    ea90:	5e                   	pop    %esi
    ea91:	5f                   	pop    %edi
    ea92:	5d                   	pop    %ebp
    ea93:	c3                   	ret    
    ea94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);

			if(count == 1)
			{
				tbuff->segStart[0]=-1;
    ea98:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
				tbuff->segEnd[0]=-1;
    ea9f:	c7 43 50 ff ff ff ff 	movl   $0xffffffff,0x50(%ebx)
    eaa6:	e9 e6 fe ff ff       	jmp    e991 <rlc_resegment+0x191>
    eaab:	90                   	nop
    eaac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000eab0 <rlc_AM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
{
    eab0:	55                   	push   %ebp
    eab1:	89 e5                	mov    %esp,%ebp
    eab3:	57                   	push   %edi
    eab4:	56                   	push   %esi
    eab5:	53                   	push   %ebx
    eab6:	83 ec 44             	sub    $0x44,%esp
    eab9:	e8 fc ff ff ff       	call   eaba <rlc_AM_reassemble_deliver+0xa>
    eabe:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eac1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    eac4:	e8 fc ff ff ff       	call   eac5 <rlc_AM_reassemble_deliver+0x15>
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    eac9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    eacc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    eacf:	0f bf 82 ee 22 00 00 	movswl 0x22ee(%edx),%eax
    ead6:	89 44 24 08          	mov    %eax,0x8(%esp)
    eada:	0f bf 82 f4 22 00 00 	movswl 0x22f4(%edx),%eax
    eae1:	c7 04 24 50 38 00 00 	movl   $0x3850,(%esp)
    eae8:	89 44 24 04          	mov    %eax,0x4(%esp)
    eaec:	e8 fc ff ff ff       	call   eaed <rlc_AM_reassemble_deliver+0x3d>
	u16 h=(amIns->vr_h + 1)%1024;
    eaf1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    eaf4:	0f bf 81 ee 22 00 00 	movswl 0x22ee(%ecx),%eax
    eafb:	83 c0 01             	add    $0x1,%eax
    eafe:	89 c2                	mov    %eax,%edx
    eb00:	c1 fa 1f             	sar    $0x1f,%edx
    eb03:	c1 ea 16             	shr    $0x16,%edx
    eb06:	01 d0                	add    %edx,%eax
    eb08:	25 ff 03 00 00       	and    $0x3ff,%eax
    eb0d:	29 d0                	sub    %edx,%eax
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    eb0f:	0f b7 c0             	movzwl %ax,%eax
    eb12:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    eb15:	0f b7 81 f4 22 00 00 	movzwl 0x22f4(%ecx),%eax
    eb1c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    eb1f:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    eb25:	89 d0                	mov    %edx,%eax
    eb27:	c1 f8 1f             	sar    $0x1f,%eax
    eb2a:	c1 e8 16             	shr    $0x16,%eax
    eb2d:	01 c2                	add    %eax,%edx
    eb2f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    eb35:	29 c2                	sub    %eax,%edx
    eb37:	85 d2                	test   %edx,%edx
    eb39:	89 55 c8             	mov    %edx,-0x38(%ebp)
    eb3c:	0f 8e 16 04 00 00    	jle    ef58 <rlc_AM_reassemble_deliver+0x4a8>
    eb42:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    eb45:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    eb48:	e9 8d 00 00 00       	jmp    ebda <rlc_AM_reassemble_deliver+0x12a>
    eb4d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    eb50:	84 c0                	test   %al,%al
    eb52:	0f 84 88 01 00 00    	je     ece0 <rlc_AM_reassemble_deliver+0x230>
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
					//fsm_octets_print(tbuff->pkt->data,64);
				}
			}
			else if(pduhdr->E==1)
    eb58:	83 e2 04             	and    $0x4,%edx
    eb5b:	0f 85 e7 01 00 00    	jne    ed48 <rlc_AM_reassemble_deliver+0x298>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    eb61:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    eb67:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    eb6d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    eb70:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
				{
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
    eb72:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    eb74:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
    eb7b:	01 10 00 
	entry->prev = LIST_POISON2;
    eb7e:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
    eb85:	02 20 00 
    eb88:	e8 fc ff ff ff       	call   eb89 <rlc_AM_reassemble_deliver+0xd9>
					tbuff = NULL;
				}
			if(icimsg != NULL)
    eb8d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    eb90:	85 c9                	test   %ecx,%ecx
    eb92:	74 08                	je     eb9c <rlc_AM_reassemble_deliver+0xec>
			{
				fsm_mem_free(icimsg);
    eb94:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb97:	e8 fc ff ff ff       	call   eb98 <rlc_AM_reassemble_deliver+0xe8>
				icimsg=NULL;
			}
			amIns->amRecvWindow[i]=NULL;
    eb9c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    eb9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    eba2:	c7 44 98 0c 00 00 00 	movl   $0x0,0xc(%eax,%ebx,4)
    eba9:	00 
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
	u16 h=(amIns->vr_h + 1)%1024;
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    ebaa:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ebae:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    ebb5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebb8:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    ebbb:	05 00 04 00 00       	add    $0x400,%eax
    ebc0:	89 c2                	mov    %eax,%edx
    ebc2:	c1 fa 1f             	sar    $0x1f,%edx
    ebc5:	c1 ea 16             	shr    $0x16,%edx
    ebc8:	01 d0                	add    %edx,%eax
    ebca:	25 ff 03 00 00       	and    $0x3ff,%eax
    ebcf:	29 d0                	sub    %edx,%eax
    ebd1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    ebd4:	0f 8d 7e 03 00 00    	jge    ef58 <rlc_AM_reassemble_deliver+0x4a8>
	//for(i=0; i<=AM_WINDOW_SIZE; i++)
	{
		if(amIns->amRecvWindow[i] != NULL)
    ebda:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    ebdd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ebe0:	81 c3 98 04 00 00    	add    $0x498,%ebx
    ebe6:	8b 74 98 0c          	mov    0xc(%eax,%ebx,4),%esi
    ebea:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    ebed:	85 f6                	test   %esi,%esi
    ebef:	74 b9                	je     ebaa <rlc_AM_reassemble_deliver+0xfa>
		{
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    ebf1:	8b 06                	mov    (%esi),%eax
    ebf3:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    ebf9:	b8 02 00 00 00       	mov    $0x2,%eax
    ebfe:	e8 fc ff ff ff       	call   ebff <rlc_AM_reassemble_deliver+0x14f>
    ec03:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    ec06:	8b 43 02             	mov    0x2(%ebx),%eax
    ec09:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec0c:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    ec0e:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    ec12:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ec15:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ec17:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ec1c:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    ec22:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ec25:	e8 fc ff ff ff       	call   ec26 <rlc_AM_reassemble_deliver+0x176>
    		fsm_printf("[RLC][rlc_AM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    ec2a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ec2e:	c0 e8 03             	shr    $0x3,%al
    ec31:	83 e0 01             	and    $0x1,%eax
    ec34:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ec38:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ec3c:	c0 e8 04             	shr    $0x4,%al
    ec3f:	83 e0 01             	and    $0x1,%eax
    ec42:	89 44 24 08          	mov    %eax,0x8(%esp)
    ec46:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ec4a:	c7 04 24 84 38 00 00 	movl   $0x3884,(%esp)
    ec51:	c0 e8 02             	shr    $0x2,%al
    ec54:	83 e0 01             	and    $0x1,%eax
    ec57:	89 44 24 04          	mov    %eax,0x4(%esp)
    ec5b:	e8 fc ff ff ff       	call   ec5c <rlc_AM_reassemble_deliver+0x1ac>
			//fsm_octets_print(tbuff->pkt->data,64);
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    ec60:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    ec64:	89 d0                	mov    %edx,%eax
    ec66:	83 e0 14             	and    $0x14,%eax
    ec69:	3c 10                	cmp    $0x10,%al
    ec6b:	0f 85 df fe ff ff    	jne    eb50 <rlc_AM_reassemble_deliver+0xa0>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ec71:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ec74:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    ec78:	66 83 f9 ff          	cmp    $0xffff,%cx
    ec7c:	74 2f                	je     ecad <rlc_AM_reassemble_deliver+0x1fd>
    ec7e:	0f bf c9             	movswl %cx,%ecx
    ec81:	0f b6 13             	movzbl (%ebx),%edx
    ec84:	83 c1 01             	add    $0x1,%ecx
    ec87:	89 c8                	mov    %ecx,%eax
    ec89:	c1 f8 1f             	sar    $0x1f,%eax
    ec8c:	c1 e8 16             	shr    $0x16,%eax
    ec8f:	01 c1                	add    %eax,%ecx
    ec91:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ec97:	29 c1                	sub    %eax,%ecx
    ec99:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ec9d:	83 e0 03             	and    $0x3,%eax
    eca0:	c1 e0 08             	shl    $0x8,%eax
    eca3:	09 d0                	or     %edx,%eax
    eca5:	39 c1                	cmp    %eax,%ecx
    eca7:	0f 84 e3 03 00 00    	je     f090 <rlc_AM_reassemble_deliver+0x5e0>
						//fsm_octets_print(new_skb->data,new_skb->len);
					}
				}
				else
				{
					SV(countDropPacket)++;
    ecad:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ecb0:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    ecb7:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ecba:	e8 fc ff ff ff       	call   ecbb <rlc_AM_reassemble_deliver+0x20b>
                    
					if(tbuff->pkt != NULL)
    ecbf:	8b 06                	mov    (%esi),%eax
    ecc1:	85 c0                	test   %eax,%eax
    ecc3:	0f 84 98 fe ff ff    	je     eb61 <rlc_AM_reassemble_deliver+0xb1>
					{
						fsm_pkt_destroy(tbuff->pkt);
    ecc9:	e8 fc ff ff ff       	call   ecca <rlc_AM_reassemble_deliver+0x21a>
						tbuff->pkt = NULL;
    ecce:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    ecd4:	e9 88 fe ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
    ecd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{
				clear_left_pdu(pdu_left);
    ece0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ece3:	e8 fc ff ff ff       	call   ece4 <rlc_AM_reassemble_deliver+0x234>
				if(pduhdr->FIsecond==0)
    ece8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    eceb:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    ecef:	0f 85 6b 02 00 00    	jne    ef60 <rlc_AM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    ecf5:	8b 1e                	mov    (%esi),%ebx
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ecf7:	89 d8                	mov    %ebx,%eax
    ecf9:	e8 fc ff ff ff       	call   ecfa <rlc_AM_reassemble_deliver+0x24a>
    ecfe:	83 f8 01             	cmp    $0x1,%eax
    ed01:	0f 86 9f 04 00 00    	jbe    f1a6 <rlc_AM_reassemble_deliver+0x6f6>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ed07:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ed0a:	b9 02 00 00 00       	mov    $0x2,%ecx
    ed0f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ed15:	e8 fc ff ff ff       	call   ed16 <rlc_AM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ed1a:	89 d8                	mov    %ebx,%eax
    ed1c:	ba 06 00 00 00       	mov    $0x6,%edx
    ed21:	e8 fc ff ff ff       	call   ed22 <rlc_AM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					//list_del(&tbuff->list);
					//fsm_mem_free(tbuff);
					//tbuff=NULL;
					SV(countSendToUpper)++;
    ed26:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ed29:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP2\n");
    ed30:	c7 04 24 48 39 00 00 	movl   $0x3948,(%esp)
    ed37:	e8 fc ff ff ff       	call   ed38 <rlc_AM_reassemble_deliver+0x288>
    ed3c:	e9 20 fe ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
    ed41:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    ed48:	b8 40 00 00 00       	mov    $0x40,%eax
    ed4d:	e8 fc ff ff ff       	call   ed4e <rlc_AM_reassemble_deliver+0x29e>
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ed52:	31 c9                	xor    %ecx,%ecx
    ed54:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    ed56:	89 45 d0             	mov    %eax,-0x30(%ebp)
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ed59:	89 04 24             	mov    %eax,(%esp)
    ed5c:	b8 01 00 00 00       	mov    $0x1,%eax
    ed61:	e8 fc ff ff ff       	call   ed62 <rlc_AM_reassemble_deliver+0x2b2>
               
				if(pduhdr->FIfirst==1)
    ed66:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ed69:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
               
				if(pduhdr->FIfirst==1)
    ed6d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    ed71:	0f 84 81 02 00 00    	je     eff8 <rlc_AM_reassemble_deliver+0x548>
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ed77:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ed7a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    ed7e:	66 83 f8 ff          	cmp    $0xffff,%ax
    ed82:	74 2d                	je     edb1 <rlc_AM_reassemble_deliver+0x301>
    ed84:	98                   	cwtl   
    ed85:	0f b6 13             	movzbl (%ebx),%edx
    ed88:	8d 48 01             	lea    0x1(%eax),%ecx
    ed8b:	89 c8                	mov    %ecx,%eax
    ed8d:	c1 f8 1f             	sar    $0x1f,%eax
    ed90:	c1 e8 16             	shr    $0x16,%eax
    ed93:	01 c1                	add    %eax,%ecx
    ed95:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ed9b:	29 c1                	sub    %eax,%ecx
    ed9d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    eda1:	83 e0 03             	and    $0x3,%eax
    eda4:	c1 e0 08             	shl    $0x8,%eax
    eda7:	09 d0                	or     %edx,%eax
    eda9:	39 c1                	cmp    %eax,%ecx
    edab:	0f 84 08 04 00 00    	je     f1b9 <rlc_AM_reassemble_deliver+0x709>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    edb1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    edb4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    edbb:	8b 45 c0             	mov    -0x40(%ebp),%eax
    edbe:	e8 fc ff ff ff       	call   edbf <rlc_AM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    edc3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    edc6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    edca:	8b 06                	mov    (%esi),%eax
    edcc:	e8 fc ff ff ff       	call   edcd <rlc_AM_reassemble_deliver+0x31d>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    edd1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    edd5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    edd7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    edde:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ede2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    ede5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ede8:	7f 47                	jg     ee31 <rlc_AM_reassemble_deliver+0x381>
    edea:	e9 ab 00 00 00       	jmp    ee9a <rlc_AM_reassemble_deliver+0x3ea>
    edef:	90                   	nop
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    edf0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    edf6:	b9 02 00 00 00       	mov    $0x2,%ecx
    edfb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    edfe:	e8 fc ff ff ff       	call   edff <rlc_AM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ee03:	89 d8                	mov    %ebx,%eax
    ee05:	ba 06 00 00 00       	mov    $0x6,%edx
    ee0a:	e8 fc ff ff ff       	call   ee0b <rlc_AM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ee0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ee12:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    ee19:	c7 04 24 e4 39 00 00 	movl   $0x39e4,(%esp)
    ee20:	e8 fc ff ff ff       	call   ee21 <rlc_AM_reassemble_deliver+0x371>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ee25:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    ee28:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ee2c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    ee2f:	74 67                	je     ee98 <rlc_AM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ee31:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ee34:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ee37:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    ee3c:	89 d8                	mov    %ebx,%eax
    ee3e:	e8 fc ff ff ff       	call   ee3f <rlc_AM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    ee43:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1;  j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ee45:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    ee47:	e8 fc ff ff ff       	call   ee48 <rlc_AM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ee4c:	8b 07                	mov    (%edi),%eax
    ee4e:	89 da                	mov    %ebx,%edx
    ee50:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ee56:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ee59:	89 f0                	mov    %esi,%eax
    ee5b:	e8 fc ff ff ff       	call   ee5c <rlc_AM_reassemble_deliver+0x3ac>
    ee60:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ee63:	89 d9                	mov    %ebx,%ecx
    ee65:	e8 fc ff ff ff       	call   ee66 <rlc_AM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    ee6a:	8b 07                	mov    (%edi),%eax
    ee6c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    ee6e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    ee70:	e8 fc ff ff ff       	call   ee71 <rlc_AM_reassemble_deliver+0x3c1>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ee75:	89 f0                	mov    %esi,%eax
    ee77:	e8 fc ff ff ff       	call   ee78 <rlc_AM_reassemble_deliver+0x3c8>
    ee7c:	83 f8 01             	cmp    $0x1,%eax
    ee7f:	0f 87 6b ff ff ff    	ja     edf0 <rlc_AM_reassemble_deliver+0x340>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    ee85:	ba 02 00 00 00       	mov    $0x2,%edx
    ee8a:	89 f0                	mov    %esi,%eax
    ee8c:	e8 fc ff ff ff       	call   ee8d <rlc_AM_reassemble_deliver+0x3dd>
    ee91:	89 c3                	mov    %eax,%ebx
    ee93:	e9 58 ff ff ff       	jmp    edf0 <rlc_AM_reassemble_deliver+0x340>
    ee98:	89 fe                	mov    %edi,%esi
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    ee9a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    ee9d:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    ee9f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    eea3:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    eea7:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    eea9:	0f 85 e1 00 00 00    	jne    ef90 <rlc_AM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    eeaf:	e8 fc ff ff ff       	call   eeb0 <rlc_AM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    eeb4:	89 da                	mov    %ebx,%edx
                }
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    eeb6:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    eeb8:	e8 fc ff ff ff       	call   eeb9 <rlc_AM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    eebd:	8b 06                	mov    (%esi),%eax
    eebf:	89 da                	mov    %ebx,%edx
    eec1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    eec7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eeca:	89 f8                	mov    %edi,%eax
    eecc:	e8 fc ff ff ff       	call   eecd <rlc_AM_reassemble_deliver+0x41d>
    eed1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eed4:	89 d9                	mov    %ebx,%ecx
    eed6:	e8 fc ff ff ff       	call   eed7 <rlc_AM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    eedb:	8b 06                	mov    (%esi),%eax
    eedd:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    eedf:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    eee1:	e8 fc ff ff ff       	call   eee2 <rlc_AM_reassemble_deliver+0x432>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    eee6:	89 f8                	mov    %edi,%eax
    eee8:	e8 fc ff ff ff       	call   eee9 <rlc_AM_reassemble_deliver+0x439>
    eeed:	83 f8 01             	cmp    $0x1,%eax
    eef0:	0f 86 9d 02 00 00    	jbe    f193 <rlc_AM_reassemble_deliver+0x6e3>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    eef6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eef9:	b9 02 00 00 00       	mov    $0x2,%ecx
    eefe:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ef04:	e8 fc ff ff ff       	call   ef05 <rlc_AM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ef09:	ba 06 00 00 00       	mov    $0x6,%edx
    ef0e:	89 d8                	mov    %ebx,%eax
    ef10:	e8 fc ff ff ff       	call   ef11 <rlc_AM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ef15:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ef18:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP6\n");
    ef1f:	c7 04 24 18 3a 00 00 	movl   $0x3a18,(%esp)
    ef26:	e8 fc ff ff ff       	call   ef27 <rlc_AM_reassemble_deliver+0x477>
					//fsm_octets_print(skb->data,64);

					//list_del(&tbuff->list);
					if(tbuff->pkt != NULL)
    ef2b:	8b 06                	mov    (%esi),%eax
    ef2d:	85 c0                	test   %eax,%eax
    ef2f:	74 0b                	je     ef3c <rlc_AM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
                    {
                    	fsm_pkt_destroy(tbuff->pkt);
    ef31:	e8 fc ff ff ff       	call   ef32 <rlc_AM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    ef36:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					{
						fsm_mem_free(tbuff);
						tbuff = NULL;
					}*/
				}
				if(pPduhdrExt != NULL)
    ef3c:	8b 5d d0             	mov    -0x30(%ebp),%ebx
    ef3f:	85 db                	test   %ebx,%ebx
    ef41:	0f 84 1a fc ff ff    	je     eb61 <rlc_AM_reassemble_deliver+0xb1>
				{
					fsm_mem_free(pPduhdrExt);
    ef47:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ef4a:	e8 fc ff ff ff       	call   ef4b <rlc_AM_reassemble_deliver+0x49b>
    ef4f:	e9 0d fc ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
    ef54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			amIns->amRecvWindow[i]=NULL;
		}//end if
	}//end for
	FOUT;
}
    ef58:	83 c4 44             	add    $0x44,%esp
    ef5b:	5b                   	pop    %ebx
    ef5c:	5e                   	pop    %esi
    ef5d:	5f                   	pop    %edi
    ef5e:	5d                   	pop    %ebp
    ef5f:	c3                   	ret    
					//fsm_printf("[RLC][rlc_AM_reassemble_deliver] data len = %d\n", skb->len);
					//fsm_octets_print(skb->data,skb->len);
				}
				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    ef60:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    ef63:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef67:	0f b6 13             	movzbl (%ebx),%edx
    ef6a:	83 e0 03             	and    $0x3,%eax
    ef6d:	c1 e0 08             	shl    $0x8,%eax
    ef70:	09 d0                	or     %edx,%eax
    ef72:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ef75:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = tbuff->pkt;
    ef79:	8b 06                	mov    (%esi),%eax
    ef7b:	89 42 04             	mov    %eax,0x4(%edx)
					/*list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    ef7e:	c7 04 24 10 39 00 00 	movl   $0x3910,(%esp)
    ef85:	e8 fc ff ff ff       	call   ef86 <rlc_AM_reassemble_deliver+0x4d6>
    ef8a:	e9 d2 fb ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
    ef8f:	90                   	nop
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ef90:	e8 fc ff ff ff       	call   ef91 <rlc_AM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    ef95:	89 da                	mov    %ebx,%edx
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ef97:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    ef99:	e8 fc ff ff ff       	call   ef9a <rlc_AM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ef9e:	8b 06                	mov    (%esi),%eax
    efa0:	89 da                	mov    %ebx,%edx
    efa2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    efa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    efab:	89 f8                	mov    %edi,%eax
    efad:	e8 fc ff ff ff       	call   efae <rlc_AM_reassemble_deliver+0x4fe>
    efb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    efb5:	89 d9                	mov    %ebx,%ecx
    efb7:	e8 fc ff ff ff       	call   efb8 <rlc_AM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    efbc:	8b 06                	mov    (%esi),%eax
    efbe:	8b 50 50             	mov    0x50(%eax),%edx
    efc1:	e8 fc ff ff ff       	call   efc2 <rlc_AM_reassemble_deliver+0x512>

					pdu_left->SN_Left = pduhdr->SN;
    efc6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    efc9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    efcd:	0f b6 13             	movzbl (%ebx),%edx
    efd0:	83 e0 03             	and    $0x3,%eax
    efd3:	c1 e0 08             	shl    $0x8,%eax
    efd6:	09 d0                	or     %edx,%eax
    efd8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    efdb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    efdf:	89 7a 04             	mov    %edi,0x4(%edx)
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
    efe2:	8b 06                	mov    (%esi),%eax
    efe4:	85 c0                	test   %eax,%eax
    efe6:	0f 85 45 ff ff ff    	jne    ef31 <rlc_AM_reassemble_deliver+0x481>
    efec:	e9 4b ff ff ff       	jmp    ef3c <rlc_AM_reassemble_deliver+0x48c>
    eff1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    eff8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    effb:	e8 fc ff ff ff       	call   effc <rlc_AM_reassemble_deliver+0x54c>
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f000:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f003:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f007:	89 d8                	mov    %ebx,%eax
    f009:	e8 fc ff ff ff       	call   f00a <rlc_AM_reassemble_deliver+0x55a>

					fsm_skb_reserve(new_skb,length);
    f00e:	89 da                	mov    %ebx,%edx
				}
				else
				{
					clear_left_pdu(pdu_left);
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f010:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
    f012:	e8 fc ff ff ff       	call   f013 <rlc_AM_reassemble_deliver+0x563>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f017:	8b 06                	mov    (%esi),%eax
    f019:	89 da                	mov    %ebx,%edx
    f01b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f021:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f024:	89 f8                	mov    %edi,%eax
    f026:	e8 fc ff ff ff       	call   f027 <rlc_AM_reassemble_deliver+0x577>
    f02b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f02e:	89 d9                	mov    %ebx,%ecx
    f030:	e8 fc ff ff ff       	call   f031 <rlc_AM_reassemble_deliver+0x581>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f035:	8b 06                	mov    (%esi),%eax
    f037:	89 da                	mov    %ebx,%edx


					skb = new_skb;
    f039:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f03b:	e8 fc ff ff ff       	call   f03c <rlc_AM_reassemble_deliver+0x58c>


					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f040:	89 f8                	mov    %edi,%eax
    f042:	e8 fc ff ff ff       	call   f043 <rlc_AM_reassemble_deliver+0x593>
    f047:	83 f8 01             	cmp    $0x1,%eax
    f04a:	0f 86 34 02 00 00    	jbe    f284 <rlc_AM_reassemble_deliver+0x7d4>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f050:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f053:	b9 02 00 00 00       	mov    $0x2,%ecx
    f058:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f05e:	e8 fc ff ff ff       	call   f05f <rlc_AM_reassemble_deliver+0x5af>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f063:	89 d8                	mov    %ebx,%eax
    f065:	ba 06 00 00 00       	mov    $0x6,%edx
    f06a:	e8 fc ff ff ff       	call   f06b <rlc_AM_reassemble_deliver+0x5bb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f06f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f072:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP4\n");
    f079:	c7 04 24 b0 39 00 00 	movl   $0x39b0,(%esp)
    f080:	e8 fc ff ff ff       	call   f081 <rlc_AM_reassemble_deliver+0x5d1>
    f085:	e9 47 fd ff ff       	jmp    edd1 <rlc_AM_reassemble_deliver+0x321>
    f08a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f090:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f093:	8b 16                	mov    (%esi),%edx
    f095:	8b 41 04             	mov    0x4(%ecx),%eax
    f098:	8b 40 50             	mov    0x50(%eax),%eax
    f09b:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f09f:	0f b7 d8             	movzwl %ax,%ebx
    f0a2:	89 d8                	mov    %ebx,%eax
    f0a4:	e8 fc ff ff ff       	call   f0a5 <rlc_AM_reassemble_deliver+0x5f5>
					fsm_skb_reserve(new_skb,length);
    f0a9:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f0ab:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f0ad:	e8 fc ff ff ff       	call   f0ae <rlc_AM_reassemble_deliver+0x5fe>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f0b2:	8b 06                	mov    (%esi),%eax
    f0b4:	8b 58 50             	mov    0x50(%eax),%ebx
    f0b7:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f0bd:	89 f8                	mov    %edi,%eax
    f0bf:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f0c2:	89 da                	mov    %ebx,%edx
    f0c4:	e8 fc ff ff ff       	call   f0c5 <rlc_AM_reassemble_deliver+0x615>
    f0c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f0cc:	89 d9                	mov    %ebx,%ecx
    f0ce:	e8 fc ff ff ff       	call   f0cf <rlc_AM_reassemble_deliver+0x61f>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f0d3:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f0d6:	8b 42 04             	mov    0x4(%edx),%eax
    f0d9:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f0df:	8b 58 50             	mov    0x50(%eax),%ebx
    f0e2:	89 f8                	mov    %edi,%eax
    f0e4:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f0e7:	89 da                	mov    %ebx,%edx
    f0e9:	e8 fc ff ff ff       	call   f0ea <rlc_AM_reassemble_deliver+0x63a>
    f0ee:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f0f1:	89 d9                	mov    %ebx,%ecx
    f0f3:	e8 fc ff ff ff       	call   f0f4 <rlc_AM_reassemble_deliver+0x644>
					clear_left_pdu(pdu_left);
    f0f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f0fb:	e8 fc ff ff ff       	call   f0fc <rlc_AM_reassemble_deliver+0x64c>
					if(tbuff->pkt != NULL)
    f100:	8b 06                	mov    (%esi),%eax
    f102:	85 c0                	test   %eax,%eax
    f104:	74 0b                	je     f111 <rlc_AM_reassemble_deliver+0x661>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f106:	e8 fc ff ff ff       	call   f107 <rlc_AM_reassemble_deliver+0x657>
						tbuff->pkt = NULL;							
    f10b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f111:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f114:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f118:	75 4c                	jne    f166 <rlc_AM_reassemble_deliver+0x6b6>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f11a:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;							
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f11c:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f11e:	e8 fc ff ff ff       	call   f11f <rlc_AM_reassemble_deliver+0x66f>
    f123:	83 f8 01             	cmp    $0x1,%eax
    f126:	0f 86 6b 01 00 00    	jbe    f297 <rlc_AM_reassemble_deliver+0x7e7>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f12c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f12f:	b9 02 00 00 00       	mov    $0x2,%ecx
    f134:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f13a:	e8 fc ff ff ff       	call   f13b <rlc_AM_reassemble_deliver+0x68b>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f13f:	89 d8                	mov    %ebx,%eax
    f141:	ba 06 00 00 00       	mov    $0x6,%edx
    f146:	e8 fc ff ff ff       	call   f147 <rlc_AM_reassemble_deliver+0x697>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f14b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f14e:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP1\n");
    f155:	c7 04 24 dc 38 00 00 	movl   $0x38dc,(%esp)
    f15c:	e8 fc ff ff ff       	call   f15d <rlc_AM_reassemble_deliver+0x6ad>
    f161:	e9 fb f9 ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
						//fsm_octets_print(skb->data,skb->len);
						//list_del(&tbuff->list);//20150123
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f166:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f169:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f16d:	0f b6 13             	movzbl (%ebx),%edx
    f170:	83 e0 03             	and    $0x3,%eax
    f173:	c1 e0 08             	shl    $0x8,%eax
    f176:	09 d0                	or     %edx,%eax
    f178:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f17b:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    f17f:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f182:	c7 04 24 10 39 00 00 	movl   $0x3910,(%esp)
    f189:	e8 fc ff ff ff       	call   f18a <rlc_AM_reassemble_deliver+0x6da>
    f18e:	e9 ce f9 ff ff       	jmp    eb61 <rlc_AM_reassemble_deliver+0xb1>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f193:	ba 02 00 00 00       	mov    $0x2,%edx
    f198:	89 f8                	mov    %edi,%eax
    f19a:	e8 fc ff ff ff       	call   f19b <rlc_AM_reassemble_deliver+0x6eb>
    f19f:	89 c3                	mov    %eax,%ebx
    f1a1:	e9 50 fd ff ff       	jmp    eef6 <rlc_AM_reassemble_deliver+0x446>
				if(pduhdr->FIsecond==0)
				{
					skb = tbuff->pkt;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f1a6:	89 d8                	mov    %ebx,%eax
    f1a8:	ba 02 00 00 00       	mov    $0x2,%edx
    f1ad:	e8 fc ff ff ff       	call   f1ae <rlc_AM_reassemble_deliver+0x6fe>
    f1b2:	89 c3                	mov    %eax,%ebx
    f1b4:	e9 4e fb ff ff       	jmp    ed07 <rlc_AM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    f1b9:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f1bc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    f1bf:	8b 42 04             	mov    0x4(%edx),%eax
    f1c2:	8b 40 50             	mov    0x50(%eax),%eax
    f1c5:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    f1c9:	0f b7 d8             	movzwl %ax,%ebx
    f1cc:	89 d8                	mov    %ebx,%eax
    f1ce:	e8 fc ff ff ff       	call   f1cf <rlc_AM_reassemble_deliver+0x71f>

						fsm_skb_reserve(new_skb,length);
    f1d3:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    f1d5:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
    f1d7:	e8 fc ff ff ff       	call   f1d8 <rlc_AM_reassemble_deliver+0x728>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    f1dc:	8b 06                	mov    (%esi),%eax
    f1de:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f1e4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f1e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f1ea:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f1ee:	89 f8                	mov    %edi,%eax
    f1f0:	89 da                	mov    %ebx,%edx
    f1f2:	e8 fc ff ff ff       	call   f1f3 <rlc_AM_reassemble_deliver+0x743>
    f1f7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f1fa:	89 d9                	mov    %ebx,%ecx
    f1fc:	e8 fc ff ff ff       	call   f1fd <rlc_AM_reassemble_deliver+0x74d>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f201:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f204:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f208:	8b 06                	mov    (%esi),%eax
    f20a:	e8 fc ff ff ff       	call   f20b <rlc_AM_reassemble_deliver+0x75b>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f20f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f212:	8b 42 04             	mov    0x4(%edx),%eax
    f215:	8b 58 50             	mov    0x50(%eax),%ebx
    f218:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f21e:	89 f8                	mov    %edi,%eax
    f220:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f223:	89 da                	mov    %ebx,%edx
    f225:	e8 fc ff ff ff       	call   f226 <rlc_AM_reassemble_deliver+0x776>
    f22a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f22d:	89 d9                	mov    %ebx,%ecx
						skb = new_skb;
    f22f:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f231:	e8 fc ff ff ff       	call   f232 <rlc_AM_reassemble_deliver+0x782>
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f236:	89 f8                	mov    %edi,%eax
    f238:	e8 fc ff ff ff       	call   f239 <rlc_AM_reassemble_deliver+0x789>
    f23d:	83 f8 01             	cmp    $0x1,%eax
    f240:	76 68                	jbe    f2aa <rlc_AM_reassemble_deliver+0x7fa>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f242:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f245:	b9 02 00 00 00       	mov    $0x2,%ecx
    f24a:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f250:	e8 fc ff ff ff       	call   f251 <rlc_AM_reassemble_deliver+0x7a1>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f255:	ba 06 00 00 00       	mov    $0x6,%edx
    f25a:	89 d8                	mov    %ebx,%eax
    f25c:	e8 fc ff ff ff       	call   f25d <rlc_AM_reassemble_deliver+0x7ad>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f261:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f264:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP3\n");
    f26b:	c7 04 24 7c 39 00 00 	movl   $0x397c,(%esp)
    f272:	e8 fc ff ff ff       	call   f273 <rlc_AM_reassemble_deliver+0x7c3>
						//fsm_octets_print(skb->data,64);
						clear_left_pdu(pdu_left);
    f277:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f27a:	e8 fc ff ff ff       	call   f27b <rlc_AM_reassemble_deliver+0x7cb>
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
               
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    f27f:	e9 4d fb ff ff       	jmp    edd1 <rlc_AM_reassemble_deliver+0x321>

					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f284:	ba 02 00 00 00       	mov    $0x2,%edx
    f289:	89 f8                	mov    %edi,%eax
    f28b:	e8 fc ff ff ff       	call   f28c <rlc_AM_reassemble_deliver+0x7dc>
    f290:	89 c3                	mov    %eax,%ebx
    f292:	e9 b9 fd ff ff       	jmp    f050 <rlc_AM_reassemble_deliver+0x5a0>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f297:	ba 02 00 00 00       	mov    $0x2,%edx
    f29c:	89 f8                	mov    %edi,%eax
    f29e:	e8 fc ff ff ff       	call   f29f <rlc_AM_reassemble_deliver+0x7ef>
    f2a3:	89 c3                	mov    %eax,%ebx
    f2a5:	e9 82 fe ff ff       	jmp    f12c <rlc_AM_reassemble_deliver+0x67c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f2aa:	ba 02 00 00 00       	mov    $0x2,%edx
    f2af:	89 f8                	mov    %edi,%eax
    f2b1:	e8 fc ff ff ff       	call   f2b2 <rlc_AM_reassemble_deliver+0x802>
    f2b6:	89 c3                	mov    %eax,%ebx
    f2b8:	eb 88                	jmp    f242 <rlc_AM_reassemble_deliver+0x792>
    f2ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f2c0 <rlc_UM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    f2c0:	55                   	push   %ebp
    f2c1:	89 e5                	mov    %esp,%ebp
    f2c3:	57                   	push   %edi
    f2c4:	56                   	push   %esi
    f2c5:	53                   	push   %ebx
    f2c6:	83 ec 44             	sub    $0x44,%esp
    f2c9:	e8 fc ff ff ff       	call   f2ca <rlc_UM_reassemble_deliver+0xa>
    f2ce:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f2d1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
    f2d4:	c7 04 24 4c 3a 00 00 	movl   $0x3a4c,(%esp)
    f2db:	e8 fc ff ff ff       	call   f2dc <rlc_UM_reassemble_deliver+0x1c>
	SV_PTR_GET(rlc_mac_sv);
    f2e0:	e8 fc ff ff ff       	call   f2e1 <rlc_UM_reassemble_deliver+0x21>
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f2e5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f2e8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
	SV_PTR_GET(rlc_mac_sv);
    f2eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f2ee:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    f2f5:	83 c0 01             	add    $0x1,%eax
    f2f8:	89 c2                	mov    %eax,%edx
    f2fa:	c1 fa 1f             	sar    $0x1f,%edx
    f2fd:	c1 ea 16             	shr    $0x16,%edx
    f300:	01 d0                	add    %edx,%eax
    f302:	25 ff 03 00 00       	and    $0x3ff,%eax
    f307:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f309:	0f b7 c0             	movzwl %ax,%eax
    f30c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    f30f:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    f316:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f319:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    f31f:	89 d0                	mov    %edx,%eax
    f321:	c1 f8 1f             	sar    $0x1f,%eax
    f324:	c1 e8 16             	shr    $0x16,%eax
    f327:	01 c2                	add    %eax,%edx
    f329:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    f32f:	29 c2                	sub    %eax,%edx
    f331:	85 d2                	test   %edx,%edx
    f333:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f336:	0f 8e 2c 04 00 00    	jle    f768 <rlc_UM_reassemble_deliver+0x4a8>
    f33c:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    f33f:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    f342:	e9 83 00 00 00       	jmp    f3ca <rlc_UM_reassemble_deliver+0x10a>
    f347:	90                   	nop
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    f348:	84 c0                	test   %al,%al
    f34a:	0f 84 a0 01 00 00    	je     f4f0 <rlc_UM_reassemble_deliver+0x230>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft=tbuff->pkt;
					fsm_printf("[RLC] Not a complet SDU\n");
				}
			}
			else if(pduhdr->E==1)
    f350:	83 e2 04             	and    $0x4,%edx
    f353:	0f 85 ff 01 00 00    	jne    f558 <rlc_UM_reassemble_deliver+0x298>
				{
					fsm_mem_free(pPduhdrExt);
					pPduhdrExt = NULL;
				}
			}
			if(tbuff != NULL)
    f359:	85 f6                	test   %esi,%esi
    f35b:	74 20                	je     f37d <rlc_UM_reassemble_deliver+0xbd>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    f35d:	8b 46 14             	mov    0x14(%esi),%eax
    f360:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    f363:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    f366:	89 10                	mov    %edx,(%eax)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    f368:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    f36a:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    f371:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    f378:	e8 fc ff ff ff       	call   f379 <rlc_UM_reassemble_deliver+0xb9>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    f37d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    f380:	85 f6                	test   %esi,%esi
    f382:	74 08                	je     f38c <rlc_UM_reassemble_deliver+0xcc>
			{
				fsm_mem_free(icimsg);
    f384:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f387:	e8 fc ff ff ff       	call   f388 <rlc_UM_reassemble_deliver+0xc8>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    f38c:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f38f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f392:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
    f399:	00 
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f39a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f39e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    f3a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3a8:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f3ab:	05 00 04 00 00       	add    $0x400,%eax
    f3b0:	89 c2                	mov    %eax,%edx
    f3b2:	c1 fa 1f             	sar    $0x1f,%edx
    f3b5:	c1 ea 16             	shr    $0x16,%edx
    f3b8:	01 d0                	add    %edx,%eax
    f3ba:	25 ff 03 00 00       	and    $0x3ff,%eax
    f3bf:	29 d0                	sub    %edx,%eax
    f3c1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    f3c4:	0f 8d 9e 03 00 00    	jge    f768 <rlc_UM_reassemble_deliver+0x4a8>
	{
		if(umIns->umRecvWindow10[i] != NULL)
    f3ca:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f3cd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f3d0:	83 c3 2c             	add    $0x2c,%ebx
    f3d3:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
    f3d7:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    f3da:	85 c0                	test   %eax,%eax
    f3dc:	74 bc                	je     f39a <rlc_UM_reassemble_deliver+0xda>
		{
			fsm_printf("[RLC]  umIns->umRecvWindow10[i] != NULL, i = %d\n",i);
    f3de:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f3e1:	c7 04 24 74 3a 00 00 	movl   $0x3a74,(%esp)
    f3e8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    f3ec:	e8 fc ff ff ff       	call   f3ed <rlc_UM_reassemble_deliver+0x12d>
			tbuff = umIns->umRecvWindow10[i];
    f3f1:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f3f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f3f7:	8b 74 98 08          	mov    0x8(%eax,%ebx,4),%esi
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    f3fb:	8b 06                	mov    (%esi),%eax
    f3fd:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    f403:	b8 02 00 00 00       	mov    $0x2,%eax
    f408:	e8 fc ff ff ff       	call   f409 <rlc_UM_reassemble_deliver+0x149>
    f40d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    f410:	8b 43 02             	mov    0x2(%ebx),%eax
    f413:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f416:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    f418:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    f41c:	88 42 01             	mov    %al,0x1(%edx)
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f41f:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f421:	ba 02 00 00 00       	mov    $0x2,%edx
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f426:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    f42c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f42f:	e8 fc ff ff ff       	call   f430 <rlc_UM_reassemble_deliver+0x170>
			//get_UmPduhead(umIns->umRecvWindow10[i],pduhdr) ;
			fsm_octets_print(pduhdr,2);
    f434:	ba 02 00 00 00       	mov    $0x2,%edx
    f439:	89 d8                	mov    %ebx,%eax
    f43b:	e8 fc ff ff ff       	call   f43c <rlc_UM_reassemble_deliver+0x17c>
          	fsm_printf("[RLC][rlc_UM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    f440:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f444:	c0 e8 03             	shr    $0x3,%al
    f447:	83 e0 01             	and    $0x1,%eax
    f44a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f44e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f452:	c0 e8 04             	shr    $0x4,%al
    f455:	83 e0 01             	and    $0x1,%eax
    f458:	89 44 24 08          	mov    %eax,0x8(%esp)
    f45c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f460:	c7 04 24 a8 3a 00 00 	movl   $0x3aa8,(%esp)
    f467:	c0 e8 02             	shr    $0x2,%al
    f46a:	83 e0 01             	and    $0x1,%eax
    f46d:	89 44 24 04          	mov    %eax,0x4(%esp)
    f471:	e8 fc ff ff ff       	call   f472 <rlc_UM_reassemble_deliver+0x1b2>
			
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    f476:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    f47a:	89 d0                	mov    %edx,%eax
    f47c:	83 e0 14             	and    $0x14,%eax
    f47f:	3c 10                	cmp    $0x10,%al
    f481:	0f 85 c1 fe ff ff    	jne    f348 <rlc_UM_reassemble_deliver+0x88>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f487:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f48a:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    f48e:	66 83 f9 ff          	cmp    $0xffff,%cx
    f492:	74 2f                	je     f4c3 <rlc_UM_reassemble_deliver+0x203>
    f494:	0f bf c9             	movswl %cx,%ecx
    f497:	0f b6 13             	movzbl (%ebx),%edx
    f49a:	83 c1 01             	add    $0x1,%ecx
    f49d:	89 c8                	mov    %ecx,%eax
    f49f:	c1 f8 1f             	sar    $0x1f,%eax
    f4a2:	c1 e8 16             	shr    $0x16,%eax
    f4a5:	01 c1                	add    %eax,%ecx
    f4a7:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f4ad:	29 c1                	sub    %eax,%ecx
    f4af:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f4b3:	83 e0 03             	and    $0x3,%eax
    f4b6:	c1 e0 08             	shl    $0x8,%eax
    f4b9:	09 d0                	or     %edx,%eax
    f4bb:	39 c1                	cmp    %eax,%ecx
    f4bd:	0f 84 e5 03 00 00    	je     f8a8 <rlc_UM_reassemble_deliver+0x5e8>
						fsm_printf("[RLC] Not a complet SDU\n");
					}
				}
				else
				{
					SV(countDropPacket)++;
    f4c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f4c6:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    f4cd:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f4d0:	e8 fc ff ff ff       	call   f4d1 <rlc_UM_reassemble_deliver+0x211>
					if(tbuff->pkt != NULL)
    f4d5:	8b 06                	mov    (%esi),%eax
    f4d7:	85 c0                	test   %eax,%eax
    f4d9:	0f 84 7a fe ff ff    	je     f359 <rlc_UM_reassemble_deliver+0x99>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f4df:	e8 fc ff ff ff       	call   f4e0 <rlc_UM_reassemble_deliver+0x220>
						tbuff->pkt = NULL;
    f4e4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    f4ea:	e9 6a fe ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
    f4ef:	90                   	nop
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    f4f0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f4f3:	e8 fc ff ff ff       	call   f4f4 <rlc_UM_reassemble_deliver+0x234>

				if(pduhdr->FIsecond==0)
    f4f8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f4fb:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f4ff:	0f 85 6b 02 00 00    	jne    f770 <rlc_UM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    f505:	8b 1e                	mov    (%esi),%ebx
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f507:	89 d8                	mov    %ebx,%eax
    f509:	e8 fc ff ff ff       	call   f50a <rlc_UM_reassemble_deliver+0x24a>
    f50e:	83 f8 01             	cmp    $0x1,%eax
    f511:	0f 86 a7 04 00 00    	jbe    f9be <rlc_UM_reassemble_deliver+0x6fe>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f517:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f51a:	b9 02 00 00 00       	mov    $0x2,%ecx
    f51f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f525:	e8 fc ff ff ff       	call   f526 <rlc_UM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f52a:	89 d8                	mov    %ebx,%eax
    f52c:	ba 06 00 00 00       	mov    $0x6,%edx
    f531:	e8 fc ff ff ff       	call   f532 <rlc_UM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f536:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f539:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
    f540:	c7 04 24 34 3b 00 00 	movl   $0x3b34,(%esp)
    f547:	e8 fc ff ff ff       	call   f548 <rlc_UM_reassemble_deliver+0x288>
    f54c:	e9 08 fe ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
    f551:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f558:	b8 40 00 00 00       	mov    $0x40,%eax
    f55d:	e8 fc ff ff ff       	call   f55e <rlc_UM_reassemble_deliver+0x29e>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f562:	31 c9                	xor    %ecx,%ecx
    f564:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f566:	89 45 d0             	mov    %eax,-0x30(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f569:	89 04 24             	mov    %eax,(%esp)
    f56c:	b8 01 00 00 00       	mov    $0x1,%eax
    f571:	e8 fc ff ff ff       	call   f572 <rlc_UM_reassemble_deliver+0x2b2>
                
				if(pduhdr->FIfirst==1)
    f576:	8b 5d e8             	mov    -0x18(%ebp),%ebx
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f579:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
                
				if(pduhdr->FIfirst==1)
    f57d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    f581:	0f 84 89 02 00 00    	je     f810 <rlc_UM_reassemble_deliver+0x550>
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f587:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f58a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    f58e:	66 83 f8 ff          	cmp    $0xffff,%ax
    f592:	74 2d                	je     f5c1 <rlc_UM_reassemble_deliver+0x301>
    f594:	98                   	cwtl   
    f595:	0f b6 13             	movzbl (%ebx),%edx
    f598:	8d 48 01             	lea    0x1(%eax),%ecx
    f59b:	89 c8                	mov    %ecx,%eax
    f59d:	c1 f8 1f             	sar    $0x1f,%eax
    f5a0:	c1 e8 16             	shr    $0x16,%eax
    f5a3:	01 c1                	add    %eax,%ecx
    f5a5:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f5ab:	29 c1                	sub    %eax,%ecx
    f5ad:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f5b1:	83 e0 03             	and    $0x3,%eax
    f5b4:	c1 e0 08             	shl    $0x8,%eax
    f5b7:	09 d0                	or     %edx,%eax
    f5b9:	39 c1                	cmp    %eax,%ecx
    f5bb:	0f 84 10 04 00 00    	je     f9d1 <rlc_UM_reassemble_deliver+0x711>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    f5c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f5c4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    f5cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f5ce:	e8 fc ff ff ff       	call   f5cf <rlc_UM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f5d3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f5d6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f5da:	8b 06                	mov    (%esi),%eax
    f5dc:	e8 fc ff ff ff       	call   f5dd <rlc_UM_reassemble_deliver+0x31d>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f5e1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    f5e5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f5e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f5ee:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f5f2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f5f5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f5f8:	7f 47                	jg     f641 <rlc_UM_reassemble_deliver+0x381>
    f5fa:	e9 ab 00 00 00       	jmp    f6aa <rlc_UM_reassemble_deliver+0x3ea>
    f5ff:	90                   	nop
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f600:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f606:	b9 02 00 00 00       	mov    $0x2,%ecx
    f60b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f60e:	e8 fc ff ff ff       	call   f60f <rlc_UM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f613:	89 d8                	mov    %ebx,%eax
    f615:	ba 06 00 00 00       	mov    $0x6,%edx
    f61a:	e8 fc ff ff ff       	call   f61b <rlc_UM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f61f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f622:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f629:	c7 04 24 d0 3b 00 00 	movl   $0x3bd0,(%esp)
    f630:	e8 fc ff ff ff       	call   f631 <rlc_UM_reassemble_deliver+0x371>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f635:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f638:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f63c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f63f:	74 67                	je     f6a8 <rlc_UM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f641:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f644:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f647:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f64c:	89 d8                	mov    %ebx,%eax
    f64e:	e8 fc ff ff ff       	call   f64f <rlc_UM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f653:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f655:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f657:	e8 fc ff ff ff       	call   f658 <rlc_UM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f65c:	8b 07                	mov    (%edi),%eax
    f65e:	89 da                	mov    %ebx,%edx
    f660:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f666:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f669:	89 f0                	mov    %esi,%eax
    f66b:	e8 fc ff ff ff       	call   f66c <rlc_UM_reassemble_deliver+0x3ac>
    f670:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f673:	89 d9                	mov    %ebx,%ecx
    f675:	e8 fc ff ff ff       	call   f676 <rlc_UM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f67a:	8b 07                	mov    (%edi),%eax
    f67c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f67e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f680:	e8 fc ff ff ff       	call   f681 <rlc_UM_reassemble_deliver+0x3c1>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f685:	89 f0                	mov    %esi,%eax
    f687:	e8 fc ff ff ff       	call   f688 <rlc_UM_reassemble_deliver+0x3c8>
    f68c:	83 f8 01             	cmp    $0x1,%eax
    f68f:	0f 87 6b ff ff ff    	ja     f600 <rlc_UM_reassemble_deliver+0x340>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f695:	ba 02 00 00 00       	mov    $0x2,%edx
    f69a:	89 f0                	mov    %esi,%eax
    f69c:	e8 fc ff ff ff       	call   f69d <rlc_UM_reassemble_deliver+0x3dd>
    f6a1:	89 c3                	mov    %eax,%ebx
    f6a3:	e9 58 ff ff ff       	jmp    f600 <rlc_UM_reassemble_deliver+0x340>
    f6a8:	89 fe                	mov    %edi,%esi
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f6aa:	8b 5d e8             	mov    -0x18(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f6ad:	8b 06                	mov    (%esi),%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f6af:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f6b3:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f6b7:	89 d8                	mov    %ebx,%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f6b9:	0f 85 e1 00 00 00    	jne    f7a0 <rlc_UM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f6bf:	e8 fc ff ff ff       	call   f6c0 <rlc_UM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f6c4:	89 da                	mov    %ebx,%edx
				}
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f6c6:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f6c8:	e8 fc ff ff ff       	call   f6c9 <rlc_UM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f6cd:	8b 06                	mov    (%esi),%eax
    f6cf:	89 da                	mov    %ebx,%edx
    f6d1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f6d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6da:	89 f8                	mov    %edi,%eax
    f6dc:	e8 fc ff ff ff       	call   f6dd <rlc_UM_reassemble_deliver+0x41d>
    f6e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f6e4:	89 d9                	mov    %ebx,%ecx
    f6e6:	e8 fc ff ff ff       	call   f6e7 <rlc_UM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f6eb:	8b 06                	mov    (%esi),%eax
    f6ed:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    f6ef:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f6f1:	e8 fc ff ff ff       	call   f6f2 <rlc_UM_reassemble_deliver+0x432>
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f6f6:	89 f8                	mov    %edi,%eax
    f6f8:	e8 fc ff ff ff       	call   f6f9 <rlc_UM_reassemble_deliver+0x439>
    f6fd:	83 f8 01             	cmp    $0x1,%eax
    f700:	0f 86 a5 02 00 00    	jbe    f9ab <rlc_UM_reassemble_deliver+0x6eb>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f706:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f709:	b9 02 00 00 00       	mov    $0x2,%ecx
    f70e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f714:	e8 fc ff ff ff       	call   f715 <rlc_UM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f719:	ba 06 00 00 00       	mov    $0x6,%edx
    f71e:	89 d8                	mov    %ebx,%eax
    f720:	e8 fc ff ff ff       	call   f721 <rlc_UM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f725:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f728:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP6\n");				
    f72f:	c7 04 24 04 3c 00 00 	movl   $0x3c04,(%esp)
    f736:	e8 fc ff ff ff       	call   f737 <rlc_UM_reassemble_deliver+0x477>
					if(tbuff->pkt != NULL)
    f73b:	8b 06                	mov    (%esi),%eax
    f73d:	85 c0                	test   %eax,%eax
    f73f:	74 0b                	je     f74c <rlc_UM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					fsm_printf("[RLC]Not a complet SDU\n");
					if(tbuff->pkt != NULL)
					{
						fsm_pkt_destroy(tbuff->pkt);
    f741:	e8 fc ff ff ff       	call   f742 <rlc_UM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    f746:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
				}
				if(pPduhdrExt != NULL)
    f74c:	8b 7d d0             	mov    -0x30(%ebp),%edi
    f74f:	85 ff                	test   %edi,%edi
    f751:	0f 84 02 fc ff ff    	je     f359 <rlc_UM_reassemble_deliver+0x99>
				{
					fsm_mem_free(pPduhdrExt);
    f757:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f75a:	e8 fc ff ff ff       	call   f75b <rlc_UM_reassemble_deliver+0x49b>
    f75f:	e9 f5 fb ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
    f764:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			umIns->umRecvWindow10[i]=NULL;
			
		}//end if
	}//end for
}
    f768:	83 c4 44             	add    $0x44,%esp
    f76b:	5b                   	pop    %ebx
    f76c:	5e                   	pop    %esi
    f76d:	5f                   	pop    %edi
    f76e:	5d                   	pop    %ebp
    f76f:	c3                   	ret    
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
				}

				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    f770:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f773:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f777:	0f b6 13             	movzbl (%ebx),%edx
    f77a:	83 e0 03             	and    $0x3,%eax
    f77d:	c1 e0 08             	shl    $0x8,%eax
    f780:	09 d0                	or     %edx,%eax
    f782:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f785:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    f789:	8b 06                	mov    (%esi),%eax
    f78b:	89 42 04             	mov    %eax,0x4(%edx)
					fsm_printf("[RLC] Not a complet SDU\n");
    f78e:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    f795:	e8 fc ff ff ff       	call   f796 <rlc_UM_reassemble_deliver+0x4d6>
    f79a:	e9 ba fb ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
    f79f:	90                   	nop
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f7a0:	e8 fc ff ff ff       	call   f7a1 <rlc_UM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f7a5:	89 da                	mov    %ebx,%edx
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f7a7:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f7a9:	e8 fc ff ff ff       	call   f7aa <rlc_UM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f7ae:	8b 06                	mov    (%esi),%eax
    f7b0:	89 da                	mov    %ebx,%edx
    f7b2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f7b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7bb:	89 f8                	mov    %edi,%eax
    f7bd:	e8 fc ff ff ff       	call   f7be <rlc_UM_reassemble_deliver+0x4fe>
    f7c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f7c5:	89 d9                	mov    %ebx,%ecx
    f7c7:	e8 fc ff ff ff       	call   f7c8 <rlc_UM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f7cc:	8b 06                	mov    (%esi),%eax
    f7ce:	8b 50 50             	mov    0x50(%eax),%edx
    f7d1:	e8 fc ff ff ff       	call   f7d2 <rlc_UM_reassemble_deliver+0x512>
                   
					pdu_left->SN_Left = pduhdr->SN;
    f7d6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f7d9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f7dd:	0f b6 13             	movzbl (%ebx),%edx
    f7e0:	83 e0 03             	and    $0x3,%eax
    f7e3:	c1 e0 08             	shl    $0x8,%eax
    f7e6:	09 d0                	or     %edx,%eax
    f7e8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f7eb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f7ef:	89 7a 04             	mov    %edi,0x4(%edx)
					fsm_printf("[RLC]Not a complet SDU\n");
    f7f2:	c7 04 24 d3 07 00 00 	movl   $0x7d3,(%esp)
    f7f9:	e8 fc ff ff ff       	call   f7fa <rlc_UM_reassemble_deliver+0x53a>
					if(tbuff->pkt != NULL)
    f7fe:	8b 06                	mov    (%esi),%eax
    f800:	85 c0                	test   %eax,%eax
    f802:	0f 85 39 ff ff ff    	jne    f741 <rlc_UM_reassemble_deliver+0x481>
    f808:	e9 3f ff ff ff       	jmp    f74c <rlc_UM_reassemble_deliver+0x48c>
    f80d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f810:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f813:	e8 fc ff ff ff       	call   f814 <rlc_UM_reassemble_deliver+0x554>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f818:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f81b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f81f:	89 d8                	mov    %ebx,%eax
    f821:	e8 fc ff ff ff       	call   f822 <rlc_UM_reassemble_deliver+0x562>
					fsm_skb_reserve(new_skb,length);
    f826:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f828:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f82a:	e8 fc ff ff ff       	call   f82b <rlc_UM_reassemble_deliver+0x56b>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f82f:	8b 06                	mov    (%esi),%eax
    f831:	89 da                	mov    %ebx,%edx
    f833:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f839:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f83c:	89 f8                	mov    %edi,%eax
    f83e:	e8 fc ff ff ff       	call   f83f <rlc_UM_reassemble_deliver+0x57f>
    f843:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f846:	89 d9                	mov    %ebx,%ecx
    f848:	e8 fc ff ff ff       	call   f849 <rlc_UM_reassemble_deliver+0x589>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f84d:	8b 06                	mov    (%esi),%eax
    f84f:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f851:	89 fb                	mov    %edi,%ebx

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f853:	e8 fc ff ff ff       	call   f854 <rlc_UM_reassemble_deliver+0x594>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f858:	89 f8                	mov    %edi,%eax
    f85a:	e8 fc ff ff ff       	call   f85b <rlc_UM_reassemble_deliver+0x59b>
    f85f:	83 f8 01             	cmp    $0x1,%eax
    f862:	0f 86 34 02 00 00    	jbe    fa9c <rlc_UM_reassemble_deliver+0x7dc>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f868:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f86b:	b9 02 00 00 00       	mov    $0x2,%ecx
    f870:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f876:	e8 fc ff ff ff       	call   f877 <rlc_UM_reassemble_deliver+0x5b7>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f87b:	89 d8                	mov    %ebx,%eax
    f87d:	ba 06 00 00 00       	mov    $0x6,%edx
    f882:	e8 fc ff ff ff       	call   f883 <rlc_UM_reassemble_deliver+0x5c3>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f887:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f88a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
    f891:	c7 04 24 9c 3b 00 00 	movl   $0x3b9c,(%esp)
    f898:	e8 fc ff ff ff       	call   f899 <rlc_UM_reassemble_deliver+0x5d9>
    f89d:	e9 3f fd ff ff       	jmp    f5e1 <rlc_UM_reassemble_deliver+0x321>
    f8a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f8a8:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f8ab:	8b 16                	mov    (%esi),%edx
    f8ad:	8b 41 04             	mov    0x4(%ecx),%eax
    f8b0:	8b 40 50             	mov    0x50(%eax),%eax
    f8b3:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f8b7:	0f b7 d8             	movzwl %ax,%ebx
    f8ba:	89 d8                	mov    %ebx,%eax
    f8bc:	e8 fc ff ff ff       	call   f8bd <rlc_UM_reassemble_deliver+0x5fd>
					fsm_skb_reserve(new_skb,length);
    f8c1:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f8c3:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f8c5:	e8 fc ff ff ff       	call   f8c6 <rlc_UM_reassemble_deliver+0x606>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f8ca:	8b 06                	mov    (%esi),%eax
    f8cc:	8b 58 50             	mov    0x50(%eax),%ebx
    f8cf:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f8d5:	89 f8                	mov    %edi,%eax
    f8d7:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f8da:	89 da                	mov    %ebx,%edx
    f8dc:	e8 fc ff ff ff       	call   f8dd <rlc_UM_reassemble_deliver+0x61d>
    f8e1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8e4:	89 d9                	mov    %ebx,%ecx
    f8e6:	e8 fc ff ff ff       	call   f8e7 <rlc_UM_reassemble_deliver+0x627>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f8eb:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f8ee:	8b 42 04             	mov    0x4(%edx),%eax
    f8f1:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f8f7:	8b 58 50             	mov    0x50(%eax),%ebx
    f8fa:	89 f8                	mov    %edi,%eax
    f8fc:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f8ff:	89 da                	mov    %ebx,%edx
    f901:	e8 fc ff ff ff       	call   f902 <rlc_UM_reassemble_deliver+0x642>
    f906:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f909:	89 d9                	mov    %ebx,%ecx
    f90b:	e8 fc ff ff ff       	call   f90c <rlc_UM_reassemble_deliver+0x64c>
					clear_left_pdu(pdu_left);
    f910:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f913:	e8 fc ff ff ff       	call   f914 <rlc_UM_reassemble_deliver+0x654>
					if(tbuff->pkt != NULL)
    f918:	8b 06                	mov    (%esi),%eax
    f91a:	85 c0                	test   %eax,%eax
    f91c:	74 0b                	je     f929 <rlc_UM_reassemble_deliver+0x669>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f91e:	e8 fc ff ff ff       	call   f91f <rlc_UM_reassemble_deliver+0x65f>
						tbuff->pkt = NULL;
    f923:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f929:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f92c:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f930:	75 4c                	jne    f97e <rlc_UM_reassemble_deliver+0x6be>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f932:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f934:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f936:	e8 fc ff ff ff       	call   f937 <rlc_UM_reassemble_deliver+0x677>
    f93b:	83 f8 01             	cmp    $0x1,%eax
    f93e:	0f 86 6b 01 00 00    	jbe    faaf <rlc_UM_reassemble_deliver+0x7ef>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f944:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f947:	b9 02 00 00 00       	mov    $0x2,%ecx
    f94c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f952:	e8 fc ff ff ff       	call   f953 <rlc_UM_reassemble_deliver+0x693>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f957:	89 d8                	mov    %ebx,%eax
    f959:	ba 06 00 00 00       	mov    $0x6,%edx
    f95e:	e8 fc ff ff ff       	call   f95f <rlc_UM_reassemble_deliver+0x69f>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f963:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f966:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP1\n");
    f96d:	c7 04 24 00 3b 00 00 	movl   $0x3b00,(%esp)
    f974:	e8 fc ff ff ff       	call   f975 <rlc_UM_reassemble_deliver+0x6b5>
    f979:	e9 db f9 ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f97e:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f981:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f985:	0f b6 13             	movzbl (%ebx),%edx
    f988:	83 e0 03             	and    $0x3,%eax
    f98b:	c1 e0 08             	shl    $0x8,%eax
    f98e:	09 d0                	or     %edx,%eax
    f990:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f993:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    f997:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC] Not a complet SDU\n");
    f99a:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    f9a1:	e8 fc ff ff ff       	call   f9a2 <rlc_UM_reassemble_deliver+0x6e2>
    f9a6:	e9 ae f9 ff ff       	jmp    f359 <rlc_UM_reassemble_deliver+0x99>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f9ab:	ba 02 00 00 00       	mov    $0x2,%edx
    f9b0:	89 f8                	mov    %edi,%eax
    f9b2:	e8 fc ff ff ff       	call   f9b3 <rlc_UM_reassemble_deliver+0x6f3>
    f9b7:	89 c3                	mov    %eax,%ebx
    f9b9:	e9 48 fd ff ff       	jmp    f706 <rlc_UM_reassemble_deliver+0x446>
				{
					skb = tbuff->pkt;
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f9be:	89 d8                	mov    %ebx,%eax
    f9c0:	ba 02 00 00 00       	mov    $0x2,%edx
    f9c5:	e8 fc ff ff ff       	call   f9c6 <rlc_UM_reassemble_deliver+0x706>
    f9ca:	89 c3                	mov    %eax,%ebx
    f9cc:	e9 46 fb ff ff       	jmp    f517 <rlc_UM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    f9d1:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f9d4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    f9d7:	8b 42 04             	mov    0x4(%edx),%eax
    f9da:	8b 40 50             	mov    0x50(%eax),%eax
    f9dd:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    f9e1:	0f b7 d8             	movzwl %ax,%ebx
    f9e4:	89 d8                	mov    %ebx,%eax
    f9e6:	e8 fc ff ff ff       	call   f9e7 <rlc_UM_reassemble_deliver+0x727>
						fsm_skb_reserve(new_skb,length);
    f9eb:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    f9ed:	89 c7                	mov    %eax,%edi
						fsm_skb_reserve(new_skb,length);
    f9ef:	e8 fc ff ff ff       	call   f9f0 <rlc_UM_reassemble_deliver+0x730>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    f9f4:	8b 06                	mov    (%esi),%eax
    f9f6:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f9fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f9ff:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fa02:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    fa06:	89 f8                	mov    %edi,%eax
    fa08:	89 da                	mov    %ebx,%edx
    fa0a:	e8 fc ff ff ff       	call   fa0b <rlc_UM_reassemble_deliver+0x74b>
    fa0f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa12:	89 d9                	mov    %ebx,%ecx
    fa14:	e8 fc ff ff ff       	call   fa15 <rlc_UM_reassemble_deliver+0x755>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fa19:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fa1c:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    fa20:	8b 06                	mov    (%esi),%eax
    fa22:	e8 fc ff ff ff       	call   fa23 <rlc_UM_reassemble_deliver+0x763>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fa27:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fa2a:	8b 42 04             	mov    0x4(%edx),%eax
    fa2d:	8b 58 50             	mov    0x50(%eax),%ebx
    fa30:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fa36:	89 f8                	mov    %edi,%eax
    fa38:	89 55 d8             	mov    %edx,-0x28(%ebp)
    fa3b:	89 da                	mov    %ebx,%edx
    fa3d:	e8 fc ff ff ff       	call   fa3e <rlc_UM_reassemble_deliver+0x77e>
    fa42:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa45:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
    fa47:	89 fb                	mov    %edi,%ebx
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fa49:	e8 fc ff ff ff       	call   fa4a <rlc_UM_reassemble_deliver+0x78a>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fa4e:	89 f8                	mov    %edi,%eax
    fa50:	e8 fc ff ff ff       	call   fa51 <rlc_UM_reassemble_deliver+0x791>
    fa55:	83 f8 01             	cmp    $0x1,%eax
    fa58:	76 68                	jbe    fac2 <rlc_UM_reassemble_deliver+0x802>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fa5a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fa5d:	b9 02 00 00 00       	mov    $0x2,%ecx
    fa62:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fa68:	e8 fc ff ff ff       	call   fa69 <rlc_UM_reassemble_deliver+0x7a9>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    fa6d:	ba 06 00 00 00       	mov    $0x6,%edx
    fa72:	89 d8                	mov    %ebx,%eax
    fa74:	e8 fc ff ff ff       	call   fa75 <rlc_UM_reassemble_deliver+0x7b5>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    fa79:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fa7c:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP3\n");
    fa83:	c7 04 24 68 3b 00 00 	movl   $0x3b68,(%esp)
    fa8a:	e8 fc ff ff ff       	call   fa8b <rlc_UM_reassemble_deliver+0x7cb>
						
						clear_left_pdu(pdu_left);
    fa8f:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fa92:	e8 fc ff ff ff       	call   fa93 <rlc_UM_reassemble_deliver+0x7d3>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    fa97:	e9 45 fb ff ff       	jmp    f5e1 <rlc_UM_reassemble_deliver+0x321>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fa9c:	ba 02 00 00 00       	mov    $0x2,%edx
    faa1:	89 f8                	mov    %edi,%eax
    faa3:	e8 fc ff ff ff       	call   faa4 <rlc_UM_reassemble_deliver+0x7e4>
    faa8:	89 c3                	mov    %eax,%ebx
    faaa:	e9 b9 fd ff ff       	jmp    f868 <rlc_UM_reassemble_deliver+0x5a8>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    faaf:	ba 02 00 00 00       	mov    $0x2,%edx
    fab4:	89 f8                	mov    %edi,%eax
    fab6:	e8 fc ff ff ff       	call   fab7 <rlc_UM_reassemble_deliver+0x7f7>
    fabb:	89 c3                	mov    %eax,%ebx
    fabd:	e9 82 fe ff ff       	jmp    f944 <rlc_UM_reassemble_deliver+0x684>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fac2:	ba 02 00 00 00       	mov    $0x2,%edx
    fac7:	89 f8                	mov    %edi,%eax
    fac9:	e8 fc ff ff ff       	call   faca <rlc_UM_reassemble_deliver+0x80a>
    face:	89 c3                	mov    %eax,%ebx
    fad0:	eb 88                	jmp    fa5a <rlc_UM_reassemble_deliver+0x79a>
    fad2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    fad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000fae0 <rlc_UM5_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fae0:	55                   	push   %ebp
    fae1:	89 e5                	mov    %esp,%ebp
    fae3:	57                   	push   %edi
    fae4:	56                   	push   %esi
    fae5:	53                   	push   %ebx
    fae6:	83 ec 34             	sub    $0x34,%esp
    fae9:	e8 fc ff ff ff       	call   faea <rlc_UM5_reassemble_deliver+0xa>
    faee:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    faf1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	SV_PTR_GET(rlc_mac_sv);
    faf4:	e8 fc ff ff ff       	call   faf5 <rlc_UM5_reassemble_deliver+0x15>
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    faf9:	8b 55 d8             	mov    -0x28(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fafc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
	SV_PTR_GET(rlc_mac_sv);
    faff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fb02:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    fb09:	83 c0 01             	add    $0x1,%eax
    fb0c:	89 c2                	mov    %eax,%edx
    fb0e:	c1 fa 1f             	sar    $0x1f,%edx
    fb11:	c1 ea 1b             	shr    $0x1b,%edx
    fb14:	01 d0                	add    %edx,%eax
    fb16:	83 e0 1f             	and    $0x1f,%eax
    fb19:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fb1b:	0f b7 c0             	movzwl %ax,%eax
    fb1e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    fb21:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    fb28:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fb2b:	8d 50 20             	lea    0x20(%eax),%edx
    fb2e:	89 d0                	mov    %edx,%eax
    fb30:	c1 f8 1f             	sar    $0x1f,%eax
    fb33:	c1 e8 1b             	shr    $0x1b,%eax
    fb36:	01 c2                	add    %eax,%edx
    fb38:	83 e2 1f             	and    $0x1f,%edx
    fb3b:	29 c2                	sub    %eax,%edx
    fb3d:	85 d2                	test   %edx,%edx
    fb3f:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fb42:	0f 8e d8 03 00 00    	jle    ff20 <rlc_UM5_reassemble_deliver+0x440>
    fb48:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fb4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fb4e:	e9 8d 00 00 00       	jmp    fbe0 <rlc_UM5_reassemble_deliver+0x100>
    fb53:	90                   	nop
    fb54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    fb58:	84 d2                	test   %dl,%dl
    fb5a:	0f 84 38 01 00 00    	je     fc98 <rlc_UM5_reassemble_deliver+0x1b8>
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;
				}
			}
			else if(pduhdr->E==1)
    fb60:	a8 20                	test   $0x20,%al
    fb62:	0f 85 98 01 00 00    	jne    fd00 <rlc_UM5_reassemble_deliver+0x220>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    fb68:	8b 46 14             	mov    0x14(%esi),%eax
    fb6b:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    fb6e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    fb71:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    fb73:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    fb75:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    fb7c:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    fb83:	e8 fc ff ff ff       	call   fb84 <rlc_UM5_reassemble_deliver+0xa4>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    fb88:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb8b:	85 c0                	test   %eax,%eax
    fb8d:	74 08                	je     fb97 <rlc_UM5_reassemble_deliver+0xb7>
			{
				fsm_mem_free(icimsg);
    fb8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fb92:	e8 fc ff ff ff       	call   fb93 <rlc_UM5_reassemble_deliver+0xb3>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    fb97:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    fb9a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fb9d:	c7 84 88 b8 00 00 00 	movl   $0x0,0xb8(%eax,%ecx,4)
    fba4:	00 00 00 00 
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fba8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbab:	83 c2 01             	add    $0x1,%edx
    fbae:	89 d0                	mov    %edx,%eax
    fbb0:	c1 f8 1f             	sar    $0x1f,%eax
    fbb3:	c1 e8 1b             	shr    $0x1b,%eax
    fbb6:	01 c2                	add    %eax,%edx
    fbb8:	83 e2 1f             	and    $0x1f,%edx
    fbbb:	29 c2                	sub    %eax,%edx
    fbbd:	89 d0                	mov    %edx,%eax
    fbbf:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fbc2:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fbc5:	83 c0 20             	add    $0x20,%eax
    fbc8:	89 c2                	mov    %eax,%edx
    fbca:	c1 fa 1f             	sar    $0x1f,%edx
    fbcd:	c1 ea 1b             	shr    $0x1b,%edx
    fbd0:	01 d0                	add    %edx,%eax
    fbd2:	83 e0 1f             	and    $0x1f,%eax
    fbd5:	29 d0                	sub    %edx,%eax
    fbd7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    fbda:	0f 8d 40 03 00 00    	jge    ff20 <rlc_UM5_reassemble_deliver+0x440>
	{
		if(umIns->umRecvWindow5[i] != NULL)
    fbe0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbe3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fbe6:	8b 74 90 38          	mov    0x38(%eax,%edx,4),%esi
    fbea:	85 f6                	test   %esi,%esi
    fbec:	74 ba                	je     fba8 <rlc_UM5_reassemble_deliver+0xc8>
		{

			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    fbee:	8b 06                	mov    (%esi),%eax
    fbf0:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    fbf6:	b8 02 00 00 00       	mov    $0x2,%eax
    fbfb:	e8 fc ff ff ff       	call   fbfc <rlc_UM5_reassemble_deliver+0x11c>
    fc00:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    fc03:	8b 43 02             	mov    0x2(%ebx),%eax
    fc06:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fc09:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    fc0b:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    fc0f:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fc12:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fc14:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fc19:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
    fc1f:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fc22:	e8 fc ff ff ff       	call   fc23 <rlc_UM5_reassemble_deliver+0x143>
          
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    fc27:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc2a:	0f b6 02             	movzbl (%edx),%eax
    fc2d:	89 c2                	mov    %eax,%edx
    fc2f:	83 e2 a0             	and    $0xffffffa0,%edx
    fc32:	80 fa 80             	cmp    $0x80,%dl
    fc35:	0f 85 1d ff ff ff    	jne    fb58 <rlc_UM5_reassemble_deliver+0x78>
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
    fc3b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    fc3e:	0f b7 11             	movzwl (%ecx),%edx
    fc41:	66 83 fa ff          	cmp    $0xffff,%dx
    fc45:	74 20                	je     fc67 <rlc_UM5_reassemble_deliver+0x187>
    fc47:	0f bf d2             	movswl %dx,%edx
    fc4a:	83 e0 1f             	and    $0x1f,%eax
    fc4d:	83 c2 01             	add    $0x1,%edx
    fc50:	89 d1                	mov    %edx,%ecx
    fc52:	c1 f9 1f             	sar    $0x1f,%ecx
    fc55:	c1 e9 1b             	shr    $0x1b,%ecx
    fc58:	01 ca                	add    %ecx,%edx
    fc5a:	83 e2 1f             	and    $0x1f,%edx
    fc5d:	29 ca                	sub    %ecx,%edx
    fc5f:	39 c2                	cmp    %eax,%edx
    fc61:	0f 84 c1 03 00 00    	je     10028 <rlc_UM5_reassemble_deliver+0x548>
						pdu_left->sduLeft = new_skb;
					}
				}
				else
				{
					SV(countDropPacket)++;
    fc67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fc6a:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    fc71:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fc74:	e8 fc ff ff ff       	call   fc75 <rlc_UM5_reassemble_deliver+0x195>
					if(tbuff->pkt != NULL)
    fc79:	8b 06                	mov    (%esi),%eax
    fc7b:	85 c0                	test   %eax,%eax
    fc7d:	0f 84 e5 fe ff ff    	je     fb68 <rlc_UM5_reassemble_deliver+0x88>
					{
						fsm_pkt_destroy(tbuff->pkt);
    fc83:	e8 fc ff ff ff       	call   fc84 <rlc_UM5_reassemble_deliver+0x1a4>
						tbuff->pkt = NULL;
    fc88:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    fc8e:	e9 d5 fe ff ff       	jmp    fb68 <rlc_UM5_reassemble_deliver+0x88>
    fc93:	90                   	nop
    fc94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    fc98:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fc9b:	e8 fc ff ff ff       	call   fc9c <rlc_UM5_reassemble_deliver+0x1bc>

				if(pduhdr->FIsecond==0)
    fca0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fca3:	0f b6 02             	movzbl (%edx),%eax
    fca6:	a8 40                	test   $0x40,%al
    fca8:	0f 85 7a 02 00 00    	jne    ff28 <rlc_UM5_reassemble_deliver+0x448>
				{

					skb = tbuff->pkt;
    fcae:	8b 1e                	mov    (%esi),%ebx
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fcb0:	89 d8                	mov    %ebx,%eax
    fcb2:	e8 fc ff ff ff       	call   fcb3 <rlc_UM5_reassemble_deliver+0x1d3>
    fcb7:	83 f8 01             	cmp    $0x1,%eax
    fcba:	0f 86 35 04 00 00    	jbe    100f5 <rlc_UM5_reassemble_deliver+0x615>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fcc0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fcc3:	b9 02 00 00 00       	mov    $0x2,%ecx
    fcc8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fcce:	e8 fc ff ff ff       	call   fccf <rlc_UM5_reassemble_deliver+0x1ef>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fcd3:	89 d8                	mov    %ebx,%eax
    fcd5:	ba 06 00 00 00       	mov    $0x6,%edx
    fcda:	e8 fc ff ff ff       	call   fcdb <rlc_UM5_reassemble_deliver+0x1fb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fcdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fce2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fce9:	c7 04 24 38 3c 00 00 	movl   $0x3c38,(%esp)
    fcf0:	e8 fc ff ff ff       	call   fcf1 <rlc_UM5_reassemble_deliver+0x211>
    fcf5:	e9 6e fe ff ff       	jmp    fb68 <rlc_UM5_reassemble_deliver+0x88>
    fcfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fd00:	b8 40 00 00 00       	mov    $0x40,%eax
    fd05:	e8 fc ff ff ff       	call   fd06 <rlc_UM5_reassemble_deliver+0x226>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fd0a:	31 c9                	xor    %ecx,%ecx
    fd0c:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fd0e:	89 45 dc             	mov    %eax,-0x24(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fd11:	89 04 24             	mov    %eax,(%esp)
    fd14:	b8 01 00 00 00       	mov    $0x1,%eax
    fd19:	e8 fc ff ff ff       	call   fd1a <rlc_UM5_reassemble_deliver+0x23a>
    fd1e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
                
				if(pduhdr->FIfirst==1)
    fd22:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd25:	0f b6 08             	movzbl (%eax),%ecx
    fd28:	84 c9                	test   %cl,%cl
    fd2a:	0f 89 60 02 00 00    	jns    ff90 <rlc_UM5_reassemble_deliver+0x4b0>
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
    fd30:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    fd33:	0f b7 02             	movzwl (%edx),%eax
    fd36:	66 83 f8 ff          	cmp    $0xffff,%ax
    fd3a:	74 20                	je     fd5c <rlc_UM5_reassemble_deliver+0x27c>
    fd3c:	98                   	cwtl   
    fd3d:	83 e1 1f             	and    $0x1f,%ecx
    fd40:	83 c0 01             	add    $0x1,%eax
    fd43:	89 c2                	mov    %eax,%edx
    fd45:	c1 fa 1f             	sar    $0x1f,%edx
    fd48:	c1 ea 17             	shr    $0x17,%edx
    fd4b:	01 d0                	add    %edx,%eax
    fd4d:	25 ff 01 00 00       	and    $0x1ff,%eax
    fd52:	29 d0                	sub    %edx,%eax
    fd54:	39 c8                	cmp    %ecx,%eax
    fd56:	0f 84 ac 03 00 00    	je     10108 <rlc_UM5_reassemble_deliver+0x628>
						clear_left_pdu(pdu_left);
                        
					}
					else
					{
						SV(countDropPacket)++;
    fd5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fd5f:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    fd66:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fd69:	e8 fc ff ff ff       	call   fd6a <rlc_UM5_reassemble_deliver+0x28a>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fd6e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fd71:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    fd75:	8b 06                	mov    (%esi),%eax
    fd77:	e8 fc ff ff ff       	call   fd78 <rlc_UM5_reassemble_deliver+0x298>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fd7c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    fd80:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    fd82:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    fd89:	8d 54 00 fe          	lea    -0x2(%eax,%eax,1),%edx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fd8d:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    fd90:	89 55 d0             	mov    %edx,-0x30(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fd93:	7f 4c                	jg     fde1 <rlc_UM5_reassemble_deliver+0x301>
    fd95:	e9 b0 00 00 00       	jmp    fe4a <rlc_UM5_reassemble_deliver+0x36a>
    fd9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fda0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fda3:	b9 02 00 00 00       	mov    $0x2,%ecx
    fda8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fdae:	e8 fc ff ff ff       	call   fdaf <rlc_UM5_reassemble_deliver+0x2cf>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fdb3:	ba 06 00 00 00       	mov    $0x6,%edx
    fdb8:	89 d8                	mov    %ebx,%eax
    fdba:	e8 fc ff ff ff       	call   fdbb <rlc_UM5_reassemble_deliver+0x2db>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fdbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fdc2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fdc9:	c7 04 24 38 3c 00 00 	movl   $0x3c38,(%esp)
    fdd0:	e8 fc ff ff ff       	call   fdd1 <rlc_UM5_reassemble_deliver+0x2f1>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fdd5:	8b 55 d0             	mov    -0x30(%ebp),%edx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fdd8:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fddc:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    fddf:	74 67                	je     fe48 <rlc_UM5_reassemble_deliver+0x368>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fde1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fde4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fde7:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    fdec:	89 d8                	mov    %ebx,%eax
    fdee:	e8 fc ff ff ff       	call   fdef <rlc_UM5_reassemble_deliver+0x30f>

					fsm_skb_reserve(new_skb,length);
    fdf3:	89 da                	mov    %ebx,%edx
                
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fdf5:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    fdf7:	e8 fc ff ff ff       	call   fdf8 <rlc_UM5_reassemble_deliver+0x318>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fdfc:	8b 07                	mov    (%edi),%eax
    fdfe:	89 da                	mov    %ebx,%edx
    fe00:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fe06:	89 45 e0             	mov    %eax,-0x20(%ebp)
    fe09:	89 f0                	mov    %esi,%eax
    fe0b:	e8 fc ff ff ff       	call   fe0c <rlc_UM5_reassemble_deliver+0x32c>
    fe10:	8b 55 e0             	mov    -0x20(%ebp),%edx
    fe13:	89 d9                	mov    %ebx,%ecx
    fe15:	e8 fc ff ff ff       	call   fe16 <rlc_UM5_reassemble_deliver+0x336>
					fsm_skb_pull(tbuff->pkt,length ) ;
    fe1a:	8b 07                	mov    (%edi),%eax
    fe1c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    fe1e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    fe20:	e8 fc ff ff ff       	call   fe21 <rlc_UM5_reassemble_deliver+0x341>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fe25:	89 f0                	mov    %esi,%eax
    fe27:	e8 fc ff ff ff       	call   fe28 <rlc_UM5_reassemble_deliver+0x348>
    fe2c:	83 f8 01             	cmp    $0x1,%eax
    fe2f:	0f 87 6b ff ff ff    	ja     fda0 <rlc_UM5_reassemble_deliver+0x2c0>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fe35:	ba 02 00 00 00       	mov    $0x2,%edx
    fe3a:	89 f0                	mov    %esi,%eax
    fe3c:	e8 fc ff ff ff       	call   fe3d <rlc_UM5_reassemble_deliver+0x35d>
    fe41:	89 c3                	mov    %eax,%ebx
    fe43:	e9 58 ff ff ff       	jmp    fda0 <rlc_UM5_reassemble_deliver+0x2c0>
    fe48:	89 fe                	mov    %edi,%esi
                    
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
    fe4a:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fe4c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe4f:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fe53:	f6 01 40             	testb  $0x40,(%ecx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe56:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fe58:	0f 85 e2 00 00 00    	jne    ff40 <rlc_UM5_reassemble_deliver+0x460>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe5e:	e8 fc ff ff ff       	call   fe5f <rlc_UM5_reassemble_deliver+0x37f>
					fsm_skb_reserve(new_skb,length);
    fe63:	89 da                	mov    %ebx,%edx
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe65:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fe67:	e8 fc ff ff ff       	call   fe68 <rlc_UM5_reassemble_deliver+0x388>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fe6c:	8b 06                	mov    (%esi),%eax
    fe6e:	89 da                	mov    %ebx,%edx
    fe70:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fe76:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fe79:	89 f8                	mov    %edi,%eax
    fe7b:	e8 fc ff ff ff       	call   fe7c <rlc_UM5_reassemble_deliver+0x39c>
    fe80:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fe83:	89 d9                	mov    %ebx,%ecx
    fe85:	e8 fc ff ff ff       	call   fe86 <rlc_UM5_reassemble_deliver+0x3a6>
					fsm_skb_pull(tbuff->pkt,length) ;
    fe8a:	8b 06                	mov    (%esi),%eax
    fe8c:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    fe8e:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    fe90:	e8 fc ff ff ff       	call   fe91 <rlc_UM5_reassemble_deliver+0x3b1>
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fe95:	89 f8                	mov    %edi,%eax
    fe97:	e8 fc ff ff ff       	call   fe98 <rlc_UM5_reassemble_deliver+0x3b8>
    fe9c:	83 f8 01             	cmp    $0x1,%eax
    fe9f:	0f 86 1f 02 00 00    	jbe    100c4 <rlc_UM5_reassemble_deliver+0x5e4>
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
			    	}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fea5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fea8:	b9 02 00 00 00       	mov    $0x2,%ecx
    fead:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    feb3:	e8 fc ff ff ff       	call   feb4 <rlc_UM5_reassemble_deliver+0x3d4>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    feb8:	89 d8                	mov    %ebx,%eax
    feba:	ba 06 00 00 00       	mov    $0x6,%edx
    febf:	e8 fc ff ff ff       	call   fec0 <rlc_UM5_reassemble_deliver+0x3e0>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fec4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fec7:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");                  
    fece:	c7 04 24 38 3c 00 00 	movl   $0x3c38,(%esp)
    fed5:	e8 fc ff ff ff       	call   fed6 <rlc_UM5_reassemble_deliver+0x3f6>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    feda:	8b 56 10             	mov    0x10(%esi),%edx
    fedd:	8b 46 14             	mov    0x14(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    fee0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    fee3:	89 10                	mov    %edx,(%eax)
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
    fee5:	8b 06                	mov    (%esi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    fee7:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    feee:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    fef5:	e8 fc ff ff ff       	call   fef6 <rlc_UM5_reassemble_deliver+0x416>
					tbuff->pkt = NULL;
					fsm_mem_free(tbuff);
    fefa:	89 f0                	mov    %esi,%eax
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
					tbuff->pkt = NULL;
    fefc:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(tbuff);
    ff02:	e8 fc ff ff ff       	call   ff03 <rlc_UM5_reassemble_deliver+0x423>
					tbuff = NULL;
				}
				if(pPduhdrExt != NULL)
    ff07:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff0a:	85 c0                	test   %eax,%eax
    ff0c:	0f 84 76 fc ff ff    	je     fb88 <rlc_UM5_reassemble_deliver+0xa8>
				{
					fsm_mem_free(pPduhdrExt);
    ff12:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff15:	e8 fc ff ff ff       	call   ff16 <rlc_UM5_reassemble_deliver+0x436>
    ff1a:	e9 69 fc ff ff       	jmp    fb88 <rlc_UM5_reassemble_deliver+0xa8>
    ff1f:	90                   	nop
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    ff20:	83 c4 34             	add    $0x34,%esp
    ff23:	5b                   	pop    %ebx
    ff24:	5e                   	pop    %esi
    ff25:	5f                   	pop    %edi
    ff26:	5d                   	pop    %ebp
    ff27:	c3                   	ret    
					tbuff=NULL;
				}

				else
				{
					pdu_left->SN5_Left = pduhdr->SN;
    ff28:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ff2b:	83 e0 1f             	and    $0x1f,%eax
    ff2e:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    ff31:	8b 06                	mov    (%esi),%eax
    ff33:	89 42 04             	mov    %eax,0x4(%edx)
    ff36:	e9 2d fc ff ff       	jmp    fb68 <rlc_UM5_reassemble_deliver+0x88>
    ff3b:	90                   	nop
    ff3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ff40:	e8 fc ff ff ff       	call   ff41 <rlc_UM5_reassemble_deliver+0x461>
					fsm_skb_reserve(new_skb,length);
    ff45:	89 da                	mov    %ebx,%edx
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ff47:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    ff49:	e8 fc ff ff ff       	call   ff4a <rlc_UM5_reassemble_deliver+0x46a>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ff4e:	8b 06                	mov    (%esi),%eax
    ff50:	89 da                	mov    %ebx,%edx
    ff52:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff58:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ff5b:	89 f8                	mov    %edi,%eax
    ff5d:	e8 fc ff ff ff       	call   ff5e <rlc_UM5_reassemble_deliver+0x47e>
    ff62:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ff65:	89 d9                	mov    %ebx,%ecx
    ff67:	e8 fc ff ff ff       	call   ff68 <rlc_UM5_reassemble_deliver+0x488>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    ff6c:	8b 06                	mov    (%esi),%eax
    ff6e:	8b 50 50             	mov    0x50(%eax),%edx
    ff71:	e8 fc ff ff ff       	call   ff72 <rlc_UM5_reassemble_deliver+0x492>
                    
					pdu_left->SN5_Left = pduhdr->SN;
    ff76:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff79:	0f b6 02             	movzbl (%edx),%eax
    ff7c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ff7f:	83 e0 1f             	and    $0x1f,%eax
    ff82:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft = new_skb;
    ff85:	89 7a 04             	mov    %edi,0x4(%edx)
    ff88:	e9 4d ff ff ff       	jmp    feda <rlc_UM5_reassemble_deliver+0x3fa>
    ff8d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    ff90:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ff93:	e8 fc ff ff ff       	call   ff94 <rlc_UM5_reassemble_deliver+0x4b4>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    ff98:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff9b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    ff9f:	89 d8                	mov    %ebx,%eax
    ffa1:	e8 fc ff ff ff       	call   ffa2 <rlc_UM5_reassemble_deliver+0x4c2>

					fsm_skb_reserve(new_skb,length);
    ffa6:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    ffa8:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
    ffaa:	e8 fc ff ff ff       	call   ffab <rlc_UM5_reassemble_deliver+0x4cb>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ffaf:	8b 06                	mov    (%esi),%eax
    ffb1:	89 da                	mov    %ebx,%edx
    ffb3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ffb9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ffbc:	89 f8                	mov    %edi,%eax
    ffbe:	e8 fc ff ff ff       	call   ffbf <rlc_UM5_reassemble_deliver+0x4df>
    ffc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ffc6:	89 d9                	mov    %ebx,%ecx
    ffc8:	e8 fc ff ff ff       	call   ffc9 <rlc_UM5_reassemble_deliver+0x4e9>
					fsm_skb_pull(tbuff->pkt,length ) ;
    ffcd:	8b 06                	mov    (%esi),%eax
    ffcf:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    ffd1:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    ffd3:	e8 fc ff ff ff       	call   ffd4 <rlc_UM5_reassemble_deliver+0x4f4>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ffd8:	89 f8                	mov    %edi,%eax
    ffda:	e8 fc ff ff ff       	call   ffdb <rlc_UM5_reassemble_deliver+0x4fb>
    ffdf:	83 f8 01             	cmp    $0x1,%eax
    ffe2:	0f 86 f7 01 00 00    	jbe    101df <rlc_UM5_reassemble_deliver+0x6ff>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ffe8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ffeb:	b9 02 00 00 00       	mov    $0x2,%ecx
    fff0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fff6:	e8 fc ff ff ff       	call   fff7 <rlc_UM5_reassemble_deliver+0x517>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fffb:	89 d8                	mov    %ebx,%eax
    fffd:	ba 06 00 00 00       	mov    $0x6,%edx
   10002:	e8 fc ff ff ff       	call   10003 <rlc_UM5_reassemble_deliver+0x523>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   10007:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1000a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   10011:	c7 04 24 38 3c 00 00 	movl   $0x3c38,(%esp)
   10018:	e8 fc ff ff ff       	call   10019 <rlc_UM5_reassemble_deliver+0x539>
   1001d:	e9 5a fd ff ff       	jmp    fd7c <rlc_UM5_reassemble_deliver+0x29c>
   10022:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
   10028:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
   1002b:	8b 16                	mov    (%esi),%edx
   1002d:	8b 41 04             	mov    0x4(%ecx),%eax
   10030:	8b 40 50             	mov    0x50(%eax),%eax
   10033:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
   10037:	0f b7 d8             	movzwl %ax,%ebx
   1003a:	89 d8                	mov    %ebx,%eax
   1003c:	e8 fc ff ff ff       	call   1003d <rlc_UM5_reassemble_deliver+0x55d>

					fsm_skb_reserve(new_skb,length);
   10041:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
   10043:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   10045:	e8 fc ff ff ff       	call   10046 <rlc_UM5_reassemble_deliver+0x566>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
   1004a:	8b 06                	mov    (%esi),%eax
   1004c:	8b 58 50             	mov    0x50(%eax),%ebx
   1004f:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10055:	89 f8                	mov    %edi,%eax
   10057:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1005a:	89 da                	mov    %ebx,%edx
   1005c:	e8 fc ff ff ff       	call   1005d <rlc_UM5_reassemble_deliver+0x57d>
   10061:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10064:	89 d9                	mov    %ebx,%ecx
   10066:	e8 fc ff ff ff       	call   10067 <rlc_UM5_reassemble_deliver+0x587>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1006b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1006e:	8b 42 04             	mov    0x4(%edx),%eax
   10071:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10077:	8b 58 50             	mov    0x50(%eax),%ebx
   1007a:	89 f8                	mov    %edi,%eax
   1007c:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1007f:	89 da                	mov    %ebx,%edx
   10081:	e8 fc ff ff ff       	call   10082 <rlc_UM5_reassemble_deliver+0x5a2>
   10086:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10089:	89 d9                	mov    %ebx,%ecx
   1008b:	e8 fc ff ff ff       	call   1008c <rlc_UM5_reassemble_deliver+0x5ac>
					clear_left_pdu(pdu_left);
   10090:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10093:	e8 fc ff ff ff       	call   10094 <rlc_UM5_reassemble_deliver+0x5b4>
					if(tbuff->pkt != NULL)
   10098:	8b 06                	mov    (%esi),%eax
   1009a:	85 c0                	test   %eax,%eax
   1009c:	74 0b                	je     100a9 <rlc_UM5_reassemble_deliver+0x5c9>
					{
						fsm_pkt_destroy(tbuff->pkt);
   1009e:	e8 fc ff ff ff       	call   1009f <rlc_UM5_reassemble_deliver+0x5bf>
						tbuff->pkt = NULL;
   100a3:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
   100a9:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   100ac:	0f b6 01             	movzbl (%ecx),%eax
   100af:	a8 40                	test   $0x40,%al
   100b1:	74 24                	je     100d7 <rlc_UM5_reassemble_deliver+0x5f7>
						SV(countSendToUpper)++;
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n"); 
					}
					else
					{
						pdu_left->SN5_Left = pduhdr->SN;
   100b3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   100b6:	83 e0 1f             	and    $0x1f,%eax
   100b9:	66 89 02             	mov    %ax,(%edx)
						pdu_left->sduLeft = new_skb;
   100bc:	89 7a 04             	mov    %edi,0x4(%edx)
   100bf:	e9 a4 fa ff ff       	jmp    fb68 <rlc_UM5_reassemble_deliver+0x88>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   100c4:	ba 02 00 00 00       	mov    $0x2,%edx
   100c9:	89 f8                	mov    %edi,%eax
   100cb:	e8 fc ff ff ff       	call   100cc <rlc_UM5_reassemble_deliver+0x5ec>
   100d0:	89 c3                	mov    %eax,%ebx
   100d2:	e9 ce fd ff ff       	jmp    fea5 <rlc_UM5_reassemble_deliver+0x3c5>
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   100d7:	ba 06 00 00 00       	mov    $0x6,%edx
   100dc:	89 f8                	mov    %edi,%eax
   100de:	e8 fc ff ff ff       	call   100df <rlc_UM5_reassemble_deliver+0x5ff>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   100e3:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
   100e5:	89 fb                	mov    %edi,%ebx
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   100e7:	e8 fc ff ff ff       	call   100e8 <rlc_UM5_reassemble_deliver+0x608>
   100ec:	83 f8 01             	cmp    $0x1,%eax
   100ef:	0f 87 cb fb ff ff    	ja     fcc0 <rlc_UM5_reassemble_deliver+0x1e0>

					skb = tbuff->pkt;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   100f5:	89 d8                	mov    %ebx,%eax
   100f7:	ba 02 00 00 00       	mov    $0x2,%edx
   100fc:	e8 fc ff ff ff       	call   100fd <rlc_UM5_reassemble_deliver+0x61d>
   10101:	89 c3                	mov    %eax,%ebx
   10103:	e9 b8 fb ff ff       	jmp    fcc0 <rlc_UM5_reassemble_deliver+0x1e0>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
   10108:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1010b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1010e:	8b 42 04             	mov    0x4(%edx),%eax
   10111:	8b 40 50             	mov    0x50(%eax),%eax
   10114:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
   10118:	0f b7 d8             	movzwl %ax,%ebx
   1011b:	89 d8                	mov    %ebx,%eax
   1011d:	e8 fc ff ff ff       	call   1011e <rlc_UM5_reassemble_deliver+0x63e>

						fsm_skb_reserve(new_skb,length);
   10122:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
   10124:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
   10126:	e8 fc ff ff ff       	call   10127 <rlc_UM5_reassemble_deliver+0x647>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
   1012b:	8b 06                	mov    (%esi),%eax
   1012d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10133:	89 45 e0             	mov    %eax,-0x20(%ebp)
   10136:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10139:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1013d:	89 f8                	mov    %edi,%eax
   1013f:	89 da                	mov    %ebx,%edx
   10141:	e8 fc ff ff ff       	call   10142 <rlc_UM5_reassemble_deliver+0x662>
   10146:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10149:	89 d9                	mov    %ebx,%ecx
   1014b:	e8 fc ff ff ff       	call   1014c <rlc_UM5_reassemble_deliver+0x66c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
   10150:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10153:	0f b7 50 20          	movzwl 0x20(%eax),%edx
   10157:	8b 06                	mov    (%esi),%eax
   10159:	e8 fc ff ff ff       	call   1015a <rlc_UM5_reassemble_deliver+0x67a>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1015e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10161:	8b 42 04             	mov    0x4(%edx),%eax
   10164:	8b 58 50             	mov    0x50(%eax),%ebx
   10167:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   1016d:	89 f8                	mov    %edi,%eax
   1016f:	89 55 e0             	mov    %edx,-0x20(%ebp)
   10172:	89 da                	mov    %ebx,%edx
   10174:	e8 fc ff ff ff       	call   10175 <rlc_UM5_reassemble_deliver+0x695>
   10179:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1017c:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
   1017e:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   10180:	e8 fc ff ff ff       	call   10181 <rlc_UM5_reassemble_deliver+0x6a1>

						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10185:	ba 06 00 00 00       	mov    $0x6,%edx
   1018a:	89 f8                	mov    %edi,%eax
   1018c:	e8 fc ff ff ff       	call   1018d <rlc_UM5_reassemble_deliver+0x6ad>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10191:	89 f8                	mov    %edi,%eax
   10193:	e8 fc ff ff ff       	call   10194 <rlc_UM5_reassemble_deliver+0x6b4>
   10198:	83 f8 01             	cmp    $0x1,%eax
   1019b:	76 55                	jbe    101f2 <rlc_UM5_reassemble_deliver+0x712>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   1019d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   101a0:	b9 02 00 00 00       	mov    $0x2,%ecx
   101a5:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   101ab:	e8 fc ff ff ff       	call   101ac <rlc_UM5_reassemble_deliver+0x6cc>
						fsm_pkt_send(skb,STRM_TO_PDCP);
   101b0:	ba 06 00 00 00       	mov    $0x6,%edx
   101b5:	89 d8                	mov    %ebx,%eax
   101b7:	e8 fc ff ff ff       	call   101b8 <rlc_UM5_reassemble_deliver+0x6d8>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
   101bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   101bf:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   101c6:	c7 04 24 38 3c 00 00 	movl   $0x3c38,(%esp)
   101cd:	e8 fc ff ff ff       	call   101ce <rlc_UM5_reassemble_deliver+0x6ee>
                      
						clear_left_pdu(pdu_left);
   101d2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   101d5:	e8 fc ff ff ff       	call   101d6 <rlc_UM5_reassemble_deliver+0x6f6>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
   101da:	e9 9d fb ff ff       	jmp    fd7c <rlc_UM5_reassemble_deliver+0x29c>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   101df:	ba 02 00 00 00       	mov    $0x2,%edx
   101e4:	89 f8                	mov    %edi,%eax
   101e6:	e8 fc ff ff ff       	call   101e7 <rlc_UM5_reassemble_deliver+0x707>
   101eb:	89 c3                	mov    %eax,%ebx
   101ed:	e9 f6 fd ff ff       	jmp    ffe8 <rlc_UM5_reassemble_deliver+0x508>
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   101f2:	ba 02 00 00 00       	mov    $0x2,%edx
   101f7:	89 f8                	mov    %edi,%eax
   101f9:	e8 fc ff ff ff       	call   101fa <rlc_UM5_reassemble_deliver+0x71a>
   101fe:	89 c3                	mov    %eax,%ebx
   10200:	eb 9b                	jmp    1019d <rlc_UM5_reassemble_deliver+0x6bd>
   10202:	90                   	nop
   10203:	90                   	nop
   10204:	90                   	nop
   10205:	90                   	nop
   10206:	90                   	nop
   10207:	90                   	nop
   10208:	90                   	nop
   10209:	90                   	nop
   1020a:	90                   	nop
   1020b:	90                   	nop
   1020c:	90                   	nop
   1020d:	90                   	nop
   1020e:	90                   	nop
   1020f:	90                   	nop

00010210 <Am_instance_build>:
void skb_printf(FSM_PKT *pkt);
void buff_printf(struct AM_Instance *amIns);


void Am_instance_build()
{
   10210:	55                   	push   %ebp
   10211:	89 e5                	mov    %esp,%ebp
   10213:	57                   	push   %edi
   10214:	56                   	push   %esi
   10215:	53                   	push   %ebx
   10216:	83 ec 08             	sub    $0x8,%esp
   10219:	e8 fc ff ff ff       	call   1021a <Am_instance_build+0xa>
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
   1021e:	e8 fc ff ff ff       	call   1021f <Am_instance_build+0xf>
   10223:	89 c2                	mov    %eax,%edx
	amIns =  instance_create(struct AM_Instance);
   10225:	b8 0c 23 00 00       	mov    $0x230c,%eax
   1022a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1022d:	e8 fc ff ff ff       	call   1022e <Am_instance_build+0x1e>
	amIns->rbId = 4;
   10232:	c6 40 02 04          	movb   $0x4,0x2(%eax)
void Am_instance_build()
{
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   10236:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 4;
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 4;
   10238:	c6 40 03 04          	movb   $0x4,0x3(%eax)
	amIns->reorderTimerValue= 100*100;
   1023c:	c7 40 1c 10 27 00 00 	movl   $0x2710,0x1c(%eax)
	amIns->statProhTimerValue =150*150;
   10243:	c7 40 28 e4 57 00 00 	movl   $0x57e4,0x28(%eax)
	amIns->pollRetxTimerValue = 100*100;
   1024a:	c7 40 10 10 27 00 00 	movl   $0x2710,0x10(%eax)
	amIns->pollPDU = 32;
   10251:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10258:	20 00 
	amIns->pollBYTE = 1000;
   1025a:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10261:	e8 03 
	amIns->maxRetxThreshold = 4;
   10263:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   1026a:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   1026c:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10273:	00 00 00 
   10276:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   1027d:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10284:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10287:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   1028e:	00 00 00 
   10291:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10298:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   1029f:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   102a2:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   102a9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   102b0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   102b7:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   102bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
   102c0:	eb 08                	jmp    102ca <Am_instance_build+0xba>
   102c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   102c8:	89 fe                	mov    %edi,%esi
   102ca:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   102d1:	ff 
   102d2:	8d 7e 01             	lea    0x1(%esi),%edi
   102d5:	0f 85 b4 01 00 00    	jne    1048f <Am_instance_build+0x27f>
   102db:	83 ff 31             	cmp    $0x31,%edi
   102de:	7e e8                	jle    102c8 <Am_instance_build+0xb8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   102e0:	89 55 f0             	mov    %edx,-0x10(%ebp)
   102e3:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   102ea:	e8 fc ff ff ff       	call   102eb <Am_instance_build+0xdb>
   102ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
   102f2:	eb 06                	jmp    102fa <Am_instance_build+0xea>
   102f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   102f8:	89 f7                	mov    %esi,%edi
   102fa:	83 bc ba 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%edi,4)
   10301:	ff 
   10302:	8d 77 01             	lea    0x1(%edi),%esi
   10305:	0f 85 68 01 00 00    	jne    10473 <Am_instance_build+0x263>
   1030b:	83 fe 31             	cmp    $0x31,%esi
   1030e:	7e e8                	jle    102f8 <Am_instance_build+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10310:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10313:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1031a:	e8 fc ff ff ff       	call   1031b <Am_instance_build+0x10b>
   1031f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10322:	eb 06                	jmp    1032a <Am_instance_build+0x11a>
   10324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10328:	89 c6                	mov    %eax,%esi
   1032a:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   10331:	ff 
   10332:	8d 46 01             	lea    0x1(%esi),%eax
   10335:	0f 85 1c 01 00 00    	jne    10457 <Am_instance_build+0x247>
   1033b:	83 f8 31             	cmp    $0x31,%eax
   1033e:	7e e8                	jle    10328 <Am_instance_build+0x118>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10340:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10343:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1034a:	e8 fc ff ff ff       	call   1034b <Am_instance_build+0x13b>
   1034f:	8b 55 f0             	mov    -0x10(%ebp),%edx
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10352:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10355:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   10358:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   1035b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10361:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10367:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   1036d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10373:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   10379:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   1037f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10385:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   1038b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10391:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10397:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   1039d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   103a3:	31 c0                	xor    %eax,%eax
	else
		{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   103a5:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   103ac:	00 00 
   103ae:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   103b5:	00 00 
   103b7:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   103be:	00 00 
   103c0:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   103c7:	00 00 
   103c9:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   103d0:	00 00 
   103d2:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   103d9:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   103db:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   103e2:	00 02 
   103e4:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   103eb:	00 02 
   103ed:	8d 76 00             	lea    0x0(%esi),%esi
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   103f0:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   103f7:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   103fb:	83 c0 01             	add    $0x1,%eax
   103fe:	3d 00 04 00 00       	cmp    $0x400,%eax
   10403:	75 eb                	jne    103f0 <Am_instance_build+0x1e0>
   10405:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   10408:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   1040f:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10413:	83 c0 01             	add    $0x1,%eax
   10416:	3d 00 04 00 00       	cmp    $0x400,%eax
   1041b:	75 eb                	jne    10408 <Am_instance_build+0x1f8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1041d:	8b 82 f8 25 00 00    	mov    0x25f8(%edx),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10423:	8d 8b 04 23 00 00    	lea    0x2304(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10429:	89 8a f8 25 00 00    	mov    %ecx,0x25f8(%edx)
   1042f:	81 c2 f4 25 00 00    	add    $0x25f4,%edx
   10435:	89 93 04 23 00 00    	mov    %edx,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   1043b:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10441:	89 08                	mov    %ecx,(%eax)
	fsm_printf(" am instance has established\n");
   10443:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   1044a:	e8 fc ff ff ff       	call   1044b <Am_instance_build+0x23b>

    FOUT;
}
   1044f:	83 c4 08             	add    $0x8,%esp
   10452:	5b                   	pop    %ebx
   10453:	5e                   	pop    %esi
   10454:	5f                   	pop    %edi
   10455:	5d                   	pop    %ebp
   10456:	c3                   	ret    
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10457:	83 f8 31             	cmp    $0x31,%eax
   1045a:	0f 8f e0 fe ff ff    	jg     10340 <Am_instance_build+0x130>
	else
		{
		amIns->statProhTimerCode = i - 1;
   10460:	89 73 24             	mov    %esi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10463:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   1046a:	ff ff ff ff 
   1046e:	e9 df fe ff ff       	jmp    10352 <Am_instance_build+0x142>
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10473:	83 fe 31             	cmp    $0x31,%esi
   10476:	0f 8f 94 fe ff ff    	jg     10310 <Am_instance_build+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   1047c:	89 7b 18             	mov    %edi,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   1047f:	c7 84 ba 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%edi,4)
   10486:	ff ff ff ff 
   1048a:	e9 9b fe ff ff       	jmp    1032a <Am_instance_build+0x11a>
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   1048f:	83 ff 31             	cmp    $0x31,%edi
   10492:	0f 8f 48 fe ff ff    	jg     102e0 <Am_instance_build+0xd0>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10498:	89 73 0c             	mov    %esi,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   1049b:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   104a2:	ff ff ff ff 
   104a6:	e9 4f fe ff ff       	jmp    102fa <Am_instance_build+0xea>
   104ab:	90                   	nop
   104ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000104b0 <UM_instance_bulid>:

    FOUT;
}

void UM_instance_bulid(void)
{
   104b0:	55                   	push   %ebp
   104b1:	89 e5                	mov    %esp,%ebp
   104b3:	83 ec 08             	sub    $0x8,%esp
   104b6:	e8 fc ff ff ff       	call   104b7 <UM_instance_bulid+0x7>
	SV_PTR_GET(rlc_mac_sv);
   104bb:	e8 fc ff ff ff       	call   104bc <UM_instance_bulid+0xc>
	SV(umText).snFiledLength = 5;
	SV(umText).lcid = 2;
	SV(umText).rbid = 2 ;
	SV(umText).CurrentStatVar = ST_TRAN;
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
   104c0:	8d 90 64 5a 00 00    	lea    0x5a64(%eax),%edx

void UM_instance_bulid(void)
{
	SV_PTR_GET(rlc_mac_sv);
 //    SV(umText) =  instance_create(UM_TX_Instance);
	SV(umText).snFiledLength = 5;
   104c6:	66 c7 80 76 5a 00 00 	movw   $0x5,0x5a76(%eax)
   104cd:	05 00 
	SV(umText).lcid = 2;
   104cf:	c6 80 4f 5a 00 00 02 	movb   $0x2,0x5a4f(%eax)
	SV(umText).rbid = 2 ;
   104d6:	c6 80 4e 5a 00 00 02 	movb   $0x2,0x5a4e(%eax)
	SV(umText).CurrentStatVar = ST_TRAN;
   104dd:	c6 80 78 5a 00 00 08 	movb   $0x8,0x5a78(%eax)
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
   104e4:	c7 80 6c 5a 00 00 00 	movl   $0x0,0x5a6c(%eax)
   104eb:	00 00 00 
   104ee:	c7 80 70 5a 00 00 00 	movl   $0x0,0x5a70(%eax)
   104f5:	00 00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   104f8:	89 90 64 5a 00 00    	mov    %edx,0x5a64(%eax)
	list->prev = list;
   104fe:	89 90 68 5a 00 00    	mov    %edx,0x5a68(%eax)
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
   10504:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
   1050b:	00 
   1050c:	c7 04 24 6c 3c 00 00 	movl   $0x3c6c,(%esp)
   10513:	e8 fc ff ff ff       	call   10514 <UM_instance_bulid+0x64>
}
   10518:	c9                   	leave  
   10519:	c3                   	ret    
   1051a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00010520 <test>:
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
void test()
{
   10520:	55                   	push   %ebp
   10521:	89 e5                	mov    %esp,%ebp
   10523:	53                   	push   %ebx
   10524:	83 ec 10             	sub    $0x10,%esp
   10527:	e8 fc ff ff ff       	call   10528 <test+0x8>
	struct AM_Instance *amIns;
	void *up, *down;
	SV_PTR_GET(rlc_mac_sv);
   1052c:	e8 fc ff ff ff       	call   1052d <test+0xd>
	//fsm_schedule_self(0,SEGMENT);
	//
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
   10531:	8d 4d f8             	lea    -0x8(%ebp),%ecx
   10534:	8d 55 f4             	lea    -0xc(%ebp),%edx
   10537:	05 18 02 00 00       	add    $0x218,%eax
   1053c:	89 04 24             	mov    %eax,(%esp)
   1053f:	b8 08 00 00 00       	mov    $0x8,%eax
   10544:	e8 fc ff ff ff       	call   10545 <test+0x25>
	amIns = (AM_Instance *)up;	
   10549:	8b 5d f4             	mov    -0xc(%ebp),%ebx
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   1054c:	85 db                	test   %ebx,%ebx
   1054e:	74 30                	je     10580 <test+0x60>
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
   10550:	8b 53 18             	mov    0x18(%ebx),%edx
   10553:	b8 40 0d 03 00       	mov    $0x30d40,%eax
   10558:	e8 fc ff ff ff       	call   10559 <test+0x39>
   1055d:	89 43 14             	mov    %eax,0x14(%ebx)
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
   10560:	8b 43 18             	mov    0x18(%ebx),%eax
   10563:	c7 04 24 ac 3c 00 00 	movl   $0x3cac,(%esp)
   1056a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1056e:	e8 fc ff ff ff       	call   1056f <test+0x4f>
}
   10573:	83 c4 10             	add    $0x10,%esp
   10576:	5b                   	pop    %ebx
   10577:	5d                   	pop    %ebp
   10578:	c3                   	ret    
   10579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
	amIns = (AM_Instance *)up;	
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   10580:	c7 04 24 25 08 00 00 	movl   $0x825,(%esp)
   10587:	e8 fc ff ff ff       	call   10588 <test+0x68>
   1058c:	eb d2                	jmp    10560 <test+0x40>
   1058e:	66 90                	xchg   %ax,%ax

00010590 <skb_printf>:
	}
	nposBf = NULL;
}

void skb_printf(FSM_PKT *pkt)
{
   10590:	55                   	push   %ebp
   10591:	89 e5                	mov    %esp,%ebp
   10593:	83 ec 08             	sub    $0x8,%esp
   10596:	e8 fc ff ff ff       	call   10597 <skb_printf+0x7>
	fsm_printf("%s\n",(char *)(pkt->data+4));
   1059b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   105a1:	c7 04 24 40 08 00 00 	movl   $0x840,(%esp)
   105a8:	83 c0 04             	add    $0x4,%eax
   105ab:	89 44 24 04          	mov    %eax,0x4(%esp)
   105af:	e8 fc ff ff ff       	call   105b0 <skb_printf+0x20>
	FOUT;
}
   105b4:	c9                   	leave  
   105b5:	c3                   	ret    
   105b6:	8d 76 00             	lea    0x0(%esi),%esi
   105b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000105c0 <buff_printf>:
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
}

void buff_printf(struct AM_Instance *amIns)
{
   105c0:	55                   	push   %ebp
   105c1:	89 e5                	mov    %esp,%ebp
   105c3:	57                   	push   %edi
   105c4:	56                   	push   %esi
   105c5:	53                   	push   %ebx
   105c6:	83 ec 08             	sub    $0x8,%esp
   105c9:	e8 fc ff ff ff       	call   105ca <buff_printf+0xa>
   105ce:	89 c3                	mov    %eax,%ebx
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   105d0:	c7 04 24 44 08 00 00 	movl   $0x844,(%esp)
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
   105d7:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   105dd:	e8 fc ff ff ff       	call   105de <buff_printf+0x1e>
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
   105e2:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   105e8:	c7 04 24 5d 08 00 00 	movl   $0x85d,(%esp)
   105ef:	89 44 24 04          	mov    %eax,0x4(%esp)
   105f3:	e8 fc ff ff ff       	call   105f4 <buff_printf+0x34>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   105f8:	8b b3 9c 01 00 00    	mov    0x19c(%ebx),%esi
	if( !list_empty(&amIns->amRetxBuffer.list) )
   105fe:	39 f7                	cmp    %esi,%edi
   10600:	74 56                	je     10658 <buff_printf+0x98>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   10602:	8b 1e                	mov    (%esi),%ebx
   10604:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   1060a:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
   10610:	eb 0a                	jmp    1061c <buff_printf+0x5c>
   10612:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10618:	89 de                	mov    %ebx,%esi
   1061a:	89 d3                	mov    %edx,%ebx
		{
			fsm_printf("The PDU SN is %d\n",amRetxBf->SN);
   1061c:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   10623:	c7 04 24 79 08 00 00 	movl   $0x879,(%esp)
   1062a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1062e:	e8 fc ff ff ff       	call   1062f <buff_printf+0x6f>
			skb_printf(amRetxBf->pkt);
   10633:	8b 06                	mov    (%esi),%eax
   10635:	e8 fc ff ff ff       	call   10636 <buff_printf+0x76>
	//
	fsm_printf("printf the amRetxBuffer\n");
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   1063a:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   10640:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   10646:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1064c:	39 c7                	cmp    %eax,%edi
   1064e:	75 c8                	jne    10618 <buff_printf+0x58>
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
	}
	nposBf = NULL;
}
   10650:	83 c4 08             	add    $0x8,%esp
   10653:	5b                   	pop    %ebx
   10654:	5e                   	pop    %esi
   10655:	5f                   	pop    %edi
   10656:	5d                   	pop    %ebp
   10657:	c3                   	ret    
			skb_printf(amRetxBf->pkt);
		}
	}
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
   10658:	c7 04 24 8b 08 00 00 	movl   $0x88b,(%esp)
   1065f:	e8 fc ff ff ff       	call   10660 <buff_printf+0xa0>
   10664:	eb ea                	jmp    10650 <buff_printf+0x90>
   10666:	8d 76 00             	lea    0x0(%esi),%esi
   10669:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010670 <add_data_retx>:
{
	fsm_printf("%s\n",(char *)(pkt->data+4));
	FOUT;
}
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
   10670:	55                   	push   %ebp
   10671:	89 e5                	mov    %esp,%ebp
   10673:	57                   	push   %edi
   10674:	56                   	push   %esi
   10675:	53                   	push   %ebx
   10676:	83 ec 04             	sub    $0x4,%esp
   10679:	e8 fc ff ff ff       	call   1067a <add_data_retx+0xa>
   1067e:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
   10680:	e8 fc ff ff ff       	call   10681 <add_data_retx+0x11>
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10685:	b8 1a 00 00 00       	mov    $0x1a,%eax
   1068a:	e8 fc ff ff ff       	call   1068b <add_data_retx+0x1b>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   1068f:	ba 02 00 00 00       	mov    $0x2,%edx
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
	SV_PTR_GET(rlc_mac_sv);
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10694:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->data;;
   10696:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
   1069c:	c6 00 00             	movb   $0x0,(%eax)
   1069f:	c6 40 01 84          	movb   $0x84,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   106a3:	89 d8                	mov    %ebx,%eax
   106a5:	e8 fc ff ff ff       	call   106a6 <add_data_retx+0x36>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   106aa:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   106b0:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   106b5:	c6 00 0b             	movb   $0xb,(%eax)
   106b8:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   106bc:	89 d8                	mov    %ebx,%eax
   106be:	e8 fc ff ff ff       	call   106bf <add_data_retx+0x4f>
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
   106c3:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   106c8:	e8 fc ff ff ff       	call   106c9 <add_data_retx+0x59>
   106cd:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   106d3:	ba a6 08 00 00       	mov    $0x8a6,%edx
   106d8:	89 c1                	mov    %eax,%ecx
   106da:	89 f8                	mov    %edi,%eax
   106dc:	e8 fc ff ff ff       	call   106dd <add_data_retx+0x6d>
	fsm_skb_put(skb,strlen(sdu1));
   106e1:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   106e6:	e8 fc ff ff ff       	call   106e7 <add_data_retx+0x77>
   106eb:	89 c2                	mov    %eax,%edx
   106ed:	89 d8                	mov    %ebx,%eax
   106ef:	e8 fc ff ff ff       	call   106f0 <add_data_retx+0x80>
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
   106f4:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   106f9:	e8 fc ff ff ff       	call   106fa <add_data_retx+0x8a>
   106fe:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   10704:	ba b1 08 00 00       	mov    $0x8b1,%edx
   10709:	89 c1                	mov    %eax,%ecx
   1070b:	89 f8                	mov    %edi,%eax
   1070d:	e8 fc ff ff ff       	call   1070e <add_data_retx+0x9e>
	fsm_skb_put(skb,strlen(sdu2));
   10712:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   10717:	e8 fc ff ff ff       	call   10718 <add_data_retx+0xa8>
   1071c:	89 c2                	mov    %eax,%edx
   1071e:	89 d8                	mov    %ebx,%eax
   10720:	e8 fc ff ff ff       	call   10721 <add_data_retx+0xb1>

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10725:	b8 a4 00 00 00       	mov    $0xa4,%eax
   1072a:	e8 fc ff ff ff       	call   1072b <add_data_retx+0xbb>
	ambuf->pkt = skb;
   1072f:	89 18                	mov    %ebx,(%eax)
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
	fsm_skb_put(skb,strlen(sdu1));
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
	fsm_skb_put(skb,strlen(sdu2));

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10731:	89 c7                	mov    %eax,%edi
	ambuf->pkt = skb;
	ambuf->pktstatus = FULL_SDU;
   10733:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	ambuf->pos = 0;
   1073a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10741:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10748:	00 00 00 
	ambuf->segStart[0] = 0;
   1074b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	ambuf->segEnd[0] = 20;
   10752:	c7 40 50 14 00 00 00 	movl   $0x14,0x50(%eax)
	ambuf->retxCount = 0;
   10759:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10760:	00 00 
	ambuf->SN = 0;
   10762:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10769:	00 00 
	ambuf->headLen = 2*2;
   1076b:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 20;
   10772:	c7 80 98 00 00 00 14 	movl   $0x14,0x98(%eax)
   10779:	00 00 00 
	fsm_printf("add data in retx buffer\n");
   1077c:	c7 04 24 bc 08 00 00 	movl   $0x8bc,(%esp)
   10783:	e8 fc ff ff ff       	call   10784 <add_data_retx+0x114>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10788:	8b 86 a0 01 00 00    	mov    0x1a0(%esi),%eax
	list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
   1078e:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10794:	89 96 a0 01 00 00    	mov    %edx,0x1a0(%esi)
   1079a:	81 c6 9c 01 00 00    	add    $0x19c,%esi
   107a0:	89 b7 9c 00 00 00    	mov    %esi,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   107a6:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   107ac:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   107ae:	83 c4 04             	add    $0x4,%esp
   107b1:	5b                   	pop    %ebx
   107b2:	5e                   	pop    %esi
   107b3:	5f                   	pop    %edi
   107b4:	5d                   	pop    %ebp
   107b5:	c3                   	ret    
   107b6:	8d 76 00             	lea    0x0(%esi),%esi
   107b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000107c0 <Am_instance_add>:
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
}

void Am_instance_add()
{
   107c0:	55                   	push   %ebp
   107c1:	89 e5                	mov    %esp,%ebp
   107c3:	57                   	push   %edi
   107c4:	56                   	push   %esi
   107c5:	53                   	push   %ebx
   107c6:	83 ec 04             	sub    $0x4,%esp
   107c9:	e8 fc ff ff ff       	call   107ca <Am_instance_add+0xa>
    struct AM_Instance *amIns;
    int i = 0;
    SV_PTR_GET(rlc_mac_sv);
   107ce:	e8 fc ff ff ff       	call   107cf <Am_instance_add+0xf>
   107d3:	89 c6                	mov    %eax,%esi
	amIns =  instance_create(struct AM_Instance);
   107d5:	b8 0c 23 00 00       	mov    $0x230c,%eax
   107da:	e8 fc ff ff ff       	call   107db <Am_instance_add+0x1b>
}

void Am_instance_add()
{
    struct AM_Instance *amIns;
    int i = 0;
   107df:	31 d2                	xor    %edx,%edx
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   107e1:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 8;
   107e3:	c6 40 02 08          	movb   $0x8,0x2(%eax)
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 8;
   107e7:	c6 40 03 08          	movb   $0x8,0x3(%eax)
	amIns->reorderTimerValue= 1000*100;
   107eb:	c7 40 1c a0 86 01 00 	movl   $0x186a0,0x1c(%eax)
	amIns->statProhTimerValue = 2000*100;
   107f2:	c7 40 28 40 0d 03 00 	movl   $0x30d40,0x28(%eax)
	amIns->pollRetxTimerValue = 1000*100;
   107f9:	c7 40 10 a0 86 01 00 	movl   $0x186a0,0x10(%eax)
	amIns->pollPDU = 32;
   10800:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10807:	20 00 
	amIns->pollBYTE = 1000;
   10809:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10810:	e8 03 
	amIns->maxRetxThreshold = 4;
   10812:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   10819:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   1081b:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10822:	00 00 00 
   10825:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   1082c:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10833:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10836:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   1083d:	00 00 00 
   10840:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10847:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   1084e:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10851:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10858:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   1085f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   10866:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   1086c:	eb 0d                	jmp    1087b <Am_instance_add+0xbb>
   1086e:	66 90                	xchg   %ax,%ax
   10870:	83 f8 32             	cmp    $0x32,%eax
   10873:	0f 84 8a 01 00 00    	je     10a03 <Am_instance_add+0x243>
   10879:	89 c2                	mov    %eax,%edx
   1087b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
   10882:	ff 
   10883:	8d 42 01             	lea    0x1(%edx),%eax
   10886:	74 e8                	je     10870 <Am_instance_add+0xb0>
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10888:	83 f8 32             	cmp    $0x32,%eax
   1088b:	0f 84 72 01 00 00    	je     10a03 <Am_instance_add+0x243>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10891:	89 53 0c             	mov    %edx,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   10894:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
   1089b:	ff ff ff ff 
   1089f:	eb 09                	jmp    108aa <Am_instance_add+0xea>
   108a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   108a8:	89 f8                	mov    %edi,%eax
   108aa:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   108b1:	ff 
   108b2:	8d 78 01             	lea    0x1(%eax),%edi
   108b5:	0f 85 6a 01 00 00    	jne    10a25 <Am_instance_add+0x265>
   108bb:	83 ff 31             	cmp    $0x31,%edi
   108be:	7e e8                	jle    108a8 <Am_instance_add+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   108c0:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   108c7:	e8 fc ff ff ff       	call   108c8 <Am_instance_add+0x108>
   108cc:	eb 04                	jmp    108d2 <Am_instance_add+0x112>
   108ce:	66 90                	xchg   %ax,%ax
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   108d0:	89 c7                	mov    %eax,%edi
   108d2:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   108d9:	ff 
   108da:	8d 47 01             	lea    0x1(%edi),%eax
   108dd:	0f 85 6a 01 00 00    	jne    10a4d <Am_instance_add+0x28d>
   108e3:	83 f8 31             	cmp    $0x31,%eax
   108e6:	7e e8                	jle    108d0 <Am_instance_add+0x110>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   108e8:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   108ef:	e8 fc ff ff ff       	call   108f0 <Am_instance_add+0x130>
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   108f4:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   108f7:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   108fa:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   108fd:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10903:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10909:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   1090f:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10915:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   1091b:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   10921:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10927:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   1092d:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10933:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10939:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   1093f:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10945:	31 c0                	xor    %eax,%eax
	else
	{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10947:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   1094e:	00 00 
   10950:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   10957:	00 00 
   10959:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   10960:	00 00 
   10962:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   10969:	00 00 
   1096b:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   10972:	00 00 
   10974:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   1097b:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   1097d:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   10984:	00 02 
   10986:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   1098d:	00 02 
   1098f:	90                   	nop
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   10990:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   10997:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   1099b:	83 c0 01             	add    $0x1,%eax
   1099e:	3d 00 04 00 00       	cmp    $0x400,%eax
   109a3:	75 eb                	jne    10990 <Am_instance_add+0x1d0>
   109a5:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   109a8:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   109af:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   109b3:	83 c0 01             	add    $0x1,%eax
   109b6:	3d 00 04 00 00       	cmp    $0x400,%eax
   109bb:	75 eb                	jne    109a8 <Am_instance_add+0x1e8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   109bd:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   109c3:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   109c9:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
   109cf:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
   109d5:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   109db:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   109e1:	89 10                	mov    %edx,(%eax)
	fsm_printf(" am instance has established\n");
   109e3:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   109ea:	e8 fc ff ff ff       	call   109eb <Am_instance_add+0x22b>

//
	add_data_retx(amIns,8);
   109ef:	89 d8                	mov    %ebx,%eax
   109f1:	ba 08 00 00 00       	mov    $0x8,%edx
   109f6:	e8 fc ff ff ff       	call   109f7 <Am_instance_add+0x237>
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
   109fb:	83 c4 04             	add    $0x4,%esp
   109fe:	5b                   	pop    %ebx
   109ff:	5e                   	pop    %esi
   10a00:	5f                   	pop    %edi
   10a01:	5d                   	pop    %ebp
   10a02:	c3                   	ret    
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10a03:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10a0a:	e8 fc ff ff ff       	call   10a0b <Am_instance_add+0x24b>
   10a0f:	b8 32 00 00 00       	mov    $0x32,%eax
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10a14:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10a1b:	ff 
   10a1c:	8d 78 01             	lea    0x1(%eax),%edi
   10a1f:	0f 84 96 fe ff ff    	je     108bb <Am_instance_add+0xfb>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10a25:	83 ff 31             	cmp    $0x31,%edi
   10a28:	0f 8f 92 fe ff ff    	jg     108c0 <Am_instance_add+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   10a2e:	89 43 18             	mov    %eax,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   10a31:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
   10a38:	ff ff ff ff 
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10a3c:	8d 47 01             	lea    0x1(%edi),%eax
   10a3f:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10a46:	ff 
   10a47:	0f 84 96 fe ff ff    	je     108e3 <Am_instance_add+0x123>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10a4d:	83 f8 31             	cmp    $0x31,%eax
   10a50:	0f 8f 92 fe ff ff    	jg     108e8 <Am_instance_add+0x128>
	else
	{
		amIns->statProhTimerCode = i - 1;
   10a56:	89 7b 24             	mov    %edi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10a59:	c7 84 be 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edi,4)
   10a60:	ff ff ff ff 
   10a64:	e9 8b fe ff ff       	jmp    108f4 <Am_instance_add+0x134>
   10a69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00010a70 <addPollData>:
}


//build()
void addPollData()
{
   10a70:	55                   	push   %ebp
   10a71:	89 e5                	mov    %esp,%ebp
   10a73:	57                   	push   %edi
   10a74:	56                   	push   %esi
   10a75:	53                   	push   %ebx
   10a76:	83 ec 04             	sub    $0x4,%esp
   10a79:	e8 fc ff ff ff       	call   10a7a <addPollData+0xa>
	FSM_PKT *skb = NULL;
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
   10a7e:	66 c7 45 f0 01 80    	movw   $0x8001,-0x10(%ebp)
	unsigned short data = 0x0002;
   10a84:	66 c7 45 f2 02 00    	movw   $0x2,-0xe(%ebp)
	SV_PTR_GET(rlc_mac_sv);
   10a8a:	e8 fc ff ff ff       	call   10a8b <addPollData+0x1b>
   10a8f:	89 c6                	mov    %eax,%esi
	skb = fsm_pkt_create(4);
   10a91:	b8 04 00 00 00       	mov    $0x4,%eax
   10a96:	e8 fc ff ff ff       	call   10a97 <addPollData+0x27>
   10a9b:	89 c7                	mov    %eax,%edi
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10a9d:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10aa2:	e8 fc ff ff ff       	call   10aa3 <addPollData+0x33>

	fsm_mem_cpy(skb->tail,&hdr,2);
   10aa7:	b9 02 00 00 00       	mov    $0x2,%ecx
   10aac:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
	unsigned short data = 0x0002;
	SV_PTR_GET(rlc_mac_sv);
	skb = fsm_pkt_create(4);
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10aaf:	89 c3                	mov    %eax,%ebx

	fsm_mem_cpy(skb->tail,&hdr,2);
   10ab1:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10ab7:	e8 fc ff ff ff       	call   10ab8 <addPollData+0x48>
	fsm_skb_put(skb,2);
   10abc:	ba 02 00 00 00       	mov    $0x2,%edx
   10ac1:	89 f8                	mov    %edi,%eax
   10ac3:	e8 fc ff ff ff       	call   10ac4 <addPollData+0x54>
	fsm_mem_cpy(skb->tail,&data,2);
   10ac8:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10ace:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10ad1:	b9 02 00 00 00       	mov    $0x2,%ecx
   10ad6:	e8 fc ff ff ff       	call   10ad7 <addPollData+0x67>
	fsm_skb_put(skb,2);
   10adb:	ba 02 00 00 00       	mov    $0x2,%edx
   10ae0:	89 f8                	mov    %edi,%eax
   10ae2:	e8 fc ff ff ff       	call   10ae3 <addPollData+0x73>
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10ae7:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx

	fsm_mem_cpy(skb->tail,&hdr,2);
	fsm_skb_put(skb,2);
	fsm_mem_cpy(skb->tail,&data,2);
	fsm_skb_put(skb,2);
	amTxedBuffer->pkt = skb;
   10aed:	89 3b                	mov    %edi,(%ebx)
	amTxedBuffer->SN = 0x0001;
   10aef:	66 c7 83 94 00 00 00 	movw   $0x1,0x94(%ebx)
   10af6:	01 00 
	amTxedBuffer->pktstatus = 1;
   10af8:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	amTxedBuffer->headLen = 2;
   10aff:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amTxedBuffer->retxCount = 0;
   10b06:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   10b0d:	00 00 
	amTxedBuffer->segnum = 0;
   10b0f:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
   10b16:	00 00 00 
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
   10b19:	83 86 e8 38 00 00 01 	addl   $0x1,0x38e8(%esi)
	amTxedBuffer->SN = 0x0001;
	amTxedBuffer->pktstatus = 1;
	amTxedBuffer->headLen = 2;
	amTxedBuffer->retxCount = 0;
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
   10b20:	66 c7 86 3c 5a 00 00 	movw   $0x20,0x5a3c(%esi)
   10b27:	20 00 
	SV(amText).byteWithoutPoll = 1000;
   10b29:	66 c7 86 3e 5a 00 00 	movw   $0x3e8,0x5a3e(%esi)
   10b30:	e8 03 
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
   10b32:	8b 47 50             	mov    0x50(%edi),%eax
   10b35:	01 86 e4 38 00 00    	add    %eax,0x38e4(%esi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10b3b:	8b 86 e0 38 00 00    	mov    0x38e0(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10b41:	89 96 e0 38 00 00    	mov    %edx,0x38e0(%esi)
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10b47:	81 c6 dc 38 00 00    	add    $0x38dc,%esi
   10b4d:	89 b3 9c 00 00 00    	mov    %esi,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
   10b53:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
   10b59:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   10b5b:	83 c4 04             	add    $0x4,%esp
   10b5e:	5b                   	pop    %ebx
   10b5f:	5e                   	pop    %esi
   10b60:	5f                   	pop    %edi
   10b61:	5d                   	pop    %ebp
   10b62:	c3                   	ret    
   10b63:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010b70 <addPollRetxData>:
void addPollRetxData(struct AM_Instance*amIns)
{
   10b70:	55                   	push   %ebp
   10b71:	89 e5                	mov    %esp,%ebp
   10b73:	57                   	push   %edi
   10b74:	56                   	push   %esi
   10b75:	53                   	push   %ebx
   10b76:	e8 fc ff ff ff       	call   10b77 <addPollRetxData+0x7>
   10b7b:	89 c6                	mov    %eax,%esi
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10b7d:	b8 1a 00 00 00       	mov    $0x1a,%eax
   10b82:	e8 fc ff ff ff       	call   10b83 <addPollRetxData+0x13>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10b87:	ba 02 00 00 00       	mov    $0x2,%edx
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10b8c:	8d be f0 00 00 00    	lea    0xf0(%esi),%edi
void addPollRetxData(struct AM_Instance*amIns)
{
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10b92:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->tail;
   10b94:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
   10b9a:	c6 00 00             	movb   $0x0,(%eax)
   10b9d:	c6 40 01 dc          	movb   $0xdc,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10ba1:	89 d8                	mov    %ebx,%eax
   10ba3:	e8 fc ff ff ff       	call   10ba4 <addPollRetxData+0x34>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   10ba8:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10bae:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10bb3:	c6 00 0b             	movb   $0xb,(%eax)
   10bb6:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10bba:	89 d8                	mov    %ebx,%eax
   10bbc:	e8 fc ff ff ff       	call   10bbd <addPollRetxData+0x4d>
	fsm_mem_cpy(skb->tail, sdu1, 11);
   10bc1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10bc7:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10bcc:	ba d5 08 00 00       	mov    $0x8d5,%edx
   10bd1:	e8 fc ff ff ff       	call   10bd2 <addPollRetxData+0x62>
	fsm_skb_put(skb,11);
   10bd6:	ba 0b 00 00 00       	mov    $0xb,%edx
   10bdb:	89 d8                	mov    %ebx,%eax
   10bdd:	e8 fc ff ff ff       	call   10bde <addPollRetxData+0x6e>
	fsm_mem_cpy(skb->tail, sdu2, 11);
   10be2:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10be8:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10bed:	ba e1 08 00 00       	mov    $0x8e1,%edx
   10bf2:	e8 fc ff ff ff       	call   10bf3 <addPollRetxData+0x83>
	fsm_skb_put(skb,11);
   10bf7:	ba 0b 00 00 00       	mov    $0xb,%edx
   10bfc:	89 d8                	mov    %ebx,%eax
   10bfe:	e8 fc ff ff ff       	call   10bff <addPollRetxData+0x8f>

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
   10c03:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10c08:	e8 fc ff ff ff       	call   10c09 <addPollRetxData+0x99>
	ambuf->pkt = skb;
   10c0d:	89 18                	mov    %ebx,(%eax)
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10c0f:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
	fsm_mem_cpy(skb->tail, sdu2, 11);
	fsm_skb_put(skb,11);

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
	ambuf->pkt = skb;
	ambuf->pktstatus = ANY_SEGMENT;
   10c15:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	ambuf->pos = 0;
   10c1c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10c23:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10c2a:	00 00 00 
	ambuf->segStart[0] = 3;
   10c2d:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
	ambuf->segEnd[0] = 18;
   10c34:	c7 40 50 12 00 00 00 	movl   $0x12,0x50(%eax)
	ambuf->retxCount = 0;
   10c3b:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10c42:	00 00 
	ambuf->SN = 0;
   10c44:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10c4b:	00 00 
	ambuf->headLen = 2*2;
   10c4d:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 22;
   10c54:	c7 80 98 00 00 00 16 	movl   $0x16,0x98(%eax)
   10c5b:	00 00 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10c5e:	8b 96 f4 00 00 00    	mov    0xf4(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10c64:	89 8e f4 00 00 00    	mov    %ecx,0xf4(%esi)
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10c6a:	89 b8 9c 00 00 00    	mov    %edi,0x9c(%eax)
	new->next = next;
	new->prev = prev;
   10c70:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
   10c76:	89 0a                	mov    %ecx,(%edx)
	amIns->amTransmittedBufferNum++;
   10c78:	83 86 fc 00 00 00 01 	addl   $0x1,0xfc(%esi)
	amIns->amTransmittedBufferSize += skb->len;
   10c7f:	8b 43 50             	mov    0x50(%ebx),%eax
   10c82:	01 86 f8 00 00 00    	add    %eax,0xf8(%esi)
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10c88:	5b                   	pop    %ebx
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
   10c89:	66 83 86 64 12 00 00 	addw   $0x1,0x1264(%esi)
   10c90:	01 
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10c91:	5e                   	pop    %esi
   10c92:	5f                   	pop    %edi
   10c93:	5d                   	pop    %ebp
   10c94:	c3                   	ret    
   10c95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   10c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010ca0 <addpkt_recvData>:


void addpkt_recvData(struct AM_Instance *amIns)
{
   10ca0:	55                   	push   %ebp
   10ca1:	89 e5                	mov    %esp,%ebp
   10ca3:	57                   	push   %edi
   10ca4:	56                   	push   %esi
   10ca5:	53                   	push   %ebx
   10ca6:	83 ec 20             	sub    $0x20,%esp
   10ca9:	e8 fc ff ff ff       	call   10caa <addpkt_recvData+0xa>
   10cae:	89 c3                	mov    %eax,%ebx
	unsigned short hdr;
	unsigned char *str1 = "pkt1";
	unsigned char *str2 = "pkt2";
	unsigned char *str3 = "pkt3";
	unsigned char *str4 = "pkt4";
	SV_PTR_GET(rlc_mac_sv);
   10cb0:	e8 fc ff ff ff       	call   10cb1 <addpkt_recvData+0x11>

	skb1 = fsm_pkt_create(6);
   10cb5:	b8 06 00 00 00       	mov    $0x6,%eax
   10cba:	e8 fc ff ff ff       	call   10cbb <addpkt_recvData+0x1b>
   10cbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	amTxedBuffer1= (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));	
   10cc2:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10cc7:	e8 fc ff ff ff       	call   10cc8 <addpkt_recvData+0x28>
   10ccc:	89 c7                	mov    %eax,%edi
	skb2 = fsm_pkt_create(6);
   10cce:	b8 06 00 00 00       	mov    $0x6,%eax
   10cd3:	e8 fc ff ff ff       	call   10cd4 <addpkt_recvData+0x34>
   10cd8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10cdb:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10ce0:	e8 fc ff ff ff       	call   10ce1 <addpkt_recvData+0x41>
   10ce5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	skb3 = fsm_pkt_create(6);
   10ce8:	b8 06 00 00 00       	mov    $0x6,%eax
   10ced:	e8 fc ff ff ff       	call   10cee <addpkt_recvData+0x4e>
   10cf2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10cf5:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10cfa:	e8 fc ff ff ff       	call   10cfb <addpkt_recvData+0x5b>
   10cff:	89 45 e8             	mov    %eax,-0x18(%ebp)
	skb4 = fsm_pkt_create(6);
   10d02:	b8 06 00 00 00       	mov    $0x6,%eax
   10d07:	e8 fc ff ff ff       	call   10d08 <addpkt_recvData+0x68>
   10d0c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d0f:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d14:	e8 fc ff ff ff       	call   10d15 <addpkt_recvData+0x75>

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10d19:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10d1c:	b9 02 00 00 00       	mov    $0x2,%ecx
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));

	hdr = 0x8000;
   10d21:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	skb2 = fsm_pkt_create(6);
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d27:	89 c6                	mov    %eax,%esi

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10d29:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   10d2f:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10d32:	e8 fc ff ff ff       	call   10d33 <addpkt_recvData+0x93>
	fsm_skb_put(skb1,2);
   10d37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d3a:	ba 02 00 00 00       	mov    $0x2,%edx
   10d3f:	e8 fc ff ff ff       	call   10d40 <addpkt_recvData+0xa0>
	fsm_mem_cpy(skb1->tail,str1,4);
   10d44:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10d47:	ba ed 08 00 00       	mov    $0x8ed,%edx
   10d4c:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   10d52:	b9 04 00 00 00       	mov    $0x4,%ecx
   10d57:	e8 fc ff ff ff       	call   10d58 <addpkt_recvData+0xb8>
	fsm_skb_put(skb1,4);
   10d5c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d5f:	ba 04 00 00 00       	mov    $0x4,%edx
   10d64:	e8 fc ff ff ff       	call   10d65 <addpkt_recvData+0xc5>
	amTxedBuffer1->pkt = skb1;
   10d69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10d6c:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
   10d72:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   10d79:	00 00 
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10d7b:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
   10d81:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amTxedBuffer1->headLen = 2;
   10d88:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
   10d8f:	89 07                	mov    %eax,(%edi)
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
	amTxedBuffer1->headLen = 2;
	amTxedBuffer1->datalen = 4;
   10d91:	c7 87 98 00 00 00 04 	movl   $0x4,0x98(%edi)
   10d98:	00 00 00 
	amTxedBuffer1->retxCount = -1;
   10d9b:	66 c7 87 96 00 00 00 	movw   $0xffff,0x96(%edi)
   10da2:	ff ff 
	amTxedBuffer1->segnum = 0;
   10da4:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   10dab:	00 00 00 
	amTxedBuffer1->pos = 0;
   10dae:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	amTxedBuffer1->segEnd[0] = -1;
   10db5:	c7 47 50 ff ff ff ff 	movl   $0xffffffff,0x50(%edi)
	amTxedBuffer1->segStart[0] = -1;
   10dbc:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edi)
	amIns->amTransmittedBufferNum++;
   10dc3:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb1->len;
   10dca:	8b 40 50             	mov    0x50(%eax),%eax
   10dcd:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10dd3:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   10dd9:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10de0:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10de1:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10de7:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->prev = prev;
   10ded:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10df3:	8b 7d e0             	mov    -0x20(%ebp),%edi
	prev->next = new;
   10df6:	89 10                	mov    %edx,(%eax)
   10df8:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10dfb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10dfe:	b9 02 00 00 00       	mov    $0x2,%ecx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
   10e03:	66 c7 45 f2 01 80    	movw   $0x8001,-0xe(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10e09:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10e0f:	e8 fc ff ff ff       	call   10e10 <addpkt_recvData+0x170>
	fsm_skb_put(skb2,2);
   10e14:	ba 02 00 00 00       	mov    $0x2,%edx
   10e19:	89 f8                	mov    %edi,%eax
   10e1b:	e8 fc ff ff ff       	call   10e1c <addpkt_recvData+0x17c>
	fsm_mem_cpy(skb2->tail,str2,4);
   10e20:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10e26:	b9 04 00 00 00       	mov    $0x4,%ecx
   10e2b:	ba f2 08 00 00       	mov    $0x8f2,%edx
   10e30:	e8 fc ff ff ff       	call   10e31 <addpkt_recvData+0x191>
	fsm_skb_put(skb2,4);
   10e35:	ba 04 00 00 00       	mov    $0x4,%edx
   10e3a:	89 f8                	mov    %edi,%eax
   10e3c:	e8 fc ff ff ff       	call   10e3d <addpkt_recvData+0x19d>
	amTxedBuffer2->pkt = skb2;
   10e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   10e44:	8b 55 ec             	mov    -0x14(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   10e47:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
   10e4a:	89 38                	mov    %edi,(%eax)
	amTxedBuffer2->SN = 0x0001;
   10e4c:	66 c7 80 94 00 00 00 	movw   $0x1,0x94(%eax)
   10e53:	01 00 
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   10e55:	81 c2 9c 00 00 00    	add    $0x9c,%edx
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
	amTxedBuffer2->SN = 0x0001;
	amTxedBuffer2->pktstatus = FULL_SDU;
   10e5b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	amTxedBuffer2->headLen = 2;
   10e62:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer2->datalen = 4;
   10e69:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   10e70:	00 00 00 
	amTxedBuffer2->retxCount = -1;
   10e73:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   10e7a:	ff ff 
	amTxedBuffer2->segnum = 0;
   10e7c:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
   10e83:	00 00 00 
	amTxedBuffer2->pos = 0;
   10e86:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer2->segEnd[0] = -1;
   10e8d:	c7 40 50 ff ff ff ff 	movl   $0xffffffff,0x50(%eax)
	amTxedBuffer2->segStart[0] = -1;
   10e94:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   10e9b:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb2->len;
   10ea2:	8b 47 50             	mov    0x50(%edi),%eax
   10ea5:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
   10eab:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10eae:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   10eb4:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10ebb:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10ebc:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10ec2:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)
	new->prev = prev;
   10ec8:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
   10ece:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   10ed3:	89 10                	mov    %edx,(%eax)
   10ed5:	8b 55 dc             	mov    -0x24(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
   10ed8:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	fsm_mem_cpy(skb3->tail,&hdr,2);
   10ede:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   10ee4:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10ee7:	e8 fc ff ff ff       	call   10ee8 <addpkt_recvData+0x248>
	fsm_skb_put(skb3,2);
   10eec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10eef:	ba 02 00 00 00       	mov    $0x2,%edx
   10ef4:	e8 fc ff ff ff       	call   10ef5 <addpkt_recvData+0x255>
	fsm_mem_cpy(skb3->tail,str3,4);
   10ef9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10efc:	ba f7 08 00 00       	mov    $0x8f7,%edx
   10f01:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   10f07:	b9 04 00 00 00       	mov    $0x4,%ecx
   10f0c:	e8 fc ff ff ff       	call   10f0d <addpkt_recvData+0x26d>
	fsm_skb_put(skb3,4);
   10f11:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f14:	ba 04 00 00 00       	mov    $0x4,%edx
   10f19:	e8 fc ff ff ff       	call   10f1a <addpkt_recvData+0x27a>
	amTxedBuffer3->pkt = skb3;
   10f1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f21:	8b 55 dc             	mov    -0x24(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   10f24:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	amTxedBuffer3->SN = 0x0002;
   10f27:	66 c7 80 94 00 00 00 	movw   $0x2,0x94(%eax)
   10f2e:	02 00 
	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
	fsm_skb_put(skb3,2);
	fsm_mem_cpy(skb3->tail,str3,4);
	fsm_skb_put(skb3,4);
	amTxedBuffer3->pkt = skb3;
   10f30:	89 10                	mov    %edx,(%eax)
	amTxedBuffer3->SN = 0x0002;
	amTxedBuffer3->pktstatus = ANY_SEGMENT;
   10f32:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	amTxedBuffer3->headLen = 2;
   10f39:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer3->datalen = 4;
   10f40:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   10f47:	00 00 00 
	amTxedBuffer3->retxCount = -1;
   10f4a:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   10f51:	ff ff 
	amTxedBuffer3->segnum = 1;
   10f53:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10f5a:	00 00 00 
	amTxedBuffer3->pos = 0;
   10f5d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer3->segEnd[0] = 6;
   10f64:	c7 40 50 06 00 00 00 	movl   $0x6,0x50(%eax)
	amTxedBuffer3->segStart[0] = 2;
   10f6b:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   10f72:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb3->len;
   10f79:	8b 42 50             	mov    0x50(%edx),%eax
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   10f7c:	8b 55 e8             	mov    -0x18(%ebp),%edx
	amTxedBuffer3->segnum = 1;
	amTxedBuffer3->pos = 0;
	amTxedBuffer3->segEnd[0] = 6;
	amTxedBuffer3->segStart[0] = 2;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
   10f7f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->vt_s++;
   10f85:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10f8c:	01 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10f8d:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   10f93:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10f99:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10f9f:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)

	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
   10fa5:	8b 7d d8             	mov    -0x28(%ebp),%edi
	new->prev = prev;
   10fa8:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   10fae:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   10fb3:	89 10                	mov    %edx,(%eax)
   10fb5:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8003;
   10fb8:	66 c7 45 f2 03 80    	movw   $0x8003,-0xe(%ebp)
	fsm_mem_cpy(skb4->tail,&hdr,2);
   10fbe:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10fc4:	e8 fc ff ff ff       	call   10fc5 <addpkt_recvData+0x325>
	fsm_skb_put(skb4,2);
   10fc9:	ba 02 00 00 00       	mov    $0x2,%edx
   10fce:	89 f8                	mov    %edi,%eax
   10fd0:	e8 fc ff ff ff       	call   10fd1 <addpkt_recvData+0x331>
	fsm_mem_cpy(skb4->tail,str4,4);
   10fd5:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10fdb:	b9 04 00 00 00       	mov    $0x4,%ecx
   10fe0:	ba fc 08 00 00       	mov    $0x8fc,%edx
   10fe5:	e8 fc ff ff ff       	call   10fe6 <addpkt_recvData+0x346>
	fsm_skb_put(skb4,4);
   10fea:	ba 04 00 00 00       	mov    $0x4,%edx
   10fef:	89 f8                	mov    %edi,%eax
   10ff1:	e8 fc ff ff ff       	call   10ff2 <addpkt_recvData+0x352>
	amTxedBuffer4->segStart[1] = 8;

	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb4->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
   10ff6:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
	fsm_skb_put(skb4,2);
	fsm_mem_cpy(skb4->tail,str4,4);
	fsm_skb_put(skb4,4);
	amTxedBuffer4->pkt = skb4;
   10ffc:	89 3e                	mov    %edi,(%esi)
	amTxedBuffer4->SN = 0x0003;
   10ffe:	66 c7 86 94 00 00 00 	movw   $0x3,0x94(%esi)
   11005:	03 00 
	amTxedBuffer4->pktstatus = ANY_SEGMENT;
   11007:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
	amTxedBuffer4->headLen = 2;
   1100e:	c7 46 0c 02 00 00 00 	movl   $0x2,0xc(%esi)
	amTxedBuffer4->datalen = 4;
   11015:	c7 86 98 00 00 00 04 	movl   $0x4,0x98(%esi)
   1101c:	00 00 00 
	amTxedBuffer4->retxCount = -1;
   1101f:	66 c7 86 96 00 00 00 	movw   $0xffff,0x96(%esi)
   11026:	ff ff 
	amTxedBuffer4->segnum = 2;
   11028:	c7 86 90 00 00 00 02 	movl   $0x2,0x90(%esi)
   1102f:	00 00 00 
	amTxedBuffer4->pos = 0;
   11032:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	amTxedBuffer4->segEnd[0] = 7;
   11039:	c7 46 50 07 00 00 00 	movl   $0x7,0x50(%esi)
	amTxedBuffer4->segStart[0] = 5;
   11040:	c7 46 10 05 00 00 00 	movl   $0x5,0x10(%esi)
	amTxedBuffer4->segEnd[1] = 10;
   11047:	c7 46 54 0a 00 00 00 	movl   $0xa,0x54(%esi)
	amTxedBuffer4->segStart[1] = 8;
   1104e:	c7 46 14 08 00 00 00 	movl   $0x8,0x14(%esi)

	amIns->amTransmittedBufferNum++;
   11055:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb4->len;
   1105c:	8b 47 50             	mov    0x50(%edi),%eax
   1105f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11065:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11068:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   1106e:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   11075:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11076:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1107c:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
	new->prev = prev;
   11082:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   11088:	89 10                	mov    %edx,(%eax)
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
	fsm_printf("has added data for ctrl_pkt_recv\n");
   1108a:	c7 04 24 cc 3c 00 00 	movl   $0x3ccc,(%esp)
   11091:	e8 fc ff ff ff       	call   11092 <addpkt_recvData+0x3f2>
	FOUT;
}
   11096:	83 c4 20             	add    $0x20,%esp
   11099:	5b                   	pop    %ebx
   1109a:	5e                   	pop    %esi
   1109b:	5f                   	pop    %edi
   1109c:	5d                   	pop    %ebp
   1109d:	c3                   	ret    
   1109e:	66 90                	xchg   %ax,%ax

000110a0 <addPktTranData>:

void addPktTranData(struct AM_Instance*amIns)
{
   110a0:	55                   	push   %ebp
   110a1:	89 e5                	mov    %esp,%ebp
   110a3:	57                   	push   %edi
   110a4:	56                   	push   %esi
   110a5:	53                   	push   %ebx
   110a6:	83 ec 0c             	sub    $0xc,%esp
   110a9:	e8 fc ff ff ff       	call   110aa <addPktTranData+0xa>
   110ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
	FSM_PKT *skb1 = NULL;
	struct AmBuffer *amRecvBuffer1 = NULL;
	FSM_PKT *skb2 = NULL;
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
   110b1:	b8 06 00 00 00       	mov    $0x6,%eax
   110b6:	e8 fc ff ff ff       	call   110b7 <addPktTranData+0x17>
   110bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   110be:	b8 a4 00 00 00       	mov    $0xa4,%eax
   110c3:	e8 fc ff ff ff       	call   110c4 <addPktTranData+0x24>
   110c8:	89 c7                	mov    %eax,%edi
	skb2= fsm_pkt_create(2+6);
   110ca:	b8 08 00 00 00       	mov    $0x8,%eax
   110cf:	e8 fc ff ff ff       	call   110d0 <addPktTranData+0x30>
   110d4:	89 c6                	mov    %eax,%esi
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   110d6:	b8 a4 00 00 00       	mov    $0xa4,%eax
   110db:	e8 fc ff ff ff       	call   110dc <addPktTranData+0x3c>

	unsigned short data = 0x0000;
   110e0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	unsigned short hdr = 0X0000;
   110e6:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb2= fsm_pkt_create(2+6);
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   110ec:	89 c3                	mov    %eax,%ebx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);
   110ee:	e8 fc ff ff ff       	call   110ef <addPktTranData+0x4f>

	hdr = 0x8000;
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
   110f3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   110f6:	b9 02 00 00 00       	mov    $0x2,%ecx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);

	hdr = 0x8000;
   110fb:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	data = 0x0001;	
   11101:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
	fsm_mem_cpy(skb1->tail,&hdr,2);
   11107:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   1110d:	8d 55 f2             	lea    -0xe(%ebp),%edx
   11110:	e8 fc ff ff ff       	call   11111 <addPktTranData+0x71>
	fsm_skb_put(skb1,2);
   11115:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11118:	ba 02 00 00 00       	mov    $0x2,%edx
   1111d:	e8 fc ff ff ff       	call   1111e <addPktTranData+0x7e>
	fsm_mem_cpy(skb1->tail,&data,2);
   11122:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11125:	b9 02 00 00 00       	mov    $0x2,%ecx
   1112a:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   11130:	8d 55 f0             	lea    -0x10(%ebp),%edx
   11133:	e8 fc ff ff ff       	call   11134 <addPktTranData+0x94>
	fsm_skb_put(skb1,2);
   11138:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1113b:	ba 02 00 00 00       	mov    $0x2,%edx
   11140:	e8 fc ff ff ff       	call   11141 <addPktTranData+0xa1>
	amRecvBuffer1->pkt = skb1;
   11145:	8b 45 e8             	mov    -0x18(%ebp),%eax

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11148:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
   1114d:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   11154:	00 00 

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11156:	8d 55 f2             	lea    -0xe(%ebp),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
   11159:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amRecvBuffer1->headLen = 2;
   11160:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
   11167:	89 07                	mov    %eax,(%edi)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11169:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
   1116c:	66 c7 87 96 00 00 00 	movw   $0x0,0x96(%edi)
   11173:	00 00 
	amRecvBuffer1->segnum = 0;
   11175:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   1117c:	00 00 00 
	amIns->vr_r++;
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
   1117f:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11185:	66 83 80 f4 22 00 00 	addw   $0x1,0x22f4(%eax)
   1118c:	01 
	amIns->amRecvWindow[0] = amRecvBuffer1;
   1118d:	89 b8 6c 12 00 00    	mov    %edi,0x126c(%eax)

	amIns->amRecvWindow[1] = NULL;
   11193:	c7 80 70 12 00 00 00 	movl   $0x0,0x1270(%eax)
   1119a:	00 00 00 

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   1119d:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
   111a3:	66 c7 45 f0 03 00    	movw   $0x3,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   111a9:	e8 fc ff ff ff       	call   111aa <addPktTranData+0x10a>
	fsm_skb_put(skb2,2);
   111ae:	ba 02 00 00 00       	mov    $0x2,%edx
   111b3:	89 f0                	mov    %esi,%eax
   111b5:	e8 fc ff ff ff       	call   111b6 <addPktTranData+0x116>
	fsm_mem_cpy(skb2->tail,&data,2);
   111ba:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   111c0:	b9 02 00 00 00       	mov    $0x2,%ecx
   111c5:	8d 55 f0             	lea    -0x10(%ebp),%edx
   111c8:	e8 fc ff ff ff       	call   111c9 <addPktTranData+0x129>
	fsm_skb_put(skb2,2);
   111cd:	ba 02 00 00 00       	mov    $0x2,%edx
   111d2:	89 f0                	mov    %esi,%eax
   111d4:	e8 fc ff ff ff       	call   111d5 <addPktTranData+0x135>
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
   111d9:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   111df:	8d 55 f0             	lea    -0x10(%ebp),%edx
   111e2:	b9 02 00 00 00       	mov    $0x2,%ecx
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);
	data = 0x0004;
   111e7:	66 c7 45 f0 04 00    	movw   $0x4,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&data,2);
   111ed:	e8 fc ff ff ff       	call   111ee <addPktTranData+0x14e>
	fsm_skb_put(skb2,2);
   111f2:	89 f0                	mov    %esi,%eax
   111f4:	ba 02 00 00 00       	mov    $0x2,%edx
   111f9:	e8 fc ff ff ff       	call   111fa <addPktTranData+0x15a>
	amRecvBuffer2->segEnd[0] = 1;
	amRecvBuffer2->segStart[1] = -1;
	amRecvBuffer2->segEnd[1] = -1;
	amRecvBuffer2->segStart[2] = -1;
	amRecvBuffer2->segEnd[2] = -1;
	amIns->amRecvWindow[2] = amRecvBuffer2;
   111fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb2,2);
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);

	amRecvBuffer2->pkt = skb2;
   11201:	89 33                	mov    %esi,(%ebx)
	amRecvBuffer2->SN = 0x0002;
   11203:	66 c7 83 94 00 00 00 	movw   $0x2,0x94(%ebx)
   1120a:	02 00 
	amRecvBuffer2->pktstatus = 2;
   1120c:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	amRecvBuffer2->headLen = 2;
   11213:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amRecvBuffer2->retxCount = 0;
   1121a:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   11221:	00 00 
	amRecvBuffer2->segnum = 3;
   11223:	c7 83 90 00 00 00 03 	movl   $0x3,0x90(%ebx)
   1122a:	00 00 00 
	amRecvBuffer2->segStart[0] = 0;
   1122d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	amRecvBuffer2->segEnd[0] = 1;
   11234:	c7 43 50 01 00 00 00 	movl   $0x1,0x50(%ebx)
	amRecvBuffer2->segStart[1] = -1;
   1123b:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
	amRecvBuffer2->segEnd[1] = -1;
   11242:	c7 43 54 ff ff ff ff 	movl   $0xffffffff,0x54(%ebx)
	amRecvBuffer2->segStart[2] = -1;
   11249:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
	amRecvBuffer2->segEnd[2] = -1;
   11250:	c7 43 58 ff ff ff ff 	movl   $0xffffffff,0x58(%ebx)
	amIns->amRecvWindow[2] = amRecvBuffer2;
   11257:	89 98 74 12 00 00    	mov    %ebx,0x1274(%eax)
	amIns->vr_h = 3;
   1125d:	66 c7 80 ee 22 00 00 	movw   $0x3,0x22ee(%eax)
   11264:	03 00 
	amIns->vr_ms = 1;
   11266:	66 c7 80 f2 22 00 00 	movw   $0x1,0x22f2(%eax)
   1126d:	01 00 
   1126f:	83 c4 0c             	add    $0xc,%esp
   11272:	5b                   	pop    %ebx
   11273:	5e                   	pop    %esi
   11274:	5f                   	pop    %edi
   11275:	5d                   	pop    %ebp
   11276:	c3                   	ret    
   11277:	90                   	nop
   11278:	90                   	nop
   11279:	90                   	nop
   1127a:	90                   	nop
   1127b:	90                   	nop
   1127c:	90                   	nop
   1127d:	90                   	nop
   1127e:	90                   	nop
   1127f:	90                   	nop

00011280 <Assemble_ctrlPduPart2>:
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11280:	55                   	push   %ebp
   11281:	89 e5                	mov    %esp,%ebp
   11283:	57                   	push   %edi
   11284:	56                   	push   %esi
   11285:	53                   	push   %ebx
   11286:	83 ec 1c             	sub    $0x1c,%esp
   11289:	e8 fc ff ff ff       	call   1128a <Assemble_ctrlPduPart2+0xa>
   1128e:	89 c7                	mov    %eax,%edi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11290:	b8 02 00 00 00       	mov    $0x2,%eax
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11295:	89 ce                	mov    %ecx,%esi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11297:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1129a:	e8 fc ff ff ff       	call   1129b <Assemble_ctrlPduPart2+0x1b>
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1129f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   112a2:	89 d1                	mov    %edx,%ecx
   112a4:	c1 e1 06             	shl    $0x6,%ecx
   112a7:	66 c1 ea 02          	shr    $0x2,%dx
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   112ab:	89 c3                	mov    %eax,%ebx
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   112ad:	88 50 01             	mov    %dl,0x1(%eax)
	part2->E2 = 1;	
   112b0:	89 c8                	mov    %ecx,%eax
   112b2:	83 c8 10             	or     $0x10,%eax
   112b5:	88 45 eb             	mov    %al,-0x15(%ebp)
   112b8:	88 03                	mov    %al,(%ebx)
	if (*pduLen + 6 < size)
   112ba:	8b 06                	mov    (%esi),%eax
   112bc:	8d 50 06             	lea    0x6(%eax),%edx
   112bf:	89 55 f0             	mov    %edx,-0x10(%ebp)
   112c2:	8b 55 08             	mov    0x8(%ebp),%edx
   112c5:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   112c8:	73 66                	jae    11330 <Assemble_ctrlPduPart2+0xb0>
	{
		part2->E1 =1;
   112ca:	83 c9 30             	or     $0x30,%ecx
   112cd:	ba 01 00 00 00       	mov    $0x1,%edx
   112d2:	88 0b                	mov    %cl,(%ebx)
   112d4:	8b 06                	mov    (%esi),%eax
	}
	else if (*pduLen + 6 == size)
	{
		part2->E1 =0;
	}
	fsm_printf("[RLC][Assemble_ctrlPduPart2] pdulen = %d, size = %d, E1 = %d\n",*pduLen,size,part2->E1);
   112d6:	89 54 24 0c          	mov    %edx,0xc(%esp)
   112da:	8b 55 08             	mov    0x8(%ebp),%edx
   112dd:	89 44 24 04          	mov    %eax,0x4(%esp)
   112e1:	c7 04 24 f0 3c 00 00 	movl   $0x3cf0,(%esp)
   112e8:	89 54 24 08          	mov    %edx,0x8(%esp)
   112ec:	e8 fc ff ff ff       	call   112ed <Assemble_ctrlPduPart2+0x6d>
	*(u16 *)part2 = htons(*(u16 *)part2);
	fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   112f1:	b9 02 00 00 00       	mov    $0x2,%ecx
   112f6:	89 da                	mov    %ebx,%edx
   112f8:	66 c1 03 08          	rolw   $0x8,(%ebx)
   112fc:	8b 07                	mov    (%edi),%eax
   112fe:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11304:	e8 fc ff ff ff       	call   11305 <Assemble_ctrlPduPart2+0x85>
	fsm_skb_put(ctrlBf->pkt,2);
   11309:	8b 07                	mov    (%edi),%eax
   1130b:	ba 02 00 00 00       	mov    $0x2,%edx
   11310:	e8 fc ff ff ff       	call   11311 <Assemble_ctrlPduPart2+0x91>
	*pduLen += 2;
   11315:	83 06 02             	addl   $0x2,(%esi)
	if ( part2 != NULL )
   11318:	85 db                	test   %ebx,%ebx
   1131a:	74 07                	je     11323 <Assemble_ctrlPduPart2+0xa3>
	{
		fsm_mem_free(part2);
   1131c:	89 d8                	mov    %ebx,%eax
   1131e:	e8 fc ff ff ff       	call   1131f <Assemble_ctrlPduPart2+0x9f>
		part2=NULL;
	}
}
   11323:	83 c4 1c             	add    $0x1c,%esp
   11326:	5b                   	pop    %ebx
   11327:	5e                   	pop    %esi
   11328:	5f                   	pop    %edi
   11329:	5d                   	pop    %ebp
   1132a:	c3                   	ret    
   1132b:	90                   	nop
   1132c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	part2->E2 = 1;	
	if (*pduLen + 6 < size)
	{
		part2->E1 =1;
	}
	else if (*pduLen + 6 == size)
   11330:	74 06                	je     11338 <Assemble_ctrlPduPart2+0xb8>
	{
		part2->E1 =0;
   11332:	31 d2                	xor    %edx,%edx
   11334:	eb a0                	jmp    112d6 <Assemble_ctrlPduPart2+0x56>
   11336:	66 90                	xchg   %ax,%ax
   11338:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   1133c:	83 e2 df             	and    $0xffffffdf,%edx
   1133f:	88 13                	mov    %dl,(%ebx)
   11341:	31 d2                	xor    %edx,%edx
   11343:	8b 06                	mov    (%esi),%eax
   11345:	eb 8f                	jmp    112d6 <Assemble_ctrlPduPart2+0x56>
   11347:	89 f6                	mov    %esi,%esi
   11349:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00011350 <size_of_ctrl_pdu>:
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
{
   11350:	55                   	push   %ebp
   11351:	89 e5                	mov    %esp,%ebp
   11353:	57                   	push   %edi
   11354:	56                   	push   %esi
   11355:	53                   	push   %ebx
   11356:	83 ec 0c             	sub    $0xc,%esp
   11359:	e8 fc ff ff ff       	call   1135a <size_of_ctrl_pdu+0xa>
	u32 size = 0;
	int i;
	//PDU
	size = 2;  //
   1135e:	bb 02 00 00 00       	mov    $0x2,%ebx
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
   11363:	0f bf 90 ee 22 00 00 	movswl 0x22ee(%eax),%edx
   1136a:	0f bf 88 f4 22 00 00 	movswl 0x22f4(%eax),%ecx
   11371:	83 ea 01             	sub    $0x1,%edx
   11374:	39 d1                	cmp    %edx,%ecx
   11376:	7c 20                	jl     11398 <size_of_ctrl_pdu+0x48>
					}
				}
			}
		}
	}
	fsm_printf("[RLC][size_of_ctrl_pdu] size of ctrl pdu is %d\n",size);
   11378:	89 5c 24 04          	mov    %ebx,0x4(%esp)
   1137c:	c7 04 24 30 3d 00 00 	movl   $0x3d30,(%esp)
   11383:	e8 fc ff ff ff       	call   11384 <size_of_ctrl_pdu+0x34>
	return size;
}
   11388:	89 d8                	mov    %ebx,%eax
   1138a:	83 c4 0c             	add    $0xc,%esp
   1138d:	5b                   	pop    %ebx
   1138e:	5e                   	pop    %esi
   1138f:	5f                   	pop    %edi
   11390:	5d                   	pop    %ebp
   11391:	c3                   	ret    
   11392:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   11398:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
   1139f:	39 d1                	cmp    %edx,%ecx
   113a1:	7d d5                	jge    11378 <size_of_ctrl_pdu+0x28>
**Created Date: 2014/10/15
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
   113a3:	29 ca                	sub    %ecx,%edx
   113a5:	c1 e2 02             	shl    $0x2,%edx
   113a8:	89 55 f0             	mov    %edx,-0x10(%ebp)
   113ab:	8d 3c 88             	lea    (%eax,%ecx,4),%edi
   113ae:	31 d2                	xor    %edx,%edx
   113b0:	eb 13                	jmp    113c5 <size_of_ctrl_pdu+0x75>
   113b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
   113b8:	83 f9 03             	cmp    $0x3,%ecx
   113bb:	74 43                	je     11400 <size_of_ctrl_pdu+0xb0>
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   113bd:	83 c2 04             	add    $0x4,%edx
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   113c0:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   113c3:	74 b3                	je     11378 <size_of_ctrl_pdu+0x28>
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
   113c5:	8b 84 17 6c 12 00 00 	mov    0x126c(%edi,%edx,1),%eax
   113cc:	85 c0                	test   %eax,%eax
   113ce:	74 28                	je     113f8 <size_of_ctrl_pdu+0xa8>
			{
				size += 2;//2
			}
			else //PDU
			{
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)
   113d0:	8b 48 04             	mov    0x4(%eax),%ecx
   113d3:	83 f9 01             	cmp    $0x1,%ecx
   113d6:	74 e5                	je     113bd <size_of_ctrl_pdu+0x6d>
				{
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{
						size += 6;//soendsostart6
   113d8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   113dc:	8d 73 06             	lea    0x6(%ebx),%esi
   113df:	0f 4f de             	cmovg  %esi,%ebx
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
   113e2:	83 f9 02             	cmp    $0x2,%ecx
   113e5:	75 d1                	jne    113b8 <size_of_ctrl_pdu+0x68>
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
   113e7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   113ed:	8d 04 40             	lea    (%eax,%eax,2),%eax
   113f0:	8d 5c 43 fa          	lea    -0x6(%ebx,%eax,2),%ebx
   113f4:	eb c7                	jmp    113bd <size_of_ctrl_pdu+0x6d>
   113f6:	66 90                	xchg   %ax,%ax
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
			{
				size += 2;//2
   113f8:	83 c3 02             	add    $0x2,%ebx
   113fb:	eb c0                	jmp    113bd <size_of_ctrl_pdu+0x6d>
   113fd:	8d 76 00             	lea    0x0(%esi),%esi
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   11400:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   11406:	8d 04 40             	lea    (%eax,%eax,2),%eax
   11409:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
   1140c:	eb af                	jmp    113bd <size_of_ctrl_pdu+0x6d>
   1140e:	66 90                	xchg   %ax,%ax

00011410 <rlc_ctrl_pkt_trans>:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   11410:	55                   	push   %ebp
   11411:	89 e5                	mov    %esp,%ebp
   11413:	57                   	push   %edi
   11414:	56                   	push   %esi
   11415:	53                   	push   %ebx
   11416:	83 ec 30             	sub    $0x30,%esp
   11419:	e8 fc ff ff ff       	call   1141a <rlc_ctrl_pkt_trans+0xa>
   1141e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32 pduLen;
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
   11421:	c7 04 24 60 3d 00 00 	movl   $0x3d60,(%esp)
   11428:	e8 fc ff ff ff       	call   11429 <rlc_ctrl_pkt_trans+0x19>
	pduLen = 0;
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   1142d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
	pduLen = 0;
   11430:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   11437:	e8 fc ff ff ff       	call   11438 <rlc_ctrl_pkt_trans+0x28>
   1143c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
   1143f:	89 44 24 04          	mov    %eax,0x4(%esp)
   11443:	c7 04 24 9c 3d 00 00 	movl   $0x3d9c,(%esp)
   1144a:	e8 fc ff ff ff       	call   1144b <rlc_ctrl_pkt_trans+0x3b>
	if( size < 2)  //PDU2
   1144f:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
   11453:	0f 86 fc 04 00 00    	jbe    11955 <rlc_ctrl_pkt_trans+0x545>
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
   11459:	b8 0c 00 00 00       	mov    $0xc,%eax
   1145e:	e8 fc ff ff ff       	call   1145f <rlc_ctrl_pkt_trans+0x4f>
   11463:	89 45 ec             	mov    %eax,-0x14(%ebp)
	memset(ctrlBf,0,sizeof(struct Buffer));
   11466:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1146c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11473:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ctrlBf->pkt = fsm_pkt_create(size);
   1147a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1147d:	e8 fc ff ff ff       	call   1147e <rlc_ctrl_pkt_trans+0x6e>
   11482:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11485:	89 02                	mov    %eax,(%edx)
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11487:	b8 02 00 00 00       	mov    $0x2,%eax
   1148c:	e8 fc ff ff ff       	call   1148d <rlc_ctrl_pkt_trans+0x7d>
	memset(part1,0,sizeof(ctrlPduPart1));
   11491:	66 c7 00 00 00       	movw   $0x0,(%eax)
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
	memset(ctrlBf,0,sizeof(struct Buffer));
	ctrlBf->pkt = fsm_pkt_create(size);
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11496:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	part1->D_C = 0;
	part1->CPT = 0;
   11498:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	part1->ACK_SN = amIns->vr_ms;	
   1149c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1149f:	0f b6 90 f2 22 00 00 	movzbl 0x22f2(%eax),%edx
   114a6:	0f b6 03             	movzbl (%ebx),%eax
   114a9:	c1 e2 02             	shl    $0x2,%edx
   114ac:	83 e0 03             	and    $0x3,%eax
   114af:	09 d0                	or     %edx,%eax
   114b1:	88 03                	mov    %al,(%ebx)
   114b3:	8b 55 d8             	mov    -0x28(%ebp),%edx
   114b6:	0f b7 82 f2 22 00 00 	movzwl 0x22f2(%edx),%eax
   114bd:	66 c1 e8 06          	shr    $0x6,%ax
   114c1:	83 e0 0f             	and    $0xf,%eax
   114c4:	88 43 01             	mov    %al,0x1(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
   114c7:	0f bf 82 f2 22 00 00 	movswl 0x22f2(%edx),%eax
   114ce:	c7 04 24 f0 3d 00 00 	movl   $0x3df0,(%esp)
   114d5:	89 44 24 04          	mov    %eax,0x4(%esp)
   114d9:	e8 fc ff ff ff       	call   114da <rlc_ctrl_pkt_trans+0xca>
	fsm_octets_print(part1,2);
   114de:	ba 02 00 00 00       	mov    $0x2,%edx
   114e3:	89 d8                	mov    %ebx,%eax
   114e5:	e8 fc ff ff ff       	call   114e6 <rlc_ctrl_pkt_trans+0xd6>
	if( size == 2 )  //PDU
   114ea:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
   114ee:	0f 84 9b 02 00 00    	je     1178f <rlc_ctrl_pkt_trans+0x37f>
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
   114f4:	c7 04 24 18 3e 00 00 	movl   $0x3e18,(%esp)
   114fb:	e8 fc ff ff ff       	call   114fc <rlc_ctrl_pkt_trans+0xec>
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11500:	b9 02 00 00 00       	mov    $0x2,%ecx
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
   11505:	80 0b 02             	orb    $0x2,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11508:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1150b:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1150f:	8b 02                	mov    (%edx),%eax
   11511:	89 da                	mov    %ebx,%edx
   11513:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11519:	e8 fc ff ff ff       	call   1151a <rlc_ctrl_pkt_trans+0x10a>
		fsm_skb_put(ctrlBf->pkt,2);
   1151e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11521:	ba 02 00 00 00       	mov    $0x2,%edx
   11526:	8b 01                	mov    (%ecx),%eax
   11528:	e8 fc ff ff ff       	call   11529 <rlc_ctrl_pkt_trans+0x119>
		pduLen += 2;
   1152d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11530:	83 c0 02             	add    $0x2,%eax
		if( part1 != NULL )
   11533:	85 db                	test   %ebx,%ebx
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
   11535:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if( part1 != NULL )
   11538:	74 0a                	je     11544 <rlc_ctrl_pkt_trans+0x134>
		{
			fsm_mem_free(part1);
   1153a:	89 d8                	mov    %ebx,%eax
   1153c:	e8 fc ff ff ff       	call   1153d <rlc_ctrl_pkt_trans+0x12d>
   11541:	8b 45 f0             	mov    -0x10(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
   11544:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11547:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1154b:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11552:	89 44 24 08          	mov    %eax,0x8(%esp)
   11556:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
   1155d:	c7 04 24 44 3e 00 00 	movl   $0x3e44,(%esp)
   11564:	89 44 24 04          	mov    %eax,0x4(%esp)
   11568:	e8 fc ff ff ff       	call   11569 <rlc_ctrl_pkt_trans+0x159>
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1156d:	0f b7 83 f4 22 00 00 	movzwl 0x22f4(%ebx),%eax
   11574:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11577:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   1157a:	0f bf d0             	movswl %ax,%edx
   1157d:	0f 83 3d 02 00 00    	jae    117c0 <rlc_ctrl_pkt_trans+0x3b0>
   11583:	0f bf 8b f2 22 00 00 	movswl 0x22f2(%ebx),%ecx
   1158a:	39 ca                	cmp    %ecx,%edx
   1158c:	0f 8d 2e 02 00 00    	jge    117c0 <rlc_ctrl_pkt_trans+0x3b0>
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11592:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11595:	8d 5a 01             	lea    0x1(%edx),%ebx
   11598:	89 5d dc             	mov    %ebx,-0x24(%ebp)
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1159b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   1159f:	8d b4 91 6c 12 00 00 	lea    0x126c(%ecx,%edx,4),%esi
   115a6:	66 90                	xchg   %ax,%ax
   115a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   115ab:	c7 04 24 84 3e 00 00 	movl   $0x3e84,(%esp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   115b2:	83 e8 01             	sub    $0x1,%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   115b5:	89 44 24 04          	mov    %eax,0x4(%esp)
   115b9:	e8 fc ff ff ff       	call   115ba <rlc_ctrl_pkt_trans+0x1aa>
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
   115be:	8b 0e                	mov    (%esi),%ecx
   115c0:	85 c9                	test   %ecx,%ecx
   115c2:	0f 84 f8 02 00 00    	je     118c0 <rlc_ctrl_pkt_trans+0x4b0>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] != NULL\n");
   115c8:	c7 04 24 e4 3e 00 00 	movl   $0x3ee4,(%esp)
   115cf:	e8 fc ff ff ff       	call   115d0 <rlc_ctrl_pkt_trans+0x1c0>
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
   115d4:	8b 06                	mov    (%esi),%eax
   115d6:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   115da:	0f 84 80 01 00 00    	je     11760 <rlc_ctrl_pkt_trans+0x350>
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
   115e0:	8b 50 10             	mov    0x10(%eax),%edx
   115e3:	85 d2                	test   %edx,%edx
   115e5:	0f 8e 8d 00 00 00    	jle    11678 <rlc_ctrl_pkt_trans+0x268>
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
   115eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   115ee:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   115f1:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   115f5:	89 04 24             	mov    %eax,(%esp)
   115f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   115fb:	e8 fc ff ff ff       	call   115fc <rlc_ctrl_pkt_trans+0x1ec>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11600:	b8 04 00 00 00       	mov    $0x4,%eax
   11605:	e8 fc ff ff ff       	call   11606 <rlc_ctrl_pkt_trans+0x1f6>
						memset(part3,0,sizeof(ctrlPduPart3));
   1160a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11610:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
   11612:	c6 40 02 00          	movb   $0x0,0x2(%eax)
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   11616:	8b 06                	mov    (%esi),%eax
   11618:	8b 50 10             	mov    0x10(%eax),%edx
   1161b:	0f b6 03             	movzbl (%ebx),%eax
   1161e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
   11625:	83 e0 03             	and    $0x3,%eax
   11628:	09 c8                	or     %ecx,%eax
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1162a:	b9 04 00 00 00       	mov    $0x4,%ecx
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   1162f:	88 03                	mov    %al,(%ebx)
   11631:	89 d0                	mov    %edx,%eax
   11633:	66 c1 e8 06          	shr    $0x6,%ax
   11637:	88 43 01             	mov    %al,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   1163a:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1163d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11640:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
						*(u32 *)part3 = htons(*(u32 *)part3);
   11644:	0f b7 c0             	movzwl %ax,%eax
   11647:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11649:	8b 02                	mov    (%edx),%eax
   1164b:	89 da                	mov    %ebx,%edx
   1164d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11653:	e8 fc ff ff ff       	call   11654 <rlc_ctrl_pkt_trans+0x244>
						fsm_skb_put(ctrlBf->pkt,4);
   11658:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1165b:	ba 04 00 00 00       	mov    $0x4,%edx
   11660:	8b 01                	mov    (%ecx),%eax
   11662:	e8 fc ff ff ff       	call   11663 <rlc_ctrl_pkt_trans+0x253>
						pduLen += 4;
   11667:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   1166b:	85 db                	test   %ebx,%ebx
   1166d:	74 07                	je     11676 <rlc_ctrl_pkt_trans+0x266>
						{
							fsm_mem_free(part3);
   1166f:	89 d8                	mov    %ebx,%eax
   11671:	e8 fc ff ff ff       	call   11672 <rlc_ctrl_pkt_trans+0x262>
   11676:	8b 06                	mov    (%esi),%eax
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11678:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   1167e:	31 ff                	xor    %edi,%edi
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11680:	0f bf 5d e8          	movswl -0x18(%ebp),%ebx
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11684:	83 ea 01             	sub    $0x1,%edx
   11687:	39 d7                	cmp    %edx,%edi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11689:	89 5d e0             	mov    %ebx,-0x20(%ebp)
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   1168c:	0f 83 c4 00 00 00    	jae    11756 <rlc_ctrl_pkt_trans+0x346>
   11692:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11698:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1169b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1169e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   116a1:	89 04 24             	mov    %eax,(%esp)
   116a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116a7:	e8 fc ff ff ff       	call   116a8 <rlc_ctrl_pkt_trans+0x298>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   116ac:	b8 04 00 00 00       	mov    $0x4,%eax
   116b1:	e8 fc ff ff ff       	call   116b2 <rlc_ctrl_pkt_trans+0x2a2>
						memset(part3,0,sizeof(ctrlPduPart3));
   116b6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   116bc:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   116be:	8b 06                	mov    (%esi),%eax
   116c0:	8b 54 b8 50          	mov    0x50(%eax,%edi,4),%edx
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   116c4:	83 c7 01             	add    $0x1,%edi
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   116c7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
   116cb:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
   116ce:	83 e0 01             	and    $0x1,%eax
   116d1:	09 c8                	or     %ecx,%eax
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   116d3:	b9 04 00 00 00       	mov    $0x4,%ecx
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   116d8:	66 c1 ea 07          	shr    $0x7,%dx
   116dc:	88 43 02             	mov    %al,0x2(%ebx)
   116df:	88 53 03             	mov    %dl,0x3(%ebx)
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   116e2:	8b 16                	mov    (%esi),%edx
   116e4:	8b 54 ba 10          	mov    0x10(%edx,%edi,4),%edx
   116e8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   116eb:	c1 e2 02             	shl    $0x2,%edx
   116ee:	88 55 eb             	mov    %dl,-0x15(%ebp)
   116f1:	0f b6 13             	movzbl (%ebx),%edx
   116f4:	83 e2 03             	and    $0x3,%edx
   116f7:	0a 55 eb             	or     -0x15(%ebp),%dl
   116fa:	88 13                	mov    %dl,(%ebx)
   116fc:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
   11700:	66 c1 ea 06          	shr    $0x6,%dx
   11704:	88 53 01             	mov    %dl,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   11707:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1170a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1170d:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
   11711:	0f b7 c0             	movzwl %ax,%eax
   11714:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11716:	8b 02                	mov    (%edx),%eax
   11718:	89 da                	mov    %ebx,%edx
   1171a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11720:	e8 fc ff ff ff       	call   11721 <rlc_ctrl_pkt_trans+0x311>
						fsm_skb_put(ctrlBf->pkt,4);
   11725:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11728:	ba 04 00 00 00       	mov    $0x4,%edx
   1172d:	8b 01                	mov    (%ecx),%eax
   1172f:	e8 fc ff ff ff       	call   11730 <rlc_ctrl_pkt_trans+0x320>
						pduLen += 4;
   11734:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   11738:	85 db                	test   %ebx,%ebx
   1173a:	74 07                	je     11743 <rlc_ctrl_pkt_trans+0x333>
						{
							fsm_mem_free(part3);
   1173c:	89 d8                	mov    %ebx,%eax
   1173e:	e8 fc ff ff ff       	call   1173f <rlc_ctrl_pkt_trans+0x32f>
   11743:	8b 06                	mov    (%esi),%eax
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11745:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   1174b:	83 ea 01             	sub    $0x1,%edx
   1174e:	39 d7                	cmp    %edx,%edi
   11750:	0f 82 42 ff ff ff    	jb     11698 <rlc_ctrl_pkt_trans+0x288>
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
   11756:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
   1175a:	0f 84 e1 00 00 00    	je     11841 <rlc_ctrl_pkt_trans+0x431>
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
						if( part3 != NULL )
						{
							fsm_mem_free(part3);
   11760:	8b 45 f0             	mov    -0x10(%ebp),%eax
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   11763:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11766:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
   11769:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11770:	0f 97 c2             	seta   %dl
   11773:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   11776:	0f 9f c0             	setg   %al
   11779:	83 c6 04             	add    $0x4,%esi
   1177c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   11780:	66 83 45 e8 01       	addw   $0x1,-0x18(%ebp)
   11785:	84 c2                	test   %al,%dl
   11787:	0f 85 1b fe ff ff    	jne    115a8 <rlc_ctrl_pkt_trans+0x198>
   1178d:	eb 31                	jmp    117c0 <rlc_ctrl_pkt_trans+0x3b0>
	part1->ACK_SN = amIns->vr_ms;	
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
	fsm_octets_print(part1,2);
	if( size == 2 )  //PDU
	{
		part1->E1 = 0;
   1178f:	80 23 fd             	andb   $0xfd,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11792:	89 da                	mov    %ebx,%edx
   11794:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11797:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1179b:	8b 01                	mov    (%ecx),%eax
   1179d:	b9 02 00 00 00       	mov    $0x2,%ecx
   117a2:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   117a8:	e8 fc ff ff ff       	call   117a9 <rlc_ctrl_pkt_trans+0x399>
		fsm_skb_put(ctrlBf->pkt,2);
   117ad:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   117b0:	ba 02 00 00 00       	mov    $0x2,%edx
   117b5:	8b 03                	mov    (%ebx),%eax
   117b7:	e8 fc ff ff ff       	call   117b8 <rlc_ctrl_pkt_trans+0x3a8>
		pduLen += 2;
   117bc:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   117c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   117c3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   117c6:	8b 5d d8             	mov    -0x28(%ebp),%ebx
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   117c9:	8b 90 bc 01 00 00    	mov    0x1bc(%eax),%edx
   117cf:	83 c2 01             	add    $0x1,%edx
   117d2:	89 90 bc 01 00 00    	mov    %edx,0x1bc(%eax)
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   117d8:	8b 01                	mov    (%ecx),%eax
   117da:	8b 40 50             	mov    0x50(%eax),%eax
   117dd:	03 83 b8 01 00 00    	add    0x1b8(%ebx),%eax
   117e3:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
   117e9:	89 54 24 04          	mov    %edx,0x4(%esp)
   117ed:	89 44 24 08          	mov    %eax,0x8(%esp)
   117f1:	c7 04 24 20 3f 00 00 	movl   $0x3f20,(%esp)
   117f8:	e8 fc ff ff ff       	call   117f9 <rlc_ctrl_pkt_trans+0x3e9>
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
   117fd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11800:	89 d9                	mov    %ebx,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11802:	8b 83 b4 01 00 00    	mov    0x1b4(%ebx),%eax
   11808:	81 c1 b0 01 00 00    	add    $0x1b0,%ecx
   1180e:	83 c2 04             	add    $0x4,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11811:	89 93 b4 01 00 00    	mov    %edx,0x1b4(%ebx)
   11817:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	new->next = next;
	new->prev = prev;
   1181a:	89 43 08             	mov    %eax,0x8(%ebx)
   1181d:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = new;
   11820:	89 10                	mov    %edx,(%eax)
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
   11822:	8b 03                	mov    (%ebx),%eax
   11824:	8b 50 50             	mov    0x50(%eax),%edx
   11827:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1182d:	e8 fc ff ff ff       	call   1182e <rlc_ctrl_pkt_trans+0x41e>
	amIns->statFlag = false;
   11832:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11835:	c6 40 06 00          	movb   $0x0,0x6(%eax)
	FOUT;
}
   11839:	83 c4 30             	add    $0x30,%esp
   1183c:	5b                   	pop    %ebx
   1183d:	5e                   	pop    %esi
   1183e:	5f                   	pop    %edi
   1183f:	5d                   	pop    %ebp
   11840:	c3                   	ret    
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11841:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11844:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   11847:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   1184b:	89 04 24             	mov    %eax,(%esp)
   1184e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11851:	e8 fc ff ff ff       	call   11852 <rlc_ctrl_pkt_trans+0x442>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11856:	b8 04 00 00 00       	mov    $0x4,%eax
   1185b:	e8 fc ff ff ff       	call   1185c <rlc_ctrl_pkt_trans+0x44c>
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11860:	b9 04 00 00 00       	mov    $0x4,%ecx
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
   11865:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1186b:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
   1186d:	80 08 fc             	orb    $0xfc,(%eax)
   11870:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
						*(u32 *)part3 = htons(*(u32 *)part3);
   11874:	0f b7 00             	movzwl (%eax),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11877:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1187a:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
   1187e:	0f b7 c0             	movzwl %ax,%eax
   11881:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11883:	8b 02                	mov    (%edx),%eax
   11885:	89 da                	mov    %ebx,%edx
   11887:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1188d:	e8 fc ff ff ff       	call   1188e <rlc_ctrl_pkt_trans+0x47e>
						fsm_skb_put(ctrlBf->pkt,4);
   11892:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11895:	ba 04 00 00 00       	mov    $0x4,%edx
   1189a:	8b 01                	mov    (%ecx),%eax
   1189c:	e8 fc ff ff ff       	call   1189d <rlc_ctrl_pkt_trans+0x48d>
						pduLen += 4;
   118a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118a4:	83 c0 04             	add    $0x4,%eax
						if( part3 != NULL )
   118a7:	85 db                	test   %ebx,%ebx
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
   118a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
						if( part3 != NULL )
   118ac:	0f 84 b1 fe ff ff    	je     11763 <rlc_ctrl_pkt_trans+0x353>
						{
							fsm_mem_free(part3);
   118b2:	89 d8                	mov    %ebx,%eax
   118b4:	e8 fc ff ff ff       	call   118b5 <rlc_ctrl_pkt_trans+0x4a5>
   118b9:	e9 a2 fe ff ff       	jmp    11760 <rlc_ctrl_pkt_trans+0x350>
   118be:	66 90                	xchg   %ax,%ax
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] == NULL\n");
   118c0:	c7 04 24 a8 3e 00 00 	movl   $0x3ea8,(%esp)
   118c7:	e8 fc ff ff ff       	call   118c8 <rlc_ctrl_pkt_trans+0x4b8>
				if( pduLen+2<=size )
   118cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   118cf:	8d 50 02             	lea    0x2(%eax),%edx
   118d2:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
   118d5:	0f 82 88 fe ff ff    	jb     11763 <rlc_ctrl_pkt_trans+0x353>
				{
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   118db:	b8 02 00 00 00       	mov    $0x2,%eax
   118e0:	e8 fc ff ff ff       	call   118e1 <rlc_ctrl_pkt_trans+0x4d1>
   118e5:	89 c3                	mov    %eax,%ebx
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
   118e7:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   118eb:	c1 e0 06             	shl    $0x6,%eax
   118ee:	88 03                	mov    %al,(%ebx)
   118f0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   118f4:	66 c1 ea 02          	shr    $0x2,%dx
   118f8:	88 53 01             	mov    %dl,0x1(%ebx)
					if( pduLen+2==size )
   118fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
   118fe:	83 c2 02             	add    $0x2,%edx
   11901:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
   11904:	74 48                	je     1194e <rlc_ctrl_pkt_trans+0x53e>
					{
						part2->E1=0; //E11
					}
					else
					{
						part2->E1=1;
   11906:	83 c8 20             	or     $0x20,%eax
   11909:	88 03                	mov    %al,(%ebx)
					}
					part2->E2=0;
   1190b:	80 23 ef             	andb   $0xef,(%ebx)
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   1190e:	b9 02 00 00 00       	mov    $0x2,%ecx
   11913:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11916:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1191a:	8b 02                	mov    (%edx),%eax
   1191c:	89 da                	mov    %ebx,%edx
   1191e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11924:	e8 fc ff ff ff       	call   11925 <rlc_ctrl_pkt_trans+0x515>
					fsm_skb_put(ctrlBf->pkt,2);
   11929:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1192c:	ba 02 00 00 00       	mov    $0x2,%edx
   11931:	8b 01                	mov    (%ecx),%eax
   11933:	e8 fc ff ff ff       	call   11934 <rlc_ctrl_pkt_trans+0x524>
					pduLen += 2;
   11938:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1193b:	83 c0 02             	add    $0x2,%eax
					if( part2 != NULL )
   1193e:	85 db                	test   %ebx,%ebx
					}
					part2->E2=0;
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
					fsm_skb_put(ctrlBf->pkt,2);
					pduLen += 2;
   11940:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if( part2 != NULL )
   11943:	0f 85 69 ff ff ff    	jne    118b2 <rlc_ctrl_pkt_trans+0x4a2>
   11949:	e9 15 fe ff ff       	jmp    11763 <rlc_ctrl_pkt_trans+0x353>
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
					if( pduLen+2==size )
					{
						part2->E1=0; //E11
   1194e:	83 e0 df             	and    $0xffffffdf,%eax
   11951:	88 03                	mov    %al,(%ebx)
   11953:	eb b6                	jmp    1190b <rlc_ctrl_pkt_trans+0x4fb>
	size = 0;
	size = size_of_ctrl_pdu(amIns);
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
	if( size < 2)  //PDU2
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
   11955:	c7 04 24 c4 3d 00 00 	movl   $0x3dc4,(%esp)
   1195c:	e8 fc ff ff ff       	call   1195d <rlc_ctrl_pkt_trans+0x54d>
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
	amIns->statFlag = false;
	FOUT;
}
   11961:	83 c4 30             	add    $0x30,%esp
   11964:	5b                   	pop    %ebx
   11965:	5e                   	pop    %esi
   11966:	5f                   	pop    %edi
   11967:	5d                   	pop    %ebp
   11968:	c3                   	ret    
   11969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00011970 <ack_handler>:
**----------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014/10/13
**********************************************************************************************/
void ack_handler(struct AM_Instance *amIns,SequenceNumber ackSn)   //20141013
{
   11970:	55                   	push   %ebp
   11971:	89 e5                	mov    %esp,%ebp
   11973:	57                   	push   %edi
   11974:	56                   	push   %esi
   11975:	53                   	push   %ebx
   11976:	83 ec 10             	sub    $0x10,%esp
   11979:	e8 fc ff ff ff       	call   1197a <ack_handler+0xa>
   1197e:	89 c3                	mov    %eax,%ebx
   11980:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11984:	0f b7 90 66 12 00 00 	movzwl 0x1266(%eax),%edx
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   1198b:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
   1198f:	89 45 e8             	mov    %eax,-0x18(%ebp)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11992:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
   11998:	89 45 f0             	mov    %eax,-0x10(%ebp)
   1199b:	90                   	nop
   1199c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   119a0:	66 39 55 ee          	cmp    %dx,-0x12(%ebp)
   119a4:	7f 12                	jg     119b8 <ack_handler+0x48>
   119a6:	0f bf c2             	movswl %dx,%eax
   119a9:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   119af:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
   119b2:	0f 8d 17 02 00 00    	jge    11bcf <ack_handler+0x25f>
   119b8:	0f b7 b3 64 12 00 00 	movzwl 0x1264(%ebx),%esi
   119bf:	66 39 d6             	cmp    %dx,%si
   119c2:	7f 14                	jg     119d8 <ack_handler+0x68>
   119c4:	0f bf c2             	movswl %dx,%eax
   119c7:	0f bf f6             	movswl %si,%esi
   119ca:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   119d0:	39 ce                	cmp    %ecx,%esi
   119d2:	0f 8d f7 01 00 00    	jge    11bcf <ack_handler+0x25f>
	{
		if( amIns->vt_a == amIns->pollSn )
   119d8:	66 39 93 00 23 00 00 	cmp    %dx,0x2300(%ebx)
   119df:	0f 84 bb 01 00 00    	je     11ba0 <ack_handler+0x230>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   119e5:	8b 8b f0 00 00 00    	mov    0xf0(%ebx),%ecx
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   119eb:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   119ee:	74 45                	je     11a35 <ack_handler+0xc5>
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   119f0:	8b 01                	mov    (%ecx),%eax
   119f2:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   119f8:	8b 7d f0             	mov    -0x10(%ebp),%edi
   119fb:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11a00:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11a04:	75 19                	jne    11a1f <ack_handler+0xaf>
   11a06:	e9 2f 01 00 00       	jmp    11b3a <ack_handler+0x1ca>
   11a0b:	90                   	nop
   11a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11a10:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11a17:	0f 84 1b 01 00 00    	je     11b38 <ack_handler+0x1c8>
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11a1d:	89 f0                	mov    %esi,%eax
   11a1f:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11a25:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11a2b:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11a31:	39 cf                	cmp    %ecx,%edi
   11a33:	75 db                	jne    11a10 <ack_handler+0xa0>
   11a35:	8b 8b 9c 01 00 00    	mov    0x19c(%ebx),%ecx
			}
			//nposBf = NULL;
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
   11a3b:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
   11a41:	39 cf                	cmp    %ecx,%edi
   11a43:	74 3c                	je     11a81 <ack_handler+0x111>
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11a45:	8b 01                	mov    (%ecx),%eax
   11a47:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11a4d:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amRetxBf->SN == amIns->vt_a )
   11a52:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11a56:	75 13                	jne    11a6b <ack_handler+0xfb>
   11a58:	eb 50                	jmp    11aaa <ack_handler+0x13a>
   11a5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11a60:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11a67:	74 3f                	je     11aa8 <ack_handler+0x138>
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11a69:	89 f0                	mov    %esi,%eax
   11a6b:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11a71:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11a77:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11a7d:	39 cf                	cmp    %ecx,%edi
   11a7f:	75 df                	jne    11a60 <ack_handler+0xf0>
					break;
				}
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
   11a81:	0f bf c2             	movswl %dx,%eax
   11a84:	83 c0 01             	add    $0x1,%eax
   11a87:	89 c1                	mov    %eax,%ecx
   11a89:	c1 f9 1f             	sar    $0x1f,%ecx
   11a8c:	c1 e9 16             	shr    $0x16,%ecx
   11a8f:	01 c8                	add    %ecx,%eax
   11a91:	25 ff 03 00 00       	and    $0x3ff,%eax
   11a96:	29 c8                	sub    %ecx,%eax
   11a98:	89 c2                	mov    %eax,%edx
   11a9a:	66 89 83 66 12 00 00 	mov    %ax,0x1266(%ebx)
   11aa1:	e9 fa fe ff ff       	jmp    119a0 <ack_handler+0x30>
   11aa6:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
   11aa8:	89 c6                	mov    %eax,%esi
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11aaa:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
   11ab0:	31 d2                	xor    %edx,%edx
   11ab2:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   11ab8:	85 ff                	test   %edi,%edi
   11aba:	74 1d                	je     11ad9 <ack_handler+0x169>
   11abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11ac0:	03 44 96 10          	add    0x10(%esi,%edx,4),%eax
   11ac4:	2b 44 96 50          	sub    0x50(%esi,%edx,4),%eax
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11ac8:	83 c2 01             	add    $0x1,%edx
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11acb:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11ad1:	3b 96 90 00 00 00    	cmp    0x90(%esi),%edx
   11ad7:	72 e7                	jb     11ac0 <ack_handler+0x150>
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11ad9:	2b 46 0c             	sub    0xc(%esi),%eax
					amIns->amRetxBufferNum--;
   11adc:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				{
					for( i = 0; i <amRetxBf->segnum; i++)
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11ae3:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
					amIns->amRetxBufferNum--;
					if(amRetxBf->pkt != NULL)
   11ae9:	8b 06                	mov    (%esi),%eax
   11aeb:	85 c0                	test   %eax,%eax
   11aed:	74 0b                	je     11afa <ack_handler+0x18a>
					{
						fsm_pkt_destroy( amRetxBf->pkt );
   11aef:	e8 fc ff ff ff       	call   11af0 <ack_handler+0x180>
						amRetxBf->pkt = NULL;
   11af4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11afa:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amRetxBf->list);
					if(amRetxBf != NULL)
   11b00:	85 f6                	test   %esi,%esi
   11b02:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11b08:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11b0b:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11b0d:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11b14:	01 10 00 
	entry->prev = LIST_POISON2;
   11b17:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11b1e:	02 20 00 
   11b21:	74 07                	je     11b2a <ack_handler+0x1ba>
					{
						fsm_mem_free(amRetxBf);
   11b23:	89 f0                	mov    %esi,%eax
   11b25:	e8 fc ff ff ff       	call   11b26 <ack_handler+0x1b6>
   11b2a:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11b31:	e9 4b ff ff ff       	jmp    11a81 <ack_handler+0x111>
   11b36:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11b38:	89 c6                	mov    %eax,%esi
				{
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11b3a:	8b 06                	mov    (%esi),%eax
   11b3c:	8b 40 50             	mov    0x50(%eax),%eax
   11b3f:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11b45:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					if(amTxedBuffer->pkt != NULL)
   11b4c:	8b 06                	mov    (%esi),%eax
   11b4e:	85 c0                	test   %eax,%eax
   11b50:	74 0b                	je     11b5d <ack_handler+0x1ed>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   11b52:	e8 fc ff ff ff       	call   11b53 <ack_handler+0x1e3>
						amTxedBuffer->pkt = NULL;
   11b57:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11b5d:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   11b63:	85 f6                	test   %esi,%esi
   11b65:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11b6b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11b6e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11b70:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11b77:	01 10 00 
	entry->prev = LIST_POISON2;
   11b7a:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11b81:	02 20 00 
   11b84:	74 07                	je     11b8d <ack_handler+0x21d>
					{
						fsm_mem_free(amTxedBuffer);
   11b86:	89 f0                	mov    %esi,%eax
   11b88:	e8 fc ff ff ff       	call   11b89 <ack_handler+0x219>
   11b8d:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11b94:	e9 9c fe ff ff       	jmp    11a35 <ack_handler+0xc5>
   11b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
	{
		if( amIns->vt_a == amIns->pollSn )
		{
			//
			if(amIns->pollRetxTimer)
   11ba0:	8b 43 08             	mov    0x8(%ebx),%eax
   11ba3:	85 c0                	test   %eax,%eax
   11ba5:	0f 84 3a fe ff ff    	je     119e5 <ack_handler+0x75>
			{
				fsm_schedule_cancel(amIns->pollRetxTimer);
   11bab:	e8 fc ff ff ff       	call   11bac <ack_handler+0x23c>
				amIns->pollRetxTimer = 0;
   11bb0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
   11bb7:	c7 04 24 64 3f 00 00 	movl   $0x3f64,(%esp)
   11bbe:	e8 fc ff ff ff       	call   11bbf <ack_handler+0x24f>
   11bc3:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11bca:	e9 16 fe ff ff       	jmp    119e5 <ack_handler+0x75>
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
	}
	amIns->vt_ms = (amIns->vt_a + AM_WINDOW_SIZE)%(AM_WINDOW_SIZE*2);
   11bcf:	05 00 02 00 00       	add    $0x200,%eax
   11bd4:	89 c2                	mov    %eax,%edx
   11bd6:	c1 fa 1f             	sar    $0x1f,%edx
   11bd9:	c1 ea 16             	shr    $0x16,%edx
   11bdc:	01 d0                	add    %edx,%eax
   11bde:	25 ff 03 00 00       	and    $0x3ff,%eax
   11be3:	29 d0                	sub    %edx,%eax
   11be5:	66 89 83 68 12 00 00 	mov    %ax,0x1268(%ebx)
}
   11bec:	83 c4 10             	add    $0x10,%esp
   11bef:	5b                   	pop    %ebx
   11bf0:	5e                   	pop    %esi
   11bf1:	5f                   	pop    %edi
   11bf2:	5d                   	pop    %ebp
   11bf3:	c3                   	ret    
   11bf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11bfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00011c00 <no_so_handler>:
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11c00:	55                   	push   %ebp
   11c01:	89 e5                	mov    %esp,%ebp
   11c03:	57                   	push   %edi
   11c04:	56                   	push   %esi
   11c05:	53                   	push   %ebx
   11c06:	83 ec 14             	sub    $0x14,%esp
   11c09:	e8 fc ff ff ff       	call   11c0a <no_so_handler+0xa>
   11c0e:	89 c3                	mov    %eax,%ebx
   11c10:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11c13:	8d bb f0 00 00 00    	lea    0xf0(%ebx),%edi
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11c19:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	struct AmBuffer *amTxedBuffer;	//
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
   11c1c:	c7 04 24 90 3f 00 00 	movl   $0x3f90,(%esp)
   11c23:	e8 fc ff ff ff       	call   11c24 <no_so_handler+0x24>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11c28:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11c2e:	39 c7                	cmp    %eax,%edi
   11c30:	74 61                	je     11c93 <no_so_handler+0x93>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11c32:	8b 10                	mov    (%eax),%edx
   11c34:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11c3a:	8b 75 f0             	mov    -0x10(%ebp),%esi
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11c3d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   11c40:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11c43:	0f b6 16             	movzbl (%esi),%edx
   11c46:	0f b6 76 01          	movzbl 0x1(%esi),%esi
   11c4a:	c0 ea 06             	shr    $0x6,%dl
   11c4d:	0f b6 d2             	movzbl %dl,%edx
   11c50:	c1 e6 02             	shl    $0x2,%esi
   11c53:	09 d6                	or     %edx,%esi
   11c55:	0f bf 50 f8          	movswl -0x8(%eax),%edx
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11c59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11c5c:	2d 9c 00 00 00       	sub    $0x9c,%eax
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11c61:	39 d6                	cmp    %edx,%esi
   11c63:	75 18                	jne    11c7d <no_so_handler+0x7d>
   11c65:	e9 e7 01 00 00       	jmp    11e51 <no_so_handler+0x251>
   11c6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11c70:	0f bf 90 94 00 00 00 	movswl 0x94(%eax),%edx
   11c77:	39 f2                	cmp    %esi,%edx
   11c79:	74 25                	je     11ca0 <no_so_handler+0xa0>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11c7b:	89 c8                	mov    %ecx,%eax
   11c7d:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   11c83:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   11c89:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   11c8f:	39 d7                	cmp    %edx,%edi
   11c91:	75 dd                	jne    11c70 <no_so_handler+0x70>
				break;
			}
		}
	}
	FOUT;
}
   11c93:	83 c4 14             	add    $0x14,%esp
   11c96:	5b                   	pop    %ebx
   11c97:	5e                   	pop    %esi
   11c98:	5f                   	pop    %edi
   11c99:	5d                   	pop    %ebp
   11c9a:	c3                   	ret    
   11c9b:	90                   	nop
   11c9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11ca0:	89 c6                	mov    %eax,%esi
			{
				*isPduFound = true;
   11ca2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11ca5:	c6 01 01             	movb   $0x1,(%ecx)
				amTxedBuffer->segStart[0] = 0;
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11ca8:	8b 06                	mov    (%esi),%eax
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
			{
				*isPduFound = true;
				amTxedBuffer->segStart[0] = 0;
   11caa:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11cb1:	8b 40 50             	mov    0x50(%eax),%eax
   11cb4:	89 46 50             	mov    %eax,0x50(%esi)

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   11cb7:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   11cbe:	66 83 f8 ff          	cmp    $0xffff,%ax
   11cc2:	0f 84 28 01 00 00    	je     11df0 <no_so_handler+0x1f0>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   11cc8:	83 c0 01             	add    $0x1,%eax
   11ccb:	66 89 86 96 00 00 00 	mov    %ax,0x96(%esi)
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
   11cd2:	c7 04 24 c0 3f 00 00 	movl   $0x3fc0,(%esp)
   11cd9:	e8 fc ff ff ff       	call   11cda <no_so_handler+0xda>
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   11cde:	0f bf 96 96 00 00 00 	movswl 0x96(%esi),%edx
   11ce5:	0f b7 83 fa 22 00 00 	movzwl 0x22fa(%ebx),%eax
   11cec:	39 c2                	cmp    %eax,%edx
   11cee:	74 18                	je     11d08 <no_so_handler+0x108>
						}
					}
				}
				else
				{
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   11cf0:	c7 04 24 e8 3f 00 00 	movl   $0x3fe8,(%esp)
   11cf7:	e8 fc ff ff ff       	call   11cf8 <no_so_handler+0xf8>
				break;
			}
		}
	}
	FOUT;
}
   11cfc:	83 c4 14             	add    $0x14,%esp
   11cff:	5b                   	pop    %ebx
   11d00:	5e                   	pop    %esi
   11d01:	5f                   	pop    %edi
   11d02:	5d                   	pop    %ebp
   11d03:	c3                   	ret    
   11d04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   11d08:	b8 04 00 00 00       	mov    $0x4,%eax
   11d0d:	e8 fc ff ff ff       	call   11d0e <no_so_handler+0x10e>
					mioctrl->eventCode = 0;
   11d12:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   11d17:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
   11d1b:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   11d1e:	e8 fc ff ff ff       	call   11d1f <no_so_handler+0x11f>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11d23:	8b 06                	mov    (%esi),%eax
   11d25:	8b 40 50             	mov    0x50(%eax),%eax
   11d28:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11d2e:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   11d35:	8b 06                	mov    (%esi),%eax
   11d37:	e8 fc ff ff ff       	call   11d38 <no_so_handler+0x138>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11d3c:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   11d42:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
					amTxedBuffer->pkt = NULL;
   11d48:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11d4e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11d51:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   11d53:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11d55:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11d5c:	01 10 00 
	entry->prev = LIST_POISON2;
   11d5f:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11d66:	02 20 00 
   11d69:	e8 fc ff ff ff       	call   11d6a <no_so_handler+0x16a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11d6e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   11d74:	8d 93 9c 01 00 00    	lea    0x19c(%ebx),%edx
   11d7a:	39 c2                	cmp    %eax,%edx
   11d7c:	0f 84 11 ff ff ff    	je     11c93 <no_so_handler+0x93>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11d82:	8b 30                	mov    (%eax),%esi
   11d84:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11d8a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11d8d:	89 7d ec             	mov    %edi,-0x14(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11d90:	0f bf 40 f8          	movswl -0x8(%eax),%eax
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11d94:	89 75 e8             	mov    %esi,-0x18(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11d97:	0f b6 31             	movzbl (%ecx),%esi
   11d9a:	89 f1                	mov    %esi,%ecx
   11d9c:	c0 e9 06             	shr    $0x6,%cl
   11d9f:	89 ce                	mov    %ecx,%esi
   11da1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11da4:	81 e6 ff 00 00 00    	and    $0xff,%esi
   11daa:	0f b6 79 01          	movzbl 0x1(%ecx),%edi
   11dae:	c1 e7 02             	shl    $0x2,%edi
   11db1:	09 f7                	or     %esi,%edi
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11db3:	8b 75 e8             	mov    -0x18(%ebp),%esi
   11db6:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11dbc:	39 f8                	cmp    %edi,%eax
   11dbe:	75 15                	jne    11dd5 <no_so_handler+0x1d5>
   11dc0:	eb 3c                	jmp    11dfe <no_so_handler+0x1fe>
   11dc2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11dc8:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   11dcf:	39 f8                	cmp    %edi,%eax
   11dd1:	74 2e                	je     11e01 <no_so_handler+0x201>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11dd3:	89 ce                	mov    %ecx,%esi
   11dd5:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
   11ddb:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   11de1:	8d 86 9c 00 00 00    	lea    0x9c(%esi),%eax
   11de7:	39 c2                	cmp    %eax,%edx
   11de9:	75 dd                	jne    11dc8 <no_so_handler+0x1c8>
   11deb:	e9 a3 fe ff ff       	jmp    11c93 <no_so_handler+0x93>
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   11df0:	66 c7 86 96 00 00 00 	movw   $0x0,0x96(%esi)
   11df7:	00 00 
   11df9:	e9 d4 fe ff ff       	jmp    11cd2 <no_so_handler+0xd2>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11dfe:	8b 75 ec             	mov    -0x14(%ebp),%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
							{
								amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   11e01:	8b 06                	mov    (%esi),%eax
   11e03:	8b 40 50             	mov    0x50(%eax),%eax
   11e06:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
								amIns->amRetxBufferNum--;
   11e0c:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
								fsm_pkt_destroy( amRetxBf->pkt );
   11e13:	8b 06                	mov    (%esi),%eax
   11e15:	e8 fc ff ff ff       	call   11e16 <no_so_handler+0x216>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11e1a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   11e20:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
								amRetxBf->pkt = NULL;
   11e26:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11e2c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11e2f:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   11e31:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11e33:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11e3a:	01 10 00 
	entry->prev = LIST_POISON2;
   11e3d:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11e44:	02 20 00 
   11e47:	e8 fc ff ff ff       	call   11e48 <no_so_handler+0x248>
								amRetxBf = NULL;
								break;
   11e4c:	e9 42 fe ff ff       	jmp    11c93 <no_so_handler+0x93>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11e51:	89 ce                	mov    %ecx,%esi
   11e53:	e9 4a fe ff ff       	jmp    11ca2 <no_so_handler+0xa2>
   11e58:	90                   	nop
   11e59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00011e60 <rlc_ctrl_pkt_recv>:
**Modified by:
**Modified Date:
************************************************************************/

void rlc_ctrl_pkt_recv(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   11e60:	55                   	push   %ebp
   11e61:	89 e5                	mov    %esp,%ebp
   11e63:	56                   	push   %esi
   11e64:	53                   	push   %ebx
   11e65:	83 ec 08             	sub    $0x8,%esp
   11e68:	e8 fc ff ff ff       	call   11e69 <rlc_ctrl_pkt_recv+0x9>
   11e6d:	89 d6                	mov    %edx,%esi
	u32 pduLen=0;
	u8 E1=0;
	bool isPduFound = false;

	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
   11e6f:	c7 04 24 14 40 00 00 	movl   $0x4014,(%esp)
   11e76:	e8 fc ff ff ff       	call   11e77 <rlc_ctrl_pkt_recv+0x17>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
   11e7b:	8b 46 50             	mov    0x50(%esi),%eax
   11e7e:	c7 04 24 54 40 00 00 	movl   $0x4054,(%esp)
   11e85:	89 44 24 04          	mov    %eax,0x4(%esp)
   11e89:	e8 fc ff ff ff       	call   11e8a <rlc_ctrl_pkt_recv+0x2a>
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11e8e:	b8 02 00 00 00       	mov    $0x2,%eax
   11e93:	e8 fc ff ff ff       	call   11e94 <rlc_ctrl_pkt_recv+0x34>
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11e98:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
	memset(part1,0,sizeof(ctrlPduPart1));
   11e9d:	66 c7 00 00 00       	movw   $0x0,(%eax)
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11ea2:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11ea8:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11eaa:	e8 fc ff ff ff       	call   11eab <rlc_ctrl_pkt_recv+0x4b>
	fsm_skb_pull(pkt,2);
   11eaf:	ba 02 00 00 00       	mov    $0x2,%edx
   11eb4:	89 f0                	mov    %esi,%eax
   11eb6:	e8 fc ff ff ff       	call   11eb7 <rlc_ctrl_pkt_recv+0x57>
	*(u16 *)part1 = ntohs(*(u16 *)part1);
	pduLen -= 2;
	fsm_octets_print(part1,2);
   11ebb:	ba 02 00 00 00       	mov    $0x2,%edx
   11ec0:	89 d8                	mov    %ebx,%eax
   11ec2:	66 c1 03 08          	rolw   $0x8,(%ebx)
   11ec6:	e8 fc ff ff ff       	call   11ec7 <rlc_ctrl_pkt_recv+0x67>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->E1 is %d)\n",part1->E1);	
   11ecb:	0f b6 03             	movzbl (%ebx),%eax
   11ece:	d0 e8                	shr    %al
   11ed0:	83 e0 01             	and    $0x1,%eax
   11ed3:	89 44 24 04          	mov    %eax,0x4(%esp)
   11ed7:	c7 04 24 80 40 00 00 	movl   $0x4080,(%esp)
   11ede:	e8 fc ff ff ff       	call   11edf <rlc_ctrl_pkt_recv+0x7f>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->acksn is %d)\n",part1->ACK_SN);
   11ee3:	0f b6 03             	movzbl (%ebx),%eax
   11ee6:	c0 e8 02             	shr    $0x2,%al
   11ee9:	0f b6 d0             	movzbl %al,%edx
   11eec:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   11ef0:	c7 04 24 ac 40 00 00 	movl   $0x40ac,(%esp)
   11ef7:	83 e0 0f             	and    $0xf,%eax
   11efa:	c1 e0 06             	shl    $0x6,%eax
   11efd:	09 d0                	or     %edx,%eax
   11eff:	89 44 24 04          	mov    %eax,0x4(%esp)
   11f03:	e8 fc ff ff ff       	call   11f04 <rlc_ctrl_pkt_recv+0xa4>
		{
			fsm_mem_free(part3);
			part3=NULL;
		}
	}
}
   11f08:	83 c4 08             	add    $0x8,%esp
   11f0b:	5b                   	pop    %ebx
   11f0c:	5e                   	pop    %esi
   11f0d:	5d                   	pop    %ebp
   11f0e:	c3                   	ret    
   11f0f:	90                   	nop

00011f10 <rlc_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_retx(struct AM_Instance *amIns,struct AmBuffer *amTxedBuffer)
{
   11f10:	55                   	push   %ebp
   11f11:	89 e5                	mov    %esp,%ebp
   11f13:	57                   	push   %edi
   11f14:	56                   	push   %esi
   11f15:	53                   	push   %ebx
   11f16:	83 ec 10             	sub    $0x10,%esp
   11f19:	e8 fc ff ff ff       	call   11f1a <rlc_retx+0xa>
   11f1e:	89 c3                	mov    %eax,%ebx
   11f20:	89 d6                	mov    %edx,%esi
	struct AmBuffer *amRetxBf;
	struct AmBuffer *nposBf;
	int i;

	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
   11f22:	c7 04 24 dc 40 00 00 	movl   $0x40dc,(%esp)
   11f29:	e8 fc ff ff ff       	call   11f2a <rlc_retx+0x1a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11f2e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
   11f34:	8d 8b 9c 01 00 00    	lea    0x19c(%ebx),%ecx
   11f3a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   11f3d:	39 c1                	cmp    %eax,%ecx
   11f3f:	74 5a                	je     11f9b <rlc_retx+0x8b>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11f41:	8b 38                	mov    (%eax),%edi
   11f43:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   11f49:	0f b7 8e 94 00 00 00 	movzwl 0x94(%esi),%ecx
   11f50:	0f b7 40 f8          	movzwl -0x8(%eax),%eax
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11f54:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   11f5a:	66 39 c8             	cmp    %cx,%ax
   11f5d:	0f 84 a2 02 00 00    	je     12205 <rlc_retx+0x2f5>
   11f63:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   11f66:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11f69:	eb 17                	jmp    11f82 <rlc_retx+0x72>
   11f6b:	90                   	nop
   11f6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11f70:	0f b7 87 94 00 00 00 	movzwl 0x94(%edi),%eax
   11f77:	66 39 c8             	cmp    %cx,%ax
   11f7a:	0f 84 b8 01 00 00    	je     12138 <rlc_retx+0x228>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11f80:	89 d7                	mov    %edx,%edi
   11f82:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
   11f88:	8d 87 9c 00 00 00    	lea    0x9c(%edi),%eax
   11f8e:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   11f94:	39 c3                	cmp    %eax,%ebx
   11f96:	75 d8                	jne    11f70 <rlc_retx+0x60>
   11f98:	8b 5d ec             	mov    -0x14(%ebp),%ebx
		}
		//nposBf = NULL;
	}

	//
	amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11f9b:	8b 06                	mov    (%esi),%eax
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11f9d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11fa0:	8b 40 50             	mov    0x50(%eax),%eax
   11fa3:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum--;
   11fa9:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11fb0:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   11fb6:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11fbc:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11fbf:	89 10                	mov    %edx,(%eax)
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
   11fc1:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11fc7:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11fce:	01 10 00 
	entry->prev = LIST_POISON2;
   11fd1:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11fd8:	02 20 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11fdb:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11fe1:	89 93 a0 01 00 00    	mov    %edx,0x1a0(%ebx)
	new->next = next;
   11fe7:	89 8e 9c 00 00 00    	mov    %ecx,0x9c(%esi)
	new->prev = prev;
   11fed:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   11ff3:	89 10                	mov    %edx,(%eax)
	if( amTxedBuffer->pktstatus != FULL_SDU )
   11ff5:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
   11ff9:	0f 84 e9 01 00 00    	je     121e8 <rlc_retx+0x2d8>
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   11fff:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12005:	8b 93 a4 01 00 00    	mov    0x1a4(%ebx),%edx
   1200b:	85 c0                	test   %eax,%eax
   1200d:	74 29                	je     12038 <rlc_retx+0x128>
   1200f:	31 c0                	xor    %eax,%eax
   12011:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			if( amTxedBuffer->segStart[i] != -1 )
   12018:	8b 4c 86 10          	mov    0x10(%esi,%eax,4),%ecx
   1201c:	83 f9 ff             	cmp    $0xffffffff,%ecx
   1201f:	74 0c                	je     1202d <rlc_retx+0x11d>
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
   12021:	29 ca                	sub    %ecx,%edx
   12023:	03 54 86 50          	add    0x50(%esi,%eax,4),%edx
   12027:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	amIns->amTransmittedBufferNum--;
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
	if( amTxedBuffer->pktstatus != FULL_SDU )
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   1202d:	83 c0 01             	add    $0x1,%eax
   12030:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   12036:	72 e0                	jb     12018 <rlc_retx+0x108>
			if( amTxedBuffer->segStart[i] != -1 )
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
			}
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
   12038:	03 56 0c             	add    0xc(%esi),%edx
   1203b:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
	}
	amIns->amRetxBufferNum++;
   12041:	83 83 a8 01 00 00 01 	addl   $0x1,0x1a8(%ebx)
	fsm_printf("[RLC][rlc_retx] has move to RetxBuffer,%d\n",amTxedBuffer->SN);
   12048:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   1204f:	c7 04 24 40 41 00 00 	movl   $0x4140,(%esp)
   12056:	89 44 24 04          	mov    %eax,0x4(%esp)
   1205a:	e8 fc ff ff ff       	call   1205b <rlc_retx+0x14b>
	//
	amTxedBf = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1205f:	b8 a4 00 00 00       	mov    $0xa4,%eax
   12064:	e8 fc ff ff ff       	call   12065 <rlc_retx+0x155>
   12069:	89 c7                	mov    %eax,%edi
	//amTxedBf->pkt = fsm_pkt_create(amTxedBuffer->pkt->len+fsm_skb_headroom(amTxedBuffer->pkt));
	amTxedBf->pkt = fsm_pkt_duplicate(amTxedBuffer->pkt);
   1206b:	8b 06                	mov    (%esi),%eax
   1206d:	e8 fc ff ff ff       	call   1206e <rlc_retx+0x15e>
   12072:	89 07                	mov    %eax,(%edi)
	//fsm_mem_cpy(amTxedBf->pkt->data,amTxedBuffer->pkt->data,amTxedBuffer->pkt->len);
	//fsm_skb_put(amTxedBf->pkt,amTxedBuffer->pkt->len);
	amTxedBf->datalen = amTxedBuffer->datalen;
   12074:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
   1207a:	89 87 98 00 00 00    	mov    %eax,0x98(%edi)
	amTxedBf->headLen = amTxedBuffer->headLen;
   12080:	8b 46 0c             	mov    0xc(%esi),%eax
   12083:	89 47 0c             	mov    %eax,0xc(%edi)
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
   12086:	8b 46 04             	mov    0x4(%esi),%eax
   12089:	89 47 04             	mov    %eax,0x4(%edi)
	amTxedBf->pos = amTxedBuffer->pos;
   1208c:	8b 46 08             	mov    0x8(%esi),%eax
   1208f:	89 47 08             	mov    %eax,0x8(%edi)
	amTxedBf->retxCount = amTxedBuffer->retxCount;
   12092:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   12099:	66 89 87 96 00 00 00 	mov    %ax,0x96(%edi)
	amTxedBf->segnum = amTxedBuffer->segnum;
   120a0:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   120a6:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
	for( i = 0;i < amTxedBuffer->segnum; i++)
   120ac:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   120b2:	85 c0                	test   %eax,%eax
   120b4:	74 1d                	je     120d3 <rlc_retx+0x1c3>
   120b6:	31 c0                	xor    %eax,%eax
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
   120b8:	8b 54 86 10          	mov    0x10(%esi,%eax,4),%edx
   120bc:	89 54 87 10          	mov    %edx,0x10(%edi,%eax,4)
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
   120c0:	8b 54 86 50          	mov    0x50(%esi,%eax,4),%edx
   120c4:	89 54 87 50          	mov    %edx,0x50(%edi,%eax,4)
	amTxedBf->headLen = amTxedBuffer->headLen;
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
	amTxedBf->pos = amTxedBuffer->pos;
	amTxedBf->retxCount = amTxedBuffer->retxCount;
	amTxedBf->segnum = amTxedBuffer->segnum;
	for( i = 0;i < amTxedBuffer->segnum; i++)
   120c8:	83 c0 01             	add    $0x1,%eax
   120cb:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   120d1:	72 e5                	jb     120b8 <rlc_retx+0x1a8>
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   120d3:	0f b7 86 94 00 00 00 	movzwl 0x94(%esi),%eax
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   120da:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   120e0:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	for( i = 0;i < amTxedBuffer->segnum; i++)
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   120e6:	66 89 87 94 00 00 00 	mov    %ax,0x94(%edi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   120ed:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   120f3:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   120f9:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   120ff:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   12105:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amTxedBf->pkt->len;
   12107:	8b 07                	mov    (%edi),%eax
   12109:	8b 40 50             	mov    0x50(%eax),%eax
   1210c:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum++;
   12112:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	fsm_printf("[RLC][rlc_retx] has copy to amTxedBuffer,%d\n",amTxedBuffer->SN);
   12119:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   12120:	c7 04 24 6c 41 00 00 	movl   $0x416c,(%esp)
   12127:	89 44 24 04          	mov    %eax,0x4(%esp)
   1212b:	e8 fc ff ff ff       	call   1212c <rlc_retx+0x21c>
	FOUT;
}
   12130:	83 c4 10             	add    $0x10,%esp
   12133:	5b                   	pop    %ebx
   12134:	5e                   	pop    %esi
   12135:	5f                   	pop    %edi
   12136:	5d                   	pop    %ebp
   12137:	c3                   	ret    
   12138:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
   1213b:	98                   	cwtl   
   1213c:	89 44 24 04          	mov    %eax,0x4(%esp)
   12140:	c7 04 24 0c 41 00 00 	movl   $0x410c,(%esp)
   12147:	e8 fc ff ff ff       	call   12148 <rlc_retx+0x238>
				if( amRetxBf->pktstatus != FULL_SDU )
   1214c:	83 7f 04 01          	cmpl   $0x1,0x4(%edi)
   12150:	0f 84 a2 00 00 00    	je     121f8 <rlc_retx+0x2e8>
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   12156:	8b 87 90 00 00 00    	mov    0x90(%edi),%eax
   1215c:	8b 8b a4 01 00 00    	mov    0x1a4(%ebx),%ecx
   12162:	85 c0                	test   %eax,%eax
   12164:	74 22                	je     12188 <rlc_retx+0x278>
   12166:	31 c0                	xor    %eax,%eax
					{
						if( amRetxBf->segStart[i] != -1 )
   12168:	8b 54 87 10          	mov    0x10(%edi,%eax,4),%edx
   1216c:	83 fa ff             	cmp    $0xffffffff,%edx
   1216f:	74 0c                	je     1217d <rlc_retx+0x26d>
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12171:	2b 54 87 50          	sub    0x50(%edi,%eax,4),%edx
   12175:	01 d1                	add    %edx,%ecx
   12177:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
				if( amRetxBf->pktstatus != FULL_SDU )
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   1217d:	83 c0 01             	add    $0x1,%eax
   12180:	3b 87 90 00 00 00    	cmp    0x90(%edi),%eax
   12186:	72 e0                	jb     12168 <rlc_retx+0x258>
						if( amRetxBf->segStart[i] != -1 )
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
						}
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   12188:	2b 4f 0c             	sub    0xc(%edi),%ecx
   1218b:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
				}
				amIns->amRetxBufferNum--;
   12191:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				if(amRetxBf->pkt != NULL)
   12198:	8b 07                	mov    (%edi),%eax
   1219a:	85 c0                	test   %eax,%eax
   1219c:	74 0b                	je     121a9 <rlc_retx+0x299>
				{
					fsm_pkt_destroy( amRetxBf->pkt );
   1219e:	e8 fc ff ff ff       	call   1219f <rlc_retx+0x28f>
					amRetxBf->pkt = NULL;
   121a3:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   121a9:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
				}
				list_del(&amRetxBf->list);
				if(amRetxBf != NULL)
   121af:	85 ff                	test   %edi,%edi
   121b1:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   121b7:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   121ba:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   121bc:	c7 87 9c 00 00 00 00 	movl   $0x100100,0x9c(%edi)
   121c3:	01 10 00 
	entry->prev = LIST_POISON2;
   121c6:	c7 87 a0 00 00 00 00 	movl   $0x200200,0xa0(%edi)
   121cd:	02 20 00 
   121d0:	0f 84 c5 fd ff ff    	je     11f9b <rlc_retx+0x8b>
				{
					fsm_mem_free(amRetxBf);
   121d6:	89 f8                	mov    %edi,%eax
   121d8:	e8 fc ff ff ff       	call   121d9 <rlc_retx+0x2c9>
   121dd:	e9 b9 fd ff ff       	jmp    11f9b <rlc_retx+0x8b>
   121e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
   121e8:	8b 06                	mov    (%esi),%eax
   121ea:	8b 40 50             	mov    0x50(%eax),%eax
   121ed:	01 83 a4 01 00 00    	add    %eax,0x1a4(%ebx)
   121f3:	e9 49 fe ff ff       	jmp    12041 <rlc_retx+0x131>
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   121f8:	8b 07                	mov    (%edi),%eax
   121fa:	8b 40 50             	mov    0x50(%eax),%eax
   121fd:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
   12203:	eb 8c                	jmp    12191 <rlc_retx+0x281>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12205:	89 d7                	mov    %edx,%edi
   12207:	e9 2f ff ff ff       	jmp    1213b <rlc_retx+0x22b>
   1220c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00012210 <so_handler>:
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12210:	55                   	push   %ebp
   12211:	89 e5                	mov    %esp,%ebp
   12213:	57                   	push   %edi
   12214:	56                   	push   %esi
   12215:	53                   	push   %ebx
   12216:	83 ec 20             	sub    $0x20,%esp
   12219:	e8 fc ff ff ff       	call   1221a <so_handler+0xa>
   1221e:	0f b7 75 08          	movzwl 0x8(%ebp),%esi
   12222:	89 45 e8             	mov    %eax,-0x18(%ebp)
   12225:	89 cf                	mov    %ecx,%edi
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12227:	89 c1                	mov    %eax,%ecx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12229:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
   1222f:	81 c1 f0 00 00 00    	add    $0xf0,%ecx
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12235:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12238:	39 c1                	cmp    %eax,%ecx
   1223a:	74 3d                	je     12279 <so_handler+0x69>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   1223c:	8b 18                	mov    (%eax),%ebx
   1223e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   12244:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
		{
			if( nackSn == amTxedBuffer->SN )
   1224a:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   1224e:	75 13                	jne    12263 <so_handler+0x53>
   12250:	eb 2f                	jmp    12281 <so_handler+0x71>
   12252:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12258:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   1225f:	74 27                	je     12288 <so_handler+0x78>
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12261:	89 d3                	mov    %edx,%ebx
   12263:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   12269:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1226f:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12275:	39 c1                	cmp    %eax,%ecx
   12277:	75 df                	jne    12258 <so_handler+0x48>
				break;
			}
		}
	}
	FOUT;
}
   12279:	83 c4 20             	add    $0x20,%esp
   1227c:	5b                   	pop    %ebx
   1227d:	5e                   	pop    %esi
   1227e:	5f                   	pop    %edi
   1227f:	5d                   	pop    %ebp
   12280:	c3                   	ret    
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12281:	89 d3                	mov    %edx,%ebx
   12283:	90                   	nop
   12284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			if( nackSn == amTxedBuffer->SN )
			{
				*isPduFound = true;
   12288:	c6 07 01             	movb   $0x1,(%edi)
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
   1228b:	0f bf c6             	movswl %si,%eax
   1228e:	89 44 24 04          	mov    %eax,0x4(%esp)
   12292:	c7 04 24 9c 41 00 00 	movl   $0x419c,(%esp)
   12299:	e8 fc ff ff ff       	call   1229a <so_handler+0x8a>
				for( i = 0; i < amTxedBuffer->segnum; i++ )
   1229e:	8b 8b 90 00 00 00    	mov    0x90(%ebx),%ecx
   122a4:	85 c9                	test   %ecx,%ecx
   122a6:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   122a9:	0f 84 d1 01 00 00    	je     12480 <so_handler+0x270>
   122af:	8b 55 ec             	mov    -0x14(%ebp),%edx
   122b2:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   122b6:	0f b6 7a 03          	movzbl 0x3(%edx),%edi
   122ba:	31 d2                	xor    %edx,%edx
   122bc:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
   122c0:	89 d6                	mov    %edx,%esi
   122c2:	d0 e8                	shr    %al
   122c4:	0f b6 c0             	movzbl %al,%eax
   122c7:	c1 e7 07             	shl    $0x7,%edi
   122ca:	09 c7                	or     %eax,%edi
   122cc:	31 c0                	xor    %eax,%eax
   122ce:	89 7d dc             	mov    %edi,-0x24(%ebp)
   122d1:	eb 0f                	jmp    122e2 <so_handler+0xd2>
   122d3:	90                   	nop
   122d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   122d8:	83 c0 01             	add    $0x1,%eax
   122db:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   122de:	89 c6                	mov    %eax,%esi
   122e0:	74 5e                	je     12340 <so_handler+0x130>
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
   122e2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   122e5:	39 4c 83 10          	cmp    %ecx,0x10(%ebx,%eax,4)
   122e9:	75 ed                	jne    122d8 <so_handler+0xc8>
   122eb:	8b 7d ec             	mov    -0x14(%ebp),%edi
   122ee:	0f b6 17             	movzbl (%edi),%edx
   122f1:	c0 ea 02             	shr    $0x2,%dl
   122f4:	0f b6 fa             	movzbl %dl,%edi
   122f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   122fa:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
   122fe:	0f b6 52 02          	movzbl 0x2(%edx),%edx
   12302:	c1 e1 06             	shl    $0x6,%ecx
   12305:	83 e2 01             	and    $0x1,%edx
   12308:	09 f9                	or     %edi,%ecx
   1230a:	c1 e2 0e             	shl    $0xe,%edx
   1230d:	09 ca                	or     %ecx,%edx
   1230f:	39 54 83 50          	cmp    %edx,0x50(%ebx,%eax,4)
   12313:	75 c3                	jne    122d8 <so_handler+0xc8>
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   12315:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12318:	89 f2                	mov    %esi,%edx
   1231a:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1231d:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12321:	c7 04 24 d4 41 00 00 	movl   $0x41d4,(%esp)
   12328:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   1232c:	e8 fc ff ff ff       	call   1232d <so_handler+0x11d>
   12331:	8b bb 90 00 00 00    	mov    0x90(%ebx),%edi
						break;
   12337:	8b 55 e0             	mov    -0x20(%ebp),%edx
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
				for( i = 0; i < amTxedBuffer->segnum; i++ )
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   1233a:	89 7d f0             	mov    %edi,-0x10(%ebp)
						break;
   1233d:	eb 07                	jmp    12346 <so_handler+0x136>
   1233f:	90                   	nop
   12340:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12344:	89 c2                	mov    %eax,%edx
					}
				}
				if( i == amTxedBuffer->segnum )
   12346:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   12349:	0f 84 31 01 00 00    	je     12480 <so_handler+0x270>
					amTxedBuffer->segnum++;
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   1234f:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
   12356:	66 83 f8 ff          	cmp    $0xffff,%ax
   1235a:	0f 84 10 01 00 00    	je     12470 <so_handler+0x260>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   12360:	83 c0 01             	add    $0x1,%eax
   12363:	66 89 83 96 00 00 00 	mov    %ax,0x96(%ebx)
   1236a:	98                   	cwtl   
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   1236b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1236e:	0f b7 91 fa 22 00 00 	movzwl 0x22fa(%ecx),%edx
   12375:	39 c2                	cmp    %eax,%edx
   12377:	74 1f                	je     12398 <so_handler+0x188>
						}
					}
				}
				else
				{
					rlc_retx(amIns,amTxedBuffer);
   12379:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1237c:	89 da                	mov    %ebx,%edx
   1237e:	e8 fc ff ff ff       	call   1237f <so_handler+0x16f>
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   12383:	c7 04 24 e8 3f 00 00 	movl   $0x3fe8,(%esp)
   1238a:	e8 fc ff ff ff       	call   1238b <so_handler+0x17b>
				break;
			}
		}
	}
	FOUT;
}
   1238f:	83 c4 20             	add    $0x20,%esp
   12392:	5b                   	pop    %ebx
   12393:	5e                   	pop    %esi
   12394:	5f                   	pop    %edi
   12395:	5d                   	pop    %ebp
   12396:	c3                   	ret    
   12397:	90                   	nop
					amTxedBuffer->retxCount++;
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
   12398:	c7 04 24 34 42 00 00 	movl   $0x4234,(%esp)
   1239f:	e8 fc ff ff ff       	call   123a0 <so_handler+0x190>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   123a4:	b8 04 00 00 00       	mov    $0x4,%eax
   123a9:	e8 fc ff ff ff       	call   123aa <so_handler+0x19a>
					mioctrl->eventCode = 0;
					mioctrl->rbIdentity = amIns->rbId;
   123ae:	8b 7d e8             	mov    -0x18(%ebp),%edi
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
					mioctrl->eventCode = 0;
   123b1:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   123b6:	0f b6 57 02          	movzbl 0x2(%edi),%edx
   123ba:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   123bd:	e8 fc ff ff ff       	call   123be <so_handler+0x1ae>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   123c2:	8b 03                	mov    (%ebx),%eax
   123c4:	8b 40 50             	mov    0x50(%eax),%eax
   123c7:	29 87 f8 00 00 00    	sub    %eax,0xf8(%edi)
					amIns->amTransmittedBufferNum--;
   123cd:	83 af fc 00 00 00 01 	subl   $0x1,0xfc(%edi)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   123d4:	8b 03                	mov    (%ebx),%eax
   123d6:	e8 fc ff ff ff       	call   123d7 <so_handler+0x1c7>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   123db:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   123e1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
					amTxedBuffer->pkt = NULL;
   123e7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   123ed:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   123f0:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   123f2:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   123f4:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   123fb:	01 10 00 
	entry->prev = LIST_POISON2;
   123fe:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   12405:	02 20 00 
   12408:	e8 fc ff ff ff       	call   12409 <so_handler+0x1f9>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   1240d:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12413:	89 fa                	mov    %edi,%edx
   12415:	81 c2 9c 01 00 00    	add    $0x19c,%edx
   1241b:	39 c2                	cmp    %eax,%edx
   1241d:	0f 84 56 fe ff ff    	je     12279 <so_handler+0x69>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12423:	8b 18                	mov    (%eax),%ebx
   12425:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1242b:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
						{
							if( amRetxBf->SN == nackSn)
   12431:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   12435:	75 18                	jne    1244f <so_handler+0x23f>
   12437:	e9 b6 00 00 00       	jmp    124f2 <so_handler+0x2e2>
   1243c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12440:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   12447:	0f 84 a7 00 00 00    	je     124f4 <so_handler+0x2e4>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   1244d:	89 cb                	mov    %ecx,%ebx
   1244f:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   12455:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1245b:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   12461:	39 c2                	cmp    %eax,%edx
   12463:	75 db                	jne    12440 <so_handler+0x230>
   12465:	e9 0f fe ff ff       	jmp    12279 <so_handler+0x69>
   1246a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   12470:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   12477:	00 00 
   12479:	31 c0                	xor    %eax,%eax
   1247b:	e9 eb fe ff ff       	jmp    1236b <so_handler+0x15b>
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12480:	8b 45 ec             	mov    -0x14(%ebp),%eax
					if(part3->SOend  == 0x7fff ) //
   12483:	8b 4d ec             	mov    -0x14(%ebp),%ecx
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12486:	0f b6 50 02          	movzbl 0x2(%eax),%edx
   1248a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1248e:	d0 ea                	shr    %dl
   12490:	0f b6 d2             	movzbl %dl,%edx
   12493:	c1 e0 07             	shl    $0x7,%eax
   12496:	09 d0                	or     %edx,%eax
   12498:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1249b:	89 44 93 10          	mov    %eax,0x10(%ebx,%edx,4)
					if(part3->SOend  == 0x7fff ) //
   1249f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   124a2:	0f b6 02             	movzbl (%edx),%eax
   124a5:	0f b6 52 01          	movzbl 0x1(%edx),%edx
   124a9:	c0 e8 02             	shr    $0x2,%al
   124ac:	0f b6 c0             	movzbl %al,%eax
   124af:	c1 e2 06             	shl    $0x6,%edx
   124b2:	09 c2                	or     %eax,%edx
   124b4:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   124b8:	83 e0 01             	and    $0x1,%eax
   124bb:	c1 e0 0e             	shl    $0xe,%eax
   124be:	09 c2                	or     %eax,%edx
   124c0:	66 81 fa ff 7f       	cmp    $0x7fff,%dx
   124c5:	0f 84 c1 00 00 00    	je     1258c <so_handler+0x37c>
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
					}
					else
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = part3->SOend;
   124cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124ce:	0f b7 d2             	movzwl %dx,%edx
   124d1:	89 54 83 50          	mov    %edx,0x50(%ebx,%eax,4)
					}
					amTxedBuffer->segnum++;
   124d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124d8:	83 c0 01             	add    $0x1,%eax
   124db:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
   124e1:	c7 04 24 0c 42 00 00 	movl   $0x420c,(%esp)
   124e8:	e8 fc ff ff ff       	call   124e9 <so_handler+0x2d9>
   124ed:	e9 5d fe ff ff       	jmp    1234f <so_handler+0x13f>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   124f2:	89 cb                	mov    %ecx,%ebx
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   124f4:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
   124f8:	0f 84 9f 00 00 00    	je     1259d <so_handler+0x38d>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   124fe:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
   12504:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12507:	85 d2                	test   %edx,%edx
   12509:	8b 88 a4 01 00 00    	mov    0x1a4(%eax),%ecx
   1250f:	74 27                	je     12538 <so_handler+0x328>
   12511:	8b 75 e8             	mov    -0x18(%ebp),%esi
   12514:	31 c0                	xor    %eax,%eax
   12516:	66 90                	xchg   %ax,%ax
									{
										if( amRetxBf->segStart[i] != -1 )
   12518:	8b 54 83 10          	mov    0x10(%ebx,%eax,4),%edx
   1251c:	83 fa ff             	cmp    $0xffffffff,%edx
   1251f:	74 0c                	je     1252d <so_handler+0x31d>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12521:	2b 54 83 50          	sub    0x50(%ebx,%eax,4),%edx
   12525:	01 d1                	add    %edx,%ecx
   12527:	89 8e a4 01 00 00    	mov    %ecx,0x1a4(%esi)
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   1252d:	83 c0 01             	add    $0x1,%eax
   12530:	3b 83 90 00 00 00    	cmp    0x90(%ebx),%eax
   12536:	72 e0                	jb     12518 <so_handler+0x308>
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12538:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1253b:	2b 4b 0c             	sub    0xc(%ebx),%ecx
   1253e:	89 88 a4 01 00 00    	mov    %ecx,0x1a4(%eax)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12544:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12547:	83 a8 a8 01 00 00 01 	subl   $0x1,0x1a8(%eax)
								fsm_pkt_destroy( amRetxBf->pkt );
   1254e:	8b 03                	mov    (%ebx),%eax
   12550:	e8 fc ff ff ff       	call   12551 <so_handler+0x341>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12555:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   1255b:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
								amRetxBf->pkt = NULL;
   12561:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12567:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1256a:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   1256c:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1256e:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12575:	01 10 00 
	entry->prev = LIST_POISON2;
   12578:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   1257f:	02 20 00 
   12582:	e8 fc ff ff ff       	call   12583 <so_handler+0x373>
								amRetxBf= NULL;
								break;
   12587:	e9 ed fc ff ff       	jmp    12279 <so_handler+0x69>
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
					if(part3->SOend  == 0x7fff ) //
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
   1258c:	8b 03                	mov    (%ebx),%eax
   1258e:	8b 7d f0             	mov    -0x10(%ebp),%edi
   12591:	8b 40 50             	mov    0x50(%eax),%eax
   12594:	89 44 bb 50          	mov    %eax,0x50(%ebx,%edi,4)
   12598:	e9 38 ff ff ff       	jmp    124d5 <so_handler+0x2c5>
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   1259d:	8b 03                	mov    (%ebx),%eax
   1259f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   125a2:	8b 40 50             	mov    0x50(%eax),%eax
   125a5:	29 82 a4 01 00 00    	sub    %eax,0x1a4(%edx)
   125ab:	eb 97                	jmp    12544 <so_handler+0x334>
   125ad:	8d 76 00             	lea    0x0(%esi),%esi

000125b0 <rlc_poll>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   125b0:	55                   	push   %ebp
   125b1:	89 e5                	mov    %esp,%ebp
   125b3:	56                   	push   %esi
   125b4:	53                   	push   %ebx
   125b5:	83 ec 04             	sub    $0x4,%esp
   125b8:	e8 fc ff ff ff       	call   125b9 <rlc_poll+0x9>
   125bd:	89 d6                	mov    %edx,%esi
   125bf:	89 c3                	mov    %eax,%ebx
	//u16 amHdr = 0x0000; //AM PDU
	RLC_AMPDU_fixhead * amHdr;

	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
   125c1:	c7 04 24 70 42 00 00 	movl   $0x4270,(%esp)
   125c8:	e8 fc ff ff ff       	call   125c9 <rlc_poll+0x19>
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
   125cd:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	*(u16*)amHdr=htons(*(u16*)amHdr);
   125d3:	0f b7 02             	movzwl (%edx),%eax
   125d6:	66 c1 c0 08          	rol    $0x8,%ax
	if(amHdr->P!=1)
   125da:	89 c1                	mov    %eax,%ecx
	{
		amHdr->P = 1;
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   125dc:	0f b7 f0             	movzwl %ax,%esi
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
	if(amHdr->P!=1)
   125df:	66 c1 e9 08          	shr    $0x8,%cx
   125e3:	f6 c1 20             	test   $0x20,%cl
	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
   125e6:	66 89 02             	mov    %ax,(%edx)
	if(amHdr->P!=1)
   125e9:	75 0c                	jne    125f7 <rlc_poll+0x47>
	{
		amHdr->P = 1;
   125eb:	83 c9 20             	or     $0x20,%ecx
   125ee:	88 4a 01             	mov    %cl,0x1(%edx)
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   125f1:	0f b7 02             	movzwl (%edx),%eax
   125f4:	0f b7 f0             	movzwl %ax,%esi
   125f7:	66 c1 e8 08          	shr    $0x8,%ax
   125fb:	c1 e6 08             	shl    $0x8,%esi
   125fe:	09 f0                	or     %esi,%eax
   12600:	66 89 02             	mov    %ax,(%edx)
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
	amIns->byteWithoutPoll = 0;
	amIns->pollSn = amIns->vt_s - 1;
   12603:	0f b7 83 64 12 00 00 	movzwl 0x1264(%ebx),%eax
	/*if( (amHdr&0x2000)>>13 == 0 )
	{
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
   1260a:	66 c7 83 fc 22 00 00 	movw   $0x0,0x22fc(%ebx)
   12611:	00 00 
	amIns->byteWithoutPoll = 0;
   12613:	66 c7 83 fe 22 00 00 	movw   $0x0,0x22fe(%ebx)
   1261a:	00 00 
	amIns->pollSn = amIns->vt_s - 1;
   1261c:	83 e8 01             	sub    $0x1,%eax
   1261f:	66 89 83 00 23 00 00 	mov    %ax,0x2300(%ebx)
	if(amIns->pollRetxTimer)
   12626:	8b 43 08             	mov    0x8(%ebx),%eax
   12629:	85 c0                	test   %eax,%eax
   1262b:	74 0c                	je     12639 <rlc_poll+0x89>
	{
		fsm_schedule_cancel(amIns->pollRetxTimer);
   1262d:	e8 fc ff ff ff       	call   1262e <rlc_poll+0x7e>
		amIns->pollRetxTimer = 0;
   12632:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	}
	amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
   12639:	8b 53 0c             	mov    0xc(%ebx),%edx
   1263c:	8b 43 10             	mov    0x10(%ebx),%eax
   1263f:	e8 fc ff ff ff       	call   12640 <rlc_poll+0x90>
   12644:	89 43 08             	mov    %eax,0x8(%ebx)
	fsm_printf("[RLC][rlc_poll] pollretxTimer start\n");
   12647:	c7 04 24 94 42 00 00 	movl   $0x4294,(%esp)
   1264e:	e8 fc ff ff ff       	call   1264f <rlc_poll+0x9f>
	FOUT;
}
   12653:	83 c4 04             	add    $0x4,%esp
   12656:	5b                   	pop    %ebx
   12657:	5e                   	pop    %esi
   12658:	5d                   	pop    %ebp
   12659:	c3                   	ret    
   1265a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00012660 <rlc_poll_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll_retx(struct AM_Instance *amIns)
{
   12660:	55                   	push   %ebp
   12661:	89 e5                	mov    %esp,%ebp
   12663:	57                   	push   %edi
   12664:	56                   	push   %esi
   12665:	53                   	push   %ebx
   12666:	83 ec 24             	sub    $0x24,%esp
   12669:	e8 fc ff ff ff       	call   1266a <rlc_poll_retx+0xa>
   1266e:	89 c6                	mov    %eax,%esi
	struct AmBuffer *amRetxBf;  //PDU
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	FIN(rlc_poll_retx());
	fsm_printf("[RLC][rlc_poll_retx] entering rlc_poll_retx() function\n");
   12670:	c7 04 24 bc 42 00 00 	movl   $0x42bc,(%esp)
   12677:	e8 fc ff ff ff       	call   12678 <rlc_poll_retx+0x18>
	//
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   1267c:	8d 8e f0 00 00 00    	lea    0xf0(%esi),%ecx
   12682:	3b 8e f0 00 00 00    	cmp    0xf0(%esi),%ecx
   12688:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1268b:	0f 84 a5 02 00 00    	je     12936 <rlc_poll_retx+0x2d6>
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");
   12691:	c7 04 24 f4 42 00 00 	movl   $0x42f4,(%esp)
   12698:	e8 fc ff ff ff       	call   12699 <rlc_poll_retx+0x39>

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1269d:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
   126a3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   126a6:	8b 38                	mov    (%eax),%edi
   126a8:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
   126ae:	0f 84 94 02 00 00    	je     12948 <rlc_poll_retx+0x2e8>
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   126b4:	8d 8e 9c 01 00 00    	lea    0x19c(%esi),%ecx
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   126ba:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   126c0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   126c3:	eb 21                	jmp    126e6 <rlc_poll_retx+0x86>
   126c5:	8d 76 00             	lea    0x0(%esi),%esi
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   126c8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
   126ce:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   126d4:	2d 9c 00 00 00       	sub    $0x9c,%eax
   126d9:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   126dc:	0f 84 66 02 00 00    	je     12948 <rlc_poll_retx+0x2e8>
   126e2:	89 fb                	mov    %edi,%ebx
   126e4:	89 c7                	mov    %eax,%edi
		{
			//amTxedBuffer = list_entry(pos,struct AmBuffer,list);
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
   126e6:	0f bf 96 64 12 00 00 	movswl 0x1264(%esi),%edx
   126ed:	0f bf 83 94 00 00 00 	movswl 0x94(%ebx),%eax
   126f4:	83 ea 01             	sub    $0x1,%edx
   126f7:	39 d0                	cmp    %edx,%eax
   126f9:	75 cd                	jne    126c8 <rlc_poll_retx+0x68>
			{
				if( amTxedBuffer->retxCount == -1 )
   126fb:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
   12702:	66 83 fa ff          	cmp    $0xffff,%dx
   12706:	0f 84 1c 02 00 00    	je     12928 <rlc_poll_retx+0x2c8>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   1270c:	83 c2 01             	add    $0x1,%edx
   1270f:	66 89 93 96 00 00 00 	mov    %dx,0x96(%ebx)
				}
				fsm_printf("[RLC][rlc_poll_retx] the pdu of rlc_poll_retx's SN is %d\n",amTxedBuffer->SN);
   12716:	89 44 24 04          	mov    %eax,0x4(%esp)
   1271a:	c7 04 24 3c 43 00 00 	movl   $0x433c,(%esp)
   12721:	e8 fc ff ff ff       	call   12722 <rlc_poll_retx+0xc2>
				fsm_printf("[RLC][rlc_poll_retx] the retxCount is %d, the maxThreshold is %d\n",amTxedBuffer->retxCount,amIns->maxRetxThreshold);
   12726:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   1272d:	89 44 24 08          	mov    %eax,0x8(%esp)
   12731:	0f bf 83 96 00 00 00 	movswl 0x96(%ebx),%eax
   12738:	c7 04 24 78 43 00 00 	movl   $0x4378,(%esp)
   1273f:	89 44 24 04          	mov    %eax,0x4(%esp)
   12743:	e8 fc ff ff ff       	call   12744 <rlc_poll_retx+0xe4>
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   12748:	0f bf 93 96 00 00 00 	movswl 0x96(%ebx),%edx
   1274f:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   12756:	39 c2                	cmp    %eax,%edx
   12758:	0f 85 02 02 00 00    	jne    12960 <rlc_poll_retx+0x300>
				{
					fsm_printf("[RLC][rlc_poll_retx] has reach the maxRetxThreshold\n");
   1275e:	c7 04 24 bc 43 00 00 	movl   $0x43bc,(%esp)
   12765:	e8 fc ff ff ff       	call   12766 <rlc_poll_retx+0x106>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   1276a:	b8 04 00 00 00       	mov    $0x4,%eax
   1276f:	e8 fc ff ff ff       	call   12770 <rlc_poll_retx+0x110>
					mioctrl->eventCode = 0;
   12774:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12779:	0f b6 56 02          	movzbl 0x2(%esi),%edx
   1277d:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   12780:	e8 fc ff ff ff       	call   12781 <rlc_poll_retx+0x121>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12785:	8b 96 9c 01 00 00    	mov    0x19c(%esi),%edx
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   1278b:	39 55 e8             	cmp    %edx,-0x18(%ebp)
   1278e:	74 6b                	je     127fb <rlc_poll_retx+0x19b>
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12790:	8d 82 64 ff ff ff    	lea    -0x9c(%edx),%eax
   12796:	8b 0a                	mov    (%edx),%ecx
   12798:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   1279b:	0f b7 83 94 00 00 00 	movzwl 0x94(%ebx),%eax
   127a2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   127a6:	8d 81 64 ff ff ff    	lea    -0x9c(%ecx),%eax
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   127ac:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
   127b0:	66 39 4a f8          	cmp    %cx,-0x8(%edx)
   127b4:	0f 84 cc 01 00 00    	je     12986 <rlc_poll_retx+0x326>
   127ba:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
   127bd:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   127c0:	89 7d e0             	mov    %edi,-0x20(%ebp)
   127c3:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
   127c7:	eb 16                	jmp    127df <rlc_poll_retx+0x17f>
   127c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   127d0:	66 39 b8 94 00 00 00 	cmp    %di,0x94(%eax)
   127d7:	0f 84 93 00 00 00    	je     12870 <rlc_poll_retx+0x210>
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   127dd:	89 c8                	mov    %ecx,%eax
   127df:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   127e5:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   127eb:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   127f1:	39 d3                	cmp    %edx,%ebx
   127f3:	75 db                	jne    127d0 <rlc_poll_retx+0x170>
   127f5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   127f8:	8b 7d e0             	mov    -0x20(%ebp),%edi
					//nposBf = NULL;
					}

					//PDU
					//pos = pos->next;
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   127fb:	8b 03                	mov    (%ebx),%eax
   127fd:	8b 40 50             	mov    0x50(%eax),%eax
   12800:	29 86 f8 00 00 00    	sub    %eax,0xf8(%esi)
					amIns->amTransmittedBufferNum--;
   12806:	83 ae fc 00 00 00 01 	subl   $0x1,0xfc(%esi)
					if(amTxedBuffer->pkt != NULL)
   1280d:	8b 03                	mov    (%ebx),%eax
   1280f:	85 c0                	test   %eax,%eax
   12811:	74 0b                	je     1281e <rlc_poll_retx+0x1be>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   12813:	e8 fc ff ff ff       	call   12814 <rlc_poll_retx+0x1b4>
						amTxedBuffer->pkt = NULL;
   12818:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   1281e:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   12824:	85 db                	test   %ebx,%ebx
   12826:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1282c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1282f:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12831:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12838:	01 10 00 
	entry->prev = LIST_POISON2;
   1283b:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   12842:	02 20 00 
   12845:	74 07                	je     1284e <rlc_poll_retx+0x1ee>
					{
						fsm_mem_free(amTxedBuffer);
   12847:	89 d8                	mov    %ebx,%eax
   12849:	e8 fc ff ff ff       	call   1284a <rlc_poll_retx+0x1ea>
						amTxedBuffer = NULL;
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
   1284e:	8b 86 a4 01 00 00    	mov    0x1a4(%esi),%eax
   12854:	c7 04 24 f4 43 00 00 	movl   $0x43f4,(%esp)
   1285b:	89 44 24 04          	mov    %eax,0x4(%esp)
   1285f:	e8 fc ff ff ff       	call   12860 <rlc_poll_retx+0x200>
   12864:	e9 5f fe ff ff       	jmp    126c8 <rlc_poll_retx+0x68>
   12869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   12870:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   12873:	89 c2                	mov    %eax,%edx
   12875:	8b 7d e0             	mov    -0x20(%ebp),%edi
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   12878:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
   1287c:	0f 84 ce 00 00 00    	je     12950 <rlc_poll_retx+0x2f0>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12882:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
   12888:	85 c9                	test   %ecx,%ecx
   1288a:	8b 8e a4 01 00 00    	mov    0x1a4(%esi),%ecx
   12890:	74 33                	je     128c5 <rlc_poll_retx+0x265>
   12892:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12895:	31 c0                	xor    %eax,%eax
   12897:	89 cb                	mov    %ecx,%ebx
   12899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
									{
										if( amRetxBf->segStart[i] != -1 )
   128a0:	8b 4c 82 10          	mov    0x10(%edx,%eax,4),%ecx
   128a4:	83 f9 ff             	cmp    $0xffffffff,%ecx
   128a7:	74 0c                	je     128b5 <rlc_poll_retx+0x255>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   128a9:	2b 4c 82 50          	sub    0x50(%edx,%eax,4),%ecx
   128ad:	01 cb                	add    %ecx,%ebx
   128af:	89 9e a4 01 00 00    	mov    %ebx,0x1a4(%esi)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   128b5:	83 c0 01             	add    $0x1,%eax
   128b8:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
   128be:	72 e0                	jb     128a0 <rlc_poll_retx+0x240>
   128c0:	89 d9                	mov    %ebx,%ecx
   128c2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   128c5:	89 c8                	mov    %ecx,%eax
   128c7:	2b 42 0c             	sub    0xc(%edx),%eax
   128ca:	89 86 a4 01 00 00    	mov    %eax,0x1a4(%esi)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   128d0:	83 ae a8 01 00 00 01 	subl   $0x1,0x1a8(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   128d7:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   128dd:	8b 8a 9c 00 00 00    	mov    0x9c(%edx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   128e3:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
   128e6:	89 08                	mov    %ecx,(%eax)
								list_del(&amRetxBf->list);
								if(amRetxBf->pkt != NULL)
   128e8:	8b 02                	mov    (%edx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   128ea:	c7 82 9c 00 00 00 00 	movl   $0x100100,0x9c(%edx)
   128f1:	01 10 00 
	entry->prev = LIST_POISON2;
   128f4:	c7 82 a0 00 00 00 00 	movl   $0x200200,0xa0(%edx)
   128fb:	02 20 00 
   128fe:	85 c0                	test   %eax,%eax
   12900:	74 11                	je     12913 <rlc_poll_retx+0x2b3>
								{
									fsm_pkt_destroy( amRetxBf->pkt );
   12902:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12905:	e8 fc ff ff ff       	call   12906 <rlc_poll_retx+0x2a6>
									amRetxBf->pkt = NULL;
   1290a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1290d:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
								}
								if(amRetxBf != NULL)
   12913:	85 d2                	test   %edx,%edx
   12915:	0f 84 e0 fe ff ff    	je     127fb <rlc_poll_retx+0x19b>
								{
									fsm_mem_free(amRetxBf);
   1291b:	89 d0                	mov    %edx,%eax
   1291d:	e8 fc ff ff ff       	call   1291e <rlc_poll_retx+0x2be>
   12922:	e9 d4 fe ff ff       	jmp    127fb <rlc_poll_retx+0x19b>
   12927:	90                   	nop
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
			{
				if( amTxedBuffer->retxCount == -1 )
				{
					amTxedBuffer->retxCount = 0;
   12928:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   1292f:	00 00 
   12931:	e9 e0 fd ff ff       	jmp    12716 <rlc_poll_retx+0xb6>
			}
		}
	}
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
   12936:	c7 04 24 70 44 00 00 	movl   $0x4470,(%esp)
   1293d:	e8 fc ff ff ff       	call   1293e <rlc_poll_retx+0x2de>
   12942:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	FOUT;
}
   12948:	83 c4 24             	add    $0x24,%esp
   1294b:	5b                   	pop    %ebx
   1294c:	5e                   	pop    %esi
   1294d:	5f                   	pop    %edi
   1294e:	5d                   	pop    %ebp
   1294f:	c3                   	ret    
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   12950:	8b 02                	mov    (%edx),%eax
   12952:	8b 40 50             	mov    0x50(%eax),%eax
   12955:	29 86 a4 01 00 00    	sub    %eax,0x1a4(%esi)
   1295b:	e9 70 ff ff ff       	jmp    128d0 <rlc_poll_retx+0x270>
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
				}
				else
				{
					fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx pdu has not reach maxRetxThreshold\n");
   12960:	c7 04 24 28 44 00 00 	movl   $0x4428,(%esp)
   12967:	e8 fc ff ff ff       	call   12968 <rlc_poll_retx+0x308>
					rlc_poll(amIns,amTxedBuffer->pkt);	//
   1296c:	8b 13                	mov    (%ebx),%edx
   1296e:	89 f0                	mov    %esi,%eax
   12970:	e8 fc ff ff ff       	call   12971 <rlc_poll_retx+0x311>
					rlc_retx(amIns,amTxedBuffer);
   12975:	89 da                	mov    %ebx,%edx
   12977:	89 f0                	mov    %esi,%eax
   12979:	e8 fc ff ff ff       	call   1297a <rlc_poll_retx+0x31a>
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
	}
	FOUT;
}
   1297e:	83 c4 24             	add    $0x24,%esp
   12981:	5b                   	pop    %ebx
   12982:	5e                   	pop    %esi
   12983:	5f                   	pop    %edi
   12984:	5d                   	pop    %ebp
   12985:	c3                   	ret    
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12986:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12989:	e9 ea fe ff ff       	jmp    12878 <rlc_poll_retx+0x218>
	...
