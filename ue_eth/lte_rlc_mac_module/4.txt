
lte_rlc_mac_module.o:     file format elf32-i386


Disassembly of section .text:

00000000 <__fsm_skb_netrx>:
{
	fsm_pkt_destroy(pkptr);
}

static void __fsm_skb_netrx(unsigned long data)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	56                   	push   %esi
       4:	53                   	push   %ebx
       5:	e8 fc ff ff ff       	call   6 <__fsm_skb_netrx+0x6>
       a:	eb 1e                	jmp    2a <__fsm_skb_netrx+0x2a>
       c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.rx_queue);
      10:	e8 fc ff ff ff       	call   11 <__fsm_skb_netrx+0x11>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
      15:	89 f2                	mov    %esi,%edx
      17:	89 c3                	mov    %eax,%ebx
      19:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      1e:	e8 fc ff ff ff       	call   1f <__fsm_skb_netrx+0x1f>
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		NETIF_RX(pkptr);
      23:	89 d8                	mov    %ebx,%eax
      25:	e8 fc ff ff ff       	call   26 <__fsm_skb_netrx+0x26>
	unsigned long flags;


	while(1)
	{
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
      2a:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      2f:	e8 fc ff ff ff       	call   30 <__fsm_skb_netrx+0x30>
      34:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.rx_queue))
      36:	a1 bc 02 00 00       	mov    0x2bc,%eax
      3b:	3b 00                	cmp    (%eax),%eax
      3d:	75 d1                	jne    10 <__fsm_skb_netrx+0x10>
      3f:	89 f2                	mov    %esi,%edx
      41:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      46:	e8 fc ff ff ff       	call   47 <__fsm_skb_netrx+0x47>
		NETIF_RX(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_netrx() packet receive\n");
	return;
}
      4b:	5b                   	pop    %ebx
      4c:	5e                   	pop    %esi
      4d:	5d                   	pop    %ebp
      4e:	c3                   	ret    
      4f:	90                   	nop

00000050 <__fsm_skb_xmit>:

static void __fsm_skb_xmit(unsigned long data)
{
      50:	55                   	push   %ebp
      51:	89 e5                	mov    %esp,%ebp
      53:	56                   	push   %esi
      54:	53                   	push   %ebx
      55:	e8 fc ff ff ff       	call   56 <__fsm_skb_xmit+0x6>
      5a:	eb 1e                	jmp    7a <__fsm_skb_xmit+0x2a>
      5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.tx_queue);
      60:	e8 fc ff ff ff       	call   61 <__fsm_skb_xmit+0x11>
      65:	89 f2                	mov    %esi,%edx
      67:	89 c3                	mov    %eax,%ebx
      69:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      6e:	e8 fc ff ff ff       	call   6f <__fsm_skb_xmit+0x1f>
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
//		fsm_octets_print(pkptr->data, pkptr->len);
		DEV_QUEUE_XMIT(pkptr);
      73:	89 d8                	mov    %ebx,%eax
      75:	e8 fc ff ff ff       	call   76 <__fsm_skb_xmit+0x26>
{
	FSM_PKT* pkptr;
	unsigned long flags;
	while(1)
	{
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
      7a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      7f:	e8 fc ff ff ff       	call   80 <__fsm_skb_xmit+0x30>
      84:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.tx_queue))
      86:	a1 b8 02 00 00       	mov    0x2b8,%eax
      8b:	3b 00                	cmp    (%eax),%eax
      8d:	75 d1                	jne    60 <__fsm_skb_xmit+0x10>
      8f:	89 f2                	mov    %esi,%edx
      91:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      96:	e8 fc ff ff ff       	call   97 <__fsm_skb_xmit+0x47>
		DEV_QUEUE_XMIT(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}
      9b:	5b                   	pop    %ebx
      9c:	5e                   	pop    %esi
      9d:	5d                   	pop    %ebp
      9e:	c3                   	ret    
      9f:	90                   	nop

000000a0 <__fsm_do_ioctl>:
	}
}


static void __fsm_do_ioctl(unsigned long data)
{
      a0:	55                   	push   %ebp
      a1:	89 e5                	mov    %esp,%ebp
      a3:	57                   	push   %edi
      a4:	56                   	push   %esi
      a5:	53                   	push   %ebx
      a6:	e8 fc ff ff ff       	call   a7 <__fsm_do_ioctl+0x7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
      ab:	8b 35 d4 02 00 00    	mov    0x2d4,%esi
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
      b1:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
      b7:	74 60                	je     119 <__fsm_do_ioctl+0x79>
      b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		ev_ptr = list_first_entry(&fsm_core.do_ioctl_list, struct evioctl, list_node);
		ev_ptr->dev->netdev_ops->ndo_do_ioctl(ev_ptr->dev, (struct ifreq*)&ev_ptr->ifr, IOCKERNEL);
      c0:	8b 46 f0             	mov    -0x10(%esi),%eax
      c3:	8d 56 f4             	lea    -0xc(%esi),%edx
      c6:	b9 f0 89 00 00       	mov    $0x89f0,%ecx
      cb:	8d 7e f0             	lea    -0x10(%esi),%edi
      ce:	8b 98 34 01 00 00    	mov    0x134(%eax),%ebx
      d4:	ff 53 28             	call   *0x28(%ebx)
		spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
      d7:	b8 e4 02 00 00       	mov    $0x2e4,%eax
      dc:	e8 fc ff ff ff       	call   dd <__fsm_do_ioctl+0x3d>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
      e1:	8b 4e 04             	mov    0x4(%esi),%ecx
      e4:	8b 1e                	mov    (%esi),%ebx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
      e6:	89 4b 04             	mov    %ecx,0x4(%ebx)
      e9:	89 c2                	mov    %eax,%edx
      eb:	b8 e4 02 00 00       	mov    $0x2e4,%eax
	prev->next = next;
      f0:	89 19                	mov    %ebx,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
      f2:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
      f8:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
      ff:	e8 fc ff ff ff       	call   100 <__fsm_do_ioctl+0x60>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     104:	89 f8                	mov    %edi,%eax
     106:	e8 fc ff ff ff       	call   107 <__fsm_do_ioctl+0x67>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     10b:	8b 35 d4 02 00 00    	mov    0x2d4,%esi

static void __fsm_do_ioctl(unsigned long data)
{
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
     111:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
     117:	75 a7                	jne    c0 <__fsm_do_ioctl+0x20>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
     119:	5b                   	pop    %ebx
     11a:	5e                   	pop    %esi
     11b:	5f                   	pop    %edi
     11c:	5d                   	pop    %ebp
     11d:	c3                   	ret    
     11e:	66 90                	xchg   %ax,%ax

00000120 <__fsm_skb_send_null>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     120:	55                   	push   %ebp
     121:	89 e5                	mov    %esp,%ebp
     123:	e8 fc ff ff ff       	call   124 <__fsm_skb_send_null+0x4>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     128:	e8 fc ff ff ff       	call   129 <__fsm_skb_send_null+0x9>
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
	fsm_pkt_destroy(pkptr);
}
     12d:	5d                   	pop    %ebp
     12e:	c3                   	ret    
     12f:	90                   	nop

00000130 <__fsm_tm_restart>:
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
}

static void __fsm_tm_restart()
{
     130:	55                   	push   %ebp
     131:	89 e5                	mov    %esp,%ebp
     133:	83 ec 04             	sub    $0x4,%esp
     136:	e8 fc ff ff ff       	call   137 <__fsm_tm_restart+0x7>
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
     13b:	8b 15 88 02 00 00    	mov    0x288,%edx
     141:	85 d2                	test   %edx,%edx
     143:	74 7b                	je     1c0 <__fsm_tm_restart+0x90>
	{
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
     145:	a1 44 02 00 00       	mov    0x244,%eax
     14a:	85 c0                	test   %eax,%eax
     14c:	74 42                	je     190 <__fsm_tm_restart+0x60>
	{	
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
     14e:	83 f8 01             	cmp    $0x1,%eax
     151:	74 05                	je     158 <__fsm_tm_restart+0x28>
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     153:	c9                   	leave  
     154:	c3                   	ret    
     155:	8d 76 00             	lea    0x0(%esi),%esi
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
     158:	b8 48 02 00 00       	mov    $0x248,%eax
     15d:	e8 fc ff ff ff       	call   15e <__fsm_tm_restart+0x2e>
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     162:	a1 88 02 00 00       	mov    0x288,%eax
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
     167:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     16e:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     171:	8b 50 08             	mov    0x8(%eax),%edx
     174:	8b 48 0c             	mov    0xc(%eax),%ecx
     177:	b8 48 02 00 00       	mov    $0x248,%eax
     17c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     183:	e8 fc ff ff ff       	call   184 <__fsm_tm_restart+0x54>
	}
}
     188:	c9                   	leave  
     189:	c3                   	ret    
     18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
	{	
		pB->timer.function = __fsm_tm_expire;
     190:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     197:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     19a:	8b 4a 0c             	mov    0xc(%edx),%ecx
     19d:	b8 48 02 00 00       	mov    $0x248,%eax
     1a2:	8b 52 08             	mov    0x8(%edx),%edx
     1a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     1ac:	e8 fc ff ff ff       	call   1ad <__fsm_tm_restart+0x7d>
		pB->tm_state = FSM_TM_RUN;
     1b1:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     1b8:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1bb:	c9                   	leave  
     1bc:	c3                   	ret    
     1bd:	8d 76 00             	lea    0x0(%esi),%esi
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
	{
		pB->tm_state = FSM_TM_STOP;
     1c0:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     1c7:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1ca:	c9                   	leave  
     1cb:	c3                   	ret    
     1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000001d0 <__fsm_skb_pending_xmit>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1d0:	55                   	push   %ebp
     1d1:	89 e5                	mov    %esp,%ebp
     1d3:	83 ec 08             	sub    $0x8,%esp
     1d6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
     1d9:	89 75 fc             	mov    %esi,-0x4(%ebp)
     1dc:	e8 fc ff ff ff       	call   1dd <__fsm_skb_pending_xmit+0xd>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
     1e1:	66 89 48 66          	mov    %cx,0x66(%eax)
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1e5:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
     1e7:	89 50 14             	mov    %edx,0x14(%eax)
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1ea:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     1ef:	e8 fc ff ff ff       	call   1f0 <__fsm_skb_pending_xmit+0x20>
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f4:	89 da                	mov    %ebx,%edx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1f6:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f8:	a1 b8 02 00 00       	mov    0x2b8,%eax
     1fd:	e8 fc ff ff ff       	call   1fe <__fsm_skb_pending_xmit+0x2e>
     202:	89 f2                	mov    %esi,%edx
     204:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     209:	e8 fc ff ff ff       	call   20a <__fsm_skb_pending_xmit+0x3a>
	spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
	tasklet_schedule(fsm_core.tx_tsklt);
     20e:	a1 c0 02 00 00       	mov    0x2c0,%eax
 */
static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
{
	int oldbit;

	asm volatile(LOCK_PREFIX "bts %2,%1\n\t"
     213:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     219:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     21b:	85 d2                	test   %edx,%edx
     21d:	75 05                	jne    224 <__fsm_skb_pending_xmit+0x54>
		__tasklet_schedule(t);
     21f:	e8 fc ff ff ff       	call   220 <__fsm_skb_pending_xmit+0x50>
//	fsm_pkt_destroy(pkptr);
	return;
}
     224:	8b 5d f8             	mov    -0x8(%ebp),%ebx
     227:	8b 75 fc             	mov    -0x4(%ebp),%esi
     22a:	89 ec                	mov    %ebp,%esp
     22c:	5d                   	pop    %ebp
     22d:	c3                   	ret    
     22e:	66 90                	xchg   %ax,%ax

00000230 <__fsm_skb_pending_netrx>:
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     230:	55                   	push   %ebp
     231:	89 e5                	mov    %esp,%ebp
     233:	56                   	push   %esi
     234:	53                   	push   %ebx
     235:	e8 fc ff ff ff       	call   236 <__fsm_skb_pending_netrx+0x6>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
     23a:	66 83 f9 08          	cmp    $0x8,%cx
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     23e:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
     240:	66 89 48 66          	mov    %cx,0x66(%eax)
	skb->dev = dev;
     244:	89 50 14             	mov    %edx,0x14(%eax)
	if(skb->protocol == htons(ETH_P_IP))
     247:	75 0d                	jne    256 <__fsm_skb_pending_netrx+0x26>
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     249:	0f b6 40 64          	movzbl 0x64(%eax),%eax
     24d:	83 e0 f3             	and    $0xfffffff3,%eax
     250:	83 c8 04             	or     $0x4,%eax
     253:	88 43 64             	mov    %al,0x64(%ebx)
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     256:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     25b:	e8 fc ff ff ff       	call   25c <__fsm_skb_pending_netrx+0x2c>
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     260:	89 da                	mov    %ebx,%edx
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     262:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     264:	a1 bc 02 00 00       	mov    0x2bc,%eax
     269:	e8 fc ff ff ff       	call   26a <__fsm_skb_pending_netrx+0x3a>
     26e:	89 f2                	mov    %esi,%edx
     270:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     275:	e8 fc ff ff ff       	call   276 <__fsm_skb_pending_netrx+0x46>
	spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
	tasklet_schedule(fsm_core.rx_tsklt);
     27a:	a1 c4 02 00 00       	mov    0x2c4,%eax
     27f:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     285:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     287:	85 d2                	test   %edx,%edx
     289:	75 05                	jne    290 <__fsm_skb_pending_netrx+0x60>
		__tasklet_schedule(t);
     28b:	e8 fc ff ff ff       	call   28c <__fsm_skb_pending_netrx+0x5c>
//	fsm_pkt_destroy(pkptr);
	return;
}
     290:	5b                   	pop    %ebx
     291:	5e                   	pop    %esi
     292:	5d                   	pop    %ebp
     293:	c3                   	ret    
     294:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     29a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000002a0 <fsm_ev_type>:

/* ---------------------utilities for state machine-----------------------------*/

/* Return information of event.	*/
u32 fsm_ev_type()
{
     2a0:	55                   	push   %ebp
     2a1:	89 e5                	mov    %esp,%ebp
     2a3:	e8 fc ff ff ff       	call   2a4 <fsm_ev_type+0x4>
	return fsm_core.evtype;
}
     2a8:	a1 30 00 00 00       	mov    0x30,%eax
     2ad:	5d                   	pop    %ebp
     2ae:	c3                   	ret    
     2af:	90                   	nop

000002b0 <fsm_ev_code>:

u32 fsm_ev_code()
{
     2b0:	55                   	push   %ebp
     2b1:	89 e5                	mov    %esp,%ebp
     2b3:	e8 fc ff ff ff       	call   2b4 <fsm_ev_code+0x4>
	return fsm_core.code;
}
     2b8:	a1 34 00 00 00       	mov    0x34,%eax
     2bd:	5d                   	pop    %ebp
     2be:	c3                   	ret    
     2bf:	90                   	nop

000002c0 <fsm_ev_src>:

int fsm_ev_src()
{
     2c0:	55                   	push   %ebp
     2c1:	89 e5                	mov    %esp,%ebp
     2c3:	e8 fc ff ff ff       	call   2c4 <fsm_ev_src+0x4>
	return fsm_core.src;
}
     2c8:	a1 38 00 00 00       	mov    0x38,%eax
     2cd:	5d                   	pop    %ebp
     2ce:	c3                   	ret    
     2cf:	90                   	nop

000002d0 <fsm_ev_ioctrl_cmd>:

u32 fsm_ev_ioctrl_cmd()
{
     2d0:	55                   	push   %ebp
     2d1:	89 e5                	mov    %esp,%ebp
     2d3:	e8 fc ff ff ff       	call   2d4 <fsm_ev_ioctrl_cmd+0x4>
	return fsm_core.ioctrl_cmd;
}
     2d8:	a1 b0 02 00 00       	mov    0x2b0,%eax
     2dd:	5d                   	pop    %ebp
     2de:	c3                   	ret    
     2df:	90                   	nop

000002e0 <fsm_sv_ptr_get>:

/* FSM information get */
void* fsm_sv_ptr_get()
{
     2e0:	55                   	push   %ebp
     2e1:	89 e5                	mov    %esp,%ebp
     2e3:	e8 fc ff ff ff       	call   2e4 <fsm_sv_ptr_get+0x4>
	return fsm_core.fsm_sv_ptr;
}
     2e8:	a1 3c 00 00 00       	mov    0x3c,%eax
     2ed:	5d                   	pop    %ebp
     2ee:	c3                   	ret    
     2ef:	90                   	nop

000002f0 <fsm_current_state_ptr_get>:

int* fsm_current_state_ptr_get()
{
     2f0:	55                   	push   %ebp
     2f1:	89 e5                	mov    %esp,%ebp
     2f3:	e8 fc ff ff ff       	call   2f4 <fsm_current_state_ptr_get+0x4>
	return fsm_core.current_state_ptr;
}
     2f8:	a1 24 00 00 00       	mov    0x24,%eax
     2fd:	5d                   	pop    %ebp
     2fe:	c3                   	ret    
     2ff:	90                   	nop

00000300 <fsm_dev_get>:

void* fsm_dev_get()
{
     300:	55                   	push   %ebp
     301:	89 e5                	mov    %esp,%ebp
     303:	e8 fc ff ff ff       	call   304 <fsm_dev_get+0x4>
	return fsm_core.dev;
}
     308:	a1 a8 02 00 00       	mov    0x2a8,%eax
     30d:	5d                   	pop    %ebp
     30e:	c3                   	ret    
     30f:	90                   	nop

00000310 <fsm_get_id_by_name>:

int fsm_get_id_by_name(const char* name)
{
     310:	55                   	push   %ebp
     311:	89 e5                	mov    %esp,%ebp
     313:	56                   	push   %esi
     314:	53                   	push   %ebx
     315:	e8 fc ff ff ff       	call   316 <fsm_get_id_by_name+0x6>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     31a:	31 db                	xor    %ebx,%ebx
{
	return fsm_core.dev;
}

int fsm_get_id_by_name(const char* name)
{
     31c:	89 c6                	mov    %eax,%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
     31e:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
     325:	89 f2                	mov    %esi,%edx
     327:	e8 fc ff ff ff       	call   328 <fsm_get_id_by_name+0x18>
     32c:	85 c0                	test   %eax,%eax
     32e:	74 18                	je     348 <fsm_get_id_by_name+0x38>
}

int fsm_get_id_by_name(const char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     330:	83 c3 01             	add    $0x1,%ebx
     333:	83 fb 06             	cmp    $0x6,%ebx
     336:	75 e6                	jne    31e <fsm_get_id_by_name+0xe>
			{
			return FSM[i]->id;
			}
		}
	return -1;
}
     338:	5b                   	pop    %ebx
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
			}
		}
	return -1;
     339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
     33e:	5e                   	pop    %esi
     33f:	5d                   	pop    %ebp
     340:	c3                   	ret    
     341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     348:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
			}
		}
	return -1;
}
     34f:	5b                   	pop    %ebx
     350:	5e                   	pop    %esi
     351:	5d                   	pop    %ebp
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     352:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
			}
		}
	return -1;
}
     358:	c3                   	ret    
     359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000360 <fsm_get_name_by_id>:

void fsm_get_name_by_id(int id, char* name)
{
     360:	55                   	push   %ebp
     361:	89 e5                	mov    %esp,%ebp
     363:	53                   	push   %ebx
     364:	e8 fc ff ff ff       	call   365 <fsm_get_name_by_id+0x5>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     369:	31 c9                	xor    %ecx,%ecx
		}
	return -1;
}

void fsm_get_name_by_id(int id, char* name)
{
     36b:	89 d3                	mov    %edx,%ebx
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
     36d:	8b 14 8d 90 02 00 00 	mov    0x290(,%ecx,4),%edx
     374:	39 82 80 00 00 00    	cmp    %eax,0x80(%edx)
     37a:	74 14                	je     390 <fsm_get_name_by_id+0x30>
}

void fsm_get_name_by_id(int id, char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     37c:	83 c1 01             	add    $0x1,%ecx
     37f:	83 f9 06             	cmp    $0x6,%ecx
     382:	75 e9                	jne    36d <fsm_get_name_by_id+0xd>
			{
			strcpy(name, FSM[i]->name);
			break;
			}
		}
	*name ='\0';
     384:	c6 03 00             	movb   $0x0,(%ebx)
}
     387:	5b                   	pop    %ebx
     388:	5d                   	pop    %ebp
     389:	c3                   	ret    
     38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
			{
			strcpy(name, FSM[i]->name);
     390:	89 d8                	mov    %ebx,%eax
     392:	e8 fc ff ff ff       	call   393 <fsm_get_name_by_id+0x33>
			break;
			}
		}
	*name ='\0';
     397:	c6 03 00             	movb   $0x0,(%ebx)
}
     39a:	5b                   	pop    %ebx
     39b:	5d                   	pop    %ebp
     39c:	c3                   	ret    
     39d:	8d 76 00             	lea    0x0(%esi),%esi

000003a0 <fsm_intf_addr_get>:

void* fsm_intf_addr_get(int strm_id)
{
     3a0:	55                   	push   %ebp
     3a1:	89 e5                	mov    %esp,%ebp
     3a3:	e8 fc ff ff ff       	call   3a4 <fsm_intf_addr_get+0x4>
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3a8:	c1 e0 04             	shl    $0x4,%eax
     3ab:	8d 90 40 00 00 00    	lea    0x40(%eax),%edx
		return INTF[strm_id].dev->dev_addr;
	else
		return NULL;
     3b1:	31 c0                	xor    %eax,%eax
	*name ='\0';
}

void* fsm_intf_addr_get(int strm_id)
{
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3b3:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
     3b7:	75 09                	jne    3c2 <fsm_intf_addr_get+0x22>
		return INTF[strm_id].dev->dev_addr;
     3b9:	8b 42 0c             	mov    0xc(%edx),%eax
     3bc:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
	else
		return NULL;
}
     3c2:	5d                   	pop    %ebp
     3c3:	c3                   	ret    
     3c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     3ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000003d0 <fsm_self_addr_get>:
	
u8* fsm_self_addr_get()
{
     3d0:	55                   	push   %ebp
     3d1:	89 e5                	mov    %esp,%ebp
     3d3:	e8 fc ff ff ff       	call   3d4 <fsm_self_addr_get+0x4>
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3d8:	a1 a8 02 00 00       	mov    0x2a8,%eax
}
     3dd:	5d                   	pop    %ebp
	
u8* fsm_self_addr_get()
{
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3de:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
}
     3e4:	c3                   	ret    
     3e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     3e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000003f0 <fsm_data_get>:



void* fsm_data_get()
{
     3f0:	55                   	push   %ebp
     3f1:	89 e5                	mov    %esp,%ebp
     3f3:	e8 fc ff ff ff       	call   3f4 <fsm_data_get+0x4>
	void* buffer;
	buffer = fsm_core.buffer;
     3f8:	a1 ac 02 00 00       	mov    0x2ac,%eax
	fsm_core.buffer = NULL;
     3fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     404:	00 00 00 
	return buffer;
}
     407:	5d                   	pop    %ebp
     408:	c3                   	ret    
     409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000410 <fsm_data_destroy>:

void fsm_data_destroy(void* data_ptr)
{
     410:	55                   	push   %ebp
     411:	89 e5                	mov    %esp,%ebp
     413:	e8 fc ff ff ff       	call   414 <fsm_data_destroy+0x4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     418:	e8 fc ff ff ff       	call   419 <fsm_data_destroy+0x9>
}

void fsm_data_destroy(void* data_ptr)
{
	fsm_mem_free(data_ptr);
	freenum++;
     41d:	83 05 00 00 00 00 01 	addl   $0x1,0x0
}
     424:	5d                   	pop    %ebp
     425:	c3                   	ret    
     426:	8d 76 00             	lea    0x0(%esi),%esi
     429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000430 <__fsm_core_self_drive>:
		fsm_mem_free(tmev_ptr);
	}
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
     430:	55                   	push   %ebp
     431:	89 e5                	mov    %esp,%ebp
     433:	56                   	push   %esi
     434:	53                   	push   %ebx
     435:	e8 fc ff ff ff       	call   436 <__fsm_core_self_drive+0x6>
     43a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsm_core.current_fsm = dst_id;
     43d:	89 1d 20 00 00 00    	mov    %ebx,0x20
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     443:	8b 1c 9d 90 02 00 00 	mov    0x290(,%ebx,4),%ebx
	fsm_core.evtype = evtype;
     44a:	a3 30 00 00 00       	mov    %eax,0x30
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     44f:	8b 45 08             	mov    0x8(%ebp),%eax
static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
	fsm_core.evtype = evtype;
	fsm_core.code = code;
     452:	89 15 34 00 00 00    	mov    %edx,0x34
	fsm_core.pkptr = pkptr;
     458:	89 0d 2c 00 00 00    	mov    %ecx,0x2c
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     45e:	8d b3 8c 00 00 00    	lea    0x8c(%ebx),%esi
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     464:	a3 38 00 00 00       	mov    %eax,0x38
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     469:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     46f:	89 35 24 00 00 00    	mov    %esi,0x24
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     475:	a3 3c 00 00 00       	mov    %eax,0x3c
	fsm_core.buffer = buffer;
     47a:	8b 45 10             	mov    0x10(%ebp),%eax
     47d:	a3 ac 02 00 00       	mov    %eax,0x2ac
	fsm_core.ioctrl_cmd = ioctrl_cmd;
     482:	8b 45 14             	mov    0x14(%ebp),%eax
     485:	a3 b0 02 00 00       	mov    %eax,0x2b0
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
     48a:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
     490:	a3 40 00 00 00       	mov    %eax,0x40
	fsm_core.fsm_drive();
     495:	ff d0                	call   *%eax

/* ------------------internal functions-------------------------------*/
static void __fsm_ev_flush()
{
	
	if(fsm_core.pkptr)
     497:	a1 2c 00 00 00       	mov    0x2c,%eax
     49c:	85 c0                	test   %eax,%eax
     49e:	74 05                	je     4a5 <__fsm_core_self_drive+0x75>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     4a0:	e8 fc ff ff ff       	call   4a1 <__fsm_core_self_drive+0x71>
		}
//	if(fsm_core.buffer && !(fsm_ev_type()==FSM_EV_TYPE_CORE && fsm_ev_code()==FSM_EV_IOCTRL && fsm_ev_src()==USER_SPACE))
//		{
//		fsm_mem_free(fsm_core.buffer);
//		}
	if(fsm_core.buffer)
     4a5:	a1 ac 02 00 00       	mov    0x2ac,%eax
     4aa:	85 c0                	test   %eax,%eax
     4ac:	74 05                	je     4b3 <__fsm_core_self_drive+0x83>
		{
		fsm_data_destroy(fsm_core.buffer);
     4ae:	e8 fc ff ff ff       	call   4af <__fsm_core_self_drive+0x7f>
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4b3:	5b                   	pop    %ebx
//		}
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
     4b4:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
     4bb:	ff ff ff 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4be:	5e                   	pop    %esi
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
     4bf:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
     4c6:	00 00 00 
	fsm_core.pkptr = NULL;
     4c9:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     4d0:	00 00 00 
	fsm_core.evtype = INVALIDE;
     4d3:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
     4da:	00 00 00 
	fsm_core.code = INVALIDE;
     4dd:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
     4e4:	00 00 00 
	fsm_core.src = INVALIDE;
     4e7:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
     4ee:	00 00 00 
	FSM_SV_PTR = NULL;
     4f1:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
     4f8:	00 00 00 
	fsm_core.fsm_drive = NULL;
     4fb:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
     502:	00 00 00 
	fsm_core.buffer = NULL;
     505:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     50c:	00 00 00 
	fsm_core.ioctrl_cmd = INVALIDE;
     50f:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
     516:	00 00 00 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     519:	5d                   	pop    %ebp
     51a:	c3                   	ret    
     51b:	90                   	nop
     51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000520 <fsm_pkt_get>:


/* Packet operation */

FSM_PKT* fsm_pkt_get()
{
     520:	55                   	push   %ebp
     521:	89 e5                	mov    %esp,%ebp
     523:	e8 fc ff ff ff       	call   524 <fsm_pkt_get+0x4>
	FSM_PKT* ptr;
	ptr = fsm_core.pkptr;
     528:	a1 2c 00 00 00       	mov    0x2c,%eax
	fsm_core.pkptr = NULL;
     52d:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     534:	00 00 00 
	return ptr;
}
     537:	5d                   	pop    %ebp
     538:	c3                   	ret    
     539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000540 <fsm_pkt_send>:

void fsm_pkt_send(FSM_PKT* pkptr, int oinf)
{
     540:	55                   	push   %ebp
     541:	89 e5                	mov    %esp,%ebp
     543:	53                   	push   %ebx
     544:	e8 fc ff ff ff       	call   545 <fsm_pkt_send+0x5>
	if(oinf < MAX_INTF && INTF[oinf].valid)
     549:	83 fa 1f             	cmp    $0x1f,%edx
     54c:	7f 2a                	jg     578 <fsm_pkt_send+0x38>
     54e:	c1 e2 04             	shl    $0x4,%edx
     551:	8d 9a 40 00 00 00    	lea    0x40(%edx),%ebx
     557:	8b 53 04             	mov    0x4(%ebx),%edx
     55a:	85 d2                	test   %edx,%edx
     55c:	74 1a                	je     578 <fsm_pkt_send+0x38>
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
     55e:	83 fa 01             	cmp    $0x1,%edx
     561:	74 25                	je     588 <fsm_pkt_send+0x48>
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
			}
		else if(INTF[oinf].valid == DEV_INTF_IND)
     563:	83 fa 02             	cmp    $0x2,%edx
     566:	75 15                	jne    57d <fsm_pkt_send+0x3d>
			{
			INTF[oinf].send(pkptr, fsm_core.dev, INTF[oinf].proto);
     568:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     56c:	8b 15 a8 02 00 00    	mov    0x2a8,%edx
     572:	ff 53 10             	call   *0x10(%ebx)
     575:	eb 06                	jmp    57d <fsm_pkt_send+0x3d>
     577:	90                   	nop
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     578:	e8 fc ff ff ff       	call   579 <fsm_pkt_send+0x39>
	}
	else
	{
		fsm_pkt_destroy(pkptr);
	}
}
     57d:	5b                   	pop    %ebx
     57e:	5d                   	pop    %ebp
     57f:	90                   	nop
     580:	c3                   	ret    
     581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	if(oinf < MAX_INTF && INTF[oinf].valid)
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
     588:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     58c:	8b 53 0c             	mov    0xc(%ebx),%edx
     58f:	ff 53 10             	call   *0x10(%ebx)
     592:	eb e9                	jmp    57d <fsm_pkt_send+0x3d>
     594:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     59a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000005a0 <fsm_pkt_create>:
		fsm_pkt_destroy(pkptr);
	}
}

FSM_PKT* fsm_pkt_create(unsigned int size)
{
     5a0:	55                   	push   %ebp
     5a1:	89 e5                	mov    %esp,%ebp
     5a3:	53                   	push   %ebx
     5a4:	e8 fc ff ff ff       	call   5a5 <fsm_pkt_create+0x5>
 *	allocates memory it can be called from an interrupt.
 */
static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
					       unsigned int length)
{
	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
     5a9:	b9 20 00 00 00       	mov    $0x20,%ecx
     5ae:	89 c2                	mov    %eax,%edx
     5b0:	31 c0                	xor    %eax,%eax
     5b2:	e8 fc ff ff ff       	call   5b3 <fsm_pkt_create+0x13>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5b7:	31 d2                	xor    %edx,%edx
     5b9:	89 c3                	mov    %eax,%ebx

FSM_PKT* fsm_pkt_create(unsigned int size)
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
     5bb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
     5c1:	8b 8b a4 00 00 00    	mov    0xa4(%ebx),%ecx
     5c7:	29 c1                	sub    %eax,%ecx
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5c9:	e8 fc ff ff ff       	call   5ca <fsm_pkt_create+0x2a>
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
	return pkptr;
}
     5ce:	89 d8                	mov    %ebx,%eax
     5d0:	5b                   	pop    %ebx
     5d1:	5d                   	pop    %ebp
     5d2:	c3                   	ret    
     5d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005e0 <fsm_skb_realloc_headeroom>:


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
     5e0:	55                   	push   %ebp
     5e1:	89 e5                	mov    %esp,%ebp
     5e3:	83 ec 0c             	sub    $0xc,%esp
     5e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     5e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
     5ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
     5ef:	e8 fc ff ff ff       	call   5f0 <fsm_skb_realloc_headeroom+0x10>
     5f4:	89 c3                	mov    %eax,%ebx
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5f6:	e8 fc ff ff ff       	call   5f7 <fsm_skb_realloc_headeroom+0x17>
	if (unlikely(pkptr_new == NULL))
     5fb:	85 c0                	test   %eax,%eax


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5fd:	89 c6                	mov    %eax,%esi
	if (unlikely(pkptr_new == NULL))
     5ff:	74 27                	je     628 <fsm_skb_realloc_headeroom+0x48>
        {
        KFREE_SKB(pkptr);
        return NULL;
       	}
    if(pkptr->sk)
     601:	8b 7b 10             	mov    0x10(%ebx),%edi
     604:	85 ff                	test   %edi,%edi
     606:	74 20                	je     628 <fsm_skb_realloc_headeroom+0x48>
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */
static inline void skb_orphan(struct sk_buff *skb)
{
	if (skb->destructor)
     608:	8b 50 68             	mov    0x68(%eax),%edx
     60b:	85 d2                	test   %edx,%edx
     60d:	74 02                	je     611 <fsm_skb_realloc_headeroom+0x31>
		skb->destructor(skb);
     60f:	ff d2                	call   *%edx
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	skb_orphan(skb);
	skb->sk = sk;
     611:	89 7e 10             	mov    %edi,0x10(%esi)
 *
 * Atomically adds @i to @v.
 */
static inline void atomic_add(int i, atomic_t *v)
{
	asm volatile(LOCK_PREFIX "addl %1,%0"
     614:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
	skb->destructor = sock_wfree;
     61a:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
     621:	f0 01 87 94 00 00 00 	lock add %eax,0x94(%edi)
        {
        SKB_SET_OWNER_W(pkptr_new, pkptr->sk); 
	}
	KFREE_SKB(pkptr);
     628:	89 d8                	mov    %ebx,%eax
     62a:	e8 fc ff ff ff       	call   62b <fsm_skb_realloc_headeroom+0x4b>
	return pkptr_new;
}
     62f:	89 f0                	mov    %esi,%eax
     631:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     634:	8b 75 f8             	mov    -0x8(%ebp),%esi
     637:	8b 7d fc             	mov    -0x4(%ebp),%edi
     63a:	89 ec                	mov    %ebp,%esp
     63c:	5d                   	pop    %ebp
     63d:	c3                   	ret    
     63e:	66 90                	xchg   %ax,%ax

00000640 <fsm_pkt_destroy>:

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
     640:	55                   	push   %ebp
     641:	89 e5                	mov    %esp,%ebp
     643:	e8 fc ff ff ff       	call   644 <fsm_pkt_destroy+0x4>
	KFREE_SKB(pkptr);
     648:	e8 fc ff ff ff       	call   649 <fsm_pkt_destroy+0x9>
}
     64d:	5d                   	pop    %ebp
     64e:	c3                   	ret    
     64f:	90                   	nop

00000650 <fsm_pkt_duplicate>:

FSM_PKT* fsm_pkt_duplicate(FSM_PKT* pkptr)
{
     650:	55                   	push   %ebp
     651:	89 e5                	mov    %esp,%ebp
     653:	e8 fc ff ff ff       	call   654 <fsm_pkt_duplicate+0x4>
	return SKB_COPY(pkptr, GFP_ATOMIC);
     658:	ba 20 00 00 00       	mov    $0x20,%edx
     65d:	e8 fc ff ff ff       	call   65e <fsm_pkt_duplicate+0xe>
}
     662:	5d                   	pop    %ebp
     663:	c3                   	ret    
     664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     66a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000670 <fsm_skb_put>:

u8* fsm_skb_put(FSM_PKT* pkptr, int len)
{	
     670:	55                   	push   %ebp
     671:	89 e5                	mov    %esp,%ebp
     673:	e8 fc ff ff ff       	call   674 <fsm_skb_put+0x4>
	return (u8*)SKB_PUT(pkptr, len);
     678:	e8 fc ff ff ff       	call   679 <fsm_skb_put+0x9>
}
     67d:	5d                   	pop    %ebp
     67e:	c3                   	ret    
     67f:	90                   	nop

00000680 <fsm_skb_push>:

u8* fsm_skb_push(FSM_PKT* pkptr, int len)
{
     680:	55                   	push   %ebp
     681:	89 e5                	mov    %esp,%ebp
     683:	e8 fc ff ff ff       	call   684 <fsm_skb_push+0x4>
	return SKB_PUSH(pkptr, len);
     688:	e8 fc ff ff ff       	call   689 <fsm_skb_push+0x9>
}
     68d:	5d                   	pop    %ebp
     68e:	c3                   	ret    
     68f:	90                   	nop

00000690 <fsm_skb_pull>:

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	e8 fc ff ff ff       	call   694 <fsm_skb_pull+0x4>
     698:	89 c1                	mov    %eax,%ecx
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     69a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	pkptr->len -= len;
     6a0:	29 51 50             	sub    %edx,0x50(%ecx)
}

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     6a3:	01 d0                	add    %edx,%eax
     6a5:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
	pkptr->len -= len;
	return (u8 *)pkptr->data;
}
     6ab:	5d                   	pop    %ebp
     6ac:	c3                   	ret    
     6ad:	8d 76 00             	lea    0x0(%esi),%esi

000006b0 <fsm_skb_reserve>:

void fsm_skb_reserve(FSM_PKT* pkptr , int len)
{
     6b0:	55                   	push   %ebp
     6b1:	89 e5                	mov    %esp,%ebp
     6b3:	e8 fc ff ff ff       	call   6b4 <fsm_skb_reserve+0x4>
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
     6b8:	01 90 ac 00 00 00    	add    %edx,0xac(%eax)
	skb->tail += len;
     6be:	01 90 a0 00 00 00    	add    %edx,0xa0(%eax)
	SKB_RESERVE(pkptr, len);
}
     6c4:	5d                   	pop    %ebp
     6c5:	c3                   	ret    
     6c6:	8d 76 00             	lea    0x0(%esi),%esi
     6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000006d0 <fsm_skb_tailroom>:

int fsm_skb_tailroom(FSM_PKT* pkptr)
{
     6d0:	55                   	push   %ebp
     6d1:	89 e5                	mov    %esp,%ebp
     6d3:	e8 fc ff ff ff       	call   6d4 <fsm_skb_tailroom+0x4>
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */
static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
     6d8:	31 d2                	xor    %edx,%edx
     6da:	8b 48 54             	mov    0x54(%eax),%ecx
     6dd:	85 c9                	test   %ecx,%ecx
     6df:	75 0c                	jne    6ed <fsm_skb_tailroom+0x1d>
     6e1:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
     6e7:	2b 90 a0 00 00 00    	sub    0xa0(%eax),%edx
	return SKB_TAILROOM(pkptr);
}
     6ed:	89 d0                	mov    %edx,%eax
     6ef:	5d                   	pop    %ebp
     6f0:	c3                   	ret    
     6f1:	eb 0d                	jmp    700 <fsm_skb_headroom>
     6f3:	90                   	nop
     6f4:	90                   	nop
     6f5:	90                   	nop
     6f6:	90                   	nop
     6f7:	90                   	nop
     6f8:	90                   	nop
     6f9:	90                   	nop
     6fa:	90                   	nop
     6fb:	90                   	nop
     6fc:	90                   	nop
     6fd:	90                   	nop
     6fe:	90                   	nop
     6ff:	90                   	nop

00000700 <fsm_skb_headroom>:

int fsm_skb_headroom(FSM_PKT* pkptr)
{
     700:	55                   	push   %ebp
     701:	89 e5                	mov    %esp,%ebp
     703:	e8 fc ff ff ff       	call   704 <fsm_skb_headroom+0x4>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
     708:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
     70e:	2b 90 a8 00 00 00    	sub    0xa8(%eax),%edx
	return SKB_HEADROOM(pkptr);
}
     714:	5d                   	pop    %ebp
     715:	89 d0                	mov    %edx,%eax
     717:	c3                   	ret    
     718:	90                   	nop
     719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000720 <fsm_mem_alloc>:

/* Memory operation */
void* fsm_mem_alloc(size_t size)
{
     720:	55                   	push   %ebp
     721:	89 e5                	mov    %esp,%ebp
     723:	e8 fc ff ff ff       	call   724 <fsm_mem_alloc+0x4>
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(s, flags, size);
		}
	}
	return __kmalloc(size, flags);
     728:	ba 20 00 00 00       	mov    $0x20,%edx
     72d:	e8 fc ff ff ff       	call   72e <fsm_mem_alloc+0xe>
	void* ptr;
	ptr = FSM_MEM_ALLOC(size);
	mallocnum++;
     732:	83 05 00 00 00 00 01 	addl   $0x1,0x0
	return ptr;
}
     739:	5d                   	pop    %ebp
     73a:	c3                   	ret    
     73b:	90                   	nop
     73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000740 <__fsm_tm_ev_add.constprop.7>:
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     740:	55                   	push   %ebp
     741:	89 e5                	mov    %esp,%ebp
     743:	57                   	push   %edi
     744:	56                   	push   %esi
     745:	53                   	push   %ebx
     746:	83 ec 14             	sub    $0x14,%esp
     749:	e8 fc ff ff ff       	call   74a <__fsm_tm_ev_add.constprop.7+0xa>
     74e:	89 c3                	mov    %eax,%ebx
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     750:	b8 2c 00 00 00       	mov    $0x2c,%eax
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     755:	89 d6                	mov    %edx,%esi
     757:	89 cf                	mov    %ecx,%edi
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     759:	e8 fc ff ff ff       	call   75a <__fsm_tm_ev_add.constprop.7+0x1a>
	if(pE)
     75e:	85 c0                	test   %eax,%eax
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     760:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(pE)
     763:	0f 84 bc 00 00 00    	je     825 <__fsm_tm_ev_add.constprop.7+0xe5>
	{
		pE->evmask = EVMASK;
     769:	c7 40 04 d6 96 0f 04 	movl   $0x40f96d6,0x4(%eax)
		pE->pNext = 0;
		pE->type = type;
		pE->code = code;
		pE->delay = delay;
		pE->pkptr = pkptr;
		pE->src_id =src;
     770:	8b 55 f0             	mov    -0x10(%ebp),%edx
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
     773:	85 db                	test   %ebx,%ebx
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
	if(pE)
	{
		pE->evmask = EVMASK;
		pE->pNext = 0;
     775:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		pE->type = type;
     77b:	89 70 18             	mov    %esi,0x18(%eax)
		pE->code = code;
     77e:	89 78 14             	mov    %edi,0x14(%eax)
		pE->delay = delay;
     781:	89 58 10             	mov    %ebx,0x10(%eax)
		pE->pkptr = pkptr;
     784:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
		pE->src_id =src;
     78b:	8b 45 08             	mov    0x8(%ebp),%eax
     78e:	89 42 24             	mov    %eax,0x24(%edx)
		pE->dst_id = dst;
     791:	8b 45 0c             	mov    0xc(%ebp),%eax
     794:	89 42 20             	mov    %eax,0x20(%edx)
		pE->buffer = buffer;
     797:	8b 45 10             	mov    0x10(%ebp),%eax
     79a:	89 42 28             	mov    %eax,0x28(%edx)
		if(delay == 0)
     79d:	0f 84 8d 00 00 00    	je     830 <__fsm_tm_ev_add.constprop.7+0xf0>
			pE->expire = ktime_add_us(ktime_get(), 10);
		else
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
     7a3:	e8 fc ff ff ff       	call   7a4 <__fsm_tm_ev_add.constprop.7+0x64>
     7a8:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
     7ab:	01 db                	add    %ebx,%ebx
     7ad:	89 c6                	mov    %eax,%esi
       return ktime_to_us(ktime_sub(later, earlier));
}

static inline ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
	return ktime_add_ns(kt, usec * 1000);
     7af:	b8 e8 03 00 00       	mov    $0x3e8,%eax
     7b4:	89 d7                	mov    %edx,%edi
     7b6:	f7 e3                	mul    %ebx
     7b8:	01 f0                	add    %esi,%eax
     7ba:	8b 75 f0             	mov    -0x10(%ebp),%esi
     7bd:	11 fa                	adc    %edi,%edx
     7bf:	89 46 08             	mov    %eax,0x8(%esi)
     7c2:	89 56 0c             	mov    %edx,0xc(%esi)
	__tmEvent* p0;
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     7c5:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     7ca:	e8 fc ff ff ff       	call   7cb <__fsm_tm_ev_add.constprop.7+0x8b>
     7cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     7d2:	a1 88 02 00 00       	mov    0x288,%eax
     7d7:	85 c0                	test   %eax,%eax
     7d9:	74 24                	je     7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     7db:	8b 7d f0             	mov    -0x10(%ebp),%edi
     7de:	8b 48 08             	mov    0x8(%eax),%ecx
     7e1:	8b 58 0c             	mov    0xc(%eax),%ebx
     7e4:	8b 77 08             	mov    0x8(%edi),%esi
     7e7:	8b 7f 0c             	mov    0xc(%edi),%edi
     7ea:	89 75 e8             	mov    %esi,-0x18(%ebp)
     7ed:	89 ce                	mov    %ecx,%esi
     7ef:	89 7d ec             	mov    %edi,-0x14(%ebp)
     7f2:	89 df                	mov    %ebx,%edi
     7f4:	2b 75 e8             	sub    -0x18(%ebp),%esi
     7f7:	1b 7d ec             	sbb    -0x14(%ebp),%edi
     7fa:	83 ff 00             	cmp    $0x0,%edi
     7fd:	7e 51                	jle    850 <__fsm_tm_ev_add.constprop.7+0x110>
	{
		pE->pNext = pB->evQ;
     7ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
     802:	89 02                	mov    %eax,(%edx)
		pB->evQ = pE;
		if(pB->tm_state != FSM_TM_EXPIRE)
     804:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
	{
		pE->pNext = pB->evQ;
		pB->evQ = pE;
     80b:	89 15 88 02 00 00    	mov    %edx,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     811:	74 05                	je     818 <__fsm_tm_ev_add.constprop.7+0xd8>
		{
			__fsm_tm_restart();
     813:	e8 18 f9 ff ff       	call   130 <__fsm_tm_restart>
     818:	8b 55 e0             	mov    -0x20(%ebp),%edx
     81b:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     820:	e8 fc ff ff ff       	call   821 <__fsm_tm_ev_add.constprop.7+0xe1>
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
		__fsm_tm_ev_insert(pE);
		return EVHANDLE(pE);
	}
	return 0;
}
     825:	8b 45 f0             	mov    -0x10(%ebp),%eax
     828:	83 c4 14             	add    $0x14,%esp
     82b:	5b                   	pop    %ebx
     82c:	5e                   	pop    %esi
     82d:	5f                   	pop    %edi
     82e:	5d                   	pop    %ebp
     82f:	c3                   	ret    
		pE->pkptr = pkptr;
		pE->src_id =src;
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
			pE->expire = ktime_add_us(ktime_get(), 10);
     830:	e8 fc ff ff ff       	call   831 <__fsm_tm_ev_add.constprop.7+0xf1>
     835:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     838:	05 10 27 00 00       	add    $0x2710,%eax
     83d:	83 d2 00             	adc    $0x0,%edx
     840:	89 41 08             	mov    %eax,0x8(%ecx)
     843:	89 51 0c             	mov    %edx,0xc(%ecx)
     846:	e9 7a ff ff ff       	jmp    7c5 <__fsm_tm_ev_add.constprop.7+0x85>
     84b:	90                   	nop
     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     850:	7c 1f                	jl     871 <__fsm_tm_ev_add.constprop.7+0x131>
     852:	83 fe 00             	cmp    $0x0,%esi
     855:	76 1a                	jbe    871 <__fsm_tm_ev_add.constprop.7+0x131>
     857:	eb a6                	jmp    7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
	{
		p1 = p0;
		p0 = p0->pNext;
     860:	8b 10                	mov    (%eax),%edx
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return;
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
     862:	85 d2                	test   %edx,%edx
     864:	74 32                	je     898 <__fsm_tm_ev_add.constprop.7+0x158>
     866:	8b 4a 08             	mov    0x8(%edx),%ecx
     869:	8b 5a 0c             	mov    0xc(%edx),%ebx
     86c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     86f:	89 d0                	mov    %edx,%eax
     871:	8b 75 e8             	mov    -0x18(%ebp),%esi
     874:	8b 7d ec             	mov    -0x14(%ebp),%edi
     877:	29 ce                	sub    %ecx,%esi
     879:	19 df                	sbb    %ebx,%edi
     87b:	83 ff 00             	cmp    $0x0,%edi
     87e:	7f e0                	jg     860 <__fsm_tm_ev_add.constprop.7+0x120>
     880:	7c 05                	jl     887 <__fsm_tm_ev_add.constprop.7+0x147>
     882:	83 fe 00             	cmp    $0x0,%esi
     885:	77 d9                	ja     860 <__fsm_tm_ev_add.constprop.7+0x120>
     887:	8b 55 ec             	mov    -0x14(%ebp),%edx
     88a:	33 4d e8             	xor    -0x18(%ebp),%ecx
     88d:	31 da                	xor    %ebx,%edx
     88f:	09 ca                	or     %ecx,%edx
     891:	74 cd                	je     860 <__fsm_tm_ev_add.constprop.7+0x120>
     893:	89 c2                	mov    %eax,%edx
     895:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		p1 = p0;
		p0 = p0->pNext;
	}
	pE->pNext = p0;
     898:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     89b:	89 11                	mov    %edx,(%ecx)
	p1->pNext = pE;
     89d:	89 08                	mov    %ecx,(%eax)
     89f:	e9 74 ff ff ff       	jmp    818 <__fsm_tm_ev_add.constprop.7+0xd8>
     8a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     8aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000008b0 <fsm_mem_free>:
	mallocnum++;
	return ptr;
}

void fsm_mem_free(void* ptr)
{
     8b0:	55                   	push   %ebp
     8b1:	89 e5                	mov    %esp,%ebp
     8b3:	e8 fc ff ff ff       	call   8b4 <fsm_mem_free+0x4>
	FSM_MEM_FREE(ptr);
     8b8:	e8 fc ff ff ff       	call   8b9 <fsm_mem_free+0x9>
}
     8bd:	5d                   	pop    %ebp
     8be:	c3                   	ret    
     8bf:	90                   	nop

000008c0 <fsm_mem_cpy>:

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
     8c0:	55                   	push   %ebp
     8c1:	89 e5                	mov    %esp,%ebp
     8c3:	e8 fc ff ff ff       	call   8c4 <fsm_mem_cpy+0x4>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     8c8:	e8 fc ff ff ff       	call   8c9 <fsm_mem_cpy+0x9>
}
     8cd:	5d                   	pop    %ebp
     8ce:	c3                   	ret    
     8cf:	90                   	nop

000008d0 <fsm_mem_set>:

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
     8d0:	55                   	push   %ebp
     8d1:	89 e5                	mov    %esp,%ebp
     8d3:	e8 fc ff ff ff       	call   8d4 <fsm_mem_set+0x4>
	return FSM_MEM_SET(dst_ptr,val,size);
     8d8:	e8 fc ff ff ff       	call   8d9 <fsm_mem_set+0x9>
}
     8dd:	5d                   	pop    %ebp
     8de:	c3                   	ret    
     8df:	90                   	nop

000008e0 <fsm_mem_cmp>:

int fsm_mem_cmp(const void* dst_ptr, const void* src_ptr, size_t size)
{
     8e0:	55                   	push   %ebp
     8e1:	89 e5                	mov    %esp,%ebp
     8e3:	e8 fc ff ff ff       	call   8e4 <fsm_mem_cmp+0x4>
	return FSM_MEM_CMP(dst_ptr,src_ptr,size);
     8e8:	e8 fc ff ff ff       	call   8e9 <fsm_mem_cmp+0x9>
}
     8ed:	5d                   	pop    %ebp
     8ee:	c3                   	ret    
     8ef:	90                   	nop

000008f0 <fsm_printf>:


/* Print */
size_t fsm_printf(const char* fmt,...)
{
     8f0:	55                   	push   %ebp
     8f1:	89 e5                	mov    %esp,%ebp
     8f3:	83 ec 08             	sub    $0x8,%esp
     8f6:	e8 fc ff ff ff       	call   8f7 <fsm_printf+0x7>
	//return 0;
	int print_len;
	va_list args;
	va_start(args,fmt);
     8fb:	8d 45 0c             	lea    0xc(%ebp),%eax
	print_len = VPRINTK(fmt,args);
     8fe:	89 44 24 04          	mov    %eax,0x4(%esp)
     902:	8b 45 08             	mov    0x8(%ebp),%eax
     905:	89 04 24             	mov    %eax,(%esp)
     908:	e8 fc ff ff ff       	call   909 <fsm_printf+0x19>
	va_end(args);
	return print_len;
	
	return 0;
}
     90d:	c9                   	leave  
     90e:	c3                   	ret    
     90f:	90                   	nop

00000910 <__fsm_pending_expev>:
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}

static void __fsm_pending_expev(unsigned long data)
{
     910:	55                   	push   %ebp
     911:	89 e5                	mov    %esp,%ebp
     913:	57                   	push   %edi
     914:	56                   	push   %esi
     915:	53                   	push   %ebx
     916:	83 ec 18             	sub    $0x18,%esp
     919:	e8 fc ff ff ff       	call   91a <__fsm_pending_expev+0xa>
     91e:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     924:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     92a:	0f 85 a5 00 00 00    	jne    9d5 <__fsm_pending_expev+0xc5>
     930:	e9 eb 00 00 00       	jmp    a20 <__fsm_pending_expev+0x110>
     935:	8d 76 00             	lea    0x0(%esi),%esi
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     938:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     93d:	e8 fc ff ff ff       	call   93e <__fsm_pending_expev+0x2e>
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     942:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
     945:	8b 53 14             	mov    0x14(%ebx),%edx
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     948:	89 45 ec             	mov    %eax,-0x14(%ebp)
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     94b:	8b 43 18             	mov    0x18(%ebx),%eax
     94e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     955:	00 
     956:	8b 7b 28             	mov    0x28(%ebx),%edi
     959:	89 7c 24 08          	mov    %edi,0x8(%esp)
     95d:	8b 7b 20             	mov    0x20(%ebx),%edi
     960:	89 7c 24 04          	mov    %edi,0x4(%esp)
     964:	8b 7b 24             	mov    0x24(%ebx),%edi
     967:	89 3c 24             	mov    %edi,(%esp)
     96a:	e8 c1 fa ff ff       	call   430 <__fsm_core_self_drive>
     96f:	8b 55 ec             	mov    -0x14(%ebp),%edx
     972:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     977:	e8 fc ff ff ff       	call   978 <__fsm_pending_expev+0x68>

#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)

static inline int arch_spin_is_locked(struct arch_spinlock *lock)
{
	return PVOP_CALL1(int, pv_lock_ops.spin_is_locked, lock);
     97c:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     981:	ff 15 00 00 00 00    	call   *0x0
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
     987:	85 c0                	test   %eax,%eax
     989:	75 7d                	jne    a08 <__fsm_pending_expev+0xf8>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
//			return;
		} 
		spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
     98b:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     990:	e8 fc ff ff ff       	call   991 <__fsm_pending_expev+0x81>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     995:	8b 4e 04             	mov    0x4(%esi),%ecx
     998:	8b 3e                	mov    (%esi),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     99a:	89 4f 04             	mov    %ecx,0x4(%edi)
     99d:	89 c2                	mov    %eax,%edx
     99f:	b8 e6 02 00 00       	mov    $0x2e6,%eax
	prev->next = next;
     9a4:	89 39                	mov    %edi,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     9a6:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
     9ac:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
     9b3:	e8 fc ff ff ff       	call   9b4 <__fsm_pending_expev+0xa4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     9b8:	89 d8                	mov    %ebx,%eax
     9ba:	e8 fc ff ff ff       	call   9bb <__fsm_pending_expev+0xab>
     9bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9c2:	e8 fc ff ff ff       	call   9c3 <__fsm_pending_expev+0xb3>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     9c7:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
static void __fsm_pending_expev(unsigned long data)
{
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     9cd:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     9d3:	74 4b                	je     a20 <__fsm_pending_expev+0x110>
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9d5:	8d 46 fc             	lea    -0x4(%esi),%eax
		pE = tmev_ptr->pE;
     9d8:	8b 5e fc             	mov    -0x4(%esi),%ebx
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9db:	89 45 f0             	mov    %eax,-0x10(%ebp)
     9de:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     9e3:	ff 15 00 00 00 00    	call   *0x0
		pE = tmev_ptr->pE;
		if(spin_is_locked(&fsm_core.lock))
     9e9:	85 c0                	test   %eax,%eax
     9eb:	0f 84 47 ff ff ff    	je     938 <__fsm_pending_expev+0x28>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
     9f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     9f8:	e8 fc ff ff ff       	call   9f9 <__fsm_pending_expev+0xe9>
     9fd:	e9 36 ff ff ff       	jmp    938 <__fsm_pending_expev+0x28>
     a02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
     a08:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
     a0f:	e8 fc ff ff ff       	call   a10 <__fsm_pending_expev+0x100>
     a14:	e9 72 ff ff ff       	jmp    98b <__fsm_pending_expev+0x7b>
     a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		list_del(&tmev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
		fsm_mem_free(pE);
		fsm_mem_free(tmev_ptr);
	}
}
     a20:	83 c4 18             	add    $0x18,%esp
     a23:	5b                   	pop    %ebx
     a24:	5e                   	pop    %esi
     a25:	5f                   	pop    %edi
     a26:	5d                   	pop    %ebp
     a27:	c3                   	ret    
     a28:	90                   	nop
     a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000a30 <__fsm_tm_expire>:
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
}

static enum hrtimer_restart __fsm_tm_expire(struct hrtimer *timer)
{
     a30:	55                   	push   %ebp
     a31:	89 e5                	mov    %esp,%ebp
     a33:	57                   	push   %edi
     a34:	56                   	push   %esi
     a35:	53                   	push   %ebx
     a36:	83 ec 08             	sub    $0x8,%esp
     a39:	e8 fc ff ff ff       	call   a3a <__fsm_tm_expire+0xa>
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a3e:	e8 fc ff ff ff       	call   a3f <__fsm_tm_expire+0xf>
	pB->tm_state = FSM_TM_EXPIRE;
     a43:	c7 05 44 02 00 00 02 	movl   $0x2,0x244
     a4a:	00 00 00 
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a4d:	89 c6                	mov    %eax,%esi
     a4f:	89 d7                	mov    %edx,%edi
     a51:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a56:	ff 15 00 00 00 00    	call   *0x0
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
     a5c:	85 c0                	test   %eax,%eax
     a5e:	0f 85 9c 00 00 00    	jne    b00 <__fsm_tm_expire+0xd0>
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a64:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a69:	e8 fc ff ff ff       	call   a6a <__fsm_tm_expire+0x3a>
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a6e:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     a74:	85 db                	test   %ebx,%ebx
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a79:	74 15                	je     a90 <__fsm_tm_expire+0x60>
     a7b:	8b 43 08             	mov    0x8(%ebx),%eax
     a7e:	8b 53 0c             	mov    0xc(%ebx),%edx
     a81:	29 f0                	sub    %esi,%eax
     a83:	19 fa                	sbb    %edi,%edx
     a85:	83 fa 00             	cmp    $0x0,%edx
     a88:	0f 8e a2 00 00 00    	jle    b30 <__fsm_tm_expire+0x100>
     a8e:	66 90                	xchg   %ax,%ax
     a90:	8b 55 f0             	mov    -0x10(%ebp),%edx
     a93:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a98:	e8 fc ff ff ff       	call   a99 <__fsm_tm_expire+0x69>
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
			tmev_ptr->pE = pE;
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);		
		tasklet_schedule(fsm_core.exp_ev_tsklt);
     a9d:	a1 cc 02 00 00       	mov    0x2cc,%eax
     aa2:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     aa8:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     aaa:	85 d2                	test   %edx,%edx
     aac:	74 42                	je     af0 <__fsm_tm_expire+0xc0>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     aae:	a1 88 02 00 00       	mov    0x288,%eax
     ab3:	85 c0                	test   %eax,%eax
     ab5:	74 61                	je     b18 <__fsm_tm_expire+0xe8>
     ab7:	8b 50 0c             	mov    0xc(%eax),%edx
     aba:	8b 40 08             	mov    0x8(%eax),%eax
        {	
		hrtimer_set_expires(&pB->timer, pB->evQ->expire);
		pB->tm_state = FSM_TM_RUN;	
     abd:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     ac4:	00 00 00 
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
};

static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
	timer->node.expires = time;
     ac7:	89 15 58 02 00 00    	mov    %edx,0x258
     acd:	a3 54 02 00 00       	mov    %eax,0x254
	timer->_softexpires = time;
     ad2:	a3 5c 02 00 00       	mov    %eax,0x25c
		return HRTIMER_RESTART;
     ad7:	b8 01 00 00 00       	mov    $0x1,%eax
     adc:	89 15 60 02 00 00    	mov    %edx,0x260
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     ae2:	83 c4 08             	add    $0x8,%esp
     ae5:	5b                   	pop    %ebx
     ae6:	5e                   	pop    %esi
     ae7:	5f                   	pop    %edi
     ae8:	5d                   	pop    %ebp
     ae9:	c3                   	ret    
     aea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		__tasklet_schedule(t);
     af0:	e8 fc ff ff ff       	call   af1 <__fsm_tm_expire+0xc1>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     af5:	a1 88 02 00 00       	mov    0x288,%eax
     afa:	85 c0                	test   %eax,%eax
     afc:	75 b9                	jne    ab7 <__fsm_tm_expire+0x87>
     afe:	eb 18                	jmp    b18 <__fsm_tm_expire+0xe8>
	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
	{
		fsm_printf("dead lock\n");
     b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     b07:	e8 fc ff ff ff       	call   b08 <__fsm_tm_expire+0xd8>
		return HRTIMER_NORESTART;
     b0c:	31 c0                	xor    %eax,%eax
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     b0e:	83 c4 08             	add    $0x8,%esp
     b11:	5b                   	pop    %ebx
     b12:	5e                   	pop    %esi
     b13:	5f                   	pop    %edi
     b14:	5d                   	pop    %ebp
     b15:	c3                   	ret    
     b16:	66 90                	xchg   %ax,%ax
		pB->tm_state = FSM_TM_RUN;	
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
     b18:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     b1f:	00 00 00 
		return HRTIMER_NORESTART;	
	}
	
}
     b22:	83 c4 08             	add    $0x8,%esp
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
     b25:	31 c0                	xor    %eax,%eax
	}
	
}
     b27:	5b                   	pop    %ebx
     b28:	5e                   	pop    %esi
     b29:	5f                   	pop    %edi
     b2a:	5d                   	pop    %ebp
     b2b:	c3                   	ret    
     b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b30:	7c 0f                	jl     b41 <__fsm_tm_expire+0x111>
     b32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b38:	83 f8 00             	cmp    $0x0,%eax
     b3b:	0f 87 4f ff ff ff    	ja     a90 <__fsm_tm_expire+0x60>
		{
			pE = pB->evQ;
			pB->evQ = pE->pNext;
     b41:	8b 03                	mov    (%ebx),%eax
     b43:	a3 88 02 00 00       	mov    %eax,0x288
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
     b48:	b8 0c 00 00 00       	mov    $0xc,%eax
     b4d:	e8 fc ff ff ff       	call   b4e <__fsm_tm_expire+0x11e>
			tmev_ptr->pE = pE;
     b52:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     b54:	8b 15 e0 02 00 00    	mov    0x2e0,%edx
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
     b5a:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     b5d:	89 0d e0 02 00 00    	mov    %ecx,0x2e0
	new->next = next;
     b63:	c7 40 04 dc 02 00 00 	movl   $0x2dc,0x4(%eax)
	new->prev = prev;
     b6a:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
     b6d:	89 0a                	mov    %ecx,(%edx)
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b6f:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     b75:	85 db                	test   %ebx,%ebx
     b77:	0f 84 13 ff ff ff    	je     a90 <__fsm_tm_expire+0x60>
     b7d:	8b 43 08             	mov    0x8(%ebx),%eax
     b80:	8b 53 0c             	mov    0xc(%ebx),%edx
     b83:	29 f0                	sub    %esi,%eax
     b85:	19 fa                	sbb    %edi,%edx
     b87:	83 fa 00             	cmp    $0x0,%edx
     b8a:	7c b5                	jl     b41 <__fsm_tm_expire+0x111>
     b8c:	0f 8f fe fe ff ff    	jg     a90 <__fsm_tm_expire+0x60>
     b92:	eb a4                	jmp    b38 <__fsm_tm_expire+0x108>
     b94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000ba0 <fsm_octets_print>:
	
	return 0;
}

size_t fsm_octets_print(void* data_ptr, size_t num)
{
     ba0:	55                   	push   %ebp
     ba1:	89 e5                	mov    %esp,%ebp
     ba3:	e8 fc ff ff ff       	call   ba4 <fsm_octets_print+0x4>
		}
	}
	fsm_printf("\n");
	fsm_printf("=====================================================\n");
	return num;
}
     ba8:	31 c0                	xor    %eax,%eax
     baa:	5d                   	pop    %ebp
     bab:	c3                   	ret    
     bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bb0 <fsm_htons>:

/* Endianness */
u16 fsm_htons(u16 val)
{
     bb0:	55                   	push   %ebp
     bb1:	89 e5                	mov    %esp,%ebp
     bb3:	e8 fc ff ff ff       	call   bb4 <fsm_htons+0x4>
	return HTONS(val);
}
     bb8:	5d                   	pop    %ebp
static inline __attribute_const__ __u16 __fswab16(__u16 val)
{
#ifdef __arch_swab16
	return __arch_swab16(val);
#else
	return ___constant_swab16(val);
     bb9:	66 c1 c0 08          	rol    $0x8,%ax
     bbd:	c3                   	ret    
     bbe:	66 90                	xchg   %ax,%ax

00000bc0 <fsm_htonl>:

u32 fsm_htonl(u32 val)
{
     bc0:	55                   	push   %ebp
     bc1:	89 e5                	mov    %esp,%ebp
     bc3:	e8 fc ff ff ff       	call   bc4 <fsm_htonl+0x4>

static inline __attribute_const__ __u32 __arch_swab32(__u32 val)
{
#ifdef __i386__
# ifdef CONFIG_X86_BSWAP
	asm("bswap %0" : "=r" (val) : "0" (val));
     bc8:	0f c8                	bswap  %eax
	return HTONL(val);
}
     bca:	5d                   	pop    %ebp
     bcb:	c3                   	ret    
     bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bd0 <fsm_ntohs>:

u16 fsm_ntohs(u16 val)
{
     bd0:	55                   	push   %ebp
     bd1:	89 e5                	mov    %esp,%ebp
     bd3:	e8 fc ff ff ff       	call   bd4 <fsm_ntohs+0x4>
	return NTOHS(val);
}
     bd8:	5d                   	pop    %ebp
     bd9:	66 c1 c0 08          	rol    $0x8,%ax
     bdd:	c3                   	ret    
     bde:	66 90                	xchg   %ax,%ax

00000be0 <fsm_ntohl>:

u32 fsm_ntohl(u32 val)
{
     be0:	55                   	push   %ebp
     be1:	89 e5                	mov    %esp,%ebp
     be3:	e8 fc ff ff ff       	call   be4 <fsm_ntohl+0x4>
     be8:	0f c8                	bswap  %eax
	return NTOHL(val);
}
     bea:	5d                   	pop    %ebp
     beb:	c3                   	ret    
     bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bf0 <fsm_schedule_self>:

/*  Event scheduling operation */
evHandle fsm_schedule_self(unsigned int delay, u32 code)
{
     bf0:	55                   	push   %ebp
     bf1:	89 e5                	mov    %esp,%ebp
     bf3:	53                   	push   %ebx
     bf4:	83 ec 0c             	sub    $0xc,%esp
     bf7:	e8 fc ff ff ff       	call   bf8 <fsm_schedule_self+0x8>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_SELF, code, NULL, fsm_core.current_fsm, fsm_core.current_fsm, NULL);
     bfc:	8b 1d 20 00 00 00    	mov    0x20,%ebx
     c02:	89 d1                	mov    %edx,%ecx
     c04:	ba 03 00 00 00       	mov    $0x3,%edx
     c09:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     c0d:	89 1c 24             	mov    %ebx,(%esp)
     c10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c17:	00 
     c18:	e8 23 fb ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c1d:	83 c4 0c             	add    $0xc,%esp
     c20:	5b                   	pop    %ebx
     c21:	5d                   	pop    %ebp
     c22:	c3                   	ret    
     c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000c30 <fsm_schedule_exfsm>:

evHandle fsm_schedule_exfsm(unsigned int delay, u32 code, int dst_id)
{
     c30:	55                   	push   %ebp
     c31:	89 e5                	mov    %esp,%ebp
     c33:	83 ec 0c             	sub    $0xc,%esp
     c36:	e8 fc ff ff ff       	call   c37 <fsm_schedule_exfsm+0x7>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_EXFSM, code, NULL, fsm_core.current_fsm, dst_id, NULL);
     c3b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     c3f:	8b 0d 20 00 00 00    	mov    0x20,%ecx
     c45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c4c:	00 
     c4d:	89 0c 24             	mov    %ecx,(%esp)
     c50:	89 d1                	mov    %edx,%ecx
     c52:	ba 04 00 00 00       	mov    $0x4,%edx
     c57:	e8 e4 fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c5c:	c9                   	leave  
     c5d:	c3                   	ret    
     c5e:	66 90                	xchg   %ax,%ax

00000c60 <fsm_post_msg>:

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
     c60:	55                   	push   %ebp
     c61:	89 e5                	mov    %esp,%ebp
     c63:	83 ec 20             	sub    $0x20,%esp
     c66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     c69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     c6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     c6f:	e8 fc ff ff ff       	call   c70 <fsm_post_msg+0x10>
     c74:	89 cf                	mov    %ecx,%edi
     c76:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c79:	89 d6                	mov    %edx,%esi
     c7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c7e:	89 c8                	mov    %ecx,%eax
     c80:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     c83:	e8 fc ff ff ff       	call   c84 <fsm_post_msg+0x24>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     c8b:	89 f2                	mov    %esi,%edx
}

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c8d:	89 c3                	mov    %eax,%ebx
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c8f:	e8 fc ff ff ff       	call   c90 <fsm_post_msg+0x30>
evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
	fsm_mem_cpy(buffer, msg_ptr, size);
	return	__fsm_tm_ev_add(0, FSM_EV_TYPE_MSG, code, NULL, fsm_core.current_fsm, dst_id, buffer);
     c94:	a1 20 00 00 00       	mov    0x20,%eax
     c99:	ba 06 00 00 00       	mov    $0x6,%edx
     c9e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     ca1:	89 04 24             	mov    %eax,(%esp)
     ca4:	31 c0                	xor    %eax,%eax
     ca6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     caa:	89 7c 24 04          	mov    %edi,0x4(%esp)
     cae:	e8 8d fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     cb3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     cb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
     cb9:	8b 7d fc             	mov    -0x4(%ebp),%edi
     cbc:	89 ec                	mov    %ebp,%esp
     cbe:	5d                   	pop    %ebp
     cbf:	c3                   	ret    

00000cc0 <fsm_schedule_cancel>:

int fsm_schedule_cancel(evHandle eh)
{
     cc0:	55                   	push   %ebp
     cc1:	89 e5                	mov    %esp,%ebp
     cc3:	56                   	push   %esi
     cc4:	53                   	push   %ebx
     cc5:	e8 fc ff ff ff       	call   cc6 <fsm_schedule_cancel+0x6>
     cca:	89 c3                	mov    %eax,%ebx
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
     ccc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
     cd1:	81 7b 04 d6 96 0f 04 	cmpl   $0x40f96d6,0x4(%ebx)
     cd8:	75 43                	jne    d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
     cda:	8b 35 88 02 00 00    	mov    0x288,%esi
     ce0:	85 f6                	test   %esi,%esi
     ce2:	74 39                	je     d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     ce4:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     ce9:	e8 fc ff ff ff       	call   cea <fsm_schedule_cancel+0x2a>
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cee:	8b 15 88 02 00 00    	mov    0x288,%edx
     cf4:	39 d3                	cmp    %edx,%ebx
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     cf6:	89 c6                	mov    %eax,%esi
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cf8:	75 0c                	jne    d06 <fsm_schedule_cancel+0x46>
     cfa:	eb 49                	jmp    d45 <fsm_schedule_cancel+0x85>
     cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
     d00:	39 c3                	cmp    %eax,%ebx
     d02:	74 24                	je     d28 <fsm_schedule_cancel+0x68>
     d04:	89 c2                	mov    %eax,%edx
     d06:	8b 02                	mov    (%edx),%eax
     d08:	85 c0                	test   %eax,%eax
     d0a:	75 f4                	jne    d00 <fsm_schedule_cancel+0x40>
     d0c:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d11:	89 f2                	mov    %esi,%edx
     d13:	e8 fc ff ff ff       	call   d14 <fsm_schedule_cancel+0x54>
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
     d18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d1d:	5b                   	pop    %ebx
     d1e:	5e                   	pop    %esi
     d1f:	5d                   	pop    %ebp
     d20:	c3                   	ret    
     d21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
		p0 = p0->pNext;
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
     d28:	8b 03                	mov    (%ebx),%eax
     d2a:	89 02                	mov    %eax,(%edx)
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d2c:	89 d8                	mov    %ebx,%eax
     d2e:	e8 fc ff ff ff       	call   d2f <fsm_schedule_cancel+0x6f>
     d33:	89 f2                	mov    %esi,%edx
     d35:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d3a:	e8 fc ff ff ff       	call   d3b <fsm_schedule_cancel+0x7b>
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
     d3f:	31 c0                	xor    %eax,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d41:	5b                   	pop    %ebx
     d42:	5e                   	pop    %esi
     d43:	5d                   	pop    %ebp
     d44:	c3                   	ret    
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d45:	8b 03                	mov    (%ebx),%eax
		if(pB->tm_state != FSM_TM_EXPIRE)
     d47:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d4e:	a3 88 02 00 00       	mov    %eax,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     d53:	74 05                	je     d5a <fsm_schedule_cancel+0x9a>
		{
			__fsm_tm_restart();
     d55:	e8 d6 f3 ff ff       	call   130 <__fsm_tm_restart>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d5a:	89 d8                	mov    %ebx,%eax
     d5c:	e8 fc ff ff ff       	call   d5d <fsm_schedule_cancel+0x9d>
		if(pB->tm_state != FSM_TM_EXPIRE)
		{
			__fsm_tm_restart();
		}
		fsm_mem_free(pE);
		if(!pB->evQ)
     d61:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     d67:	85 db                	test   %ebx,%ebx
     d69:	75 c8                	jne    d33 <fsm_schedule_cancel+0x73>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
     d6b:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
     d70:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     d77:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
     d7a:	e8 fc ff ff ff       	call   d7b <fsm_schedule_cancel+0xbb>
     d7f:	eb b2                	jmp    d33 <fsm_schedule_cancel+0x73>
     d81:	eb 0d                	jmp    d90 <fsm_do_ioctrl>
     d83:	90                   	nop
     d84:	90                   	nop
     d85:	90                   	nop
     d86:	90                   	nop
     d87:	90                   	nop
     d88:	90                   	nop
     d89:	90                   	nop
     d8a:	90                   	nop
     d8b:	90                   	nop
     d8c:	90                   	nop
     d8d:	90                   	nop
     d8e:	90                   	nop
     d8f:	90                   	nop

00000d90 <fsm_do_ioctrl>:
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     d90:	55                   	push   %ebp
     d91:	89 e5                	mov    %esp,%ebp
     d93:	83 ec 14             	sub    $0x14,%esp
     d96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     d99:	89 75 f8             	mov    %esi,-0x8(%ebp)
     d9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     d9f:	e8 fc ff ff ff       	call   da0 <fsm_do_ioctrl+0x10>
     da4:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     da7:	c1 e0 04             	shl    $0x4,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     daa:	89 d6                	mov    %edx,%esi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     dac:	8b 90 4c 00 00 00    	mov    0x4c(%eax),%edx
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     db2:	b8 18 00 00 00       	mov    $0x18,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     db7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dba:	89 55 ec             	mov    %edx,-0x14(%ebp)
     dbd:	e8 fc ff ff ff       	call   dbe <fsm_do_ioctrl+0x2e>
	ev_ptr->dev =dev;
     dc2:	8b 55 ec             	mov    -0x14(%ebp),%edx
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     dc5:	85 ff                	test   %edi,%edi
int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dc7:	89 c3                	mov    %eax,%ebx
	ev_ptr->dev =dev;
     dc9:	89 10                	mov    %edx,(%eax)
	ev_ptr->ifr.cmd = cmd;
     dcb:	89 70 04             	mov    %esi,0x4(%eax)
	ev_ptr->ifr.size = size;
     dce:	89 78 08             	mov    %edi,0x8(%eax)
	if(data_ptr != NULL && size > 0)
     dd1:	75 65                	jne    e38 <fsm_do_ioctrl+0xa8>
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
		fsm_mem_cpy(ev_ptr->ifr.buffer, data_ptr, size);
		}
	else
		{
		ev_ptr->ifr.buffer = NULL;
     dd3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     dda:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     ddf:	e8 fc ff ff ff       	call   de0 <fsm_do_ioctrl+0x50>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     de4:	a1 d8 02 00 00       	mov    0x2d8,%eax
		}
	spin_lock(&fsm_core.ioctl_list_lock);
	list_add_tail(&ev_ptr->list_node, &fsm_core.do_ioctl_list);
     de9:	8d 53 10             	lea    0x10(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     dec:	89 15 d8 02 00 00    	mov    %edx,0x2d8
	new->next = next;
     df2:	c7 43 10 d4 02 00 00 	movl   $0x2d4,0x10(%ebx)
	new->prev = prev;
     df9:	89 43 14             	mov    %eax,0x14(%ebx)
	prev->next = new;
     dfc:	89 10                	mov    %edx,(%eax)
	return PVOP_CALL1(int, pv_lock_ops.spin_trylock, lock);
}

static __always_inline void arch_spin_unlock(struct arch_spinlock *lock)
{
	PVOP_VCALL1(pv_lock_ops.spin_unlock, lock);
     dfe:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     e03:	ff 15 14 00 00 00    	call   *0x14
	spin_unlock(&fsm_core.ioctl_list_lock);
	tasklet_schedule(fsm_core.do_ioctl_tsklt);
     e09:	a1 c8 02 00 00       	mov    0x2c8,%eax
     e0e:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     e14:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     e16:	85 d2                	test   %edx,%edx
     e18:	75 05                	jne    e1f <fsm_do_ioctrl+0x8f>
		__tasklet_schedule(t);
     e1a:	e8 fc ff ff ff       	call   e1b <fsm_do_ioctrl+0x8b>
	return 1;
}
     e1f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e22:	b8 01 00 00 00       	mov    $0x1,%eax
     e27:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e2a:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e2d:	89 ec                	mov    %ebp,%esp
     e2f:	5d                   	pop    %ebp
     e30:	c3                   	ret    
     e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e3b:	85 c0                	test   %eax,%eax
     e3d:	74 94                	je     dd3 <fsm_do_ioctrl+0x43>
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e3f:	89 f8                	mov    %edi,%eax
     e41:	e8 fc ff ff ff       	call   e42 <fsm_do_ioctrl+0xb2>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
     e49:	89 f9                	mov    %edi,%ecx
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e4b:	89 43 0c             	mov    %eax,0xc(%ebx)
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e4e:	e8 fc ff ff ff       	call   e4f <fsm_do_ioctrl+0xbf>
     e53:	eb 85                	jmp    dda <fsm_do_ioctrl+0x4a>
     e55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000e60 <fsm_ioctrl_arrival>:
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e60:	55                   	push   %ebp
     e61:	89 e5                	mov    %esp,%ebp
     e63:	83 ec 28             	sub    $0x28,%esp
     e66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     e69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     e6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     e6f:	e8 fc ff ff ff       	call   e70 <fsm_ioctrl_arrival+0x10>
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e74:	81 fa f0 89 00 00    	cmp    $0x89f0,%edx
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e7a:	89 c3                	mov    %eax,%ebx
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e7c:	0f 84 b6 00 00 00    	je     f38 <fsm_ioctrl_arrival+0xd8>
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		}	
	else if(cmd == IOCUSER)	
     e82:	81 fa f1 89 00 00    	cmp    $0x89f1,%edx
     e88:	74 16                	je     ea0 <fsm_ioctrl_arrival+0x40>
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
		}
	
	return 1;
}
     e8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e8d:	b8 01 00 00 00       	mov    $0x1,%eax
     e92:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e95:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e98:	89 ec                	mov    %ebp,%esp
     e9a:	5d                   	pop    %ebp
     e9b:	c3                   	ret    
     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					  unsigned long n)
{
	int sz = __compiletime_object_size(to);

	if (likely(sz == -1 || sz >= n))
		n = _copy_from_user(to, from, n);
     ea0:	8b 50 10             	mov    0x10(%eax),%edx
     ea3:	b9 0c 00 00 00       	mov    $0xc,%ecx
     ea8:	8d 45 e8             	lea    -0x18(%ebp),%eax
     eab:	e8 fc ff ff ff       	call   eac <fsm_ioctrl_arrival+0x4c>
	else if(cmd == IOCUSER)	
		{		
		uifr_ptr = ifr;		
		copy_from_user(&kifr, uifr_ptr->ifr_ifru.ifru_data, sizeof(struct kifreq)); 	
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
     eb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     eb3:	85 c0                	test   %eax,%eax
     eb5:	0f 84 cd 00 00 00    	je     f88 <fsm_ioctrl_arrival+0x128>
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
     ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
     ebe:	e8 fc ff ff ff       	call   ebf <fsm_ioctrl_arrival+0x5f>
     ec3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     ec6:	8b 55 f0             	mov    -0x10(%ebp),%edx
     ec9:	89 c6                	mov    %eax,%esi
     ecb:	e8 fc ff ff ff       	call   ecc <fsm_ioctrl_arrival+0x6c>
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ed0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     ed5:	e8 fc ff ff ff       	call   ed6 <fsm_ioctrl_arrival+0x76>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     eda:	31 c9                	xor    %ecx,%ecx
     edc:	ba 02 00 00 00       	mov    $0x2,%edx
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ee1:	89 c7                	mov    %eax,%edi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     ee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
     ee6:	89 74 24 08          	mov    %esi,0x8(%esp)
     eea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     ef1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ef5:	a1 8c 02 00 00       	mov    0x28c,%eax
     efa:	89 44 24 04          	mov    %eax,0x4(%esp)
     efe:	b8 05 00 00 00       	mov    $0x5,%eax
     f03:	e8 28 f5 ff ff       	call   430 <__fsm_core_self_drive>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     f08:	89 fa                	mov    %edi,%edx
     f0a:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f0f:	e8 fc ff ff ff       	call   f10 <fsm_ioctrl_arrival+0xb0>
			spin_unlock_irqrestore(&fsm_core.lock, flags2);
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
     f14:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     f17:	89 f2                	mov    %esi,%edx
     f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f1c:	e8 fc ff ff ff       	call   f1d <fsm_ioctrl_arrival+0xbd>
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
			spin_unlock_irqrestore(&fsm_core.lock, flags2);		
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
     f21:	8b 43 10             	mov    0x10(%ebx),%eax
     f24:	b9 0c 00 00 00       	mov    $0xc,%ecx
     f29:	8d 55 e8             	lea    -0x18(%ebp),%edx
     f2c:	e8 fc ff ff ff       	call   f2d <fsm_ioctrl_arrival+0xcd>
     f31:	e9 54 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f36:	66 90                	xchg   %ax,%ax
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f38:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f3d:	e8 fc ff ff ff       	call   f3e <fsm_ioctrl_arrival+0xde>
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f42:	31 c9                	xor    %ecx,%ecx
     f44:	ba 02 00 00 00       	mov    $0x2,%edx
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f49:	89 c6                	mov    %eax,%esi
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f4b:	8b 03                	mov    (%ebx),%eax
     f4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     f54:	89 44 24 0c          	mov    %eax,0xc(%esp)
     f58:	8b 43 08             	mov    0x8(%ebx),%eax
     f5b:	89 44 24 08          	mov    %eax,0x8(%esp)
     f5f:	a1 8c 02 00 00       	mov    0x28c,%eax
     f64:	89 44 24 04          	mov    %eax,0x4(%esp)
     f68:	b8 05 00 00 00       	mov    $0x5,%eax
     f6d:	e8 be f4 ff ff       	call   430 <__fsm_core_self_drive>
     f72:	89 f2                	mov    %esi,%edx
     f74:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f79:	e8 fc ff ff ff       	call   f7a <fsm_ioctrl_arrival+0x11a>
     f7e:	e9 07 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f83:	90                   	nop
     f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f88:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f8d:	e8 fc ff ff ff       	call   f8e <fsm_ioctrl_arrival+0x12e>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f92:	31 c9                	xor    %ecx,%ecx
     f94:	ba 02 00 00 00       	mov    $0x2,%edx
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f99:	89 c6                	mov    %eax,%esi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     f9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     fa5:	00 
     fa6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     fad:	89 44 24 0c          	mov    %eax,0xc(%esp)
     fb1:	a1 8c 02 00 00       	mov    0x28c,%eax
     fb6:	89 44 24 04          	mov    %eax,0x4(%esp)
     fba:	b8 05 00 00 00       	mov    $0x5,%eax
     fbf:	e8 6c f4 ff ff       	call   430 <__fsm_core_self_drive>
     fc4:	89 f2                	mov    %esi,%edx
     fc6:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     fcb:	e8 fc ff ff ff       	call   fcc <fsm_ioctrl_arrival+0x16c>
     fd0:	e9 4c ff ff ff       	jmp    f21 <fsm_ioctrl_arrival+0xc1>
     fd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000fe0 <fsm_get_curtime>:



/* Time get */
u32 fsm_get_curtime()
{
     fe0:	55                   	push   %ebp
     fe1:	89 e5                	mov    %esp,%ebp
     fe3:	e8 fc ff ff ff       	call   fe4 <fsm_get_curtime+0x4>
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
     fe8:	e8 fc ff ff ff       	call   fe9 <fsm_get_curtime+0x9>
	cur_time = ktime_to_timeval(ktime);
     fed:	e8 fc ff ff ff       	call   fee <fsm_get_curtime+0xe>
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
	ctm = ctm/10;
     ff2:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
	return ctm;
}
     ff7:	5d                   	pop    %ebp
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
	cur_time = ktime_to_timeval(ktime);
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
     ff8:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
     ffe:	01 c2                	add    %eax,%edx
	ctm = ctm/10;
    1000:	89 d0                	mov    %edx,%eax
    1002:	f7 e1                	mul    %ecx
    1004:	c1 ea 03             	shr    $0x3,%edx
	return ctm;
}
    1007:	89 d0                	mov    %edx,%eax
    1009:	c3                   	ret    
    100a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00001010 <fsm_get_random_bytes>:


/* Random bytes get*/
void fsm_get_random_bytes(void *buf, int nbytes)
{
    1010:	55                   	push   %ebp
    1011:	89 e5                	mov    %esp,%ebp
    1013:	e8 fc ff ff ff       	call   1014 <fsm_get_random_bytes+0x4>
	GET_RANDOM_BYTES(buf, nbytes);
    1018:	e8 fc ff ff ff       	call   1019 <fsm_get_random_bytes+0x9>
}
    101d:	5d                   	pop    %ebp
    101e:	c3                   	ret    
    101f:	90                   	nop

00001020 <fsm_core_create>:


/* FSM core operations */

void fsm_core_create(void* dev)
{
    1020:	55                   	push   %ebp
    1021:	89 e5                	mov    %esp,%ebp
    1023:	e8 fc ff ff ff       	call   1024 <fsm_core_create+0x4>
	int i;
	fsm_core.current_fsm = -1;
    1028:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
    102f:	ff ff ff 
	fsm_core.current_state_ptr = NULL;
    1032:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
    1039:	00 00 00 
	fsm_core.state = CORE_CLOSED;
    103c:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    1043:	00 00 00 
	fsm_core.pkptr = 0;
    1046:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
    104d:	00 00 00 
	fsm_core.evtype = 0;
    1050:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
    1057:	00 00 00 
	fsm_core.code = 0;
	fsm_core.src = 0;
	fsm_core.dev = dev;
    105a:	a3 a8 02 00 00       	mov    %eax,0x2a8
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
    105f:	b8 44 00 00 00       	mov    $0x44,%eax
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
	fsm_core.state = CORE_CLOSED;
	fsm_core.pkptr = 0;
	fsm_core.evtype = 0;
	fsm_core.code = 0;
    1064:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
    106b:	00 00 00 
	fsm_core.src = 0;
    106e:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
    1075:	00 00 00 
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
    1078:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
    107f:	00 00 00 
	fsm_core.fsm_drive = NULL;
    1082:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
    1089:	00 00 00 
	MAIN_PORT = -1;
    108c:	c7 05 8c 02 00 00 ff 	movl   $0xffffffff,0x28c
    1093:	ff ff ff 
    1096:	66 90                	xchg   %ax,%ax
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    1098:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    109e:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    10a4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    10ab:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    10b2:	83 c0 10             	add    $0x10,%eax
	fsm_core.src = 0;
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
	for(i = 0; i < MAX_INTF; i++)
    10b5:	3d 44 02 00 00       	cmp    $0x244,%eax
    10ba:	75 dc                	jne    1098 <fsm_core_create+0x78>
		FSM[i] = NULL;
	}
	fsm_core.buffer = NULL;
	fsm_core.ioctrl_cmd = 0;
	spin_lock_init(&fsm_core.lock);
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    10bc:	b8 10 00 00 00       	mov    $0x10,%eax
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	for(i = 0; i < MAX_FSM; ++i)
	{
		FSM[i] = NULL;
    10c1:	c7 05 90 02 00 00 00 	movl   $0x0,0x290
    10c8:	00 00 00 
    10cb:	c7 05 94 02 00 00 00 	movl   $0x0,0x294
    10d2:	00 00 00 
    10d5:	c7 05 98 02 00 00 00 	movl   $0x0,0x298
    10dc:	00 00 00 
    10df:	c7 05 9c 02 00 00 00 	movl   $0x0,0x29c
    10e6:	00 00 00 
    10e9:	c7 05 a0 02 00 00 00 	movl   $0x0,0x2a0
    10f0:	00 00 00 
    10f3:	c7 05 a4 02 00 00 00 	movl   $0x0,0x2a4
    10fa:	00 00 00 
	}
	fsm_core.buffer = NULL;
    10fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
    1104:	00 00 00 
	fsm_core.ioctrl_cmd = 0;
    1107:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
    110e:	00 00 00 
	spin_lock_init(&fsm_core.lock);
    1111:	66 c7 05 b4 02 00 00 	movw   $0x0,0x2b4
    1118:	00 00 
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    111a:	e8 fc ff ff ff       	call   111b <fsm_core_create+0xfb>
    111f:	a3 b8 02 00 00       	mov    %eax,0x2b8
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    1124:	b8 10 00 00 00       	mov    $0x10,%eax
    1129:	e8 fc ff ff ff       	call   112a <fsm_core_create+0x10a>
    112e:	a3 bc 02 00 00       	mov    %eax,0x2bc
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1133:	b8 14 00 00 00       	mov    $0x14,%eax
    1138:	e8 fc ff ff ff       	call   1139 <fsm_core_create+0x119>
    113d:	a3 c0 02 00 00       	mov    %eax,0x2c0
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1142:	b8 14 00 00 00       	mov    $0x14,%eax
    1147:	e8 fc ff ff ff       	call   1148 <fsm_core_create+0x128>
    114c:	a3 c4 02 00 00       	mov    %eax,0x2c4
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1151:	b8 14 00 00 00       	mov    $0x14,%eax
    1156:	e8 fc ff ff ff       	call   1157 <fsm_core_create+0x137>
    115b:	a3 c8 02 00 00       	mov    %eax,0x2c8
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1160:	b8 14 00 00 00       	mov    $0x14,%eax
    1165:	e8 fc ff ff ff       	call   1166 <fsm_core_create+0x146>
	return; 
}
    116a:	5d                   	pop    %ebp
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    116b:	a3 cc 02 00 00       	mov    %eax,0x2cc
	return; 
}
    1170:	c3                   	ret    
    1171:	eb 0d                	jmp    1180 <fsm_core_intf_set>
    1173:	90                   	nop
    1174:	90                   	nop
    1175:	90                   	nop
    1176:	90                   	nop
    1177:	90                   	nop
    1178:	90                   	nop
    1179:	90                   	nop
    117a:	90                   	nop
    117b:	90                   	nop
    117c:	90                   	nop
    117d:	90                   	nop
    117e:	90                   	nop
    117f:	90                   	nop

00001180 <fsm_core_intf_set>:
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    1180:	55                   	push   %ebp
    1181:	89 e5                	mov    %esp,%ebp
    1183:	83 ec 10             	sub    $0x10,%esp
    1186:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1189:	89 75 f8             	mov    %esi,-0x8(%ebp)
    118c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    118f:	e8 fc ff ff ff       	call   1190 <fsm_core_intf_set+0x10>
    1194:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV *dev = NULL;
	switch(type)
    1197:	83 fa 01             	cmp    $0x1,%edx
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    119a:	89 c3                	mov    %eax,%ebx
    119c:	89 ce                	mov    %ecx,%esi
	NETDEV *dev = NULL;
	switch(type)
    119e:	0f 84 bc 00 00 00    	je     1260 <fsm_core_intf_set+0xe0>
    11a4:	72 3a                	jb     11e0 <fsm_core_intf_set+0x60>
    11a6:	83 fa 02             	cmp    $0x2,%edx
    11a9:	74 55                	je     1200 <fsm_core_intf_set+0x80>
		INTF[index].proto = htons(proto);
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_xmit;
		break;
	}
	if(proto == 0 && dev_name == 0)
    11ab:	85 ff                	test   %edi,%edi
    11ad:	8d 76 00             	lea    0x0(%esi),%esi
    11b0:	75 1c                	jne    11ce <fsm_core_intf_set+0x4e>
    11b2:	66 85 f6             	test   %si,%si
    11b5:	75 17                	jne    11ce <fsm_core_intf_set+0x4e>
		{
		INTF[index].valid = DEV_INTF_NULL;
    11b7:	c1 e3 04             	shl    $0x4,%ebx
    11ba:	c7 83 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
    11c1:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11c4:	c7 83 50 00 00 00 20 	movl   $0x120,0x50(%ebx)
    11cb:	01 00 00 
		}
	return;
}
    11ce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    11d1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    11d4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    11d7:	89 ec                	mov    %ebp,%esp
    11d9:	5d                   	pop    %ebp
    11da:	c3                   	ret    
    11db:	90                   	nop
    11dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	NETDEV *dev = NULL;
	switch(type)
	{
	case DEV_INTF_NULL:
		INTF[index].valid = DEV_INTF_NULL;
    11e0:	c1 e0 04             	shl    $0x4,%eax
    11e3:	c7 80 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    11ea:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11ed:	c7 80 50 00 00 00 20 	movl   $0x120,0x50(%eax)
    11f4:	01 00 00 
		break;
    11f7:	eb b2                	jmp    11ab <fsm_core_intf_set+0x2b>
    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	case DEV_INTF_IND:
		if(dev_name)
    1200:	85 ff                	test   %edi,%edi
    1202:	0f 84 b8 00 00 00    	je     12c0 <fsm_core_intf_set+0x140>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1208:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].valid = DEV_INTF_NULL;
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    120d:	89 fa                	mov    %edi,%edx
    120f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1215:	e8 fc ff ff ff       	call   1216 <fsm_core_intf_set+0x96>
		INTF[index].valid = DEV_INTF_IND;
    121a:	8d 53 02             	lea    0x2(%ebx),%edx
    121d:	89 d1                	mov    %edx,%ecx
    121f:	c1 e1 04             	shl    $0x4,%ecx
    1222:	c7 81 24 00 00 00 02 	movl   $0x2,0x24(%ecx)
    1229:	00 00 00 
		INTF[index].proto = htons(proto);
    122c:	0f b7 ce             	movzwl %si,%ecx
    122f:	c1 e1 08             	shl    $0x8,%ecx
    1232:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1235:	89 f1                	mov    %esi,%ecx
    1237:	66 c1 e9 08          	shr    $0x8,%cx
    123b:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    123f:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    1242:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    1248:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_netrx;
    124f:	c7 82 30 00 00 00 30 	movl   $0x230,0x30(%edx)
    1256:	02 00 00 
		break;
    1259:	e9 4d ff ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    125e:	66 90                	xchg   %ax,%ax
	case DEV_INTF_REQ:
		if(dev_name)
    1260:	85 ff                	test   %edi,%edi
    1262:	74 7c                	je     12e0 <fsm_core_intf_set+0x160>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1264:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    1269:	89 fa                	mov    %edi,%edx
    126b:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1271:	e8 fc ff ff ff       	call   1272 <fsm_core_intf_set+0xf2>
		INTF[index].valid = DEV_INTF_REQ;
    1276:	8d 53 02             	lea    0x2(%ebx),%edx
    1279:	89 d1                	mov    %edx,%ecx
    127b:	c1 e1 04             	shl    $0x4,%ecx
    127e:	c7 81 24 00 00 00 01 	movl   $0x1,0x24(%ecx)
    1285:	00 00 00 
		INTF[index].proto = htons(proto);
    1288:	0f b7 ce             	movzwl %si,%ecx
    128b:	c1 e1 08             	shl    $0x8,%ecx
    128e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1291:	89 f1                	mov    %esi,%ecx
    1293:	66 c1 e9 08          	shr    $0x8,%cx
    1297:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    129b:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    129e:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    12a4:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_xmit;
    12ab:	c7 82 30 00 00 00 d0 	movl   $0x1d0,0x30(%edx)
    12b2:	01 00 00 
		break;
    12b5:	e9 f1 fe ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    12ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12c3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c6:	89 d0                	mov    %edx,%eax
    12c8:	c1 e0 04             	shl    $0x4,%eax
    12cb:	c7 80 24 00 00 00 02 	movl   $0x2,0x24(%eax)
    12d2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12d5:	31 c0                	xor    %eax,%eax
    12d7:	e9 53 ff ff ff       	jmp    122f <fsm_core_intf_set+0xaf>
    12dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12e3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e6:	89 d0                	mov    %edx,%eax
    12e8:	c1 e0 04             	shl    $0x4,%eax
    12eb:	c7 80 24 00 00 00 01 	movl   $0x1,0x24(%eax)
    12f2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12f5:	31 c0                	xor    %eax,%eax
    12f7:	eb 92                	jmp    128b <fsm_core_intf_set+0x10b>
    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001300 <fsm_core_open>:
	return;
}


int fsm_core_open()
{
    1300:	55                   	push   %ebp
    1301:	89 e5                	mov    %esp,%ebp
    1303:	53                   	push   %ebx
    1304:	83 ec 10             	sub    $0x10,%esp
    1307:	e8 fc ff ff ff       	call   1308 <fsm_core_open+0x8>
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
    130c:	a1 28 00 00 00       	mov    0x28,%eax
    1311:	85 c0                	test   %eax,%eax
    1313:	0f 85 54 01 00 00    	jne    146d <fsm_core_open+0x16d>
	{
	fsm_printf("core is opening.\n");
    1319:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    1320:	e8 fc ff ff ff       	call   1321 <fsm_core_open+0x21>
	spin_lock_irqsave(&fsm_core.lock, flags);
    1325:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    132a:	e8 fc ff ff ff       	call   132b <fsm_core_open+0x2b>
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    132f:	31 c9                	xor    %ecx,%ecx
    1331:	ba 50 00 00 00       	mov    $0x50,%edx
{
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
	{
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
    1336:	89 c3                	mov    %eax,%ebx
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
    1338:	a1 b8 02 00 00       	mov    0x2b8,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    133d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    1343:	89 00                	mov    %eax,(%eax)
    1345:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    1348:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	skb_queue_head_init(fsm_core.rx_queue);
    134f:	a1 bc 02 00 00       	mov    0x2bc,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    1354:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    135a:	89 00                	mov    %eax,(%eax)
    135c:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    135f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    1366:	a1 c0 02 00 00       	mov    0x2c0,%eax
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
    136b:	66 c7 05 d0 02 00 00 	movw   $0x0,0x2d0
    1372:	00 00 
	spin_lock_init(&fsm_core.rx_queue_lock);
    1374:	66 c7 05 d2 02 00 00 	movw   $0x0,0x2d2
    137b:	00 00 
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    137d:	e8 fc ff ff ff       	call   137e <fsm_core_open+0x7e>
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
    1382:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1387:	31 c9                	xor    %ecx,%ecx
    1389:	ba 00 00 00 00       	mov    $0x0,%edx
    138e:	e8 fc ff ff ff       	call   138f <fsm_core_open+0x8f>
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    1393:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1398:	31 c9                	xor    %ecx,%ecx
    139a:	ba a0 00 00 00       	mov    $0xa0,%edx
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
    139f:	66 c7 05 e4 02 00 00 	movw   $0x0,0x2e4
    13a6:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13a8:	c7 05 d4 02 00 00 d4 	movl   $0x2d4,0x2d4
    13af:	02 00 00 
	list->prev = list;
    13b2:	c7 05 d8 02 00 00 d4 	movl   $0x2d4,0x2d8
    13b9:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    13bc:	e8 fc ff ff ff       	call   13bd <fsm_core_open+0xbd>
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13c1:	a1 cc 02 00 00       	mov    0x2cc,%eax
    13c6:	31 c9                	xor    %ecx,%ecx
    13c8:	ba 10 09 00 00       	mov    $0x910,%edx
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
    13cd:	66 c7 05 e6 02 00 00 	movw   $0x0,0x2e6
    13d4:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13d6:	c7 05 dc 02 00 00 dc 	movl   $0x2dc,0x2dc
    13dd:	02 00 00 
	list->prev = list;
    13e0:	c7 05 e0 02 00 00 dc 	movl   $0x2dc,0x2e0
    13e7:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13ea:	e8 fc ff ff ff       	call   13eb <fsm_core_open+0xeb>
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	pB->evQ = 0;
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    13ef:	31 c9                	xor    %ecx,%ecx
    13f1:	ba 01 00 00 00       	mov    $0x1,%edx
    13f6:	b8 48 02 00 00       	mov    $0x248,%eax
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
    13fb:	66 c7 05 e8 02 00 00 	movw   $0x0,0x2e8
    1402:	00 00 

static void __fsm_tm_init()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    1404:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    140b:	00 00 00 
	pB->evQ = 0;
    140e:	c7 05 88 02 00 00 00 	movl   $0x0,0x288
    1415:	00 00 00 
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    1418:	e8 fc ff ff ff       	call   1419 <fsm_core_open+0x119>
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    141d:	a1 8c 02 00 00       	mov    0x28c,%eax
    1422:	31 c9                	xor    %ecx,%ecx
    1424:	31 d2                	xor    %edx,%edx
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
    1426:	c7 05 28 00 00 00 01 	movl   $0x1,0x28
    142d:	00 00 00 
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1430:	89 44 24 04          	mov    %eax,0x4(%esp)
    1434:	b8 05 00 00 00       	mov    $0x5,%eax
    1439:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1440:	00 
    1441:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1448:	00 
    1449:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1450:	e8 db ef ff ff       	call   430 <__fsm_core_self_drive>
    1455:	89 da                	mov    %ebx,%edx
    1457:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    145c:	e8 fc ff ff ff       	call   145d <fsm_core_open+0x15d>
	spin_unlock_irqrestore(&fsm_core.lock, flags);
	fsm_printf("core has opened.\n");
    1461:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
    1468:	e8 fc ff ff ff       	call   1469 <fsm_core_open+0x169>
	}
	return FSM_EXEC_SUCC;
}
    146d:	83 c4 10             	add    $0x10,%esp
    1470:	31 c0                	xor    %eax,%eax
    1472:	5b                   	pop    %ebx
    1473:	5d                   	pop    %ebp
    1474:	c3                   	ret    
    1475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001480 <fsm_core_close>:

int fsm_core_close()
{
    1480:	55                   	push   %ebp
    1481:	89 e5                	mov    %esp,%ebp
    1483:	57                   	push   %edi
    1484:	56                   	push   %esi
    1485:	53                   	push   %ebx
    1486:	83 ec 10             	sub    $0x10,%esp
    1489:	e8 fc ff ff ff       	call   148a <fsm_core_close+0xa>
	struct evioctl *ev_ptr, *tmp_ptr;
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
    148e:	a1 28 00 00 00       	mov    0x28,%eax
    1493:	85 c0                	test   %eax,%eax
    1495:	75 11                	jne    14a8 <fsm_core_close+0x28>
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    1497:	83 c4 10             	add    $0x10,%esp
    149a:	31 c0                	xor    %eax,%eax
    149c:	5b                   	pop    %ebx
    149d:	5e                   	pop    %esi
    149e:	5f                   	pop    %edi
    149f:	5d                   	pop    %ebp
    14a0:	c3                   	ret    
    14a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
		return FSM_EXEC_SUCC;
	spin_lock_irqsave(&fsm_core.lock, flags2);
    14a8:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    14ad:	e8 fc ff ff ff       	call   14ae <fsm_core_close+0x2e>
    14b2:	89 c7                	mov    %eax,%edi
	fsm_printf("core is closing.\n");
    14b4:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
    14bb:	e8 fc ff ff ff       	call   14bc <fsm_core_close+0x3c>
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    14c0:	a1 8c 02 00 00       	mov    0x28c,%eax
    14c5:	31 c9                	xor    %ecx,%ecx
    14c7:	ba 01 00 00 00       	mov    $0x1,%edx
    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    14d0:	b8 05 00 00 00       	mov    $0x5,%eax
    14d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    14dc:	00 
    14dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    14e4:	00 
    14e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    14ec:	e8 3f ef ff ff       	call   430 <__fsm_core_self_drive>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
    14f1:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    14f6:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    14fd:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
    1500:	e8 fc ff ff ff       	call   1501 <fsm_core_close+0x81>
{
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
    1505:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    150a:	e8 fc ff ff ff       	call   150b <fsm_core_close+0x8b>
    150f:	89 c3                	mov    %eax,%ebx
	while(pB->evQ)
    1511:	a1 88 02 00 00       	mov    0x288,%eax
    1516:	85 c0                	test   %eax,%eax
    1518:	74 1c                	je     1536 <fsm_core_close+0xb6>
    151a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		pE = pB->evQ;
		pB->evQ = pE->pNext;
    1520:	8b 10                	mov    (%eax),%edx
    1522:	89 15 88 02 00 00    	mov    %edx,0x288
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1528:	e8 fc ff ff ff       	call   1529 <fsm_core_close+0xa9>
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	while(pB->evQ)
    152d:	a1 88 02 00 00       	mov    0x288,%eax
    1532:	85 c0                	test   %eax,%eax
    1534:	75 ea                	jne    1520 <fsm_core_close+0xa0>
    1536:	89 da                	mov    %ebx,%edx
    1538:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    153d:	e8 fc ff ff ff       	call   153e <fsm_core_close+0xbe>
	fsm_printf("core is closing.\n");
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
	__fsm_tm_stop();
	__fsm_tm_flush();
	//Cancel tasklets
	tasklet_kill(fsm_core.tx_tsklt);
    1542:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1547:	e8 fc ff ff ff       	call   1548 <fsm_core_close+0xc8>
	tasklet_kill(fsm_core.rx_tsklt);
    154c:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1551:	e8 fc ff ff ff       	call   1552 <fsm_core_close+0xd2>
	tasklet_kill(fsm_core.do_ioctl_tsklt);
    1556:	a1 c8 02 00 00       	mov    0x2c8,%eax
    155b:	e8 fc ff ff ff       	call   155c <fsm_core_close+0xdc>
	tasklet_kill(fsm_core.exp_ev_tsklt);	
    1560:	a1 cc 02 00 00       	mov    0x2cc,%eax
    1565:	e8 fc ff ff ff       	call   1566 <fsm_core_close+0xe6>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    156a:	a1 b8 02 00 00       	mov    0x2b8,%eax
    156f:	3b 00                	cmp    (%eax),%eax
    1571:	74 2f                	je     15a2 <fsm_core_close+0x122>
    1573:	90                   	nop
    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
    1578:	e8 fc ff ff ff       	call   1579 <fsm_core_close+0xf9>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    157d:	e8 fc ff ff ff       	call   157e <fsm_core_close+0xfe>
	tasklet_kill(fsm_core.tx_tsklt);
	tasklet_kill(fsm_core.rx_tsklt);
	tasklet_kill(fsm_core.do_ioctl_tsklt);
	tasklet_kill(fsm_core.exp_ev_tsklt);	
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    1582:	a1 b8 02 00 00       	mov    0x2b8,%eax
    1587:	3b 00                	cmp    (%eax),%eax
    1589:	75 ed                	jne    1578 <fsm_core_close+0xf8>
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    158b:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1590:	3b 00                	cmp    (%eax),%eax
    1592:	74 17                	je     15ab <fsm_core_close+0x12b>
    1594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
    1598:	e8 fc ff ff ff       	call   1599 <fsm_core_close+0x119>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    159d:	e8 fc ff ff ff       	call   159e <fsm_core_close+0x11e>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    15a2:	a1 bc 02 00 00       	mov    0x2bc,%eax
    15a7:	3b 00                	cmp    (%eax),%eax
    15a9:	75 ed                	jne    1598 <fsm_core_close+0x118>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    15ab:	8b 1d d4 02 00 00    	mov    0x2d4,%ebx
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
	}
	if(!list_empty(&fsm_core.do_ioctl_list))
    15b1:	81 fb d4 02 00 00    	cmp    $0x2d4,%ebx
    15b7:	74 6b                	je     1624 <fsm_core_close+0x1a4>
	{
		list_for_each_entry_safe(ev_ptr, tmp_ptr, &fsm_core.do_ioctl_list, list_node)
    15b9:	8b 33                	mov    (%ebx),%esi
    15bb:	83 eb 10             	sub    $0x10,%ebx
    15be:	83 ee 10             	sub    $0x10,%esi
    15c1:	eb 17                	jmp    15da <fsm_core_close+0x15a>
    15c3:	90                   	nop
    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    15c8:	8b 46 10             	mov    0x10(%esi),%eax
    15cb:	83 e8 10             	sub    $0x10,%eax
    15ce:	81 fe c4 02 00 00    	cmp    $0x2c4,%esi
    15d4:	74 4e                	je     1624 <fsm_core_close+0x1a4>
    15d6:	89 f3                	mov    %esi,%ebx
    15d8:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
    15da:	b8 e4 02 00 00       	mov    $0x2e4,%eax
    15df:	e8 fc ff ff ff       	call   15e0 <fsm_core_close+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    15e4:	8b 4b 14             	mov    0x14(%ebx),%ecx
    15e7:	89 c2                	mov    %eax,%edx
    15e9:	8b 43 10             	mov    0x10(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    15ec:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    15ef:	89 01                	mov    %eax,(%ecx)
    15f1:	b8 e4 02 00 00       	mov    $0x2e4,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    15f6:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    15fd:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    1604:	e8 fc ff ff ff       	call   1605 <fsm_core_close+0x185>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1609:	8b 43 0c             	mov    0xc(%ebx),%eax
    160c:	e8 fc ff ff ff       	call   160d <fsm_core_close+0x18d>
    1611:	89 d8                	mov    %ebx,%eax
    1613:	e8 fc ff ff ff       	call   1614 <fsm_core_close+0x194>
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
			list_del(&ev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
			fsm_mem_free(ev_ptr->ifr.buffer);
			fsm_mem_free(ev_ptr);
			if(list_empty(&fsm_core.do_ioctl_list))
    1618:	81 3d d4 02 00 00 d4 	cmpl   $0x2d4,0x2d4
    161f:	02 00 00 
    1622:	75 a4                	jne    15c8 <fsm_core_close+0x148>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1624:	8b 1d dc 02 00 00    	mov    0x2dc,%ebx
				break;
		}
	}
	if(!list_empty(&fsm_core.exp_ev_list))
    162a:	81 fb dc 02 00 00    	cmp    $0x2dc,%ebx
    1630:	74 69                	je     169b <fsm_core_close+0x21b>
	{
		list_for_each_entry_safe(tmev_ptr, tmev_tmp_ptr, &fsm_core.exp_ev_list, list_node)
    1632:	8b 33                	mov    (%ebx),%esi
    1634:	83 eb 04             	sub    $0x4,%ebx
    1637:	83 ee 04             	sub    $0x4,%esi
    163a:	eb 16                	jmp    1652 <fsm_core_close+0x1d2>
    163c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1640:	8b 46 04             	mov    0x4(%esi),%eax
    1643:	83 e8 04             	sub    $0x4,%eax
    1646:	81 fe d8 02 00 00    	cmp    $0x2d8,%esi
    164c:	74 4d                	je     169b <fsm_core_close+0x21b>
    164e:	89 f3                	mov    %esi,%ebx
    1650:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
    1652:	b8 e6 02 00 00       	mov    $0x2e6,%eax
    1657:	e8 fc ff ff ff       	call   1658 <fsm_core_close+0x1d8>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    165c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    165f:	89 c2                	mov    %eax,%edx
    1661:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1664:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    1667:	89 01                	mov    %eax,(%ecx)
    1669:	b8 e6 02 00 00       	mov    $0x2e6,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    166e:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    1675:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    167c:	e8 fc ff ff ff       	call   167d <fsm_core_close+0x1fd>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1681:	8b 03                	mov    (%ebx),%eax
    1683:	e8 fc ff ff ff       	call   1684 <fsm_core_close+0x204>
    1688:	89 d8                	mov    %ebx,%eax
    168a:	e8 fc ff ff ff       	call   168b <fsm_core_close+0x20b>
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
			list_del(&tmev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
			fsm_mem_free(tmev_ptr->pE);
			fsm_mem_free(tmev_ptr);
			if(list_empty(&fsm_core.exp_ev_list))
    168f:	81 3d dc 02 00 00 dc 	cmpl   $0x2dc,0x2dc
    1696:	02 00 00 
    1699:	75 a5                	jne    1640 <fsm_core_close+0x1c0>
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
    169b:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    16a2:	00 00 00 
    16a5:	b8 4c 00 00 00       	mov    $0x4c,%eax
    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	for(i = 0; i < MAX_INTF; i++)
	{
		if(INTF[i].dev)
    16b0:	8b 10                	mov    (%eax),%edx
    16b2:	85 d2                	test   %edx,%edx
    16b4:	74 09                	je     16bf <fsm_core_close+0x23f>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    16b6:	8b 92 98 02 00 00    	mov    0x298(%edx),%edx
 *
 * Release reference to device to allow it to be freed.
 */
static inline void dev_put(struct net_device *dev)
{
	this_cpu_dec(*dev->pcpu_refcnt);
    16bc:	64 ff 0a             	decl   %fs:(%edx)
    16bf:	83 c0 10             	add    $0x10,%eax
			if(list_empty(&fsm_core.exp_ev_list))
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
	for(i = 0; i < MAX_INTF; i++)
    16c2:	3d 4c 02 00 00       	cmp    $0x24c,%eax
    16c7:	75 e7                	jne    16b0 <fsm_core_close+0x230>
    16c9:	b8 44 00 00 00       	mov    $0x44,%eax
    16ce:	66 90                	xchg   %ax,%ax
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    16d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    16d6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    16dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    16e3:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    16ea:	83 c0 10             	add    $0x10,%eax
		if(INTF[i].dev)
		{
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
    16ed:	3d 44 02 00 00       	cmp    $0x244,%eax
    16f2:	75 dc                	jne    16d0 <fsm_core_close+0x250>
		INTF[i].valid = 0;
		INTF[i].proto = 0;
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
    16f4:	c7 04 24 41 00 00 00 	movl   $0x41,(%esp)
    16fb:	e8 fc ff ff ff       	call   16fc <fsm_core_close+0x27c>
    1700:	89 fa                	mov    %edi,%edx
    1702:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1707:	e8 fc ff ff ff       	call   1708 <fsm_core_close+0x288>
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    170c:	31 c0                	xor    %eax,%eax
    170e:	83 c4 10             	add    $0x10,%esp
    1711:	5b                   	pop    %ebx
    1712:	5e                   	pop    %esi
    1713:	5f                   	pop    %edi
    1714:	5d                   	pop    %ebp
    1715:	c3                   	ret    
    1716:	8d 76 00             	lea    0x0(%esi),%esi
    1719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001720 <fsm_core_pkt_drive>:



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1720:	55                   	push   %ebp
    1721:	89 e5                	mov    %esp,%ebp
    1723:	83 ec 18             	sub    $0x18,%esp
    1726:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    1729:	89 75 fc             	mov    %esi,-0x4(%ebp)
    172c:	e8 fc ff ff ff       	call   172d <fsm_core_pkt_drive+0xd>
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1731:	83 fa 01             	cmp    $0x1,%edx
}



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1734:	89 c6                	mov    %eax,%esi
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1736:	74 68                	je     17a0 <fsm_core_pkt_drive+0x80>
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock ,flags2);
	}
	if(type == RXTX_PKT_REQ)
    1738:	85 d2                	test   %edx,%edx
    173a:	74 0c                	je     1748 <fsm_core_pkt_drive+0x28>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    173c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    173f:	31 c0                	xor    %eax,%eax
    1741:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1744:	89 ec                	mov    %ebp,%esp
    1746:	5d                   	pop    %ebp
    1747:	c3                   	ret    
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1748:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    174d:	e8 fc ff ff ff       	call   174e <fsm_core_pkt_drive+0x2e>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1752:	89 f1                	mov    %esi,%ecx
    1754:	31 d2                	xor    %edx,%edx
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1756:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1758:	a1 8c 02 00 00       	mov    0x28c,%eax
    175d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1764:	00 
    1765:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    176c:	00 
    176d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1774:	89 44 24 04          	mov    %eax,0x4(%esp)
    1778:	b8 01 00 00 00       	mov    $0x1,%eax
    177d:	e8 ae ec ff ff       	call   430 <__fsm_core_self_drive>
    1782:	89 da                	mov    %ebx,%edx
    1784:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1789:	e8 fc ff ff ff       	call   178a <fsm_core_pkt_drive+0x6a>
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    178e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1791:	31 c0                	xor    %eax,%eax
    1793:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1796:	89 ec                	mov    %ebp,%esp
    1798:	5d                   	pop    %ebp
    1799:	c3                   	ret    
    179a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17a0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17a5:	e8 fc ff ff ff       	call   17a6 <fsm_core_pkt_drive+0x86>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17aa:	89 f1                	mov    %esi,%ecx
    17ac:	31 d2                	xor    %edx,%edx
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17ae:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17b0:	a1 8c 02 00 00       	mov    0x28c,%eax
    17b5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    17bc:	00 
    17bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    17c4:	00 
    17c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    17cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    17d0:	b8 02 00 00 00       	mov    $0x2,%eax
    17d5:	e8 56 ec ff ff       	call   430 <__fsm_core_self_drive>
    17da:	89 da                	mov    %ebx,%edx
    17dc:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17e1:	e8 fc ff ff ff       	call   17e2 <fsm_core_pkt_drive+0xc2>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    17e6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    17e9:	31 c0                	xor    %eax,%eax
    17eb:	8b 75 fc             	mov    -0x4(%ebp),%esi
    17ee:	89 ec                	mov    %ebp,%esp
    17f0:	5d                   	pop    %ebp
    17f1:	c3                   	ret    
    17f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    17f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001800 <fsm_create_register>:

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1800:	55                   	push   %ebp
    1801:	89 e5                	mov    %esp,%ebp
    1803:	83 ec 14             	sub    $0x14,%esp
    1806:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1809:	89 75 f8             	mov    %esi,-0x8(%ebp)
    180c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    180f:	e8 fc ff ff ff       	call   1810 <fsm_create_register+0x10>
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1814:	31 db                	xor    %ebx,%ebx
	return FSM_EXEC_SUCC;
}

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1816:	89 c7                	mov    %eax,%edi
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
    1818:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
    181f:	85 c0                	test   %eax,%eax
    1821:	74 1d                	je     1840 <fsm_create_register+0x40>

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1823:	83 c3 01             	add    $0x1,%ebx
    1826:	83 fb 06             	cmp    $0x6,%ebx
    1829:	75 ed                	jne    1818 <fsm_create_register+0x18>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
			FSM[i]->_fsm_current_block = 0;
			return i;
			}
		}
	return -1;
    182b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
    1830:	8b 75 f8             	mov    -0x8(%ebp),%esi
    1833:	89 d8                	mov    %ebx,%eax
    1835:	8b 7d fc             	mov    -0x4(%ebp),%edi
    1838:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    183b:	89 ec                	mov    %ebp,%esp
    183d:	5d                   	pop    %ebp
    183e:	c3                   	ret    
    183f:	90                   	nop
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1840:	b8 90 00 00 00       	mov    $0x90,%eax
    1845:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1848:	8d b3 9c 00 00 00    	lea    0x9c(%ebx),%esi
    184e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    1851:	e8 fc ff ff ff       	call   1852 <fsm_create_register+0x52>
			FSM[i]->fsm_main = fsm_main;
    1856:	8b 55 ec             	mov    -0x14(%ebp),%edx
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1859:	89 04 b5 20 00 00 00 	mov    %eax,0x20(,%esi,4)
			FSM[i]->fsm_main = fsm_main;
    1860:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			FSM[i]->id = i;
    1866:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
			strcpy(FSM[i]->name, name);
    186d:	89 fa                	mov    %edi,%edx
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
			FSM[i]->fsm_main = fsm_main;
			FSM[i]->id = i;
    186f:	89 98 80 00 00 00    	mov    %ebx,0x80(%eax)
			strcpy(FSM[i]->name, name);
    1875:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    187c:	e8 fc ff ff ff       	call   187d <fsm_create_register+0x7d>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
    1881:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1888:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    188b:	89 88 88 00 00 00    	mov    %ecx,0x88(%eax)
			FSM[i]->_fsm_current_block = 0;
    1891:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1898:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
    189f:	00 00 00 
			return i;
			}
		}
	return -1;
}
    18a2:	89 d8                	mov    %ebx,%eax
    18a4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    18a7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    18aa:	8b 7d fc             	mov    -0x4(%ebp),%edi
    18ad:	89 ec                	mov    %ebp,%esp
    18af:	5d                   	pop    %ebp
    18b0:	c3                   	ret    
    18b1:	eb 0d                	jmp    18c0 <fsm_unregister_destroy>
    18b3:	90                   	nop
    18b4:	90                   	nop
    18b5:	90                   	nop
    18b6:	90                   	nop
    18b7:	90                   	nop
    18b8:	90                   	nop
    18b9:	90                   	nop
    18ba:	90                   	nop
    18bb:	90                   	nop
    18bc:	90                   	nop
    18bd:	90                   	nop
    18be:	90                   	nop
    18bf:	90                   	nop

000018c0 <fsm_unregister_destroy>:

void fsm_unregister_destroy(int id)
{
    18c0:	55                   	push   %ebp
    18c1:	89 e5                	mov    %esp,%ebp
    18c3:	53                   	push   %ebx
    18c4:	e8 fc ff ff ff       	call   18c5 <fsm_unregister_destroy+0x5>
	if(FSM[id]!=NULL)
    18c9:	8d 98 9c 00 00 00    	lea    0x9c(%eax),%ebx
    18cf:	8b 04 9d 20 00 00 00 	mov    0x20(,%ebx,4),%eax
    18d6:	85 c0                	test   %eax,%eax
    18d8:	74 10                	je     18ea <fsm_unregister_destroy+0x2a>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    18da:	e8 fc ff ff ff       	call   18db <fsm_unregister_destroy+0x1b>
void fsm_unregister_destroy(int id)
{
	if(FSM[id]!=NULL)
	{
		fsm_mem_free(FSM[id]);
		FSM[id] = NULL;
    18df:	c7 04 9d 20 00 00 00 	movl   $0x0,0x20(,%ebx,4)
    18e6:	00 00 00 00 
	}
}
    18ea:	5b                   	pop    %ebx
    18eb:	5d                   	pop    %ebp
    18ec:	c3                   	ret    
    18ed:	8d 76 00             	lea    0x0(%esi),%esi

000018f0 <fsm_core_destroy>:
	return; 
}

		
void fsm_core_destroy()
{
    18f0:	55                   	push   %ebp
    18f1:	89 e5                	mov    %esp,%ebp
    18f3:	53                   	push   %ebx
    18f4:	e8 fc ff ff ff       	call   18f5 <fsm_core_destroy+0x5>
	int i;
	if(fsm_core.state != CORE_CLOSED)
    18f9:	a1 28 00 00 00       	mov    0x28,%eax
    18fe:	85 c0                	test   %eax,%eax
    1900:	75 56                	jne    1958 <fsm_core_destroy+0x68>
	return; 
}

		
void fsm_core_destroy()
{
    1902:	31 db                	xor    %ebx,%ebx
    1904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
	{
		fsm_unregister_destroy(i);
    1908:	89 d8                	mov    %ebx,%eax
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    190a:	83 c3 01             	add    $0x1,%ebx
	{
		fsm_unregister_destroy(i);
    190d:	e8 fc ff ff ff       	call   190e <fsm_core_destroy+0x1e>
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    1912:	83 fb 06             	cmp    $0x6,%ebx
    1915:	75 f1                	jne    1908 <fsm_core_destroy+0x18>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1917:	a1 b8 02 00 00       	mov    0x2b8,%eax
    191c:	e8 fc ff ff ff       	call   191d <fsm_core_destroy+0x2d>
    1921:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1926:	e8 fc ff ff ff       	call   1927 <fsm_core_destroy+0x37>
    192b:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1930:	e8 fc ff ff ff       	call   1931 <fsm_core_destroy+0x41>
    1935:	a1 c4 02 00 00       	mov    0x2c4,%eax
    193a:	e8 fc ff ff ff       	call   193b <fsm_core_destroy+0x4b>
    193f:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1944:	e8 fc ff ff ff       	call   1945 <fsm_core_destroy+0x55>
    1949:	a1 cc 02 00 00       	mov    0x2cc,%eax
    194e:	e8 fc ff ff ff       	call   194f <fsm_core_destroy+0x5f>
	fsm_mem_free(fsm_core.tx_tsklt);
	fsm_mem_free(fsm_core.rx_tsklt);
	fsm_mem_free(fsm_core.do_ioctl_tsklt);
	fsm_mem_free(fsm_core.exp_ev_tsklt);
	return;
}
    1953:	5b                   	pop    %ebx
    1954:	5d                   	pop    %ebp
    1955:	c3                   	ret    
    1956:	66 90                	xchg   %ax,%ax
		
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
    1958:	e8 fc ff ff ff       	call   1959 <fsm_core_destroy+0x69>
    195d:	8d 76 00             	lea    0x0(%esi),%esi
    1960:	eb a0                	jmp    1902 <fsm_core_destroy+0x12>
    1962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1969:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001970 <fsm_mainport_bind>:
		FSM[id] = NULL;
	}
}

void fsm_mainport_bind(int id)
{
    1970:	55                   	push   %ebp
    1971:	89 e5                	mov    %esp,%ebp
    1973:	e8 fc ff ff ff       	call   1974 <fsm_mainport_bind+0x4>
	fsm_core.main_port = id;
}
    1978:	5d                   	pop    %ebp
	}
}

void fsm_mainport_bind(int id)
{
	fsm_core.main_port = id;
    1979:	a3 8c 02 00 00       	mov    %eax,0x28c
}
    197e:	c3                   	ret    
    197f:	90                   	nop

00001980 <__fsm_dev_set_config>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_set_config(struct net_device *dev, struct ifmap *p_ifmap)
{
    1980:	55                   	push   %ebp
    1981:	89 e5                	mov    %esp,%ebp
    1983:	e8 fc ff ff ff       	call   1984 <__fsm_dev_set_config+0x4>
    	return 0;
}
    1988:	31 c0                	xor    %eax,%eax
    198a:	5d                   	pop    %ebp
    198b:	c3                   	ret    
    198c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001990 <__fsm_dev_get_stats>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    1990:	55                   	push   %ebp
    1991:	89 e5                	mov    %esp,%ebp
    1993:	e8 fc ff ff ff       	call   1994 <__fsm_dev_get_stats+0x4>
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
}
    1998:	5d                   	pop    %ebp
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
    1999:	05 c0 04 00 00       	add    $0x4c0,%eax
}
    199e:	c3                   	ret    
    199f:	90                   	nop

000019a0 <__fsm_dev_tx_timeout>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_tx_timeout(struct net_device *dev)
{  
    19a0:	55                   	push   %ebp
    19a1:	89 e5                	mov    %esp,%ebp
    19a3:	e8 fc ff ff ff       	call   19a4 <__fsm_dev_tx_timeout+0x4>
    return;   
}
    19a8:	5d                   	pop    %ebp
    19a9:	c3                   	ret    
    19aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000019b0 <__fsm_dev_ioctl>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	e8 fc ff ff ff       	call   19b4 <__fsm_dev_ioctl+0x4>
    19b8:	89 d0                	mov    %edx,%eax
    19ba:	89 ca                	mov    %ecx,%edx
	fsm_ioctrl_arrival(ifr,cmd);
    19bc:	e8 fc ff ff ff       	call   19bd <__fsm_dev_ioctl+0xd>
	return 0;
}
    19c1:	31 c0                	xor    %eax,%eax
    19c3:	5d                   	pop    %ebp
    19c4:	c3                   	ret    
    19c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    19c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019d0 <__fsm_dev_tx>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_tx(struct sk_buff *skb, struct net_device *dev)
{ 
    19d0:	55                   	push   %ebp
    19d1:	89 e5                	mov    %esp,%ebp
    19d3:	e8 fc ff ff ff       	call   19d4 <__fsm_dev_tx+0x4>
	fsm_core_pkt_drive(skb, RXTX_PKT_REQ);	
    19d8:	31 d2                	xor    %edx,%edx
    19da:	e8 fc ff ff ff       	call   19db <__fsm_dev_tx+0xb>
   	return 0;    
}	
    19df:	31 c0                	xor    %eax,%eax
    19e1:	5d                   	pop    %ebp
    19e2:	c3                   	ret    
    19e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    19e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019f0 <__fsm_dev_recv>:
 **-------------------------------------- ------system--------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_recv(struct sk_buff *skb ,struct net_device *dev1, struct packet_type *pktype, struct net_device *dev2)
{  
    19f0:	55                   	push   %ebp
    19f1:	89 e5                	mov    %esp,%ebp
    19f3:	e8 fc ff ff ff       	call   19f4 <__fsm_dev_recv+0x4>
    	fsm_core_pkt_drive(skb, RXTX_PKT_IND);
    19f8:	ba 01 00 00 00       	mov    $0x1,%edx
    19fd:	e8 fc ff ff ff       	call   19fe <__fsm_dev_recv+0xe>
    	return 0;            
}
    1a02:	31 c0                	xor    %eax,%eax
    1a04:	5d                   	pop    %ebp
    1a05:	c3                   	ret    
    1a06:	8d 76 00             	lea    0x0(%esi),%esi
    1a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001a10 <__fsm_dev_open>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	53                   	push   %ebx
    1a14:	83 ec 04             	sub    $0x4,%esp
    1a17:	e8 fc ff ff ff       	call   1a18 <__fsm_dev_open+0x8>
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a1c:	b9 f3 f4 00 00       	mov    $0xf4f3,%ecx
    1a21:	ba 02 00 00 00       	mov    $0x2,%edx
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a26:	89 c3                	mov    %eax,%ebx
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a28:	b8 05 00 00 00       	mov    $0x5,%eax
    1a2d:	c7 04 24 53 00 00 00 	movl   $0x53,(%esp)
    1a34:	e8 fc ff ff ff       	call   1a35 <__fsm_dev_open+0x25>
	fsm_core_intf_set(STRM_TO_IPADP, DEV_INTF_IND, DEV_PROTO_IPADP, "LTE_IPADP0");
    1a39:	b9 f0 f4 00 00       	mov    $0xf4f0,%ecx
    1a3e:	ba 02 00 00 00       	mov    $0x2,%edx
    1a43:	b8 07 00 00 00       	mov    $0x7,%eax
    1a48:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp)
    1a4f:	e8 fc ff ff ff       	call   1a50 <__fsm_dev_open+0x40>
	fsm_core_intf_set(STRM_TO_PDCP, DEV_INTF_IND, DEV_PROTO_PDCP, "LTE_PDCP0");
    1a54:	b9 f1 f4 00 00       	mov    $0xf4f1,%ecx
    1a59:	ba 02 00 00 00       	mov    $0x2,%edx
    1a5e:	b8 06 00 00 00       	mov    $0x6,%eax
    1a63:	c7 04 24 67 00 00 00 	movl   $0x67,(%esp)
    1a6a:	e8 fc ff ff ff       	call   1a6b <__fsm_dev_open+0x5b>
	//fsm_core_intf_set(STRM_TO_RLC, DEV_INTF_IND, DEV_PROTO_RLC, "LTE_RLC0");
	fsm_core_intf_set(STRM_TO_SRIO, DEV_INTF_REQ, DEV_PROTO_RLC_MAC, "LTE_SRIO0");
    1a6f:	b9 f8 f4 00 00       	mov    $0xf4f8,%ecx
    1a74:	ba 01 00 00 00       	mov    $0x1,%edx
    1a79:	b8 03 00 00 00       	mov    $0x3,%eax
    1a7e:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
    1a85:	e8 fc ff ff ff       	call   1a86 <__fsm_dev_open+0x76>
    	dev_add_pack(&pk_t); 
    1a8a:	b8 00 00 00 00       	mov    $0x0,%eax
    1a8f:	e8 fc ff ff ff       	call   1a90 <__fsm_dev_open+0x80>
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    1a94:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 */
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    1a9a:	f0 80 60 50 fe       	lock andb $0xfe,0x50(%eax)
	netif_start_queue(dev);   
    	fsm_core_open();	 
    1a9f:	e8 fc ff ff ff       	call   1aa0 <__fsm_dev_open+0x90>
    	return 0;    
}
    1aa4:	31 c0                	xor    %eax,%eax
    1aa6:	83 c4 04             	add    $0x4,%esp
    1aa9:	5b                   	pop    %ebx
    1aaa:	5d                   	pop    %ebp
    1aab:	c3                   	ret    
    1aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001ab0 <dev_init>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1ab0:	55                   	push   %ebp
    1ab1:	89 e5                	mov    %esp,%ebp
    1ab3:	53                   	push   %ebx
    1ab4:	83 ec 08             	sub    $0x8,%esp
    1ab7:	e8 fc ff ff ff       	call   1ab8 <dev_init+0x8>
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1abc:	85 c0                	test   %eax,%eax
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1abe:	89 c3                	mov    %eax,%ebx
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1ac0:	0f 84 af 00 00 00    	je     1b75 <dev_init+0xc5>
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ac6:	83 88 a4 00 00 00 04 	orl    $0x4,0xa4(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1acd:	b9 60 00 00 00       	mov    $0x60,%ecx
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ad2:	83 88 a8 00 00 00 00 	orl    $0x0,0xa8(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1ad9:	31 d2                	xor    %edx,%edx
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    	dev->tx_queue_len = 128;   	/* the queue length */   
    1adb:	c7 80 50 02 00 00 80 	movl   $0x80,0x250(%eax)
    1ae2:	00 00 00 
    	dev->mtu = MTU;		/* now we do not fragmentate the packet */
    1ae5:	c7 80 50 01 00 00 dc 	movl   $0x5dc,0x150(%eax)
    1aec:	05 00 00 
   	dev->header_ops = NULL;   	/* cancle eth_header function for not building ethnet mac header */ 
    1aef:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%eax)
    1af6:	00 00 00 
    	dev->addr_len = 0;
    1af9:	c6 80 7d 01 00 00 00 	movb   $0x0,0x17d(%eax)
    	dev->hard_header_len = 0;
    1b00:	66 c7 80 56 01 00 00 	movw   $0x0,0x156(%eax)
    1b07:	00 00 
	dev->netdev_ops = &fsm_netdev_ops;
    1b09:	c7 80 34 01 00 00 20 	movl   $0x20,0x134(%eax)
    1b10:	00 00 00 
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
    1b13:	c7 80 60 02 00 00 e8 	movl   $0x3e8,0x260(%eax)
    1b1a:	03 00 00 
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    1b1d:	c7 80 40 01 00 00 82 	movl   $0x1082,0x140(%eax)
    1b24:	10 00 00 
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
    1b27:	8d 80 c0 04 00 00    	lea    0x4c0(%eax),%eax
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1b2d:	e8 fc ff ff ff       	call   1b2e <dev_init+0x7e>
	fsm_core_create(dev);
    1b32:	89 d8                	mov    %ebx,%eax
    1b34:	e8 fc ff ff ff       	call   1b35 <dev_init+0x85>
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b39:	b8 ac 5a 00 00       	mov    $0x5aac,%eax
    1b3e:	e8 fc ff ff ff       	call   1b3f <dev_init+0x8f>
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b43:	b9 ac 5a 00 00       	mov    $0x5aac,%ecx
    1b48:	31 d2                	xor    %edx,%edx
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
	fsm_core_create(dev);
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b4a:	89 83 1c 05 00 00    	mov    %eax,0x51c(%ebx)
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b50:	e8 fc ff ff ff       	call   1b51 <dev_init+0xa1>
/*-----------------------------------FSM creation---------------------------*/
	fsm_id = fsm_create_register("lte_rlc_mac_fsm", rlc_mac_main, priv->sv_ptr);
    1b55:	8b 8b 1c 05 00 00    	mov    0x51c(%ebx),%ecx
    1b5b:	ba 00 00 00 00       	mov    $0x0,%edx
    1b60:	b8 7b 00 00 00       	mov    $0x7b,%eax
    1b65:	e8 fc ff ff ff       	call   1b66 <dev_init+0xb6>
	fsm_mainport_bind(fsm_id);
    1b6a:	e8 fc ff ff ff       	call   1b6b <dev_init+0xbb>
/*--------------------------------------------------------------------------*/
    return;
}
    1b6f:	83 c4 08             	add    $0x8,%esp
    1b72:	5b                   	pop    %ebx
    1b73:	5d                   	pop    %ebp
    1b74:	c3                   	ret    
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1b75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1b7c:	00 
    1b7d:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
    1b84:	e8 fc ff ff ff       	call   1b85 <dev_init+0xd5>
    1b89:	e8 fc ff ff ff       	call   1b8a <dev_init+0xda>
    1b8e:	eb df                	jmp    1b6f <dev_init+0xbf>

00001b90 <__fsm_dev_stop>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_stop(struct net_device *dev)
{  
    1b90:	55                   	push   %ebp
    1b91:	89 e5                	mov    %esp,%ebp
    1b93:	53                   	push   %ebx
    1b94:	83 ec 04             	sub    $0x4,%esp
    1b97:	e8 fc ff ff ff       	call   1b98 <__fsm_dev_stop+0x8>
    1b9c:	89 c3                	mov    %eax,%ebx
         
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    1b9e:	e8 fc ff ff ff       	call   1b9f <__fsm_dev_stop+0xf>
    	dev_remove_pack(&pk_t);
    1ba3:	b8 00 00 00 00       	mov    $0x0,%eax
    1ba8:	e8 fc ff ff ff       	call   1ba9 <__fsm_dev_stop+0x19>
{  
    return;   
}

module_init(__fsm_dev_create);
module_exit(__fsm_dev_destroy);
    1bad:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
	}
}

static inline void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
	if (WARN_ON(!dev_queue)) {
    1bb3:	85 c0                	test   %eax,%eax
    1bb5:	74 0d                	je     1bc4 <__fsm_dev_stop+0x34>
 */
static __always_inline void
set_bit(unsigned int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1bb7:	f0 80 48 50 01       	lock orb $0x1,0x50(%eax)
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    	dev_remove_pack(&pk_t);
    	netif_stop_queue(dev);
     	return 0;    
}
    1bbc:	83 c4 04             	add    $0x4,%esp
    1bbf:	31 c0                	xor    %eax,%eax
    1bc1:	5b                   	pop    %ebx
    1bc2:	5d                   	pop    %ebp
    1bc3:	c3                   	ret    
    1bc4:	ba 50 07 00 00       	mov    $0x750,%edx
    1bc9:	b8 8b 00 00 00       	mov    $0x8b,%eax
    1bce:	e8 fc ff ff ff       	call   1bcf <__fsm_dev_stop+0x3f>
		pr_info("netif_stop_queue() cannot be called before register_netdev()\n");
    1bd3:	c7 04 24 8c 00 00 00 	movl   $0x8c,(%esp)
    1bda:	e8 fc ff ff ff       	call   1bdb <__fsm_dev_stop+0x4b>
    1bdf:	eb db                	jmp    1bbc <__fsm_dev_stop+0x2c>
    1be1:	eb 0d                	jmp    1bf0 <__fsm_dev_create>
    1be3:	90                   	nop
    1be4:	90                   	nop
    1be5:	90                   	nop
    1be6:	90                   	nop
    1be7:	90                   	nop
    1be8:	90                   	nop
    1be9:	90                   	nop
    1bea:	90                   	nop
    1beb:	90                   	nop
    1bec:	90                   	nop
    1bed:	90                   	nop
    1bee:	90                   	nop
    1bef:	90                   	nop

00001bf0 <__fsm_dev_create>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_create(void)
{   
    1bf0:	55                   	push   %ebp
    1bf1:	89 e5                	mov    %esp,%ebp
    1bf3:	53                   	push   %ebx
    1bf4:	83 ec 08             	sub    $0x8,%esp
    1bf7:	e8 fc ff ff ff       	call   1bf8 <__fsm_dev_create+0x8>
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1bfc:	b9 00 00 00 00       	mov    $0x0,%ecx
    1c01:	ba a5 00 00 00       	mov    $0xa5,%edx
    1c06:	b8 60 00 00 00       	mov    $0x60,%eax
    1c0b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1c12:	00 
    1c13:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1c1a:	e8 fc ff ff ff       	call   1c1b <__fsm_dev_create+0x2b>
    if (dev == NULL)   /* allocation error */
    1c1f:	85 c0                	test   %eax,%eax
{   
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1c21:	89 c3                	mov    %eax,%ebx
    if (dev == NULL)   /* allocation error */
    1c23:	74 41                	je     1c66 <__fsm_dev_create+0x76>
		{
		return -2;
		}
	memcpy(dev->dev_addr, &dev_addr, 6);       
    1c25:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
    1c2b:	c6 00 00             	movb   $0x0,(%eax)
    1c2e:	c6 40 01 11          	movb   $0x11,0x1(%eax)
    1c32:	c6 40 02 1a          	movb   $0x1a,0x2(%eax)
    1c36:	c6 40 03 1a          	movb   $0x1a,0x3(%eax)
    1c3a:	c6 40 04 8a          	movb   $0x8a,0x4(%eax)
    1c3e:	c6 40 05 42          	movb   $0x42,0x5(%eax)
    if (priv == NULL)
    	{                
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
    1c42:	89 d8                	mov    %ebx,%eax
    1c44:	e8 fc ff ff ff       	call   1c45 <__fsm_dev_create+0x55>
    1c49:	85 c0                	test   %eax,%eax
    1c4b:	75 0b                	jne    1c58 <__fsm_dev_create+0x68>
		{
        free_netdev(dev);   /* release the struct net_device */
        dev = NULL;               
        return -1;
		}
 	return 0;       
    1c4d:	31 c0                	xor    %eax,%eax
}
    1c4f:	83 c4 08             	add    $0x8,%esp
    1c52:	5b                   	pop    %ebx
    1c53:	5d                   	pop    %ebp
    1c54:	c3                   	ret    
    1c55:	8d 76 00             	lea    0x0(%esi),%esi
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
		{
        free_netdev(dev);   /* release the struct net_device */
    1c58:	89 d8                	mov    %ebx,%eax
    1c5a:	e8 fc ff ff ff       	call   1c5b <__fsm_dev_create+0x6b>
        dev = NULL;               
        return -1;
    1c5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1c64:	eb e9                	jmp    1c4f <__fsm_dev_create+0x5f>
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    if (dev == NULL)   /* allocation error */
		{
		return -2;
    1c66:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    1c6b:	eb e2                	jmp    1c4f <__fsm_dev_create+0x5f>
    1c6d:	8d 76 00             	lea    0x0(%esi),%esi

00001c70 <__fsm_dev_destroy>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_destroy(void)
{
    1c70:	55                   	push   %ebp
    1c71:	89 e5                	mov    %esp,%ebp
    1c73:	53                   	push   %ebx
    1c74:	e8 fc ff ff ff       	call   1c75 <__fsm_dev_destroy+0x5>
	NETDEV* dev;
	fsm_priv* priv;
	dev = (NETDEV*)fsm_dev_get();
    1c79:	e8 fc ff ff ff       	call   1c7a <__fsm_dev_destroy+0xa>
    1c7e:	89 c3                	mov    %eax,%ebx
	fsm_core_destroy();
    1c80:	e8 fc ff ff ff       	call   1c81 <__fsm_dev_destroy+0x11>
	priv = netdev_priv(dev);
	fsm_mem_free(priv->sv_ptr);
    1c85:	8b 83 1c 05 00 00    	mov    0x51c(%ebx),%eax
    1c8b:	e8 fc ff ff ff       	call   1c8c <__fsm_dev_destroy+0x1c>
    	unregister_netdev(dev);
    1c90:	89 d8                	mov    %ebx,%eax
    1c92:	e8 fc ff ff ff       	call   1c93 <__fsm_dev_destroy+0x23>
    	free_netdev(dev);
    1c97:	89 d8                	mov    %ebx,%eax
    1c99:	e8 fc ff ff ff       	call   1c9a <__fsm_dev_destroy+0x2a>
}   
    1c9e:	5b                   	pop    %ebx
    1c9f:	5d                   	pop    %ebp
    1ca0:	c3                   	ret    
    1ca1:	90                   	nop
    1ca2:	90                   	nop
    1ca3:	90                   	nop
    1ca4:	90                   	nop
    1ca5:	90                   	nop
    1ca6:	90                   	nop
    1ca7:	90                   	nop
    1ca8:	90                   	nop
    1ca9:	90                   	nop
    1caa:	90                   	nop
    1cab:	90                   	nop
    1cac:	90                   	nop
    1cad:	90                   	nop
    1cae:	90                   	nop
    1caf:	90                   	nop

00001cb0 <findInsByCode>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void * findInsByCode(long code, RlcTimerType * timer)
{
    1cb0:	55                   	push   %ebp
    1cb1:	89 e5                	mov    %esp,%ebp
    1cb3:	57                   	push   %edi
    1cb4:	56                   	push   %esi
    1cb5:	53                   	push   %ebx
    1cb6:	e8 fc ff ff ff       	call   1cb7 <findInsByCode+0x7>
    1cbb:	89 d6                	mov    %edx,%esi
    1cbd:	89 c3                	mov    %eax,%ebx
	struct list_head* pos;
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	
	FIN(findInsByCode());
	SV_PTR_GET(rlc_mac_sv);
    1cbf:	e8 fc ff ff ff       	call   1cc0 <findInsByCode+0x10>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1cc4:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
	/*if( SV(bufferReqTimerCode) == code )
	{
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    1cca:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    1cd0:	39 d1                	cmp    %edx,%ecx
    1cd2:	74 28                	je     1cfc <findInsByCode+0x4c>
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
    1cd4:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cda:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1ce0:	75 14                	jne    1cf6 <findInsByCode+0x46>
    1ce2:	eb 64                	jmp    1d48 <findInsByCode+0x98>
    1ce4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1ce8:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cee:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1cf4:	74 52                	je     1d48 <findInsByCode+0x98>
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    1cf6:	8b 12                	mov    (%edx),%edx
    1cf8:	39 d1                	cmp    %edx,%ecx
    1cfa:	75 ec                	jne    1ce8 <findInsByCode+0x38>
    1cfc:	8b 90 f4 25 00 00    	mov    0x25f4(%eax),%edx
				*timer = UM_REORDER;
				return (void*)umRxIns;
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
    1d02:	8d 88 f4 25 00 00    	lea    0x25f4(%eax),%ecx
    1d08:	39 d1                	cmp    %edx,%ecx
    1d0a:	75 1a                	jne    1d26 <findInsByCode+0x76>
    1d0c:	eb 5a                	jmp    1d68 <findInsByCode+0xb8>
    1d0e:	66 90                	xchg   %ax,%ax
			if(amIns->pollRetxTimerCode == code)
			{
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
    1d10:	39 9a 14 dd ff ff    	cmp    %ebx,-0x22ec(%edx)
    1d16:	74 40                	je     1d58 <findInsByCode+0xa8>
			{
				*timer = AM_REORDER;
				return (void*)amIns;
			}
			if(amIns->statProhTimerCode == code)
    1d18:	39 9a 20 dd ff ff    	cmp    %ebx,-0x22e0(%edx)
    1d1e:	74 40                	je     1d60 <findInsByCode+0xb0>
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    1d20:	8b 12                	mov    (%edx),%edx
    1d22:	39 d1                	cmp    %edx,%ecx
    1d24:	74 2a                	je     1d50 <findInsByCode+0xa0>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->pollRetxTimerCode == code)
    1d26:	39 9a 08 dd ff ff    	cmp    %ebx,-0x22f8(%edx)
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    1d2c:	8d ba fc dc ff ff    	lea    -0x2304(%edx),%edi
			if(amIns->pollRetxTimerCode == code)
    1d32:	75 dc                	jne    1d10 <findInsByCode+0x60>
			{
				*timer = POLL_RETX;
    1d34:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    1d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	else
	{
		return NULL;
	}
}
    1d40:	5b                   	pop    %ebx
    1d41:	89 f8                	mov    %edi,%eax
    1d43:	5e                   	pop    %esi
    1d44:	5f                   	pop    %edi
    1d45:	5d                   	pop    %ebp
    1d46:	c3                   	ret    
    1d47:	90                   	nop
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
			{
				*timer = UM_REORDER;
    1d48:	c7 06 04 00 00 00    	movl   $0x4,(%esi)
				return (void*)umRxIns;
    1d4e:	eb f0                	jmp    1d40 <findInsByCode+0x90>
	}
	else
	{
		return NULL;
	}
}
    1d50:	5b                   	pop    %ebx
    1d51:	5e                   	pop    %esi
    1d52:	5f                   	pop    %edi
    1d53:	5d                   	pop    %ebp
    1d54:	c3                   	ret    
    1d55:	8d 76 00             	lea    0x0(%esi),%esi
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
			{
				*timer = AM_REORDER;
    1d58:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				return (void*)amIns;
    1d5e:	eb e0                	jmp    1d40 <findInsByCode+0x90>
			}
			if(amIns->statProhTimerCode == code)
			{
				*timer = STAT_PRO;
    1d60:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
				return (void*)amIns;
    1d66:	eb d8                	jmp    1d40 <findInsByCode+0x90>
			}
		}
	}
	else
	{
		return NULL;
    1d68:	31 ff                	xor    %edi,%edi
    1d6a:	eb d4                	jmp    1d40 <findInsByCode+0x90>
    1d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001d70 <rlc_close>:
**--------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
***********************************************************************************/
static void rlc_close()
{
    1d70:	55                   	push   %ebp
    1d71:	89 e5                	mov    %esp,%ebp
    1d73:	57                   	push   %edi
    1d74:	56                   	push   %esi
    1d75:	53                   	push   %ebx
    1d76:	83 ec 20             	sub    $0x20,%esp
    1d79:	e8 fc ff ff ff       	call   1d7a <rlc_close+0xa>
	struct AmBuffer *amBuffer, *tempAmBuffer;
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
    1d7e:	e8 fc ff ff ff       	call   1d7f <rlc_close+0xf>
    1d83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
//AM
	if(!list_empty(&SV(vAm_ins).amList))
    1d86:	05 f4 25 00 00       	add    $0x25f4,%eax
    1d8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1d91:	8b b0 f4 25 00 00    	mov    0x25f4(%eax),%esi
    1d97:	39 75 e0             	cmp    %esi,-0x20(%ebp)
    1d9a:	0f 84 6f 04 00 00    	je     220f <rlc_close+0x49f>
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    1da0:	8b 06                	mov    (%esi),%eax
    1da2:	81 ee 04 23 00 00    	sub    $0x2304,%esi
    1da8:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    1dae:	89 55 e8             	mov    %edx,-0x18(%ebp)
    1db1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1db8:	8b 96 08 23 00 00    	mov    0x2308(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1dbe:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1dc1:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1dc3:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
    1dc9:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1dcf:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    1dd6:	01 10 00 
	entry->prev = LIST_POISON2;
    1dd9:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    1de0:	02 20 00 
    1de3:	39 c2                	cmp    %eax,%edx
    1de5:	0f 84 8d 08 00 00    	je     2678 <rlc_close+0x908>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    1deb:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1df1:	8b 00                	mov    (%eax),%eax
    1df3:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1df6:	89 d6                	mov    %edx,%esi
    1df8:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1dfe:	eb 1e                	jmp    1e1e <rlc_close+0xae>
    1e00:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1e06:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1e0c:	39 ce                	cmp    %ecx,%esi
    1e0e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1e14:	0f 84 ae 03 00 00    	je     21c8 <rlc_close+0x458>
    1e1a:	89 fb                	mov    %edi,%ebx
    1e1c:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1e1e:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1e24:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1e27:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1e29:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1e2b:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1e32:	01 10 00 
	entry->prev = LIST_POISON2;
    1e35:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1e3c:	02 20 00 
    1e3f:	85 c0                	test   %eax,%eax
    1e41:	74 0b                	je     1e4e <rlc_close+0xde>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1e43:	e8 fc ff ff ff       	call   1e44 <rlc_close+0xd4>
						amBuffer->pkt = NULL;
    1e48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1e4e:	85 db                	test   %ebx,%ebx
    1e50:	74 07                	je     1e59 <rlc_close+0xe9>
					{
						fsm_mem_free(amBuffer);
    1e52:	89 d8                	mov    %ebx,%eax
    1e54:	e8 fc ff ff ff       	call   1e55 <rlc_close+0xe5>
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
    1e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5c:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    1e62:	75 9c                	jne    1e00 <rlc_close+0x90>
    1e64:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
						break;
    1e66:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
    1e68:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
    1e6f:	e8 fc ff ff ff       	call   1e70 <rlc_close+0x100>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1e74:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    1e7a:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    1e80:	39 c2                	cmp    %eax,%edx
    1e82:	0f 84 59 03 00 00    	je     21e1 <rlc_close+0x471>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    1e88:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1e8e:	8b 00                	mov    (%eax),%eax
    1e90:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1e93:	89 d6                	mov    %edx,%esi
    1e95:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1e9b:	eb 21                	jmp    1ebe <rlc_close+0x14e>
    1e9d:	8d 76 00             	lea    0x0(%esi),%esi
    1ea0:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1ea6:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1eac:	39 ce                	cmp    %ecx,%esi
    1eae:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1eb4:	0f 84 e6 02 00 00    	je     21a0 <rlc_close+0x430>
    1eba:	89 fb                	mov    %edi,%ebx
    1ebc:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ebe:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1ec4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1ec7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1ec9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1ecb:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1ed2:	01 10 00 
	entry->prev = LIST_POISON2;
    1ed5:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1edc:	02 20 00 
    1edf:	85 c0                	test   %eax,%eax
    1ee1:	74 0b                	je     1eee <rlc_close+0x17e>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1ee3:	e8 fc ff ff ff       	call   1ee4 <rlc_close+0x174>
						amBuffer->pkt = NULL;
    1ee8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1eee:	85 db                	test   %ebx,%ebx
    1ef0:	74 07                	je     1ef9 <rlc_close+0x189>
					{
						fsm_mem_free(amBuffer);
    1ef2:	89 d8                	mov    %ebx,%eax
    1ef4:	e8 fc ff ff ff       	call   1ef5 <rlc_close+0x185>
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
    1ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1efc:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    1f02:	75 9c                	jne    1ea0 <rlc_close+0x130>
    1f04:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
						break;
    1f06:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
    1f08:	c7 04 24 2c 01 00 00 	movl   $0x12c,(%esp)
    1f0f:	e8 fc ff ff ff       	call   1f10 <rlc_close+0x1a0>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1f14:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    1f17:	8d 4e 44             	lea    0x44(%esi),%ecx
    1f1a:	39 f9                	cmp    %edi,%ecx
    1f1c:	0f 84 91 02 00 00    	je     21b3 <rlc_close+0x443>
			{
				list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    1f22:	8b 07                	mov    (%edi),%eax
    1f24:	83 ef 0c             	sub    $0xc,%edi
    1f27:	89 75 ec             	mov    %esi,-0x14(%ebp)
    1f2a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    1f2d:	89 cb                	mov    %ecx,%ebx
    1f2f:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f32:	89 d6                	mov    %edx,%esi
    1f34:	eb 17                	jmp    1f4d <rlc_close+0x1dd>
    1f36:	66 90                	xchg   %ax,%ax
    1f38:	8b 46 0c             	mov    0xc(%esi),%eax
    1f3b:	8d 4e 0c             	lea    0xc(%esi),%ecx
    1f3e:	39 cb                	cmp    %ecx,%ebx
    1f40:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f43:	0f 84 07 02 00 00    	je     2150 <rlc_close+0x3e0>
    1f49:	89 f7                	mov    %esi,%edi
    1f4b:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1f4d:	8b 57 10             	mov    0x10(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1f50:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1f53:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amsBuffer->list);
					if(amBuffer->pkt != NULL)
    1f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1f58:	c7 47 0c 00 01 10 00 	movl   $0x100100,0xc(%edi)
	entry->prev = LIST_POISON2;
    1f5f:	c7 47 10 00 02 20 00 	movl   $0x200200,0x10(%edi)
    1f66:	8b 00                	mov    (%eax),%eax
    1f68:	85 c0                	test   %eax,%eax
    1f6a:	74 10                	je     1f7c <rlc_close+0x20c>
					{
						fsm_pkt_destroy(amsBuffer->pkt);
    1f6c:	8b 07                	mov    (%edi),%eax
    1f6e:	e8 fc ff ff ff       	call   1f6f <rlc_close+0x1ff>
						amBuffer->pkt = NULL;
    1f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					}
					if(amsBuffer != NULL)
    1f7c:	85 ff                	test   %edi,%edi
    1f7e:	74 07                	je     1f87 <rlc_close+0x217>
					{
						fsm_mem_free(amsBuffer);
    1f80:	89 f8                	mov    %edi,%eax
    1f82:	e8 fc ff ff ff       	call   1f83 <rlc_close+0x213>
						amsBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amSduBuffer.list))
    1f87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f8a:	3b 58 44             	cmp    0x44(%eax),%ebx
    1f8d:	75 a9                	jne    1f38 <rlc_close+0x1c8>
    1f8f:	89 c6                	mov    %eax,%esi
    1f91:	8b 5d f0             	mov    -0x10(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:sdu buffer is realeasing\n");
    1f94:	c7 04 24 94 01 00 00 	movl   $0x194,(%esp)
    1f9b:	e8 fc ff ff ff       	call   1f9c <rlc_close+0x22c>
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    1fa0:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    1fa6:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    1fac:	0f 84 b6 01 00 00    	je     2168 <rlc_close+0x3f8>
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is not empty\n");
    1fb2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    1fb5:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
    1fbc:	e8 fc ff ff ff       	call   1fbd <rlc_close+0x24d>
				list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    1fc1:	8b 96 b0 01 00 00    	mov    0x1b0(%esi),%edx
    1fc7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    1fca:	8b 02                	mov    (%edx),%eax
    1fcc:	8d 7a fc             	lea    -0x4(%edx),%edi
    1fcf:	39 d1                	cmp    %edx,%ecx
    1fd1:	74 78                	je     204b <rlc_close+0x2db>
    1fd3:	8d 50 fc             	lea    -0x4(%eax),%edx
    1fd6:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1fd9:	89 ce                	mov    %ecx,%esi
    1fdb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    1fde:	89 d3                	mov    %edx,%ebx
    1fe0:	eb 1b                	jmp    1ffd <rlc_close+0x28d>
    1fe2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1fe8:	8b 43 04             	mov    0x4(%ebx),%eax
    1feb:	8d 4b 04             	lea    0x4(%ebx),%ecx
    1fee:	39 ce                	cmp    %ecx,%esi
    1ff0:	8d 50 fc             	lea    -0x4(%eax),%edx
    1ff3:	0f 84 ff 01 00 00    	je     21f8 <rlc_close+0x488>
    1ff9:	89 df                	mov    %ebx,%edi
    1ffb:	89 d3                	mov    %edx,%ebx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ffd:	8b 57 08             	mov    0x8(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2000:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2003:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    2005:	8b 07                	mov    (%edi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2007:	c7 47 04 00 01 10 00 	movl   $0x100100,0x4(%edi)
	entry->prev = LIST_POISON2;
    200e:	c7 47 08 00 02 20 00 	movl   $0x200200,0x8(%edi)
    2015:	85 c0                	test   %eax,%eax
    2017:	74 0b                	je     2024 <rlc_close+0x2b4>
					{
						fsm_pkt_destroy(buffer->pkt);
    2019:	e8 fc ff ff ff       	call   201a <rlc_close+0x2aa>
						buffer->pkt = NULL;
    201e:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
					}
					if(buffer != NULL)
    2024:	85 ff                	test   %edi,%edi
    2026:	74 07                	je     202f <rlc_close+0x2bf>
					{
						fsm_mem_free(buffer);
    2028:	89 f8                	mov    %edi,%eax
    202a:	e8 fc ff ff ff       	call   202b <rlc_close+0x2bb>
						buffer = NULL;
					}					
					if(list_empty(&amIns->ctrlPduBuffer.list))
    202f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2032:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    2038:	75 ae                	jne    1fe8 <rlc_close+0x278>
    203a:	89 c6                	mov    %eax,%esi
    203c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:ctrl buffer is realeasing\n");
    203f:	c7 04 24 20 02 00 00 	movl   $0x220,(%esp)
    2046:	e8 fc ff ff ff       	call   2047 <rlc_close+0x2d7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    204b:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    2051:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2057:	39 c2                	cmp    %eax,%edx
    2059:	0f 84 29 01 00 00    	je     2188 <rlc_close+0x418>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    205f:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    2065:	8b 00                	mov    (%eax),%eax
    2067:	89 75 f0             	mov    %esi,-0x10(%ebp)
    206a:	89 d6                	mov    %edx,%esi
    206c:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    2072:	eb 22                	jmp    2096 <rlc_close+0x326>
    2074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    207e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    2084:	39 ce                	cmp    %ecx,%esi
    2086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    208c:	0f 84 b6 00 00 00    	je     2148 <rlc_close+0x3d8>
    2092:	89 fb                	mov    %edi,%ebx
    2094:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2096:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    209c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    209f:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    20a1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    20a3:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    20aa:	01 10 00 
	entry->prev = LIST_POISON2;
    20ad:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    20b4:	02 20 00 
    20b7:	85 c0                	test   %eax,%eax
    20b9:	74 0b                	je     20c6 <rlc_close+0x356>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    20bb:	e8 fc ff ff ff       	call   20bc <rlc_close+0x34c>
						amBuffer->pkt = NULL;
    20c0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    20c6:	85 db                	test   %ebx,%ebx
    20c8:	74 07                	je     20d1 <rlc_close+0x361>
					{
						fsm_mem_free(amBuffer);
    20ca:	89 d8                	mov    %ebx,%eax
    20cc:	e8 fc ff ff ff       	call   20cd <rlc_close+0x35d>
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
    20d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    20d4:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    20da:	75 9c                	jne    2078 <rlc_close+0x308>
    20dc:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
						break;
    20de:	31 db                	xor    %ebx,%ebx
						fsm_mem_free(amBuffer);
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
    20e0:	c7 04 24 7c 02 00 00 	movl   $0x27c,(%esp)
    20e7:	e8 fc ff ff ff       	call   20e8 <rlc_close+0x378>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] am instance  has released(rbid is%d)\n", amIns->rbId);
    20ec:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    20f0:	c7 04 24 d8 02 00 00 	movl   $0x2d8,(%esp)
    20f7:	89 44 24 04          	mov    %eax,0x4(%esp)
    20fb:	e8 fc ff ff ff       	call   20fc <rlc_close+0x38c>
			if(amIns != NULL)
    2100:	85 f6                	test   %esi,%esi
    2102:	74 07                	je     210b <rlc_close+0x39b>
			{
				fsm_mem_free(amIns);
    2104:	89 f0                	mov    %esi,%eax
    2106:	e8 fc ff ff ff       	call   2107 <rlc_close+0x397>
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
    210b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    210e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2111:	3b 90 f4 25 00 00    	cmp    0x25f4(%eax),%edx
    2117:	0f 84 e6 00 00 00    	je     2203 <rlc_close+0x493>
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
//AM
	if(!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    211d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    2120:	8b 81 04 23 00 00    	mov    0x2304(%ecx),%eax
    2126:	81 c1 04 23 00 00    	add    $0x2304,%ecx
    212c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
    212f:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    2135:	0f 84 d4 00 00 00    	je     220f <rlc_close+0x49f>
    213b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    213e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    2141:	e9 72 fc ff ff       	jmp    1db8 <rlc_close+0x48>
    2146:	66 90                	xchg   %ax,%ax
    2148:	8b 75 f0             	mov    -0x10(%ebp),%esi
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    214b:	89 fb                	mov    %edi,%ebx
    214d:	eb 9d                	jmp    20ec <rlc_close+0x37c>
    214f:	90                   	nop
    2150:	8b 75 ec             	mov    -0x14(%ebp),%esi
    2153:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    2156:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    215c:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    2162:	0f 85 4a fe ff ff    	jne    1fb2 <rlc_close+0x242>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
    2168:	c7 04 24 50 02 00 00 	movl   $0x250,(%esp)
    216f:	e8 fc ff ff ff       	call   2170 <rlc_close+0x400>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2174:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    217a:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2180:	39 c2                	cmp    %eax,%edx
    2182:	0f 85 d7 fe ff ff    	jne    205f <rlc_close+0x2ef>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
    2188:	c7 04 24 ac 02 00 00 	movl   $0x2ac,(%esp)
    218f:	e8 fc ff ff ff       	call   2190 <rlc_close+0x420>
    2194:	e9 53 ff ff ff       	jmp    20ec <rlc_close+0x37c>
    2199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    21a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    21a3:	89 fb                	mov    %edi,%ebx
    21a5:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    21a8:	8d 4e 44             	lea    0x44(%esi),%ecx
    21ab:	39 f9                	cmp    %edi,%ecx
    21ad:	0f 85 6f fd ff ff    	jne    1f22 <rlc_close+0x1b2>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
    21b3:	c7 04 24 c4 01 00 00 	movl   $0x1c4,(%esp)
    21ba:	e8 fc ff ff ff       	call   21bb <rlc_close+0x44b>
    21bf:	e9 dc fd ff ff       	jmp    1fa0 <rlc_close+0x230>
    21c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    21c8:	8b 75 f0             	mov    -0x10(%ebp),%esi
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    21cb:	89 fb                	mov    %edi,%ebx
    21cd:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    21d3:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    21d9:	39 c2                	cmp    %eax,%edx
    21db:	0f 85 a7 fc ff ff    	jne    1e88 <rlc_close+0x118>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
    21e1:	c7 04 24 64 01 00 00 	movl   $0x164,(%esp)
    21e8:	e8 fc ff ff ff       	call   21e9 <rlc_close+0x479>
    21ed:	e9 22 fd ff ff       	jmp    1f14 <rlc_close+0x1a4>
    21f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    21f8:	8b 75 f0             	mov    -0x10(%ebp),%esi
    21fb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    21fe:	e9 48 fe ff ff       	jmp    204b <rlc_close+0x2db>
				fsm_mem_free(amIns);
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
			{
				fsm_printf("[RLC][rlc_close] amInsList is empty\n");
    2203:	c7 04 24 10 03 00 00 	movl   $0x310,(%esp)
    220a:	e8 fc ff ff ff       	call   220b <rlc_close+0x49b>
				break;
			}
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    220f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2212:	05 c0 36 00 00       	add    $0x36c0,%eax
    2217:	89 45 e8             	mov    %eax,-0x18(%ebp)
    221a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    221d:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
    2223:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2226:	0f 84 13 01 00 00    	je     233f <rlc_close+0x5cf>
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    222c:	8b 02                	mov    (%edx),%eax
    222e:	81 ea c4 10 00 00    	sub    $0x10c4,%edx
    2234:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2237:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    223d:	89 55 ec             	mov    %edx,-0x14(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2240:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2243:	8b 91 c8 10 00 00    	mov    0x10c8(%ecx),%edx
		{
			list_del(&umRxIns->umRxList);
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    2249:	89 cf                	mov    %ecx,%edi
    224b:	83 c7 30             	add    $0x30,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    224e:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2251:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2253:	8b 59 30             	mov    0x30(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2256:	c7 81 c4 10 00 00 00 	movl   $0x100100,0x10c4(%ecx)
    225d:	01 10 00 
	entry->prev = LIST_POISON2;
    2260:	c7 81 c8 10 00 00 00 	movl   $0x200200,0x10c8(%ecx)
    2267:	02 20 00 
    226a:	39 df                	cmp    %ebx,%edi
    226c:	0f 84 f5 03 00 00    	je     2667 <rlc_close+0x8f7>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    2272:	8b 03                	mov    (%ebx),%eax
    2274:	83 eb 10             	sub    $0x10,%ebx
    2277:	8d 70 f0             	lea    -0x10(%eax),%esi
    227a:	eb 15                	jmp    2291 <rlc_close+0x521>
    227c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2280:	8b 46 10             	mov    0x10(%esi),%eax
    2283:	8d 4e 10             	lea    0x10(%esi),%ecx
    2286:	39 cf                	cmp    %ecx,%edi
    2288:	8d 50 f0             	lea    -0x10(%eax),%edx
    228b:	74 4a                	je     22d7 <rlc_close+0x567>
    228d:	89 f3                	mov    %esi,%ebx
    228f:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2291:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2294:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2297:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    2299:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    229b:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    22a2:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    22a9:	85 c0                	test   %eax,%eax
    22ab:	74 0b                	je     22b8 <rlc_close+0x548>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    22ad:	e8 fc ff ff ff       	call   22ae <rlc_close+0x53e>
						umBuffer->pkt = NULL;
    22b2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    22b8:	85 db                	test   %ebx,%ebx
    22ba:	74 07                	je     22c3 <rlc_close+0x553>
					{
						fsm_mem_free(umBuffer);
    22bc:	89 d8                	mov    %ebx,%eax
    22be:	e8 fc ff ff ff       	call   22bf <rlc_close+0x54f>
						umBuffer = NULL;
					}				
					
					if(list_empty(&umRxIns->umRecvBuffer.list))
    22c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22c6:	3b 78 30             	cmp    0x30(%eax),%edi
    22c9:	75 b5                	jne    2280 <rlc_close+0x510>
					{
						fsm_printf("[RLC][rlc_close] um recv:recv buffer is realeasing\n");
    22cb:	c7 04 24 38 03 00 00 	movl   $0x338,(%esp)
    22d2:	e8 fc ff ff ff       	call   22d3 <rlc_close+0x563>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umRxIns->rbId);
    22d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22da:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    22de:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    22e5:	89 44 24 04          	mov    %eax,0x4(%esp)
    22e9:	e8 fc ff ff ff       	call   22ea <rlc_close+0x57a>
			if(umRxIns != NULL)
    22ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    22f1:	85 c9                	test   %ecx,%ecx
    22f3:	74 08                	je     22fd <rlc_close+0x58d>
			{
				fsm_mem_free(umRxIns);
    22f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22f8:	e8 fc ff ff ff       	call   22f9 <rlc_close+0x589>
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
    22fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2300:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2303:	3b 90 c0 36 00 00    	cmp    0x36c0(%eax),%edx
    2309:	74 28                	je     2333 <rlc_close+0x5c3>
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    230b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    230e:	8b 81 c4 10 00 00    	mov    0x10c4(%ecx),%eax
    2314:	81 c1 c4 10 00 00    	add    $0x10c4,%ecx
    231a:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    231d:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    2323:	74 1a                	je     233f <rlc_close+0x5cf>
    2325:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2328:	89 55 ec             	mov    %edx,-0x14(%ebp)
    232b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    232e:	e9 0d ff ff ff       	jmp    2240 <rlc_close+0x4d0>
				fsm_mem_free(umRxIns);
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
			{
				fsm_printf("[RLC][rlc_close] umRxInsList is empty\n");
    2333:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
    233a:	e8 fc ff ff ff       	call   233b <rlc_close+0x5cb>
				break;
			}
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
    233f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2342:	05 f8 36 00 00       	add    $0x36f8,%eax
    2347:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    234a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    234d:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
    2353:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2356:	0f 84 02 01 00 00    	je     245e <rlc_close+0x6ee>
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    235c:	8b 02                	mov    (%edx),%eax
    235e:	83 ea 30             	sub    $0x30,%edx
    2361:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2364:	8d 50 d0             	lea    -0x30(%eax),%edx
    2367:	89 55 ec             	mov    %edx,-0x14(%ebp)
    236a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2370:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2373:	8b 51 34             	mov    0x34(%ecx),%edx
		{
			list_del(&umTxIns->umTxList);
			if(!list_empty(&umTxIns->umSduBuffer.list))
    2376:	89 cf                	mov    %ecx,%edi
    2378:	83 c7 18             	add    $0x18,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    237b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    237e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2380:	8b 59 18             	mov    0x18(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2383:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    238a:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    2391:	39 df                	cmp    %ebx,%edi
    2393:	0f 84 bd 02 00 00    	je     2656 <rlc_close+0x8e6>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    2399:	8b 03                	mov    (%ebx),%eax
    239b:	83 eb 10             	sub    $0x10,%ebx
    239e:	8d 70 f0             	lea    -0x10(%eax),%esi
    23a1:	eb 16                	jmp    23b9 <rlc_close+0x649>
    23a3:	90                   	nop
    23a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    23a8:	8b 46 10             	mov    0x10(%esi),%eax
    23ab:	8d 4e 10             	lea    0x10(%esi),%ecx
    23ae:	39 cf                	cmp    %ecx,%edi
    23b0:	8d 50 f0             	lea    -0x10(%eax),%edx
    23b3:	74 4a                	je     23ff <rlc_close+0x68f>
    23b5:	89 f3                	mov    %esi,%ebx
    23b7:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    23b9:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    23bc:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    23bf:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    23c1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    23c3:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    23ca:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    23d1:	85 c0                	test   %eax,%eax
    23d3:	74 0b                	je     23e0 <rlc_close+0x670>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    23d5:	e8 fc ff ff ff       	call   23d6 <rlc_close+0x666>
						umBuffer->pkt = NULL;
    23da:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    23e0:	85 db                	test   %ebx,%ebx
    23e2:	74 07                	je     23eb <rlc_close+0x67b>
					{
						fsm_mem_free(umBuffer);
    23e4:	89 d8                	mov    %ebx,%eax
    23e6:	e8 fc ff ff ff       	call   23e7 <rlc_close+0x677>
						umBuffer = NULL;
					}					
					
					if(list_empty(&umTxIns->umSduBuffer.list))
    23eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23ee:	3b 78 18             	cmp    0x18(%eax),%edi
    23f1:	75 b5                	jne    23a8 <rlc_close+0x638>
					{
						fsm_printf("[RLC][rlc_close] um tran:sdu buffer is realeasing\n");
    23f3:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
    23fa:	e8 fc ff ff ff       	call   23fb <rlc_close+0x68b>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umTxIns->rbid);
    23ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2402:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    2406:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    240d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2411:	e8 fc ff ff ff       	call   2412 <rlc_close+0x6a2>
			if(umTxIns != NULL)
    2416:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2419:	85 d2                	test   %edx,%edx
    241b:	74 08                	je     2425 <rlc_close+0x6b5>
			{
				fsm_mem_free(umTxIns);
    241d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2420:	e8 fc ff ff ff       	call   2421 <rlc_close+0x6b1>
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
    2425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2428:	8b 55 e8             	mov    -0x18(%ebp),%edx
    242b:	3b 90 f8 36 00 00    	cmp    0x36f8(%eax),%edx
    2431:	74 1f                	je     2452 <rlc_close+0x6e2>
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    2433:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2436:	8b 41 30             	mov    0x30(%ecx),%eax
    2439:	83 c1 30             	add    $0x30,%ecx
    243c:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    243f:	8d 50 d0             	lea    -0x30(%eax),%edx
    2442:	74 1a                	je     245e <rlc_close+0x6ee>
    2444:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2447:	89 55 ec             	mov    %edx,-0x14(%ebp)
    244a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    244d:	e9 1e ff ff ff       	jmp    2370 <rlc_close+0x600>
				fsm_mem_free(umTxIns);
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
			{
				fsm_printf("[RLC][rlc_close] umTxInsList is empty\n");
    2452:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2459:	e8 fc ff ff ff       	call   245a <rlc_close+0x6ea>
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
    245e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2461:	05 2c 37 00 00       	add    $0x372c,%eax
    2466:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    246c:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
    2472:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2475:	0f 84 1f 01 00 00    	je     259a <rlc_close+0x82a>
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    247b:	8b 02                	mov    (%edx),%eax
    247d:	83 ea 1c             	sub    $0x1c,%edx
    2480:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2483:	8d 50 e4             	lea    -0x1c(%eax),%edx
    2486:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2490:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2493:	8b 51 20             	mov    0x20(%ecx),%edx
		{
			list_del(&tmTxIns->tmTxList);
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    2496:	89 cf                	mov    %ecx,%edi
    2498:	83 c7 0c             	add    $0xc,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    249b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    249e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    24a0:	8b 59 0c             	mov    0xc(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24a3:	c7 41 1c 00 01 10 00 	movl   $0x100100,0x1c(%ecx)
	entry->prev = LIST_POISON2;
    24aa:	c7 41 20 00 02 20 00 	movl   $0x200200,0x20(%ecx)
    24b1:	39 df                	cmp    %ebx,%edi
    24b3:	74 56                	je     250b <rlc_close+0x79b>
			{
				list_for_each_entry_safe(buffer,tempBuffer, &tmTxIns->tmSduBuffer.list,list)
    24b5:	8b 03                	mov    (%ebx),%eax
    24b7:	83 eb 04             	sub    $0x4,%ebx
    24ba:	8d 70 fc             	lea    -0x4(%eax),%esi
    24bd:	eb 12                	jmp    24d1 <rlc_close+0x761>
    24bf:	90                   	nop
    24c0:	8b 46 04             	mov    0x4(%esi),%eax
    24c3:	8d 4e 04             	lea    0x4(%esi),%ecx
    24c6:	39 cf                	cmp    %ecx,%edi
    24c8:	8d 50 fc             	lea    -0x4(%eax),%edx
    24cb:	74 4a                	je     2517 <rlc_close+0x7a7>
    24cd:	89 f3                	mov    %esi,%ebx
    24cf:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    24d1:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    24d4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    24d7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    24d9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24db:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    24e2:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    24e9:	85 c0                	test   %eax,%eax
    24eb:	74 0b                	je     24f8 <rlc_close+0x788>
					{
						fsm_pkt_destroy(buffer->pkt);
    24ed:	e8 fc ff ff ff       	call   24ee <rlc_close+0x77e>
						buffer->pkt = NULL;
    24f2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(buffer != NULL)
    24f8:	85 db                	test   %ebx,%ebx
    24fa:	74 07                	je     2503 <rlc_close+0x793>
					{
						fsm_mem_free(buffer);
    24fc:	89 d8                	mov    %ebx,%eax
    24fe:	e8 fc ff ff ff       	call   24ff <rlc_close+0x78f>
						buffer = NULL;
					}					
					
					if(list_empty(&tmTxIns->tmSduBuffer.list))
    2503:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2506:	3b 78 0c             	cmp    0xc(%eax),%edi
    2509:	75 b5                	jne    24c0 <rlc_close+0x750>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
    250b:	c7 04 24 88 04 00 00 	movl   $0x488,(%esp)
    2512:	e8 fc ff ff ff       	call   2513 <rlc_close+0x7a3>
			}
			if( tmTxIns->pbCh == 0)
    2517:	8b 55 f0             	mov    -0x10(%ebp),%edx
    251a:	0f b6 42 04          	movzbl 0x4(%edx),%eax
    251e:	84 c0                	test   %al,%al
    2520:	74 4e                	je     2570 <rlc_close+0x800>
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
			}
			else if(tmTxIns->pbCh == 1)
    2522:	3c 01                	cmp    $0x1,%al
    2524:	74 5a                	je     2580 <rlc_close+0x810>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    2526:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    252d:	e8 fc ff ff ff       	call   252e <rlc_close+0x7be>
			}
			if(tmTxIns != NULL)
    2532:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2535:	85 c0                	test   %eax,%eax
    2537:	74 08                	je     2541 <rlc_close+0x7d1>
			{
				fsm_mem_free(tmTxIns);
    2539:	8b 45 f0             	mov    -0x10(%ebp),%eax
    253c:	e8 fc ff ff ff       	call   253d <rlc_close+0x7cd>
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
    2541:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2544:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2547:	3b 90 2c 37 00 00    	cmp    0x372c(%eax),%edx
    254d:	74 3f                	je     258e <rlc_close+0x81e>
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    254f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2552:	8b 41 1c             	mov    0x1c(%ecx),%eax
    2555:	83 c1 1c             	add    $0x1c,%ecx
    2558:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    255b:	8d 50 e4             	lea    -0x1c(%eax),%edx
    255e:	74 3a                	je     259a <rlc_close+0x82a>
    2560:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2563:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2566:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2569:	e9 22 ff ff ff       	jmp    2490 <rlc_close+0x720>
    256e:	66 90                	xchg   %ax,%ax
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
			}
			if( tmTxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
    2570:	c7 04 24 b4 04 00 00 	movl   $0x4b4,(%esp)
    2577:	e8 fc ff ff ff       	call   2578 <rlc_close+0x808>
    257c:	eb b4                	jmp    2532 <rlc_close+0x7c2>
    257e:	66 90                	xchg   %ax,%ax
			}
			else if(tmTxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2580:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    2587:	e8 fc ff ff ff       	call   2588 <rlc_close+0x818>
    258c:	eb a4                	jmp    2532 <rlc_close+0x7c2>
				fsm_mem_free(tmTxIns);
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
			{
				fsm_printf("[RLC][rlc_close] tmTxInsList is empty\n");
    258e:	c7 04 24 28 05 00 00 	movl   $0x528,(%esp)
    2595:	e8 fc ff ff ff       	call   2596 <rlc_close+0x826>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    259a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
    259d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    25a0:	8b 98 08 37 00 00    	mov    0x3708(%eax),%ebx
    25a6:	81 c7 08 37 00 00    	add    $0x3708,%edi
    25ac:	39 df                	cmp    %ebx,%edi
    25ae:	0f 84 8e 00 00 00    	je     2642 <rlc_close+0x8d2>
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25b4:	8b 03                	mov    (%ebx),%eax
    25b6:	83 eb 08             	sub    $0x8,%ebx
    25b9:	8d 70 f8             	lea    -0x8(%eax),%esi
    25bc:	eb 39                	jmp    25f7 <rlc_close+0x887>
    25be:	66 90                	xchg   %ax,%ax
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
			}
			else if(tmRxIns->pbCh == 1)
    25c0:	3c 01                	cmp    $0x1,%al
    25c2:	74 64                	je     2628 <rlc_close+0x8b8>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    25c4:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    25cb:	e8 fc ff ff ff       	call   25cc <rlc_close+0x85c>
			}
			if(tmRxIns != NULL)
    25d0:	85 db                	test   %ebx,%ebx
    25d2:	74 07                	je     25db <rlc_close+0x86b>
			{
				fsm_mem_free(tmRxIns);
    25d4:	89 d8                	mov    %ebx,%eax
    25d6:	e8 fc ff ff ff       	call   25d7 <rlc_close+0x867>
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
    25db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25de:	3b b8 08 37 00 00    	cmp    0x3708(%eax),%edi
    25e4:	74 50                	je     2636 <rlc_close+0x8c6>
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25e6:	8b 46 08             	mov    0x8(%esi),%eax
    25e9:	8d 4e 08             	lea    0x8(%esi),%ecx
    25ec:	39 cf                	cmp    %ecx,%edi
    25ee:	8d 50 f8             	lea    -0x8(%eax),%edx
    25f1:	74 4f                	je     2642 <rlc_close+0x8d2>
    25f3:	89 f3                	mov    %esi,%ebx
    25f5:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    25f7:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    25fa:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    25fd:	89 02                	mov    %eax,(%edx)
		{
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
    25ff:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2603:	c7 43 08 00 01 10 00 	movl   $0x100100,0x8(%ebx)
	entry->prev = LIST_POISON2;
    260a:	c7 43 0c 00 02 20 00 	movl   $0x200200,0xc(%ebx)
    2611:	84 c0                	test   %al,%al
    2613:	75 ab                	jne    25c0 <rlc_close+0x850>
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
    2615:	c7 04 24 50 05 00 00 	movl   $0x550,(%esp)
    261c:	e8 fc ff ff ff       	call   261d <rlc_close+0x8ad>
    2621:	eb ad                	jmp    25d0 <rlc_close+0x860>
    2623:	90                   	nop
    2624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			else if(tmRxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2628:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    262f:	e8 fc ff ff ff       	call   2630 <rlc_close+0x8c0>
    2634:	eb 9a                	jmp    25d0 <rlc_close+0x860>
				fsm_mem_free(tmRxIns);
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
			{
				fsm_printf("[RLC][rlc_close] tmRxInsList is empty\n");
    2636:	c7 04 24 7c 05 00 00 	movl   $0x57c,(%esp)
    263d:	e8 fc ff ff ff       	call   263e <rlc_close+0x8ce>
				break;
			}
		}
	}
	fsm_printf("[RLC][rlc_close] rlc has closed \n");
    2642:	c7 04 24 a4 05 00 00 	movl   $0x5a4,(%esp)
    2649:	e8 fc ff ff ff       	call   264a <rlc_close+0x8da>
	FOUT;
}
    264e:	83 c4 20             	add    $0x20,%esp
    2651:	5b                   	pop    %ebx
    2652:	5e                   	pop    %esi
    2653:	5f                   	pop    %edi
    2654:	5d                   	pop    %ebp
    2655:	c3                   	ret    
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
    2656:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
    265d:	e8 fc ff ff ff       	call   265e <rlc_close+0x8ee>
    2662:	e9 98 fd ff ff       	jmp    23ff <rlc_close+0x68f>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
    2667:	c7 04 24 6c 03 00 00 	movl   $0x36c,(%esp)
    266e:	e8 fc ff ff ff       	call   266f <rlc_close+0x8ff>
    2673:	e9 5f fc ff ff       	jmp    22d7 <rlc_close+0x567>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
    2678:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
    267f:	e8 fc ff ff ff       	call   2680 <rlc_close+0x910>
    2684:	e9 eb f7 ff ff       	jmp    1e74 <rlc_close+0x104>
    2689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00002690 <StartWaitingForRaResponse>:
->output:
->Special:
*******************************
*/
static void StartWaitingForRaResponse()
{
    2690:	55                   	push   %ebp
    2691:	89 e5                	mov    %esp,%ebp
    2693:	53                   	push   %ebx
    2694:	83 ec 04             	sub    $0x4,%esp
    2697:	e8 fc ff ff ff       	call   2698 <StartWaitingForRaResponse+0x8>
	FIN(StartWaitingForRaResponse());
	SV_PTR_GET(rlc_mac_sv);
    269c:	e8 fc ff ff ff       	call   269d <StartWaitingForRaResponse+0xd>
    26a1:	89 c3                	mov    %eax,%ebx
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
    26a3:	8b 80 cc 00 00 00    	mov    0xcc(%eax),%eax
    26a9:	89 83 90 01 00 00    	mov    %eax,0x190(%ebx)
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
    26af:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)
    26b6:	e8 fc ff ff ff       	call   26b7 <StartWaitingForRaResponse+0x27>
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26bb:	ba 18 00 00 00       	mov    $0x18,%edx
    26c0:	6b 83 90 01 00 00 64 	imul   $0x64,0x190(%ebx),%eax
    26c7:	e8 fc ff ff ff       	call   26c8 <StartWaitingForRaResponse+0x38>
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
    26cc:	c6 83 98 01 00 00 01 	movb   $0x1,0x198(%ebx)
	SV_PTR_GET(rlc_mac_sv);
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26d3:	89 83 94 01 00 00    	mov    %eax,0x194(%ebx)
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
	FOUT;
}
    26d9:	83 c4 04             	add    $0x4,%esp
    26dc:	5b                   	pop    %ebx
    26dd:	5d                   	pop    %ebp
    26de:	c3                   	ret    
    26df:	90                   	nop

000026e0 <send_SR>:
->output:
->Special:
*******************************
*/
static void send_SR()
{
    26e0:	55                   	push   %ebp
    26e1:	89 e5                	mov    %esp,%ebp
    26e3:	53                   	push   %ebx
    26e4:	83 ec 04             	sub    $0x4,%esp
    26e7:	e8 fc ff ff ff       	call   26e8 <send_SR+0x8>
	FIN(send_SR());
	SV_PTR_GET(rlc_mac_sv);
    26ec:	e8 fc ff ff ff       	call   26ed <send_SR+0xd>
    26f1:	89 c3                	mov    %eax,%ebx
	fsm_printf("[UE MAC]send_SR\n");
    26f3:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    26fa:	e8 fc ff ff ff       	call   26fb <send_SR+0x1b>
	fsm_schedule_self(0,SR_Fail);//SR
    26ff:	ba 07 00 00 00       	mov    $0x7,%edx
    2704:	31 c0                	xor    %eax,%eax
    2706:	e8 fc ff ff ff       	call   2707 <send_SR+0x27>
	SV(ratype.ra_type)=2;
    270b:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    2712:	00 00 00 
	FOUT;
}
    2715:	83 c4 04             	add    $0x4,%esp
    2718:	5b                   	pop    %ebx
    2719:	5d                   	pop    %ebp
    271a:	c3                   	ret    
    271b:	90                   	nop
    271c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00002720 <rlc_init_enter>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void rlc_init_enter(void)
{
    2720:	55                   	push   %ebp
    2721:	89 e5                	mov    %esp,%ebp
    2723:	57                   	push   %edi
    2724:	56                   	push   %esi
    2725:	53                   	push   %ebx
    2726:	83 ec 04             	sub    $0x4,%esp
    2729:	e8 fc ff ff ff       	call   272a <rlc_init_enter+0xa>
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
    272e:	e8 fc ff ff ff       	call   272f <rlc_init_enter+0xf>
    2733:	89 c3                	mov    %eax,%ebx
	if(RLC_OPEN)
    2735:	e8 fc ff ff ff       	call   2736 <rlc_init_enter+0x16>
    273a:	83 f8 05             	cmp    $0x5,%eax
    273d:	74 09                	je     2748 <rlc_init_enter+0x28>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    273f:	83 c4 04             	add    $0x4,%esp
    2742:	5b                   	pop    %ebx
    2743:	5e                   	pop    %esi
    2744:	5f                   	pop    %edi
    2745:	5d                   	pop    %ebp
    2746:	c3                   	ret    
    2747:	90                   	nop
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
    2748:	e8 fc ff ff ff       	call   2749 <rlc_init_enter+0x29>
    274d:	85 c0                	test   %eax,%eax
    274f:	75 ee                	jne    273f <rlc_init_enter+0x1f>
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
    2751:	8d 83 f4 25 00 00    	lea    0x25f4(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2757:	89 83 f4 25 00 00    	mov    %eax,0x25f4(%ebx)
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
    275d:	8d b3 08 37 00 00    	lea    0x3708(%ebx),%esi
	list->prev = list;
    2763:	89 83 f8 25 00 00    	mov    %eax,0x25f8(%ebx)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
    2769:	8d 83 c0 36 00 00    	lea    0x36c0(%ebx),%eax
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
		INIT_LIST_HEAD(&SV(vTm_tx_ins).tmTxList);
    276f:	8d bb 2c 37 00 00    	lea    0x372c(%ebx),%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2775:	89 83 c0 36 00 00    	mov    %eax,0x36c0(%ebx)
	list->prev = list;
    277b:	89 83 c4 36 00 00    	mov    %eax,0x36c4(%ebx)
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
    2781:	8d 83 f8 36 00 00    	lea    0x36f8(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2787:	89 83 f8 36 00 00    	mov    %eax,0x36f8(%ebx)
	list->prev = list;
    278d:	89 83 fc 36 00 00    	mov    %eax,0x36fc(%ebx)
		SV(countDropPacket)=0;
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2793:	31 c0                	xor    %eax,%eax
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
    2795:	c6 83 24 02 00 00 00 	movb   $0x0,0x224(%ebx)
		SV(packetType) = -1;
    279c:	c7 83 20 02 00 00 ff 	movl   $0xffffffff,0x220(%ebx)
    27a3:	ff ff ff 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27a6:	89 b3 08 37 00 00    	mov    %esi,0x3708(%ebx)
	list->prev = list;
    27ac:	89 b3 0c 37 00 00    	mov    %esi,0x370c(%ebx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27b2:	89 bb 2c 37 00 00    	mov    %edi,0x372c(%ebx)
	list->prev = list;
    27b8:	89 bb 30 37 00 00    	mov    %edi,0x3730(%ebx)
		//mallocnum=0;
		//freenum=0;
	//	SV(pduLft).SN_Left = -1;
	//	SV(pduLft).sduLeft = NULL;
		//for test
		SV(countRecvFromUpper)=0;
    27be:	c7 83 8c 5a 00 00 00 	movl   $0x0,0x5a8c(%ebx)
    27c5:	00 00 00 
		SV(countSendToUpper)=0;
    27c8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    27cf:	00 00 00 
		SV(countRecvFromLower)=0;
    27d2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    27d9:	00 00 00 
		SV(countSentToLower)=0;
    27dc:	c7 83 98 5a 00 00 00 	movl   $0x0,0x5a98(%ebx)
    27e3:	00 00 00 
		SV(countDropPacket)=0;
    27e6:	c7 83 9c 5a 00 00 00 	movl   $0x0,0x5a9c(%ebx)
    27ed:	00 00 00 
		SV(countSendCtrlPdu)=0;
    27f0:	c7 83 a0 5a 00 00 00 	movl   $0x0,0x5aa0(%ebx)
    27f7:	00 00 00 
		SV(countRecvCtrlPdu)=0;
    27fa:	c7 83 a4 5a 00 00 00 	movl   $0x0,0x5aa4(%ebx)
    2801:	00 00 00 
		SV(max_queue_num)=0;
    2804:	c7 83 a8 5a 00 00 00 	movl   $0x0,0x5aa8(%ebx)
    280b:	00 00 00 
    280e:	66 90                	xchg   %ax,%ax
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2810:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
    2817:	83 c0 01             	add    $0x1,%eax
    281a:	83 f8 32             	cmp    $0x32,%eax
    281d:	75 f1                	jne    2810 <rlc_init_enter+0xf0>
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    281f:	c7 83 e8 02 00 00 ff 	movl   $0xffffffff,0x2e8(%ebx)
    2826:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2829:	b0 10                	mov    $0x10,%al
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    282b:	c7 83 cc 02 00 00 ff 	movl   $0xffffffff,0x2cc(%ebx)
    2832:	ff ff ff 
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
    2835:	c7 83 c8 02 00 00 ff 	movl   $0xffffffff,0x2c8(%ebx)
    283c:	ff ff ff 
    283f:	c7 83 c4 02 00 00 ff 	movl   $0xffffffff,0x2c4(%ebx)
    2846:	ff ff ff 
    2849:	c7 83 c0 02 00 00 ff 	movl   $0xffffffff,0x2c0(%ebx)
    2850:	ff ff ff 
    2853:	c7 83 bc 02 00 00 ff 	movl   $0xffffffff,0x2bc(%ebx)
    285a:	ff ff ff 
    285d:	c7 83 b8 02 00 00 ff 	movl   $0xffffffff,0x2b8(%ebx)
    2864:	ff ff ff 
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
    2867:	c7 83 b4 02 00 00 ff 	movl   $0xffffffff,0x2b4(%ebx)
    286e:	ff ff ff 
    2871:	c7 83 b0 02 00 00 ff 	movl   $0xffffffff,0x2b0(%ebx)
    2878:	ff ff ff 
    287b:	c7 83 ac 02 00 00 ff 	movl   $0xffffffff,0x2ac(%ebx)
    2882:	ff ff ff 
    2885:	c7 83 54 02 00 00 ff 	movl   $0xffffffff,0x254(%ebx)
    288c:	ff ff ff 
    288f:	c7 83 28 02 00 00 ff 	movl   $0xffffffff,0x228(%ebx)
    2896:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2899:	e8 fc ff ff ff       	call   289a <rlc_init_enter+0x17a>
		tmRxIns->pbCh = 1;            //PCCH
    289e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28a2:	8d 48 08             	lea    0x8(%eax),%ecx
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 1;            //PCCH
		tmRxIns->rnti = 0;
    28a5:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28aa:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;
    28ae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28b2:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28b8:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28be:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28c1:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    28c4:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");
    28c6:	c7 04 24 fc 05 00 00 	movl   $0x5fc,(%esp)
    28cd:	e8 fc ff ff ff       	call   28ce <rlc_init_enter+0x1ae>

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    28d2:	b8 10 00 00 00       	mov    $0x10,%eax
    28d7:	e8 fc ff ff ff       	call   28d8 <rlc_init_enter+0x1b8>
		tmRxIns->pbCh = 2;            //BCCH
    28dc:	c6 40 04 02          	movb   $0x2,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //BCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28e0:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 2;            //BCCH
		tmRxIns->rnti = 0;
    28e3:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28e8:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //BCCH
    28ec:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28f0:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28f6:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28fc:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28ff:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2902:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");
    2904:	c7 04 24 30 06 00 00 	movl   $0x630,(%esp)
    290b:	e8 fc ff ff ff       	call   290c <rlc_init_enter+0x1ec>

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2910:	b8 10 00 00 00       	mov    $0x10,%eax
    2915:	e8 fc ff ff ff       	call   2916 <rlc_init_enter+0x1f6>
		tmRxIns->pbCh = 0;            //CCCH
    291a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //CCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    291e:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 0;            //CCCH
		tmRxIns->rnti = 0;
    2921:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    2926:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //CCCH
    292a:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    292e:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2934:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    293a:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    293d:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2940:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");
    2942:	c7 04 24 64 06 00 00 	movl   $0x664,(%esp)
    2949:	e8 fc ff ff ff       	call   294a <rlc_init_enter+0x22a>

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
    294e:	b8 24 00 00 00       	mov    $0x24,%eax
    2953:	e8 fc ff ff ff       	call   2954 <rlc_init_enter+0x234>
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
    2958:	8d 50 0c             	lea    0xc(%eax),%edx
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
    295b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
		tmTxIns->tmSduBufferSize = 0;
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
    295f:	8d 48 1c             	lea    0x1c(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
    2962:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmTxIns->rbId = 0;
    2967:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmTxIns->lcId = 0;       //CCCH
    296b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    296f:	89 50 0c             	mov    %edx,0xc(%eax)
	list->prev = list;
    2972:	89 50 10             	mov    %edx,0x10(%eax)
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
    2975:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		tmTxIns->tmSduBufferSize = 0;
    297c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    2983:	8b 93 30 37 00 00    	mov    0x3730(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2989:	89 8b 30 37 00 00    	mov    %ecx,0x3730(%ebx)
	new->next = next;
    298f:	89 78 1c             	mov    %edi,0x1c(%eax)
	new->prev = prev;
    2992:	89 50 20             	mov    %edx,0x20(%eax)
	prev->next = new;
    2995:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH tran instance has bulided\n");
    2997:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    299e:	e8 fc ff ff ff       	call   299f <rlc_init_enter+0x27f>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    29a3:	83 c4 04             	add    $0x4,%esp
    29a6:	5b                   	pop    %ebx
    29a7:	5e                   	pop    %esi
    29a8:	5f                   	pop    %edi
    29a9:	5d                   	pop    %ebp
    29aa:	c3                   	ret    
    29ab:	90                   	nop
    29ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000029b0 <rlc_pkt_receive_from_upper>:
**--------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
static void rlc_pkt_receive_from_upper(void)
{
    29b0:	55                   	push   %ebp
    29b1:	89 e5                	mov    %esp,%ebp
    29b3:	83 ec 18             	sub    $0x18,%esp
    29b6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    29b9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    29bc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    29bf:	e8 fc ff ff ff       	call   29c0 <rlc_pkt_receive_from_upper+0x10>
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	
    29c4:	e8 fc ff ff ff       	call   29c5 <rlc_pkt_receive_from_upper+0x15>
    29c9:	89 c7                	mov    %eax,%edi

	skb = (FSM_PKT *)fsm_pkt_get();
    29cb:	e8 fc ff ff ff       	call   29cc <rlc_pkt_receive_from_upper+0x1c>
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
    29d0:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	

	skb = (FSM_PKT *)fsm_pkt_get();
    29d6:	89 c6                	mov    %eax,%esi
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
	fsm_printf("[RLC][rlc_pkt_receive_from_upper][-->] receive from upper, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
    29d8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    29dc:	89 44 24 08          	mov    %eax,0x8(%esp)
    29e0:	0f b6 03             	movzbl (%ebx),%eax
    29e3:	c7 04 24 d4 06 00 00 	movl   $0x6d4,(%esp)
    29ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    29ee:	e8 fc ff ff ff       	call   29ef <rlc_pkt_receive_from_upper+0x3f>
	fsm_octets_print(skb->data,64);
    29f3:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    29f9:	ba 40 00 00 00       	mov    $0x40,%edx
    29fe:	e8 fc ff ff ff       	call   29ff <rlc_pkt_receive_from_upper+0x4f>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    2a03:	80 3b 00             	cmpb   $0x0,(%ebx)
    2a06:	75 0d                	jne    2a15 <rlc_pkt_receive_from_upper+0x65>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    2a08:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2a0b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2a0e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2a11:	89 ec                	mov    %ebp,%esp
    2a13:	5d                   	pop    %ebp
    2a14:	c3                   	ret    
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    2a15:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
    2a1c:	c7 04 24 24 07 00 00 	movl   $0x724,(%esp)
    2a23:	e8 fc ff ff ff       	call   2a24 <rlc_pkt_receive_from_upper+0x74>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    2a28:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    2a2e:	c7 04 24 74 07 00 00 	movl   $0x774,(%esp)
    2a35:	89 44 24 04          	mov    %eax,0x4(%esp)
    2a39:	e8 fc ff ff ff       	call   2a3a <rlc_pkt_receive_from_upper+0x8a>
		fsm_pkt_destroy(skb);
    2a3e:	89 f0                	mov    %esi,%eax
    2a40:	e8 fc ff ff ff       	call   2a41 <rlc_pkt_receive_from_upper+0x91>
		skb = NULL;
		FOUT;
    2a45:	eb c1                	jmp    2a08 <rlc_pkt_receive_from_upper+0x58>
    2a47:	89 f6                	mov    %esi,%esi
    2a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00002a50 <ue_mac_sv_close>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_close()
{
    2a50:	55                   	push   %ebp
    2a51:	89 e5                	mov    %esp,%ebp
    2a53:	53                   	push   %ebx
    2a54:	e8 fc ff ff ff       	call   2a55 <ue_mac_sv_close+0x5>
	FIN(ue_mac_sv_close());
	SV_PTR_GET(rlc_mac_sv);
    2a59:	e8 fc ff ff ff       	call   2a5a <ue_mac_sv_close+0xa>
    2a5e:	89 c3                	mov    %eax,%ebx
	if(SV(m_temp_cr) != NULL)
    2a60:	8b 80 a0 01 00 00    	mov    0x1a0(%eax),%eax
    2a66:	85 c0                	test   %eax,%eax
    2a68:	74 0f                	je     2a79 <ue_mac_sv_close+0x29>
	{
		fsm_mem_free(SV(m_temp_cr));
    2a6a:	e8 fc ff ff ff       	call   2a6b <ue_mac_sv_close+0x1b>
		SV(m_temp_cr) = NULL;
    2a6f:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    2a76:	00 00 00 
	}
	Free_Uemac_Scheduler_Resource();
    2a79:	e8 fc ff ff ff       	call   2a7a <ue_mac_sv_close+0x2a>
	if(SV(msg3_buf_ptr)!=NULL)
    2a7e:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    2a84:	85 c0                	test   %eax,%eax
    2a86:	74 0f                	je     2a97 <ue_mac_sv_close+0x47>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));
    2a88:	e8 fc ff ff ff       	call   2a89 <ue_mac_sv_close+0x39>
		SV(msg3_buf_ptr)=NULL;
    2a8d:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    2a94:	00 00 00 
	}
	FOUT;
}
    2a97:	5b                   	pop    %ebx
    2a98:	5d                   	pop    %ebp
    2a99:	c3                   	ret    
    2a9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00002aa0 <SendRaPreamble>:
->output:
->Special:
*******************************
*/
static void SendRaPreamble(RACH_ConfigDedicated *randomaccess_info)
{
    2aa0:	55                   	push   %ebp
    2aa1:	89 e5                	mov    %esp,%ebp
    2aa3:	53                   	push   %ebx
    2aa4:	83 ec 04             	sub    $0x4,%esp
    2aa7:	e8 fc ff ff ff       	call   2aa8 <SendRaPreamble+0x8>
    2aac:	89 c3                	mov    %eax,%ebx
	FIN(SendRaPreamble());
	//modified by HQ
	fsm_printf("[UEMAC][sendrapreamble]run here,start send RAP \n");//testing code
    2aae:	c7 04 24 c0 07 00 00 	movl   $0x7c0,(%esp)
    2ab5:	e8 fc ff ff ff       	call   2ab6 <SendRaPreamble+0x16>
	//fsm_octets_print(randomaccess_info,sizeof(RACH_ConfigDedicated));// for test
	fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_Preamble_Indicate, (void*)randomaccess_info , sizeof(randomaccess_info));
    2aba:	89 d9                	mov    %ebx,%ecx
    2abc:	ba 25 00 00 00       	mov    $0x25,%edx
    2ac1:	b8 03 00 00 00       	mov    $0x3,%eax
    2ac6:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    2acd:	e8 fc ff ff ff       	call   2ace <SendRaPreamble+0x2e>
	//send the information of random access to PHYadapter
	fsm_mem_free(randomaccess_info);//20140722 modified by lhl IOCTL
    2ad2:	89 d8                	mov    %ebx,%eax
    2ad4:	e8 fc ff ff ff       	call   2ad5 <SendRaPreamble+0x35>
	FOUT;
 }
    2ad9:	83 c4 04             	add    $0x4,%esp
    2adc:	5b                   	pop    %ebx
    2add:	5d                   	pop    %ebp
    2ade:	c3                   	ret    
    2adf:	90                   	nop

00002ae0 <ioctrl_handler>:
->output:
->Special:
*******************************
*/
static void ioctrl_handler()
{
    2ae0:	55                   	push   %ebp
    2ae1:	89 e5                	mov    %esp,%ebp
    2ae3:	83 ec 18             	sub    $0x18,%esp
    2ae6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    2ae9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    2aec:	89 7d fc             	mov    %edi,-0x4(%ebp)
    2aef:	e8 fc ff ff ff       	call   2af0 <ioctrl_handler+0x10>
	UEPHY_TO_MAC_ULgrant *tempulgrant;
	u32 rar_failed_times;//201501
	u32 contention_failed_times;//201501
	FIN(ioctrl_handler());

	SV_PTR_GET(rlc_mac_sv);
    2af4:	e8 fc ff ff ff       	call   2af5 <ioctrl_handler+0x15>
    2af9:	89 c6                	mov    %eax,%esi

	int cmd_value=fsm_ev_ioctrl_cmd();
    2afb:	e8 fc ff ff ff       	call   2afc <ioctrl_handler+0x1c>

	switch(cmd_value)
    2b00:	3d 87 00 00 00       	cmp    $0x87,%eax
    2b05:	76 21                	jbe    2b28 <ioctrl_handler+0x48>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
			
			
			break;
		default:
			fsm_printf("[RLC_MAC] unidentified ioctrl command!\n");
    2b07:	c7 04 24 b4 0b 00 00 	movl   $0xbb4,(%esp)
    2b0e:	e8 fc ff ff ff       	call   2b0f <ioctrl_handler+0x2f>
    2b13:	90                   	nop
    2b14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		
/**/
	}	
	FOUT;
}
    2b18:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2b1b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2b1e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2b21:	89 ec                	mov    %ebp,%esp
    2b23:	5d                   	pop    %ebp
    2b24:	c3                   	ret    
    2b25:	8d 76 00             	lea    0x0(%esi),%esi

	SV_PTR_GET(rlc_mac_sv);

	int cmd_value=fsm_ev_ioctrl_cmd();

	switch(cmd_value)
    2b28:	ff 24 85 e0 00 00 00 	jmp    *0xe0(,%eax,4)
    2b2f:	90                   	nop
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
		break;
		case TEST_RECV_SYS :  
			fsm_printf("[MAC][RECVSYS]\n");
    2b30:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
    2b37:	e8 fc ff ff ff       	call   2b38 <ioctrl_handler+0x58>
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
    2b3c:	31 c9                	xor    %ecx,%ecx
    2b3e:	ba 26 00 00 00       	mov    $0x26,%edx
    2b43:	b8 03 00 00 00       	mov    $0x3,%eax
    2b48:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2b4f:	e8 fc ff ff ff       	call   2b50 <ioctrl_handler+0x70>
		//ioctrlRNTI
		break;
    2b54:	eb c2                	jmp    2b18 <ioctrl_handler+0x38>
    2b56:	66 90                	xchg   %ax,%ax
			test_print_pkt_num();
		break;

		/***************** RLC ioctl_handler ******************/
		case CRLC_CONFIG_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
    2b58:	c7 04 24 8c 0a 00 00 	movl   $0xa8c,(%esp)
    2b5f:	e8 fc ff ff ff       	call   2b60 <ioctrl_handler+0x80>
			PCRLC_CONFIG_REQ();
    2b64:	e8 fc ff ff ff       	call   2b65 <ioctrl_handler+0x85>
			FOUT;
    2b69:	eb ad                	jmp    2b18 <ioctrl_handler+0x38>
    2b6b:	90                   	nop
    2b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
		//ioctrlRNTI
		break;
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
    2b70:	c7 04 24 d4 00 00 00 	movl   $0xd4,(%esp)
    2b77:	e8 fc ff ff ff       	call   2b78 <ioctrl_handler+0x98>
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
    2b7c:	31 c9                	xor    %ecx,%ecx
    2b7e:	ba 46 00 00 00       	mov    $0x46,%edx
    2b83:	b8 03 00 00 00       	mov    $0x3,%eax
    2b88:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2b8f:	e8 fc ff ff ff       	call   2b90 <ioctrl_handler+0xb0>
		break;
    2b94:	eb 82                	jmp    2b18 <ioctrl_handler+0x38>
    2b96:	66 90                	xchg   %ax,%ax
			SV(RetxBSRTimer.time_value)	= SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer);
			SV(RetxBSRTimer.timer_sign) = fsm_schedule_self(SV(RetxBSRTimer.time_value), RexBSRTimer_Expire);
			SV(RetxBSRTimer.flag)= true;*/ 	//noted in 20151228
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
    2b98:	ba 0b 00 00 00       	mov    $0xb,%edx
    2b9d:	b8 64 00 00 00       	mov    $0x64,%eax
    2ba2:	e8 fc ff ff ff       	call   2ba3 <ioctrl_handler+0xc3>
		break;
    2ba7:	e9 6c ff ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
*/
static void handle_HARQ_feedback()
{
	void *tmpdata_ptr;	
	FIN(handle_HARQ_feedback());
	SV_PTR_GET(rlc_mac_sv);
    2bb0:	e8 fc ff ff ff       	call   2bb1 <ioctrl_handler+0xd1>
    2bb5:	89 c6                	mov    %eax,%esi
	HARQ_statu_parameters ACK_statu={0,true,0};
	tmpdata_ptr = fsm_data_get();
    2bb7:	e8 fc ff ff ff       	call   2bb8 <ioctrl_handler+0xd8>
	if( ((struct HARQ_feedback*)tmpdata_ptr)->HARQ_FEEDBACK == true )
    2bbc:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
    2bc0:	74 31                	je     2bf3 <ioctrl_handler+0x113>
	{
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].avaiable_flag = true;
    2bc2:	8b 10                	mov    (%eax),%edx
    2bc4:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bc7:	c6 44 96 38 01       	movb   $0x1,0x38(%esi,%edx,4)
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].HARQ_buffer_pointer = NULL;
    2bcc:	8b 10                	mov    (%eax),%edx
    2bce:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bd1:	c7 44 96 44 00 00 00 	movl   $0x0,0x44(%esi,%edx,4)
    2bd8:	00 
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].statu=ACK_statu;
    2bd9:	8b 10                	mov    (%eax),%edx
    2bdb:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2bde:	8d 4c 96 30          	lea    0x30(%esi,%edx,4),%ecx
    2be2:	66 c7 41 0c 00 00    	movw   $0x0,0xc(%ecx)
    2be8:	c6 41 0e 01          	movb   $0x1,0xe(%ecx)
    2bec:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
    2bf3:	e8 fc ff ff ff       	call   2bf4 <ioctrl_handler+0x114>
		break;
    2bf8:	e9 1b ff ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2bfd:	8d 76 00             	lea    0x0(%esi),%esi
*/
static void ue_mac_lc_release()
{
	void *tmpdata_ptr;
	FIN(ue_mac_lc_release());
	tmpdata_ptr = fsm_data_get();
    2c00:	e8 fc ff ff ff       	call   2c01 <ioctrl_handler+0x121>
    2c05:	89 c6                	mov    %eax,%esi
	Delete_LogicalChannel_ConfigInfo(*((unsigned char *)tmpdata_ptr));
    2c07:	0f b6 00             	movzbl (%eax),%eax
    2c0a:	e8 fc ff ff ff       	call   2c0b <ioctrl_handler+0x12b>
	fsm_data_destroy(tmpdata_ptr);
    2c0f:	89 f0                	mov    %esi,%eax
    2c11:	e8 fc ff ff ff       	call   2c12 <ioctrl_handler+0x132>
    2c16:	e9 fd fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c1b:	90                   	nop
    2c1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
			ue_mac_rach_config();
		break;
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
    2c20:	c7 04 24 ac 08 00 00 	movl   $0x8ac,(%esp)
    2c27:	e8 fc ff ff ff       	call   2c28 <ioctrl_handler+0x148>
*/
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    2c2c:	b8 15 00 00 00       	mov    $0x15,%eax
    2c31:	e8 fc ff ff ff       	call   2c32 <ioctrl_handler+0x152>
    2c36:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2c38:	e8 fc ff ff ff       	call   2c39 <ioctrl_handler+0x159>
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2c3d:	b9 15 00 00 00       	mov    $0x15,%ecx
    2c42:	89 c2                	mov    %eax,%edx
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	tmpdata_ptr = fsm_data_get();	
    2c44:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2c46:	89 f0                	mov    %esi,%eax
    2c48:	e8 fc ff ff ff       	call   2c49 <ioctrl_handler+0x169>
	fsm_data_destroy(tmpdata_ptr);//
    2c4d:	89 f8                	mov    %edi,%eax
    2c4f:	e8 fc ff ff ff       	call   2c50 <ioctrl_handler+0x170>
	Init_LogicalChannel_ConfigInfo(lc_configinfo);//lc_configinfo 20140506
    2c54:	89 f0                	mov    %esi,%eax
    2c56:	e8 fc ff ff ff       	call   2c57 <ioctrl_handler+0x177>
	//fsm_printf("[UEMAC][logch_config]LCID:%d, ",lc_configinfo->logicalChannelIdentity);
	//fsm_printf("[UEMAC][logch_config]RRC TO MAC:LCGROUP:%d\n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup);
	//fsm_printf("[UEMAC][logch_config]prioritisedBitRate: %d \n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate);
	fsm_mem_free(lc_configinfo);	
    2c5b:	89 f0                	mov    %esi,%eax
    2c5d:	e8 fc ff ff ff       	call   2c5e <ioctrl_handler+0x17e>
    2c62:	e9 b1 fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c67:	90                   	nop
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
			ue_mac_PCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_SPS  : 
			fsm_printf("[UEMAC][RRCTOMAC_spsconfig]rrctomac_spsconfig\n");
    2c68:	c7 04 24 44 09 00 00 	movl   $0x944,(%esp)
    2c6f:	e8 fc ff ff ff       	call   2c70 <ioctrl_handler+0x190>
*/
static void ue_mac_SPS_Config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_SPS_Config());
	SV_PTR_GET(rlc_mac_sv);
    2c74:	e8 fc ff ff ff       	call   2c75 <ioctrl_handler+0x195>
    2c79:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();
    2c7b:	e8 fc ff ff ff       	call   2c7c <ioctrl_handler+0x19c>
	SV(systemconfigInfo.SPSConfigInfo)= *((struct SPS_Config*)tmpdata_ptr); //ioctrl //
    2c80:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    2c86:	b9 11 00 00 00       	mov    $0x11,%ecx
    2c8b:	89 c6                	mov    %eax,%esi
    2c8d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2c8f:	e8 fc ff ff ff       	call   2c90 <ioctrl_handler+0x1b0>
    2c94:	e9 7f fe ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2c99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		break;
		case IOCCMD_PDCCHtoMAC_ULGRANT : //PHYPDCCHUL_grantDCI,MAC
		//MACul_grant 
		//MSG4
			
			tempdata_ptr = fsm_data_get();
    2ca0:	e8 fc ff ff ff       	call   2ca1 <ioctrl_handler+0x1c1>
    2ca5:	89 c7                	mov    %eax,%edi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
    2ca7:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    2cab:	66 89 46 0a          	mov    %ax,0xa(%esi)
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
    2caf:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    2cb3:	66 89 46 0c          	mov    %ax,0xc(%esi)
			if(tempulgrant->m_rnti == SV(C_RNTI))
    2cb7:	0f b7 06             	movzwl (%esi),%eax
    2cba:	66 39 07             	cmp    %ax,(%edi)
    2cbd:	0f 84 ed 03 00 00    	je     30b0 <ioctrl_handler+0x5d0>
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
    2cc3:	66 85 c0             	test   %ax,%ax
    2cc6:	74 28                	je     2cf0 <ioctrl_handler+0x210>
    2cc8:	8b 86 ec 01 00 00    	mov    0x1ec(%esi),%eax
    2cce:	85 c0                	test   %eax,%eax
    2cd0:	74 1e                	je     2cf0 <ioctrl_handler+0x210>
    2cd2:	8b 86 f0 01 00 00    	mov    0x1f0(%esi),%eax
    2cd8:	85 c0                	test   %eax,%eax
    2cda:	0f 84 df 03 00 00    	je     30bf <ioctrl_handler+0x5df>
    2ce0:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    2ce7:	0f 84 fc 03 00 00    	je     30e9 <ioctrl_handler+0x609>
    2ced:	8d 76 00             	lea    0x0(%esi),%esi
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2cf0:	8b 47 06             	mov    0x6(%edi),%eax
    2cf3:	e8 fc ff ff ff       	call   2cf4 <ioctrl_handler+0x214>
			//fsm_printf("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d\n",SV(UL_resource_info.m_tbsize));
			//printk("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d, ul_sched_count:%d\n",SV(UL_resource_info.m_tbsize),++ul_sched_count);
			//SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(*((int *)tempdata_ptr)); //UL_grant 
			// ul_grant retxBSR-Timer 36321-80c 5.4.5
			SV(UL_resource_info.resource_flag) = true;
    2cf8:	c6 46 28 01          	movb   $0x1,0x28(%esi)

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    2cfc:	89 c2                	mov    %eax,%edx
    2cfe:	c1 ea 03             	shr    $0x3,%edx
    2d01:	89 96 f4 01 00 00    	mov    %edx,0x1f4(%esi)
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2d07:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2d0d:	89 46 2c             	mov    %eax,0x2c(%esi)
			SV(UL_resource_info.resource_flag) = true;

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2d10:	8d 4a 05             	lea    0x5(%edx),%ecx
    2d13:	39 4a 05             	cmp    %ecx,0x5(%edx)
    2d16:	74 0a                	je     2d22 <ioctrl_handler+0x242>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    2d18:	e8 fc ff ff ff       	call   2d19 <ioctrl_handler+0x239>
    2d1d:	e8 fc ff ff ff       	call   2d1e <ioctrl_handler+0x23e>
				SV(UL_resource_info.resource_flag)=false;
    2d22:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    2d26:	e9 ed fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2d2b:	90                   	nop
    2d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
			TATimer_config();//RRCTA 
		break;
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
    2d30:	c7 04 24 44 08 00 00 	movl   $0x844,(%esp)
    2d37:	e8 fc ff ff ff       	call   2d38 <ioctrl_handler+0x258>
*/
static void ue_mac_main_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_main_config());
	SV_PTR_GET(rlc_mac_sv);
    2d3c:	e8 fc ff ff ff       	call   2d3d <ioctrl_handler+0x25d>
    2d41:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();	
    2d43:	e8 fc ff ff ff       	call   2d44 <ioctrl_handler+0x264>
	SV(systemconfigInfo.MACMainConfigInfo) = *((struct MAC_MainConfig*)tmpdata_ptr); //ioctrl
    2d48:	83 c7 5c             	add    $0x5c,%edi
    2d4b:	b9 14 00 00 00       	mov    $0x14,%ecx
    2d50:	89 c6                	mov    %eax,%esi
    2d52:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2d54:	e8 fc ff ff ff       	call   2d55 <ioctrl_handler+0x275>
    2d59:	e9 ba fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2d5e:	66 90                	xchg   %ax,%ax
}

static void test_print_pkt_num()
{
	FIN(test_print_pkt_num());
	SV_PTR_GET(rlc_mac_sv);
    2d60:	e8 fc ff ff ff       	call   2d61 <ioctrl_handler+0x281>
    2d65:	89 c6                	mov    %eax,%esi
	printk("[UEMAC]uplink lost pkt num:%d\n",SV(lost_pkt_num_uplink));
    2d67:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
    2d6d:	c7 04 24 04 0a 00 00 	movl   $0xa04,(%esp)
    2d74:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d78:	e8 fc ff ff ff       	call   2d79 <ioctrl_handler+0x299>
	printk("[UEMAC]uplink total pkt num:%d\n",SV(pkt_num_uplink));
    2d7d:	8b 86 08 02 00 00    	mov    0x208(%esi),%eax
    2d83:	c7 04 24 24 0a 00 00 	movl   $0xa24,(%esp)
    2d8a:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d8e:	e8 fc ff ff ff       	call   2d8f <ioctrl_handler+0x2af>
	printk("[UEMAC]downlink lost pkt num:%d\n",SV(lost_pkt_num_downlink));
    2d93:	8b 86 0c 02 00 00    	mov    0x20c(%esi),%eax
    2d99:	c7 04 24 44 0a 00 00 	movl   $0xa44,(%esp)
    2da0:	89 44 24 04          	mov    %eax,0x4(%esp)
    2da4:	e8 fc ff ff ff       	call   2da5 <ioctrl_handler+0x2c5>
	printk("[UEMAC]downlink total pkt num:%d\n",SV(pkt_num_downlink));
    2da9:	8b 86 10 02 00 00    	mov    0x210(%esi),%eax
    2daf:	c7 04 24 68 0a 00 00 	movl   $0xa68,(%esp)
    2db6:	89 44 24 04          	mov    %eax,0x4(%esp)
    2dba:	e8 fc ff ff ff       	call   2dbb <ioctrl_handler+0x2db>
    2dbf:	e9 54 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
		break;
		case _IOCTLtoUEMAC_Contention_Failed:
			tempdata_ptr = fsm_data_get();
    2dc8:	e8 fc ff ff ff       	call   2dc9 <ioctrl_handler+0x2e9>
			contention_failed_times=*((u32 *)tempdata_ptr);
    2dcd:	8b 10                	mov    (%eax),%edx
			SV(contention_failed_num)=contention_failed_times;
    2dcf:	89 96 00 02 00 00    	mov    %edx,0x200(%esi)
			fsm_data_destroy(tempdata_ptr);
    2dd5:	e8 fc ff ff ff       	call   2dd6 <ioctrl_handler+0x2f6>
		break;
    2dda:	e9 39 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2ddf:	90                   	nop
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
    2de0:	e8 fc ff ff ff       	call   2de1 <ioctrl_handler+0x301>
			rar_failed_times=*((u32 *)tempdata_ptr);
    2de5:	8b 10                	mov    (%eax),%edx
			SV(rar_failed_num)=rar_failed_times;
    2de7:	89 96 fc 01 00 00    	mov    %edx,0x1fc(%esi)
    2ded:	e9 01 fe ff ff       	jmp    2bf3 <ioctrl_handler+0x113>
    2df2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
			PCRLC_RESUME_REQ();
			FOUT;
			break;
		case  PRLC_DISC_REQ:
			PPRLC_DISC_REQ();
    2df8:	e8 fc ff ff ff       	call   2df9 <ioctrl_handler+0x319>
			FOUT;
    2dfd:	e9 16 fd ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
			PCRLC_CONFIG_REQ();
			FOUT;
			break;
		case CRLC_BULID_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
    2e08:	c7 04 24 c8 0a 00 00 	movl   $0xac8,(%esp)
    2e0f:	e8 fc ff ff ff       	call   2e10 <ioctrl_handler+0x330>
			PCRLC_BULID_REQ();
    2e14:	e8 fc ff ff ff       	call   2e15 <ioctrl_handler+0x335>
			FOUT;
    2e19:	e9 fa fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e1e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
			PCRLC_SUSPEND_REQ();
			FOUT;
			break;
		case CRLC_RESUME_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
    2e20:	c7 04 24 78 0b 00 00 	movl   $0xb78,(%esp)
    2e27:	e8 fc ff ff ff       	call   2e28 <ioctrl_handler+0x348>
			PCRLC_RESUME_REQ();
    2e2c:	e8 fc ff ff ff       	call   2e2d <ioctrl_handler+0x34d>
			FOUT;
    2e31:	e9 e2 fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e36:	66 90                	xchg   %ax,%ax
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
			PCRLC_DEACT_REQ();
			FOUT;
			break;
		case CRLC_SUSPEND_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
    2e38:	c7 04 24 3c 0b 00 00 	movl   $0xb3c,(%esp)
    2e3f:	e8 fc ff ff ff       	call   2e40 <ioctrl_handler+0x360>
			PCRLC_SUSPEND_REQ();
    2e44:	e8 fc ff ff ff       	call   2e45 <ioctrl_handler+0x365>
			FOUT;
    2e49:	e9 ca fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e4e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
			PCRLC_BULID_REQ();
			FOUT;
			break;
		case CRLC_DEACT_REQ:
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
    2e50:	c7 04 24 00 0b 00 00 	movl   $0xb00,(%esp)
    2e57:	e8 fc ff ff ff       	call   2e58 <ioctrl_handler+0x378>
			PCRLC_DEACT_REQ();
    2e5c:	e8 fc ff ff ff       	call   2e5d <ioctrl_handler+0x37d>
			FOUT;
    2e61:	e9 b2 fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2e66:	66 90                	xchg   %ax,%ax
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
			ue_mac_main_config(); 
		break;
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
    2e68:	c7 04 24 78 08 00 00 	movl   $0x878,(%esp)
    2e6f:	e8 fc ff ff ff       	call   2e70 <ioctrl_handler+0x390>
*/
static void ue_mac_rach_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_rach_config());
	SV_PTR_GET(rlc_mac_sv);
    2e74:	e8 fc ff ff ff       	call   2e75 <ioctrl_handler+0x395>
    2e79:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();
    2e7b:	e8 fc ff ff ff       	call   2e7c <ioctrl_handler+0x39c>
	//ioctrl
	SV(systemconfigInfo.RACHCommonConfigInfo) = *((struct RachConfigCommon*)tmpdata_ptr); 
    2e80:	8b 10                	mov    (%eax),%edx
    2e82:	89 96 ac 00 00 00    	mov    %edx,0xac(%esi)
    2e88:	8b 50 04             	mov    0x4(%eax),%edx
    2e8b:	89 96 b0 00 00 00    	mov    %edx,0xb0(%esi)
    2e91:	8b 50 08             	mov    0x8(%eax),%edx
    2e94:	89 96 b4 00 00 00    	mov    %edx,0xb4(%esi)
    2e9a:	8b 50 0c             	mov    0xc(%eax),%edx
    2e9d:	89 96 b8 00 00 00    	mov    %edx,0xb8(%esi)
    2ea3:	8b 50 10             	mov    0x10(%eax),%edx
    2ea6:	89 96 bc 00 00 00    	mov    %edx,0xbc(%esi)
    2eac:	8b 50 14             	mov    0x14(%eax),%edx
    2eaf:	89 96 c0 00 00 00    	mov    %edx,0xc0(%esi)
    2eb5:	8b 50 18             	mov    0x18(%eax),%edx
    2eb8:	89 96 c4 00 00 00    	mov    %edx,0xc4(%esi)
    2ebe:	8b 50 1c             	mov    0x1c(%eax),%edx
    2ec1:	89 96 c8 00 00 00    	mov    %edx,0xc8(%esi)
    2ec7:	8b 50 20             	mov    0x20(%eax),%edx
    2eca:	89 96 cc 00 00 00    	mov    %edx,0xcc(%esi)
    2ed0:	8b 50 24             	mov    0x24(%eax),%edx
    2ed3:	89 96 d0 00 00 00    	mov    %edx,0xd0(%esi)
    2ed9:	8b 50 28             	mov    0x28(%eax),%edx
    2edc:	89 96 d4 00 00 00    	mov    %edx,0xd4(%esi)
	//fsm_mem_cpy(&(SV(systemconfigInfo.RACHCommonConfigInfo)), tmpdata_ptr, sizeof(struct RachConfigCommon));
	//fsm_printf("[UEMAC][rach_config]maxHARQ_Msg3Tx :%d ",	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx) );//testing code
	//fsm_printf("[UEMAC][rach_config]mac_ContentionResolutionTimer : %d \n",SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer));
	fsm_data_destroy(tmpdata_ptr);//
    2ee2:	e8 fc ff ff ff       	call   2ee3 <ioctrl_handler+0x403>
    2ee7:	e9 2c fc ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2eec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
			//ioctrl
		break ;
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
    2ef0:	c7 04 24 f4 07 00 00 	movl   $0x7f4,(%esp)
    2ef7:	e8 fc ff ff ff       	call   2ef8 <ioctrl_handler+0x418>
*/
static void TATimer_config() 
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
    2efc:	e8 fc ff ff ff       	call   2efd <ioctrl_handler+0x41d>
    2f01:	89 c6                	mov    %eax,%esi
	int time;
	tmpdata_ptr = fsm_data_get();
    2f03:	e8 fc ff ff ff       	call   2f04 <ioctrl_handler+0x424>
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2f08:	b9 04 00 00 00       	mov    $0x4,%ecx
    2f0d:	89 c2                	mov    %eax,%edx
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
    2f0f:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2f11:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2f14:	e8 fc ff ff ff       	call   2f15 <ioctrl_handler+0x435>
	SV(TA_Periodic_time)=time;//LHL 20141021
    2f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2f1c:	80 be 68 01 00 00 00 	cmpb   $0x0,0x168(%esi)
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
	SV(TA_Periodic_time)=time;//LHL 20141021
    2f23:	89 46 24             	mov    %eax,0x24(%esi)
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2f26:	74 3a                	je     2f62 <ioctrl_handler+0x482>
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
    2f28:	c7 04 24 1c 08 00 00 	movl   $0x81c,(%esp)
    2f2f:	e8 fc ff ff ff       	call   2f30 <ioctrl_handler+0x450>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    2f34:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
    2f3a:	e8 fc ff ff ff       	call   2f3b <ioctrl_handler+0x45b>
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2f3f:	8b 46 24             	mov    0x24(%esi),%eax
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2f42:	ba 0b 00 00 00       	mov    $0xb,%edx
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
		SV(TATimer.flag)=true;
    2f47:	c6 86 68 01 00 00 01 	movb   $0x1,0x168(%esi)
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2f4e:	89 86 60 01 00 00    	mov    %eax,0x160(%esi)
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2f54:	6b c0 64             	imul   $0x64,%eax,%eax
    2f57:	e8 fc ff ff ff       	call   2f58 <ioctrl_handler+0x478>
    2f5c:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
		//SV(TA_timer_flag)=0;
	}//  
	fsm_data_destroy(tmpdata_ptr);
    2f62:	89 f8                	mov    %edi,%eax
    2f64:	e8 fc ff ff ff       	call   2f65 <ioctrl_handler+0x485>
    2f69:	e9 aa fb ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2f6e:	66 90                	xchg   %ax,%ax
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
			//ioctrlRNTI
		break;
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
    2f70:	31 c9                	xor    %ecx,%ecx
    2f72:	ba 27 00 00 00       	mov    $0x27,%edx
    2f77:	b8 03 00 00 00       	mov    $0x3,%eax
    2f7c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2f83:	e8 fc ff ff ff       	call   2f84 <ioctrl_handler+0x4a4>
			//ioctrl
		break ;
    2f88:	e9 8b fb ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    2f8d:	8d 76 00             	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] MRLC_TRANSOP_IND  has received\n");
			PMRLC_TRANSOP_IND();
			FOUT;
			break;*/ //noted in 20150804
		case PRINTRLC:
			printk("\ncountRecvFromUpper =%d\n",SV(countRecvFromUpper));
    2f90:	8b 86 8c 5a 00 00    	mov    0x5a8c(%esi),%eax
    2f96:	c7 04 24 e4 00 00 00 	movl   $0xe4,(%esp)
    2f9d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fa1:	e8 fc ff ff ff       	call   2fa2 <ioctrl_handler+0x4c2>
			printk("countSentToLower =%d\n",SV(countSentToLower));
    2fa6:	8b 86 98 5a 00 00    	mov    0x5a98(%esi),%eax
    2fac:	c7 04 24 fd 00 00 00 	movl   $0xfd,(%esp)
    2fb3:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fb7:	e8 fc ff ff ff       	call   2fb8 <ioctrl_handler+0x4d8>
			printk("countSendToUpper =%d\n",SV(countSendToUpper));
    2fbc:	8b 86 90 5a 00 00    	mov    0x5a90(%esi),%eax
    2fc2:	c7 04 24 13 01 00 00 	movl   $0x113,(%esp)
    2fc9:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fcd:	e8 fc ff ff ff       	call   2fce <ioctrl_handler+0x4ee>
			printk("countRecvFromLower =%d\n",SV(countRecvFromLower));
    2fd2:	8b 86 94 5a 00 00    	mov    0x5a94(%esi),%eax
    2fd8:	c7 04 24 29 01 00 00 	movl   $0x129,(%esp)
    2fdf:	89 44 24 04          	mov    %eax,0x4(%esp)
    2fe3:	e8 fc ff ff ff       	call   2fe4 <ioctrl_handler+0x504>
			printk("countSendCtrlPdu =%d\n",SV(countSendCtrlPdu));
    2fe8:	8b 86 a0 5a 00 00    	mov    0x5aa0(%esi),%eax
    2fee:	c7 04 24 41 01 00 00 	movl   $0x141,(%esp)
    2ff5:	89 44 24 04          	mov    %eax,0x4(%esp)
    2ff9:	e8 fc ff ff ff       	call   2ffa <ioctrl_handler+0x51a>
			printk("countRecvCtrlPdu =%d\n",SV(countRecvCtrlPdu));
    2ffe:	8b 86 a4 5a 00 00    	mov    0x5aa4(%esi),%eax
    3004:	c7 04 24 57 01 00 00 	movl   $0x157,(%esp)
    300b:	89 44 24 04          	mov    %eax,0x4(%esp)
    300f:	e8 fc ff ff ff       	call   3010 <ioctrl_handler+0x530>
			printk("countDropPacket =%d\n\n",SV(countDropPacket));
    3014:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    301a:	c7 04 24 6d 01 00 00 	movl   $0x16d,(%esp)
    3021:	89 44 24 04          	mov    %eax,0x4(%esp)
    3025:	e8 fc ff ff ff       	call   3026 <ioctrl_handler+0x546>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
    302a:	8b 86 a8 5a 00 00    	mov    0x5aa8(%esi),%eax
    3030:	c7 04 24 83 01 00 00 	movl   $0x183,(%esp)
    3037:	89 44 24 04          	mov    %eax,0x4(%esp)
    303b:	e8 fc ff ff ff       	call   303c <ioctrl_handler+0x55c>
			
			
			break;
    3040:	e9 d3 fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    3045:	8d 76 00             	lea    0x0(%esi),%esi
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
			ue_mac_BCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
    3048:	c7 04 24 10 09 00 00 	movl   $0x910,(%esp)
    304f:	e8 fc ff ff ff       	call   3050 <ioctrl_handler+0x570>
*/
static void ue_mac_PCCH_config()
{
	void *tmpdata_ptr;	
	FIN( ue_mac_PCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    3054:	e8 fc ff ff ff       	call   3055 <ioctrl_handler+0x575>
    3059:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();		
    305b:	e8 fc ff ff ff       	call   305c <ioctrl_handler+0x57c>
	SV(systemconfigInfo.PCCHConfigInfo) = *((struct PCCH_Config*)tmpdata_ptr);  //ioctrl
    3060:	8b 08                	mov    (%eax),%ecx
    3062:	8b 58 04             	mov    0x4(%eax),%ebx
    3065:	89 8e d8 00 00 00    	mov    %ecx,0xd8(%esi)
    306b:	89 9e dc 00 00 00    	mov    %ebx,0xdc(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    3071:	e8 fc ff ff ff       	call   3072 <ioctrl_handler+0x592>
    3076:	e9 9d fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    307b:	90                   	nop
    307c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
			ue_mac_logCh_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
    3080:	c7 04 24 dc 08 00 00 	movl   $0x8dc,(%esp)
    3087:	e8 fc ff ff ff       	call   3088 <ioctrl_handler+0x5a8>
*/
static void ue_mac_BCCH_config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_BCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    308c:	e8 fc ff ff ff       	call   308d <ioctrl_handler+0x5ad>
    3091:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    3093:	e8 fc ff ff ff       	call   3094 <ioctrl_handler+0x5b4>
	SV(systemconfigInfo.BCCHConfigInfo)= *((struct BCCH_Config*)tmpdata_ptr);  //ioctrl 
    3098:	8b 10                	mov    (%eax),%edx
    309a:	89 96 e0 00 00 00    	mov    %edx,0xe0(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    30a0:	e8 fc ff ff ff       	call   30a1 <ioctrl_handler+0x5c1>
    30a5:	e9 6e fa ff ff       	jmp    2b18 <ioctrl_handler+0x38>
    30aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
    30b0:	c7 86 f0 01 00 00 01 	movl   $0x1,0x1f0(%esi)
    30b7:	00 00 00 
    30ba:	e9 04 fc ff ff       	jmp    2cc3 <ioctrl_handler+0x1e3>
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
				fsm_schedule_self(0, Contention_Success );
			}
			else if(SV(C_RNTI) && SV(sendmsg3) && !SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )
    30bf:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    30c6:	0f 85 24 fc ff ff    	jne    2cf0 <ioctrl_handler+0x210>
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
    30cc:	c7 04 24 c0 09 00 00 	movl   $0x9c0,(%esp)
    30d3:	e8 fc ff ff ff       	call   30d4 <ioctrl_handler+0x5f4>
				fsm_schedule_self(0, ContentionResolution_Fail );
    30d8:	ba 05 00 00 00       	mov    $0x5,%edx
    30dd:	31 c0                	xor    %eax,%eax
    30df:	e8 fc ff ff ff       	call   30e0 <ioctrl_handler+0x600>
    30e4:	e9 07 fc ff ff       	jmp    2cf0 <ioctrl_handler+0x210>
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
    30e9:	c7 04 24 74 09 00 00 	movl   $0x974,(%esp)
    30f0:	e8 fc ff ff ff       	call   30f1 <ioctrl_handler+0x611>
				fsm_schedule_self(0, Contention_Success );
    30f5:	ba 06 00 00 00       	mov    $0x6,%edx
    30fa:	31 c0                	xor    %eax,%eax
    30fc:	e8 fc ff ff ff       	call   30fd <ioctrl_handler+0x61d>
    3101:	e9 ea fb ff ff       	jmp    2cf0 <ioctrl_handler+0x210>
    3106:	8d 76 00             	lea    0x0(%esi),%esi
    3109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003110 <doStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
static void doStartContentionBasedRandomAccessProcedure() //modified by HQ  20140419
{
    3110:	55                   	push   %ebp
    3111:	89 e5                	mov    %esp,%ebp
    3113:	83 ec 18             	sub    $0x18,%esp
    3116:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3119:	89 75 f8             	mov    %esi,-0x8(%ebp)
    311c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    311f:	e8 fc ff ff ff       	call   3120 <doStartContentionBasedRandomAccessProcedure+0x10>
	FIN(doStartContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    3124:	e8 fc ff ff ff       	call   3125 <doStartContentionBasedRandomAccessProcedure+0x15>
    3129:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated));
    312b:	b8 02 00 00 00       	mov    $0x2,%eax
    3130:	e8 fc ff ff ff       	call   3131 <doStartContentionBasedRandomAccessProcedure+0x21>
    3135:	89 c6                	mov    %eax,%esi
	int mg3_buffer;
	//print_tran_info("[UEMAC][contention_ra]startCRA IDLE -> CRA");//testing code
	if(SV(PREAMBLE_TRANSMISSION_COUNTER )== 0)   //
    3137:	8b 43 14             	mov    0x14(%ebx),%eax
    313a:	85 c0                	test   %eax,%eax
    313c:	75 10                	jne    314e <doStartContentionBasedRandomAccessProcedure+0x3e>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
    313e:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    3145:	b0 01                	mov    $0x1,%al
    3147:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    314e:	89 44 24 04          	mov    %eax,0x4(%esp)
    3152:	c7 04 24 dc 0b 00 00 	movl   $0xbdc,(%esp)
    3159:	e8 fc ff ff ff       	call   315a <doStartContentionBasedRandomAccessProcedure+0x4a>
*******************************
*/
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
    315e:	e8 fc ff ff ff       	call   315f <doStartContentionBasedRandomAccessProcedure+0x4f>
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    3163:	ba 01 00 00 00       	mov    $0x1,%edx
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
    3168:	0f b6 b8 ac 00 00 00 	movzbl 0xac(%eax),%edi
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    316f:	8d 45 f3             	lea    -0xd(%ebp),%eax
    3172:	e8 fc ff ff ff       	call   3173 <doStartContentionBasedRandomAccessProcedure+0x63>
	raPreambleID = raPreambleID%NumberOfRA_Preambles;
    3177:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    317b:	89 fa                	mov    %edi,%edx
    317d:	f6 f2                	div    %dl
    317f:	0f b6 c4             	movzbl %ah,%eax
    3182:	88 45 f3             	mov    %al,-0xd(%ebp)
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
		SV(backoff_index) = 0;  //UEbackoff0ms    
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
	randomaccess_info->ra_PreambleIndex=RandomlySelectRaPreamble();//rapreamble
    3185:	88 06                	mov    %al,(%esi)
	SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//rapid,RAR //HQ 20140506 
    3187:	88 43 04             	mov    %al,0x4(%ebx)
	
	/*for test*/
	//randomaccess_info->ra_PreambleIndex=2;//for test 20141103
	//SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//for test20141103
	/*for test*/
	fsm_printf("[UEMAC][contention_ra]MAC ra_PreambleIndex:%d\n",SV(RA_info.ra_PreambleIndex));//test code
    318a:	0f b6 c0             	movzbl %al,%eax
    318d:	89 44 24 04          	mov    %eax,0x4(%esp)
    3191:	c7 04 24 04 0c 00 00 	movl   $0xc04,(%esp)
    3198:	e8 fc ff ff ff       	call   3199 <doStartContentionBasedRandomAccessProcedure+0x89>
	/*randomaccess_info->ra_PRACHMaskIndex=0;
	SV(RA_info.ra_PRACHMaskIndex)=randomaccess_info->ra_PRACHMaskIndex;*/
	SendRaPreamble(randomaccess_info);//
    319d:	89 f0                	mov    %esi,%eax
    319f:	e8 fc f8 ff ff       	call   2aa0 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    31a4:	e8 e7 f4 ff ff       	call   2690 <StartWaitingForRaResponse>
	FOUT;
}
    31a9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    31ac:	8b 75 f8             	mov    -0x8(%ebp),%esi
    31af:	8b 7d fc             	mov    -0x4(%ebp),%edi
    31b2:	89 ec                	mov    %ebp,%esp
    31b4:	5d                   	pop    %ebp
    31b5:	c3                   	ret    
    31b6:	8d 76 00             	lea    0x0(%esi),%esi
    31b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000031c0 <reports_handler>:
->output:
->Special:
*******************************
*/
static void reports_handler()
{
    31c0:	55                   	push   %ebp
    31c1:	89 e5                	mov    %esp,%ebp
    31c3:	53                   	push   %ebx
    31c4:	83 ec 04             	sub    $0x4,%esp
    31c7:	e8 fc ff ff ff       	call   31c8 <reports_handler+0x8>
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    31cc:	e8 fc ff ff ff       	call   31cd <reports_handler+0xd>
    31d1:	83 f8 03             	cmp    $0x3,%eax
    31d4:	74 4a                	je     3220 <reports_handler+0x60>
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    31d6:	e8 fc ff ff ff       	call   31d7 <reports_handler+0x17>
    31db:	83 f8 03             	cmp    $0x3,%eax
    31de:	66 90                	xchg   %ax,%ax
    31e0:	74 06                	je     31e8 <reports_handler+0x28>
		handle_RetxBSRTimerExpire();
	//PHR 
FOUT;
}
    31e2:	83 c4 04             	add    $0x4,%esp
    31e5:	5b                   	pop    %ebx
    31e6:	5d                   	pop    %ebp
    31e7:	c3                   	ret    
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    31e8:	e8 fc ff ff ff       	call   31e9 <reports_handler+0x29>
    31ed:	83 f8 0d             	cmp    $0xd,%eax
    31f0:	75 f0                	jne    31e2 <reports_handler+0x22>
->Special:
*******************************
*/
static void handle_RetxBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    31f2:	e8 fc ff ff ff       	call   31f3 <reports_handler+0x33>
    31f7:	89 c3                	mov    %eax,%ebx
	FIN(handle_RetxBSRTimerExpire());
	DoProduceBsr_RetxBSRTimer();
    31f9:	e8 fc ff ff ff       	call   31fa <reports_handler+0x3a>
	SV(RetxBSRTimer.timer_sign) = NULL;
    31fe:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3205:	00 00 00 
	SV(RetxBSRTimer.flag) = false;	
    3208:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	fsm_printf("[UEMAC][handle_retxbsrtimer]handle RetxBSRTimer expire\n");//testing code 
    320f:	c7 04 24 74 0c 00 00 	movl   $0xc74,(%esp)
    3216:	e8 fc ff ff ff       	call   3217 <reports_handler+0x57>
    321b:	eb c5                	jmp    31e2 <reports_handler+0x22>
    321d:	8d 76 00             	lea    0x0(%esi),%esi
*******************************
*/
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    3220:	e8 fc ff ff ff       	call   3221 <reports_handler+0x61>
    3225:	83 f8 0c             	cmp    $0xc,%eax
    3228:	75 ac                	jne    31d6 <reports_handler+0x16>
->Special:
*******************************
*/
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    322a:	e8 fc ff ff ff       	call   322b <reports_handler+0x6b>
    322f:	89 c3                	mov    %eax,%ebx
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
    3231:	e8 fc ff ff ff       	call   3232 <reports_handler+0x72>
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3236:	ba 0c 00 00 00       	mov    $0xc,%edx
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
    323b:	6b 43 64 64          	imul   $0x64,0x64(%ebx),%eax
    323f:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3245:	e8 fc ff ff ff       	call   3246 <reports_handler+0x86>
	SV(PeriodicBSRTimer).flag = true;
    324a:	c6 83 8c 01 00 00 01 	movb   $0x1,0x18c(%ebx)
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3251:	89 83 88 01 00 00    	mov    %eax,0x188(%ebx)
	SV(PeriodicBSRTimer).flag = true;
	fsm_printf("[UEMAC][handle_periodicbsrtimer]handle PeriodicBSRTimer expire\n");//testing code 
    3257:	c7 04 24 34 0c 00 00 	movl   $0xc34,(%esp)
    325e:	e8 fc ff ff ff       	call   325f <reports_handler+0x9f>
    3263:	e9 6e ff ff ff       	jmp    31d6 <reports_handler+0x16>
    3268:	90                   	nop
    3269:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003270 <send_msg3>:
->output:
->Special:
*******************************
*/
void send_msg3(FSM_PKT *skb) //defined by HQ 20140430  
{
    3270:	55                   	push   %ebp
    3271:	89 e5                	mov    %esp,%ebp
    3273:	56                   	push   %esi
    3274:	53                   	push   %ebx
    3275:	83 ec 08             	sub    $0x8,%esp
    3278:	e8 fc ff ff ff       	call   3279 <send_msg3+0x9>
    327d:	89 c6                	mov    %eax,%esi
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	//FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    327f:	e8 fc ff ff ff       	call   3280 <send_msg3+0x10>
    3284:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    3286:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    328c:	c7 04 24 ac 0c 00 00 	movl   $0xcac,(%esp)
    3293:	89 44 24 04          	mov    %eax,0x4(%esp)
    3297:	e8 fc ff ff ff       	call   3298 <send_msg3+0x28>
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    329c:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    32a2:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    32a8:	83 fa 01             	cmp    $0x1,%edx
    32ab:	74 3b                	je     32e8 <send_msg3+0x78>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    32ad:	85 c0                	test   %eax,%eax
    32af:	74 09                	je     32ba <send_msg3+0x4a>
    32b1:	83 fa 02             	cmp    $0x2,%edx
    32b4:	0f 84 a6 00 00 00    	je     3360 <send_msg3+0xf0>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    32ba:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32c0:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    32c5:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32cb:	6b c0 64             	imul   $0x64,%eax,%eax
    32ce:	e8 fc ff ff ff       	call   32cf <send_msg3+0x5f>
	SV(CRTimer.flag)=true;
    32d3:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    32da:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	SV(CRTimer.flag)=true;
	FOUT;
}
    32e0:	83 c4 08             	add    $0x8,%esp
    32e3:	5b                   	pop    %ebx
    32e4:	5e                   	pop    %esi
    32e5:	5d                   	pop    %ebp
    32e6:	c3                   	ret    
    32e7:	90                   	nop
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    32e8:	85 c0                	test   %eax,%eax
    32ea:	74 05                	je     32f1 <send_msg3+0x81>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    32ec:	e8 fc ff ff ff       	call   32ed <send_msg3+0x7d>
		SV(msg3_buf_ptr)=skb;//3
    32f1:	89 b3 e4 01 00 00    	mov    %esi,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32f7:	89 f0                	mov    %esi,%eax
    32f9:	e8 fc ff ff ff       	call   32fa <send_msg3+0x8a>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32fe:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3303:	89 c6                	mov    %eax,%esi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3305:	e8 fc ff ff ff       	call   3306 <send_msg3+0x96>
    330a:	85 c0                	test   %eax,%eax
    330c:	74 1a                	je     3328 <send_msg3+0xb8>
    330e:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3312:	74 14                	je     3328 <send_msg3+0xb8>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3314:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    331b:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3322:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
		complexUeMacPdu(skb);
    3328:	89 f0                	mov    %esi,%eax
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    332a:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3331:	00 00 00 
		complexUeMacPdu(skb);
    3334:	e8 fc ff ff ff       	call   3335 <send_msg3+0xc5>
		
	
		if(SV(Tbsize_Complex)!=0)
    3339:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    333f:	85 c0                	test   %eax,%eax
    3341:	74 0a                	je     334d <send_msg3+0xdd>
			SV(Tbsize_Complex)=0;//TBSIZE
    3343:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    334a:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    334d:	c7 04 24 d8 0c 00 00 	movl   $0xcd8,(%esp)
    3354:	e8 fc ff ff ff       	call   3355 <send_msg3+0xe5>
    3359:	e9 5c ff ff ff       	jmp    32ba <send_msg3+0x4a>
    335e:	66 90                	xchg   %ax,%ax
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3360:	e8 fc ff ff ff       	call   3361 <send_msg3+0xf1>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3365:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    336a:	89 c6                	mov    %eax,%esi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    336c:	e8 fc ff ff ff       	call   336d <send_msg3+0xfd>
    3371:	85 c0                	test   %eax,%eax
    3373:	74 06                	je     337b <send_msg3+0x10b>
    3375:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3379:	75 3d                	jne    33b8 <send_msg3+0x148>
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
		complexUeMacPdu(skb); 	
    337b:	89 f0                	mov    %esi,%eax
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
    337d:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3384:	00 00 00 
		complexUeMacPdu(skb); 	
    3387:	e8 fc ff ff ff       	call   3388 <send_msg3+0x118>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    338c:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    3392:	85 c0                	test   %eax,%eax
    3394:	74 0a                	je     33a0 <send_msg3+0x130>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    3396:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    339d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    33a0:	c7 04 24 10 0d 00 00 	movl   $0xd10,(%esp)
    33a7:	e8 fc ff ff ff       	call   33a8 <send_msg3+0x138>
    33ac:	e9 09 ff ff ff       	jmp    32ba <send_msg3+0x4a>
    33b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    33b8:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    33bf:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    33c6:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
    33cc:	eb ad                	jmp    337b <send_msg3+0x10b>
    33ce:	66 90                	xchg   %ax,%ax

000033d0 <print_tran_info>:
->output:
->Special:
*******************************
*/
void print_tran_info( const char *str)
{
    33d0:	55                   	push   %ebp
    33d1:	89 e5                	mov    %esp,%ebp
    33d3:	53                   	push   %ebx
    33d4:	83 ec 04             	sub    $0x4,%esp
    33d7:	e8 fc ff ff ff       	call   33d8 <print_tran_info+0x8>
    33dc:	89 c3                	mov    %eax,%ebx
	FIN( print_tran_info());
	int curtime=0;
	curtime=fsm_get_curtime();
    33de:	e8 fc ff ff ff       	call   33df <print_tran_info+0xf>
	//fsm_printf("[UEMAC][print_info]%d ",curtime);
	fsm_printf(str);
    33e3:	89 1c 24             	mov    %ebx,(%esp)
    33e6:	e8 fc ff ff ff       	call   33e7 <print_tran_info+0x17>
	fsm_printf("\n");
    33eb:	c7 04 24 95 01 00 00 	movl   $0x195,(%esp)
    33f2:	e8 fc ff ff ff       	call   33f3 <print_tran_info+0x23>
	FOUT;
}
    33f7:	83 c4 04             	add    $0x4,%esp
    33fa:	5b                   	pop    %ebx
    33fb:	5d                   	pop    %ebp
    33fc:	c3                   	ret    
    33fd:	8d 76 00             	lea    0x0(%esi),%esi

00003400 <handle_timeAlignmentTimerExpire>:
->output:
->Special:
*******************************
*/
static void handle_timeAlignmentTimerExpire()
{
    3400:	55                   	push   %ebp
    3401:	89 e5                	mov    %esp,%ebp
    3403:	e8 fc ff ff ff       	call   3404 <handle_timeAlignmentTimerExpire+0x4>
	FIN(handle_timeAlignmentTimerExpire());  
	SV_PTR_GET(rlc_mac_sv);
    3408:	e8 fc ff ff ff       	call   3409 <handle_timeAlignmentTimerExpire+0x9>
	SV(TATimer.time_value)=0;
    340d:	c7 80 60 01 00 00 00 	movl   $0x0,0x160(%eax)
    3414:	00 00 00 
	SV(TATimer.flag)=false;//
    3417:	c6 80 68 01 00 00 00 	movb   $0x0,0x168(%eax)
	SV(TATimer.timer_sign)=NULL;
    341e:	c7 80 64 01 00 00 00 	movl   $0x0,0x164(%eax)
    3425:	00 00 00 
	cleanharqBuff(); //HARQ
	//fsm_do_ioctrl(STRM_TO_IP, IOCCMD_MACtoRRC_PUCCHSRS_release  , NULL , 0);  //RRCPUCCH/SRS
	//
	SV(UL_resource_info.resource_flag)=false;//
    3428:	c6 40 28 00          	movb   $0x0,0x28(%eax)
	SV(UL_resource_info.m_tbsize)=0;
    342c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
											//??? 
	print_tran_info("[UEMAC][handle_tatimer]LostUL"); //testing code 
    3433:	b8 97 01 00 00       	mov    $0x197,%eax
    3438:	e8 fc ff ff ff       	call   3439 <handle_timeAlignmentTimerExpire+0x39>
	FOUT;
}
    343d:	5d                   	pop    %ebp
    343e:	c3                   	ret    
    343f:	90                   	nop

00003440 <random_test>:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
{
    3440:	55                   	push   %ebp
    3441:	89 e5                	mov    %esp,%ebp
    3443:	56                   	push   %esi
    3444:	53                   	push   %ebx
    3445:	83 ec 18             	sub    $0x18,%esp
    3448:	e8 fc ff ff ff       	call   3449 <random_test+0x9>
    344d:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    3453:	89 45 f4             	mov    %eax,-0xc(%ebp)
    3456:	31 c0                	xor    %eax,%eax
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    3458:	8d 5d ea             	lea    -0x16(%ebp),%ebx
void random_test()   //HQ 20140410 0-63
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    345b:	c7 04 24 48 0d 00 00 	movl   $0xd48,(%esp)
->input:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
    3462:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    3465:	e8 fc ff ff ff       	call   3466 <random_test+0x26>
    346a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    3470:	89 d8                	mov    %ebx,%eax
    3472:	ba 01 00 00 00       	mov    $0x1,%edx
    3477:	e8 fc ff ff ff       	call   3478 <random_test+0x38>
		randNum[i]=randNum[i]%64;
    347c:	0f b6 03             	movzbl (%ebx),%eax
    347f:	83 e0 3f             	and    $0x3f,%eax
    3482:	88 03                	mov    %al,(%ebx)
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
    3484:	0f b6 c0             	movzbl %al,%eax
    3487:	83 c3 01             	add    $0x1,%ebx
    348a:	89 44 24 04          	mov    %eax,0x4(%esp)
    348e:	c7 04 24 78 0d 00 00 	movl   $0xd78,(%esp)
    3495:	e8 fc ff ff ff       	call   3496 <random_test+0x56>
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
    349a:	39 f3                	cmp    %esi,%ebx
    349c:	75 d2                	jne    3470 <random_test+0x30>
		fsm_get_random_bytes(&randNum[i], sizeof(char));
		randNum[i]=randNum[i]%64;
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
	} 
	FOUT;
}
    349e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    34a1:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    34a8:	75 07                	jne    34b1 <random_test+0x71>
    34aa:	83 c4 18             	add    $0x18,%esp
    34ad:	5b                   	pop    %ebx
    34ae:	5e                   	pop    %esi
    34af:	5d                   	pop    %ebp
    34b0:	c3                   	ret    
    34b1:	e8 fc ff ff ff       	call   34b2 <random_test+0x72>
    34b6:	8d 76 00             	lea    0x0(%esi),%esi
    34b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000034c0 <RA_RRCconfig_testingfun>:
->output:
->Special:
*******************************
*/
void RA_RRCconfig_testingfun() // RRC HQ 20140428 
{
    34c0:	55                   	push   %ebp
    34c1:	89 e5                	mov    %esp,%ebp
    34c3:	83 ec 04             	sub    $0x4,%esp
    34c6:	e8 fc ff ff ff       	call   34c7 <RA_RRCconfig_testingfun+0x7>
	FIN(RA_RRCconfig_testingfun());
	SV_PTR_GET(rlc_mac_sv);
    34cb:	e8 fc ff ff ff       	call   34cc <RA_RRCconfig_testingfun+0xc>
	SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles)= 64;
    34d0:	c7 80 ac 00 00 00 40 	movl   $0x40,0xac(%eax)
    34d7:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax)=8;
    34da:	c7 80 c8 00 00 00 08 	movl   $0x8,0xc8(%eax)
    34e1:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize)=800000;//8; 800s
    34e4:	c7 80 cc 00 00 00 00 	movl   $0xc3500,0xcc(%eax)
    34eb:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer)=800000;// 800s;
    34ee:	c7 80 d0 00 00 00 00 	movl   $0xc3500,0xd0(%eax)
    34f5:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx)=5;
    34f8:	c7 80 d4 00 00 00 05 	movl   $0x5,0xd4(%eax)
    34ff:	00 00 00 
	SV(backoff_index)= 2 ; 
    3502:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
	fsm_printf("[UEMAC][ra_rrcconfig]:RACH config have done \n");//testing code
    3509:	c7 04 24 a4 0d 00 00 	movl   $0xda4,(%esp)
    3510:	e8 fc ff ff ff       	call   3511 <RA_RRCconfig_testingfun+0x51>
	FOUT;
}
    3515:	c9                   	leave  
    3516:	c3                   	ret    
    3517:	89 f6                	mov    %esi,%esi
    3519:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003520 <ue_mac_sv_init>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_init()
{
    3520:	55                   	push   %ebp
    3521:	89 e5                	mov    %esp,%ebp
    3523:	57                   	push   %edi
    3524:	56                   	push   %esi
    3525:	53                   	push   %ebx
    3526:	83 ec 08             	sub    $0x8,%esp
    3529:	e8 fc ff ff ff       	call   352a <ue_mac_sv_init+0xa>
	FIN(ue_mac_sv_init());
	int len;
	
	SV_PTR_GET(rlc_mac_sv);
    352e:	e8 fc ff ff ff       	call   352f <ue_mac_sv_init+0xf>
    3533:	89 c3                	mov    %eax,%ebx
	print_tran_info("FSM INIT-init SV");//testing code
    3535:	b8 b5 01 00 00       	mov    $0x1b5,%eax
    353a:	e8 fc ff ff ff       	call   353b <ue_mac_sv_init+0x1b>
	SV(TA_Periodic_time)=800000000;//testing code ,
    353f:	c7 43 24 00 08 af 2f 	movl   $0x2faf0800,0x24(%ebx)
	Init_Uemac_Scheduler();
    3546:	e8 fc ff ff ff       	call   3547 <ue_mac_sv_init+0x27>
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    354b:	b8 06 00 00 00       	mov    $0x6,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("FSM INIT-init SV");//testing code
	SV(TA_Periodic_time)=800000000;//testing code ,
	Init_Uemac_Scheduler();
	SV(sys_frame.frameNo)=0;//modified LHL 20141105
    3550:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
	SV(sys_frame.subframeNo)=0;
    3556:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
	SV(recv_frame).subframeNo=0;//
    355c:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	SV(recv_frame).frameNo=0;
    3562:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	SV(ue_schedule_frame.frameNo)=0;
    3568:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
	SV(ue_schedule_frame.subframeNo)=0;
    356e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
    3574:	66 c7 43 22 00 00    	movw   $0x0,0x22(%ebx)
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    357a:	e8 fc ff ff ff       	call   357b <ue_mac_sv_init+0x5b>
	//
	
	SV(TATimer.time_value) = 0;
    357f:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    3586:	00 00 00 
	SV(TATimer.timer_sign) = NULL;
    3589:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    3590:	00 00 00 
	SV(TATimer.flag) = false;
    3593:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
	SV(CRTimer.time_value) = 0;
    359a:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    35a1:	00 00 00 
	SV(CRTimer.timer_sign) = NULL;
    35a4:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    35ab:	00 00 00 
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    35ae:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	SV(TATimer.time_value) = 0;
	SV(TATimer.timer_sign) = NULL;
	SV(TATimer.flag) = false;
	SV(CRTimer.time_value) = 0;
	SV(CRTimer.timer_sign) = NULL;
	SV(CRTimer.flag) = false;
    35b4:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
	SV(RetxBSRTimer.time_value) = 0;
    35bb:	c7 83 78 01 00 00 00 	movl   $0x0,0x178(%ebx)
    35c2:	00 00 00 
	SV(RetxBSRTimer.timer_sign) = NULL;
    35c5:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    35cc:	00 00 00 
	SV(RetxBSRTimer.flag) = false;
    35cf:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	SV(PeriodicBSRTimer.time_value) = 0;
    35d6:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
    35dd:	00 00 00 
	SV(PeriodicBSRTimer.timer_sign) = NULL;
    35e0:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    35e7:	00 00 00 
	SV(PeriodicBSRTimer.flag) = false;	
    35ea:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
	SV(WaitforRAresponseTimer.time_value) = 0;
    35f1:	c7 83 90 01 00 00 00 	movl   $0x0,0x190(%ebx)
    35f8:	00 00 00 
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
    35fb:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3602:	00 00 00 
	SV(WaitforRAresponseTimer.flag) = false;
    3605:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
	SV(msg3_buf_ptr) = NULL;	
    360c:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    3613:	00 00 00 
	SV(ra_allocation_res)=0;
    3616:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    361d:	00 00 00 
*******************************
*/
static void macmain_defaultconfig()
{
	FIN(macmain_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3620:	e8 fc ff ff ff       	call   3621 <ue_mac_sv_init+0x101>
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx) = maxHARQ_Tx_n5;
    3625:	c7 40 60 05 00 00 00 	movl   $0x5,0x60(%eax)
	//fsm_printf("test maxHARQTX:%d \n ",SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx));//testing code
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)= periodicBSR_Timer_infinity;//
    362c:	c7 40 64 ff ff ff ff 	movl   $0xffffffff,0x64(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)= retxBSR_Timer_sf2560 ;
    3633:	c7 40 68 00 0a 00 00 	movl   $0xa00,0x68(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.ttiBundling)= false ;
    363a:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.drx_Config.choice.setup.haveShortDRX)= false ;//means release
    363e:	c6 80 8c 00 00 00 00 	movb   $0x0,0x8c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.type)= 1 ; //means phr-Config release ??  
    3645:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
    364c:	00 00 00 
*******************************
*/
static void sps_defaultconfig()
{
	FIN(sps_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    364f:	e8 fc ff ff ff       	call   3650 <ue_mac_sv_init+0x130>
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigDL)=false;
    3654:	c6 80 e8 00 00 00 00 	movb   $0x0,0xe8(%eax)
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigUL)=false; 
    365b:	c6 80 08 01 00 00 00 	movb   $0x0,0x108(%eax)
*******************************
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3662:	e8 fc ff ff ff       	call   3663 <ue_mac_sv_init+0x143>
    3667:	89 c7                	mov    %eax,%edi
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    3669:	b8 15 00 00 00       	mov    $0x15,%eax
    366e:	e8 fc ff ff ff       	call   366f <ue_mac_sv_init+0x14f>
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    3673:	8d 97 28 01 00 00    	lea    0x128(%edi),%edx
    3679:	b9 15 00 00 00       	mov    $0x15,%ecx
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
    367e:	c7 87 28 01 00 00 00 	movl   $0x0,0x128(%edi)
    3685:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
    3688:	c6 87 2c 01 00 00 01 	movb   $0x1,0x12c(%edi)
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
    368f:	c7 87 2d 01 00 00 01 	movl   $0x1,0x12d(%edi)
    3696:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
    3699:	c7 87 31 01 00 00 ff 	movl   $0xffffffff,0x131(%edi)
    36a0:	ff ff ff 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
    36a3:	c7 87 39 01 00 00 00 	movl   $0x0,0x139(%edi)
    36aa:	00 00 00 
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    36ad:	89 c6                	mov    %eax,%esi
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    36af:	e8 fc ff ff ff       	call   36b0 <ue_mac_sv_init+0x190>
	Init_LogicalChannel_ConfigInfo(ccch_info); 
    36b4:	89 f0                	mov    %esi,%eax
    36b6:	e8 fc ff ff ff       	call   36b7 <ue_mac_sv_init+0x197>
	fsm_mem_free(ccch_info);//
    36bb:	89 f0                	mov    %esi,%eax
    36bd:	e8 fc ff ff ff       	call   36be <ue_mac_sv_init+0x19e>
	fsm_printf("[UEMAC][init]CCCH_defaultconfig completed\n");
    36c2:	c7 04 24 d4 0d 00 00 	movl   $0xdd4,(%esp)
    36c9:	e8 fc ff ff ff       	call   36ca <ue_mac_sv_init+0x1aa>
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
    36ce:	e8 fc ff ff ff       	call   36cf <ue_mac_sv_init+0x1af>
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    36d3:	b9 04 00 00 00       	mov    $0x4,%ecx
    36d8:	31 d2                	xor    %edx,%edx
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
	SV(UL_resource_info.resource_flag)= false; //testing code
    36da:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    36de:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
    36e4:	e8 fc ff ff ff       	call   36e5 <ue_mac_sv_init+0x1c5>
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    36e9:	b8 0c 00 00 00       	mov    $0xc,%eax
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
	SV(sendmsg3)=0;//0:MSG31:MSG3
    36ee:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    36f5:	00 00 00 
	SV(pdcch_rnti)=0;//0:PDCCHC_RNTI1:C_RNTI
    36f8:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    36ff:	00 00 00 
	SV(Tbsize_Complex)=0;//modified by lhl ,20140718,to 
    3702:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    3709:	00 00 00 
	//test_init_logicalchannel(1);//TEST 20141103
	//test_init_logicalchannel(3);//TEST 20141103
	SV(contention_failed_num)=0;
    370c:	c7 83 00 02 00 00 00 	movl   $0x0,0x200(%ebx)
    3713:	00 00 00 
	SV(rar_failed_num)=0;
    3716:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
    371d:	00 00 00 
	
	SV(lost_pkt_num_uplink)=0;
    3720:	c7 83 04 02 00 00 00 	movl   $0x0,0x204(%ebx)
    3727:	00 00 00 
	SV(pkt_num_uplink)=0;
    372a:	c7 83 08 02 00 00 00 	movl   $0x0,0x208(%ebx)
    3731:	00 00 00 
	SV(lost_pkt_num_downlink)=0;
    3734:	c7 83 0c 02 00 00 00 	movl   $0x0,0x20c(%ebx)
    373b:	00 00 00 
	SV(pkt_num_downlink)=0;
    373e:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%ebx)
    3745:	00 00 00 
	
	SV(countSendToUpper)=0;
    3748:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    374f:	00 00 00 
	SV(countRecvFromLower)=0;
    3752:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    3759:	00 00 00 
	SV(countreceive_from_mac)=0;
    375c:	c7 83 88 5a 00 00 00 	movl   $0x0,0x5a88(%ebx)
    3763:	00 00 00 
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    3766:	e8 fc ff ff ff       	call   3767 <ue_mac_sv_init+0x247>
    376b:	89 c6                	mov    %eax,%esi
    376d:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)
	(*Q)->front = (*Q)->rear = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    3773:	b8 08 00 00 00       	mov    $0x8,%eax
    3778:	e8 fc ff ff ff       	call   3779 <ue_mac_sv_init+0x259>
    377d:	89 46 04             	mov    %eax,0x4(%esi)
    3780:	89 06                	mov    %eax,(%esi)
	// Q->front = NULL;
	// Q->rear = NULL;
	(*Q)->pkt_count = 0;
    3782:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    3788:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	fsm_printf("[InitQueue]Q point: %p\n", *Q);
    378e:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    3794:	c7 04 24 c6 01 00 00 	movl   $0x1c6,(%esp)
    379b:	89 44 24 04          	mov    %eax,0x4(%esp)
    379f:	e8 fc ff ff ff       	call   37a0 <ue_mac_sv_init+0x280>
	SV(countSendToUpper)=0;
	SV(countRecvFromLower)=0;
	SV(countreceive_from_mac)=0;

	InitQueue(&SV(CraQueue));	//add cra queue initialization by LXR in 20151020
	fsm_printf("[ue_mac_sv_init]SV(CraQueue): %p\n", SV(CraQueue));
    37a4:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    37aa:	c7 04 24 00 0e 00 00 	movl   $0xe00,(%esp)
    37b1:	89 44 24 04          	mov    %eax,0x4(%esp)
    37b5:	e8 fc ff ff ff       	call   37b6 <ue_mac_sv_init+0x296>
	
	FOUT;
}
    37ba:	83 c4 08             	add    $0x8,%esp
    37bd:	5b                   	pop    %ebx
    37be:	5e                   	pop    %esi
    37bf:	5f                   	pop    %edi
    37c0:	5d                   	pop    %ebp
    37c1:	c3                   	ret    
    37c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    37c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000037d0 <testdoStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartContentionBasedRandomAccessProcedure()
{
    37d0:	55                   	push   %ebp
    37d1:	89 e5                	mov    %esp,%ebp
    37d3:	e8 fc ff ff ff       	call   37d4 <testdoStartContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> CRA");
    37d8:	b8 de 01 00 00       	mov    $0x1de,%eax
    37dd:	e8 fc ff ff ff       	call   37de <testdoStartContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	//fsm_schedule_self(100000, RandomAcc_Fail );//testing code
	FOUT;
}
    37e2:	5d                   	pop    %ebp
    37e3:	c3                   	ret    
    37e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    37ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000037f0 <testdoStartNonContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartNonContentionBasedRandomAccessProcedure() // 
{
    37f0:	55                   	push   %ebp
    37f1:	89 e5                	mov    %esp,%ebp
    37f3:	e8 fc ff ff ff       	call   37f4 <testdoStartNonContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartNonContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> NCRA");
    37f8:	b8 ea 01 00 00       	mov    $0x1ea,%eax
    37fd:	e8 fc ff ff ff       	call   37fe <testdoStartNonContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	FOUT;
}
    3802:	5d                   	pop    %ebp
    3803:	c3                   	ret    
    3804:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    380a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003810 <stop_WRAP_timer>:
->output:
->Special:
*******************************
*/
void stop_WRAP_timer()
{
    3810:	55                   	push   %ebp
    3811:	89 e5                	mov    %esp,%ebp
    3813:	53                   	push   %ebx
    3814:	e8 fc ff ff ff       	call   3815 <stop_WRAP_timer+0x5>
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3819:	e8 fc ff ff ff       	call   381a <stop_WRAP_timer+0xa>
	if(SV(WaitforRAresponseTimer.flag)==true)
    381e:	80 b8 98 01 00 00 00 	cmpb   $0x0,0x198(%eax)
*******************************
*/
void stop_WRAP_timer()
{
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3825:	89 c3                	mov    %eax,%ebx
	if(SV(WaitforRAresponseTimer.flag)==true)
    3827:	74 1c                	je     3845 <stop_WRAP_timer+0x35>
	{
		fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    3829:	8b 80 94 01 00 00    	mov    0x194(%eax),%eax
    382f:	e8 fc ff ff ff       	call   3830 <stop_WRAP_timer+0x20>
		SV(WaitforRAresponseTimer.flag)=false;
    3834:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)=NULL;
    383b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3842:	00 00 00 
	}
	FOUT;
}
    3845:	5b                   	pop    %ebx
    3846:	5d                   	pop    %ebp
    3847:	c3                   	ret    
    3848:	90                   	nop
    3849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003850 <NCRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void NCRAtoCON_testingfun() 
{
    3850:	55                   	push   %ebp
    3851:	89 e5                	mov    %esp,%ebp
    3853:	e8 fc ff ff ff       	call   3854 <NCRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("NCRA -> CON");
    3858:	b8 f7 01 00 00       	mov    $0x1f7,%eax
    385d:	e8 fc ff ff ff       	call   385e <NCRAtoCON_testingfun+0xe>
	stop_WRAP_timer(); //RAR
    3862:	e8 fc ff ff ff       	call   3863 <NCRAtoCON_testingfun+0x13>
	FOUT;
}
    3867:	5d                   	pop    %ebp
    3868:	c3                   	ret    
    3869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003870 <stop_CR_timer>:
->output:
->Special:
*******************************
*/
void stop_CR_timer()
{
    3870:	55                   	push   %ebp
    3871:	89 e5                	mov    %esp,%ebp
    3873:	53                   	push   %ebx
    3874:	e8 fc ff ff ff       	call   3875 <stop_CR_timer+0x5>
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3879:	e8 fc ff ff ff       	call   387a <stop_CR_timer+0xa>
	if(SV(CRTimer.flag)==true)
    387e:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
*******************************
*/
void stop_CR_timer()
{
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3885:	89 c3                	mov    %eax,%ebx
	if(SV(CRTimer.flag)==true)
    3887:	74 1c                	je     38a5 <stop_CR_timer+0x35>
	{
		fsm_schedule_cancel(SV(CRTimer.timer_sign));
    3889:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    388f:	e8 fc ff ff ff       	call   3890 <stop_CR_timer+0x20>
		SV(CRTimer.flag)=false;
    3894:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
		SV(CRTimer.timer_sign)=NULL;
    389b:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    38a2:	00 00 00 
	}
	FOUT;
}
    38a5:	5b                   	pop    %ebx
    38a6:	5d                   	pop    %ebp
    38a7:	c3                   	ret    
    38a8:	90                   	nop
    38a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038b0 <stop_TA_timer>:
->output:
->Special:
*******************************
*/
void stop_TA_timer()
{
    38b0:	55                   	push   %ebp
    38b1:	89 e5                	mov    %esp,%ebp
    38b3:	53                   	push   %ebx
    38b4:	e8 fc ff ff ff       	call   38b5 <stop_TA_timer+0x5>
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    38b9:	e8 fc ff ff ff       	call   38ba <stop_TA_timer+0xa>
	if(SV(TATimer.flag)==true)
    38be:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
void stop_TA_timer()
{
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    38c5:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true)
    38c7:	74 1c                	je     38e5 <stop_TA_timer+0x35>
	{
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    38c9:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    38cf:	e8 fc ff ff ff       	call   38d0 <stop_TA_timer+0x20>
		SV(TATimer.flag)=false;
    38d4:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.timer_sign)=NULL;
    38db:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    38e2:	00 00 00 
	}
	FOUT;
}
    38e5:	5b                   	pop    %ebx
    38e6:	5d                   	pop    %ebp
    38e7:	c3                   	ret    
    38e8:	90                   	nop
    38e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038f0 <stop_RetxBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_RetxBSR_timer()
{
    38f0:	55                   	push   %ebp
    38f1:	89 e5                	mov    %esp,%ebp
    38f3:	53                   	push   %ebx
    38f4:	e8 fc ff ff ff       	call   38f5 <stop_RetxBSR_timer+0x5>
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    38f9:	e8 fc ff ff ff       	call   38fa <stop_RetxBSR_timer+0xa>
	if(SV(RetxBSRTimer.flag)==true)
    38fe:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
*******************************
*/
void stop_RetxBSR_timer()
{
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3905:	89 c3                	mov    %eax,%ebx
	if(SV(RetxBSRTimer.flag)==true)
    3907:	74 1c                	je     3925 <stop_RetxBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(RetxBSRTimer.timer_sign));
    3909:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    390f:	e8 fc ff ff ff       	call   3910 <stop_RetxBSR_timer+0x20>
		SV(RetxBSRTimer.flag)=false;
    3914:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
		SV(RetxBSRTimer.timer_sign)=NULL;
    391b:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3922:	00 00 00 
	}
	FOUT;
}
    3925:	5b                   	pop    %ebx
    3926:	5d                   	pop    %ebp
    3927:	c3                   	ret    
    3928:	90                   	nop
    3929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003930 <stop_PeriodicBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_PeriodicBSR_timer()
{
    3930:	55                   	push   %ebp
    3931:	89 e5                	mov    %esp,%ebp
    3933:	53                   	push   %ebx
    3934:	e8 fc ff ff ff       	call   3935 <stop_PeriodicBSR_timer+0x5>
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3939:	e8 fc ff ff ff       	call   393a <stop_PeriodicBSR_timer+0xa>
	if(SV(PeriodicBSRTimer.flag)==true)
    393e:	80 b8 8c 01 00 00 00 	cmpb   $0x0,0x18c(%eax)
*******************************
*/
void stop_PeriodicBSR_timer()
{
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3945:	89 c3                	mov    %eax,%ebx
	if(SV(PeriodicBSRTimer.flag)==true)
    3947:	74 1c                	je     3965 <stop_PeriodicBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(PeriodicBSRTimer.timer_sign));
    3949:	8b 80 88 01 00 00    	mov    0x188(%eax),%eax
    394f:	e8 fc ff ff ff       	call   3950 <stop_PeriodicBSR_timer+0x20>
		SV(PeriodicBSRTimer.flag)=false;
    3954:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
		SV(PeriodicBSRTimer.timer_sign)=NULL;
    395b:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    3962:	00 00 00 
	}
	FOUT;
}
    3965:	5b                   	pop    %ebx
    3966:	5d                   	pop    %ebp
    3967:	c3                   	ret    
    3968:	90                   	nop
    3969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003970 <ue_mac_reset>:
->output:
->Special:
*******************************
*/
static void ue_mac_reset()//modified by LHL 20140717
{
    3970:	55                   	push   %ebp
    3971:	89 e5                	mov    %esp,%ebp
    3973:	53                   	push   %ebx
    3974:	e8 fc ff ff ff       	call   3975 <ue_mac_reset+0x5>
	FIN( ue_mac_reset());
	SV_PTR_GET(rlc_mac_sv);
    3979:	e8 fc ff ff ff       	call   397a <ue_mac_reset+0xa>
    397e:	89 c3                	mov    %eax,%ebx
	//initialize Bj for each logical channel to zero;BJ0 
	Zero_LogicalChannel_Bj_Reset();
    3980:	e8 fc ff ff ff       	call   3981 <ue_mac_reset+0x11>
	//stop (if running) all timers; 
	stop_WRAP_timer();//WaitforRAresponseTimer
    3985:	e8 fc ff ff ff       	call   3986 <ue_mac_reset+0x16>
	stop_CR_timer();//CR
    398a:	e8 fc ff ff ff       	call   398b <ue_mac_reset+0x1b>
    398f:	90                   	nop
	stop_RetxBSR_timer();
    3990:	e8 fc ff ff ff       	call   3991 <ue_mac_reset+0x21>
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
    3995:	e8 fc ff ff ff       	call   3996 <ue_mac_reset+0x26>
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    399a:	8b 83 e8 01 00 00    	mov    0x1e8(%ebx),%eax
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
	//	consider timeAlignmentTimer as expired and perform the corresponding actions in subclause 5.2;
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
    39a0:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	SV(SR_COUNTER)= 0; 
    39a7:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    39ae:	83 f8 03             	cmp    $0x3,%eax
    39b1:	74 4d                	je     3a00 <ue_mac_reset+0x90>
    39b3:	83 f8 01             	cmp    $0x1,%eax
    39b6:	74 48                	je     3a00 <ue_mac_reset+0x90>
	{
		SV(RA_info.ra_PreambleIndex)=0;//
		SV(RA_info.ra_PRACHMaskIndex)=0;
	}
	//	flush Msg3 buffer;
	if(SV(msg3_buf_ptr)!=NULL)
    39b8:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    39be:	85 c0                	test   %eax,%eax
    39c0:	74 0f                	je     39d1 <ue_mac_reset+0x61>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));	
    39c2:	e8 fc ff ff ff       	call   39c3 <ue_mac_reset+0x53>
		SV(msg3_buf_ptr) = NULL; 
    39c7:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    39ce:	00 00 00 
	}
	//	cancel, if any, triggered Scheduling Request procedure;
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
    39d1:	e8 fc ff ff ff       	call   39d2 <ue_mac_reset+0x62>
	Empty_MACBuffer_Rlc();//RLC 
    39d6:	e8 fc ff ff ff       	call   39d7 <ue_mac_reset+0x67>
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
	if(SV(m_temp_cr) != NULL)
    39db:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
	Empty_MACBuffer_Rlc();//RLC 
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
    39e1:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if(SV(m_temp_cr) != NULL)
    39e7:	85 c0                	test   %eax,%eax
    39e9:	74 0f                	je     39fa <ue_mac_reset+0x8a>
	{
		fsm_mem_free(SV(m_temp_cr));
    39eb:	e8 fc ff ff ff       	call   39ec <ue_mac_reset+0x7c>
		SV(m_temp_cr) = NULL;
    39f0:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    39f7:	00 00 00 
	}
	FOUT;
}
    39fa:	5b                   	pop    %ebx
    39fb:	5d                   	pop    %ebp
    39fc:	c3                   	ret    
    39fd:	8d 76 00             	lea    0x0(%esi),%esi
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
	{
		SV(RA_info.ra_PreambleIndex)=0;//
    3a00:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0;
    3a04:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    3a08:	eb ae                	jmp    39b8 <ue_mac_reset+0x48>
    3a0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00003a10 <CRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void CRAtoCON_testingfun()
{
    3a10:	55                   	push   %ebp
    3a11:	89 e5                	mov    %esp,%ebp
    3a13:	e8 fc ff ff ff       	call   3a14 <CRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("CRA -> CON");
    3a18:	b8 03 02 00 00       	mov    $0x203,%eax
    3a1d:	e8 fc ff ff ff       	call   3a1e <CRAtoCON_testingfun+0xe>
	stop_CR_timer(); //
    3a22:	e8 fc ff ff ff       	call   3a23 <CRAtoCON_testingfun+0x13>
	FOUT;
}
    3a27:	5d                   	pop    %ebp
    3a28:	c3                   	ret    
    3a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003a30 <test1_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test1_idle_default_handler()
{
    3a30:	55                   	push   %ebp
    3a31:	89 e5                	mov    %esp,%ebp
    3a33:	83 ec 10             	sub    $0x10,%esp
    3a36:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    3a39:	89 75 fc             	mov    %esi,-0x4(%ebp)
    3a3c:	e8 fc ff ff ff       	call   3a3d <test1_idle_default_handler+0xd>
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    3a41:	e8 fc ff ff ff       	call   3a42 <test1_idle_default_handler+0x12>
    3a46:	89 c3                	mov    %eax,%ebx
	print_tran_info("MAC:idle_default_handler");
    3a48:	b8 0e 02 00 00       	mov    $0x20e,%eax
    3a4d:	e8 fc ff ff ff       	call   3a4e <test1_idle_default_handler+0x1e>
	if(MAC_CLOSE)
    3a52:	e8 fc ff ff ff       	call   3a53 <test1_idle_default_handler+0x23>
    3a57:	83 f8 05             	cmp    $0x5,%eax
    3a5a:	74 5c                	je     3ab8 <test1_idle_default_handler+0x88>
    3a5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3a60:	e8 fc ff ff ff       	call   3a61 <test1_idle_default_handler+0x31>
    3a65:	83 f8 02             	cmp    $0x2,%eax
    3a68:	74 76                	je     3ae0 <test1_idle_default_handler+0xb0>
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3a6a:	e8 fc ff ff ff       	call   3a6b <test1_idle_default_handler+0x3b>
    3a6f:	83 f8 05             	cmp    $0x5,%eax
    3a72:	74 0c                	je     3a80 <test1_idle_default_handler+0x50>
			ioctrl_handler();  	
		break;
		}
	}
FOUT;
}
    3a74:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    3a77:	8b 75 fc             	mov    -0x4(%ebp),%esi
    3a7a:	89 ec                	mov    %ebp,%esp
    3a7c:	5d                   	pop    %ebp
    3a7d:	c3                   	ret    
    3a7e:	66 90                	xchg   %ax,%ax
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3a80:	e8 fc ff ff ff       	call   3a81 <test1_idle_default_handler+0x51>
    3a85:	83 f8 02             	cmp    $0x2,%eax
    3a88:	75 ea                	jne    3a74 <test1_idle_default_handler+0x44>
	{//IOCTL
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
    3a8a:	b8 3a 02 00 00       	mov    $0x23a,%eax
    3a8f:	e8 fc ff ff ff       	call   3a90 <test1_idle_default_handler+0x60>
		switch(fsm_ev_ioctrl_cmd())
    3a94:	e8 fc ff ff ff       	call   3a95 <test1_idle_default_handler+0x65>
    3a99:	83 f8 0b             	cmp    $0xb,%eax
    3a9c:	0f 84 be 00 00 00    	je     3b60 <test1_idle_default_handler+0x130>
    3aa2:	83 f8 0c             	cmp    $0xc,%eax
    3aa5:	74 6d                	je     3b14 <test1_idle_default_handler+0xe4>
    3aa7:	83 f8 04             	cmp    $0x4,%eax
    3aaa:	74 4d                	je     3af9 <test1_idle_default_handler+0xc9>
    3aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		*/

		//
		default:
			ioctrl_handler();  	
    3ab0:	e8 2b f0 ff ff       	call   2ae0 <ioctrl_handler>
		break;
    3ab5:	eb bd                	jmp    3a74 <test1_idle_default_handler+0x44>
    3ab7:	90                   	nop
    3ab8:	90                   	nop
    3ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("MAC:idle_default_handler");
	if(MAC_CLOSE)
    3ac0:	e8 fc ff ff ff       	call   3ac1 <test1_idle_default_handler+0x91>
    3ac5:	83 f8 01             	cmp    $0x1,%eax
    3ac8:	75 92                	jne    3a5c <test1_idle_default_handler+0x2c>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3aca:	b8 27 02 00 00       	mov    $0x227,%eax
    3acf:	e8 fc ff ff ff       	call   3ad0 <test1_idle_default_handler+0xa0>
		ue_mac_sv_close();
    3ad4:	e8 77 ef ff ff       	call   2a50 <ue_mac_sv_close>
    3ad9:	eb 81                	jmp    3a5c <test1_idle_default_handler+0x2c>
    3adb:	90                   	nop
    3adc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("MAC:IDLE receive a data packet from PHYadapter"); //testing code
    3ae0:	b8 24 0e 00 00       	mov    $0xe24,%eax
    3ae5:	e8 fc ff ff ff       	call   3ae6 <test1_idle_default_handler+0xb6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3aea:	e8 fc ff ff ff       	call   3aeb <test1_idle_default_handler+0xbb>
    3aef:	e8 fc ff ff ff       	call   3af0 <test1_idle_default_handler+0xc0>
    3af4:	e9 71 ff ff ff       	jmp    3a6a <test1_idle_default_handler+0x3a>
				fsm_data_destroy(tmpdata_ptr);//
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("MAC:IDLE receive a cra order ");
    3af9:	b8 9d 02 00 00       	mov    $0x29d,%eax
    3afe:	e8 fc ff ff ff       	call   3aff <test1_idle_default_handler+0xcf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//		
    3b03:	ba 02 00 00 00       	mov    $0x2,%edx
    3b08:	31 c0                	xor    %eax,%eax
    3b0a:	e8 fc ff ff ff       	call   3b0b <test1_idle_default_handler+0xdb>
		break;
    3b0f:	e9 60 ff ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;

		//PHYRA
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				tmpdata_ptr = fsm_data_get();
    3b14:	e8 fc ff ff ff       	call   3b15 <test1_idle_default_handler+0xe5>
    3b19:	89 c6                	mov    %eax,%esi
				print_tran_info("IDLE receive a ncra order ");
    3b1b:	b8 76 02 00 00       	mov    $0x276,%eax
    3b20:	e8 fc ff ff ff       	call   3b21 <test1_idle_default_handler+0xf1>
				fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    3b25:	b9 02 00 00 00       	mov    $0x2,%ecx
    3b2a:	89 f2                	mov    %esi,%edx
    3b2c:	8d 43 04             	lea    0x4(%ebx),%eax
    3b2f:	e8 fc ff ff ff       	call   3b30 <test1_idle_default_handler+0x100>
				fsm_printf("RAPID: %d \n",SV(RA_info.ra_PreambleIndex));		
    3b34:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    3b38:	c7 04 24 91 02 00 00 	movl   $0x291,(%esp)
    3b3f:	89 44 24 04          	mov    %eax,0x4(%esp)
    3b43:	e8 fc ff ff ff       	call   3b44 <test1_idle_default_handler+0x114>
				if(tmpdata_ptr != NULL)
    3b48:	85 f6                	test   %esi,%esi
    3b4a:	0f 84 24 ff ff ff    	je     3a74 <test1_idle_default_handler+0x44>
				fsm_data_destroy(tmpdata_ptr);//
    3b50:	89 f0                	mov    %esi,%eax
    3b52:	e8 fc ff ff ff       	call   3b53 <test1_idle_default_handler+0x123>
    3b57:	e9 18 ff ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
    3b5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3b60:	e8 fc ff ff ff       	call   3b61 <test1_idle_default_handler+0x131>
    3b65:	89 c3                	mov    %eax,%ebx
			print_tran_info("MAC:IDLE receive a RLCdatareq");
    3b67:	b8 58 02 00 00       	mov    $0x258,%eax
    3b6c:	e8 fc ff ff ff       	call   3b6d <test1_idle_default_handler+0x13d>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3b71:	89 d8                	mov    %ebx,%eax
    3b73:	e8 fc ff ff ff       	call   3b74 <test1_idle_default_handler+0x144>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3b78:	ba 02 00 00 00       	mov    $0x2,%edx
    3b7d:	31 c0                	xor    %eax,%eax
    3b7f:	e8 fc ff ff ff       	call   3b80 <test1_idle_default_handler+0x150>
		break;
    3b84:	e9 eb fe ff ff       	jmp    3a74 <test1_idle_default_handler+0x44>
    3b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003b90 <test2_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test2_idle_default_handler()
{
    3b90:	55                   	push   %ebp
    3b91:	89 e5                	mov    %esp,%ebp
    3b93:	53                   	push   %ebx
    3b94:	e8 fc ff ff ff       	call   3b95 <test2_idle_default_handler+0x5>
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
    3b99:	e8 fc ff ff ff       	call   3b9a <test2_idle_default_handler+0xa>
	print_tran_info("idle_default_handler");
    3b9e:	b8 bb 02 00 00       	mov    $0x2bb,%eax
    3ba3:	e8 fc ff ff ff       	call   3ba4 <test2_idle_default_handler+0x14>
	if(MAC_CLOSE)
    3ba8:	e8 fc ff ff ff       	call   3ba9 <test2_idle_default_handler+0x19>
    3bad:	83 f8 05             	cmp    $0x5,%eax
    3bb0:	74 56                	je     3c08 <test2_idle_default_handler+0x78>
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3bb2:	e8 fc ff ff ff       	call   3bb3 <test2_idle_default_handler+0x23>
    3bb7:	83 f8 02             	cmp    $0x2,%eax
    3bba:	74 74                	je     3c30 <test2_idle_default_handler+0xa0>
    3bbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3bc0:	e8 fc ff ff ff       	call   3bc1 <test2_idle_default_handler+0x31>
    3bc5:	83 f8 05             	cmp    $0x5,%eax
    3bc8:	74 06                	je     3bd0 <test2_idle_default_handler+0x40>
			ioctrl_handler();
		break;
		}
	}
	FOUT;
}
    3bca:	5b                   	pop    %ebx
    3bcb:	5d                   	pop    %ebp
    3bcc:	c3                   	ret    
    3bcd:	8d 76 00             	lea    0x0(%esi),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3bd0:	e8 fc ff ff ff       	call   3bd1 <test2_idle_default_handler+0x41>
    3bd5:	83 f8 02             	cmp    $0x2,%eax
    3bd8:	75 f0                	jne    3bca <test2_idle_default_handler+0x3a>
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
    3bda:	b8 d0 02 00 00       	mov    $0x2d0,%eax
    3bdf:	e8 fc ff ff ff       	call   3be0 <test2_idle_default_handler+0x50>
		switch(fsm_ev_ioctrl_cmd())
    3be4:	e8 fc ff ff ff       	call   3be5 <test2_idle_default_handler+0x55>
    3be9:	83 f8 0b             	cmp    $0xb,%eax
    3bec:	0f 84 96 00 00 00    	je     3c88 <test2_idle_default_handler+0xf8>
    3bf2:	77 5c                	ja     3c50 <test2_idle_default_handler+0xc0>
    3bf4:	83 f8 04             	cmp    $0x4,%eax
    3bf7:	74 70                	je     3c69 <test2_idle_default_handler+0xd9>
    3bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
		break;
		//do_ioctl
		//
		default:
			ioctrl_handler();
    3c00:	e8 db ee ff ff       	call   2ae0 <ioctrl_handler>
		break;
    3c05:	eb c3                	jmp    3bca <test2_idle_default_handler+0x3a>
    3c07:	90                   	nop
    3c08:	90                   	nop
    3c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("idle_default_handler");
	if(MAC_CLOSE)
    3c10:	e8 fc ff ff ff       	call   3c11 <test2_idle_default_handler+0x81>
    3c15:	83 f8 01             	cmp    $0x1,%eax
    3c18:	75 98                	jne    3bb2 <test2_idle_default_handler+0x22>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3c1a:	b8 27 02 00 00       	mov    $0x227,%eax
    3c1f:	e8 fc ff ff ff       	call   3c20 <test2_idle_default_handler+0x90>
		ue_mac_sv_close();
    3c24:	e8 27 ee ff ff       	call   2a50 <ue_mac_sv_close>
    3c29:	eb 87                	jmp    3bb2 <test2_idle_default_handler+0x22>
    3c2b:	90                   	nop
    3c2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("IDLE receive a data packet from PHYadapter"); //testing code
    3c30:	b8 54 0e 00 00       	mov    $0xe54,%eax
    3c35:	e8 fc ff ff ff       	call   3c36 <test2_idle_default_handler+0xa6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3c3a:	e8 fc ff ff ff       	call   3c3b <test2_idle_default_handler+0xab>
    3c3f:	e8 fc ff ff ff       	call   3c40 <test2_idle_default_handler+0xb0>
    3c44:	e9 73 ff ff ff       	jmp    3bbc <test2_idle_default_handler+0x2c>
    3c49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
    3c50:	83 f8 0c             	cmp    $0xc,%eax
    3c53:	74 5c                	je     3cb1 <test2_idle_default_handler+0x121>
    3c55:	83 f8 31             	cmp    $0x31,%eax
    3c58:	75 9f                	jne    3bf9 <test2_idle_default_handler+0x69>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;
		//
		//PHYRA
		case NCRATEST:
				print_tran_info("IDLE receive a ncra test ");
    3c5a:	b8 04 03 00 00       	mov    $0x304,%eax
    3c5f:	e8 fc ff ff ff       	call   3c60 <test2_idle_default_handler+0xd0>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
    3c64:	e9 61 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>
				print_tran_info("IDLE receive a ncra order ");
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("IDLE receive a cra order ");
    3c69:	b8 1e 03 00 00       	mov    $0x31e,%eax
    3c6e:	e8 fc ff ff ff       	call   3c6f <test2_idle_default_handler+0xdf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    3c73:	ba 02 00 00 00       	mov    $0x2,%edx
    3c78:	31 c0                	xor    %eax,%eax
    3c7a:	e8 fc ff ff ff       	call   3c7b <test2_idle_default_handler+0xeb>
		break;
    3c7f:	e9 46 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>
    3c84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3c88:	e8 fc ff ff ff       	call   3c89 <test2_idle_default_handler+0xf9>
    3c8d:	89 c3                	mov    %eax,%ebx
			print_tran_info("IDLE receive a RLCdatareq");
    3c8f:	b8 ea 02 00 00       	mov    $0x2ea,%eax
    3c94:	e8 fc ff ff ff       	call   3c95 <test2_idle_default_handler+0x105>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3c99:	89 d8                	mov    %ebx,%eax
    3c9b:	e8 fc ff ff ff       	call   3c9c <test2_idle_default_handler+0x10c>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3ca0:	ba 02 00 00 00       	mov    $0x2,%edx
    3ca5:	31 c0                	xor    %eax,%eax
    3ca7:	e8 fc ff ff ff       	call   3ca8 <test2_idle_default_handler+0x118>
		break;
    3cac:	e9 19 ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				print_tran_info("IDLE receive a ncra order ");
    3cb1:	b8 76 02 00 00       	mov    $0x276,%eax
    3cb6:	e8 fc ff ff ff       	call   3cb7 <test2_idle_default_handler+0x127>
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
    3cbb:	e9 0a ff ff ff       	jmp    3bca <test2_idle_default_handler+0x3a>

00003cc0 <findInsByRbid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsByRbid(u8 rbid,void **up, void **down , RlcMode *mode)
{
    3cc0:	55                   	push   %ebp
    3cc1:	89 e5                	mov    %esp,%ebp
    3cc3:	57                   	push   %edi
    3cc4:	56                   	push   %esi
    3cc5:	53                   	push   %ebx
    3cc6:	83 ec 10             	sub    $0x10,%esp
    3cc9:	e8 fc ff ff ff       	call   3cca <findInsByRbid+0xa>
    3cce:	8b 75 08             	mov    0x8(%ebp),%esi
    3cd1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3cd4:	89 c3                	mov    %eax,%ebx
    3cd6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsByRbid());
	SV_PTR_GET(rlc_mac_sv);
    3cd9:	e8 fc ff ff ff       	call   3cda <findInsByRbid+0x1a>
	*up = *down = NULL;
    3cde:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3ce1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3ce4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    3cea:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    3cf0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    3cf6:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    3cfc:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    3d02:	39 d1                	cmp    %edx,%ecx
    3d04:	74 29                	je     3d2f <findInsByRbid+0x6f>
    3d06:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d09:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3d0c:	eb 08                	jmp    3d16 <findInsByRbid+0x56>
    3d0e:	66 90                	xchg   %ax,%ax
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3d10:	8b 12                	mov    (%edx),%edx
    3d12:	39 d1                	cmp    %edx,%ecx
    3d14:	74 16                	je     3d2c <findInsByRbid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->rbId == rbid)
    3d16:	38 5a e6             	cmp    %bl,-0x1a(%edx)
    3d19:	75 f5                	jne    3d10 <findInsByRbid+0x50>
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    3d1b:	8d 42 e4             	lea    -0x1c(%edx),%eax
    3d1e:	89 07                	mov    %eax,(%edi)
			if(tmTxIns->rbId == rbid)
			{
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
    3d20:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3d26:	8b 12                	mov    (%edx),%edx
    3d28:	39 d1                	cmp    %edx,%ecx
    3d2a:	75 ea                	jne    3d16 <findInsByRbid+0x56>
    3d2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3d2f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    3d35:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    3d3b:	39 d1                	cmp    %edx,%ecx
    3d3d:	74 28                	je     3d67 <findInsByRbid+0xa7>
    3d3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d42:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d45:	eb 07                	jmp    3d4e <findInsByRbid+0x8e>
    3d47:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3d48:	8b 12                	mov    (%edx),%edx
    3d4a:	39 d1                	cmp    %edx,%ecx
    3d4c:	74 16                	je     3d64 <findInsByRbid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->rbId == rbid)
    3d4e:	38 5a fa             	cmp    %bl,-0x6(%edx)
    3d51:	75 f5                	jne    3d48 <findInsByRbid+0x88>
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    3d53:	8d 42 f8             	lea    -0x8(%edx),%eax
    3d56:	89 07                	mov    %eax,(%edi)
			if(tmRxIns->rbId == rbid)
			{
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
    3d58:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3d5e:	8b 12                	mov    (%edx),%edx
    3d60:	39 d1                	cmp    %edx,%ecx
    3d62:	75 ea                	jne    3d4e <findInsByRbid+0x8e>
    3d64:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
			}
		}
	}
	if(*mode == TM_MODE)
    3d67:	83 3e 01             	cmpl   $0x1,(%esi)
    3d6a:	0f 84 c8 00 00 00    	je     3e38 <findInsByRbid+0x178>
    3d70:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    3d76:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    3d7c:	39 d1                	cmp    %edx,%ecx
    3d7e:	74 27                	je     3da7 <findInsByRbid+0xe7>
    3d80:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d83:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3d86:	eb 06                	jmp    3d8e <findInsByRbid+0xce>
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3d88:	8b 12                	mov    (%edx),%edx
    3d8a:	39 d1                	cmp    %edx,%ecx
    3d8c:	74 16                	je     3da4 <findInsByRbid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->rbid == rbid)
    3d8e:	38 5a d2             	cmp    %bl,-0x2e(%edx)
    3d91:	75 f5                	jne    3d88 <findInsByRbid+0xc8>
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    3d93:	8d 42 d0             	lea    -0x30(%edx),%eax
    3d96:	89 07                	mov    %eax,(%edi)
			if(umTxIns->rbid == rbid)
			{
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
    3d98:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3d9e:	8b 12                	mov    (%edx),%edx
    3da0:	39 d1                	cmp    %edx,%ecx
    3da2:	75 ea                	jne    3d8e <findInsByRbid+0xce>
    3da4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3da7:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    3dad:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    3db3:	39 d1                	cmp    %edx,%ecx
    3db5:	74 2e                	je     3de5 <findInsByRbid+0x125>
    3db7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3dba:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3dbd:	eb 07                	jmp    3dc6 <findInsByRbid+0x106>
    3dbf:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3dc0:	8b 12                	mov    (%edx),%edx
    3dc2:	39 d1                	cmp    %edx,%ecx
    3dc4:	74 1c                	je     3de2 <findInsByRbid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->rbId == rbid)
    3dc6:	38 9a 3e ef ff ff    	cmp    %bl,-0x10c2(%edx)
    3dcc:	75 f2                	jne    3dc0 <findInsByRbid+0x100>
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    3dce:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
    3dd4:	89 07                	mov    %eax,(%edi)
			if(umRxIns->rbId == rbid)
			{
				*down = (void*)umRxIns;
				*mode = UM_MODE;
    3dd6:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3ddc:	8b 12                	mov    (%edx),%edx
    3dde:	39 d1                	cmp    %edx,%ecx
    3de0:	75 e4                	jne    3dc6 <findInsByRbid+0x106>
    3de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)umRxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(*mode == UM_MODE)
    3de5:	83 3e 02             	cmpl   $0x2,(%esi)
    3de8:	74 4e                	je     3e38 <findInsByRbid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    3dea:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    3df0:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    3df6:	39 c2                	cmp    %eax,%edx
    3df8:	74 3e                	je     3e38 <findInsByRbid+0x178>
    3dfa:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3dfd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    3e00:	eb 0c                	jmp    3e0e <findInsByRbid+0x14e>
    3e02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3e08:	8b 00                	mov    (%eax),%eax
    3e0a:	39 c2                	cmp    %eax,%edx
    3e0c:	74 2a                	je     3e38 <findInsByRbid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->rbId == rbid)
    3e0e:	38 98 fe dc ff ff    	cmp    %bl,-0x2302(%eax)
    3e14:	75 f2                	jne    3e08 <findInsByRbid+0x148>
			{
				*mode = AM_MODE;
    3e16:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    3e19:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->rbId == rbid)
			{
				*mode = AM_MODE;
    3e1f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    3e25:	8b 75 ec             	mov    -0x14(%ebp),%esi
    3e28:	89 0f                	mov    %ecx,(%edi)
    3e2a:	89 0e                	mov    %ecx,(%esi)
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3e2c:	8b 00                	mov    (%eax),%eax
    3e2e:	39 c2                	cmp    %eax,%edx
    3e30:	75 dc                	jne    3e0e <findInsByRbid+0x14e>
    3e32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				*up = *down =  (void*)amIns;
			}
		}
	}
	FOUT;
}
    3e38:	83 c4 10             	add    $0x10,%esp
    3e3b:	5b                   	pop    %ebx
    3e3c:	5e                   	pop    %esi
    3e3d:	5f                   	pop    %edi
    3e3e:	5d                   	pop    %ebp
    3e3f:	c3                   	ret    

00003e40 <rlc_mac_main>:
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
    3e40:	55                   	push   %ebp
    3e41:	89 e5                	mov    %esp,%ebp
    3e43:	83 ec 3c             	sub    $0x3c,%esp
    3e46:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3e49:	89 75 f8             	mov    %esi,-0x8(%ebp)
    3e4c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    3e4f:	e8 fc ff ff ff       	call   3e50 <rlc_mac_main+0x10>
	FSM_ENTER(rlc_mac_main);
    3e54:	e8 fc ff ff ff       	call   3e55 <rlc_mac_main+0x15>
	FSM_BLOCK_SWITCH
    3e59:	83 38 19             	cmpl   $0x19,(%eax)
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
    3e5c:	89 c6                	mov    %eax,%esi
	FSM_BLOCK_SWITCH
    3e5e:	76 18                	jbe    3e78 <rlc_mac_main+0x38>
		FSM_STATE_FORCED(ST_NULL_IDLE, "NULL_IDLE", , )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
    3e60:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
    3e66:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    3e69:	8b 75 f8             	mov    -0x8(%ebp),%esi
    3e6c:	8b 7d fc             	mov    -0x4(%ebp),%edi
    3e6f:	89 ec                	mov    %ebp,%esp
    3e71:	5d                   	pop    %ebp
    3e72:	c3                   	ret    
    3e73:	90                   	nop
    3e74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
    3e78:	8b 00                	mov    (%eax),%eax
    3e7a:	ff 24 85 00 03 00 00 	jmp    *0x300(,%eax,4)
    3e81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    3e88:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    3e8f:	03 00 00 
		{
			FSM_COND_TEST_IN("IDLE")				
    3e92:	31 db                	xor    %ebx,%ebx
    3e94:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    3e99:	e8 fc ff ff ff       	call   3e9a <rlc_mac_main+0x5a>
    3e9e:	83 f8 03             	cmp    $0x3,%eax
    3ea1:	0f 84 a4 0f 00 00    	je     4e4b <rlc_mac_main+0x100b>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    3ea7:	e8 fc ff ff ff       	call   3ea8 <rlc_mac_main+0x68>
    3eac:	83 f8 03             	cmp    $0x3,%eax
    3eaf:	90                   	nop
    3eb0:	0f 84 7a 0f 00 00    	je     4e30 <rlc_mac_main+0xff0>
				FSM_TEST_COND(MAC_RESET)
    3eb6:	e8 fc ff ff ff       	call   3eb7 <rlc_mac_main+0x77>
    3ebb:	83 f8 05             	cmp    $0x5,%eax
    3ebe:	66 90                	xchg   %ax,%ax
    3ec0:	0f 84 3d 0f 00 00    	je     4e03 <rlc_mac_main+0xfc3>
				
				FSM_TEST_COND(RLC_SUSPEND)
    3ec6:	e8 fc ff ff ff       	call   3ec7 <rlc_mac_main+0x87>
    3ecb:	83 f8 03             	cmp    $0x3,%eax
    3ece:	66 90                	xchg   %ax,%ax
    3ed0:	0f 84 12 0f 00 00    	je     4de8 <rlc_mac_main+0xfa8>
				FSM_TEST_COND(RLC_DEACT)
    3ed6:	e8 fc ff ff ff       	call   3ed7 <rlc_mac_main+0x97>
    3edb:	83 f8 03             	cmp    $0x3,%eax
    3ede:	66 90                	xchg   %ax,%ax
    3ee0:	0f 84 89 0e 00 00    	je     4d6f <rlc_mac_main+0xf2f>
				FSM_TEST_COND(RLC_RESUME)
    3ee6:	e8 fc ff ff ff       	call   3ee7 <rlc_mac_main+0xa7>
    3eeb:	83 f8 03             	cmp    $0x3,%eax
    3eee:	66 90                	xchg   %ax,%ax
    3ef0:	0f 84 5e 0e 00 00    	je     4d54 <rlc_mac_main+0xf14>
			FSM_COND_TEST_OUT("IDLE")
    3ef6:	83 fb 01             	cmp    $0x1,%ebx
    3ef9:	0f 8e 01 08 00 00    	jle    4700 <rlc_mac_main+0x8c0>
    3eff:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    3f06:	00 
    3f07:	c7 44 24 04 4f 03 00 	movl   $0x34f,0x4(%esp)
    3f0e:	00 
    3f0f:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    3f16:	e8 fc ff ff ff       	call   3f17 <rlc_mac_main+0xd7>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    3f1b:	c7 05 30 00 00 00 86 	movl   $0x386,0x30
    3f22:	03 00 00 
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    3f25:	e8 fc ff ff ff       	call   3f26 <rlc_mac_main+0xe6>
    3f2a:	89 c7                	mov    %eax,%edi
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code
    3f2c:	b8 dc 0e 00 00       	mov    $0xedc,%eax
    3f31:	e8 fc ff ff ff       	call   3f32 <rlc_mac_main+0xf2>

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    3f36:	e8 fc ff ff ff       	call   3f37 <rlc_mac_main+0xf7>
    3f3b:	83 f8 05             	cmp    $0x5,%eax
    3f3e:	0f 84 96 13 00 00    	je     52da <rlc_mac_main+0x149a>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    3f44:	e8 fc ff ff ff       	call   3f45 <rlc_mac_main+0x105>
    3f49:	83 f8 05             	cmp    $0x5,%eax
    3f4c:	0f 84 49 14 00 00    	je     539b <rlc_mac_main+0x155b>
	{
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    3f52:	e8 fc ff ff ff       	call   3f53 <rlc_mac_main+0x113>
    3f57:	83 f8 02             	cmp    $0x2,%eax
    3f5a:	0f 84 02 14 00 00    	je     5362 <rlc_mac_main+0x1522>
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    3f60:	e8 fc ff ff ff       	call   3f61 <rlc_mac_main+0x121>
    3f65:	83 f8 01             	cmp    $0x1,%eax
    3f68:	0f 84 bf 15 00 00    	je     552d <rlc_mac_main+0x16ed>
    3f6e:	66 90                	xchg   %ax,%ax
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    3f70:	e8 fc ff ff ff       	call   3f71 <rlc_mac_main+0x131>
    3f75:	83 f8 03             	cmp    $0x3,%eax
    3f78:	0f 84 30 17 00 00    	je     56ae <rlc_mac_main+0x186e>
    3f7e:	66 90                	xchg   %ax,%ax
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    3f80:	e8 fc ff ff ff       	call   3f81 <rlc_mac_main+0x141>
    3f85:	83 f8 03             	cmp    $0x3,%eax
    3f88:	0f 84 b6 17 00 00    	je     5744 <rlc_mac_main+0x1904>
    3f8e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
    3f90:	e8 fc ff ff ff       	call   3f91 <rlc_mac_main+0x151>
    3f95:	83 f8 03             	cmp    $0x3,%eax
    3f98:	0f 84 65 17 00 00    	je     5703 <rlc_mac_main+0x18c3>
    3f9e:	66 90                	xchg   %ax,%ax
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    3fa0:	e8 fc ff ff ff       	call   3fa1 <rlc_mac_main+0x161>
    3fa5:	83 f8 05             	cmp    $0x5,%eax
    3fa8:	0f 85 6b 1f 00 00    	jne    5f19 <rlc_mac_main+0x20d9>
    3fae:	66 90                	xchg   %ax,%ax
    3fb0:	e8 fc ff ff ff       	call   3fb1 <rlc_mac_main+0x171>
    3fb5:	83 f8 02             	cmp    $0x2,%eax
    3fb8:	0f 85 5b 1f 00 00    	jne    5f19 <rlc_mac_main+0x20d9>
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
    3fbe:	b8 e4 10 00 00       	mov    $0x10e4,%eax
    3fc3:	e8 fc ff ff ff       	call   3fc4 <rlc_mac_main+0x184>
		u32 cmd1=fsm_ev_ioctrl_cmd();
    3fc8:	e8 fc ff ff ff       	call   3fc9 <rlc_mac_main+0x189>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
    3fcd:	89 44 24 04          	mov    %eax,0x4(%esp)
    3fd1:	c7 04 24 91 03 00 00 	movl   $0x391,(%esp)
    3fd8:	e8 fc ff ff ff       	call   3fd9 <rlc_mac_main+0x199>
		switch(fsm_ev_ioctrl_cmd())
    3fdd:	e8 fc ff ff ff       	call   3fde <rlc_mac_main+0x19e>
    3fe2:	83 f8 0b             	cmp    $0xb,%eax
    3fe5:	0f 84 32 1a 00 00    	je     5a1d <rlc_mac_main+0x1bdd>
    3feb:	90                   	nop
    3fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    3ff0:	0f 87 79 17 00 00    	ja     576f <rlc_mac_main+0x192f>
    3ff6:	83 f8 04             	cmp    $0x4,%eax
    3ff9:	0f 84 9e 1a 00 00    	je     5a9d <rlc_mac_main+0x1c5d>
    3fff:	90                   	nop
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
				fsm_data_destroy(tmpdata_ptr);
			break;
			default:
				ioctrl_handler();
    4000:	e8 db ea ff ff       	call   2ae0 <ioctrl_handler>
			break;
		}
		reports_handler();//BSR PHR 
    4005:	e8 b6 f1 ff ff       	call   31c0 <reports_handler>
    400a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    4010:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4016:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4019:	8b 75 f8             	mov    -0x8(%ebp),%esi
    401c:	8b 7d fc             	mov    -0x4(%ebp),%edi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    401f:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    4026:	03 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4029:	89 ec                	mov    %ebp,%esp
    402b:	5d                   	pop    %ebp
    402c:	c3                   	ret    
    402d:	8b 75 dc             	mov    -0x24(%ebp),%esi
			do_bsr_and_resource_alloc();	//this function should in while loop or not? this a question
		}
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
    4030:	e8 fc ff ff ff       	call   4031 <rlc_mac_main+0x1f1>
    4035:	83 f8 02             	cmp    $0x2,%eax
    4038:	0f 84 3d 1f 00 00    	je     5f7b <rlc_mac_main+0x213b>
		}
		decomplexUeDataPdu(skb);
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    403e:	e8 fc ff ff ff       	call   403f <rlc_mac_main+0x1ff>
    4043:	83 f8 01             	cmp    $0x1,%eax
    4046:	0f 84 69 13 00 00    	je     53b5 <rlc_mac_main+0x1575>
    404c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4050:	e8 fc ff ff ff       	call   4051 <rlc_mac_main+0x211>
    4055:	83 f8 03             	cmp    $0x3,%eax
    4058:	0f 84 a7 15 00 00    	je     5605 <rlc_mac_main+0x17c5>
    405e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
    4060:	e8 fc ff ff ff       	call   4061 <rlc_mac_main+0x221>
    4065:	83 f8 03             	cmp    $0x3,%eax
    4068:	0f 84 4e 15 00 00    	je     55bc <rlc_mac_main+0x177c>
    406e:	66 90                	xchg   %ax,%ax
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
	}
	else if(IOCTRL_ARRIVAL)
    4070:	e8 fc ff ff ff       	call   4071 <rlc_mac_main+0x231>
    4075:	83 f8 05             	cmp    $0x5,%eax
    4078:	0f 85 c8 1f 00 00    	jne    6046 <rlc_mac_main+0x2206>
    407e:	66 90                	xchg   %ax,%ax
    4080:	e8 fc ff ff ff       	call   4081 <rlc_mac_main+0x241>
    4085:	83 f8 02             	cmp    $0x2,%eax
    4088:	0f 85 b8 1f 00 00    	jne    6046 <rlc_mac_main+0x2206>
    408e:	66 90                	xchg   %ax,%ax
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
    4090:	e8 fc ff ff ff       	call   4091 <rlc_mac_main+0x251>
    4095:	83 f8 0b             	cmp    $0xb,%eax
    4098:	0f 84 06 17 00 00    	je     57a4 <rlc_mac_main+0x1964>
    409e:	66 90                	xchg   %ax,%ax
			//RLCdatareqMAC reqregularBSR 
			//SR RLCreq
			//MACSR  
		}
		else 
			ioctrl_handler();  //ioctrl		
    40a0:	e8 3b ea ff ff       	call   2ae0 <ioctrl_handler>
		//print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
    40a5:	e8 16 f1 ff ff       	call   31c0 <reports_handler>
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
	}
	//fsm_printf("[RLC_MAC][con_default_handler][end]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	fsm_mem_free(pdu_type);
    40aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    40ad:	e8 fc ff ff ff       	call   40ae <rlc_mac_main+0x26e>
    40b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    40b8:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    40be:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    40c1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    40c4:	8b 7d fc             	mov    -0x4(%ebp),%edi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    40c7:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    40ce:	04 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    40d1:	89 ec                	mov    %ebp,%esp
    40d3:	5d                   	pop    %ebp
    40d4:	c3                   	ret    
    40d5:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    40d8:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    40df:	03 00 00 
		{
			FSM_COND_TEST_IN("CRA")
    40e2:	31 db                	xor    %ebx,%ebx
    40e4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    40e9:	e8 fc ff ff ff       	call   40ea <rlc_mac_main+0x2aa>
    40ee:	83 f8 03             	cmp    $0x3,%eax
    40f1:	0f 84 ca 0b 00 00    	je     4cc1 <rlc_mac_main+0xe81>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    40f7:	e8 fc ff ff ff       	call   40f8 <rlc_mac_main+0x2b8>
    40fc:	83 f8 03             	cmp    $0x3,%eax
    40ff:	90                   	nop
    4100:	0f 84 4a 0a 00 00    	je     4b50 <rlc_mac_main+0xd10>
    4106:	e8 fc ff ff ff       	call   4107 <rlc_mac_main+0x2c7>
    410b:	83 f8 03             	cmp    $0x3,%eax
    410e:	66 90                	xchg   %ax,%ax
    4110:	0f 84 7a 0a 00 00    	je     4b90 <rlc_mac_main+0xd50>
    4116:	e8 fc ff ff ff       	call   4117 <rlc_mac_main+0x2d7>
    411b:	83 f8 05             	cmp    $0x5,%eax
    411e:	66 90                	xchg   %ax,%ax
    4120:	0f 84 12 0f 00 00    	je     5038 <rlc_mac_main+0x11f8>
				FSM_TEST_COND(RARREV_SUCCESS)
    4126:	e8 fc ff ff ff       	call   4127 <rlc_mac_main+0x2e7>
    412b:	83 f8 03             	cmp    $0x3,%eax
    412e:	66 90                	xchg   %ax,%ax
    4130:	0f 84 fa 09 00 00    	je     4b30 <rlc_mac_main+0xcf0>
    4136:	e8 fc ff ff ff       	call   4137 <rlc_mac_main+0x2f7>
    413b:	83 f8 05             	cmp    $0x5,%eax
    413e:	66 90                	xchg   %ax,%ax
    4140:	0f 84 92 0d 00 00    	je     4ed8 <rlc_mac_main+0x1098>
				FSM_TEST_COND(CONTENTION_FAIL)
    4146:	e8 fc ff ff ff       	call   4147 <rlc_mac_main+0x307>
    414b:	83 f8 03             	cmp    $0x3,%eax
    414e:	66 90                	xchg   %ax,%ax
    4150:	0f 84 ba 09 00 00    	je     4b10 <rlc_mac_main+0xcd0>
    4156:	e8 fc ff ff ff       	call   4157 <rlc_mac_main+0x317>
    415b:	83 f8 03             	cmp    $0x3,%eax
    415e:	66 90                	xchg   %ax,%ax
    4160:	0f 84 62 0a 00 00    	je     4bc8 <rlc_mac_main+0xd88>
    4166:	e8 fc ff ff ff       	call   4167 <rlc_mac_main+0x327>
    416b:	83 f8 05             	cmp    $0x5,%eax
    416e:	66 90                	xchg   %ax,%ax
    4170:	0f 84 a0 0e 00 00    	je     5016 <rlc_mac_main+0x11d6>
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4176:	e8 fc ff ff ff       	call   4177 <rlc_mac_main+0x337>
    417b:	83 f8 03             	cmp    $0x3,%eax
    417e:	66 90                	xchg   %ax,%ax
    4180:	0f 84 6a 09 00 00    	je     4af0 <rlc_mac_main+0xcb0>
    4186:	e8 fc ff ff ff       	call   4187 <rlc_mac_main+0x347>
    418b:	83 f8 05             	cmp    $0x5,%eax
    418e:	66 90                	xchg   %ax,%ax
    4190:	0f 84 1d 0d 00 00    	je     4eb3 <rlc_mac_main+0x1073>
				FSM_TEST_COND(MAC_RESET)
    4196:	e8 fc ff ff ff       	call   4197 <rlc_mac_main+0x357>
    419b:	83 f8 05             	cmp    $0x5,%eax
    419e:	66 90                	xchg   %ax,%ax
    41a0:	0f 84 12 0c 00 00    	je     4db8 <rlc_mac_main+0xf78>
			FSM_COND_TEST_OUT("CRA")
    41a6:	83 fb 01             	cmp    $0x1,%ebx
    41a9:	0f 8e 09 06 00 00    	jle    47b8 <rlc_mac_main+0x978>
    41af:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    41b6:	00 
    41b7:	c7 44 24 04 a7 03 00 	movl   $0x3a7,0x4(%esp)
    41be:	00 
    41bf:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    41c6:	e8 fc ff ff ff       	call   41c7 <rlc_mac_main+0x387>
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
				FSM_CASE_DEFAULT(ST_CRA,cra_default_handler() , "CRA->CRA")	//transit to CRA state	by default.
    41cb:	c7 05 30 00 00 00 cd 	movl   $0x3cd,0x30
    41d2:	03 00 00 
{
	void *tmpdata_ptr;
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    41d5:	e8 fc ff ff ff       	call   41d6 <rlc_mac_main+0x396>
    41da:	89 c3                	mov    %eax,%ebx

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    41dc:	b8 01 00 00 00       	mov    $0x1,%eax
    41e1:	e8 fc ff ff ff       	call   41e2 <rlc_mac_main+0x3a2>
	fsm_mem_set(pdu_type,0,sizeof(char));
    41e6:	31 d2                	xor    %edx,%edx
    41e8:	b9 01 00 00 00       	mov    $0x1,%ecx
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    41ed:	89 c7                	mov    %eax,%edi
	fsm_mem_set(pdu_type,0,sizeof(char));
    41ef:	e8 fc ff ff ff       	call   41f0 <rlc_mac_main+0x3b0>

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    41f4:	83 bb ec 01 00 00 01 	cmpl   $0x1,0x1ec(%ebx)
    41fb:	0f 84 fb 10 00 00    	je     52fc <rlc_mac_main+0x14bc>
		fsm_schedule_self(0, Contention_Success );//TEST  
	if(MAC_CLOSE)
    4201:	e8 fc ff ff ff       	call   4202 <rlc_mac_main+0x3c2>
    4206:	83 f8 05             	cmp    $0x5,%eax
    4209:	0f 84 08 11 00 00    	je     5317 <rlc_mac_main+0x14d7>
    420f:	90                   	nop
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    4210:	e8 fc ff ff ff       	call   4211 <rlc_mac_main+0x3d1>
    4215:	83 f8 02             	cmp    $0x2,%eax
    4218:	0f 84 e8 1e 00 00    	je     6106 <rlc_mac_main+0x22c6>
    421e:	66 90                	xchg   %ax,%ax
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_pkt_destroy(fsm_pkt_get());
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
    4220:	e8 fc ff ff ff       	call   4221 <rlc_mac_main+0x3e1>
    4225:	83 f8 01             	cmp    $0x1,%eax
    4228:	0f 84 6a 12 00 00    	je     5498 <rlc_mac_main+0x1658>
    422e:	66 90                	xchg   %ax,%ax
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4230:	e8 fc ff ff ff       	call   4231 <rlc_mac_main+0x3f1>
    4235:	83 f8 03             	cmp    $0x3,%eax
    4238:	0f 84 2e 12 00 00    	je     546c <rlc_mac_main+0x162c>
    423e:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    4240:	e8 fc ff ff ff       	call   4241 <rlc_mac_main+0x401>
    4245:	83 f8 05             	cmp    $0x5,%eax
    4248:	75 1e                	jne    4268 <rlc_mac_main+0x428>
    424a:	e8 fc ff ff ff       	call   424b <rlc_mac_main+0x40b>
    424f:	83 f8 02             	cmp    $0x2,%eax
    4252:	75 14                	jne    4268 <rlc_mac_main+0x428>
	{
		switch(fsm_ev_ioctrl_cmd())
    4254:	e8 fc ff ff ff       	call   4255 <rlc_mac_main+0x415>
    4259:	83 f8 0b             	cmp    $0xb,%eax
    425c:	0f 84 6f 1c 00 00    	je     5ed1 <rlc_mac_main+0x2091>
					tmpdata_ptr = (char *)fsm_data_get();
					fsm_data_destroy((void *)tmpdata_ptr);//
				}				
			break;
			default:
				ioctrl_handler();//ioctrl
    4262:	e8 79 e8 ff ff       	call   2ae0 <ioctrl_handler>
    4267:	90                   	nop
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    4268:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    426f:	03 00 00 
    4272:	c7 06 05 00 00 00    	movl   $0x5,(%esi)
    4278:	e9 e9 fb ff ff       	jmp    3e66 <rlc_mac_main+0x26>
    427d:	8d 76 00             	lea    0x0(%esi),%esi
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    4280:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    4287:	03 00 00 
		{
			FSM_COND_TEST_IN("NCRA")
    428a:	31 db                	xor    %ebx,%ebx
    428c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4291:	e8 fc ff ff ff       	call   4292 <rlc_mac_main+0x452>
    4296:	83 f8 03             	cmp    $0x3,%eax
    4299:	0f 84 c5 0b 00 00    	je     4e64 <rlc_mac_main+0x1024>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    429f:	e8 fc ff ff ff       	call   42a0 <rlc_mac_main+0x460>
    42a4:	83 f8 03             	cmp    $0x3,%eax
    42a7:	0f 84 c3 08 00 00    	je     4b70 <rlc_mac_main+0xd30>
    42ad:	8d 76 00             	lea    0x0(%esi),%esi
    42b0:	e8 fc ff ff ff       	call   42b1 <rlc_mac_main+0x471>
    42b5:	83 f8 03             	cmp    $0x3,%eax
    42b8:	0f 84 ea 08 00 00    	je     4ba8 <rlc_mac_main+0xd68>
    42be:	66 90                	xchg   %ax,%ax
    42c0:	e8 fc ff ff ff       	call   42c1 <rlc_mac_main+0x481>
    42c5:	83 f8 05             	cmp    $0x5,%eax
    42c8:	0f 84 9a 0d 00 00    	je     5068 <rlc_mac_main+0x1228>
    42ce:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RARREV_SUCCESS)
    42d0:	e8 fc ff ff ff       	call   42d1 <rlc_mac_main+0x491>
    42d5:	83 f8 03             	cmp    $0x3,%eax
    42d8:	0f 84 f2 07 00 00    	je     4ad0 <rlc_mac_main+0xc90>
    42de:	66 90                	xchg   %ax,%ax
    42e0:	e8 fc ff ff ff       	call   42e1 <rlc_mac_main+0x4a1>
    42e5:	83 f8 05             	cmp    $0x5,%eax
    42e8:	0f 84 1a 0c 00 00    	je     4f08 <rlc_mac_main+0x10c8>
    42ee:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(MAC_RESET)
    42f0:	e8 fc ff ff ff       	call   42f1 <rlc_mac_main+0x4b1>
    42f5:	83 f8 05             	cmp    $0x5,%eax
    42f8:	0f 84 8c 0a 00 00    	je     4d8a <rlc_mac_main+0xf4a>
			FSM_COND_TEST_OUT("NCRA")
    42fe:	83 fb 01             	cmp    $0x1,%ebx
    4301:	0f 8e 81 07 00 00    	jle    4a88 <rlc_mac_main+0xc48>
    4307:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    430e:	00 
    430f:	c7 44 24 04 d6 03 00 	movl   $0x3d6,0x4(%esp)
    4316:	00 
    4317:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    431e:	e8 fc ff ff ff       	call   431f <rlc_mac_main+0x4df>
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4323:	b8 f8 17 00 00       	mov    $0x17f8,%eax
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
    4328:	c7 05 30 00 00 00 f4 	movl   $0x3f4,0x30
    432f:	03 00 00 
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4332:	e8 fc ff ff ff       	call   4333 <rlc_mac_main+0x4f3>
	if(MAC_CLOSE)
    4337:	e8 fc ff ff ff       	call   4338 <rlc_mac_main+0x4f8>
    433c:	83 f8 05             	cmp    $0x5,%eax
    433f:	0f 84 25 13 00 00    	je     566a <rlc_mac_main+0x182a>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    4345:	e8 fc ff ff ff       	call   4346 <rlc_mac_main+0x506>
    434a:	83 f8 02             	cmp    $0x2,%eax
    434d:	0f 84 06 13 00 00    	je     5659 <rlc_mac_main+0x1819>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4353:	e8 fc ff ff ff       	call   4354 <rlc_mac_main+0x514>
    4358:	83 f8 03             	cmp    $0x3,%eax
    435b:	0f 84 ce 12 00 00    	je     562f <rlc_mac_main+0x17ef>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
	}
	if(IOCTRL_ARRIVAL)
    4361:	e8 fc ff ff ff       	call   4362 <rlc_mac_main+0x522>
    4366:	83 f8 05             	cmp    $0x5,%eax
    4369:	75 15                	jne    4380 <rlc_mac_main+0x540>
    436b:	90                   	nop
    436c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4370:	e8 fc ff ff ff       	call   4371 <rlc_mac_main+0x531>
    4375:	83 f8 02             	cmp    $0x2,%eax
    4378:	75 06                	jne    4380 <rlc_mac_main+0x540>
		ioctrl_handler();//ioctrl
    437a:	e8 61 e7 ff ff       	call   2ae0 <ioctrl_handler>
    437f:	90                   	nop
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    4380:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    4387:	03 00 00 
    438a:	c7 06 07 00 00 00    	movl   $0x7,(%esi)
    4390:	e9 d1 fa ff ff       	jmp    3e66 <rlc_mac_main+0x26>
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
    4395:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
		}
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
    439b:	c7 05 30 00 00 00 3d 	movl   $0x33d,0x30
    43a2:	03 00 00 
    43a5:	e8 76 e3 ff ff       	call   2720 <rlc_init_enter>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
    43aa:	e9 61 fc ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    43af:	90                   	nop
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    43b0:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    43b7:	04 00 00 
		{
			FSM_COND_TEST_IN("CON")
    43ba:	31 db                	xor    %ebx,%ebx
    43bc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    43c1:	e8 fc ff ff ff       	call   43c2 <rlc_mac_main+0x582>
    43c6:	83 f8 03             	cmp    $0x3,%eax
    43c9:	0f 84 6c 09 00 00    	je     4d3b <rlc_mac_main+0xefb>
				FSM_TEST_COND(SR_FAIL)
    43cf:	e8 fc ff ff ff       	call   43d0 <rlc_mac_main+0x590>
    43d4:	83 f8 03             	cmp    $0x3,%eax
    43d7:	0f 84 43 09 00 00    	je     4d20 <rlc_mac_main+0xee0>
    43dd:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_TEST_COND(MAC_RESET)
    43e0:	e8 fc ff ff ff       	call   43e1 <rlc_mac_main+0x5a1>
    43e5:	83 f8 05             	cmp    $0x5,%eax
    43e8:	0f 84 07 09 00 00    	je     4cf5 <rlc_mac_main+0xeb5>
    43ee:	66 90                	xchg   %ax,%ax

				FSM_TEST_COND(RLC_SUSPEND)
    43f0:	e8 fc ff ff ff       	call   43f1 <rlc_mac_main+0x5b1>
    43f5:	83 f8 03             	cmp    $0x3,%eax
    43f8:	0f 84 9a 0a 00 00    	je     4e98 <rlc_mac_main+0x1058>
    43fe:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_DEACT)
    4400:	e8 fc ff ff ff       	call   4401 <rlc_mac_main+0x5c1>
    4405:	83 f8 03             	cmp    $0x3,%eax
    4408:	0f 84 6f 0a 00 00    	je     4e7d <rlc_mac_main+0x103d>
    440e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_RESUME)
    4410:	e8 fc ff ff ff       	call   4411 <rlc_mac_main+0x5d1>
    4415:	83 f8 03             	cmp    $0x3,%eax
    4418:	0f 84 bc 08 00 00    	je     4cda <rlc_mac_main+0xe9a>
			FSM_COND_TEST_OUT("CON")
    441e:	83 fb 01             	cmp    $0x1,%ebx
    4421:	0f 8e 79 02 00 00    	jle    46a0 <rlc_mac_main+0x860>
    4427:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    442e:	00 
    442f:	c7 44 24 04 01 04 00 	movl   $0x401,0x4(%esp)
    4436:	00 
    4437:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    443e:	e8 fc ff ff ff       	call   443f <rlc_mac_main+0x5ff>
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    4443:	b8 01 00 00 00       	mov    $0x1,%eax
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_CON,con_default_handler() , "CON -> CON")	//transit to CON state	by default.
    4448:	c7 05 30 00 00 00 1c 	movl   $0x41c,0x30
    444f:	04 00 00 
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    4452:	e8 fc ff ff ff       	call   4453 <rlc_mac_main+0x613>
	fsm_mem_set(pdu_type,0,sizeof(char));
    4457:	31 d2                	xor    %edx,%edx
    4459:	b9 01 00 00 00       	mov    $0x1,%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    445e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_mem_set(pdu_type,0,sizeof(char));
    4461:	e8 fc ff ff ff       	call   4462 <rlc_mac_main+0x622>

	FIN(con_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4466:	e8 fc ff ff ff       	call   4467 <rlc_mac_main+0x627>
    446b:	89 c7                	mov    %eax,%edi

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    446d:	e8 fc ff ff ff       	call   446e <rlc_mac_main+0x62e>
    4472:	83 f8 05             	cmp    $0x5,%eax
    4475:	0f 84 bf 0e 00 00    	je     533a <rlc_mac_main+0x14fa>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    447b:	e8 fc ff ff ff       	call   447c <rlc_mac_main+0x63c>
    4480:	83 f8 05             	cmp    $0x5,%eax
    4483:	0f 84 80 13 00 00    	je     5809 <rlc_mac_main+0x19c9>
		rlc_close();
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
		FOUT;
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
    4489:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4490:	74 0a                	je     449c <rlc_mac_main+0x65c>
    4492:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    4496:	0f 85 29 12 00 00    	jne    56c5 <rlc_mac_main+0x1885>
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
    449c:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    44a2:	66 83 7a 08 00       	cmpw   $0x0,0x8(%edx)
    44a7:	0f 84 83 fb ff ff    	je     4030 <rlc_mac_main+0x1f0>
	fsm_octets_print(skb->data,64);
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    44ad:	89 75 dc             	mov    %esi,-0x24(%ebp)
    44b0:	e9 c7 00 00 00       	jmp    457c <rlc_mac_main+0x73c>
    44b5:	8d 76 00             	lea    0x0(%esi),%esi
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
    44b8:	83 f8 03             	cmp    $0x3,%eax
    44bb:	0f 84 ba 0a 00 00    	je     4f7b <rlc_mac_main+0x113b>
    44c1:	83 f8 01             	cmp    $0x1,%eax
    44c4:	0f 84 6e 0a 00 00    	je     4f38 <rlc_mac_main+0x10f8>
			tmTxIns->tmSduBufferSize += skb->len;
			
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    44ca:	83 86 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%esi)
			printk("[RLC][skb_from_cra_to_con] cannot distinfuish this %d\n", SV(ins_mode));
    44d1:	89 44 24 04          	mov    %eax,0x4(%esp)
    44d5:	c7 04 24 c0 1a 00 00 	movl   $0x1ac0,(%esp)
    44dc:	e8 fc ff ff ff       	call   44dd <rlc_mac_main+0x69d>
			printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    44e1:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    44e7:	c7 04 24 f8 1a 00 00 	movl   $0x1af8,(%esp)
    44ee:	89 44 24 04          	mov    %eax,0x4(%esp)
    44f2:	e8 fc ff ff ff       	call   44f3 <rlc_mac_main+0x6b3>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    44f7:	89 d8                	mov    %ebx,%eax
    44f9:	e8 fc ff ff ff       	call   44fa <rlc_mac_main+0x6ba>
{
	char *tmpdata_ptr;
	int tmpdata;

	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);
    44fe:	e8 fc ff ff ff       	call   44ff <rlc_mac_main+0x6bf>
    4503:	89 c3                	mov    %eax,%ebx

	if( PMRLC_BUFFERREP_REQ() == NULL )
    4505:	e8 fc ff ff ff       	call   4506 <rlc_mac_main+0x6c6>
    450a:	85 c0                	test   %eax,%eax
    450c:	0f 84 88 0c 00 00    	je     519a <rlc_mac_main+0x135a>
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4512:	e8 fc ff ff ff       	call   4513 <rlc_mac_main+0x6d3>
		tmpdata = *((u32*)tmpdata_ptr);//	
    4517:	8b 10                	mov    (%eax),%edx
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4519:	89 c6                	mov    %eax,%esi
		tmpdata = *((u32*)tmpdata_ptr);//	
		if( tmpdata > 0 )
    451b:	85 d2                	test   %edx,%edx
    451d:	7e 21                	jle    4540 <rlc_mac_main+0x700>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    451f:	8d 40 04             	lea    0x4(%eax),%eax
    4522:	e8 fc ff ff ff       	call   4523 <rlc_mac_main+0x6e3>
    4527:	e8 fc ff ff ff       	call   4528 <rlc_mac_main+0x6e8>
			fsm_data_destroy((void *)tmpdata_ptr);//
    452c:	89 f0                	mov    %esi,%eax
    452e:	e8 fc ff ff ff       	call   452f <rlc_mac_main+0x6ef>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    4533:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    453a:	0f 85 b1 0b 00 00    	jne    50f1 <rlc_mac_main+0x12b1>
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    4540:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
		}
	}

	SV(UL_resource_info.resource_flag) = true;
    4546:	c6 43 28 01          	movb   $0x1,0x28(%ebx)
		/********for test 20150916 *********/
	if(SV(UL_resource_info.resource_flag) == true)
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
    454a:	c7 43 2c f0 2d 00 00 	movl   $0x2df0,0x2c(%ebx)
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4551:	c7 83 f4 01 00 00 be 	movl   $0x5be,0x1f4(%ebx)
    4558:	05 00 00 
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    455b:	8d 50 05             	lea    0x5(%eax),%edx
    455e:	39 50 05             	cmp    %edx,0x5(%eax)
    4561:	74 0f                	je     4572 <rlc_mac_main+0x732>
			DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    4563:	b8 f0 2d 00 00       	mov    $0x2df0,%eax
    4568:	e8 fc ff ff ff       	call   4569 <rlc_mac_main+0x729>
    456d:	e8 fc ff ff ff       	call   456e <rlc_mac_main+0x72e>
		SV(UL_resource_info.resource_flag)=false;
    4572:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    4576:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    457c:	8b 0a                	mov    (%edx),%ecx
    457e:	8b 72 04             	mov    0x4(%edx),%esi
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
    4581:	39 f1                	cmp    %esi,%ecx
    4583:	0f 84 a4 fa ff ff    	je     402d <rlc_mac_main+0x1ed>
//the first node is head node, so always take the second node out.
static FSM_PKT * DeQueue(CraQueuePtr *Q)
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
    4589:	3b 97 18 02 00 00    	cmp    0x218(%edi),%edx
    458f:	0f 84 16 0c 00 00    	je     51ab <rlc_mac_main+0x136b>
	// p = (*Q)->front;
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
    4595:	8b 41 04             	mov    0x4(%ecx),%eax
	pktptr = p->pkt;
	if((*Q)->rear == p)
    4598:	39 f0                	cmp    %esi,%eax
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
    459a:	8b 18                	mov    (%eax),%ebx
	if((*Q)->rear == p)
    459c:	0f 84 f6 0a 00 00    	je     5098 <rlc_mac_main+0x1258>
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
		(*Q)->front->next = NULL;
	}
	else
		(*Q)->front->next = p->next;	//more than 2 pkt in the queue.
    45a2:	8b 50 04             	mov    0x4(%eax),%edx
    45a5:	89 51 04             	mov    %edx,0x4(%ecx)

	fsm_mem_free(p);
    45a8:	e8 fc ff ff ff       	call   45a9 <rlc_mac_main+0x769>
	(*Q)->pkt_count--;
    45ad:	8b 87 14 02 00 00    	mov    0x214(%edi),%eax
    45b3:	66 83 68 08 01       	subw   $0x1,0x8(%eax)
	fsm_printf("[DeQueue]DeQueue successfully!\n");
    45b8:	c7 04 24 a4 18 00 00 	movl   $0x18a4,(%esp)
    45bf:	e8 fc ff ff ff       	call   45c0 <rlc_mac_main+0x780>
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
		{
			pkptr = DeQueue(&SV(CraQueue));
			if(pkptr == NULL)
    45c4:	85 db                	test   %ebx,%ebx
    45c6:	74 ae                	je     4576 <rlc_mac_main+0x736>
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    45c8:	e8 fc ff ff ff       	call   45c9 <rlc_mac_main+0x789>

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    45cd:	8b 8b a8 00 00 00    	mov    0xa8(%ebx),%ecx
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    45d3:	ba 40 00 00 00       	mov    $0x40,%edx
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    45d8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    45db:	89 c6                	mov    %eax,%esi

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    45dd:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    45e3:	e8 fc ff ff ff       	call   45e4 <rlc_mac_main+0x7a4>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    45e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    45eb:	80 38 00             	cmpb   $0x0,(%eax)
    45ee:	0f 85 d7 1b 00 00    	jne    61cb <rlc_mac_main+0x238b>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    45f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    45f8:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    45fe:	89 14 24             	mov    %edx,(%esp)
    4601:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    4604:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4607:	e8 fc ff ff ff       	call   4608 <rlc_mac_main+0x7c8>
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
    460c:	8b 86 18 02 00 00    	mov    0x218(%esi),%eax
    4612:	c7 04 24 c4 18 00 00 	movl   $0x18c4,(%esp)
    4619:	89 44 24 04          	mov    %eax,0x4(%esp)
    461d:	e8 fc ff ff ff       	call   461e <rlc_mac_main+0x7de>
		switch(SV(ins_mode))
    4622:	8b 86 18 02 00 00    	mov    0x218(%esi),%eax
    4628:	83 f8 02             	cmp    $0x2,%eax
    462b:	0f 85 87 fe ff ff    	jne    44b8 <rlc_mac_main+0x678>
			
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    4631:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4634:	85 d2                	test   %edx,%edx
    4636:	0f 84 ee 18 00 00    	je     5f2a <rlc_mac_main+0x20ea>
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    463c:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    4640:	3c 0b                	cmp    $0xb,%al
    4642:	74 08                	je     464c <rlc_mac_main+0x80c>
    4644:	3c 09                	cmp    $0x9,%al
    4646:	0f 85 af 0a 00 00    	jne    50fb <rlc_mac_main+0x12bb>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    464c:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    4650:	c7 04 24 44 1a 00 00 	movl   $0x1a44,(%esp)
    4657:	89 44 24 04          	mov    %eax,0x4(%esp)
    465b:	e8 fc ff ff ff       	call   465c <rlc_mac_main+0x81c>
    4660:	e9 92 fe ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
    4665:	8d 76 00             	lea    0x0(%esi),%esi
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
    4668:	c7 05 30 00 00 00 38 	movl   $0x338,0x30
    466f:	03 00 00 
}

static void init_enter()
{
	FIN(init_enter());
	ue_mac_sv_init();
    4672:	e8 a9 ee ff ff       	call   3520 <ue_mac_sv_init>
	rlc_init_enter();
    4677:	e8 a4 e0 ff ff       	call   2720 <rlc_init_enter>
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
    467c:	e9 8f f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4681:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
			//add RLC_INTI state, transmit to IDLE, 20150803
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
    4688:	c7 05 30 00 00 00 46 	movl   $0x346,0x30
    468f:	03 00 00 
    4692:	e8 89 ee ff ff       	call   3520 <ue_mac_sv_init>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
    4697:	e9 74 f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    469c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
    46a0:	85 db                	test   %ebx,%ebx
    46a2:	0f 84 9b fd ff ff    	je     4443 <rlc_mac_main+0x603>
			FSM_TRANSIT_SWITCH
    46a8:	83 ff 05             	cmp    $0x5,%edi
    46ab:	90                   	nop
    46ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    46b0:	0f 87 8d fd ff ff    	ja     4443 <rlc_mac_main+0x603>
    46b6:	ff 24 bd 68 03 00 00 	jmp    *0x368(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")
    46bd:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    46c4:	04 00 00 
    46c7:	e8 a4 f2 ff ff       	call   3970 <ue_mac_reset>
    46cc:	e9 3f f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
    46d1:	c7 05 30 00 00 00 11 	movl   $0x411,0x30
    46d8:	04 00 00 
    46db:	e8 30 ea ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
    46e0:	e9 83 fb ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
    46e5:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    46ec:	04 00 00 
    46ef:	e8 0c ed ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    46f4:	e9 17 f9 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    46f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
    4700:	85 db                	test   %ebx,%ebx
    4702:	0f 84 13 f8 ff ff    	je     3f1b <rlc_mac_main+0xdb>
			FSM_TRANSIT_SWITCH
    4708:	83 ff 05             	cmp    $0x5,%edi
    470b:	90                   	nop
    470c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4710:	0f 87 05 f8 ff ff    	ja     3f1b <rlc_mac_main+0xdb>
    4716:	ff 24 bd 80 03 00 00 	jmp    *0x380(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
    471d:	c7 05 30 00 00 00 79 	movl   $0x379,0x30
    4724:	03 00 00 
    4727:	e8 44 f2 ff ff       	call   3970 <ue_mac_reset>
    472c:	e9 df f8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4731:	c7 05 30 00 00 00 ea 	movl   $0x1ea,0x30
    4738:	01 00 00 
*******************************
*/
static void doStartNonContentionBasedRandomAccessProcedure() //modified by HQ  20140413
{
	FIN(doStartNonContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    473b:	e8 fc ff ff ff       	call   473c <rlc_mac_main+0x8fc>
    4740:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated ));
    4742:	b8 02 00 00 00       	mov    $0x2,%eax
    4747:	e8 fc ff ff ff       	call   4748 <rlc_mac_main+0x908>
    474c:	89 c7                	mov    %eax,%edi
	int mg3_buffer;
	print_tran_info("[UEMAC][noncontention_ra]startNCRA IDLE -> NCRA");//testing code
    474e:	b8 80 0e 00 00       	mov    $0xe80,%eax
    4753:	e8 fc ff ff ff       	call   4754 <rlc_mac_main+0x914>
	if(SV(PREAMBLE_TRANSMISSION_COUNTER ) == 0)   //
    4758:	8b 43 14             	mov    0x14(%ebx),%eax
    475b:	85 c0                	test   %eax,%eax
    475d:	75 10                	jne    476f <rlc_mac_main+0x92f>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER ) = 1; //PREAMBLE_TRANSMISSION_COUNTER1 
    475f:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    4766:	b0 01                	mov    $0x1,%al
    4768:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer = 0;   //MSG3//
	}
	fsm_printf("[UEMAC][noncontention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    476f:	89 44 24 04          	mov    %eax,0x4(%esp)
    4773:	c7 04 24 b0 0e 00 00 	movl   $0xeb0,(%esp)
    477a:	e8 fc ff ff ff       	call   477b <rlc_mac_main+0x93b>
	//
	randomaccess_info->ra_PreambleIndex=SV(RA_info.ra_PreambleIndex);
    477f:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    4783:	88 07                	mov    %al,(%edi)
	//fsm_printf("[HEXI]PREAMBLE INDEX IN MACFSM:%d\n",SV(RA_info.ra_PreambleIndex));
	
	randomaccess_info->ra_PRACHMaskIndex= SV(RA_info.ra_PRACHMaskIndex);
    4785:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
    4789:	88 47 01             	mov    %al,0x1(%edi)
	SendRaPreamble(randomaccess_info);//
    478c:	89 f8                	mov    %edi,%eax
    478e:	e8 0d e3 ff ff       	call   2aa0 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    4793:	e8 f8 de ff ff       	call   2690 <StartWaitingForRaResponse>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4798:	e9 e3 fb ff ff       	jmp    4380 <rlc_mac_main+0x540>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
    479d:	c7 05 30 00 00 00 de 	movl   $0x1de,0x30
    47a4:	01 00 00 
    47a7:	e8 64 e9 ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
    47ac:	e9 b7 fa ff ff       	jmp    4268 <rlc_mac_main+0x428>
    47b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
    47b8:	85 db                	test   %ebx,%ebx
    47ba:	0f 84 0b fa ff ff    	je     41cb <rlc_mac_main+0x38b>
			FSM_TRANSIT_SWITCH
    47c0:	83 ff 05             	cmp    $0x5,%edi
    47c3:	0f 87 02 fa ff ff    	ja     41cb <rlc_mac_main+0x38b>
    47c9:	ff 24 bd 98 03 00 00 	jmp    *0x398(,%edi,4)
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    47d0:	c7 05 30 00 00 00 03 	movl   $0x203,0x30
    47d7:	02 00 00 
*/
static void cra_success()
{
	RNTI_indication *data_ptr;
	FIN(cra_success());
	SV_PTR_GET(rlc_mac_sv);
    47da:	e8 fc ff ff ff       	call   47db <rlc_mac_main+0x99b>
    47df:	89 c7                	mov    %eax,%edi
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    47e1:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    47e5:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    47e9:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	cleanharqBuff();//HARQmsg3
	SV(ra_allocation_res)=0;
    47f0:	c7 80 f8 01 00 00 00 	movl   $0x0,0x1f8(%eax)
    47f7:	00 00 00 
	if(SV(msg3_buf_ptr) != NULL)
    47fa:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
    4800:	85 c0                	test   %eax,%eax
    4802:	74 0f                	je     4813 <rlc_mac_main+0x9d3>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    4804:	e8 fc ff ff ff       	call   4805 <rlc_mac_main+0x9c5>
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    4809:	c7 87 e4 01 00 00 00 	movl   $0x0,0x1e4(%edi)
    4810:	00 00 00 
	}
	if(SV(C_RNTI) == 0)
    4813:	66 83 3f 00          	cmpw   $0x0,(%edi)
    4817:	0f 85 92 08 00 00    	jne    50af <rlc_mac_main+0x126f>
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    481d:	0f b7 47 02          	movzwl 0x2(%edi),%eax
	SV(T_C_RNTI) = 0;//T_C_RNTI
    4821:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
    4827:	66 85 c0             	test   %ax,%ax
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    482a:	66 89 07             	mov    %ax,(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
    482d:	0f 85 82 08 00 00    	jne    50b5 <rlc_mac_main+0x1275>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
		fsm_mem_free(data_ptr);//LHL20141018
	}
	if(SV(CRTimer.flag)==true) //CR
    4833:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    483a:	74 1b                	je     4857 <rlc_mac_main+0xa17>
	{
		SV(CRTimer.timer_sign)= NULL;
    483c:	c7 87 70 01 00 00 00 	movl   $0x0,0x170(%edi)
    4843:	00 00 00 
		SV(CRTimer.flag)= false;
    4846:	c6 87 74 01 00 00 00 	movb   $0x0,0x174(%edi)
		SV(CRTimer.time_value)=0;
    484d:	c7 87 6c 01 00 00 00 	movl   $0x0,0x16c(%edi)
    4854:	00 00 00 
	}
	SV(sendmsg3)=0;//MSG30
    4857:	c7 87 ec 01 00 00 00 	movl   $0x0,0x1ec(%edi)
    485e:	00 00 00 
	SV(ratype.ra_type)=0;//0 
    4861:	c7 87 e8 01 00 00 00 	movl   $0x0,0x1e8(%edi)
    4868:	00 00 00 
	SV(pdcch_rnti)=0;
    486b:	c7 87 f0 01 00 00 00 	movl   $0x0,0x1f0(%edi)
    4872:	00 00 00 
	fsm_printf("[UEMAC][cra_success]:contention based random access success \n");//testing code 
    4875:	c7 04 24 94 14 00 00 	movl   $0x1494,(%esp)
    487c:	e8 fc ff ff ff       	call   487d <rlc_mac_main+0xa3d>
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4881:	e9 32 f8 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4886:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    488d:	03 00 00 
*******************************
*/
static void ContentionFailed() 
{
	FIN(ContentionFailed());
	SV_PTR_GET(rlc_mac_sv);
    4890:	e8 fc ff ff ff       	call   4891 <rlc_mac_main+0xa51>
    4895:	89 c3                	mov    %eax,%ebx
	int result=1;//TEST
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4897:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	u32 backoff_time=0,backoff_param=0;//ms backoff_index
    489d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
    48a4:	c7 04 24 38 14 00 00 	movl   $0x1438,(%esp)
    48ab:	e8 fc ff ff ff       	call   48ac <rlc_mac_main+0xa6c>
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
    48b0:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
    48b7:	0f 85 fb 09 00 00    	jne    52b8 <rlc_mac_main+0x1478>
		SV(CRTimer.timer_sign)= NULL;
		SV(CRTimer.flag)= false;
	}
	//if(SV(TATimer.time_value)== SV(TA_fromRAR) && SV(TATimer.flag)==true) //TATimer MAC5.1.6
	
	if(SV(TATimer.flag)==true) 
    48bd:	80 bb 68 01 00 00 00 	cmpb   $0x0,0x168(%ebx)
    48c4:	74 2a                	je     48f0 <rlc_mac_main+0xab0>
	{//HQ 20140428 
		//fsm_printf("[UEMAC][con_failed]CR fail,stop TAtimer\n");//testing code 
		if(SV(TATimer.timer_sign) != NULL)
    48c6:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
    48cc:	85 c0                	test   %eax,%eax
    48ce:	74 05                	je     48d5 <rlc_mac_main+0xa95>
		{
			result=fsm_schedule_cancel (SV(TATimer.timer_sign));
    48d0:	e8 fc ff ff ff       	call   48d1 <rlc_mac_main+0xa91>
		}
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
    48d5:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    48dc:	00 00 00 
		SV(TATimer.flag)=false;
    48df:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.time_value)=0;
    48e6:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    48ed:	00 00 00 
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    48f0:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    48f3:	83 c7 01             	add    $0x1,%edi
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
    48f6:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    48fc:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    48ff:	39 f8                	cmp    %edi,%eax
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4901:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4904:	0f 84 23 0f 00 00    	je     582d <rlc_mac_main+0x19ed>
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    490a:	8b 43 1c             	mov    0x1c(%ebx),%eax
	}
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
    490d:	c7 83 f8 01 00 00 01 	movl   $0x1,0x1f8(%ebx)
    4914:	00 00 00 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4917:	8b 55 e8             	mov    -0x18(%ebp),%edx
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    491a:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4921:	00 
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4922:	85 db                	test   %ebx,%ebx
    4924:	0f 85 26 0b 00 00    	jne    5450 <rlc_mac_main+0x1610>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			//fsm_printf("[UEMAC][con_failed]:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    492a:	6b c2 64             	imul   $0x64,%edx,%eax
    492d:	ba 02 00 00 00       	mov    $0x2,%edx
    4932:	e8 fc ff ff ff       	call   4933 <rlc_mac_main+0xaf3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4937:	e9 d4 f6 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    493c:	c7 05 30 00 00 00 c2 	movl   $0x3c2,0x30
    4943:	03 00 00 
*/
static void waitsending_msg3() //defined by HQ 20140430 
{
	RNTI_indication *data_ptr;
	FIN(waitsending_msg3());   
	SV_PTR_GET(rlc_mac_sv);
    4946:	e8 fc ff ff ff       	call   4947 <rlc_mac_main+0xb07>
    494b:	89 c7                	mov    %eax,%edi
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    494d:	e8 fc ff ff ff       	call   494e <rlc_mac_main+0xb0e>
	if(SV(TATimer.flag)==false)
    4952:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4959:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==false)
    495b:	0f 84 98 08 00 00    	je     51f9 <rlc_mac_main+0x13b9>
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		//T_C_RNTI
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
    4961:	66 83 7f 02 00       	cmpw   $0x0,0x2(%edi)
    4966:	0f 85 50 08 00 00    	jne    51bc <rlc_mac_main+0x137c>
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		fsm_mem_free(data_ptr);
	}
	//HQ HQ modified end 20140717
	fsm_printf("[UEMAC][waitsend_msg3]MAC SV(PREAMBLE_TRANSMISSION_COUNTER):%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER));
    496c:	8b 47 14             	mov    0x14(%edi),%eax
    496f:	c7 04 24 2c 13 00 00 	movl   $0x132c,(%esp)
    4976:	89 44 24 04          	mov    %eax,0x4(%esp)
    497a:	e8 fc ff ff ff       	call   497b <rlc_mac_main+0xb3b>
	{  	
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte,    	
  		fsm_printf("MAC SEND MSG3:this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
	}*/ //modified by lhl 20140725

	if(SV(ra_allocation_res)==0)
    497f:	8b 87 f8 01 00 00    	mov    0x1f8(%edi),%eax
    4985:	85 c0                	test   %eax,%eax
    4987:	0f 85 9f 08 00 00    	jne    522c <rlc_mac_main+0x13ec>
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
    498d:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4994:	0f 84 f1 07 00 00    	je     518b <rlc_mac_main+0x134b>
    499a:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    499e:	0f 84 e7 07 00 00    	je     518b <rlc_mac_main+0x134b>
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49a4:	8b 47 2c             	mov    0x2c(%edi),%eax
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    49a7:	66 83 3f 00          	cmpw   $0x0,(%edi)
	if(SV(ra_allocation_res)==0)
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
    49ab:	c7 87 f8 01 00 00 01 	movl   $0x1,0x1f8(%edi)
    49b2:	00 00 00 
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49b5:	89 c2                	mov    %eax,%edx
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    49b7:	0f 84 d5 0c 00 00    	je     5692 <rlc_mac_main+0x1852>
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49bd:	c1 ea 03             	shr    $0x3,%edx
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    49c0:	83 e8 18             	sub    $0x18,%eax
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    49c3:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    49c9:	e8 fc ff ff ff       	call   49ca <rlc_mac_main+0xb8a>
    49ce:	e8 fc ff ff ff       	call   49cf <rlc_mac_main+0xb8f>
				SV(UL_resource_info.resource_flag)=false;
    49d3:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    49d7:	e9 8c f8 ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    49dc:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    49e3:	03 00 00 
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    49e6:	e8 fc ff ff ff       	call   49e7 <rlc_mac_main+0xba7>
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    49eb:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    49f1:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    49f3:	b8 74 12 00 00       	mov    $0x1274,%eax
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
    49f8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    49fe:	e8 fc ff ff ff       	call   49ff <rlc_mac_main+0xbbf>
	if(SV(WaitforRAresponseTimer.flag)==true)//
    4a03:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4a0a:	74 11                	je     4a1d <rlc_mac_main+0xbdd>
	{
		SV(WaitforRAresponseTimer.flag)= false;
    4a0c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4a13:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4a1a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a1d:	8b 43 14             	mov    0x14(%ebx),%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a20:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a23:	83 c0 01             	add    $0x1,%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a26:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4a28:	89 43 14             	mov    %eax,0x14(%ebx)
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4a2b:	0f 84 41 0e 00 00    	je     5872 <rlc_mac_main+0x1a32>
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
		//fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
	//modified by HQ
	else
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
    4a31:	8b 43 1c             	mov    0x1c(%ebx),%eax
    4a34:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4a3b:	00 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4a3c:	66 85 db             	test   %bx,%bx
    4a3f:	0f 85 b5 09 00 00    	jne    53fa <rlc_mac_main+0x15ba>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4a45:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    4a49:	ba 02 00 00 00       	mov    $0x2,%edx
    4a4e:	6b c0 64             	imul   $0x64,%eax,%eax
    4a51:	e8 fc ff ff ff       	call   4a52 <rlc_mac_main+0xc12>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4a56:	e9 b5 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
    4a5b:	c7 05 30 00 00 00 ab 	movl   $0x3ab,0x30
    4a62:	03 00 00 
    4a65:	e8 96 e9 ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    4a6a:	e9 a1 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
    4a6f:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4a76:	03 00 00 
    4a79:	e8 f2 ee ff ff       	call   3970 <ue_mac_reset>
    4a7e:	e9 8d f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4a83:	90                   	nop
    4a84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
    4a88:	85 db                	test   %ebx,%ebx
    4a8a:	0f 84 93 f8 ff ff    	je     4323 <rlc_mac_main+0x4e3>
			FSM_TRANSIT_SWITCH
    4a90:	83 ff 01             	cmp    $0x1,%edi
    4a93:	0f 84 b9 01 00 00    	je     4c52 <rlc_mac_main+0xe12>
    4a99:	0f 8e 95 09 00 00    	jle    5434 <rlc_mac_main+0x15f4>
    4a9f:	83 ff 02             	cmp    $0x2,%edi
    4aa2:	0f 84 3d 01 00 00    	je     4be5 <rlc_mac_main+0xda5>
    4aa8:	83 ff 03             	cmp    $0x3,%edi
    4aab:	90                   	nop
    4aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4ab0:	0f 85 6d f8 ff ff    	jne    4323 <rlc_mac_main+0x4e3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
    4ab6:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4abd:	03 00 00 
    4ac0:	e8 ab ee ff ff       	call   3970 <ue_mac_reset>
    4ac5:	e9 46 f5 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
    4aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4ad0:	e8 fc ff ff ff       	call   4ad1 <rlc_mac_main+0xc91>
    4ad5:	83 f8 04             	cmp    $0x4,%eax
    4ad8:	0f 85 00 f8 ff ff    	jne    42de <rlc_mac_main+0x49e>
    4ade:	83 c3 01             	add    $0x1,%ebx
    4ae1:	bf 02 00 00 00       	mov    $0x2,%edi
    4ae6:	e9 03 f8 ff ff       	jmp    42ee <rlc_mac_main+0x4ae>
    4aeb:	90                   	nop
    4aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4af0:	e8 fc ff ff ff       	call   4af1 <rlc_mac_main+0xcb1>
    4af5:	83 f8 06             	cmp    $0x6,%eax
    4af8:	0f 85 88 f6 ff ff    	jne    4186 <rlc_mac_main+0x346>
    4afe:	83 c3 01             	add    $0x1,%ebx
    4b01:	bf 04 00 00 00       	mov    $0x4,%edi
    4b06:	e9 8b f6 ff ff       	jmp    4196 <rlc_mac_main+0x356>
    4b0b:	90                   	nop
    4b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4b10:	e8 fc ff ff ff       	call   4b11 <rlc_mac_main+0xcd1>
    4b15:	83 f8 05             	cmp    $0x5,%eax
    4b18:	0f 85 38 f6 ff ff    	jne    4156 <rlc_mac_main+0x316>
    4b1e:	83 c3 01             	add    $0x1,%ebx
    4b21:	bf 03 00 00 00       	mov    $0x3,%edi
    4b26:	e9 4b f6 ff ff       	jmp    4176 <rlc_mac_main+0x336>
    4b2b:	90                   	nop
    4b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4b30:	e8 fc ff ff ff       	call   4b31 <rlc_mac_main+0xcf1>
    4b35:	83 f8 04             	cmp    $0x4,%eax
    4b38:	0f 85 f8 f5 ff ff    	jne    4136 <rlc_mac_main+0x2f6>
    4b3e:	83 c3 01             	add    $0x1,%ebx
    4b41:	bf 02 00 00 00       	mov    $0x2,%edi
    4b46:	e9 fb f5 ff ff       	jmp    4146 <rlc_mac_main+0x306>
    4b4b:	90                   	nop
    4b4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b50:	e8 fc ff ff ff       	call   4b51 <rlc_mac_main+0xd11>
    4b55:	83 f8 03             	cmp    $0x3,%eax
    4b58:	0f 85 a8 f5 ff ff    	jne    4106 <rlc_mac_main+0x2c6>
    4b5e:	83 c3 01             	add    $0x1,%ebx
    4b61:	bf 01 00 00 00       	mov    $0x1,%edi
    4b66:	e9 bb f5 ff ff       	jmp    4126 <rlc_mac_main+0x2e6>
    4b6b:	90                   	nop
    4b6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b70:	e8 fc ff ff ff       	call   4b71 <rlc_mac_main+0xd31>
    4b75:	83 f8 03             	cmp    $0x3,%eax
    4b78:	0f 85 2f f7 ff ff    	jne    42ad <rlc_mac_main+0x46d>
    4b7e:	83 c3 01             	add    $0x1,%ebx
    4b81:	bf 01 00 00 00       	mov    $0x1,%edi
    4b86:	e9 43 f7 ff ff       	jmp    42ce <rlc_mac_main+0x48e>
    4b8b:	90                   	nop
    4b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4b90:	e8 fc ff ff ff       	call   4b91 <rlc_mac_main+0xd51>
    4b95:	83 f8 18             	cmp    $0x18,%eax
    4b98:	0f 85 78 f5 ff ff    	jne    4116 <rlc_mac_main+0x2d6>
    4b9e:	66 90                	xchg   %ax,%ax
    4ba0:	eb bc                	jmp    4b5e <rlc_mac_main+0xd1e>
    4ba2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4ba8:	90                   	nop
    4ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4bb0:	e8 fc ff ff ff       	call   4bb1 <rlc_mac_main+0xd71>
    4bb5:	83 f8 18             	cmp    $0x18,%eax
    4bb8:	0f 85 00 f7 ff ff    	jne    42be <rlc_mac_main+0x47e>
    4bbe:	66 90                	xchg   %ax,%ax
    4bc0:	eb bc                	jmp    4b7e <rlc_mac_main+0xd3e>
    4bc2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4bc8:	90                   	nop
    4bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4bd0:	e8 fc ff ff ff       	call   4bd1 <rlc_mac_main+0xd91>
    4bd5:	83 f8 0f             	cmp    $0xf,%eax
    4bd8:	0f 85 88 f5 ff ff    	jne    4166 <rlc_mac_main+0x326>
    4bde:	66 90                	xchg   %ax,%ax
    4be0:	e9 39 ff ff ff       	jmp    4b1e <rlc_mac_main+0xcde>
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4be5:	c7 05 30 00 00 00 f7 	movl   $0x1f7,0x30
    4bec:	01 00 00 
*******************************
*/
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
    4bef:	e8 fc ff ff ff       	call   4bf0 <rlc_mac_main+0xdb0>
    4bf4:	89 c7                	mov    %eax,%edi
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4bf6:	e8 fc ff ff ff       	call   4bf7 <rlc_mac_main+0xdb7>
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4bfb:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4c02:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4c04:	74 0f                	je     4c15 <rlc_mac_main+0xdd5>
    4c06:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    4c0c:	85 c0                	test   %eax,%eax
    4c0e:	74 05                	je     4c15 <rlc_mac_main+0xdd5>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    4c10:	e8 fc ff ff ff       	call   4c11 <rlc_mac_main+0xdd1>
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4c15:	8b 43 24             	mov    0x24(%ebx),%eax
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c18:	ba 0b 00 00 00       	mov    $0xb,%edx
	SV_PTR_GET(rlc_mac_sv);	
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4c1d:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c23:	6b c0 64             	imul   $0x64,%eax,%eax
    4c26:	e8 fc ff ff ff       	call   4c27 <rlc_mac_main+0xde7>
	SV(TATimer.flag)=true;
    4c2b:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4c32:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
	RARTA_handleA();//RAR  TA 
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4c38:	c6 47 04 00          	movb   $0x0,0x4(%edi)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4c3c:	c6 47 05 00          	movb   $0x0,0x5(%edi)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4c40:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI 
    4c47:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4c4d:	e9 66 f4 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4c52:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4c59:	03 00 00 
*******************************
*/
static void NC_RaResponseFailed() 
{
	FIN(NC_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c5c:	e8 fc ff ff ff       	call   4c5d <rlc_mac_main+0xe1d>
    4c61:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4c63:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	print_tran_info("[UEMAC][nc_ra_failed]NCRA -> IDLE");//testing code
    4c69:	b8 68 17 00 00       	mov    $0x1768,%eax
    4c6e:	e8 fc ff ff ff       	call   4c6f <rlc_mac_main+0xe2f>
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
    4c73:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4c7a:	74 11                	je     4c8d <rlc_mac_main+0xe4d>
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
    4c7c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4c83:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4c8a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c8d:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c90:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c93:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c96:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c98:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c9b:	0f 84 d1 04 00 00    	je     5172 <rlc_mac_main+0x1332>
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
	}
	else
	{
		fsm_printf("[UEMAC][nc_ra_failed]MAC:start a new NCRA \n");//testing code 
    4ca1:	c7 04 24 cc 17 00 00 	movl   $0x17cc,(%esp)
    4ca8:	e8 fc ff ff ff       	call   4ca9 <rlc_mac_main+0xe69>
		fsm_schedule_self(100,Start_NonContentionBase_RandomAcc);//trigger a new random access procedure
    4cad:	ba 01 00 00 00       	mov    $0x1,%edx
    4cb2:	b8 64 00 00 00       	mov    $0x64,%eax
    4cb7:	e8 fc ff ff ff       	call   4cb8 <rlc_mac_main+0xe78>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4cbc:	e9 4f f3 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4cc1:	e8 fc ff ff ff       	call   4cc2 <rlc_mac_main+0xe82>
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
    4cc6:	83 f8 0b             	cmp    $0xb,%eax
    4cc9:	0f 94 c3             	sete   %bl
    4ccc:	0f b6 fb             	movzbl %bl,%edi
    4ccf:	0f b6 db             	movzbl %bl,%ebx
    4cd2:	83 ef 01             	sub    $0x1,%edi
    4cd5:	e9 1d f4 ff ff       	jmp    40f7 <rlc_mac_main+0x2b7>
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4cda:	e8 fc ff ff ff       	call   4cdb <rlc_mac_main+0xe9b>
    4cdf:	83 f8 54             	cmp    $0x54,%eax
    4ce2:	0f 85 36 f7 ff ff    	jne    441e <rlc_mac_main+0x5de>
    4ce8:	83 c3 01             	add    $0x1,%ebx
    4ceb:	bf 05 00 00 00       	mov    $0x5,%edi
    4cf0:	e9 29 f7 ff ff       	jmp    441e <rlc_mac_main+0x5de>
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)
    4cf5:	e8 fc ff ff ff       	call   4cf6 <rlc_mac_main+0xeb6>
    4cfa:	83 f8 02             	cmp    $0x2,%eax
    4cfd:	0f 85 eb f6 ff ff    	jne    43ee <rlc_mac_main+0x5ae>
    4d03:	e8 fc ff ff ff       	call   4d04 <rlc_mac_main+0xec4>
    4d08:	83 f8 03             	cmp    $0x3,%eax
    4d0b:	0f 85 dd f6 ff ff    	jne    43ee <rlc_mac_main+0x5ae>
    4d11:	83 c3 01             	add    $0x1,%ebx
    4d14:	bf 02 00 00 00       	mov    $0x2,%edi
    4d19:	e9 d0 f6 ff ff       	jmp    43ee <rlc_mac_main+0x5ae>
    4d1e:	66 90                	xchg   %ax,%ax
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
    4d20:	e8 fc ff ff ff       	call   4d21 <rlc_mac_main+0xee1>
    4d25:	83 f8 07             	cmp    $0x7,%eax
    4d28:	0f 85 af f6 ff ff    	jne    43dd <rlc_mac_main+0x59d>
    4d2e:	83 c3 01             	add    $0x1,%ebx
    4d31:	bf 01 00 00 00       	mov    $0x1,%edi
    4d36:	e9 a2 f6 ff ff       	jmp    43dd <rlc_mac_main+0x59d>
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4d3b:	e8 fc ff ff ff       	call   4d3c <rlc_mac_main+0xefc>
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
    4d40:	83 f8 0b             	cmp    $0xb,%eax
    4d43:	0f 94 c3             	sete   %bl
    4d46:	0f b6 fb             	movzbl %bl,%edi
    4d49:	0f b6 db             	movzbl %bl,%ebx
    4d4c:	83 ef 01             	sub    $0x1,%edi
    4d4f:	e9 7b f6 ff ff       	jmp    43cf <rlc_mac_main+0x58f>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4d54:	e8 fc ff ff ff       	call   4d55 <rlc_mac_main+0xf15>
    4d59:	83 f8 54             	cmp    $0x54,%eax
    4d5c:	0f 85 94 f1 ff ff    	jne    3ef6 <rlc_mac_main+0xb6>
    4d62:	83 c3 01             	add    $0x1,%ebx
    4d65:	bf 05 00 00 00       	mov    $0x5,%edi
    4d6a:	e9 87 f1 ff ff       	jmp    3ef6 <rlc_mac_main+0xb6>
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4d6f:	e8 fc ff ff ff       	call   4d70 <rlc_mac_main+0xf30>
    4d74:	83 f8 52             	cmp    $0x52,%eax
    4d77:	0f 85 69 f1 ff ff    	jne    3ee6 <rlc_mac_main+0xa6>
    4d7d:	83 c3 01             	add    $0x1,%ebx
    4d80:	bf 04 00 00 00       	mov    $0x4,%edi
    4d85:	e9 5c f1 ff ff       	jmp    3ee6 <rlc_mac_main+0xa6>
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4d8a:	e8 fc ff ff ff       	call   4d8b <rlc_mac_main+0xf4b>
    4d8f:	83 f8 02             	cmp    $0x2,%eax
    4d92:	0f 85 66 f5 ff ff    	jne    42fe <rlc_mac_main+0x4be>
    4d98:	e8 fc ff ff ff       	call   4d99 <rlc_mac_main+0xf59>
    4d9d:	83 f8 03             	cmp    $0x3,%eax
    4da0:	0f 85 58 f5 ff ff    	jne    42fe <rlc_mac_main+0x4be>
    4da6:	83 c3 01             	add    $0x1,%ebx
    4da9:	bf 03 00 00 00       	mov    $0x3,%edi
    4dae:	e9 4b f5 ff ff       	jmp    42fe <rlc_mac_main+0x4be>
    4db3:	90                   	nop
    4db4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4db8:	e8 fc ff ff ff       	call   4db9 <rlc_mac_main+0xf79>
    4dbd:	83 f8 02             	cmp    $0x2,%eax
    4dc0:	0f 85 e0 f3 ff ff    	jne    41a6 <rlc_mac_main+0x366>
    4dc6:	e8 fc ff ff ff       	call   4dc7 <rlc_mac_main+0xf87>
    4dcb:	83 f8 03             	cmp    $0x3,%eax
    4dce:	66 90                	xchg   %ax,%ax
    4dd0:	0f 85 d0 f3 ff ff    	jne    41a6 <rlc_mac_main+0x366>
    4dd6:	83 c3 01             	add    $0x1,%ebx
    4dd9:	bf 05 00 00 00       	mov    $0x5,%edi
    4dde:	e9 c3 f3 ff ff       	jmp    41a6 <rlc_mac_main+0x366>
    4de3:	90                   	nop
    4de4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
    4de8:	e8 fc ff ff ff       	call   4de9 <rlc_mac_main+0xfa9>
    4ded:	83 f8 53             	cmp    $0x53,%eax
    4df0:	0f 85 e0 f0 ff ff    	jne    3ed6 <rlc_mac_main+0x96>
    4df6:	83 c3 01             	add    $0x1,%ebx
    4df9:	bf 03 00 00 00       	mov    $0x3,%edi
    4dfe:	e9 d3 f0 ff ff       	jmp    3ed6 <rlc_mac_main+0x96>
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
    4e03:	e8 fc ff ff ff       	call   4e04 <rlc_mac_main+0xfc4>
    4e08:	83 f8 02             	cmp    $0x2,%eax
    4e0b:	0f 85 b5 f0 ff ff    	jne    3ec6 <rlc_mac_main+0x86>
    4e11:	e8 fc ff ff ff       	call   4e12 <rlc_mac_main+0xfd2>
    4e16:	83 f8 03             	cmp    $0x3,%eax
    4e19:	0f 85 a7 f0 ff ff    	jne    3ec6 <rlc_mac_main+0x86>
    4e1f:	83 c3 01             	add    $0x1,%ebx
    4e22:	bf 02 00 00 00       	mov    $0x2,%edi
    4e27:	e9 9a f0 ff ff       	jmp    3ec6 <rlc_mac_main+0x86>
    4e2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    4e30:	e8 fc ff ff ff       	call   4e31 <rlc_mac_main+0xff1>
    4e35:	83 f8 01             	cmp    $0x1,%eax
    4e38:	0f 85 78 f0 ff ff    	jne    3eb6 <rlc_mac_main+0x76>
    4e3e:	83 c3 01             	add    $0x1,%ebx
    4e41:	bf 01 00 00 00       	mov    $0x1,%edi
    4e46:	e9 6b f0 ff ff       	jmp    3eb6 <rlc_mac_main+0x76>
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    4e4b:	e8 fc ff ff ff       	call   4e4c <rlc_mac_main+0x100c>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
    4e50:	83 f8 02             	cmp    $0x2,%eax
    4e53:	0f 94 c3             	sete   %bl
    4e56:	0f b6 fb             	movzbl %bl,%edi
    4e59:	0f b6 db             	movzbl %bl,%ebx
    4e5c:	83 ef 01             	sub    $0x1,%edi
    4e5f:	e9 43 f0 ff ff       	jmp    3ea7 <rlc_mac_main+0x67>
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4e64:	e8 fc ff ff ff       	call   4e65 <rlc_mac_main+0x1025>
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
    4e69:	83 f8 0b             	cmp    $0xb,%eax
    4e6c:	0f 94 c3             	sete   %bl
    4e6f:	0f b6 fb             	movzbl %bl,%edi
    4e72:	0f b6 db             	movzbl %bl,%ebx
    4e75:	83 ef 01             	sub    $0x1,%edi
    4e78:	e9 22 f4 ff ff       	jmp    429f <rlc_mac_main+0x45f>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4e7d:	e8 fc ff ff ff       	call   4e7e <rlc_mac_main+0x103e>
    4e82:	83 f8 52             	cmp    $0x52,%eax
    4e85:	0f 85 83 f5 ff ff    	jne    440e <rlc_mac_main+0x5ce>
    4e8b:	83 c3 01             	add    $0x1,%ebx
    4e8e:	bf 04 00 00 00       	mov    $0x4,%edi
    4e93:	e9 76 f5 ff ff       	jmp    440e <rlc_mac_main+0x5ce>
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
    4e98:	e8 fc ff ff ff       	call   4e99 <rlc_mac_main+0x1059>
    4e9d:	83 f8 53             	cmp    $0x53,%eax
    4ea0:	0f 85 58 f5 ff ff    	jne    43fe <rlc_mac_main+0x5be>
    4ea6:	83 c3 01             	add    $0x1,%ebx
    4ea9:	bf 03 00 00 00       	mov    $0x3,%edi
    4eae:	e9 4b f5 ff ff       	jmp    43fe <rlc_mac_main+0x5be>
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4eb3:	e8 fc ff ff ff       	call   4eb4 <rlc_mac_main+0x1074>
    4eb8:	83 f8 02             	cmp    $0x2,%eax
    4ebb:	0f 85 d5 f2 ff ff    	jne    4196 <rlc_mac_main+0x356>
    4ec1:	e8 fc ff ff ff       	call   4ec2 <rlc_mac_main+0x1082>
    4ec6:	83 f8 43             	cmp    $0x43,%eax
    4ec9:	0f 85 c7 f2 ff ff    	jne    4196 <rlc_mac_main+0x356>
    4ecf:	90                   	nop
    4ed0:	e9 29 fc ff ff       	jmp    4afe <rlc_mac_main+0xcbe>
    4ed5:	8d 76 00             	lea    0x0(%esi),%esi
    4ed8:	90                   	nop
    4ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4ee0:	e8 fc ff ff ff       	call   4ee1 <rlc_mac_main+0x10a1>
    4ee5:	83 f8 02             	cmp    $0x2,%eax
    4ee8:	0f 85 58 f2 ff ff    	jne    4146 <rlc_mac_main+0x306>
    4eee:	66 90                	xchg   %ax,%ax
    4ef0:	e8 fc ff ff ff       	call   4ef1 <rlc_mac_main+0x10b1>
    4ef5:	83 f8 41             	cmp    $0x41,%eax
    4ef8:	0f 85 48 f2 ff ff    	jne    4146 <rlc_mac_main+0x306>
    4efe:	66 90                	xchg   %ax,%ax
    4f00:	e9 39 fc ff ff       	jmp    4b3e <rlc_mac_main+0xcfe>
    4f05:	8d 76 00             	lea    0x0(%esi),%esi
    4f08:	90                   	nop
    4f09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4f10:	e8 fc ff ff ff       	call   4f11 <rlc_mac_main+0x10d1>
    4f15:	83 f8 02             	cmp    $0x2,%eax
    4f18:	0f 85 d0 f3 ff ff    	jne    42ee <rlc_mac_main+0x4ae>
    4f1e:	66 90                	xchg   %ax,%ax
    4f20:	e8 fc ff ff ff       	call   4f21 <rlc_mac_main+0x10e1>
    4f25:	83 f8 41             	cmp    $0x41,%eax
    4f28:	0f 85 c0 f3 ff ff    	jne    42ee <rlc_mac_main+0x4ae>
    4f2e:	66 90                	xchg   %ax,%ax
    4f30:	e9 a9 fb ff ff       	jmp    4ade <rlc_mac_main+0xc9e>
    4f35:	8d 76 00             	lea    0x0(%esi),%esi
			
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    4f38:	8b 75 ec             	mov    -0x14(%ebp),%esi
    4f3b:	85 f6                	test   %esi,%esi
    4f3d:	8d 76 00             	lea    0x0(%esi),%esi
    4f40:	0f 84 b3 12 00 00    	je     61f9 <rlc_mac_main+0x23b9>
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    4f46:	b8 0c 00 00 00       	mov    $0xc,%eax
    4f4b:	e8 fc ff ff ff       	call   4f4c <rlc_mac_main+0x110c>
			tmElm->pkt = skb;
    4f50:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4f52:	8b 56 10             	mov    0x10(%esi),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    4f55:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4f58:	89 4e 10             	mov    %ecx,0x10(%esi)
    4f5b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4f5e:	8d 4e 0c             	lea    0xc(%esi),%ecx
    4f61:	89 48 04             	mov    %ecx,0x4(%eax)
	new->next = next;
	new->prev = prev;
    4f64:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    4f67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f6a:	89 02                	mov    %eax,(%edx)
			tmTxIns->tmSduBufferNum++;
    4f6c:	83 46 18 01          	addl   $0x1,0x18(%esi)
			tmTxIns->tmSduBufferSize += skb->len;
    4f70:	8b 43 50             	mov    0x50(%ebx),%eax
    4f73:	01 46 14             	add    %eax,0x14(%esi)
    4f76:	e9 83 f5 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    4f7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f7e:	85 c0                	test   %eax,%eax
    4f80:	0f 84 d9 0f 00 00    	je     5f5f <rlc_mac_main+0x211f>
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    4f86:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    4f89:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
    4f8d:	66 83 fa 0b          	cmp    $0xb,%dx
    4f91:	0f 84 af 0f 00 00    	je     5f46 <rlc_mac_main+0x2106>
    4f97:	66 83 fa 09          	cmp    $0x9,%dx
    4f9b:	0f 84 a5 0f 00 00    	je     5f46 <rlc_mac_main+0x2106>
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    4fa1:	b8 14 00 00 00       	mov    $0x14,%eax
    4fa6:	e8 fc ff ff ff       	call   4fa7 <rlc_mac_main+0x1167>
			
			amElm->pkt = skb;
    4fab:	89 18                	mov    %ebx,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    4fad:	8d 48 0c             	lea    0xc(%eax),%ecx
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
			
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    4fb0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    4fb7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    4fbe:	8b 55 e8             	mov    -0x18(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    4fc1:	8b 72 48             	mov    0x48(%edx),%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    4fc4:	89 4a 48             	mov    %ecx,0x48(%edx)
    4fc7:	83 c2 44             	add    $0x44,%edx
    4fca:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    4fcd:	89 70 10             	mov    %esi,0x10(%eax)
	prev->next = new;
    4fd0:	89 0e                	mov    %ecx,(%esi)
			fsm_printf("[RLC][skb_from_cra_to_con]AM_MODE list_add done!\n");
    4fd2:	c7 04 24 7c 19 00 00 	movl   $0x197c,(%esp)
    4fd9:	e8 fc ff ff ff       	call   4fda <rlc_mac_main+0x119a>
			fsm_printf("[RLC][skb_from_cra_to_con] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    4fde:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4fe1:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    4fe5:	89 54 24 0c          	mov    %edx,0xc(%esp)
    4fe9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    4fed:	c7 04 24 b0 19 00 00 	movl   $0x19b0,(%esp)
    4ff4:	89 44 24 08          	mov    %eax,0x8(%esp)
    4ff8:	8d 45 e8             	lea    -0x18(%ebp),%eax
    4ffb:	89 44 24 04          	mov    %eax,0x4(%esp)
    4fff:	e8 fc ff ff ff       	call   5000 <rlc_mac_main+0x11c0>
			amIns->amSduBufferSize += skb->len;
    5004:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5007:	8b 53 50             	mov    0x50(%ebx),%edx
    500a:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    500d:	83 40 50 01          	addl   $0x1,0x50(%eax)
    5011:	e9 e8 f4 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    5016:	e8 fc ff ff ff       	call   5017 <rlc_mac_main+0x11d7>
    501b:	83 f8 02             	cmp    $0x2,%eax
    501e:	0f 85 52 f1 ff ff    	jne    4176 <rlc_mac_main+0x336>
    5024:	e8 fc ff ff ff       	call   5025 <rlc_mac_main+0x11e5>
    5029:	83 f8 42             	cmp    $0x42,%eax
    502c:	0f 85 44 f1 ff ff    	jne    4176 <rlc_mac_main+0x336>
    5032:	e9 e7 fa ff ff       	jmp    4b1e <rlc_mac_main+0xcde>
    5037:	90                   	nop
    5038:	90                   	nop
    5039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    5040:	e8 fc ff ff ff       	call   5041 <rlc_mac_main+0x1201>
    5045:	83 f8 02             	cmp    $0x2,%eax
    5048:	0f 85 d8 f0 ff ff    	jne    4126 <rlc_mac_main+0x2e6>
    504e:	66 90                	xchg   %ax,%ax
    5050:	e8 fc ff ff ff       	call   5051 <rlc_mac_main+0x1211>
    5055:	83 f8 40             	cmp    $0x40,%eax
    5058:	0f 85 c8 f0 ff ff    	jne    4126 <rlc_mac_main+0x2e6>
    505e:	66 90                	xchg   %ax,%ax
    5060:	e9 f9 fa ff ff       	jmp    4b5e <rlc_mac_main+0xd1e>
    5065:	8d 76 00             	lea    0x0(%esi),%esi
    5068:	90                   	nop
    5069:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    5070:	e8 fc ff ff ff       	call   5071 <rlc_mac_main+0x1231>
    5075:	83 f8 02             	cmp    $0x2,%eax
    5078:	0f 85 50 f2 ff ff    	jne    42ce <rlc_mac_main+0x48e>
    507e:	66 90                	xchg   %ax,%ax
    5080:	e8 fc ff ff ff       	call   5081 <rlc_mac_main+0x1241>
    5085:	83 f8 40             	cmp    $0x40,%eax
    5088:	0f 85 40 f2 ff ff    	jne    42ce <rlc_mac_main+0x48e>
    508e:	66 90                	xchg   %ax,%ax
    5090:	e9 e9 fa ff ff       	jmp    4b7e <rlc_mac_main+0xd3e>
    5095:	8d 76 00             	lea    0x0(%esi),%esi
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
	if((*Q)->rear == p)
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
    5098:	89 4a 04             	mov    %ecx,0x4(%edx)
		(*Q)->front->next = NULL;
    509b:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    50a1:	8b 12                	mov    (%edx),%edx
    50a3:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    50aa:	e9 f9 f4 ff ff       	jmp    45a8 <rlc_mac_main+0x768>
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
    50af:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    50b5:	b8 08 00 00 00       	mov    $0x8,%eax
    50ba:	e8 fc ff ff ff       	call   50bb <rlc_mac_main+0x127b>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50bf:	ba 24 00 00 00       	mov    $0x24,%edx
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    50c4:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 1; 
    50c6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		data_ptr->rnti_value = SV(C_RNTI);
    50cc:	0f b7 07             	movzwl (%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50cf:	89 d9                	mov    %ebx,%ecx
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
    50d1:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    50d4:	b8 03 00 00 00       	mov    $0x3,%eax
    50d9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    50e0:	e8 fc ff ff ff       	call   50e1 <rlc_mac_main+0x12a1>
		fsm_mem_free(data_ptr);//LHL20141018
    50e5:	89 d8                	mov    %ebx,%eax
    50e7:	e8 fc ff ff ff       	call   50e8 <rlc_mac_main+0x12a8>
    50ec:	e9 42 f7 ff ff       	jmp    4833 <rlc_mac_main+0x9f3>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    50f1:	e8 fc ff ff ff       	call   50f2 <rlc_mac_main+0x12b2>
    50f6:	e9 45 f4 ff ff       	jmp    4540 <rlc_mac_main+0x700>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    50fb:	b8 18 00 00 00       	mov    $0x18,%eax
    5100:	89 55 d8             	mov    %edx,-0x28(%ebp)
    5103:	e8 fc ff ff ff       	call   5104 <rlc_mac_main+0x12c4>
			umElm->pkt = skb;
    5108:	89 18                	mov    %ebx,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    510a:	8d 48 10             	lea    0x10(%eax),%ecx
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    510d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    5114:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    511b:	8b 55 d8             	mov    -0x28(%ebp),%edx
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    511e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5121:	8b 4a 1c             	mov    0x1c(%edx),%ecx
    5124:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5127:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    512a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    512d:	8d 4a 18             	lea    0x18(%edx),%ecx
    5130:	89 48 10             	mov    %ecx,0x10(%eax)
	new->next = next;
	new->prev = prev;
    5133:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    5136:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    5139:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    513c:	89 01                	mov    %eax,(%ecx)
			fsm_printf("[RLC][skb_from_cra_to_con]UM_MODE list_add done!\n");
    513e:	89 55 d8             	mov    %edx,-0x28(%ebp)
    5141:	c7 04 24 8c 1a 00 00 	movl   $0x1a8c,(%esp)
    5148:	e8 fc ff ff ff       	call   5149 <rlc_mac_main+0x1309>
			
			umTxIns->umSduBufferNum++;
    514d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5150:	8b 42 24             	mov    0x24(%edx),%eax
    5153:	83 c0 01             	add    $0x1,%eax
    5156:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    5159:	3b 86 a8 5a 00 00    	cmp    0x5aa8(%esi),%eax
    515f:	76 06                	jbe    5167 <rlc_mac_main+0x1327>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    5161:	89 86 a8 5a 00 00    	mov    %eax,0x5aa8(%esi)
			}
			umTxIns->umSduBufferSize += skb->len;
    5167:	8b 43 50             	mov    0x50(%ebx),%eax
    516a:	01 42 20             	add    %eax,0x20(%edx)
    516d:	e9 8c f3 ff ff       	jmp    44fe <rlc_mac_main+0x6be>
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
	{
		//modified by HQ    	
		fsm_printf("[UEMAC][nc_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    5172:	c7 04 24 8c 17 00 00 	movl   $0x178c,(%esp)
    5179:	e8 fc ff ff ff       	call   517a <rlc_mac_main+0x133a>
		// fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
		//modified by HQ
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
    517e:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
    5182:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    5186:	e9 85 ee ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
				SV(UL_resource_info.resource_flag)=false;
			}
			//fsm_printf("[UEMAC][waitsend_msg3]DoResourceAllocation \n");
		}
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
    518b:	b8 6c 13 00 00       	mov    $0x136c,%eax
    5190:	e8 fc ff ff ff       	call   5191 <rlc_mac_main+0x1351>
    5195:	e9 ce f0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);

	if( PMRLC_BUFFERREP_REQ() == NULL )
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    519a:	c7 04 24 88 1b 00 00 	movl   $0x1b88,(%esp)
    51a1:	e8 fc ff ff ff       	call   51a2 <rlc_mac_main+0x1362>
    51a6:	e9 cb f3 ff ff       	jmp    4576 <rlc_mac_main+0x736>
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
	{
		fsm_printf("[DeQueue]Queue is empty!\n");
    51ab:	c7 04 24 44 04 00 00 	movl   $0x444,(%esp)
    51b2:	e8 fc ff ff ff       	call   51b3 <rlc_mac_main+0x1373>
    51b7:	e9 ba f3 ff ff       	jmp    4576 <rlc_mac_main+0x736>
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    51bc:	b8 08 00 00 00       	mov    $0x8,%eax
    51c1:	e8 fc ff ff ff       	call   51c2 <rlc_mac_main+0x1382>
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51c6:	ba 24 00 00 00       	mov    $0x24,%edx
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    51cb:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 2; 
    51cd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
		data_ptr->rnti_value = SV(T_C_RNTI);
    51d3:	0f b7 47 02          	movzwl 0x2(%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51d7:	89 d9                	mov    %ebx,%ecx
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
    51d9:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    51dc:	b8 03 00 00 00       	mov    $0x3,%eax
    51e1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    51e8:	e8 fc ff ff ff       	call   51e9 <rlc_mac_main+0x13a9>
		fsm_mem_free(data_ptr);
    51ed:	89 d8                	mov    %ebx,%eax
    51ef:	e8 fc ff ff ff       	call   51f0 <rlc_mac_main+0x13b0>
    51f4:	e9 73 f7 ff ff       	jmp    496c <rlc_mac_main+0xb2c>
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    51f9:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    51fd:	ba 0b 00 00 00       	mov    $0xb,%edx
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5202:	c1 e0 04             	shl    $0x4,%eax
    5205:	66 89 43 22          	mov    %ax,0x22(%ebx)
		SV(TATimer.time_value)=SV(TA_Periodic_time);
    5209:	8b 43 24             	mov    0x24(%ebx),%eax
    520c:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5212:	6b c0 64             	imul   $0x64,%eax,%eax
    5215:	e8 fc ff ff ff       	call   5216 <rlc_mac_main+0x13d6>
		SV(TATimer.flag)=true;
    521a:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5221:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
    5227:	e9 35 f7 ff ff       	jmp    4961 <rlc_mac_main+0xb21>
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    522c:	8b 47 2c             	mov    0x2c(%edi),%eax
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
    522f:	c7 87 f8 01 00 00 02 	movl   $0x2,0x1f8(%edi)
    5236:	00 00 00 
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    5239:	c1 e8 03             	shr    $0x3,%eax
    523c:	89 87 f4 01 00 00    	mov    %eax,0x1f4(%edi)
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    5242:	e8 fc ff ff ff       	call   5243 <rlc_mac_main+0x1403>
    5247:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    5249:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    524f:	c7 04 24 98 13 00 00 	movl   $0x1398,(%esp)
    5256:	89 44 24 04          	mov    %eax,0x4(%esp)
    525a:	e8 fc ff ff ff       	call   525b <rlc_mac_main+0x141b>
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    525f:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    5265:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    526b:	83 fa 01             	cmp    $0x1,%edx
    526e:	0f 84 c8 06 00 00    	je     593c <rlc_mac_main+0x1afc>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    5274:	85 c0                	test   %eax,%eax
    5276:	74 09                	je     5281 <rlc_mac_main+0x1441>
    5278:	83 fa 02             	cmp    $0x2,%edx
    527b:	0f 84 3c 0a 00 00    	je     5cbd <rlc_mac_main+0x1e7d>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    5281:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5287:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    528c:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5292:	6b c0 64             	imul   $0x64,%eax,%eax
    5295:	e8 fc ff ff ff       	call   5296 <rlc_mac_main+0x1456>
	SV(CRTimer.flag)=true;
    529a:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    52a1:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
		//fsm_schedule_self(0, RA_Send_Msg3);//LHL 20140726 ,MSG3MAC
		retransmit_msg3(); 	//call static retransmit_msg3(void) function 20150901 
		fsm_printf("[UEMAC][waitsend_msg3]this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
    52a7:	c7 04 24 bc 13 00 00 	movl   $0x13bc,(%esp)
    52ae:	e8 fc ff ff ff       	call   52af <rlc_mac_main+0x146f>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    52b3:	e9 b0 ef ff ff       	jmp    4268 <rlc_mac_main+0x428>
	u32 backoff_time=0,backoff_param=0;//ms backoff_index

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
	{
		fsm_printf("[UEMAC][con_failed]because CRtimer expire \n");
    52b8:	c7 04 24 68 14 00 00 	movl   $0x1468,(%esp)
    52bf:	e8 fc ff ff ff       	call   52c0 <rlc_mac_main+0x1480>
		SV(CRTimer.timer_sign)= NULL;
    52c4:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    52cb:	00 00 00 
		SV(CRTimer.flag)= false;
    52ce:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
    52d5:	e9 e3 f5 ff ff       	jmp    48bd <rlc_mac_main+0xa7d>
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    52da:	e8 fc ff ff ff       	call   52db <rlc_mac_main+0x149b>
    52df:	83 f8 01             	cmp    $0x1,%eax
    52e2:	0f 85 5c ec ff ff    	jne    3f44 <rlc_mac_main+0x104>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
    52e8:	b8 0c 0f 00 00       	mov    $0xf0c,%eax
    52ed:	e8 fc ff ff ff       	call   52ee <rlc_mac_main+0x14ae>
		ue_mac_sv_close();
    52f2:	e8 59 d7 ff ff       	call   2a50 <ue_mac_sv_close>
    52f7:	e9 14 ed ff ff       	jmp    4010 <rlc_mac_main+0x1d0>

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
	fsm_mem_set(pdu_type,0,sizeof(char));

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    52fc:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5300:	0f 84 fb ee ff ff    	je     4201 <rlc_mac_main+0x3c1>
		fsm_schedule_self(0, Contention_Success );//TEST  
    5306:	ba 06 00 00 00       	mov    $0x6,%edx
    530b:	31 c0                	xor    %eax,%eax
    530d:	e8 fc ff ff ff       	call   530e <rlc_mac_main+0x14ce>
    5312:	e9 ea ee ff ff       	jmp    4201 <rlc_mac_main+0x3c1>
	if(MAC_CLOSE)
    5317:	e8 fc ff ff ff       	call   5318 <rlc_mac_main+0x14d8>
    531c:	83 f8 01             	cmp    $0x1,%eax
    531f:	90                   	nop
    5320:	0f 85 e9 ee ff ff    	jne    420f <rlc_mac_main+0x3cf>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
    5326:	b8 d4 14 00 00       	mov    $0x14d4,%eax
    532b:	e8 fc ff ff ff       	call   532c <rlc_mac_main+0x14ec>
		ue_mac_sv_close();
    5330:	e8 1b d7 ff ff       	call   2a50 <ue_mac_sv_close>
    5335:	e9 2e ef ff ff       	jmp    4268 <rlc_mac_main+0x428>
    533a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    5340:	e8 fc ff ff ff       	call   5341 <rlc_mac_main+0x1501>
    5345:	83 f8 01             	cmp    $0x1,%eax
    5348:	0f 85 2d f1 ff ff    	jne    447b <rlc_mac_main+0x63b>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
    534e:	b8 44 18 00 00       	mov    $0x1844,%eax
    5353:	e8 fc ff ff ff       	call   5354 <rlc_mac_main+0x1514>
		ue_mac_sv_close();
    5358:	e8 f3 d6 ff ff       	call   2a50 <ue_mac_sv_close>
    535d:	e9 56 ed ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
	{//ICIRLC
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
    5362:	b8 34 0f 00 00       	mov    $0xf34,%eax
    5367:	e8 fc ff ff ff       	call   5368 <rlc_mac_main+0x1528>
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
    536c:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    5373:	0f 84 79 03 00 00    	je     56f2 <rlc_mac_main+0x18b2>
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
    5379:	c7 04 24 80 0f 00 00 	movl   $0xf80,(%esp)
    5380:	e8 fc ff ff ff       	call   5381 <rlc_mac_main+0x1541>
		{
			//IDLE
			fsm_pkt_destroy(fsm_pkt_get());
		}
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
    5385:	e8 fc ff ff ff       	call   5386 <rlc_mac_main+0x1546>
    538a:	e8 fc ff ff ff       	call   538b <rlc_mac_main+0x154b>
		SV(countRecvFromLower)++;
    538f:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
    5396:	e9 75 ec ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    539b:	e8 fc ff ff ff       	call   539c <rlc_mac_main+0x155c>
    53a0:	83 f8 01             	cmp    $0x1,%eax
    53a3:	0f 85 a9 eb ff ff    	jne    3f52 <rlc_mac_main+0x112>
	{
		rlc_close();
    53a9:	e8 c2 c9 ff ff       	call   1d70 <rlc_close>
    53ae:	66 90                	xchg   %ax,%ax
    53b0:	e9 5b ec ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    53b5:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    53bc:	e8 ef d5 ff ff       	call   29b0 <rlc_pkt_receive_from_upper>

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
    53c1:	e8 fc ff ff ff       	call   53c2 <rlc_mac_main+0x1582>
    53c6:	85 c0                	test   %eax,%eax
    53c8:	0f 84 0d 07 00 00    	je     5adb <rlc_mac_main+0x1c9b>
    53ce:	66 90                	xchg   %ax,%ax
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    53d0:	e8 fc ff ff ff       	call   53d1 <rlc_mac_main+0x1591>
			tmpdata = *((u32*)tmpdata_ptr);//	
    53d5:	8b 10                	mov    (%eax),%edx
		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    53d7:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    53d9:	85 d2                	test   %edx,%edx
    53db:	0f 8e c9 ec ff ff    	jle    40aa <rlc_mac_main+0x26a>
			{
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    53e1:	8d 40 04             	lea    0x4(%eax),%eax
    53e4:	e8 fc ff ff ff       	call   53e5 <rlc_mac_main+0x15a5>
    53e9:	e8 fc ff ff ff       	call   53ea <rlc_mac_main+0x15aa>
				fsm_data_destroy((void *)tmpdata_ptr);//
    53ee:	89 d8                	mov    %ebx,%eax
    53f0:	e8 fc ff ff ff       	call   53f1 <rlc_mac_main+0x15b1>
    53f5:	e9 b0 ec ff ff       	jmp    40aa <rlc_mac_main+0x26a>
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    53fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
    53fd:	ba 02 00 00 00       	mov    $0x2,%edx
    5402:	e8 fc ff ff ff       	call   5403 <rlc_mac_main+0x15c3>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    5407:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    540b:	31 d2                	xor    %edx,%edx
    540d:	66 f7 f3             	div    %bx
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5410:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    5417:	00 
    5418:	c7 04 24 ec 12 00 00 	movl   $0x12ec,(%esp)
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    541f:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5423:	0f b7 d2             	movzwl %dx,%edx
    5426:	89 54 24 08          	mov    %edx,0x8(%esp)
    542a:	e8 fc ff ff ff       	call   542b <rlc_mac_main+0x15eb>
    542f:	e9 11 f6 ff ff       	jmp    4a45 <rlc_mac_main+0xc05>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
    5434:	85 ff                	test   %edi,%edi
    5436:	0f 85 e7 ee ff ff    	jne    4323 <rlc_mac_main+0x4e3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
    543c:	c7 05 30 00 00 00 db 	movl   $0x3db,0x30
    5443:	03 00 00 
    5446:	e8 b5 df ff ff       	call   3400 <handle_timeAlignmentTimerExpire>
    544b:	e9 c0 eb ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    5450:	ba 04 00 00 00       	mov    $0x4,%edx
    5455:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5458:	e8 fc ff ff ff       	call   5459 <rlc_mac_main+0x1619>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    545d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5460:	31 d2                	xor    %edx,%edx
    5462:	f7 f3                	div    %ebx
    5464:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5467:	e9 be f4 ff ff       	jmp    492a <rlc_mac_main+0xaea>
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    546c:	e8 fc ff ff ff       	call   546d <rlc_mac_main+0x162d>
    5471:	83 f8 09             	cmp    $0x9,%eax
    5474:	0f 85 c4 ed ff ff    	jne    423e <rlc_mac_main+0x3fe>
	{
		FlushBj();
    547a:	e8 fc ff ff ff       	call   547b <rlc_mac_main+0x163b>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    547f:	ba 09 00 00 00       	mov    $0x9,%edx
    5484:	b8 64 00 00 00       	mov    $0x64,%eax
    5489:	e8 fc ff ff ff       	call   548a <rlc_mac_main+0x164a>
    548e:	e9 d5 ed ff ff       	jmp    4268 <rlc_mac_main+0x428>
    5493:	90                   	nop
    5494:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void cra_pkt_recv_from_upper(void)
{
	FSM_PKT *skb;

	FIN(cra_pkt_recv_from_upper());
	SV_PTR_GET(rlc_mac_sv);
    5498:	e8 fc ff ff ff       	call   5499 <rlc_mac_main+0x1659>
    549d:	89 c3                	mov    %eax,%ebx
    549f:	90                   	nop
	
	skb = (FSM_PKT *)fsm_pkt_get();
    54a0:	e8 fc ff ff ff       	call   54a1 <rlc_mac_main+0x1661>
    54a5:	89 c7                	mov    %eax,%edi
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]recv from upper\n");
    54a7:	c7 04 24 64 16 00 00 	movl   $0x1664,(%esp)
    54ae:	e8 fc ff ff ff       	call   54af <rlc_mac_main+0x166f>
	fsm_octets_print(skb->data, 64);
    54b3:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    54b9:	ba 40 00 00 00       	mov    $0x40,%edx
    54be:	e8 fc ff ff ff       	call   54bf <rlc_mac_main+0x167f>
	return Q->front == Q->rear;		//because of the head node existence, once front==rear represent the queue empty.
}

static void EnQueue(CraQueuePtr *Q, FSM_PKT *pktptr)
{
	QueueNode *p = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    54c3:	b8 08 00 00 00       	mov    $0x8,%eax
    54c8:	e8 fc ff ff ff       	call   54c9 <rlc_mac_main+0x1689>
	p->pkt = pktptr;
    54cd:	89 38                	mov    %edi,(%eax)
	p->next = NULL;
    54cf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	// 	(*Q)->front = (*Q)->rear = p;		//insert node p into a empty queue
	// else{
	// 	(*Q)->rear->next = p;
	// 	(*Q)->rear = p;
	// }
	(*Q)->rear->next = p;
    54d6:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    54dc:	8b 52 04             	mov    0x4(%edx),%edx
    54df:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->rear = p;
    54e2:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    54e8:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->pkt_count++;
    54eb:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    54f1:	66 83 40 08 01       	addw   $0x1,0x8(%eax)
	fsm_printf("[EnQueue]EnQueue successfully!\n");
    54f6:	c7 04 24 98 16 00 00 	movl   $0x1698,(%esp)
    54fd:	e8 fc ff ff ff       	call   54fe <rlc_mac_main+0x16be>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    5502:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5508:	0f b7 40 08          	movzwl 0x8(%eax),%eax
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    550c:	c7 04 24 b8 16 00 00 	movl   $0x16b8,(%esp)
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5513:	89 44 24 04          	mov    %eax,0x4(%esp)
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    5517:	e8 fc ff ff ff       	call   5518 <rlc_mac_main+0x16d8>
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
    551c:	c7 04 24 f4 16 00 00 	movl   $0x16f4,(%esp)
    5523:	e8 fc ff ff ff       	call   5524 <rlc_mac_main+0x16e4>
    5528:	e9 3b ed ff ff       	jmp    4268 <rlc_mac_main+0x428>
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    552d:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    5534:	e8 77 d4 ff ff       	call   29b0 <rlc_pkt_receive_from_upper>

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
    5539:	e8 fc ff ff ff       	call   553a <rlc_mac_main+0x16fa>
    553e:	85 c0                	test   %eax,%eax
    5540:	0f 84 c2 09 00 00    	je     5f08 <rlc_mac_main+0x20c8>
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    5546:	e8 fc ff ff ff       	call   5547 <rlc_mac_main+0x1707>
			tmpdata = *((u32*)tmpdata_ptr);//	
    554b:	8b 10                	mov    (%eax),%edx

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    554d:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    554f:	85 d2                	test   %edx,%edx
    5551:	0f 8e b9 ea ff ff    	jle    4010 <rlc_mac_main+0x1d0>
			{
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5557:	89 55 d8             	mov    %edx,-0x28(%ebp)
    555a:	c7 04 24 1c 10 00 00 	movl   $0x101c,(%esp)
    5561:	e8 fc ff ff ff       	call   5562 <rlc_mac_main+0x1722>
				//fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    5566:	8b 43 07             	mov    0x7(%ebx),%eax
    5569:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    5570:	89 44 24 04          	mov    %eax,0x4(%esp)
    5574:	e8 fc ff ff ff       	call   5575 <rlc_mac_main+0x1735>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5579:	8b 55 d8             	mov    -0x28(%ebp),%edx
    557c:	8d 43 04             	lea    0x4(%ebx),%eax
    557f:	e8 fc ff ff ff       	call   5580 <rlc_mac_main+0x1740>
    5584:	e8 fc ff ff ff       	call   5585 <rlc_mac_main+0x1745>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    5589:	89 d8                	mov    %ebx,%eax
    558b:	e8 fc ff ff ff       	call   558c <rlc_mac_main+0x174c>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5590:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5597:	74 05                	je     559e <rlc_mac_main+0x175e>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    5599:	e8 fc ff ff ff       	call   559a <rlc_mac_main+0x175a>
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    559e:	ba 02 00 00 00       	mov    $0x2,%edx
    55a3:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    55a8:	e8 fc ff ff ff       	call   55a9 <rlc_mac_main+0x1769>
				SV(ratype.ra_type)=2;
    55ad:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    55b4:	00 00 00 
    55b7:	e9 54 ea ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    55bc:	e8 fc ff ff ff       	call   55bd <rlc_mac_main+0x177d>
    55c1:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    55c7:	e8 e4 c6 ff ff       	call   1cb0 <findInsByCode>
    55cc:	85 c0                	test   %eax,%eax
    55ce:	89 c3                	mov    %eax,%ebx
    55d0:	0f 84 99 0b 00 00    	je     616f <rlc_mac_main+0x232f>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    55d6:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    55dc:	83 f8 02             	cmp    $0x2,%eax
    55df:	0f 84 3c 07 00 00    	je     5d21 <rlc_mac_main+0x1ee1>
    55e5:	0f 87 98 02 00 00    	ja     5883 <rlc_mac_main+0x1a43>
    55eb:	83 e8 01             	sub    $0x1,%eax
    55ee:	0f 84 99 05 00 00    	je     5b8d <rlc_mac_main+0x1d4d>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    55f4:	c7 04 24 b0 10 00 00 	movl   $0x10b0,(%esp)
    55fb:	e8 fc ff ff ff       	call   55fc <rlc_mac_main+0x17bc>
    5600:	e9 a5 ea ff ff       	jmp    40aa <rlc_mac_main+0x26a>
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5605:	e8 fc ff ff ff       	call   5606 <rlc_mac_main+0x17c6>
    560a:	83 f8 09             	cmp    $0x9,%eax
    560d:	8d 76 00             	lea    0x0(%esi),%esi
    5610:	0f 85 48 ea ff ff    	jne    405e <rlc_mac_main+0x21e>
	{
		FlushBj();
    5616:	e8 fc ff ff ff       	call   5617 <rlc_mac_main+0x17d7>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    561b:	ba 09 00 00 00       	mov    $0x9,%edx
    5620:	b8 64 00 00 00       	mov    $0x64,%eax
    5625:	e8 fc ff ff ff       	call   5626 <rlc_mac_main+0x17e6>
    562a:	e9 7b ea ff ff       	jmp    40aa <rlc_mac_main+0x26a>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    562f:	e8 fc ff ff ff       	call   5630 <rlc_mac_main+0x17f0>
    5634:	83 f8 09             	cmp    $0x9,%eax
    5637:	0f 85 24 ed ff ff    	jne    4361 <rlc_mac_main+0x521>
    563d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		FlushBj();
    5640:	e8 fc ff ff ff       	call   5641 <rlc_mac_main+0x1801>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    5645:	ba 09 00 00 00       	mov    $0x9,%edx
    564a:	b8 64 00 00 00       	mov    $0x64,%eax
    564f:	e8 fc ff ff ff       	call   5650 <rlc_mac_main+0x1810>
    5654:	e9 08 ed ff ff       	jmp    4361 <rlc_mac_main+0x521>
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
	{
		//decomplexUeDataPdu(fsm_pkt_get());
		decomplexUeRARPdu(fsm_pkt_get());	//modify by lxr 20160122
    5659:	e8 fc ff ff ff       	call   565a <rlc_mac_main+0x181a>
    565e:	66 90                	xchg   %ax,%ax
    5660:	e8 fc ff ff ff       	call   5661 <rlc_mac_main+0x1821>
    5665:	e9 e9 ec ff ff       	jmp    4353 <rlc_mac_main+0x513>
    566a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
	if(MAC_CLOSE)
    5670:	e8 fc ff ff ff       	call   5671 <rlc_mac_main+0x1831>
    5675:	83 f8 01             	cmp    $0x1,%eax
    5678:	0f 85 c7 ec ff ff    	jne    4345 <rlc_mac_main+0x505>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
    567e:	b8 1c 18 00 00       	mov    $0x181c,%eax
    5683:	e8 fc ff ff ff       	call   5684 <rlc_mac_main+0x1844>
		ue_mac_sv_close();
    5688:	e8 c3 d3 ff ff       	call   2a50 <ue_mac_sv_close>
    568d:	e9 b3 ec ff ff       	jmp    4345 <rlc_mac_main+0x505>
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
				SV(UL_resource_info.resource_flag)=false;
			}
			else//RRCC_RNTI2010721 LHL
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5692:	c1 ea 03             	shr    $0x3,%edx
    5695:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//20140531 ,20140718LHL:32MAC
    569b:	e8 fc ff ff ff       	call   569c <rlc_mac_main+0x185c>
    56a0:	e8 fc ff ff ff       	call   56a1 <rlc_mac_main+0x1861>
				SV(UL_resource_info.resource_flag)=false;
    56a5:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    56a9:	e9 ba eb ff ff       	jmp    4268 <rlc_mac_main+0x428>
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    56ae:	e8 fc ff ff ff       	call   56af <rlc_mac_main+0x186f>
    56b3:	83 f8 0b             	cmp    $0xb,%eax
    56b6:	0f 85 c2 e8 ff ff    	jne    3f7e <rlc_mac_main+0x13e>
    56bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    56c0:	e9 a0 f3 ff ff       	jmp    4a65 <rlc_mac_main+0xc25>
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
	{// 
		//DoResourceAllocation(SV(UL_resource_info.m_tbsize)); 
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
    56c5:	c7 04 24 6c 18 00 00 	movl   $0x186c,(%esp)
    56cc:	e8 fc ff ff ff       	call   56cd <rlc_mac_main+0x188d>
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    56d1:	8b 47 2c             	mov    0x2c(%edi),%eax
    56d4:	89 c2                	mov    %eax,%edx
    56d6:	c1 ea 03             	shr    $0x3,%edx
    56d9:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
    56df:	e8 fc ff ff ff       	call   56e0 <rlc_mac_main+0x18a0>
    56e4:	e8 fc ff ff ff       	call   56e5 <rlc_mac_main+0x18a5>
		SV(UL_resource_info.resource_flag)=false;
    56e9:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    56ed:	e9 aa ed ff ff       	jmp    449c <rlc_mac_main+0x65c>
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
		else
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=false\n");//testing code 	 
    56f2:	c7 04 24 ac 0f 00 00 	movl   $0xfac,(%esp)
    56f9:	e8 fc ff ff ff       	call   56fa <rlc_mac_main+0x18ba>
    56fe:	e9 82 fc ff ff       	jmp    5385 <rlc_mac_main+0x1545>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    5703:	e8 fc ff ff ff       	call   5704 <rlc_mac_main+0x18c4>
    5708:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    570e:	e8 9d c5 ff ff       	call   1cb0 <findInsByCode>
    5713:	89 c3                	mov    %eax,%ebx
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5715:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    571b:	83 f8 02             	cmp    $0x2,%eax
    571e:	0f 84 8f 04 00 00    	je     5bb3 <rlc_mac_main+0x1d73>
    5724:	0f 87 c2 03 00 00    	ja     5aec <rlc_mac_main+0x1cac>
    572a:	83 e8 01             	sub    $0x1,%eax
    572d:	0f 84 6d 04 00 00    	je     5ba0 <rlc_mac_main+0x1d60>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    5733:	c7 04 24 b0 10 00 00 	movl   $0x10b0,(%esp)
    573a:	e8 fc ff ff ff       	call   573b <rlc_mac_main+0x18fb>
    573f:	e9 cc e8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	else if(TimeAlignmentTimerExpire)
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5744:	e8 fc ff ff ff       	call   5745 <rlc_mac_main+0x1905>
    5749:	83 f8 09             	cmp    $0x9,%eax
    574c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5750:	0f 85 38 e8 ff ff    	jne    3f8e <rlc_mac_main+0x14e>
	{
		FlushBj();
    5756:	e8 fc ff ff ff       	call   5757 <rlc_mac_main+0x1917>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    575b:	ba 09 00 00 00       	mov    $0x9,%edx
    5760:	b8 64 00 00 00       	mov    $0x64,%eax
    5765:	e8 fc ff ff ff       	call   5766 <rlc_mac_main+0x1926>
    576a:	e9 a1 e8 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
	else if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
		u32 cmd1=fsm_ev_ioctrl_cmd();
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
    576f:	83 f8 0c             	cmp    $0xc,%eax
    5772:	0f 84 39 02 00 00    	je     59b1 <rlc_mac_main+0x1b71>
    5778:	83 f8 0e             	cmp    $0xe,%eax
    577b:	90                   	nop
    577c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5780:	0f 85 79 e8 ff ff    	jne    3fff <rlc_mac_main+0x1bf>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//
			case IOCCMD_PHYtoMAC_SYSFRAME:
				tmpdata_ptr = fsm_data_get();
    5786:	e8 fc ff ff ff       	call   5787 <rlc_mac_main+0x1947>
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
    578b:	0f b7 10             	movzwl (%eax),%edx
    578e:	66 89 57 06          	mov    %dx,0x6(%edi)
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
    5792:	0f b7 50 02          	movzwl 0x2(%eax),%edx
    5796:	66 89 57 08          	mov    %dx,0x8(%edi)
				fsm_data_destroy(tmpdata_ptr);
    579a:	e8 fc ff ff ff       	call   579b <rlc_mac_main+0x195b>
    579f:	e9 61 e8 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
	else if(IOCTRL_ARRIVAL)
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
		{
			tmpdata_ptr = (char *)fsm_data_get();
    57a4:	e8 fc ff ff ff       	call   57a5 <rlc_mac_main+0x1965>
    57a9:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//
			//print_tran_info("CON receive a RLCdatareq");//testing code
			//fsm_printf("tmpdata:%d \n",tmpdata);//testing code
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    57ab:	8b 13                	mov    (%ebx),%edx
    57ad:	8d 40 04             	lea    0x4(%eax),%eax
    57b0:	e8 fc ff ff ff       	call   57b1 <rlc_mac_main+0x1971>
    57b5:	e8 fc ff ff ff       	call   57b6 <rlc_mac_main+0x1976>
			fsm_data_destroy((void *)tmpdata_ptr);//
    57ba:	89 d8                	mov    %ebx,%eax
    57bc:	e8 fc ff ff ff       	call   57bd <rlc_mac_main+0x197d>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    57c1:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    57c8:	0f 85 67 06 00 00    	jne    5e35 <rlc_mac_main+0x1ff5>
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    57ce:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
			
			/*******for test *********/
			SV(UL_resource_info.resource_flag) = true;
    57d4:	c6 47 28 01          	movb   $0x1,0x28(%edi)
			/********for test *********/
			if(SV(UL_resource_info.resource_flag) == true)
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
    57d8:	c7 47 2c c0 2b 00 00 	movl   $0x2bc0,0x2c(%edi)
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    57df:	c7 87 f4 01 00 00 78 	movl   $0x578,0x1f4(%edi)
    57e6:	05 00 00 
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    57e9:	8d 50 05             	lea    0x5(%eax),%edx
    57ec:	39 50 05             	cmp    %edx,0x5(%eax)
    57ef:	74 0f                	je     5800 <rlc_mac_main+0x19c0>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    57f1:	b8 c0 2b 00 00       	mov    $0x2bc0,%eax
    57f6:	e8 fc ff ff ff       	call   57f7 <rlc_mac_main+0x19b7>
    57fb:	e8 fc ff ff ff       	call   57fc <rlc_mac_main+0x19bc>
				SV(UL_resource_info.resource_flag)=false;
    5800:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    5804:	e9 9c e8 ff ff       	jmp    40a5 <rlc_mac_main+0x265>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    5809:	e8 fc ff ff ff       	call   580a <rlc_mac_main+0x19ca>
    580e:	83 e8 01             	sub    $0x1,%eax
    5811:	0f 85 72 ec ff ff    	jne    4489 <rlc_mac_main+0x649>
	{
		rlc_close();
    5817:	e8 54 c5 ff ff       	call   1d70 <rlc_close>
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
    581c:	c7 04 24 27 04 00 00 	movl   $0x427,(%esp)
    5823:	e8 fc ff ff ff       	call   5824 <rlc_mac_main+0x19e4>
    5828:	e9 8b e8 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
    582d:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    5834:	00 00 00 
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5837:	31 c9                	xor    %ecx,%ecx
    5839:	ba 22 00 00 00       	mov    $0x22,%edx
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
    583e:	c7 83 e8 01 00 00 00 	movl   $0x0,0x1e8(%ebx)
    5845:	00 00 00 
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5848:	b8 05 00 00 00       	mov    $0x5,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
    584d:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    5854:	00 00 00 
		SV(ra_allocation_res)=0;
    5857:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    585e:	00 00 00 
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5861:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5868:	e8 fc ff ff ff       	call   5869 <rlc_mac_main+0x1a29>
    586d:	e9 9e e7 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
		//modified by HQ
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    5872:	c7 04 24 ac 12 00 00 	movl   $0x12ac,(%esp)
    5879:	e8 fc ff ff ff       	call   587a <rlc_mac_main+0x1a3a>
    587e:	e9 8d e7 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    5883:	83 f8 03             	cmp    $0x3,%eax
    5886:	0f 84 b2 04 00 00    	je     5d3e <rlc_mac_main+0x1efe>
    588c:	83 f8 04             	cmp    $0x4,%eax
    588f:	90                   	nop
    5890:	0f 85 5e fd ff ff    	jne    55f4 <rlc_mac_main+0x17b4>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5896:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    589a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    58a1:	c7 04 24 78 10 00 00 	movl   $0x1078,(%esp)
    58a8:	89 44 24 04          	mov    %eax,0x4(%esp)
    58ac:	e8 fc ff ff ff       	call   58ad <rlc_mac_main+0x1a6d>
			if(umRxIns->snFiledLength == 5)
    58b1:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    58b6:	0f 84 b3 05 00 00    	je     5e6f <rlc_mac_main+0x202f>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    58bc:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    58c1:	0f 85 f1 e7 ff ff    	jne    40b8 <rlc_mac_main+0x278>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    58c7:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    58ce:	bf 00 04 00 00       	mov    $0x400,%edi
    58d3:	89 ca                	mov    %ecx,%edx
    58d5:	89 c8                	mov    %ecx,%eax
    58d7:	66 c1 fa 0f          	sar    $0xf,%dx
    58db:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    58de:	0f bf fa             	movswl %dx,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    58e1:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    58e8:	83 bc bb b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edi,4)
    58ef:	00 
    58f0:	74 3b                	je     592d <rlc_mac_main+0x1aed>
    58f2:	66 39 d1             	cmp    %dx,%cx
    58f5:	7e 0e                	jle    5905 <rlc_mac_main+0x1ac5>
    58f7:	eb 34                	jmp    592d <rlc_mac_main+0x1aed>
    58f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    5900:	66 39 c1             	cmp    %ax,%cx
    5903:	7f 21                	jg     5926 <rlc_mac_main+0x1ae6>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5905:	8d 47 01             	lea    0x1(%edi),%eax
    5908:	89 c2                	mov    %eax,%edx
    590a:	c1 fa 1f             	sar    $0x1f,%edx
    590d:	c1 ea 16             	shr    $0x16,%edx
    5910:	01 d0                	add    %edx,%eax
    5912:	25 ff 03 00 00       	and    $0x3ff,%eax
    5917:	29 d0                	sub    %edx,%eax
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5919:	0f bf f8             	movswl %ax,%edi
    591c:	83 bc bb b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edi,4)
    5923:	00 
    5924:	75 da                	jne    5900 <rlc_mac_main+0x1ac0>
    5926:	66 89 83 bc 10 00 00 	mov    %ax,0x10bc(%ebx)
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    592d:	8d 53 18             	lea    0x18(%ebx),%edx
    5930:	89 d8                	mov    %ebx,%eax
    5932:	e8 fc ff ff ff       	call   5933 <rlc_mac_main+0x1af3>
    5937:	e9 7c e7 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    593c:	85 c0                	test   %eax,%eax
    593e:	74 05                	je     5945 <rlc_mac_main+0x1b05>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    5940:	e8 fc ff ff ff       	call   5941 <rlc_mac_main+0x1b01>
		SV(msg3_buf_ptr)=skb;//3
    5945:	31 c0                	xor    %eax,%eax
    5947:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    594d:	e8 fc ff ff ff       	call   594e <rlc_mac_main+0x1b0e>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5952:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5957:	89 c7                	mov    %eax,%edi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5959:	e8 fc ff ff ff       	call   595a <rlc_mac_main+0x1b1a>
    595e:	85 c0                	test   %eax,%eax
    5960:	74 1a                	je     597c <rlc_mac_main+0x1b3c>
    5962:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5966:	74 14                	je     597c <rlc_mac_main+0x1b3c>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5968:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    596f:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5976:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    597c:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5983:	00 00 00 
		complexUeMacPdu(skb);
    5986:	89 f8                	mov    %edi,%eax
    5988:	e8 fc ff ff ff       	call   5989 <rlc_mac_main+0x1b49>
		
	
		if(SV(Tbsize_Complex)!=0)
    598d:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5994:	74 0a                	je     59a0 <rlc_mac_main+0x1b60>
			SV(Tbsize_Complex)=0;//TBSIZE
    5996:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    599d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    59a0:	c7 04 24 d8 0c 00 00 	movl   $0xcd8,(%esp)
    59a7:	e8 fc ff ff ff       	call   59a8 <rlc_mac_main+0x1b68>
    59ac:	e9 d0 f8 ff ff       	jmp    5281 <rlc_mac_main+0x1441>
				SV(ratype.ra_type)=2;
			break;
			//PHYRA
			case IOCCMD_PDCCHtoMAC_RandomAcc_Req: 	
			// break	  
				tmpdata_ptr = fsm_data_get();
    59b1:	e8 fc ff ff ff       	call   59b2 <rlc_mac_main+0x1b72>
    59b6:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    59b8:	b8 3c 11 00 00       	mov    $0x113c,%eax
    59bd:	e8 fc ff ff ff       	call   59be <rlc_mac_main+0x1b7e>
				if(tmpdata_ptr > 0)//
    59c2:	85 db                	test   %ebx,%ebx
    59c4:	0f 84 80 04 00 00    	je     5e4a <rlc_mac_main+0x200a>
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
				if(tmpdata_ptr > 0)//
				{
					fsm_printf("[UEMAC][idle_default]IDLE receive a ncra order ");
    59ca:	c7 04 24 7c 11 00 00 	movl   $0x117c,(%esp)
    59d1:	e8 fc ff ff ff       	call   59d2 <rlc_mac_main+0x1b92>
					fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    59d6:	89 da                	mov    %ebx,%edx
    59d8:	b9 02 00 00 00       	mov    $0x2,%ecx
    59dd:	8d 47 04             	lea    0x4(%edi),%eax
    59e0:	e8 fc ff ff ff       	call   59e1 <rlc_mac_main+0x1ba1>
					fsm_printf("[UEMAC][idle_default]the RAPID is %d\n",SV(RA_info.ra_PreambleIndex));
    59e5:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    59e9:	c7 04 24 ac 11 00 00 	movl   $0x11ac,(%esp)
    59f0:	89 44 24 04          	mov    %eax,0x4(%esp)
    59f4:	e8 fc ff ff ff       	call   59f5 <rlc_mac_main+0x1bb5>
					if(tmpdata_ptr != NULL)
					{
						fsm_data_destroy(tmpdata_ptr);//
    59f9:	89 d8                	mov    %ebx,%eax
    59fb:	e8 fc ff ff ff       	call   59fc <rlc_mac_main+0x1bbc>
						fsm_printf("[UEMAC][idle_default]fsm_ev_data,then free the memory\n");
    5a00:	c7 04 24 d4 11 00 00 	movl   $0x11d4,(%esp)
    5a07:	e8 fc ff ff ff       	call   5a08 <rlc_mac_main+0x1bc8>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
    5a0c:	ba 01 00 00 00       	mov    $0x1,%edx
    5a11:	31 c0                	xor    %eax,%eax
    5a13:	e8 fc ff ff ff       	call   5a14 <rlc_mac_main+0x1bd4>
    5a18:	e9 e8 e5 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5a1d:	e8 fc ff ff ff       	call   5a1e <rlc_mac_main+0x1bde>
				tmpdata = *((u32*)tmpdata_ptr);//				
    5a22:	8b 10                	mov    (%eax),%edx
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5a24:	89 c3                	mov    %eax,%ebx
				tmpdata = *((u32*)tmpdata_ptr);//				
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5a26:	c7 04 24 1c 10 00 00 	movl   $0x101c,(%esp)
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
				tmpdata = *((u32*)tmpdata_ptr);//				
    5a2d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5a30:	e8 fc ff ff ff       	call   5a31 <rlc_mac_main+0x1bf1>
				fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
    5a35:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5a38:	c7 04 24 18 11 00 00 	movl   $0x1118,(%esp)
    5a3f:	89 54 24 04          	mov    %edx,0x4(%esp)
    5a43:	e8 fc ff ff ff       	call   5a44 <rlc_mac_main+0x1c04>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    5a48:	8b 43 07             	mov    0x7(%ebx),%eax
    5a4b:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    5a52:	89 44 24 04          	mov    %eax,0x4(%esp)
    5a56:	e8 fc ff ff ff       	call   5a57 <rlc_mac_main+0x1c17>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5a5b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5a5e:	8d 43 04             	lea    0x4(%ebx),%eax
    5a61:	e8 fc ff ff ff       	call   5a62 <rlc_mac_main+0x1c22>
    5a66:	e8 fc ff ff ff       	call   5a67 <rlc_mac_main+0x1c27>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    5a6b:	89 d8                	mov    %ebx,%eax
    5a6d:	e8 fc ff ff ff       	call   5a6e <rlc_mac_main+0x1c2e>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5a72:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5a79:	0f 85 c0 03 00 00    	jne    5e3f <rlc_mac_main+0x1fff>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    5a7f:	ba 02 00 00 00       	mov    $0x2,%edx
    5a84:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5a89:	e8 fc ff ff ff       	call   5a8a <rlc_mac_main+0x1c4a>
				SV(ratype.ra_type)=2;
    5a8e:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5a95:	00 00 00 
    5a98:	e9 68 e5 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//RRCRA
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
    5a9d:	e8 fc ff ff ff       	call   5a9e <rlc_mac_main+0x1c5e>
    5aa2:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5aa4:	b8 3c 11 00 00       	mov    $0x113c,%eax
    5aa9:	e8 fc ff ff ff       	call   5aaa <rlc_mac_main+0x1c6a>
				if(tmpdata_ptr > 0)//
    5aae:	85 db                	test   %ebx,%ebx
    5ab0:	0f 85 14 ff ff ff    	jne    59ca <rlc_mac_main+0x1b8a>
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5ab6:	b8 0c 12 00 00       	mov    $0x120c,%eax
    5abb:	e8 fc ff ff ff       	call   5abc <rlc_mac_main+0x1c7c>
					SV(ratype.ra_type)=3;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5ac0:	ba 02 00 00 00       	mov    $0x2,%edx
    5ac5:	31 c0                	xor    %eax,%eax
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=3;
    5ac7:	c7 87 e8 01 00 00 03 	movl   $0x3,0x1e8(%edi)
    5ace:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5ad1:	e8 fc ff ff ff       	call   5ad2 <rlc_mac_main+0x1c92>
    5ad6:	e9 2a e5 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
		rlc_pkt_receive_from_upper();

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    5adb:	c7 04 24 6c 1c 00 00 	movl   $0x1c6c,(%esp)
    5ae2:	e8 fc ff ff ff       	call   5ae3 <rlc_mac_main+0x1ca3>
    5ae7:	e9 be e5 ff ff       	jmp    40aa <rlc_mac_main+0x26a>
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5aec:	83 f8 03             	cmp    $0x3,%eax
    5aef:	0f 84 db 00 00 00    	je     5bd0 <rlc_mac_main+0x1d90>
    5af5:	83 f8 04             	cmp    $0x4,%eax
    5af8:	0f 85 35 fc ff ff    	jne    5733 <rlc_mac_main+0x18f3>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5afe:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5b02:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5b09:	c7 04 24 78 10 00 00 	movl   $0x1078,(%esp)
    5b10:	89 44 24 04          	mov    %eax,0x4(%esp)
    5b14:	e8 fc ff ff ff       	call   5b15 <rlc_mac_main+0x1cd5>
			if(umRxIns->snFiledLength == 5)
    5b19:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    5b1e:	0f 84 aa 04 00 00    	je     5fce <rlc_mac_main+0x218e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5b24:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    5b29:	0f 85 e1 e4 ff ff    	jne    4010 <rlc_mac_main+0x1d0>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5b2f:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    5b36:	bf 00 04 00 00       	mov    $0x400,%edi
    5b3b:	89 ca                	mov    %ecx,%edx
    5b3d:	89 c8                	mov    %ecx,%eax
    5b3f:	66 c1 fa 0f          	sar    $0xf,%dx
    5b43:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5b46:	bf 00 04 00 00       	mov    $0x400,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5b4b:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5b52:	eb 16                	jmp    5b6a <rlc_mac_main+0x1d2a>
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5b54:	66 39 c1             	cmp    %ax,%cx
    5b57:	7f 25                	jg     5b7e <rlc_mac_main+0x1d3e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5b59:	8d 42 01             	lea    0x1(%edx),%eax
    5b5c:	89 c2                	mov    %eax,%edx
    5b5e:	c1 fa 1f             	sar    $0x1f,%edx
    5b61:	f7 ff                	idiv   %edi
    5b63:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5b6a:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5b71:	0f bf d0             	movswl %ax,%edx
    5b74:	83 bc 93 b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edx,4)
    5b7b:	00 
    5b7c:	75 d6                	jne    5b54 <rlc_mac_main+0x1d14>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5b7e:	8d 53 18             	lea    0x18(%ebx),%edx
    5b81:	89 d8                	mov    %ebx,%eax
    5b83:	e8 fc ff ff ff       	call   5b84 <rlc_mac_main+0x1d44>
    5b88:	e9 83 e4 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5b8d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5b94:	89 d8                	mov    %ebx,%eax
    5b96:	e8 fc ff ff ff       	call   5b97 <rlc_mac_main+0x1d57>
    5b9b:	e9 18 e5 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5ba0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5ba7:	89 d8                	mov    %ebx,%eax
    5ba9:	e8 fc ff ff ff       	call   5baa <rlc_mac_main+0x1d6a>
    5bae:	e9 5d e4 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5bb3:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5bb7:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5bbe:	0f 84 4c e4 ff ff    	je     4010 <rlc_mac_main+0x1d0>
			{
				rlc_ctrl_pkt_trans(amIns);
    5bc4:	89 d8                	mov    %ebx,%eax
    5bc6:	e8 fc ff ff ff       	call   5bc7 <rlc_mac_main+0x1d87>
    5bcb:	e9 40 e4 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5bd0:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5bd7:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5bde:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5be5:	39 d0                	cmp    %edx,%eax
    5be7:	7d 29                	jge    5c12 <rlc_mac_main+0x1dd2>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5be9:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5bf0:	00 
    5bf1:	0f 84 08 03 00 00    	je     5eff <rlc_mac_main+0x20bf>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5bf7:	83 c0 01             	add    $0x1,%eax
    5bfa:	eb 12                	jmp    5c0e <rlc_mac_main+0x1dce>
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5bfc:	83 c0 01             	add    $0x1,%eax
    5bff:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5c06:	85 c9                	test   %ecx,%ecx
    5c08:	0f 84 f1 02 00 00    	je     5eff <rlc_mac_main+0x20bf>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5c0e:	39 d0                	cmp    %edx,%eax
    5c10:	75 ea                	jne    5bfc <rlc_mac_main+0x1dbc>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5c12:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5c19:	bf 00 04 00 00       	mov    $0x400,%edi
    5c1e:	89 ca                	mov    %ecx,%edx
    5c20:	89 c8                	mov    %ecx,%eax
    5c22:	66 c1 fa 0f          	sar    $0xf,%dx
    5c26:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5c29:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5c2c:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5c33:	7e 2b                	jle    5c60 <rlc_mac_main+0x1e20>
    5c35:	eb 37                	jmp    5c6e <rlc_mac_main+0x1e2e>
    5c37:	90                   	nop
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5c38:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5c3c:	74 30                	je     5c6e <rlc_mac_main+0x1e2e>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5c3e:	8d 42 01             	lea    0x1(%edx),%eax
    5c41:	89 c2                	mov    %eax,%edx
    5c43:	c1 fa 1f             	sar    $0x1f,%edx
    5c46:	c1 ea 16             	shr    $0x16,%edx
    5c49:	01 d0                	add    %edx,%eax
    5c4b:	25 ff 03 00 00       	and    $0x3ff,%eax
    5c50:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5c52:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5c55:	89 c2                	mov    %eax,%edx
    5c57:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5c5e:	7f 0e                	jg     5c6e <rlc_mac_main+0x1e2e>
    5c60:	0f bf d2             	movswl %dx,%edx
    5c63:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5c6a:	85 c0                	test   %eax,%eax
    5c6c:	75 ca                	jne    5c38 <rlc_mac_main+0x1df8>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5c6e:	8d 53 30             	lea    0x30(%ebx),%edx
    5c71:	89 d8                	mov    %ebx,%eax
    5c73:	e8 fc ff ff ff       	call   5c74 <rlc_mac_main+0x1e34>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5c78:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5c7f:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5c86:	66 39 c2             	cmp    %ax,%dx
    5c89:	7f 11                	jg     5c9c <rlc_mac_main+0x1e5c>
    5c8b:	98                   	cwtl   
    5c8c:	0f bf d2             	movswl %dx,%edx
    5c8f:	2d 00 02 00 00       	sub    $0x200,%eax
    5c94:	39 c2                	cmp    %eax,%edx
    5c96:	0f 8d 74 e3 ff ff    	jge    4010 <rlc_mac_main+0x1d0>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5c9c:	8b 53 18             	mov    0x18(%ebx),%edx
    5c9f:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5ca2:	e8 fc ff ff ff       	call   5ca3 <rlc_mac_main+0x1e63>
    5ca7:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5caa:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5cb1:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5cb8:	e9 53 e3 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5cbd:	e8 fc ff ff ff       	call   5cbe <rlc_mac_main+0x1e7e>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5cc2:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5cc7:	89 c7                	mov    %eax,%edi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5cc9:	e8 fc ff ff ff       	call   5cca <rlc_mac_main+0x1e8a>
    5cce:	85 c0                	test   %eax,%eax
    5cd0:	74 1a                	je     5cec <rlc_mac_main+0x1eac>
    5cd2:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5cd6:	74 14                	je     5cec <rlc_mac_main+0x1eac>
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5cd8:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5cdf:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5ce6:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
		}
		SV(sendmsg3)=1;	
    5cec:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5cf3:	00 00 00 
		complexUeMacPdu(skb); 	
    5cf6:	89 f8                	mov    %edi,%eax
    5cf8:	e8 fc ff ff ff       	call   5cf9 <rlc_mac_main+0x1eb9>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    5cfd:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5d04:	74 0a                	je     5d10 <rlc_mac_main+0x1ed0>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    5d06:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5d0d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    5d10:	c7 04 24 10 0d 00 00 	movl   $0xd10,(%esp)
    5d17:	e8 fc ff ff ff       	call   5d18 <rlc_mac_main+0x1ed8>
    5d1c:	e9 60 f5 ff ff       	jmp    5281 <rlc_mac_main+0x1441>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5d21:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5d25:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5d2c:	0f 84 86 e3 ff ff    	je     40b8 <rlc_mac_main+0x278>
			{
				rlc_ctrl_pkt_trans(amIns);
    5d32:	89 d8                	mov    %ebx,%eax
    5d34:	e8 fc ff ff ff       	call   5d35 <rlc_mac_main+0x1ef5>
    5d39:	e9 7a e3 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5d3e:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5d45:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5d4c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5d53:	39 d0                	cmp    %edx,%eax
    5d55:	7d 2f                	jge    5d86 <rlc_mac_main+0x1f46>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5d57:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5d5e:	00 
    5d5f:	0f 84 63 01 00 00    	je     5ec8 <rlc_mac_main+0x2088>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5d65:	83 c0 01             	add    $0x1,%eax
    5d68:	eb 18                	jmp    5d82 <rlc_mac_main+0x1f42>
    5d6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5d70:	83 c0 01             	add    $0x1,%eax
    5d73:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5d7a:	85 c9                	test   %ecx,%ecx
    5d7c:	0f 84 46 01 00 00    	je     5ec8 <rlc_mac_main+0x2088>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5d82:	39 d0                	cmp    %edx,%eax
    5d84:	75 ea                	jne    5d70 <rlc_mac_main+0x1f30>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5d86:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5d8d:	bf 00 04 00 00       	mov    $0x400,%edi
    5d92:	89 ca                	mov    %ecx,%edx
    5d94:	89 c8                	mov    %ecx,%eax
    5d96:	66 c1 fa 0f          	sar    $0xf,%dx
    5d9a:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5d9d:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5da0:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5da7:	7e 2f                	jle    5dd8 <rlc_mac_main+0x1f98>
    5da9:	eb 3b                	jmp    5de6 <rlc_mac_main+0x1fa6>
    5dab:	90                   	nop
    5dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5db0:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5db4:	74 30                	je     5de6 <rlc_mac_main+0x1fa6>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5db6:	8d 42 01             	lea    0x1(%edx),%eax
    5db9:	89 c2                	mov    %eax,%edx
    5dbb:	c1 fa 1f             	sar    $0x1f,%edx
    5dbe:	c1 ea 16             	shr    $0x16,%edx
    5dc1:	01 d0                	add    %edx,%eax
    5dc3:	25 ff 03 00 00       	and    $0x3ff,%eax
    5dc8:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5dca:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5dcd:	89 c2                	mov    %eax,%edx
    5dcf:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5dd6:	7f 0e                	jg     5de6 <rlc_mac_main+0x1fa6>
    5dd8:	0f bf d2             	movswl %dx,%edx
    5ddb:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5de2:	85 c0                	test   %eax,%eax
    5de4:	75 ca                	jne    5db0 <rlc_mac_main+0x1f70>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5de6:	8d 53 30             	lea    0x30(%ebx),%edx
    5de9:	89 d8                	mov    %ebx,%eax
    5deb:	e8 fc ff ff ff       	call   5dec <rlc_mac_main+0x1fac>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5df0:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5df7:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5dfe:	66 39 c2             	cmp    %ax,%dx
    5e01:	7f 11                	jg     5e14 <rlc_mac_main+0x1fd4>
    5e03:	98                   	cwtl   
    5e04:	0f bf d2             	movswl %dx,%edx
    5e07:	2d 00 02 00 00       	sub    $0x200,%eax
    5e0c:	39 c2                	cmp    %eax,%edx
    5e0e:	0f 8d a4 e2 ff ff    	jge    40b8 <rlc_mac_main+0x278>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5e14:	8b 53 18             	mov    0x18(%ebx),%edx
    5e17:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5e1a:	e8 fc ff ff ff       	call   5e1b <rlc_mac_main+0x1fdb>
    5e1f:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5e22:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5e29:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5e30:	e9 83 e2 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    5e35:	e8 fc ff ff ff       	call   5e36 <rlc_mac_main+0x1ff6>
    5e3a:	e9 8f f9 ff ff       	jmp    57ce <rlc_mac_main+0x198e>
    5e3f:	90                   	nop
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    5e40:	e8 fc ff ff ff       	call   5e41 <rlc_mac_main+0x2001>
    5e45:	e9 35 fc ff ff       	jmp    5a7f <rlc_mac_main+0x1c3f>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5e4a:	b8 0c 12 00 00       	mov    $0x120c,%eax
    5e4f:	e8 fc ff ff ff       	call   5e50 <rlc_mac_main+0x2010>
					SV(ratype.ra_type)=1;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5e54:	ba 02 00 00 00       	mov    $0x2,%edx
    5e59:	31 c0                	xor    %eax,%eax
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=1;
    5e5b:	c7 87 e8 01 00 00 01 	movl   $0x1,0x1e8(%edi)
    5e62:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5e65:	e8 fc ff ff ff       	call   5e66 <rlc_mac_main+0x2026>
    5e6a:	e9 96 e1 ff ff       	jmp    4005 <rlc_mac_main+0x1c5>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5e6f:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    5e76:	b9 20 00 00 00       	mov    $0x20,%ecx
    5e7b:	83 c0 01             	add    $0x1,%eax
    5e7e:	89 c2                	mov    %eax,%edx
    5e80:	c1 fa 1f             	sar    $0x1f,%edx
    5e83:	f7 f9                	idiv   %ecx
    5e85:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5e8c:	eb 1a                	jmp    5ea8 <rlc_mac_main+0x2068>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5e8e:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    5e95:	7f 22                	jg     5eb9 <rlc_mac_main+0x2079>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5e97:	8d 42 01             	lea    0x1(%edx),%eax
    5e9a:	89 c2                	mov    %eax,%edx
    5e9c:	c1 fa 1f             	sar    $0x1f,%edx
    5e9f:	f7 f9                	idiv   %ecx
    5ea1:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5ea8:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5eaf:	0f bf d0             	movswl %ax,%edx
    5eb2:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    5eb7:	75 d5                	jne    5e8e <rlc_mac_main+0x204e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5eb9:	8d 53 18             	lea    0x18(%ebx),%edx
    5ebc:	89 d8                	mov    %ebx,%eax
    5ebe:	e8 fc ff ff ff       	call   5ebf <rlc_mac_main+0x207f>
    5ec3:	e9 f4 f9 ff ff       	jmp    58bc <rlc_mac_main+0x1a7c>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    5ec8:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    5ecc:	e9 b5 fe ff ff       	jmp    5d86 <rlc_mac_main+0x1f46>
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
    5ed1:	c7 04 24 2c 17 00 00 	movl   $0x172c,(%esp)
    5ed8:	e8 fc ff ff ff       	call   5ed9 <rlc_mac_main+0x2099>
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
    5edd:	83 bb ec 01 00 00 00 	cmpl   $0x0,0x1ec(%ebx)
    5ee4:	74 0a                	je     5ef0 <rlc_mac_main+0x20b0>
    5ee6:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5eea:	0f 85 67 01 00 00    	jne    6057 <rlc_mac_main+0x2217>
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
					SV(ratype.ra_type)=2;
				}
				else//
				{
					tmpdata_ptr = (char *)fsm_data_get();
    5ef0:	e8 fc ff ff ff       	call   5ef1 <rlc_mac_main+0x20b1>
					fsm_data_destroy((void *)tmpdata_ptr);//
    5ef5:	e8 fc ff ff ff       	call   5ef6 <rlc_mac_main+0x20b6>
    5efa:	e9 69 e3 ff ff       	jmp    4268 <rlc_mac_main+0x428>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    5eff:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    5f03:	e9 0a fd ff ff       	jmp    5c12 <rlc_mac_main+0x1dd2>
		SV(countRecvFromUpper)++;
		rlc_pkt_receive_from_upper();

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    5f08:	c7 04 24 dc 0f 00 00 	movl   $0xfdc,(%esp)
    5f0f:	e8 fc ff ff ff       	call   5f10 <rlc_mac_main+0x20d0>
    5f14:	e9 f7 e0 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
		}
		reports_handler();//BSR PHR 
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    5f19:	c7 04 24 3c 12 00 00 	movl   $0x123c,(%esp)
    5f20:	e8 fc ff ff ff       	call   5f21 <rlc_mac_main+0x20e1>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    5f25:	e9 e6 e0 ff ff       	jmp    4010 <rlc_mac_main+0x1d0>
			break;

		case UM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    5f2a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    5f2d:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
    5f31:	c7 04 24 00 1a 00 00 	movl   $0x1a00,(%esp)
    5f38:	89 44 24 04          	mov    %eax,0x4(%esp)
    5f3c:	e8 fc ff ff ff       	call   5f3d <rlc_mac_main+0x20fd>
    5f41:	e9 b1 e5 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    5f46:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    5f4a:	c7 04 24 34 19 00 00 	movl   $0x1934,(%esp)
    5f51:	89 44 24 04          	mov    %eax,0x4(%esp)
    5f55:	e8 fc ff ff ff       	call   5f56 <rlc_mac_main+0x2116>
    5f5a:	e9 98 e5 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    5f5f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5f62:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    5f66:	c7 04 24 f4 18 00 00 	movl   $0x18f4,(%esp)
    5f6d:	89 44 24 04          	mov    %eax,0x4(%esp)
    5f71:	e8 fc ff ff ff       	call   5f72 <rlc_mac_main+0x2132>
    5f76:	e9 7c e5 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
	}

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		//print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
		SV(countRecvFromLower)++;
    5f7b:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
		skb=fsm_pkt_get();
    5f82:	e8 fc ff ff ff       	call   5f83 <rlc_mac_main+0x2143>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    5f87:	b9 01 00 00 00       	mov    $0x1,%ecx
    5f8c:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		//print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
		SV(countRecvFromLower)++;
		skb=fsm_pkt_get();
    5f92:	89 c3                	mov    %eax,%ebx
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    5f94:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5f97:	e8 fc ff ff ff       	call   5f98 <rlc_mac_main+0x2158>
		*pdu_type=(*pdu_type)>>6;
    5f9c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    5f9f:	0f b6 02             	movzbl (%edx),%eax
    5fa2:	c0 f8 06             	sar    $0x6,%al
    5fa5:	88 02                	mov    %al,(%edx)
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    5fa7:	0f be c0             	movsbl %al,%eax
    5faa:	89 44 24 04          	mov    %eax,0x4(%esp)
    5fae:	c7 04 24 e4 1b 00 00 	movl   $0x1be4,(%esp)
    5fb5:	e8 fc ff ff ff       	call   5fb6 <rlc_mac_main+0x2176>
		if( (*pdu_type) > 0){
    5fba:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5fbd:	80 38 00             	cmpb   $0x0,(%eax)
			fsm_pkt_destroy(skb);
    5fc0:	89 d8                	mov    %ebx,%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
    5fc2:	7f 63                	jg     6027 <rlc_mac_main+0x21e7>
			fsm_pkt_destroy(skb);
			fsm_mem_free(pdu_type);
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			FOUT;
		}
		decomplexUeDataPdu(skb);
    5fc4:	e8 fc ff ff ff       	call   5fc5 <rlc_mac_main+0x2185>
    5fc9:	e9 dc e0 ff ff       	jmp    40aa <rlc_mac_main+0x26a>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5fce:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    5fd5:	b9 20 00 00 00       	mov    $0x20,%ecx
    5fda:	83 c0 01             	add    $0x1,%eax
    5fdd:	89 c2                	mov    %eax,%edx
    5fdf:	c1 fa 1f             	sar    $0x1f,%edx
    5fe2:	f7 f9                	idiv   %ecx
    5fe4:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5feb:	eb 1a                	jmp    6007 <rlc_mac_main+0x21c7>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    5fed:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    5ff4:	7f 22                	jg     6018 <rlc_mac_main+0x21d8>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    5ff6:	8d 42 01             	lea    0x1(%edx),%eax
    5ff9:	89 c2                	mov    %eax,%edx
    5ffb:	c1 fa 1f             	sar    $0x1f,%edx
    5ffe:	f7 f9                	idiv   %ecx
    6000:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    6007:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    600e:	0f bf d0             	movswl %ax,%edx
    6011:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    6016:	75 d5                	jne    5fed <rlc_mac_main+0x21ad>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6018:	8d 53 18             	lea    0x18(%ebx),%edx
    601b:	89 d8                	mov    %ebx,%eax
    601d:	e8 fc ff ff ff       	call   601e <rlc_mac_main+0x21de>
    6022:	e9 fd fa ff ff       	jmp    5b24 <rlc_mac_main+0x1ce4>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
			fsm_pkt_destroy(skb);
    6027:	e8 fc ff ff ff       	call   6028 <rlc_mac_main+0x21e8>
			fsm_mem_free(pdu_type);
    602c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    602f:	90                   	nop
    6030:	e8 fc ff ff ff       	call   6031 <rlc_mac_main+0x21f1>
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
    6035:	c7 04 24 20 1c 00 00 	movl   $0x1c20,(%esp)
    603c:	e8 fc ff ff ff       	call   603d <rlc_mac_main+0x21fd>
    6041:	e9 72 e0 ff ff       	jmp    40b8 <rlc_mac_main+0x278>
		//print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    6046:	c7 04 24 3c 12 00 00 	movl   $0x123c,(%esp)
    604d:	e8 fc ff ff ff       	call   604e <rlc_mac_main+0x220e>
    6052:	e9 53 e0 ff ff       	jmp    40aa <rlc_mac_main+0x26a>
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
				{
					tmpdata_ptr = (char *)fsm_data_get();
    6057:	e8 fc ff ff ff       	call   6058 <rlc_mac_main+0x2218>
    605c:	89 c7                	mov    %eax,%edi
					tmpdata = *((u32*)tmpdata_ptr);//	
					DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    605e:	8b 17                	mov    (%edi),%edx
    6060:	8d 40 04             	lea    0x4(%eax),%eax
    6063:	e8 fc ff ff ff       	call   6064 <rlc_mac_main+0x2224>
    6068:	e8 fc ff ff ff       	call   6069 <rlc_mac_main+0x2229>
					//tmpdata_ptr+sizeof(int)//4 
					fsm_data_destroy((void *)tmpdata_ptr);//
    606d:	89 f8                	mov    %edi,%eax
    606f:	e8 fc ff ff ff       	call   6070 <rlc_mac_main+0x2230>
					if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    6074:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    607b:	74 05                	je     6082 <rlc_mac_main+0x2242>
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    607d:	e8 fc ff ff ff       	call   607e <rlc_mac_main+0x223e>
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    6082:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
					//cra_success();//
					//IOCTL

					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    6088:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
    608c:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    6090:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    6097:	85 c0                	test   %eax,%eax
					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
    6099:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    60a0:	00 00 00 
					if(SV(msg3_buf_ptr) != NULL)
    60a3:	74 0f                	je     60b4 <rlc_mac_main+0x2274>
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    60a5:	e8 fc ff ff ff       	call   60a6 <rlc_mac_main+0x2266>
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    60aa:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    60b1:	00 00 00 
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
					if(SV(CRTimer.flag)==true) //CR
    60b4:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
					if(SV(msg3_buf_ptr) != NULL)
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
    60bb:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
					if(SV(CRTimer.flag)==true) //CR
    60c1:	74 1b                	je     60de <rlc_mac_main+0x229e>
					{
						SV(CRTimer.timer_sign)= NULL;
    60c3:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    60ca:	00 00 00 
						SV(CRTimer.flag)= false;
    60cd:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
						SV(CRTimer.time_value)=0;
    60d4:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    60db:	00 00 00 
					}
					SV(sendmsg3)=0;//MSG30
    60de:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    60e5:	00 00 00 
					//SV(ratype.ra_type)=0;//0 
					SV(pdcch_rnti)=0;
    60e8:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    60ef:	00 00 00 
					/*************/
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
    60f2:	e8 19 d0 ff ff       	call   3110 <doStartContentionBasedRandomAccessProcedure>
					SV(ratype.ra_type)=2;
    60f7:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    60fe:	00 00 00 
    6101:	e9 62 e1 ff ff       	jmp    4268 <rlc_mac_main+0x428>
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    6106:	e8 fc ff ff ff       	call   6107 <rlc_mac_main+0x22c7>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    610b:	b9 01 00 00 00       	mov    $0x1,%ecx
    6110:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    6116:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    6119:	89 f8                	mov    %edi,%eax
    611b:	e8 fc ff ff ff       	call   611c <rlc_mac_main+0x22dc>
		*pdu_type=(*pdu_type)>>6;
    6120:	0f b6 07             	movzbl (%edi),%eax
    6123:	c0 f8 06             	sar    $0x6,%al
    6126:	88 07                	mov    %al,(%edi)
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    6128:	0f be c0             	movsbl %al,%eax
    612b:	89 44 24 04          	mov    %eax,0x4(%esp)
    612f:	c7 04 24 fc 14 00 00 	movl   $0x14fc,(%esp)
    6136:	e8 fc ff ff ff       	call   6137 <rlc_mac_main+0x22f7>
		if(SV(sendmsg3)==0){
    613b:	8b 83 ec 01 00 00    	mov    0x1ec(%ebx),%eax
    6141:	85 c0                	test   %eax,%eax
    6143:	75 58                	jne    619d <rlc_mac_main+0x235d>
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    6145:	0f b6 07             	movzbl (%edi),%eax
    6148:	83 e8 01             	sub    $0x1,%eax
    614b:	3c 02                	cmp    $0x2,%al
				decomplexUeRARPdu(skb);
    614d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if(SV(sendmsg3)==0){
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    6150:	77 2e                	ja     6180 <rlc_mac_main+0x2340>
				decomplexUeRARPdu(skb);
    6152:	e8 fc ff ff ff       	call   6153 <rlc_mac_main+0x2313>
				fsm_mem_free(pdu_type);
    6157:	89 f8                	mov    %edi,%eax
    6159:	e8 fc ff ff ff       	call   615a <rlc_mac_main+0x231a>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
    615e:	c7 04 24 38 15 00 00 	movl   $0x1538,(%esp)
    6165:	e8 fc ff ff ff       	call   6166 <rlc_mac_main+0x2326>
    616a:	e9 f9 e0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
    616f:	c7 04 24 c0 1c 00 00 	movl   $0x1cc0,(%esp)
    6176:	e8 fc ff ff ff       	call   6177 <rlc_mac_main+0x2337>
    617b:	e9 38 df ff ff       	jmp    40b8 <rlc_mac_main+0x278>
				decomplexUeRARPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    6180:	e8 fc ff ff ff       	call   6181 <rlc_mac_main+0x2341>
				fsm_mem_free(pdu_type);
    6185:	89 f8                	mov    %edi,%eax
    6187:	e8 fc ff ff ff       	call   6188 <rlc_mac_main+0x2348>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
    618c:	c7 04 24 7c 15 00 00 	movl   $0x157c,(%esp)
    6193:	e8 fc ff ff ff       	call   6194 <rlc_mac_main+0x2354>
    6198:	e9 cb e0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
    619d:	83 e8 01             	sub    $0x1,%eax
    61a0:	0f 85 c2 e0 ff ff    	jne    4268 <rlc_mac_main+0x428>
			if( (*pdu_type) == 0){  
    61a6:	80 3f 00             	cmpb   $0x0,(%edi)
				decomplexUeDataPdu(skb);
    61a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
			if( (*pdu_type) == 0){  
    61ac:	75 67                	jne    6215 <rlc_mac_main+0x23d5>
				decomplexUeDataPdu(skb);
    61ae:	e8 fc ff ff ff       	call   61af <rlc_mac_main+0x236f>
				fsm_mem_free(pdu_type);
    61b3:	89 f8                	mov    %edi,%eax
    61b5:	e8 fc ff ff ff       	call   61b6 <rlc_mac_main+0x2376>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
    61ba:	c7 04 24 d0 15 00 00 	movl   $0x15d0,(%esp)
    61c1:	e8 fc ff ff ff       	call   61c2 <rlc_mac_main+0x2382>
    61c6:	e9 9d e0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    61cb:	83 86 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%esi)
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
    61d2:	c7 04 24 40 1b 00 00 	movl   $0x1b40,(%esp)
    61d9:	e8 fc ff ff ff       	call   61da <rlc_mac_main+0x239a>
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    61de:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    61e4:	c7 04 24 f8 1a 00 00 	movl   $0x1af8,(%esp)
    61eb:	89 44 24 04          	mov    %eax,0x4(%esp)
    61ef:	e8 fc ff ff ff       	call   61f0 <rlc_mac_main+0x23b0>
    61f4:	e9 fe e2 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    61f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    61fc:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    6200:	c7 04 24 00 1a 00 00 	movl   $0x1a00,(%esp)
    6207:	89 44 24 04          	mov    %eax,0x4(%esp)
    620b:	e8 fc ff ff ff       	call   620c <rlc_mac_main+0x23cc>
    6210:	e9 e2 e2 ff ff       	jmp    44f7 <rlc_mac_main+0x6b7>
				decomplexUeDataPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    6215:	e8 fc ff ff ff       	call   6216 <rlc_mac_main+0x23d6>
				fsm_mem_free(pdu_type);
    621a:	89 f8                	mov    %edi,%eax
    621c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    6220:	e8 fc ff ff ff       	call   6221 <rlc_mac_main+0x23e1>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a other PDU !!!\n");
    6225:	c7 04 24 1c 16 00 00 	movl   $0x161c,(%esp)
    622c:	e8 fc ff ff ff       	call   622d <rlc_mac_main+0x23ed>
    6231:	e9 32 e0 ff ff       	jmp    4268 <rlc_mac_main+0x428>
    6236:	8d 76 00             	lea    0x0(%esi),%esi
    6239:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00006240 <findInsBylcid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsBylcid(u8 lcid, void **up, void**down, RlcMode *mode)
{
    6240:	55                   	push   %ebp
    6241:	89 e5                	mov    %esp,%ebp
    6243:	57                   	push   %edi
    6244:	56                   	push   %esi
    6245:	53                   	push   %ebx
    6246:	83 ec 10             	sub    $0x10,%esp
    6249:	e8 fc ff ff ff       	call   624a <findInsBylcid+0xa>
    624e:	8b 75 08             	mov    0x8(%ebp),%esi
    6251:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6254:	89 c3                	mov    %eax,%ebx
    6256:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsBylcid());
	SV_PTR_GET(rlc_mac_sv);
    6259:	e8 fc ff ff ff       	call   625a <findInsBylcid+0x1a>
	*up = *down = NULL;
    625e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6261:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6264:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    626a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    6270:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    6276:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    627c:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    6282:	39 d1                	cmp    %edx,%ecx
    6284:	74 29                	je     62af <findInsBylcid+0x6f>
    6286:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6289:	8b 7d ec             	mov    -0x14(%ebp),%edi
    628c:	eb 08                	jmp    6296 <findInsBylcid+0x56>
    628e:	66 90                	xchg   %ax,%ax
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6290:	8b 12                	mov    (%edx),%edx
    6292:	39 d1                	cmp    %edx,%ecx
    6294:	74 16                	je     62ac <findInsBylcid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->lcId == lcid)
    6296:	38 5a e7             	cmp    %bl,-0x19(%edx)
    6299:	75 f5                	jne    6290 <findInsBylcid+0x50>
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    629b:	8d 42 e4             	lea    -0x1c(%edx),%eax
			if(tmTxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    629e:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    62a4:	89 07                	mov    %eax,(%edi)
	SV_PTR_GET(rlc_mac_sv);
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    62a6:	8b 12                	mov    (%edx),%edx
    62a8:	39 d1                	cmp    %edx,%ecx
    62aa:	75 ea                	jne    6296 <findInsBylcid+0x56>
    62ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    62af:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up =  (void*)tmTxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    62b5:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    62bb:	39 d1                	cmp    %edx,%ecx
    62bd:	74 28                	je     62e7 <findInsBylcid+0xa7>
    62bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    62c2:	8b 7d e8             	mov    -0x18(%ebp),%edi
    62c5:	eb 07                	jmp    62ce <findInsBylcid+0x8e>
    62c7:	90                   	nop
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    62c8:	8b 12                	mov    (%edx),%edx
    62ca:	39 d1                	cmp    %edx,%ecx
    62cc:	74 16                	je     62e4 <findInsBylcid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->lcId == lcid)
    62ce:	38 5a fb             	cmp    %bl,-0x5(%edx)
    62d1:	75 f5                	jne    62c8 <findInsBylcid+0x88>
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    62d3:	8d 42 f8             	lea    -0x8(%edx),%eax
			if(tmRxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    62d6:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    62dc:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    62de:	8b 12                	mov    (%edx),%edx
    62e0:	39 d1                	cmp    %edx,%ecx
    62e2:	75 ea                	jne    62ce <findInsBylcid+0x8e>
    62e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down =  (void*)tmRxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if(*mode == TM_MODE)
    62e7:	83 3e 01             	cmpl   $0x1,(%esi)
    62ea:	0f 84 c8 00 00 00    	je     63b8 <findInsBylcid+0x178>
    62f0:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    62f6:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    62fc:	39 d1                	cmp    %edx,%ecx
    62fe:	74 27                	je     6327 <findInsBylcid+0xe7>
    6300:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6303:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6306:	eb 06                	jmp    630e <findInsBylcid+0xce>
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    6308:	8b 12                	mov    (%edx),%edx
    630a:	39 d1                	cmp    %edx,%ecx
    630c:	74 16                	je     6324 <findInsBylcid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->lcid == lcid)
    630e:	38 5a d3             	cmp    %bl,-0x2d(%edx)
    6311:	75 f5                	jne    6308 <findInsBylcid+0xc8>
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    6313:	8d 42 d0             	lea    -0x30(%edx),%eax
			if(umTxIns->lcid == lcid)
			{
				*mode = UM_MODE;
    6316:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    631c:	89 07                	mov    %eax,(%edi)
	}
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    631e:	8b 12                	mov    (%edx),%edx
    6320:	39 d1                	cmp    %edx,%ecx
    6322:	75 ea                	jne    630e <findInsBylcid+0xce>
    6324:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6327:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*mode = UM_MODE;
				*up =  (void*)umTxIns;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    632d:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    6333:	39 d1                	cmp    %edx,%ecx
    6335:	74 2e                	je     6365 <findInsBylcid+0x125>
    6337:	89 45 f0             	mov    %eax,-0x10(%ebp)
    633a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    633d:	eb 07                	jmp    6346 <findInsBylcid+0x106>
    633f:	90                   	nop
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    6340:	8b 12                	mov    (%edx),%edx
    6342:	39 d1                	cmp    %edx,%ecx
    6344:	74 1c                	je     6362 <findInsBylcid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->lcId == lcid)
    6346:	38 9a 3f ef ff ff    	cmp    %bl,-0x10c1(%edx)
    634c:	75 f2                	jne    6340 <findInsBylcid+0x100>
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    634e:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
			if(umRxIns->lcId == lcid)
			{
				*mode = UM_MODE;
    6354:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    635a:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    635c:	8b 12                	mov    (%edx),%edx
    635e:	39 d1                	cmp    %edx,%ecx
    6360:	75 e4                	jne    6346 <findInsBylcid+0x106>
    6362:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*mode = UM_MODE;
				*down =  (void*)umRxIns;
			}
		}
	}
	if(*mode == UM_MODE)
    6365:	83 3e 02             	cmpl   $0x2,(%esi)
    6368:	74 4e                	je     63b8 <findInsBylcid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    636a:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    6370:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    6376:	39 c2                	cmp    %eax,%edx
    6378:	74 3e                	je     63b8 <findInsBylcid+0x178>
    637a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    637d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    6380:	eb 0c                	jmp    638e <findInsBylcid+0x14e>
    6382:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    6388:	8b 00                	mov    (%eax),%eax
    638a:	39 c2                	cmp    %eax,%edx
    638c:	74 2a                	je     63b8 <findInsBylcid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->lcId == lcid)
    638e:	38 98 ff dc ff ff    	cmp    %bl,-0x2301(%eax)
    6394:	75 f2                	jne    6388 <findInsBylcid+0x148>
			{
				*mode = AM_MODE;
    6396:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    6399:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->lcId == lcid)
			{
				*mode = AM_MODE;
    639f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    63a5:	8b 75 ec             	mov    -0x14(%ebp),%esi
    63a8:	89 0f                	mov    %ecx,(%edi)
    63aa:	89 0e                	mov    %ecx,(%esi)
	}
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    63ac:	8b 00                	mov    (%eax),%eax
    63ae:	39 c2                	cmp    %eax,%edx
    63b0:	75 dc                	jne    638e <findInsBylcid+0x14e>
    63b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				//      fsm_printf("am instance(lcid is %d)\n",lcid);
			}
		}
	}
	FOUT;
}
    63b8:	83 c4 10             	add    $0x10,%esp
    63bb:	5b                   	pop    %ebx
    63bc:	5e                   	pop    %esi
    63bd:	5f                   	pop    %edi
    63be:	5d                   	pop    %ebp
    63bf:	c3                   	ret    

000063c0 <isInsideTranWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideTranWin(struct AM_Instance *amIns, SequenceNumber SN)
{
    63c0:	55                   	push   %ebp
    63c1:	89 e5                	mov    %esp,%ebp
    63c3:	53                   	push   %ebx
    63c4:	e8 fc ff ff ff       	call   63c5 <isInsideTranWin+0x5>
	//printk("[RLC][isInsideTranWin] vt_a=%d, vt_ms=%d, SN=%d\n",amIns->vt_a, amIns->vt_ms, SN);
	//return((amIns->vt_a <= SN)&&(SN < amIns->vt_ms));
	return (SN-amIns->vt_a+1024)%1024 < (amIns->vt_ms-amIns->vt_a+1024)%1024;
    63c9:	0f bf 98 66 12 00 00 	movswl 0x1266(%eax),%ebx
    63d0:	0f bf 80 68 12 00 00 	movswl 0x1268(%eax),%eax
    63d7:	0f bf d2             	movswl %dx,%edx
    63da:	29 da                	sub    %ebx,%edx
    63dc:	81 c2 00 04 00 00    	add    $0x400,%edx
    63e2:	29 d8                	sub    %ebx,%eax
    63e4:	89 d1                	mov    %edx,%ecx
    63e6:	05 00 04 00 00       	add    $0x400,%eax
    63eb:	c1 f9 1f             	sar    $0x1f,%ecx
    63ee:	c1 e9 16             	shr    $0x16,%ecx
    63f1:	01 ca                	add    %ecx,%edx
    63f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    63f9:	29 ca                	sub    %ecx,%edx
    63fb:	89 c1                	mov    %eax,%ecx
    63fd:	c1 f9 1f             	sar    $0x1f,%ecx
    6400:	c1 e9 16             	shr    $0x16,%ecx
    6403:	01 c8                	add    %ecx,%eax
    6405:	25 ff 03 00 00       	and    $0x3ff,%eax
    640a:	29 c8                	sub    %ecx,%eax
    640c:	39 c2                	cmp    %eax,%edx
    640e:	0f 9c c0             	setl   %al
}
    6411:	5b                   	pop    %ebx
    6412:	5d                   	pop    %ebp
    6413:	c3                   	ret    
    6414:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    641a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00006420 <isInsideAmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    6420:	55                   	push   %ebp
    6421:	89 e5                	mov    %esp,%ebp
    6423:	56                   	push   %esi
    6424:	53                   	push   %ebx
    6425:	83 ec 14             	sub    $0x14,%esp
    6428:	e8 fc ff ff ff       	call   6429 <isInsideAmRecvWin+0x9>
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    642d:	0f bf 88 ec 22 00 00 	movswl 0x22ec(%eax),%ecx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    6434:	89 c3                	mov    %eax,%ebx
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    6436:	0f bf 80 f4 22 00 00 	movswl 0x22f4(%eax),%eax
    643d:	0f bf f2             	movswl %dx,%esi
    6440:	89 ca                	mov    %ecx,%edx
    6442:	89 74 24 0c          	mov    %esi,0xc(%esp)
    6446:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    644a:	29 c2                	sub    %eax,%edx
    644c:	89 54 24 10          	mov    %edx,0x10(%esp)
    6450:	89 44 24 04          	mov    %eax,0x4(%esp)
    6454:	c7 04 24 f8 1c 00 00 	movl   $0x1cf8,(%esp)
    645b:	e8 fc ff ff ff       	call   645c <isInsideAmRecvWin+0x3c>
	return (SN-amIns->vr_r+1024)%1024 < (amIns->vr_mr-amIns->vr_r+1024)%1024;
    6460:	0f bf 93 f4 22 00 00 	movswl 0x22f4(%ebx),%edx
    6467:	29 d6                	sub    %edx,%esi
    6469:	81 c6 00 04 00 00    	add    $0x400,%esi
    646f:	89 f0                	mov    %esi,%eax
    6471:	c1 f8 1f             	sar    $0x1f,%eax
    6474:	c1 e8 16             	shr    $0x16,%eax
    6477:	01 c6                	add    %eax,%esi
    6479:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    647f:	29 c6                	sub    %eax,%esi
    6481:	0f bf 83 ec 22 00 00 	movswl 0x22ec(%ebx),%eax
    6488:	29 d0                	sub    %edx,%eax
    648a:	05 00 04 00 00       	add    $0x400,%eax
    648f:	89 c2                	mov    %eax,%edx
    6491:	c1 fa 1f             	sar    $0x1f,%edx
    6494:	c1 ea 16             	shr    $0x16,%edx
    6497:	01 d0                	add    %edx,%eax
    6499:	25 ff 03 00 00       	and    $0x3ff,%eax
    649e:	29 d0                	sub    %edx,%eax
    64a0:	39 c6                	cmp    %eax,%esi
    64a2:	0f 9c c0             	setl   %al
}
    64a5:	83 c4 14             	add    $0x14,%esp
    64a8:	5b                   	pop    %ebx
    64a9:	5e                   	pop    %esi
    64aa:	5d                   	pop    %ebp
    64ab:	c3                   	ret    
    64ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000064b0 <isInsideUmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    64b0:	55                   	push   %ebp
    64b1:	89 e5                	mov    %esp,%ebp
    64b3:	e8 fc ff ff ff       	call   64b4 <isInsideUmRecvWin+0x4>
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    64b8:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    64bd:	0f bf 80 c0 10 00 00 	movswl 0x10c0(%eax),%eax
    64c4:	0f bf d2             	movswl %dx,%edx
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    64c7:	74 27                	je     64f0 <isInsideUmRecvWin+0x40>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    64c9:	29 c2                	sub    %eax,%edx
    64cb:	81 c2 00 06 00 00    	add    $0x600,%edx
    64d1:	89 d0                	mov    %edx,%eax
    64d3:	c1 f8 1f             	sar    $0x1f,%eax
    64d6:	c1 e8 16             	shr    $0x16,%eax
    64d9:	01 c2                	add    %eax,%edx
    64db:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    64e1:	29 c2                	sub    %eax,%edx
    64e3:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    64e9:	0f 9e c0             	setle  %al
	}
}
    64ec:	5d                   	pop    %ebp
    64ed:	c3                   	ret    
    64ee:	66 90                	xchg   %ax,%ax
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    64f0:	29 c2                	sub    %eax,%edx
    64f2:	83 c2 30             	add    $0x30,%edx
    64f5:	89 d0                	mov    %edx,%eax
    64f7:	c1 f8 1f             	sar    $0x1f,%eax
    64fa:	c1 e8 1b             	shr    $0x1b,%eax
    64fd:	01 c2                	add    %eax,%edx
    64ff:	83 e2 1f             	and    $0x1f,%edx
    6502:	29 c2                	sub    %eax,%edx
    6504:	83 fa 0f             	cmp    $0xf,%edx
    6507:	0f 9e c0             	setle  %al
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
	}
}
    650a:	5d                   	pop    %ebp
    650b:	c3                   	ret    
    650c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006510 <isOrderedUm>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isOrderedUm(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6510:	55                   	push   %ebp
    6511:	89 e5                	mov    %esp,%ebp
    6513:	53                   	push   %ebx
    6514:	e8 fc ff ff ff       	call   6515 <isOrderedUm+0x5>
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6519:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    651e:	0f bf 98 c0 10 00 00 	movswl 0x10c0(%eax),%ebx
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6525:	74 51                	je     6578 <isOrderedUm+0x68>
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
	}
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
    6527:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    652e:	b9 00 02 00 00       	mov    $0x200,%ecx
    6533:	0f bf d2             	movswl %dx,%edx
    6536:	29 d9                	sub    %ebx,%ecx
    6538:	8d 94 11 00 04 00 00 	lea    0x400(%ecx,%edx,1),%edx
    653f:	89 d3                	mov    %edx,%ebx
    6541:	8d 84 01 00 04 00 00 	lea    0x400(%ecx,%eax,1),%eax
    6548:	89 c1                	mov    %eax,%ecx
    654a:	c1 fb 1f             	sar    $0x1f,%ebx
    654d:	c1 f9 1f             	sar    $0x1f,%ecx
    6550:	c1 eb 16             	shr    $0x16,%ebx
    6553:	c1 e9 16             	shr    $0x16,%ecx
    6556:	01 da                	add    %ebx,%edx
    6558:	01 c8                	add    %ecx,%eax
    655a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6560:	25 ff 03 00 00       	and    $0x3ff,%eax
    6565:	29 da                	sub    %ebx,%edx
    6567:	29 c8                	sub    %ecx,%eax
    6569:	39 c2                	cmp    %eax,%edx
    656b:	0f 9c c0             	setl   %al
	}
}
    656e:	5b                   	pop    %ebx
    656f:	5d                   	pop    %ebp
    6570:	c3                   	ret    
    6571:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    6578:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    657f:	b9 10 00 00 00       	mov    $0x10,%ecx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6584:	0f bf d2             	movswl %dx,%edx
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    6587:	29 d9                	sub    %ebx,%ecx
    6589:	8d 54 11 20          	lea    0x20(%ecx,%edx,1),%edx
    658d:	89 d3                	mov    %edx,%ebx
    658f:	8d 44 01 20          	lea    0x20(%ecx,%eax,1),%eax
    6593:	89 c1                	mov    %eax,%ecx
    6595:	c1 fb 1f             	sar    $0x1f,%ebx
    6598:	c1 f9 1f             	sar    $0x1f,%ecx
    659b:	c1 eb 1b             	shr    $0x1b,%ebx
    659e:	c1 e9 1b             	shr    $0x1b,%ecx
    65a1:	01 da                	add    %ebx,%edx
    65a3:	01 c8                	add    %ecx,%eax
    65a5:	83 e2 1f             	and    $0x1f,%edx
    65a8:	83 e0 1f             	and    $0x1f,%eax
    65ab:	29 da                	sub    %ebx,%edx
    65ad:	29 c8                	sub    %ecx,%eax
    65af:	39 c2                	cmp    %eax,%edx
    65b1:	0f 9c c0             	setl   %al
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
	}
}
    65b4:	5b                   	pop    %ebx
    65b5:	5d                   	pop    %ebp
    65b6:	c3                   	ret    
    65b7:	89 f6                	mov    %esi,%esi
    65b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000065c0 <countSegInd>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
    65c0:	55                   	push   %ebp
    65c1:	89 e5                	mov    %esp,%ebp
    65c3:	e8 fc ff ff ff       	call   65c4 <countSegInd+0x4>
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    65c8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    65ce:	31 c0                	xor    %eax,%eax
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    65d0:	f6 42 01 04          	testb  $0x4,0x1(%edx)
    65d4:	74 20                	je     65f6 <countSegInd+0x36>
	{
		count++;
		while(1 == (ind++)->E)
    65d6:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    65da:	b0 01                	mov    $0x1,%al
    65dc:	79 18                	jns    65f6 <countSegInd+0x36>
    65de:	83 c2 06             	add    $0x6,%edx
    65e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    65e8:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
		{
			count++;
    65ec:	83 c0 01             	add    $0x1,%eax
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    65ef:	83 c2 02             	add    $0x2,%edx
    65f2:	84 c9                	test   %cl,%cl
    65f4:	78 f2                	js     65e8 <countSegInd+0x28>
		{
			count++;
		}
	}
	return count;
}
    65f6:	5d                   	pop    %ebp
    65f7:	c3                   	ret    
    65f8:	90                   	nop
    65f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006600 <assamble_segment>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6600:	55                   	push   %ebp
    6601:	89 e5                	mov    %esp,%ebp
    6603:	57                   	push   %edi
    6604:	56                   	push   %esi
    6605:	53                   	push   %ebx
    6606:	83 ec 20             	sub    $0x20,%esp
    6609:	e8 fc ff ff ff       	call   660a <assamble_segment+0xa>
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    660e:	8b 9a ac 00 00 00    	mov    0xac(%edx),%ebx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6614:	89 c6                	mov    %eax,%esi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6616:	8b 00                	mov    (%eax),%eax
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6618:	89 55 ec             	mov    %edx,-0x14(%ebp)
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    661b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    661e:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6625:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    662b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    662e:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    6632:	74 34                	je     6668 <assamble_segment+0x68>
	{
		count++;
		while(1 == (ind++)->E)
    6634:	c7 45 e8 06 00 00 00 	movl   $0x6,-0x18(%ebp)
    663b:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    663f:	79 27                	jns    6668 <assamble_segment+0x68>
    6641:	83 c0 06             	add    $0x6,%eax
    6644:	ba 01 00 00 00       	mov    $0x1,%edx
    6649:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    6650:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    6654:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    6657:	83 c0 02             	add    $0x2,%eax
    665a:	84 c9                	test   %cl,%cl
    665c:	78 f2                	js     6650 <assamble_segment+0x50>
    665e:	8d 54 12 04          	lea    0x4(%edx,%edx,1),%edx
    6662:	0f b7 d2             	movzwl %dx,%edx
    6665:	89 55 e8             	mov    %edx,-0x18(%ebp)
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    6668:	8b 7d f0             	mov    -0x10(%ebp),%edi
	u32 posEnd = posStart + pkt->len - headLen;
    666b:	8b 55 ec             	mov    -0x14(%ebp),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    666e:	0f b6 5f 03          	movzbl 0x3(%edi),%ebx
    6672:	0f b6 47 02          	movzbl 0x2(%edi),%eax
	u32 posEnd = posStart + pkt->len - headLen;
    6676:	8b 4a 50             	mov    0x50(%edx),%ecx
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6679:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    667f:	83 e3 7f             	and    $0x7f,%ebx
    6682:	c1 e3 08             	shl    $0x8,%ebx
    6685:	09 c3                	or     %eax,%ebx
	u32 posEnd = posStart + pkt->len - headLen;
    6687:	8d 3c 0b             	lea    (%ebx,%ecx,1),%edi
    668a:	89 7d e0             	mov    %edi,-0x20(%ebp)
    668d:	2b 7d e8             	sub    -0x18(%ebp),%edi
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6690:	85 d2                	test   %edx,%edx
    6692:	74 1b                	je     66af <assamble_segment+0xaf>
    6694:	31 c0                	xor    %eax,%eax
    6696:	66 90                	xchg   %ax,%ax
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
    6698:	3b 5c 86 10          	cmp    0x10(%esi,%eax,4),%ebx
    669c:	72 0a                	jb     66a8 <assamble_segment+0xa8>
    669e:	3b 7c 86 50          	cmp    0x50(%esi,%eax,4),%edi
    66a2:	0f 86 50 01 00 00    	jbe    67f8 <assamble_segment+0x1f8>
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    66a8:	83 c0 01             	add    $0x1,%eax
    66ab:	39 d0                	cmp    %edx,%eax
    66ad:	75 e9                	jne    6698 <assamble_segment+0x98>
	char *posbuf = (char*)ambuf->pkt->data;
	int i, j,datalen = 0;
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
    66af:	8b 45 f0             	mov    -0x10(%ebp),%eax
    66b2:	03 45 e8             	add    -0x18(%ebp),%eax
    66b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	}
	//fsm_printf("[RLC][assamble_segment] ambuf->datalen is %d\n",ambuf->datalen);
	//fsm_printf("[RLC][assamble_segment] ambuf->segEnd[ambuf->segnum - 1] is %d\n",ambuf->segEnd[ambuf->segnum - 1]);
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
    66b8:	8d 42 ff             	lea    -0x1(%edx),%eax
    66bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    66be:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    66c2:	39 c7                	cmp    %eax,%edi
    66c4:	0f 82 3e 01 00 00    	jb     6808 <assamble_segment+0x208>
	//
	else
	{
		//fsm_printf("[RLC][assamble_segment] have not received the last segment\n");
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
    66ca:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    66cd:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    66d1:	78 6d                	js     6740 <assamble_segment+0x140>
    66d3:	39 c7                	cmp    %eax,%edi
    66d5:	77 69                	ja     6740 <assamble_segment+0x140>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
		ambuf->datalen = datalen;
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    66d7:	39 c3                	cmp    %eax,%ebx
    66d9:	0f 87 f9 00 00 00    	ja     67d8 <assamble_segment+0x1d8>
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    66df:	8b 55 dc             	mov    -0x24(%ebp),%edx
    66e2:	85 d2                	test   %edx,%edx
    66e4:	7e 3b                	jle    6721 <assamble_segment+0x121>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    66e6:	8d 44 96 10          	lea    0x10(%esi,%edx,4),%eax
    66ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
			{
				//10:
				if((ambuf->segStart[i] <= posStart)&&(posStart <= ambuf->segEnd[i]))
    66f0:	8b 08                	mov    (%eax),%ecx
    66f2:	39 cb                	cmp    %ecx,%ebx
    66f4:	72 09                	jb     66ff <assamble_segment+0xff>
    66f6:	3b 58 40             	cmp    0x40(%eax),%ebx
    66f9:	0f 86 5f 02 00 00    	jbe    695e <assamble_segment+0x35e>
					ambuf->segEnd[i] = posEnd;
					ambuf->segnum = i + 1;
					FOUT;
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
    66ff:	3b 58 3c             	cmp    0x3c(%eax),%ebx
    6702:	76 08                	jbe    670c <assamble_segment+0x10c>
    6704:	39 cb                	cmp    %ecx,%ebx
    6706:	0f 86 4e 02 00 00    	jbe    695a <assamble_segment+0x35a>
					ambuf->segnum = i + 1;
					FOUT;
				}
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
    670c:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    6713:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    6719:	83 e8 04             	sub    $0x4,%eax
    671c:	83 ea 01             	sub    $0x1,%edx
    671f:	75 cf                	jne    66f0 <assamble_segment+0xf0>
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
				}
			}
			if(posStart > ambuf->segStart[0])
    6721:	3b 5e 10             	cmp    0x10(%esi),%ebx
    6724:	77 03                	ja     6729 <assamble_segment+0x129>
				ambuf->segnum = 1;
				FOUT;
			}
            else
            {
	            ambuf->segStart[0]  = posStart;
    6726:	89 5e 10             	mov    %ebx,0x10(%esi)
	            ambuf->segEnd[0] = posEnd;
    6729:	89 7e 50             	mov    %edi,0x50(%esi)
	            ambuf->segnum = 1;
    672c:	c7 86 90 00 00 00 01 	movl   $0x1,0x90(%esi)
    6733:	00 00 00 
	            FOUT;
			}
		}
	}
}
    6736:	83 c4 20             	add    $0x20,%esp
    6739:	5b                   	pop    %ebx
    673a:	5e                   	pop    %esi
    673b:	5f                   	pop    %edi
    673c:	5d                   	pop    %ebp
    673d:	c3                   	ret    
    673e:	66 90                	xchg   %ax,%ax
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
		{
			//pdu
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    6740:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6743:	e8 fc ff ff ff       	call   6744 <assamble_segment+0x144>
    6748:	03 45 e0             	add    -0x20(%ebp),%eax
    674b:	e8 fc ff ff ff       	call   674c <assamble_segment+0x14c>
    6750:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
    6753:	8b 06                	mov    (%esi),%eax
    6755:	8b 48 50             	mov    0x50(%eax),%ecx
    6758:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    675e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6761:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    6767:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    676a:	e8 fc ff ff ff       	call   676b <assamble_segment+0x16b>
			fsm_skb_put(pkptr, datalen);
    676f:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6772:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6775:	e8 fc ff ff ff       	call   6776 <assamble_segment+0x176>
			fsm_pkt_destroy(ambuf->pkt);
    677a:	8b 06                	mov    (%esi),%eax
    677c:	e8 fc ff ff ff       	call   677d <assamble_segment+0x17d>
			ambuf->pkt = pkptr;
    6781:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6784:	8b 55 ec             	mov    -0x14(%ebp),%edx
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
    6787:	89 06                	mov    %eax,(%esi)
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    6789:	8b 45 e8             	mov    -0x18(%ebp),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    678c:	8b 4a 50             	mov    0x50(%edx),%ecx
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    678f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6792:	01 d8                	add    %ebx,%eax
    6794:	03 82 ac 00 00 00    	add    0xac(%edx),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    679a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    679d:	e8 fc ff ff ff       	call   679e <assamble_segment+0x19e>
			fsm_pkt_destroy(pkt);
    67a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    67a5:	e8 fc ff ff ff       	call   67a6 <assamble_segment+0x1a6>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    67aa:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    67ad:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    67b1:	0f 89 bc 01 00 00    	jns    6973 <assamble_segment+0x373>
		ambuf->datalen = datalen;
    67b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
    67ba:	89 96 98 00 00 00    	mov    %edx,0x98(%esi)
    67c0:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    67c6:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    67ca:	8d 4a ff             	lea    -0x1(%edx),%ecx
    67cd:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    67d0:	39 c3                	cmp    %eax,%ebx
    67d2:	0f 86 07 ff ff ff    	jbe    66df <assamble_segment+0xdf>
		{
			ambuf->segEnd[ambuf->segnum] = posEnd;
    67d8:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
			ambuf->segStart[ambuf->segnum]  = posStart;
    67dc:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
			ambuf->segnum++;
    67e0:	83 c2 01             	add    $0x1,%edx
    67e3:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    67e9:	83 c4 20             	add    $0x20,%esp
    67ec:	5b                   	pop    %ebx
    67ed:	5e                   	pop    %esi
    67ee:	5f                   	pop    %edi
    67ef:	5d                   	pop    %ebp
    67f0:	c3                   	ret    
    67f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
		{
			//fsm_printf("[RLC][assamble_segment] this segment has been received\n");
			fsm_pkt_destroy(pkt);
    67f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    67fb:	e8 fc ff ff ff       	call   67fc <assamble_segment+0x1fc>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6800:	83 c4 20             	add    $0x20,%esp
    6803:	5b                   	pop    %ebx
    6804:	5e                   	pop    %esi
    6805:	5f                   	pop    %edi
    6806:	5d                   	pop    %ebp
    6807:	c3                   	ret    
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
    6808:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    680b:	03 45 e8             	add    -0x18(%ebp),%eax
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    680e:	8b 55 d8             	mov    -0x28(%ebp),%edx
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
    6811:	01 d8                	add    %ebx,%eax
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6813:	e8 fc ff ff ff       	call   6814 <assamble_segment+0x214>
		fsm_pkt_destroy(pkt);
    6818:	8b 45 ec             	mov    -0x14(%ebp),%eax
    681b:	e8 fc ff ff ff       	call   681c <assamble_segment+0x21c>
		pkt = NULL;
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
    6820:	8b 46 10             	mov    0x10(%esi),%eax
    6823:	85 c0                	test   %eax,%eax
    6825:	7e 29                	jle    6850 <assamble_segment+0x250>
    6827:	3b 7e 14             	cmp    0x14(%esi),%edi
    682a:	73 24                	jae    6850 <assamble_segment+0x250>
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    682c:	39 c3                	cmp    %eax,%ebx
    682e:	0f 82 54 01 00 00    	jb     6988 <assamble_segment+0x388>
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    6834:	77 1a                	ja     6850 <assamble_segment+0x250>
    6836:	39 c7                	cmp    %eax,%edi
    6838:	76 16                	jbe    6850 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    683a:	8b 46 50             	mov    0x50(%esi),%eax
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    683d:	39 c3                	cmp    %eax,%ebx
    683f:	90                   	nop
    6840:	73 0e                	jae    6850 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    6842:	39 c7                	cmp    %eax,%edi
    6844:	76 0a                	jbe    6850 <assamble_segment+0x250>
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
    6846:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    6849:	89 7e 50             	mov    %edi,0x50(%esi)
				FOUT;
    684c:	eb b2                	jmp    6800 <assamble_segment+0x200>
    684e:	66 90                	xchg   %ax,%ax
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6850:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6856:	89 ca                	mov    %ecx,%edx
    6858:	83 ea 01             	sub    $0x1,%edx
    685b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    685e:	74 a0                	je     6800 <assamble_segment+0x200>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				FOUT;
    6860:	89 75 ec             	mov    %esi,-0x14(%ebp)
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6863:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    686a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    686d:	89 75 e0             	mov    %esi,-0x20(%ebp)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6870:	8b 75 ec             	mov    -0x14(%ebp),%esi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6873:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6876:	8b 46 50             	mov    0x50(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6879:	83 eb 01             	sub    $0x1,%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    687c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    687f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6882:	76 14                	jbe    6898 <assamble_segment+0x298>
    6884:	8b 56 14             	mov    0x14(%esi),%edx
    6887:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    688a:	73 0c                	jae    6898 <assamble_segment+0x298>
    688c:	39 c7                	cmp    %eax,%edi
    688e:	76 08                	jbe    6898 <assamble_segment+0x298>
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
    6890:	39 d7                	cmp    %edx,%edi
    6892:	0f 82 5d 03 00 00    	jb     6bf5 <assamble_segment+0x5f5>
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
    6898:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    689b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    689e:	3b 73 10             	cmp    0x10(%ebx),%esi
    68a1:	72 5d                	jb     6900 <assamble_segment+0x300>
    68a3:	39 c6                	cmp    %eax,%esi
    68a5:	77 5e                	ja     6905 <assamble_segment+0x305>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68a7:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    68aa:	76 34                	jbe    68e0 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    68ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
    68af:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    68b2:	8d 44 93 10          	lea    0x10(%ebx,%edx,4),%eax
    68b6:	66 90                	xchg   %ax,%ax
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    68b8:	8b 18                	mov    (%eax),%ebx
    68ba:	39 df                	cmp    %ebx,%edi
    68bc:	72 0b                	jb     68c9 <assamble_segment+0x2c9>
    68be:	8b 70 40             	mov    0x40(%eax),%esi
    68c1:	39 f7                	cmp    %esi,%edi
    68c3:	0f 86 09 01 00 00    	jbe    69d2 <assamble_segment+0x3d2>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    68c9:	3b 78 3c             	cmp    0x3c(%eax),%edi
    68cc:	72 08                	jb     68d6 <assamble_segment+0x2d6>
    68ce:	39 df                	cmp    %ebx,%edi
    68d0:	0f 82 76 01 00 00    	jb     6a4c <assamble_segment+0x44c>
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68d6:	83 c2 01             	add    $0x1,%edx
    68d9:	83 c0 04             	add    $0x4,%eax
    68dc:	39 d1                	cmp    %edx,%ecx
    68de:	77 d8                	ja     68b8 <assamble_segment+0x2b8>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    68e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    68e6:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
    68ea:	83 c0 01             	add    $0x1,%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    68ed:	39 55 dc             	cmp    %edx,-0x24(%ebp)
    68f0:	0f 86 0a ff ff ff    	jbe    6800 <assamble_segment+0x200>
    68f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    68f9:	e9 72 ff ff ff       	jmp    6870 <assamble_segment+0x270>
    68fe:	66 90                	xchg   %ax,%ax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6900:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6903:	72 db                	jb     68e0 <assamble_segment+0x2e0>
    6905:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6908:	8b 55 e0             	mov    -0x20(%ebp),%edx
    690b:	83 c0 04             	add    $0x4,%eax
    690e:	8b 1c 82             	mov    (%edx,%eax,4),%ebx
    6911:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
    6914:	89 45 d8             	mov    %eax,-0x28(%ebp)
    6917:	77 c7                	ja     68e0 <assamble_segment+0x2e0>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6919:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    691c:	76 c2                	jbe    68e0 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    691e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6921:	8d 44 b2 14          	lea    0x14(%edx,%esi,4),%eax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6925:	89 f2                	mov    %esi,%edx
    6927:	eb 0c                	jmp    6935 <assamble_segment+0x335>
    6929:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6930:	8b 18                	mov    (%eax),%ebx
    6932:	83 c0 04             	add    $0x4,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6935:	39 df                	cmp    %ebx,%edi
    6937:	72 0b                	jb     6944 <assamble_segment+0x344>
    6939:	8b 70 3c             	mov    0x3c(%eax),%esi
    693c:	39 f7                	cmp    %esi,%edi
    693e:	0f 86 08 02 00 00    	jbe    6b4c <assamble_segment+0x54c>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6944:	3b 78 38             	cmp    0x38(%eax),%edi
    6947:	72 08                	jb     6951 <assamble_segment+0x351>
    6949:	39 df                	cmp    %ebx,%edi
    694b:	0f 82 73 01 00 00    	jb     6ac4 <assamble_segment+0x4c4>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6951:	83 c2 01             	add    $0x1,%edx
    6954:	39 d1                	cmp    %edx,%ecx
    6956:	77 d8                	ja     6930 <assamble_segment+0x330>
    6958:	eb 86                	jmp    68e0 <assamble_segment+0x2e0>
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
				{
					//fsm_printf("[RLC][assamble_segment] condition 11\n");
					ambuf->segStart[i] = posStart;
    695a:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
					ambuf->segEnd[i] = posEnd;
    695e:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
					ambuf->segnum = i + 1;
    6962:	83 c2 01             	add    $0x1,%edx
    6965:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    696b:	83 c4 20             	add    $0x20,%esp
    696e:	5b                   	pop    %ebx
    696f:	5e                   	pop    %esi
    6970:	5f                   	pop    %edi
    6971:	5d                   	pop    %ebp
    6972:	c3                   	ret    
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
			fsm_pkt_destroy(pkt);
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    6973:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6979:	8d 42 ff             	lea    -0x1(%edx),%eax
    697c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    697f:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6983:	e9 4f fd ff ff       	jmp    66d7 <assamble_segment+0xd7>
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    6988:	39 c7                	cmp    %eax,%edi
    698a:	0f 83 4c 02 00 00    	jae    6bdc <assamble_segment+0x5dc>
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6990:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6996:	89 ca                	mov    %ecx,%edx
    6998:	83 ea 01             	sub    $0x1,%edx
    699b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    699e:	78 1b                	js     69bb <assamble_segment+0x3bb>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69a0:	8d 44 8e 4c          	lea    0x4c(%esi,%ecx,4),%eax
    69a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
    69a8:	8b 08                	mov    (%eax),%ecx
    69aa:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[i+1] = ambuf->segStart[i];
    69ad:	8b 48 c0             	mov    -0x40(%eax),%ecx
    69b0:	89 48 c4             	mov    %ecx,-0x3c(%eax)
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    69b3:	83 e8 04             	sub    $0x4,%eax
    69b6:	83 ea 01             	sub    $0x1,%edx
    69b9:	79 ed                	jns    69a8 <assamble_segment+0x3a8>
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
    69bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
    69be:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    69c1:	89 7e 50             	mov    %edi,0x50(%esi)
				ambuf->segnum++;
    69c4:	83 c0 01             	add    $0x1,%eax
    69c7:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
				FOUT;
    69cd:	e9 2e fe ff ff       	jmp    6800 <assamble_segment+0x200>
    69d2:	89 f0                	mov    %esi,%eax
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    69d4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    69d7:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;j++;
    69da:	8d 5a 01             	lea    0x1(%edx),%ebx
						for(; i < ambuf->segnum; j++, i++)
    69dd:	89 4d ec             	mov    %ecx,-0x14(%ebp)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    69e0:	89 44 be 50          	mov    %eax,0x50(%esi,%edi,4)
						i++;j++;
    69e4:	8b 7d f0             	mov    -0x10(%ebp),%edi
						for(; i < ambuf->segnum; j++, i++)
    69e7:	39 f9                	cmp    %edi,%ecx
    69e9:	76 4f                	jbe    6a3a <assamble_segment+0x43a>
    69eb:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69f1:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
    69f5:	89 75 f0             	mov    %esi,-0x10(%ebp)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    69f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69fb:	8d 44 be 50          	lea    0x50(%esi,%edi,4),%eax
    69ff:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6a02:	eb 20                	jmp    6a24 <assamble_segment+0x424>
    6a04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6a08:	8b 0a                	mov    (%edx),%ecx
    6a0a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6a0c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6a0f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6a12:	83 c7 01             	add    $0x1,%edi
    6a15:	83 c3 01             	add    $0x1,%ebx
    6a18:	83 c2 04             	add    $0x4,%edx
    6a1b:	83 c0 04             	add    $0x4,%eax
    6a1e:	39 f7                	cmp    %esi,%edi
    6a20:	73 15                	jae    6a37 <assamble_segment+0x437>
    6a22:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6a24:	39 cb                	cmp    %ecx,%ebx
    6a26:	72 e0                	jb     6a08 <assamble_segment+0x408>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6a28:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6a2e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6a35:	eb db                	jmp    6a12 <assamble_segment+0x412>
    6a37:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6a3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a3d:	29 df                	sub    %ebx,%edi
    6a3f:	01 f8                	add    %edi,%eax
    6a41:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6a47:	e9 b4 fd ff ff       	jmp    6800 <assamble_segment+0x200>
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6a4c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6a4f:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a52:	89 4d ec             	mov    %ecx,-0x14(%ebp)
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6a55:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6a59:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						for(; i < ambuf->segnum; j++, i++)
    6a5c:	39 d9                	cmp    %ebx,%ecx
    6a5e:	76 52                	jbe    6ab2 <assamble_segment+0x4b2>
    6a60:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a66:	8d 44 9e 50          	lea    0x50(%esi,%ebx,4),%eax
    6a6a:	89 75 f0             	mov    %esi,-0x10(%ebp)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a6d:	89 7d ec             	mov    %edi,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a70:	8d 7c 96 50          	lea    0x50(%esi,%edx,4),%edi
    6a74:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6a77:	eb 23                	jmp    6a9c <assamble_segment+0x49c>
    6a79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6a80:	8b 0f                	mov    (%edi),%ecx
    6a82:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6a84:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6a87:	89 48 c0             	mov    %ecx,-0x40(%eax)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6a8a:	83 c3 01             	add    $0x1,%ebx
    6a8d:	83 c2 01             	add    $0x1,%edx
    6a90:	83 c7 04             	add    $0x4,%edi
    6a93:	83 c0 04             	add    $0x4,%eax
    6a96:	39 de                	cmp    %ebx,%esi
    6a98:	76 15                	jbe    6aaf <assamble_segment+0x4af>
    6a9a:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6a9c:	39 d1                	cmp    %edx,%ecx
    6a9e:	77 e0                	ja     6a80 <assamble_segment+0x480>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6aa0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6aa6:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6aad:	eb db                	jmp    6a8a <assamble_segment+0x48a>
    6aaf:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6ab2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ab5:	29 d3                	sub    %edx,%ebx
    6ab7:	01 d8                	add    %ebx,%eax
    6ab9:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6abf:	e9 3c fd ff ff       	jmp    6800 <assamble_segment+0x200>
    6ac4:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6ac7:	8b 75 e0             	mov    -0x20(%ebp),%esi
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
    6aca:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6acd:	89 1c 86             	mov    %ebx,(%esi,%eax,4)
						ambuf->segEnd[i] = posEnd;
    6ad0:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6ad3:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
    6ad6:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6ada:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6add:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6ae0:	39 d9                	cmp    %ebx,%ecx
    6ae2:	76 56                	jbe    6b3a <assamble_segment+0x53a>
    6ae4:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6aea:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6aee:	89 45 ec             	mov    %eax,-0x14(%ebp)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6af1:	89 7d f0             	mov    %edi,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6af4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6af7:	8d 44 be 58          	lea    0x58(%esi,%edi,4),%eax
    6afb:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6afe:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6b01:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6b04:	eb 1e                	jmp    6b24 <assamble_segment+0x524>
    6b06:	66 90                	xchg   %ax,%ax
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6b08:	8b 0f                	mov    (%edi),%ecx
    6b0a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6b0c:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6b0f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6b12:	83 c3 01             	add    $0x1,%ebx
    6b15:	83 c2 01             	add    $0x1,%edx
    6b18:	83 c7 04             	add    $0x4,%edi
    6b1b:	83 c0 04             	add    $0x4,%eax
    6b1e:	39 de                	cmp    %ebx,%esi
    6b20:	76 15                	jbe    6b37 <assamble_segment+0x537>
    6b22:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6b24:	39 ca                	cmp    %ecx,%edx
    6b26:	72 e0                	jb     6b08 <assamble_segment+0x508>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6b28:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6b2e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6b35:	eb db                	jmp    6b12 <assamble_segment+0x512>
    6b37:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6b3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b3d:	29 d3                	sub    %edx,%ebx
    6b3f:	01 d8                	add    %ebx,%eax
    6b41:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6b47:	e9 b4 fc ff ff       	jmp    6800 <assamble_segment+0x200>
    6b4c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6b4f:	89 f0                	mov    %esi,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
    6b51:	8b 7d d8             	mov    -0x28(%ebp),%edi
    6b54:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6b57:	89 1c be             	mov    %ebx,(%esi,%edi,4)
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6b5a:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;j++;
    6b5d:	8d 7a 01             	lea    0x1(%edx),%edi
						for(; i < ambuf->segnum; j++, i++)
    6b60:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6b63:	89 44 9e 50          	mov    %eax,0x50(%esi,%ebx,4)
						i++;j++;
    6b67:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6b6a:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6b6d:	39 d9                	cmp    %ebx,%ecx
    6b6f:	76 59                	jbe    6bca <assamble_segment+0x5ca>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b71:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b75:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b7b:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6b7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b81:	89 45 f0             	mov    %eax,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b84:	8d 44 96 58          	lea    0x58(%esi,%edx,4),%eax
    6b88:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6b8b:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6b8e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6b91:	eb 21                	jmp    6bb4 <assamble_segment+0x5b4>
    6b93:	90                   	nop
    6b94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6b98:	8b 0a                	mov    (%edx),%ecx
    6b9a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6b9c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6b9f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6ba2:	83 c3 01             	add    $0x1,%ebx
    6ba5:	83 c7 01             	add    $0x1,%edi
    6ba8:	83 c2 04             	add    $0x4,%edx
    6bab:	83 c0 04             	add    $0x4,%eax
    6bae:	39 de                	cmp    %ebx,%esi
    6bb0:	76 15                	jbe    6bc7 <assamble_segment+0x5c7>
    6bb2:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6bb4:	39 cf                	cmp    %ecx,%edi
    6bb6:	72 e0                	jb     6b98 <assamble_segment+0x598>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6bb8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6bbe:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6bc5:	eb db                	jmp    6ba2 <assamble_segment+0x5a2>
    6bc7:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6bca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bcd:	29 fb                	sub    %edi,%ebx
    6bcf:	01 d8                	add    %ebx,%eax
    6bd1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6bd7:	e9 24 fc ff ff       	jmp    6800 <assamble_segment+0x200>
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//2:
			if((posStart < ambuf->segStart[0] )&&(ambuf->segStart[0] < posEnd)&&(posEnd <= ambuf->segEnd[0]))
    6bdc:	0f 86 6e fc ff ff    	jbe    6850 <assamble_segment+0x250>
    6be2:	3b 7e 50             	cmp    0x50(%esi),%edi
    6be5:	0f 87 4f fc ff ff    	ja     683a <assamble_segment+0x23a>
			{
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
    6beb:	89 5e 10             	mov    %ebx,0x10(%esi)
    6bee:	66 90                	xchg   %ax,%ax
				FOUT;
    6bf0:	e9 0b fc ff ff       	jmp    6800 <assamble_segment+0x200>
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6bf5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6bf8:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6bfb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6bfe:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6c01:	7e 20                	jle    6c23 <assamble_segment+0x623>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c03:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6c07:	89 4d f0             	mov    %ecx,-0x10(%ebp)
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6c0a:	8b 08                	mov    (%eax),%ecx
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6c0c:	83 ea 01             	sub    $0x1,%edx
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6c0f:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[j+1] = ambuf->segStart[j];
    6c12:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6c15:	89 48 c4             	mov    %ecx,-0x3c(%eax)
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6c18:	83 e8 04             	sub    $0x4,%eax
    6c1b:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6c1e:	7f ea                	jg     6c0a <assamble_segment+0x60a>
    6c20:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
    6c23:	83 c1 01             	add    $0x1,%ecx
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
    6c26:	89 5c 96 14          	mov    %ebx,0x14(%esi,%edx,4)
				ambuf->segEnd[j+1] = posEnd;
    6c2a:	89 7c 96 54          	mov    %edi,0x54(%esi,%edx,4)
				ambuf->segnum++;
    6c2e:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
				FOUT;
    6c34:	e9 c7 fb ff ff       	jmp    6800 <assamble_segment+0x200>
    6c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006c40 <rlc_pkt_receive_from_mac>:
**-------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
******************************************************************************/
void rlc_pkt_receive_from_mac(FSM_PKT * skb)
{
    6c40:	55                   	push   %ebp
    6c41:	89 e5                	mov    %esp,%ebp
    6c43:	57                   	push   %edi
    6c44:	56                   	push   %esi
    6c45:	53                   	push   %ebx
    6c46:	83 ec 4c             	sub    $0x4c,%esp
    6c49:	e8 fc ff ff ff       	call   6c4a <rlc_pkt_receive_from_mac+0xa>
    6c4e:	89 c3                	mov    %eax,%ebx
	struct  UM_RX_Instance *umRxIns;
//   struct  TM_RX_Instance *tmRxIns;
	void *insptru, *insptrd;
	
	FIN(rlc_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6c50:	e8 fc ff ff ff       	call   6c51 <rlc_pkt_receive_from_mac+0x11>
    6c55:	89 c7                	mov    %eax,%edi
	SV(countreceive_from_mac)++;
    6c57:	8b 80 88 5a 00 00    	mov    0x5a88(%eax),%eax
    6c5d:	83 c0 01             	add    $0x1,%eax
    6c60:	89 87 88 5a 00 00    	mov    %eax,0x5a88(%edi)
	printk("[rlc_pkt_receive_from_mac]UE RLC_MAC SEND TO UPPER=%d\n",SV(countreceive_from_mac));
    6c66:	89 44 24 04          	mov    %eax,0x4(%esp)
    6c6a:	c7 04 24 38 1d 00 00 	movl   $0x1d38,(%esp)
    6c71:	e8 fc ff ff ff       	call   6c72 <rlc_pkt_receive_from_mac+0x32>

	//skb = fsm_pkt_get();

	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from lower\n");
	//fsm_octets_print(skb->data,50);
	micimsg = (MRLC_fromMac_IciMsg*)skb->head;
    6c76:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
    6c7c:	8b 46 02             	mov    0x2(%esi),%eax
    6c7f:	89 44 24 08          	mov    %eax,0x8(%esp)
    6c83:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6c87:	c7 04 24 70 1d 00 00 	movl   $0x1d70,(%esp)
    6c8e:	89 44 24 04          	mov    %eax,0x4(%esp)
    6c92:	e8 fc ff ff ff       	call   6c93 <rlc_pkt_receive_from_mac+0x53>
	fsm_octets_print(skb->data,64);
    6c97:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    6c9d:	ba 40 00 00 00       	mov    $0x40,%edx
    6ca2:	e8 fc ff ff ff       	call   6ca3 <rlc_pkt_receive_from_mac+0x63>
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
    6ca7:	8b 46 02             	mov    0x2(%esi),%eax
    6caa:	85 c0                	test   %eax,%eax
    6cac:	75 08                	jne    6cb6 <rlc_pkt_receive_from_mac+0x76>
    6cae:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6cb2:	84 c0                	test   %al,%al
    6cb4:	75 5a                	jne    6d10 <rlc_pkt_receive_from_mac+0xd0>
		}
		
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    6cb6:	89 d8                	mov    %ebx,%eax
    6cb8:	e8 fc ff ff ff       	call   6cb9 <rlc_pkt_receive_from_mac+0x79>
    6cbd:	83 f8 01             	cmp    $0x1,%eax
    6cc0:	0f 86 92 03 00 00    	jbe    7058 <rlc_pkt_receive_from_mac+0x418>
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6cc6:	8b 46 02             	mov    0x2(%esi),%eax
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6cc9:	8d 55 f2             	lea    -0xe(%ebp),%edx
    6ccc:	b9 02 00 00 00       	mov    $0x2,%ecx
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
    6cd1:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6cd5:	88 45 f2             	mov    %al,-0xe(%ebp)
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6cd8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    6cde:	e8 fc ff ff ff       	call   6cdf <rlc_pkt_receive_from_mac+0x9f>
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
    6ce3:	c7 04 24 84 26 00 00 	movl   $0x2684,(%esp)
    6cea:	e8 fc ff ff ff       	call   6ceb <rlc_pkt_receive_from_mac+0xab>
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6cef:	ba 05 00 00 00       	mov    $0x5,%edx
    6cf4:	89 d8                	mov    %ebx,%eax
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
    6cf6:	83 87 90 5a 00 00 01 	addl   $0x1,0x5a90(%edi)
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6cfd:	e8 fc ff ff ff       	call   6cfe <rlc_pkt_receive_from_mac+0xbe>
	}
	//printk("[RLC_MAC]SV(countDropPacket):%d\n", SV(countDropPacket));
	FOUT;
}
    6d02:	83 c4 4c             	add    $0x4c,%esp
    6d05:	5b                   	pop    %ebx
    6d06:	5e                   	pop    %esi
    6d07:	5f                   	pop    %edi
    6d08:	5d                   	pop    %ebp
    6d09:	c3                   	ret    
    6d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
	fsm_octets_print(skb->data,64);
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
    6d10:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    6d16:	0f b6 c0             	movzbl %al,%eax
    6d19:	89 14 24             	mov    %edx,(%esp)
    6d1c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    6d1f:	8d 55 e8             	lea    -0x18(%ebp),%edx
    6d22:	e8 fc ff ff ff       	call   6d23 <rlc_pkt_receive_from_mac+0xe3>
		switch(SV(ins_mode))
    6d27:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    6d2d:	83 f8 02             	cmp    $0x2,%eax
    6d30:	74 3e                	je     6d70 <rlc_pkt_receive_from_mac+0x130>
    6d32:	83 f8 03             	cmp    $0x3,%eax
    6d35:	0f 84 35 03 00 00    	je     7070 <rlc_pkt_receive_from_mac+0x430>
			//printk("[RLC_MAC UM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		default:
			printk("[RLC][rlc_pkt_receive_from_mac] cannot distinfuish this  %d", SV(ins_mode));
    6d3b:	89 44 24 04          	mov    %eax,0x4(%esp)
    6d3f:	c7 04 24 10 26 00 00 	movl   $0x2610,(%esp)
    6d46:	e8 fc ff ff ff       	call   6d47 <rlc_pkt_receive_from_mac+0x107>
			break;
		}
		//fsm_printf("[RLC][rlc_pkt_receive_from_mac] cannot find the instance or the instance is suspended(rbid is %d)\n", micimsg->lcid);
		printk("[RLC][rlc_pkt_receive_from_mac] A packet has dropped\n");
    6d4b:	c7 04 24 4c 26 00 00 	movl   $0x264c,(%esp)
    6d52:	e8 fc ff ff ff       	call   6d53 <rlc_pkt_receive_from_mac+0x113>
		SV(countDropPacket)++;
    6d57:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		if(skb != NULL)
    6d5e:	85 db                	test   %ebx,%ebx
    6d60:	74 a0                	je     6d02 <rlc_pkt_receive_from_mac+0xc2>
		{
			fsm_pkt_destroy(skb);
    6d62:	89 d8                	mov    %ebx,%eax
    6d64:	e8 fc ff ff ff       	call   6d65 <rlc_pkt_receive_from_mac+0x125>
    6d69:	eb 97                	jmp    6d02 <rlc_pkt_receive_from_mac+0xc2>
    6d6b:	90                   	nop
    6d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		case UM_MODE:
			if(insptrd == NULL)
    6d70:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    6d73:	85 c9                	test   %ecx,%ecx
    6d75:	0f 84 ab 0d 00 00    	je     7b26 <rlc_pkt_receive_from_mac+0xee6>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
    6d7b:	0f b6 81 c2 10 00 00 	movzbl 0x10c2(%ecx),%eax
    6d82:	3c 0b                	cmp    $0xb,%al
    6d84:	0f 84 83 0d 00 00    	je     7b0d <rlc_pkt_receive_from_mac+0xecd>
    6d8a:	3c 09                	cmp    $0x9,%al
    6d8c:	0f 84 7b 0d 00 00    	je     7b0d <rlc_pkt_receive_from_mac+0xecd>
	u16 windows;
	//MRLC_fromMac_IciMsg *mac_ici;
	//URLC_IciMsg *icimsg;
	
	FIN(rlc_UM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6d92:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6d95:	e8 fc ff ff ff       	call   6d96 <rlc_pkt_receive_from_mac+0x156>
    6d9a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	fsm_printf("\n[RLC][rlc_UM_pkt_receive_from_mac] entering rlc_UM_pkt_receive_from_mac\n");
    6d9d:	c7 04 24 40 22 00 00 	movl   $0x2240,(%esp)
    6da4:	e8 fc ff ff ff       	call   6da5 <rlc_pkt_receive_from_mac+0x165>
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
    6da9:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6dac:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6db0:	c7 04 24 8c 22 00 00 	movl   $0x228c,(%esp)
    6db7:	89 44 24 04          	mov    %eax,0x4(%esp)
    6dbb:	e8 fc ff ff ff       	call   6dbc <rlc_pkt_receive_from_mac+0x17c>
	switch(umRxIns->snFiledLength)
    6dc0:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6dc3:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6dc7:	66 83 f8 05          	cmp    $0x5,%ax
    6dcb:	0f 84 3f 06 00 00    	je     7410 <rlc_pkt_receive_from_mac+0x7d0>
    6dd1:	66 83 f8 0a          	cmp    $0xa,%ax
    6dd5:	0f 84 7d 06 00 00    	je     7458 <rlc_pkt_receive_from_mac+0x818>
			FOUT;
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size10 + 1));
		break;
	default:
		printk("[RLC][rlc_UM_pkt_receive_from_mac] cannot distinguish the %d",umRxIns->snFiledLength);
    6ddb:	0f b7 c0             	movzwl %ax,%eax
    6dde:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6de1:	89 44 24 04          	mov    %eax,0x4(%esp)
    6de5:	c7 04 24 24 23 00 00 	movl   $0x2324,(%esp)
    6dec:	e8 fc ff ff ff       	call   6ded <rlc_pkt_receive_from_mac+0x1ad>
    6df1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6df4:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    6dfa:	0f bf 75 e4          	movswl -0x1c(%ebp),%esi
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6dfe:	b8 18 00 00 00       	mov    $0x18,%eax
    6e03:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6e06:	e8 fc ff ff ff       	call   6e07 <rlc_pkt_receive_from_mac+0x1c7>
	umbuf->pkt = pkt;
    6e0b:	89 18                	mov    %ebx,(%eax)
	umbuf->SN = SN;
    6e0d:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6e11:	8d 50 10             	lea    0x10(%eax),%edx
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6e14:	89 c7                	mov    %eax,%edi
	umbuf->pkt = pkt;
	umbuf->SN = SN;
    6e16:	66 89 58 0c          	mov    %bx,0xc(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    6e1a:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6e1d:	8b 41 34             	mov    0x34(%ecx),%eax
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6e20:	8d 59 30             	lea    0x30(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    6e23:	89 51 34             	mov    %edx,0x34(%ecx)
    6e26:	89 5f 10             	mov    %ebx,0x10(%edi)
	new->next = next;
	new->prev = prev;
    6e29:	89 47 14             	mov    %eax,0x14(%edi)
	prev->next = new;
    6e2c:	89 10                	mov    %edx,(%eax)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    6e2e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6e31:	89 74 24 04          	mov    %esi,0x4(%esp)
    6e35:	c7 04 24 64 23 00 00 	movl   $0x2364,(%esp)
    6e3c:	e8 fc ff ff ff       	call   6e3d <rlc_pkt_receive_from_mac+0x1fd>
	if(umRxIns->snFiledLength == 5)
    6e41:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6e44:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6e48:	66 83 f8 05          	cmp    $0x5,%ax
    6e4c:	0f 84 1e 07 00 00    	je     7570 <rlc_pkt_receive_from_mac+0x930>
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
	}
	if(umRxIns->snFiledLength == 10)
    6e52:	66 83 f8 0a          	cmp    $0xa,%ax
    6e56:	75 07                	jne    6e5f <rlc_pkt_receive_from_mac+0x21f>
	{
		umRxIns->umRecvWindow10[SN] = umbuf;
    6e58:	89 bc b1 b8 00 00 00 	mov    %edi,0xb8(%ecx,%esi,4)
	}
	umRxIns->vr_uh %= windows;
    6e5f:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6e66:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    6e6a:	89 c2                	mov    %eax,%edx
    6e6c:	c1 fa 1f             	sar    $0x1f,%edx
    6e6f:	f7 fb                	idiv   %ebx
    6e71:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_uh is %d\n", umRxIns->vr_uh);
    6e78:	0f bf d2             	movswl %dx,%edx
    6e7b:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6e7e:	89 54 24 04          	mov    %edx,0x4(%esp)
    6e82:	c7 04 24 b0 23 00 00 	movl   $0x23b0,(%esp)
    6e89:	e8 fc ff ff ff       	call   6e8a <rlc_pkt_receive_from_mac+0x24a>
	//
	if((SN>=umRxIns->vr_uh)||(SN <= umRxIns->vr_uh - windows/2))
    6e8e:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6e91:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
    6e95:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    6e9c:	66 d1 ef             	shr    %di
    6e9f:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
    6ea3:	0f b7 ff             	movzwl %di,%edi
    6ea6:	7d 07                	jge    6eaf <rlc_pkt_receive_from_mac+0x26f>
    6ea8:	98                   	cwtl   
    6ea9:	29 f8                	sub    %edi,%eax
    6eab:	39 c6                	cmp    %eax,%esi
    6ead:	7f 66                	jg     6f15 <rlc_pkt_receive_from_mac+0x2d5>
	{
		//	fsm_printf("umbuf->SN  >=  umRxIns->vr_uh is %d\n",umRxIns->vr_uh);
		umRxIns->vr_uh = (SN + 1)%windows;
    6eaf:	8d 46 01             	lea    0x1(%esi),%eax
    6eb2:	89 c2                	mov    %eax,%edx
    6eb4:	c1 fa 1f             	sar    $0x1f,%edx
    6eb7:	f7 fb                	idiv   %ebx
    6eb9:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] outside the windows: umRxIns->vr_uh is updated to %d\n", umRxIns->vr_uh);
    6ec0:	89 54 24 04          	mov    %edx,0x4(%esp)
    6ec4:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6ec7:	c7 04 24 ec 23 00 00 	movl   $0x23ec,(%esp)
    6ece:	e8 fc ff ff ff       	call   6ecf <rlc_pkt_receive_from_mac+0x28f>
		//temp = umRxIns->vr_ur;
		if(umRxIns->vr_ur < umRxIns->vr_uh - windows/2 )
    6ed3:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6ed6:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6edd:	0f bf 91 bc 10 00 00 	movswl 0x10bc(%ecx),%edx
    6ee4:	89 c6                	mov    %eax,%esi
    6ee6:	29 fe                	sub    %edi,%esi
    6ee8:	39 f2                	cmp    %esi,%edx
    6eea:	7d 13                	jge    6eff <rlc_pkt_receive_from_mac+0x2bf>
		{
			umRxIns->vr_ur = (umRxIns->vr_uh + windows/2)%windows;
    6eec:	01 f8                	add    %edi,%eax
    6eee:	89 c2                	mov    %eax,%edx
    6ef0:	c1 fa 1f             	sar    $0x1f,%edx
    6ef3:	f7 fb                	idiv   %ebx
    6ef5:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
    6efc:	0f bf d2             	movswl %dx,%edx
			}
			umRxIns->vr_ur =  temp;*/
			//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
		}		
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    6eff:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f02:	89 54 24 04          	mov    %edx,0x4(%esp)
    6f06:	c7 04 24 48 24 00 00 	movl   $0x2448,(%esp)
    6f0d:	e8 fc ff ff ff       	call   6f0e <rlc_pkt_receive_from_mac+0x2ce>
    6f12:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		//	fsm_printf("umRxIns->vr_ur is %d\n",umRxIns->vr_ur);
		//	   fsm_pkt_send(rlc_UM_reassemble_deliver( umRxIns),STRM_TO_PDCP);
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
    6f15:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6f19:	66 83 f8 05          	cmp    $0x5,%ax
    6f1d:	0f 84 f6 06 00 00    	je     7619 <rlc_pkt_receive_from_mac+0x9d9>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
		}
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
    6f23:	66 83 f8 0a          	cmp    $0xa,%ax
    6f27:	0f 84 92 07 00 00    	je     76bf <rlc_pkt_receive_from_mac+0xa7f>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6f2d:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    6f34:	8b 71 08             	mov    0x8(%ecx),%esi
    6f37:	85 f6                	test   %esi,%esi
    6f39:	0f 84 a4 00 00 00    	je     6fe3 <rlc_pkt_receive_from_mac+0x3a3>
    6f3f:	0f b7 81 be 10 00 00 	movzwl 0x10be(%ecx),%eax
    6f46:	66 39 c7             	cmp    %ax,%di
    6f49:	7d 6d                	jge    6fb8 <rlc_pkt_receive_from_mac+0x378>
    6f4b:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    6f4f:	0f bf d0             	movswl %ax,%edx
    6f52:	0f bf ff             	movswl %di,%edi
    6f55:	66 d1 ee             	shr    %si
    6f58:	0f b7 f6             	movzwl %si,%esi
    6f5b:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    6f5e:	89 d6                	mov    %edx,%esi
    6f60:	2b 75 e4             	sub    -0x1c(%ebp),%esi
    6f63:	39 f7                	cmp    %esi,%edi
    6f65:	7e 51                	jle    6fb8 <rlc_pkt_receive_from_mac+0x378>
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6f67:	66 83 79 06 05       	cmpw   $0x5,0x6(%ecx)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    6f6c:	0f bf b1 c0 10 00 00 	movswl 0x10c0(%ecx),%esi
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6f73:	0f 84 f4 08 00 00    	je     786d <rlc_pkt_receive_from_mac+0xc2d>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    6f79:	29 f2                	sub    %esi,%edx
    6f7b:	81 c2 00 06 00 00    	add    $0x600,%edx
    6f81:	89 d6                	mov    %edx,%esi
    6f83:	c1 fe 1f             	sar    $0x1f,%esi
    6f86:	c1 ee 16             	shr    $0x16,%esi
    6f89:	01 f2                	add    %esi,%edx
    6f8b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6f91:	29 f2                	sub    %esi,%edx
    6f93:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    6f99:	0f 9e c2             	setle  %dl
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    6f9c:	84 d2                	test   %dl,%dl
    6f9e:	0f 85 5e fd ff ff    	jne    6d02 <rlc_pkt_receive_from_mac+0xc2>
								((!isInsideUmRecvWin(umRxIns,umRxIns->vr_ux ))&&(umRxIns->vr_ux != umRxIns->vr_uh))))
    6fa4:	66 3b 81 c0 10 00 00 	cmp    0x10c0(%ecx),%ax
    6fab:	0f 84 51 fd ff ff    	je     6d02 <rlc_pkt_receive_from_mac+0xc2>
    6fb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is canceling\n\n");
    6fb8:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6fbb:	c7 04 24 58 25 00 00 	movl   $0x2558,(%esp)
    6fc2:	e8 fc ff ff ff       	call   6fc3 <rlc_pkt_receive_from_mac+0x383>
		fsm_schedule_cancel(umRxIns->reorderTimer);
    6fc7:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6fca:	8b 41 08             	mov    0x8(%ecx),%eax
    6fcd:	e8 fc ff ff ff       	call   6fce <rlc_pkt_receive_from_mac+0x38e>
		umRxIns->reorderTimer = 0;
    6fd2:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6fd5:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    6fdc:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
	}
	//h>r(!=)
	//if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh != umRxIns->vr_ur))//??
	if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh>umRxIns->vr_ur||umRxIns->vr_uh<umRxIns->vr_ur-windows/2))
    6fe3:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    6fea:	66 39 c7             	cmp    %ax,%di
    6fed:	7c 18                	jl     7007 <rlc_pkt_receive_from_mac+0x3c7>
    6fef:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    6ff3:	0f bf ff             	movswl %di,%edi
    6ff6:	98                   	cwtl   
    6ff7:	66 d1 ea             	shr    %dx
    6ffa:	0f b7 d2             	movzwl %dx,%edx
    6ffd:	29 d7                	sub    %edx,%edi
    6fff:	39 f8                	cmp    %edi,%eax
    7001:	0f 8d fb fc ff ff    	jge    6d02 <rlc_pkt_receive_from_mac+0xc2>
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is scheduling\n");
    7007:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    700a:	c7 04 24 90 25 00 00 	movl   $0x2590,(%esp)
    7011:	e8 fc ff ff ff       	call   7012 <rlc_pkt_receive_from_mac+0x3d2>
		umRxIns->reorderTimer = fsm_schedule_self(umRxIns->reorderTimerValue, umRxIns->reorderTimerCode);
    7016:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7019:	8b 51 0c             	mov    0xc(%ecx),%edx
    701c:	8b 41 10             	mov    0x10(%ecx),%eax
    701f:	e8 fc ff ff ff       	call   7020 <rlc_pkt_receive_from_mac+0x3e0>
    7024:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7027:	89 41 08             	mov    %eax,0x8(%ecx)
		umRxIns->vr_ux = umRxIns->vr_uh;
		umRxIns->vr_ux %= windows;
    702a:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    7031:	89 c2                	mov    %eax,%edx
    7033:	c1 fa 1f             	sar    $0x1f,%edx
    7036:	f7 fb                	idiv   %ebx
    7038:	66 89 91 be 10 00 00 	mov    %dx,0x10be(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ux is updated to %d\n\n", umRxIns->vr_ux);
    703f:	0f bf d2             	movswl %dx,%edx
    7042:	89 54 24 04          	mov    %edx,0x4(%esp)
    7046:	c7 04 24 c8 25 00 00 	movl   $0x25c8,(%esp)
    704d:	e8 fc ff ff ff       	call   704e <rlc_pkt_receive_from_mac+0x40e>
    7052:	e9 ab fc ff ff       	jmp    6d02 <rlc_pkt_receive_from_mac+0xc2>
    7057:	90                   	nop
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    7058:	89 d8                	mov    %ebx,%eax
    705a:	ba 02 00 00 00       	mov    $0x2,%edx
    705f:	e8 fc ff ff ff       	call   7060 <rlc_pkt_receive_from_mac+0x420>
    7064:	89 c3                	mov    %eax,%ebx
    7066:	e9 5b fc ff ff       	jmp    6cc6 <rlc_pkt_receive_from_mac+0x86>
    706b:	90                   	nop
    706c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    7070:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7073:	85 c0                	test   %eax,%eax
    7075:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    7078:	0f 84 76 0a 00 00    	je     7af4 <rlc_pkt_receive_from_mac+0xeb4>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    707e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7081:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
    7085:	66 83 f8 0b          	cmp    $0xb,%ax
    7089:	0f 84 4c 0a 00 00    	je     7adb <rlc_pkt_receive_from_mac+0xe9b>
    708f:	66 83 f8 09          	cmp    $0x9,%ax
    7093:	0f 84 42 0a 00 00    	je     7adb <rlc_pkt_receive_from_mac+0xe9b>
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7099:	e8 fc ff ff ff       	call   709a <rlc_pkt_receive_from_mac+0x45a>
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
    709e:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
    70a4:	66 c1 06 08          	rolw   $0x8,(%esi)
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    70a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
	*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
	fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the header is:\n");
    70ab:	c7 04 24 5c 1e 00 00 	movl   $0x1e5c,(%esp)
    70b2:	e8 fc ff ff ff       	call   70b3 <rlc_pkt_receive_from_mac+0x473>
	fsm_octets_print(fixhead,2);
    70b7:	ba 02 00 00 00       	mov    $0x2,%edx
    70bc:	89 f0                	mov    %esi,%eax
    70be:	e8 fc ff ff ff       	call   70bf <rlc_pkt_receive_from_mac+0x47f>
	//fsm_printf("\n[RLC][rlc_AM_pkt_receive_from_mac] entering rlc_AM_pkt_receive_from_mac\n");
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
    70c3:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    70c7:	84 c0                	test   %al,%al
    70c9:	0f 89 b1 04 00 00    	jns    7580 <rlc_pkt_receive_from_mac+0x940>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    70cf:	a8 40                	test   $0x40,%al
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    70d1:	0f b6 16             	movzbl (%esi),%edx
    70d4:	0f b6 46 01          	movzbl 0x1(%esi),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    70d8:	0f 84 3a 02 00 00    	je     7318 <rlc_pkt_receive_from_mac+0x6d8>
	}

//AMD PDU 
	else
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
    70de:	83 e0 03             	and    $0x3,%eax
    70e1:	c1 e0 08             	shl    $0x8,%eax
    70e4:	09 d0                	or     %edx,%eax
    70e6:	89 44 24 04          	mov    %eax,0x4(%esp)
    70ea:	c7 04 24 18 1f 00 00 	movl   $0x1f18,(%esp)
    70f1:	e8 fc ff ff ff       	call   70f2 <rlc_pkt_receive_from_mac+0x4b2>
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
    70f6:	8b 8b ac 00 00 00    	mov    0xac(%ebx),%ecx
    70fc:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    70ff:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7103:	0f b6 16             	movzbl (%esi),%edx
    7106:	83 e0 03             	and    $0x3,%eax
    7109:	c1 e0 08             	shl    $0x8,%eax
    710c:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    710e:	0f bf d0             	movswl %ax,%edx
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    7111:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    7115:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7118:	89 55 e0             	mov    %edx,-0x20(%ebp)
    711b:	e8 fc ff ff ff       	call   711c <rlc_pkt_receive_from_mac+0x4dc>
    7120:	84 c0                	test   %al,%al
    7122:	0f 84 4b 09 00 00    	je     7a73 <rlc_pkt_receive_from_mac+0xe33>
    7128:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    712b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    712e:	81 c1 98 04 00 00    	add    $0x498,%ecx
    7134:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
    7138:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    713b:	85 c0                	test   %eax,%eax
    713d:	0f 84 49 07 00 00    	je     788c <rlc_pkt_receive_from_mac+0xc4c>
    7143:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7147:	0f 84 26 09 00 00    	je     7a73 <rlc_pkt_receive_from_mac+0xe33>
		//PDU
		else
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not received this PDU segment before(pos is %d)\n", extseghead->SO);
			//
			if(extseghead->LSF == 1)
    714d:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    7150:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    7154:	79 3a                	jns    7190 <rlc_pkt_receive_from_mac+0x550>
			{
				amIns->amRecvWindow[SN]->pktstatus = LAST_SEGMENT;
    7156:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
    715d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7160:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7163:	8b 44 82 0c          	mov    0xc(%edx,%eax,4),%eax
    7167:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    716a:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    716e:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    7172:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7175:	83 e0 7f             	and    $0x7f,%eax
    7178:	c1 e0 08             	shl    $0x8,%eax
    717b:	09 d0                	or     %edx,%eax
    717d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    7180:	03 43 50             	add    0x50(%ebx),%eax
    7183:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    7189:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    718c:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
    7190:	89 da                	mov    %ebx,%edx
    7192:	e8 fc ff ff ff       	call   7193 <rlc_pkt_receive_from_mac+0x553>
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    7197:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    719a:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    719d:	8b 44 9a 0c          	mov    0xc(%edx,%ebx,4),%eax
    71a1:	8b 10                	mov    (%eax),%edx
    71a3:	8b 4a 50             	mov    0x50(%edx),%ecx
    71a6:	39 88 98 00 00 00    	cmp    %ecx,0x98(%eax)
    71ac:	0f 84 d9 05 00 00    	je     778b <rlc_pkt_receive_from_mac+0xb4b>
	}

//PDUSN

//vr_h
	if(SN >= amIns->vr_h || SN <= amIns->vr_h-AM_WINDOW_SIZE)
    71b2:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    71b5:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    71bc:	66 3b 45 da          	cmp    -0x26(%ebp),%ax
    71c0:	7e 0b                	jle    71cd <rlc_pkt_receive_from_mac+0x58d>
    71c2:	98                   	cwtl   
    71c3:	2d 00 02 00 00       	sub    $0x200,%eax
    71c8:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    71cb:	7f 31                	jg     71fe <rlc_pkt_receive_from_mac+0x5be>
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN > amIns->vr_h\n");
    71cd:	c7 04 24 d8 1f 00 00 	movl   $0x1fd8,(%esp)
    71d4:	e8 fc ff ff ff       	call   71d5 <rlc_pkt_receive_from_mac+0x595>
		amIns->vr_h = (SN + 1)%(AM_WINDOW_SIZE*2);
    71d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    71dc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    71df:	83 c0 01             	add    $0x1,%eax
    71e2:	25 ff 03 00 00       	and    $0x3ff,%eax
    71e7:	66 89 82 ee 22 00 00 	mov    %ax,0x22ee(%edx)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_h is updated to %d\n",amIns->vr_h);
    71ee:	89 44 24 04          	mov    %eax,0x4(%esp)
    71f2:	c7 04 24 10 20 00 00 	movl   $0x2010,(%esp)
    71f9:	e8 fc ff ff ff       	call   71fa <rlc_pkt_receive_from_mac+0x5ba>
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    71fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7201:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
    7208:	8b 84 90 6c 12 00 00 	mov    0x126c(%eax,%edx,4),%eax
    720f:	85 c0                	test   %eax,%eax
    7211:	74 0a                	je     721d <rlc_pkt_receive_from_mac+0x5dd>
    7213:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7217:	0f 84 83 03 00 00    	je     75a0 <rlc_pkt_receive_from_mac+0x960>
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    721d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7220:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7223:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    722a:	0f bf c2             	movswl %dx,%eax
    722d:	8b 84 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%eax
    7234:	85 c0                	test   %eax,%eax
    7236:	74 0a                	je     7242 <rlc_pkt_receive_from_mac+0x602>
    7238:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    723c:	0f 84 6d 05 00 00    	je     77af <rlc_pkt_receive_from_mac+0xb6f>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
	}
	
//x>r,xmr
	if(amIns->reorderTimer &&((amIns->vr_x == amIns->vr_r)||(!isInsideAmRecvWin(amIns, SN)&&(amIns->vr_x != amIns->vr_mr))))
    7242:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7245:	8b 41 14             	mov    0x14(%ecx),%eax
    7248:	85 c0                	test   %eax,%eax
    724a:	74 4b                	je     7297 <rlc_pkt_receive_from_mac+0x657>
    724c:	66 3b 91 f0 22 00 00 	cmp    0x22f0(%ecx),%dx
    7253:	74 2c                	je     7281 <rlc_pkt_receive_from_mac+0x641>
    7255:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7258:	89 c8                	mov    %ecx,%eax
    725a:	e8 fc ff ff ff       	call   725b <rlc_pkt_receive_from_mac+0x61b>
    725f:	84 c0                	test   %al,%al
    7261:	0f 85 a1 02 00 00    	jne    7508 <rlc_pkt_receive_from_mac+0x8c8>
    7267:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    726a:	0f b7 90 ec 22 00 00 	movzwl 0x22ec(%eax),%edx
    7271:	66 39 90 f0 22 00 00 	cmp    %dx,0x22f0(%eax)
    7278:	0f 84 8a 02 00 00    	je     7508 <rlc_pkt_receive_from_mac+0x8c8>
    727e:	8b 40 14             	mov    0x14(%eax),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
    7281:	e8 fc ff ff ff       	call   7282 <rlc_pkt_receive_from_mac+0x642>
		amIns->reorderTimer = 0;
    7286:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7289:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    7290:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7297:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    729a:	0f b7 81 ee 22 00 00 	movzwl 0x22ee(%ecx),%eax
    72a1:	66 39 c2             	cmp    %ax,%dx
    72a4:	7c 0e                	jl     72b4 <rlc_pkt_receive_from_mac+0x674>
    72a6:	0f bf d2             	movswl %dx,%edx
    72a9:	98                   	cwtl   
    72aa:	81 ea 00 02 00 00    	sub    $0x200,%edx
    72b0:	39 d0                	cmp    %edx,%eax
    72b2:	7d 24                	jge    72d8 <rlc_pkt_receive_from_mac+0x698>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is scheduling\n");
		amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue ,amIns->reorderTimerCode);
    72b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72b7:	8b 50 18             	mov    0x18(%eax),%edx
    72ba:	8b 40 1c             	mov    0x1c(%eax),%eax
    72bd:	e8 fc ff ff ff       	call   72be <rlc_pkt_receive_from_mac+0x67e>
    72c2:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    72c5:	89 43 14             	mov    %eax,0x14(%ebx)
		amIns->vr_x = amIns->vr_h;
    72c8:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    72cf:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    72d6:	66 90                	xchg   %ax,%ax
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_x is updated to %d\n",amIns->vr_x);
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
    72d8:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    72dc:	c7 04 24 5e 04 00 00 	movl   $0x45e,(%esp)
    72e3:	c0 e8 05             	shr    $0x5,%al
    72e6:	83 e0 01             	and    $0x1,%eax
    72e9:	89 44 24 04          	mov    %eax,0x4(%esp)
    72ed:	e8 fc ff ff ff       	call   72ee <rlc_pkt_receive_from_mac+0x6ae>
	if(fixhead->P == 1)
    72f2:	f6 46 01 20          	testb  $0x20,0x1(%esi)
    72f6:	0f 85 2c 02 00 00    	jne    7528 <rlc_pkt_receive_from_mac+0x8e8>
			//amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
			//fsm_printf("After am receive_from_mac pollRetxRimer is running\n");
			//addpkt_recvData(amIns);				
			rlc_AM_pkt_receive_from_mac(amIns,skb);
			//    fsm_printf("time for rlc_AM_pkt_receive_from_mac(amIns,skb)\n");
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
    72fc:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    7302:	c7 04 24 8c 21 00 00 	movl   $0x218c,(%esp)
    7309:	89 44 24 04          	mov    %eax,0x4(%esp)
    730d:	e8 fc ff ff ff       	call   730e <rlc_pkt_receive_from_mac+0x6ce>
			FOUT;
    7312:	e9 eb f9 ff ff       	jmp    6d02 <rlc_pkt_receive_from_mac+0xc2>
    7317:	90                   	nop
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7318:	83 e0 03             	and    $0x3,%eax
    731b:	c1 e0 08             	shl    $0x8,%eax
    731e:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7320:	0f bf d0             	movswl %ax,%edx
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7323:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7327:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    732a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    732d:	e8 fc ff ff ff       	call   732e <rlc_pkt_receive_from_mac+0x6ee>
    7332:	84 c0                	test   %al,%al
    7334:	0f 84 45 07 00 00    	je     7a7f <rlc_pkt_receive_from_mac+0xe3f>
				pkt= NULL;
			}			
			FOUT;
		}
//,
		if(amIns->amRecvWindow[SN] != NULL)
    733a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    733d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7340:	81 c2 98 04 00 00    	add    $0x498,%edx
    7346:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    734a:	89 55 dc             	mov    %edx,-0x24(%ebp)
    734d:	85 c0                	test   %eax,%eax
    734f:	74 42                	je     7393 <rlc_pkt_receive_from_mac+0x753>
		{
			if(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)
    7351:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7355:	0f 84 24 07 00 00    	je     7a7f <rlc_pkt_receive_from_mac+0xe3f>
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received completly\n");
				FOUT;
			}
			else
			{
				if(amIns->amRecvWindow[SN]->pkt != NULL)
    735b:	8b 10                	mov    (%eax),%edx
    735d:	85 d2                	test   %edx,%edx
    735f:	74 1f                	je     7380 <rlc_pkt_receive_from_mac+0x740>
				{
					fsm_pkt_destroy(amIns->amRecvWindow[SN]->pkt);
    7361:	89 d0                	mov    %edx,%eax
    7363:	e8 fc ff ff ff       	call   7364 <rlc_pkt_receive_from_mac+0x724>
					amIns->amRecvWindow[SN]->pkt = NULL;
    7368:	8b 55 dc             	mov    -0x24(%ebp),%edx
    736b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    736e:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    7372:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				}
				if(amIns->amRecvWindow[SN] != NULL)
    7378:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    737c:	85 c0                	test   %eax,%eax
    737e:	74 13                	je     7393 <rlc_pkt_receive_from_mac+0x753>
				{
					fsm_mem_free(amIns->amRecvWindow[SN]);
    7380:	e8 fc ff ff ff       	call   7381 <rlc_pkt_receive_from_mac+0x741>
					amIns->amRecvWindow[SN] = NULL;
    7385:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7388:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    738b:	c7 44 82 0c 00 00 00 	movl   $0x0,0xc(%edx,%eax,4)
    7392:	00 
					//printk("RLC FREE: %d\n", freenum);
				}				
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received but not completly\n");
			}
		}
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    7393:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7398:	e8 fc ff ff ff       	call   7399 <rlc_pkt_receive_from_mac+0x759>
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
    739d:	89 18                	mov    %ebx,(%eax)
		ambuf->pktstatus = FULL_SDU;
		ambuf->pos = 0;
		ambuf->segnum = 0;
		ambuf->SN = SN;
    739f:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    73a3:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
		ambuf->pktstatus = FULL_SDU;
    73a9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		ambuf->pos = 0;
    73b0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		ambuf->segnum = 0;
    73b7:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    73be:	00 00 00 
		ambuf->SN = SN;
    73c1:	66 89 98 94 00 00 00 	mov    %bx,0x94(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    73c8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    73cb:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    73d1:	89 8b 60 02 00 00    	mov    %ecx,0x260(%ebx)
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    73d7:	81 c3 5c 02 00 00    	add    $0x25c,%ebx
    73dd:	89 98 9c 00 00 00    	mov    %ebx,0x9c(%eax)
		amIns->amRecvWindow[SN] = ambuf;
    73e3:	8b 5d dc             	mov    -0x24(%ebp),%ebx
	new->next = next;
	new->prev = prev;
    73e6:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
    73ec:	89 0a                	mov    %ecx,(%edx)
    73ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    73f1:	89 44 9a 0c          	mov    %eax,0xc(%edx,%ebx,4)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    73f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    73f8:	c7 04 24 cc 1e 00 00 	movl   $0x1ecc,(%esp)
    73ff:	89 54 24 04          	mov    %edx,0x4(%esp)
    7403:	e8 fc ff ff ff       	call   7404 <rlc_pkt_receive_from_mac+0x7c4>
    7408:	e9 a5 fd ff ff       	jmp    71b2 <rlc_pkt_receive_from_mac+0x572>
    740d:	8d 76 00             	lea    0x0(%esi),%esi
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
	switch(umRxIns->snFiledLength)
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
    7410:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    7416:	0f b6 00             	movzbl (%eax),%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
    7419:	89 c6                	mov    %eax,%esi
    741b:	83 e6 1f             	and    $0x1f,%esi
    741e:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
    7422:	0f bf f6             	movswl %si,%esi
    7425:	8b 44 b1 38          	mov    0x38(%ecx,%esi,4),%eax
    7429:	85 c0                	test   %eax,%eax
    742b:	0f 85 78 06 00 00    	jne    7aa9 <rlc_pkt_receive_from_mac+0xe69>
    7431:	89 c8                	mov    %ecx,%eax
    7433:	89 f2                	mov    %esi,%edx
    7435:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7438:	e8 fc ff ff ff       	call   7439 <rlc_pkt_receive_from_mac+0x7f9>
    743d:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7440:	84 c0                	test   %al,%al
    7442:	0f 85 61 06 00 00    	jne    7aa9 <rlc_pkt_receive_from_mac+0xe69>
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
    7448:	66 c7 45 e0 20 00    	movw   $0x20,-0x20(%ebp)
    744e:	e9 ab f9 ff ff       	jmp    6dfe <rlc_pkt_receive_from_mac+0x1be>
    7453:	90                   	nop
    7454:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
    7458:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    745e:	ba 02 00 00 00       	mov    $0x2,%edx
    7463:	66 c1 00 08          	rolw   $0x8,(%eax)
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
    7467:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    746d:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7470:	89 f0                	mov    %esi,%eax
    7472:	e8 fc ff ff ff       	call   7473 <rlc_pkt_receive_from_mac+0x833>
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    7477:	0f b6 46 01          	movzbl 0x1(%esi),%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    747b:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    747e:	0f b6 16             	movzbl (%esi),%edx
    7481:	83 e0 03             	and    $0x3,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7484:	0f bf b9 bc 10 00 00 	movswl 0x10bc(%ecx),%edi
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    748b:	c1 e0 08             	shl    $0x8,%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    748e:	09 d0                	or     %edx,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7490:	0f bf f0             	movswl %ax,%esi
    7493:	89 f2                	mov    %esi,%edx
    7495:	29 fa                	sub    %edi,%edx
    7497:	81 c2 00 04 00 00    	add    $0x400,%edx
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    749d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    74a1:	89 d0                	mov    %edx,%eax
    74a3:	c1 f8 1f             	sar    $0x1f,%eax
    74a6:	c1 e8 16             	shr    $0x16,%eax
    74a9:	01 c2                	add    %eax,%edx
    74ab:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    74b1:	29 c2                	sub    %eax,%edx
    74b3:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    74ba:	29 f8                	sub    %edi,%eax
    74bc:	05 00 04 00 00       	add    $0x400,%eax
    74c1:	89 c7                	mov    %eax,%edi
    74c3:	c1 ff 1f             	sar    $0x1f,%edi
    74c6:	c1 ef 16             	shr    $0x16,%edi
    74c9:	01 f8                	add    %edi,%eax
    74cb:	25 ff 03 00 00       	and    $0x3ff,%eax
    74d0:	29 f8                	sub    %edi,%eax
    74d2:	39 c2                	cmp    %eax,%edx
    74d4:	7d 0f                	jge    74e5 <rlc_pkt_receive_from_mac+0x8a5>
    74d6:	8b bc b1 b8 00 00 00 	mov    0xb8(%ecx,%esi,4),%edi
    74dd:	85 ff                	test   %edi,%edi
    74df:	0f 85 6c 05 00 00    	jne    7a51 <rlc_pkt_receive_from_mac+0xe11>
    74e5:	89 c8                	mov    %ecx,%eax
    74e7:	89 f2                	mov    %esi,%edx
    74e9:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    74ec:	e8 fc ff ff ff       	call   74ed <rlc_pkt_receive_from_mac+0x8ad>
    74f1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    74f4:	84 c0                	test   %al,%al
    74f6:	0f 85 55 05 00 00    	jne    7a51 <rlc_pkt_receive_from_mac+0xe11>
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
    74fc:	66 c7 45 e0 00 04    	movw   $0x400,-0x20(%ebp)
    7502:	e9 f7 f8 ff ff       	jmp    6dfe <rlc_pkt_receive_from_mac+0x1be>
    7507:	90                   	nop
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
		amIns->reorderTimer = 0;
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7508:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    750b:	8b 50 14             	mov    0x14(%eax),%edx
    750e:	85 d2                	test   %edx,%edx
    7510:	0f 85 c2 fd ff ff    	jne    72d8 <rlc_pkt_receive_from_mac+0x698>
    7516:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    751d:	e9 75 fd ff ff       	jmp    7297 <rlc_pkt_receive_from_mac+0x657>
    7522:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
	if(fixhead->P == 1)
	{
		fsm_printf("[RLC] amIns->statProhTimer = %d\n",amIns->statProhTimer);
    7528:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    752b:	8b 46 20             	mov    0x20(%esi),%eax
    752e:	c7 04 24 2c 21 00 00 	movl   $0x212c,(%esp)
    7535:	89 44 24 04          	mov    %eax,0x4(%esp)
    7539:	e8 fc ff ff ff       	call   753a <rlc_pkt_receive_from_mac+0x8fa>
		//
		if( !amIns->statProhTimer )
    753e:	8b 46 20             	mov    0x20(%esi),%eax
    7541:	85 c0                	test   %eax,%eax
    7543:	0f 85 b3 fd ff ff    	jne    72fc <rlc_pkt_receive_from_mac+0x6bc>
		{
			amIns->statFlag = true;
    7549:	c6 46 06 01          	movb   $0x1,0x6(%esi)
			fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the statProhTimer start\n");
    754d:	c7 04 24 50 21 00 00 	movl   $0x2150,(%esp)
    7554:	e8 fc ff ff ff       	call   7555 <rlc_pkt_receive_from_mac+0x915>
			amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    7559:	8b 56 24             	mov    0x24(%esi),%edx
    755c:	8b 46 28             	mov    0x28(%esi),%eax
    755f:	e8 fc ff ff ff       	call   7560 <rlc_pkt_receive_from_mac+0x920>
    7564:	89 46 20             	mov    %eax,0x20(%esi)
    7567:	e9 90 fd ff ff       	jmp    72fc <rlc_pkt_receive_from_mac+0x6bc>
    756c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	umbuf->SN = SN;
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
	if(umRxIns->snFiledLength == 5)
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
    7570:	89 7c b1 38          	mov    %edi,0x38(%ecx,%esi,4)
    7574:	e9 e6 f8 ff ff       	jmp    6e5f <rlc_pkt_receive_from_mac+0x21f>
    7579:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    7580:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		rlc_ctrl_pkt_recv(amIns, pkt);
    7583:	89 da                	mov    %ebx,%edx
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    7585:	83 80 a4 5a 00 00 01 	addl   $0x1,0x5aa4(%eax)
		rlc_ctrl_pkt_recv(amIns, pkt);
    758c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    758f:	e8 fc ff ff ff       	call   7590 <rlc_pkt_receive_from_mac+0x950>
    7594:	e9 63 fd ff ff       	jmp    72fc <rlc_pkt_receive_from_mac+0x6bc>
    7599:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    75a0:	8d 42 01             	lea    0x1(%edx),%eax
    75a3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    75a6:	89 c1                	mov    %eax,%ecx
    75a8:	c1 f9 1f             	sar    $0x1f,%ecx
    75ab:	c1 e9 16             	shr    $0x16,%ecx
    75ae:	01 c8                	add    %ecx,%eax
    75b0:	25 ff 03 00 00       	and    $0x3ff,%eax
    75b5:	29 c8                	sub    %ecx,%eax
    75b7:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    75be:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    75c5:	85 d2                	test   %edx,%edx
    75c7:	74 3b                	je     7604 <rlc_pkt_receive_from_mac+0x9c4>
    75c9:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    75cd:	75 35                	jne    7604 <rlc_pkt_receive_from_mac+0x9c4>
    75cf:	89 d9                	mov    %ebx,%ecx
    75d1:	eb 0b                	jmp    75de <rlc_pkt_receive_from_mac+0x99e>
    75d3:	90                   	nop
    75d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    75d8:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    75dc:	75 26                	jne    7604 <rlc_pkt_receive_from_mac+0x9c4>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    75de:	83 c0 01             	add    $0x1,%eax
    75e1:	89 c2                	mov    %eax,%edx
    75e3:	c1 fa 1f             	sar    $0x1f,%edx
    75e6:	c1 ea 16             	shr    $0x16,%edx
    75e9:	01 d0                	add    %edx,%eax
    75eb:	25 ff 03 00 00       	and    $0x3ff,%eax
    75f0:	29 d0                	sub    %edx,%eax
    75f2:	66 89 81 f2 22 00 00 	mov    %ax,0x22f2(%ecx)

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    75f9:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7600:	85 d2                	test   %edx,%edx
    7602:	75 d4                	jne    75d8 <rlc_pkt_receive_from_mac+0x998>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
    7604:	89 44 24 04          	mov    %eax,0x4(%esp)
    7608:	c7 04 24 54 20 00 00 	movl   $0x2054,(%esp)
    760f:	e8 fc ff ff ff       	call   7610 <rlc_pkt_receive_from_mac+0x9d0>
    7614:	e9 04 fc ff ff       	jmp    721d <rlc_pkt_receive_from_mac+0x5dd>
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
    7619:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    761c:	c7 04 24 8c 24 00 00 	movl   $0x248c,(%esp)
    7623:	e8 fc ff ff ff       	call   7624 <rlc_pkt_receive_from_mac+0x9e4>
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
    7628:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    762b:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    7632:	0f bf c7             	movswl %di,%eax
    7635:	8b 74 81 38          	mov    0x38(%ecx,%eax,4),%esi
    7639:	85 f6                	test   %esi,%esi
    763b:	0f 84 f3 f8 ff ff    	je     6f34 <rlc_pkt_receive_from_mac+0x2f4>
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7641:	83 c0 01             	add    $0x1,%eax
    7644:	89 c2                	mov    %eax,%edx
    7646:	c1 fa 1f             	sar    $0x1f,%edx
    7649:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    764b:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    764e:	89 d7                	mov    %edx,%edi
    7650:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7657:	8b 54 81 38          	mov    0x38(%ecx,%eax,4),%edx
    765b:	85 d2                	test   %edx,%edx
    765d:	74 31                	je     7690 <rlc_pkt_receive_from_mac+0xa50>
    765f:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    7666:	66 39 fe             	cmp    %di,%si
    7669:	7d 0a                	jge    7675 <rlc_pkt_receive_from_mac+0xa35>
    766b:	eb 23                	jmp    7690 <rlc_pkt_receive_from_mac+0xa50>
    766d:	8d 76 00             	lea    0x0(%esi),%esi
    7670:	66 39 d6             	cmp    %dx,%si
    7673:	7c 14                	jl     7689 <rlc_pkt_receive_from_mac+0xa49>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7675:	83 c0 01             	add    $0x1,%eax
    7678:	89 c2                	mov    %eax,%edx
    767a:	c1 fa 1f             	sar    $0x1f,%edx
    767d:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    767f:	0f bf c2             	movswl %dx,%eax
    7682:	83 7c 81 38 00       	cmpl   $0x0,0x38(%ecx,%eax,4)
    7687:	75 e7                	jne    7670 <rlc_pkt_receive_from_mac+0xa30>
    7689:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    7690:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7693:	89 44 24 04          	mov    %eax,0x4(%esp)
    7697:	c7 04 24 48 24 00 00 	movl   $0x2448,(%esp)
    769e:	e8 fc ff ff ff       	call   769f <rlc_pkt_receive_from_mac+0xa5f>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    76a3:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    76a6:	8d 51 18             	lea    0x18(%ecx),%edx
    76a9:	89 c8                	mov    %ecx,%eax
    76ab:	e8 fc ff ff ff       	call   76ac <rlc_pkt_receive_from_mac+0xa6c>
    76b0:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    76b3:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    76ba:	e9 75 f8 ff ff       	jmp    6f34 <rlc_pkt_receive_from_mac+0x2f4>
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
    76bf:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    76c6:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    76c9:	c7 04 24 bc 24 00 00 	movl   $0x24bc,(%esp)
    76d0:	89 44 24 04          	mov    %eax,0x4(%esp)
    76d4:	e8 fc ff ff ff       	call   76d5 <rlc_pkt_receive_from_mac+0xa95>
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
    76d9:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    76dc:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    76e3:	0f bf c7             	movswl %di,%eax
    76e6:	8b b4 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%esi
    76ed:	85 f6                	test   %esi,%esi
    76ef:	0f 84 3f f8 ff ff    	je     6f34 <rlc_pkt_receive_from_mac+0x2f4>
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
    76f5:	c7 04 24 04 25 00 00 	movl   $0x2504,(%esp)
    76fc:	e8 fc ff ff ff       	call   76fd <rlc_pkt_receive_from_mac+0xabd>
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7701:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7704:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    770b:	83 c0 01             	add    $0x1,%eax
    770e:	89 c2                	mov    %eax,%edx
    7710:	c1 fa 1f             	sar    $0x1f,%edx
    7713:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7715:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7718:	89 d7                	mov    %edx,%edi
    771a:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7721:	8b 94 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%edx
    7728:	85 d2                	test   %edx,%edx
    772a:	74 37                	je     7763 <rlc_pkt_receive_from_mac+0xb23>
    772c:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    7733:	66 39 f7             	cmp    %si,%di
    7736:	7e 0d                	jle    7745 <rlc_pkt_receive_from_mac+0xb05>
    7738:	eb 29                	jmp    7763 <rlc_pkt_receive_from_mac+0xb23>
    773a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7740:	66 39 f2             	cmp    %si,%dx
    7743:	7f 17                	jg     775c <rlc_pkt_receive_from_mac+0xb1c>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7745:	83 c0 01             	add    $0x1,%eax
    7748:	89 c2                	mov    %eax,%edx
    774a:	c1 fa 1f             	sar    $0x1f,%edx
    774d:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    774f:	0f bf c2             	movswl %dx,%eax
    7752:	83 bc 81 b8 00 00 00 	cmpl   $0x0,0xb8(%ecx,%eax,4)
    7759:	00 
    775a:	75 e4                	jne    7740 <rlc_pkt_receive_from_mac+0xb00>
    775c:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    7763:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7766:	89 44 24 04          	mov    %eax,0x4(%esp)
    776a:	c7 04 24 48 24 00 00 	movl   $0x2448,(%esp)
    7771:	e8 fc ff ff ff       	call   7772 <rlc_pkt_receive_from_mac+0xb32>
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    7776:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7779:	8d 51 18             	lea    0x18(%ecx),%edx
    777c:	89 c8                	mov    %ecx,%eax
    777e:	e8 fc ff ff ff       	call   777f <rlc_pkt_receive_from_mac+0xb3f>
    7783:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7786:	e9 a2 f7 ff ff       	jmp    6f2d <rlc_pkt_receive_from_mac+0x2ed>
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    778b:	83 b8 90 00 00 00 01 	cmpl   $0x1,0x90(%eax)
    7792:	0f 85 1a fa ff ff    	jne    71b2 <rlc_pkt_receive_from_mac+0x572>
				(amIns->amRecvWindow[SN]->segnum == 1)&&(amIns->amRecvWindow[SN]->segStart[0] == 0))
    7798:	8b 48 10             	mov    0x10(%eax),%ecx
    779b:	85 c9                	test   %ecx,%ecx
    779d:	0f 85 0f fa ff ff    	jne    71b2 <rlc_pkt_receive_from_mac+0x572>
			{
				amIns->amRecvWindow[SN]->pktstatus = FULL_SDU;
    77a3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    77aa:	e9 03 fa ff ff       	jmp    71b2 <rlc_pkt_receive_from_mac+0x572>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
    77af:	c7 04 24 b0 20 00 00 	movl   $0x20b0,(%esp)
    77b6:	e8 fc ff ff ff       	call   77b7 <rlc_pkt_receive_from_mac+0xb77>
		amIns->vr_r = (amIns->vr_r+1)%1024;
    77bb:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    77be:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    77c5:	83 c0 01             	add    $0x1,%eax
    77c8:	89 c2                	mov    %eax,%edx
    77ca:	c1 fa 1f             	sar    $0x1f,%edx
    77cd:	c1 ea 16             	shr    $0x16,%edx
    77d0:	01 d0                	add    %edx,%eax
    77d2:	25 ff 03 00 00       	and    $0x3ff,%eax
    77d7:	29 d0                	sub    %edx,%eax
    77d9:	66 89 83 f4 22 00 00 	mov    %ax,0x22f4(%ebx)
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    77e0:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    77e7:	85 d2                	test   %edx,%edx
    77e9:	74 39                	je     7824 <rlc_pkt_receive_from_mac+0xbe4>
    77eb:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    77ef:	75 33                	jne    7824 <rlc_pkt_receive_from_mac+0xbe4>
    77f1:	89 d9                	mov    %ebx,%ecx
    77f3:	eb 09                	jmp    77fe <rlc_pkt_receive_from_mac+0xbbe>
    77f5:	8d 76 00             	lea    0x0(%esi),%esi
    77f8:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    77fc:	75 26                	jne    7824 <rlc_pkt_receive_from_mac+0xbe4>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
    77fe:	83 c0 01             	add    $0x1,%eax
    7801:	89 c2                	mov    %eax,%edx
    7803:	c1 fa 1f             	sar    $0x1f,%edx
    7806:	c1 ea 16             	shr    $0x16,%edx
    7809:	01 d0                	add    %edx,%eax
    780b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7810:	29 d0                	sub    %edx,%eax
    7812:	66 89 81 f4 22 00 00 	mov    %ax,0x22f4(%ecx)
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
		amIns->vr_r = (amIns->vr_r+1)%1024;
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7819:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7820:	85 d2                	test   %edx,%edx
    7822:	75 d4                	jne    77f8 <rlc_pkt_receive_from_mac+0xbb8>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
		}
		amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 1024;
    7824:	05 00 02 00 00       	add    $0x200,%eax
    7829:	89 c2                	mov    %eax,%edx
    782b:	c1 fa 1f             	sar    $0x1f,%edx
    782e:	c1 ea 16             	shr    $0x16,%edx
    7831:	01 d0                	add    %edx,%eax
    7833:	25 ff 03 00 00       	and    $0x3ff,%eax
    7838:	29 d0                	sub    %edx,%eax
    783a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    783d:	66 89 82 ec 22 00 00 	mov    %ax,0x22ec(%edx)
		//amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_r is updated to %d, amIns->vr_mr is updated to %d\n",amIns->vr_r, amIns->vr_mr);
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
    7844:	c7 04 24 e8 20 00 00 	movl   $0x20e8,(%esp)
    784b:	e8 fc ff ff ff       	call   784c <rlc_pkt_receive_from_mac+0xc0c>
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    7850:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7853:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7856:	83 c2 30             	add    $0x30,%edx
    7859:	e8 fc ff ff ff       	call   785a <rlc_pkt_receive_from_mac+0xc1a>
    785e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7861:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    7868:	e9 d5 f9 ff ff       	jmp    7242 <rlc_pkt_receive_from_mac+0x602>
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    786d:	29 f2                	sub    %esi,%edx
    786f:	83 c2 30             	add    $0x30,%edx
    7872:	89 d6                	mov    %edx,%esi
    7874:	c1 fe 1f             	sar    $0x1f,%esi
    7877:	c1 ee 1b             	shr    $0x1b,%esi
    787a:	01 f2                	add    %esi,%edx
    787c:	83 e2 1f             	and    $0x1f,%edx
    787f:	29 f2                	sub    %esi,%edx
    7881:	83 fa 0f             	cmp    $0xf,%edx
    7884:	0f 9e c2             	setle  %dl
    7887:	e9 10 f7 ff ff       	jmp    6f9c <rlc_pkt_receive_from_mac+0x35c>

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    788c:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7891:	e8 fc ff ff ff       	call   7892 <rlc_pkt_receive_from_mac+0xc52>
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7896:	8b 4d d0             	mov    -0x30(%ebp),%ecx

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    7899:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    789c:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    78a0:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    78a4:	83 e0 7f             	and    $0x7f,%eax
    78a7:	c1 e0 08             	shl    $0x8,%eax
    78aa:	09 d0                	or     %edx,%eax
    78ac:	8b 55 d4             	mov    -0x2c(%ebp),%edx
			if(0 == ambuf->pos)
    78af:	85 c0                	test   %eax,%eax
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    78b1:	89 42 08             	mov    %eax,0x8(%edx)
			if(0 == ambuf->pos)
    78b4:	0f 85 e6 00 00 00    	jne    79a0 <rlc_pkt_receive_from_mac+0xd60>
			{
				ambuf->pkt = pkt;
    78ba:	89 1a                	mov    %ebx,(%edx)
    78bc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    78c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78c6:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
			ambuf->segnum = 1;
			ambuf->datalen = 0;
			if(extseghead->LSF == 1)
    78ca:	8b 4d d0             	mov    -0x30(%ebp),%ecx
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
			ambuf->segnum = 1;
    78cd:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    78d4:	00 00 00 
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    78d7:	66 89 90 94 00 00 00 	mov    %dx,0x94(%eax)
			ambuf->segnum = 1;
			ambuf->datalen = 0;
    78de:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    78e5:	00 00 00 
			if(extseghead->LSF == 1)
    78e8:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    78ec:	0f 89 9f 00 00 00    	jns    7991 <rlc_pkt_receive_from_mac+0xd51>
			{
				ambuf->pktstatus = LAST_SEGMENT;
    78f2:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				ambuf->datalen = ambuf->pos + pkt->len;
    78f9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    78fc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    78ff:	03 43 50             	add    0x50(%ebx),%eax
    7902:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
    7908:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    790b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    790e:	89 50 10             	mov    %edx,0x10(%eax)
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7911:	8b 4b 50             	mov    0x50(%ebx),%ecx
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7914:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    791a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    791d:	31 c9                	xor    %ecx,%ecx
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    791f:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    7923:	74 19                	je     793e <rlc_pkt_receive_from_mac+0xcfe>
	{
		count++;
		while(1 == (ind++)->E)
    7925:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    7929:	b1 01                	mov    $0x1,%cl
    792b:	79 11                	jns    793e <rlc_pkt_receive_from_mac+0xcfe>
    792d:	83 c0 06             	add    $0x6,%eax
    7930:	0f b6 50 01          	movzbl 0x1(%eax),%edx
		{
			count++;
    7934:	83 c1 01             	add    $0x1,%ecx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    7937:	83 c0 02             	add    $0x2,%eax
    793a:	84 d2                	test   %dl,%dl
    793c:	78 f2                	js     7930 <rlc_pkt_receive_from_mac+0xcf0>
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    793e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7941:	8b 5d cc             	mov    -0x34(%ebp),%ebx
    7944:	8d 54 18 fc          	lea    -0x4(%eax,%ebx,1),%edx
    7948:	0f b7 c1             	movzwl %cx,%eax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    794b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    794e:	f7 d8                	neg    %eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7950:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7953:	8d 04 42             	lea    (%edx,%eax,2),%eax
    7956:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7959:	89 42 50             	mov    %eax,0x50(%edx)
    795c:	8b 81 60 02 00 00    	mov    0x260(%ecx),%eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7962:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7968:	89 91 60 02 00 00    	mov    %edx,0x260(%ecx)
    796e:	81 c1 5c 02 00 00    	add    $0x25c,%ecx
    7974:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    797a:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    7980:	89 10                	mov    %edx,(%eax)
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been put into buffer(SN is %d)\n", SN);
			amIns->amRecvWindow[SN] = ambuf;
    7982:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7985:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7988:	89 5c 82 0c          	mov    %ebx,0xc(%edx,%eax,4)
    798c:	e9 21 f8 ff ff       	jmp    71b2 <rlc_pkt_receive_from_mac+0x572>
				ambuf->datalen = ambuf->pos + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", ambuf->datalen );
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
    7991:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7994:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    799b:	e9 68 ff ff ff       	jmp    7908 <rlc_pkt_receive_from_mac+0xcc8>
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    79a0:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    79a3:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
    79a7:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    79ab:	8b 4b 50             	mov    0x50(%ebx),%ecx
    79ae:	83 e2 7f             	and    $0x7f,%edx
    79b1:	c1 e2 08             	shl    $0x8,%edx
    79b4:	09 c2                	or     %eax,%edx
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    79b6:	89 d8                	mov    %ebx,%eax
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    79b8:	01 ca                	add    %ecx,%edx
    79ba:	89 55 cc             	mov    %edx,-0x34(%ebp)
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    79bd:	e8 fc ff ff ff       	call   79be <rlc_pkt_receive_from_mac+0xd7e>
    79c2:	03 45 cc             	add    -0x34(%ebp),%eax
    79c5:	e8 fc ff ff ff       	call   79c6 <rlc_pkt_receive_from_mac+0xd86>
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    79ca:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    79d0:	89 55 c8             	mov    %edx,-0x38(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    79d3:	8b 4d c8             	mov    -0x38(%ebp),%ecx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    79d6:	31 d2                	xor    %edx,%edx
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    79d8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    79db:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    79e1:	89 45 c0             	mov    %eax,-0x40(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    79e4:	f6 41 01 04          	testb  $0x4,0x1(%ecx)
    79e8:	74 1b                	je     7a05 <rlc_pkt_receive_from_mac+0xdc5>
	{
		count++;
		while(1 == (ind++)->E)
    79ea:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
    79ee:	b2 01                	mov    $0x1,%dl
    79f0:	79 13                	jns    7a05 <rlc_pkt_receive_from_mac+0xdc5>
    79f2:	89 c8                	mov    %ecx,%eax
    79f4:	83 c0 06             	add    $0x6,%eax
    79f7:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    79fb:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    79fe:	83 c0 02             	add    $0x2,%eax
    7a01:	84 c9                	test   %cl,%cl
    7a03:	78 f2                	js     79f7 <rlc_pkt_receive_from_mac+0xdb7>
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7a05:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7a08:	8b 4b 50             	mov    0x50(%ebx),%ecx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7a0b:	8b 40 08             	mov    0x8(%eax),%eax
    7a0e:	89 45 bc             	mov    %eax,-0x44(%ebp)
    7a11:	0f b7 c2             	movzwl %dx,%eax
    7a14:	8b 55 bc             	mov    -0x44(%ebp),%edx
    7a17:	8d 44 42 04          	lea    0x4(%edx,%eax,2),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7a1b:	8b 55 c8             	mov    -0x38(%ebp),%edx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7a1e:	03 45 c0             	add    -0x40(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7a21:	e8 fc ff ff ff       	call   7a22 <rlc_pkt_receive_from_mac+0xde2>
				fsm_skb_put(pkptr, datalen);
    7a26:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7a29:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7a2c:	e8 fc ff ff ff       	call   7a2d <rlc_pkt_receive_from_mac+0xded>
				if(pkt != NULL)
    7a31:	85 db                	test   %ebx,%ebx
    7a33:	74 07                	je     7a3c <rlc_pkt_receive_from_mac+0xdfc>
				{
					fsm_pkt_destroy(pkt);
    7a35:	89 d8                	mov    %ebx,%eax
    7a37:	e8 fc ff ff ff       	call   7a38 <rlc_pkt_receive_from_mac+0xdf8>
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
    7a3c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a3f:	31 db                	xor    %ebx,%ebx
    7a41:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7a44:	8b 48 08             	mov    0x8(%eax),%ecx
    7a47:	89 10                	mov    %edx,(%eax)
    7a49:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    7a4c:	e9 72 fe ff ff       	jmp    78c3 <rlc_pkt_receive_from_mac+0xc83>
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
		{
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7a51:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7a54:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7a5b:	89 d8                	mov    %ebx,%eax
    7a5d:	e8 fc ff ff ff       	call   7a5e <rlc_pkt_receive_from_mac+0xe1e>
			printk("rlc_macfsm 4361\n");
    7a62:	c7 04 24 86 04 00 00 	movl   $0x486,(%esp)
    7a69:	e8 fc ff ff ff       	call   7a6a <rlc_pkt_receive_from_mac+0xe2a>
    7a6e:	e9 8f f2 ff ff       	jmp    6d02 <rlc_pkt_receive_from_mac+0xc2>
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
		{
			printk("[RLC][rlc_AM_pkt_receive_from_mac] PDU segment is outside the receiving window or the segment has been received\n");
    7a73:	c7 04 24 64 1f 00 00 	movl   $0x1f64,(%esp)
    7a7a:	e8 fc ff ff ff       	call   7a7b <rlc_pkt_receive_from_mac+0xe3b>
			printk("[RLC][rlc_AM_pkt_receive_from_mac] A packet has dropped\n");
    7a7f:	c7 04 24 90 1e 00 00 	movl   $0x1e90,(%esp)
    7a86:	e8 fc ff ff ff       	call   7a87 <rlc_pkt_receive_from_mac+0xe47>
			SV(countDropPacket)++;
    7a8b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a8e:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			if(pkt != NULL)
    7a95:	85 db                	test   %ebx,%ebx
    7a97:	0f 84 5f f8 ff ff    	je     72fc <rlc_pkt_receive_from_mac+0x6bc>
			{
				fsm_pkt_destroy(pkt);
    7a9d:	89 d8                	mov    %ebx,%eax
    7a9f:	e8 fc ff ff ff       	call   7aa0 <rlc_pkt_receive_from_mac+0xe60>
    7aa4:	e9 53 f8 ff ff       	jmp    72fc <rlc_pkt_receive_from_mac+0x6bc>
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
    7aa9:	89 74 24 04          	mov    %esi,0x4(%esp)
    7aad:	c7 04 24 d4 22 00 00 	movl   $0x22d4,(%esp)
    7ab4:	e8 fc ff ff ff       	call   7ab5 <rlc_pkt_receive_from_mac+0xe75>
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7ab9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7abc:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7ac3:	89 d8                	mov    %ebx,%eax
    7ac5:	e8 fc ff ff ff       	call   7ac6 <rlc_pkt_receive_from_mac+0xe86>
			printk("rlc_macfsm 4328\n");
    7aca:	c7 04 24 75 04 00 00 	movl   $0x475,(%esp)
    7ad1:	e8 fc ff ff ff       	call   7ad2 <rlc_pkt_receive_from_mac+0xe92>
    7ad6:	e9 27 f2 ff ff       	jmp    6d02 <rlc_pkt_receive_from_mac+0xc2>
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7adb:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7adf:	c7 04 24 10 1e 00 00 	movl   $0x1e10,(%esp)
    7ae6:	89 44 24 04          	mov    %eax,0x4(%esp)
    7aea:	e8 fc ff ff ff       	call   7aeb <rlc_pkt_receive_from_mac+0xeab>
				break;
    7aef:	e9 57 f2 ff ff       	jmp    6d4b <rlc_pkt_receive_from_mac+0x10b>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
    7af4:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7af8:	c7 04 24 cc 1d 00 00 	movl   $0x1dcc,(%esp)
    7aff:	89 44 24 04          	mov    %eax,0x4(%esp)
    7b03:	e8 fc ff ff ff       	call   7b04 <rlc_pkt_receive_from_mac+0xec4>
				break;
    7b08:	e9 3e f2 ff ff       	jmp    6d4b <rlc_pkt_receive_from_mac+0x10b>
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7b0d:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7b11:	c7 04 24 f4 21 00 00 	movl   $0x21f4,(%esp)
    7b18:	89 44 24 04          	mov    %eax,0x4(%esp)
    7b1c:	e8 fc ff ff ff       	call   7b1d <rlc_pkt_receive_from_mac+0xedd>
				break;
    7b21:	e9 25 f2 ff ff       	jmp    6d4b <rlc_pkt_receive_from_mac+0x10b>
			break;

		case UM_MODE:
			if(insptrd == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
    7b26:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7b2a:	c7 04 24 b0 21 00 00 	movl   $0x21b0,(%esp)
    7b31:	89 44 24 04          	mov    %eax,0x4(%esp)
    7b35:	e8 fc ff ff ff       	call   7b36 <rlc_pkt_receive_from_mac+0xef6>
				break;
    7b3a:	e9 0c f2 ff ff       	jmp    6d4b <rlc_pkt_receive_from_mac+0x10b>
    7b3f:	90                   	nop

00007b40 <MACCETA_handle>:
//HQ
/**
 * @function: deal with Timing Advance control element
 * @param ta_index: Timing Advance Command
 */
void MACCETA_handle(unsigned char ta_index) {   
    7b40:	55                   	push   %ebp
    7b41:	89 e5                	mov    %esp,%ebp
    7b43:	56                   	push   %esi
    7b44:	53                   	push   %ebx
    7b45:	e8 fc ff ff ff       	call   7b46 <MACCETA_handle+0x6>
    7b4a:	89 c6                	mov    %eax,%esi
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7b4c:	e8 fc ff ff ff       	call   7b4d <MACCETA_handle+0xd>
    if(SV(TATimer.flag)==true)
    7b51:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
 */
void MACCETA_handle(unsigned char ta_index) {   
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7b58:	89 c3                	mov    %eax,%ebx
    if(SV(TATimer.flag)==true)
    7b5a:	74 0b                	je     7b67 <MACCETA_handle+0x27>
        fsm_schedule_cancel(SV(TATimer.timer_sign));
    7b5c:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    7b62:	e8 fc ff ff ff       	call   7b63 <MACCETA_handle+0x23>
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7b67:	8b 43 24             	mov    0x24(%ebx),%eax
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7b6a:	81 e6 ff 00 00 00    	and    $0xff,%esi
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7b70:	ba 0b 00 00 00       	mov    $0xb,%edx
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7b75:	83 ee 1f             	sub    $0x1f,%esi
    7b78:	c1 e6 04             	shl    $0x4,%esi
    7b7b:	66 01 73 22          	add    %si,0x22(%ebx)
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7b7f:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7b85:	6b c0 64             	imul   $0x64,%eax,%eax
    7b88:	e8 fc ff ff ff       	call   7b89 <MACCETA_handle+0x49>
	SV(TATimer.flag)=true;
    7b8d:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7b94:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
	SV(TATimer.flag)=true;
		
FOUT;
}
    7b9a:	5b                   	pop    %ebx
    7b9b:	5e                   	pop    %esi
    7b9c:	5d                   	pop    %ebp
    7b9d:	c3                   	ret    
    7b9e:	66 90                	xchg   %ax,%ax

00007ba0 <decomplexRarPdu>:
/**
 * @function: decomplex the RAR PDU to get the MAC RAR that belongs to the user
 * @param skb: the sk_buff that contains the RAR PDU
 * @return: is there MAC RAR in the RAR PDU that belongs to the user
 */
bool decomplexRarPdu(FSM_PKT *skb){		//RAR SDU	//RAR
    7ba0:	55                   	push   %ebp
    7ba1:	89 e5                	mov    %esp,%ebp
    7ba3:	57                   	push   %edi
    7ba4:	56                   	push   %esi
    7ba5:	53                   	push   %ebx
    7ba6:	83 ec 3c             	sub    $0x3c,%esp
    7ba9:	e8 fc ff ff ff       	call   7baa <decomplexRarPdu+0xa>
    7bae:	89 45 e0             	mov    %eax,-0x20(%ebp)
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
	MAC_RAR_subhead_withbi *bi_subhead=(MAC_RAR_subhead_withbi*)fsm_mem_alloc(sizeof(MAC_RAR_subhead_withbi));	//20140430
    7bb1:	b8 01 00 00 00       	mov    $0x1,%eax
    7bb6:	e8 fc ff ff ff       	call   7bb7 <decomplexRarPdu+0x17>
    7bbb:	89 45 d0             	mov    %eax,-0x30(%ebp)
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
    7bbe:	b8 01 00 00 00       	mov    $0x1,%eax
    7bc3:	e8 fc ff ff ff       	call   7bc4 <decomplexRarPdu+0x24>
    7bc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
    7bcb:	b8 06 00 00 00       	mov    $0x6,%eax
    7bd0:	e8 fc ff ff ff       	call   7bd1 <decomplexRarPdu+0x31>
    7bd5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
    7bd8:	b8 04 00 00 00       	mov    $0x4,%eax
    7bdd:	e8 fc ff ff ff       	call   7bde <decomplexRarPdu+0x3e>
    7be2:	89 45 cc             	mov    %eax,-0x34(%ebp)
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));
    7be5:	b8 07 00 00 00       	mov    $0x7,%eax
    7bea:	e8 fc ff ff ff       	call   7beb <decomplexRarPdu+0x4b>
    7bef:	89 45 c8             	mov    %eax,-0x38(%ebp)

	SV_PTR_GET(rlc_mac_sv);
    7bf2:	e8 fc ff ff ff       	call   7bf3 <decomplexRarPdu+0x53>
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7bf7:	31 d2                	xor    %edx,%edx
    7bf9:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));

	SV_PTR_GET(rlc_mac_sv);
    7bfe:	89 45 dc             	mov    %eax,-0x24(%ebp)
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7c01:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7c04:	e8 fc ff ff ff       	call   7c05 <decomplexRarPdu+0x65>
	fsm_mem_set(rar_subhead,0,sizeof(MAC_RAR_subhead));	//20140430
    7c09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7c0c:	31 d2                	xor    %edx,%edx
    7c0e:	b9 01 00 00 00       	mov    $0x1,%ecx
    7c13:	e8 fc ff ff ff       	call   7c14 <decomplexRarPdu+0x74>
	fsm_mem_set(rar_sdu,0,sizeof(MAC_RAR_sdu));	//20140430
    7c18:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7c1b:	31 d2                	xor    %edx,%edx
    7c1d:	b9 06 00 00 00       	mov    $0x6,%ecx
    7c22:	e8 fc ff ff ff       	call   7c23 <decomplexRarPdu+0x83>
	fsm_mem_set(rar_ulgrant,0,sizeof(RAR_ULgrant));	//20141111modified
    7c27:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7c2a:	31 d2                	xor    %edx,%edx
    7c2c:	b9 04 00 00 00       	mov    $0x4,%ecx
    7c31:	e8 fc ff ff ff       	call   7c32 <decomplexRarPdu+0x92>
	fsm_mem_set(phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    7c36:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7c39:	31 d2                	xor    %edx,%edx
    7c3b:	b9 07 00 00 00       	mov    $0x7,%ecx
    7c40:	e8 fc ff ff ff       	call   7c41 <decomplexRarPdu+0xa1>
		fsm_printf("%c,",*((char *)skb->data+offset));
	}
	fsm_printf("\n");*/
	//fsm_octets_print(newskb->data,4);
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
    7c45:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7c48:	b9 01 00 00 00       	mov    $0x1,%ecx
    7c4d:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    7c53:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7c56:	e8 fc ff ff ff       	call   7c57 <decomplexRarPdu+0xb7>
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
    7c5b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7c5e:	0f b6 10             	movzbl (%eax),%edx
    7c61:	89 d0                	mov    %edx,%eax
    7c63:	c0 e8 06             	shr    $0x6,%al
    7c66:	0f b6 c0             	movzbl %al,%eax
	if(typ_flag==0||typ_flag==2){		//BI
    7c69:	83 f8 02             	cmp    $0x2,%eax
    7c6c:	0f 84 5e 01 00 00    	je     7dd0 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7c72:	31 ff                	xor    %edi,%edi
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
    7c74:	85 c0                	test   %eax,%eax
    7c76:	0f 84 54 01 00 00    	je     7dd0 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7c7c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7c7f:	8b 75 e0             	mov    -0x20(%ebp),%esi
    7c82:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7c89:	89 7d ec             	mov    %edi,-0x14(%ebp)
    7c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7c90:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    7c96:	b9 01 00 00 00       	mov    $0x1,%ecx
    7c9b:	89 d8                	mov    %ebx,%eax
	else{
		continue_flag=true;
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
    7c9d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7ca1:	01 fa                	add    %edi,%edx
		from_len=from_len+sizeof(MAC_RAR_subhead);
    7ca3:	83 c7 01             	add    $0x1,%edi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7ca6:	e8 fc ff ff ff       	call   7ca7 <decomplexRarPdu+0x107>
		from_len=from_len+sizeof(MAC_RAR_subhead);
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
    7cab:	80 3b 00             	cmpb   $0x0,(%ebx)
    7cae:	78 e0                	js     7c90 <decomplexRarPdu+0xf0>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7cb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7cb3:	89 fe                	mov    %edi,%esi
    7cb5:	89 74 24 08          	mov    %esi,0x8(%esp)
    7cb9:	8b 7d ec             	mov    -0x14(%ebp),%edi
    7cbc:	c7 04 24 b8 26 00 00 	movl   $0x26b8,(%esp)
    7cc3:	89 44 24 04          	mov    %eax,0x4(%esp)
    7cc7:	e8 fc ff ff ff       	call   7cc8 <decomplexRarPdu+0x128>

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7ccc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ccf:	85 c0                	test   %eax,%eax
    7cd1:	0f 84 f3 00 00 00    	je     7dca <decomplexRarPdu+0x22a>
    7cd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    7cde:	eb 4a                	jmp    7d2a <decomplexRarPdu+0x18a>
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7ce0:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7ce4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7ce8:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7cef:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7cf3:	e8 fc ff ff ff       	call   7cf4 <decomplexRarPdu+0x154>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7cf8:	0f bf 55 d6          	movswl -0x2a(%ebp),%edx
    7cfc:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    7cff:	89 54 24 04          	mov    %edx,0x4(%esp)
    7d03:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    7d0a:	e8 fc ff ff ff       	call   7d0b <decomplexRarPdu+0x16b>
		if(rapid_in_subhead==my_id){	//RAR
    7d0f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7d12:	39 da                	cmp    %ebx,%edx
    7d14:	0f 84 1f 01 00 00    	je     7e39 <decomplexRarPdu+0x299>
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7d1a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7d1e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d21:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7d24:	0f 84 a0 00 00 00    	je     7dca <decomplexRarPdu+0x22a>
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7d2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d2d:	89 fa                	mov    %edi,%edx
    7d2f:	b9 01 00 00 00       	mov    $0x1,%ecx
		head_len=head_len+len;
    7d34:	83 c7 01             	add    $0x1,%edi

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7d37:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7d3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d40:	e8 fc ff ff ff       	call   7d41 <decomplexRarPdu+0x1a1>
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7d45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d48:	0f b6 18             	movzbl (%eax),%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7d4b:	c7 04 24 a4 04 00 00 	movl   $0x4a4,(%esp)

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7d52:	83 e3 3f             	and    $0x3f,%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7d55:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7d59:	e8 fc ff ff ff       	call   7d5a <decomplexRarPdu+0x1ba>

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7d5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d61:	89 f2                	mov    %esi,%edx
    7d63:	b9 06 00 00 00       	mov    $0x6,%ecx

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
    7d68:	83 c6 06             	add    $0x6,%esi
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7d6b:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7d71:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7d74:	e8 fc ff ff ff       	call   7d75 <decomplexRarPdu+0x1d5>

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
    7d79:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d7c:	8b 82 fc 01 00 00    	mov    0x1fc(%edx),%eax
    7d82:	85 c0                	test   %eax,%eax
    7d84:	0f 84 56 ff ff ff    	je     7ce0 <decomplexRarPdu+0x140>
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
			
		}
		else
		{
			SV(rar_failed_num)=SV(rar_failed_num)-1;
    7d8a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7d8d:	83 e8 01             	sub    $0x1,%eax
    7d90:	89 82 fc 01 00 00    	mov    %eax,0x1fc(%edx)
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7d96:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7d9a:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
    7da1:	e8 fc ff ff ff       	call   7da2 <decomplexRarPdu+0x202>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7da6:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
    7dad:	00 
    7dae:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    7db5:	e8 fc ff ff ff       	call   7db6 <decomplexRarPdu+0x216>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7dba:	8b 55 e8             	mov    -0x18(%ebp),%edx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7dbd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7dc1:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7dc4:	0f 85 60 ff ff ff    	jne    7d2a <decomplexRarPdu+0x18a>
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7dca:	31 db                	xor    %ebx,%ebx
    7dcc:	eb 2f                	jmp    7dfd <decomplexRarPdu+0x25d>
    7dce:	66 90                	xchg   %ax,%ax
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7dd0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7dd3:	89 d0                	mov    %edx,%eax
    7dd5:	83 e0 0f             	and    $0xf,%eax
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7dd8:	84 d2                	test   %dl,%dl
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7dda:	89 41 1c             	mov    %eax,0x1c(%ecx)
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7ddd:	78 50                	js     7e2f <decomplexRarPdu+0x28f>
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7ddf:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    7de6:	00 
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7de7:	31 db                	xor    %ebx,%ebx
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7de9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    7df0:	00 
    7df1:	c7 04 24 b8 26 00 00 	movl   $0x26b8,(%esp)
    7df8:	e8 fc ff ff ff       	call   7df9 <decomplexRarPdu+0x259>
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
	}
	fsm_mem_free(bi_subhead);
    7dfd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7e00:	e8 fc ff ff ff       	call   7e01 <decomplexRarPdu+0x261>
	fsm_mem_free(rar_subhead);
    7e05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e08:	e8 fc ff ff ff       	call   7e09 <decomplexRarPdu+0x269>
	fsm_mem_free(rar_sdu);
    7e0d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7e10:	e8 fc ff ff ff       	call   7e11 <decomplexRarPdu+0x271>
	fsm_mem_free(rar_ulgrant);	//20141111modified
    7e15:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7e18:	e8 fc ff ff ff       	call   7e19 <decomplexRarPdu+0x279>
	fsm_mem_free(phy_ici);
    7e1d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7e20:	e8 fc ff ff ff       	call   7e21 <decomplexRarPdu+0x281>
	FRET(return_value);
}
    7e25:	89 d8                	mov    %ebx,%eax
    7e27:	83 c4 3c             	add    $0x3c,%esp
    7e2a:	5b                   	pop    %ebx
    7e2b:	5e                   	pop    %esi
    7e2c:	5f                   	pop    %edi
    7e2d:	5d                   	pop    %ebp
    7e2e:	c3                   	ret    
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
		SV(backoff_index)=bi;
		from_len=from_len+len;
    7e2f:	bf 01 00 00 00       	mov    $0x1,%edi
    7e34:	e9 43 fe ff ff       	jmp    7c7c <decomplexRarPdu+0xdc>
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
    7e39:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7e3c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7e3f:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    7e43:	66 89 42 02          	mov    %ax,0x2(%edx)
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
    7e47:	89 44 24 04          	mov    %eax,0x4(%esp)
    7e4b:	c7 04 24 e2 04 00 00 	movl   $0x4e2,(%esp)
    7e52:	e8 fc ff ff ff       	call   7e53 <decomplexRarPdu+0x2b3>
			
			tadvance=(rar_sdu->m_r_ta)&127;
    7e57:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7e5a:	0f b6 01             	movzbl (%ecx),%eax
			tadvance=tadvance<<4;
    7e5d:	89 c2                	mov    %eax,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7e5f:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
			
			tadvance=(rar_sdu->m_r_ta)&127;
			tadvance=tadvance<<4;
    7e63:	83 e2 7f             	and    $0x7f,%edx
    7e66:	c1 e2 04             	shl    $0x4,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7e69:	c0 e8 04             	shr    $0x4,%al
    7e6c:	0f b6 c0             	movzbl %al,%eax
    7e6f:	01 d0                	add    %edx,%eax
    7e71:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7e74:	66 89 42 20          	mov    %ax,0x20(%edx)
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
    7e78:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			ul_grant=ul_grant<<12;
    7e7c:	c1 e0 10             	shl    $0x10,%eax
    7e7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7e82:	0f b7 51 02          	movzwl 0x2(%ecx),%edx
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7e86:	b9 04 00 00 00       	mov    $0x4,%ecx
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
			ul_grant=ul_grant<<12;
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7e8b:	01 d0                	add    %edx,%eax
    7e8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7e90:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7e93:	8d 55 f0             	lea    -0x10(%ebp),%edx
    7e96:	e8 fc ff ff ff       	call   7e97 <decomplexRarPdu+0x2f7>
			//m_tb_size=DoReceiveRARULgrant_Tbsize(ul_grant);	//make		//20140428 

			SV(recv_frame).frameNo=phy_ici->frameNo;	//add on 11,17.2014
    7e9b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    7e9e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7ea1:	0f b7 41 03          	movzwl 0x3(%ecx),%eax
    7ea5:	66 89 42 0a          	mov    %ax,0xa(%edx)
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014
    7ea9:	0f b7 41 05          	movzwl 0x5(%ecx),%eax
    7ead:	66 89 42 0c          	mov    %ax,0xc(%edx)

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
    7eb1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7eb4:	e8 fc ff ff ff       	call   7eb5 <decomplexRarPdu+0x315>
    7eb9:	89 c3                	mov    %eax,%ebx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
    7ebb:	89 44 24 04          	mov    %eax,0x4(%esp)
    7ebf:	c7 04 24 fc 04 00 00 	movl   $0x4fc,(%esp)
    7ec6:	e8 fc ff ff ff       	call   7ec7 <decomplexRarPdu+0x327>
			SV(UL_resource_info).m_tbsize=m_tb_size;		
    7ecb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7ece:	89 58 2c             	mov    %ebx,0x2c(%eax)
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
    7ed1:	bb 01 00 00 00       	mov    $0x1,%ebx
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
    7ed6:	c6 40 28 01          	movb   $0x1,0x28(%eax)
			break;
    7eda:	e9 1e ff ff ff       	jmp    7dfd <decomplexRarPdu+0x25d>
    7edf:	90                   	nop

00007ee0 <lteMacCEC_rntiSend>:
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    7ee0:	55                   	push   %ebp
    7ee1:	89 e5                	mov    %esp,%ebp
    7ee3:	83 ec 10             	sub    $0x10,%esp
    7ee6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    7ee9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    7eec:	89 7d fc             	mov    %edi,-0x4(%ebp)
    7eef:	e8 fc ff ff ff       	call   7ef0 <lteMacCEC_rntiSend+0x10>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7ef4:	31 db                	xor    %ebx,%ebx
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    7ef6:	89 c7                	mov    %eax,%edi
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
    7ef8:	e8 fc ff ff ff       	call   7ef9 <lteMacCEC_rntiSend+0x19>
    7efd:	89 c6                	mov    %eax,%esi
    7eff:	90                   	nop
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
    7f00:	80 bc de a5 01 00 00 	cmpb   $0x1b,0x1a5(%esi,%ebx,8)
    7f07:	1b 
    7f08:	74 1e                	je     7f28 <lteMacCEC_rntiSend+0x48>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7f0a:	83 c3 01             	add    $0x1,%ebx
    7f0d:	83 fb 08             	cmp    $0x8,%ebx
    7f10:	75 ee                	jne    7f00 <lteMacCEC_rntiSend+0x20>
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    7f12:	8b 5d f4             	mov    -0xc(%ebp),%ebx
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
    7f15:	31 c0                	xor    %eax,%eax
}
    7f17:	8b 75 f8             	mov    -0x8(%ebp),%esi
    7f1a:	8b 7d fc             	mov    -0x4(%ebp),%edi
    7f1d:	89 ec                	mov    %ebp,%esp
    7f1f:	5d                   	pop    %ebp
    7f20:	c3                   	ret    
    7f21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    7f28:	83 c3 34             	add    $0x34,%ebx
	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");
    7f2b:	c7 04 24 e4 26 00 00 	movl   $0x26e4,(%esp)
    7f32:	e8 fc ff ff ff       	call   7f33 <lteMacCEC_rntiSend+0x53>

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    7f37:	8b 44 de 08          	mov    0x8(%esi,%ebx,8),%eax
    7f3b:	0f b7 00             	movzwl (%eax),%eax
    7f3e:	66 89 07             	mov    %ax,(%edi)
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    7f41:	8b 7d fc             	mov    -0x4(%ebp),%edi

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
			
			//fsm_printf("[MAC CRNTI]RNTI IN SV:%d\n",SV(C_RNTI));
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    7f44:	0f b6 44 de 04       	movzbl 0x4(%esi,%ebx,8),%eax
		}
	}
	
	FRET(false);
}
    7f49:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    7f4c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    7f4f:	89 ec                	mov    %ebp,%esp
    7f51:	5d                   	pop    %ebp
    7f52:	c3                   	ret    
    7f53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    7f59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00007f60 <lteMacCEPhSend>:
/**
 * @function: fill in the Power Headroom control element
 * @param m_power_headroom: the structure of Power Headroom control element
 * @return: is there Power Headroom control element tfsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);o send
 */
bool lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom){		//
    7f60:	55                   	push   %ebp
    7f61:	89 e5                	mov    %esp,%ebp
    7f63:	e8 fc ff ff ff       	call   7f64 <lteMacCEPhSend+0x4>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
    7f68:	e8 fc ff ff ff       	call   7f69 <lteMacCEPhSend+0x9>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7f6d:	31 d2                	xor    %edx,%edx
    7f6f:	90                   	nop
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
    7f70:	80 bc d0 a5 01 00 00 	cmpb   $0x1a,0x1a5(%eax,%edx,8)
    7f77:	1a 
    7f78:	74 0e                	je     7f88 <lteMacCEPhSend+0x28>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    7f7a:	83 c2 01             	add    $0x1,%edx
    7f7d:	83 fa 08             	cmp    $0x8,%edx
    7f80:	75 ee                	jne    7f70 <lteMacCEPhSend+0x10>
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	FRET(false);
    7f82:	31 c0                	xor    %eax,%eax
}
    7f84:	5d                   	pop    %ebp
    7f85:	c3                   	ret    
    7f86:	66 90                	xchg   %ax,%ax

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    7f88:	0f b6 84 d0 a4 01 00 	movzbl 0x1a4(%eax,%edx,8),%eax
    7f8f:	00 
		}
	}
	FRET(false);
}
    7f90:	5d                   	pop    %ebp
    7f91:	c3                   	ret    
    7f92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    7f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00007fa0 <lteMacCcchSend>:
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7fa0:	55                   	push   %ebp
    7fa1:	89 e5                	mov    %esp,%ebp
    7fa3:	57                   	push   %edi
    7fa4:	56                   	push   %esi
    7fa5:	53                   	push   %ebx
    7fa6:	83 ec 2c             	sub    $0x2c,%esp
    7fa9:	e8 fc ff ff ff       	call   7faa <lteMacCcchSend+0xa>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    7fae:	bf 1f 00 00 00       	mov    $0x1f,%edi
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7fb3:	89 45 f0             	mov    %eax,-0x10(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    7fb6:	b8 0a 00 00 00       	mov    $0xa,%eax
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    7fbb:	89 55 ec             	mov    %edx,-0x14(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    7fbe:	e8 fc ff ff ff       	call   7fbf <lteMacCcchSend+0x1f>
    7fc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
    7fc6:	b8 01 00 00 00       	mov    $0x1,%eax
    7fcb:	e8 fc ff ff ff       	call   7fcc <lteMacCcchSend+0x2c>
    7fd0:	89 c3                	mov    %eax,%ebx
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    7fd2:	b8 03 00 00 00       	mov    $0x3,%eax
    7fd7:	e8 fc ff ff ff       	call   7fd8 <lteMacCcchSend+0x38>
    7fdc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    7fdf:	e8 fc ff ff ff       	call   7fe0 <lteMacCcchSend+0x40>
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    7fe4:	31 d2                	xor    %edx,%edx
    7fe6:	b9 0a 00 00 00       	mov    $0xa,%ecx
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    7feb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    7fee:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7ff1:	e8 fc ff ff ff       	call   7ff2 <lteMacCcchSend+0x52>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    7ff6:	31 d2                	xor    %edx,%edx
    7ff8:	b9 02 00 00 00       	mov    $0x2,%ecx
    7ffd:	89 d8                	mov    %ebx,%eax
    7fff:	e8 fc ff ff ff       	call   8000 <lteMacCcchSend+0x60>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
    8004:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8007:	31 d2                	xor    %edx,%edx
    8009:	b9 03 00 00 00       	mov    $0x3,%ecx
    800e:	e8 fc ff ff ff       	call   800f <lteMacCcchSend+0x6f>
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    8013:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8016:	b9 02 00 00 00       	mov    $0x2,%ecx
    801b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    801e:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    8024:	89 d8                	mov    %ebx,%eax
    8026:	e8 fc ff ff ff       	call   8027 <lteMacCcchSend+0x87>
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    802b:	0f b6 13             	movzbl (%ebx),%edx
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    802e:	21 d7                	and    %edx,%edi
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8030:	89 d0                	mov    %edx,%eax
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    8032:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8036:	c0 e8 05             	shr    $0x5,%al
    8039:	0f b6 f0             	movzbl %al,%esi
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    803c:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    8040:	c0 ea 07             	shr    $0x7,%dl
    8043:	0f b6 d2             	movzbl %dl,%edx
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    8046:	89 54 24 0c          	mov    %edx,0xc(%esp)
    804a:	89 55 d8             	mov    %edx,-0x28(%ebp)
    804d:	89 74 24 04          	mov    %esi,0x4(%esp)
    8051:	c7 04 24 0c 27 00 00 	movl   $0x270c,(%esp)
    8058:	e8 fc ff ff ff       	call   8059 <lteMacCcchSend+0xb9>
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    805d:	83 fe 01             	cmp    $0x1,%esi
    8060:	8b 55 d8             	mov    -0x28(%ebp),%edx
	/*for(i=0;i<4;i++){
		fsm_printf("%c,",*(skb->data+i));
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
    8063:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	
	while(continue_flag==1){
    806a:	0f 85 7d 00 00 00    	jne    80ed <lteMacCcchSend+0x14d>
		if(lcid==0){								//ccch
    8070:	85 ff                	test   %edi,%edi
    8072:	0f 84 ab 00 00 00    	je     8123 <lteMacCcchSend+0x183>
    8078:	66 31 f6             	xor    %si,%si
    807b:	31 ff                	xor    %edi,%edi
    807d:	eb 44                	jmp    80c3 <lteMacCcchSend+0x123>
    807f:	90                   	nop
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    8080:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
    8084:	83 c6 02             	add    $0x2,%esi
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    8087:	83 e0 7f             	and    $0x7f,%eax
				offset=offset+sdu_len;
    808a:	01 c7                	add    %eax,%edi
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    808c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    808f:	b9 02 00 00 00       	mov    $0x2,%ecx
    8094:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8097:	01 f2                	add    %esi,%edx
    8099:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    809f:	89 d8                	mov    %ebx,%eax
    80a1:	e8 fc ff ff ff       	call   80a2 <lteMacCcchSend+0x102>
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    80a6:	0f b6 03             	movzbl (%ebx),%eax
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    80a9:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    80ad:	89 c1                	mov    %eax,%ecx
				sdu_len=(m_7bit_subhead->m_f_l)&127;
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    80af:	c0 e8 05             	shr    $0x5,%al
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    80b2:	83 e1 1f             	and    $0x1f,%ecx
		f_domain=m_7bit_subhead->m_f_l>>7;
    80b5:	c0 ea 07             	shr    $0x7,%dl
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    80b8:	3c 01                	cmp    $0x1,%al
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    80ba:	0f b6 d2             	movzbl %dl,%edx
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    80bd:	75 29                	jne    80e8 <lteMacCcchSend+0x148>
		if(lcid==0){								//ccch
    80bf:	85 c9                	test   %ecx,%ecx
    80c1:	74 5d                	je     8120 <lteMacCcchSend+0x180>
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
    80c3:	83 fa 01             	cmp    $0x1,%edx
    80c6:	75 b8                	jne    8080 <lteMacCcchSend+0xe0>
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    80c8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
    80cb:	83 c6 03             	add    $0x3,%esi
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    80ce:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			sdu_len=sdu_len<<8;
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    80d2:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    80d6:	83 e0 7f             	and    $0x7f,%eax
			sdu_len=sdu_len<<8;
    80d9:	c1 e0 08             	shl    $0x8,%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    80dc:	01 d0                	add    %edx,%eax
			offset=offset+sdu_len;
    80de:	01 c7                	add    %eax,%edi
    80e0:	eb aa                	jmp    808c <lteMacCcchSend+0xec>
    80e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    80e8:	89 7d dc             	mov    %edi,-0x24(%ebp)
    80eb:	89 cf                	mov    %ecx,%edi
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
    80ed:	85 ff                	test   %edi,%edi
    80ef:	0f 84 c3 01 00 00    	je     82b8 <lteMacCcchSend+0x318>
	FIN(lteMacCcchSend());

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
    80f5:	be 01 00 00 00       	mov    $0x1,%esi
			skb_len = skb->tail - skb->data;
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
		}
	fsm_mem_free(m_rrc_request);
    80fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
    80fd:	e8 fc ff ff ff       	call   80fe <lteMacCcchSend+0x15e>
	fsm_mem_free(m_7bit_subhead);
    8102:	89 d8                	mov    %ebx,%eax
    8104:	e8 fc ff ff ff       	call   8105 <lteMacCcchSend+0x165>
	fsm_mem_free(m_15bit_subhead);
    8109:	8b 45 e8             	mov    -0x18(%ebp),%eax
    810c:	e8 fc ff ff ff       	call   810d <lteMacCcchSend+0x16d>
	FRET(ccch_or_not);
		//FRET(0);
}
    8111:	89 f0                	mov    %esi,%eax
    8113:	83 c4 2c             	add    $0x2c,%esp
    8116:	5b                   	pop    %ebx
    8117:	5e                   	pop    %esi
    8118:	5f                   	pop    %edi
    8119:	5d                   	pop    %ebp
    811a:	c3                   	ret    
    811b:	90                   	nop
    811c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8120:	89 7d dc             	mov    %edi,-0x24(%ebp)
	while(continue_flag==1){
		if(lcid==0){								//ccch
		    //fsm_printf("There are two SDU from CCCH ,error \n");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8123:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8126:	b9 0a 00 00 00       	mov    $0xa,%ecx
    812b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    812e:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    8134:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8137:	e8 fc ff ff ff       	call   8138 <lteMacCcchSend+0x198>
			/*
			SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity)&0x0000ffff;
			SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity&0x000f0000)>>32;
			*/
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    813c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    813f:	b9 05 00 00 00       	mov    $0x5,%ecx
    8144:	8b 75 e0             	mov    -0x20(%ebp),%esi
    8147:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    814d:	83 c6 01             	add    $0x1,%esi
    8150:	89 f2                	mov    %esi,%edx
    8152:	e8 fc ff ff ff       	call   8153 <lteMacCcchSend+0x1b3>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    8157:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    815a:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8160:	8b 00                	mov    (%eax),%eax
    8162:	c7 04 24 4c 27 00 00 	movl   $0x274c,(%esp)
    8169:	89 44 24 04          	mov    %eax,0x4(%esp)
    816d:	e8 fc ff ff ff       	call   816e <lteMacCcchSend+0x1ce>
			
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    8172:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8175:	b9 01 00 00 00       	mov    $0x1,%ecx
    817a:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8180:	89 f2                	mov    %esi,%edx
    8182:	83 c0 04             	add    $0x4,%eax
    8185:	e8 fc ff ff ff       	call   8186 <lteMacCcchSend+0x1e6>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    818a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    818d:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8193:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8197:	c7 04 24 70 27 00 00 	movl   $0x2770,(%esp)
    819e:	89 44 24 04          	mov    %eax,0x4(%esp)
    81a2:	e8 fc ff ff ff       	call   81a3 <lteMacCcchSend+0x203>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    81a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    81aa:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    81ad:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    81b3:	8b 41 06             	mov    0x6(%ecx),%eax
    81b6:	83 e0 0f             	and    $0xf,%eax
    81b9:	66 03 42 04          	add    0x4(%edx),%ax
    81bd:	c1 e0 08             	shl    $0x8,%eax
    81c0:	66 89 42 04          	mov    %ax,0x4(%edx)
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    81c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    81c7:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    81cd:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    81d1:	c7 04 24 70 27 00 00 	movl   $0x2770,(%esp)
    81d8:	89 44 24 04          	mov    %eax,0x4(%esp)
    81dc:	e8 fc ff ff ff       	call   81dd <lteMacCcchSend+0x23d>
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    81e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    81e4:	b9 0a 00 00 00       	mov    $0xa,%ecx
    81e9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    81ec:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    81f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    81f5:	e8 fc ff ff ff       	call   81f6 <lteMacCcchSend+0x256>
			//fsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);

			//SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity.randomValue)&0x0000ffff;	//randomValue32
			//SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity.randomValue&0x000f0000)>>32;	//randomValue33~40
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    81fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    81fd:	b9 05 00 00 00       	mov    $0x5,%ecx
    8202:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8208:	89 f2                	mov    %esi,%edx
    820a:	e8 fc ff ff ff       	call   820b <lteMacCcchSend+0x26b>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    820f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    8212:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8218:	8b 00                	mov    (%eax),%eax
    821a:	c7 04 24 4c 27 00 00 	movl   $0x274c,(%esp)
    8221:	89 44 24 04          	mov    %eax,0x4(%esp)
    8225:	e8 fc ff ff ff       	call   8226 <lteMacCcchSend+0x286>
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
    822a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    822d:	b9 02 00 00 00       	mov    $0x2,%ecx
    8232:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8238:	31 d2                	xor    %edx,%edx
    823a:	83 c0 04             	add    $0x4,%eax
    823d:	e8 fc ff ff ff       	call   823e <lteMacCcchSend+0x29e>
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    8242:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    8245:	89 f2                	mov    %esi,%edx
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
    8247:	31 f6                	xor    %esi,%esi
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    8249:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    824f:	b9 01 00 00 00       	mov    $0x1,%ecx
    8254:	83 c0 04             	add    $0x4,%eax
    8257:	e8 fc ff ff ff       	call   8258 <lteMacCcchSend+0x2b8>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    825c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    825f:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8265:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8269:	c7 04 24 70 27 00 00 	movl   $0x2770,(%esp)
    8270:	89 44 24 04          	mov    %eax,0x4(%esp)
    8274:	e8 fc ff ff ff       	call   8275 <lteMacCcchSend+0x2d5>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    8279:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    827c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    827f:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    8285:	8b 41 06             	mov    0x6(%ecx),%eax
    8288:	83 e0 0f             	and    $0xf,%eax
    828b:	66 03 42 04          	add    0x4(%edx),%ax
    828f:	c1 e0 08             	shl    $0x8,%eax
    8292:	66 89 42 04          	mov    %ax,0x4(%edx)
			//fsm_printf("[MAC CCCHSEND]%d\n",m_rrc_request->establishmentCause);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8296:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8299:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    829f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    82a3:	c7 04 24 70 27 00 00 	movl   $0x2770,(%esp)
    82aa:	89 44 24 04          	mov    %eax,0x4(%esp)
    82ae:	e8 fc ff ff ff       	call   82af <lteMacCcchSend+0x30f>
    82b3:	e9 42 fe ff ff       	jmp    80fa <lteMacCcchSend+0x15a>
    82b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    82bb:	8d 70 01             	lea    0x1(%eax),%esi
    82be:	e9 1e ff ff ff       	jmp    81e1 <lteMacCcchSend+0x241>
    82c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    82c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000082d0 <setMACtoRLC_IciMsg>:
 * @function: fill in the ICI from MAC to RLC
 * @param ici_msg: the structure of the ICI
 * @param pbch: the channel that carries the PDU
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
    82d0:	55                   	push   %ebp
    82d1:	89 e5                	mov    %esp,%ebp
    82d3:	83 ec 0c             	sub    $0xc,%esp
    82d6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    82d9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    82dc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    82df:	e8 fc ff ff ff       	call   82e0 <setMACtoRLC_IciMsg+0x10>
    82e4:	89 c3                	mov    %eax,%ebx
    82e6:	89 d6                	mov    %edx,%esi
    82e8:	89 cf                	mov    %ecx,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    82ea:	e8 fc ff ff ff       	call   82eb <setMACtoRLC_IciMsg+0x1b>
	ici_msg->lcid=lcid;
    82ef:	89 fa                	mov    %edi,%edx
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    82f1:	8b 7d fc             	mov    -0x4(%ebp),%edi
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
    82f4:	89 73 02             	mov    %esi,0x2(%ebx)
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    82f7:	8b 75 f8             	mov    -0x8(%ebp),%esi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    82fa:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    82fd:	0f b7 00             	movzwl (%eax),%eax
    8300:	66 89 03             	mov    %ax,(%ebx)
	FOUT;
}
    8303:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    8306:	89 ec                	mov    %ebp,%esp
    8308:	5d                   	pop    %ebp
    8309:	c3                   	ret    
    830a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008310 <setMACtoPHY_IciMsg>:
	SV(sys_frame).subframeNo=0;
		
	//
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
    8310:	55                   	push   %ebp
    8311:	89 e5                	mov    %esp,%ebp
    8313:	83 ec 0c             	sub    $0xc,%esp
    8316:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8319:	89 75 f8             	mov    %esi,-0x8(%ebp)
    831c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    831f:	e8 fc ff ff ff       	call   8320 <setMACtoPHY_IciMsg+0x10>
    8324:	89 d6                	mov    %edx,%esi
    8326:	89 cf                	mov    %ecx,%edi
    8328:	89 c3                	mov    %eax,%ebx
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
    832a:	e8 fc ff ff ff       	call   832b <setMACtoPHY_IciMsg+0x1b>
	ici_msg->tcid=tcid;
    832f:	89 f2                	mov    %esi,%edx
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    8331:	66 85 ff             	test   %di,%di
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
	ici_msg->tcid=tcid;
    8334:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    8337:	75 0c                	jne    8345 <setMACtoPHY_IciMsg+0x35>
    8339:	0f b7 38             	movzwl (%eax),%edi
    833c:	66 85 ff             	test   %di,%di
    833f:	75 04                	jne    8345 <setMACtoPHY_IciMsg+0x35>
    8341:	0f b7 78 02          	movzwl 0x2(%eax),%edi
    8345:	66 89 7b 04          	mov    %di,0x4(%ebx)

	ici_msg->frameNo=SV(sys_frame).frameNo;
    8349:	0f b7 50 06          	movzwl 0x6(%eax),%edx
    834d:	66 89 13             	mov    %dx,(%ebx)
	ici_msg->subframeNo=SV(sys_frame).subframeNo;
    8350:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    8354:	66 89 53 02          	mov    %dx,0x2(%ebx)
	SV(sys_frame).frameNo=0;
    8358:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
	SV(sys_frame).subframeNo=0;
    835e:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		
	//
	FOUT;
}
    8364:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    8367:	8b 75 f8             	mov    -0x8(%ebp),%esi
    836a:	8b 7d fc             	mov    -0x4(%ebp),%edi
    836d:	89 ec                	mov    %ebp,%esp
    836f:	5d                   	pop    %ebp
    8370:	c3                   	ret    
    8371:	eb 0d                	jmp    8380 <lteMacCEBSRSend>
    8373:	90                   	nop
    8374:	90                   	nop
    8375:	90                   	nop
    8376:	90                   	nop
    8377:	90                   	nop
    8378:	90                   	nop
    8379:	90                   	nop
    837a:	90                   	nop
    837b:	90                   	nop
    837c:	90                   	nop
    837d:	90                   	nop
    837e:	90                   	nop
    837f:	90                   	nop

00008380 <lteMacCEBSRSend>:
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    8380:	55                   	push   %ebp
    8381:	89 e5                	mov    %esp,%ebp
    8383:	57                   	push   %edi
    8384:	56                   	push   %esi
    8385:	53                   	push   %ebx
    8386:	83 ec 08             	sub    $0x8,%esp
    8389:	e8 fc ff ff ff       	call   838a <lteMacCEBSRSend+0xa>
    838e:	89 c7                	mov    %eax,%edi
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    8390:	b8 1a 00 00 00       	mov    $0x1a,%eax
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    8395:	89 55 f0             	mov    %edx,-0x10(%ebp)
    8398:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    839b:	e8 fc ff ff ff       	call   839c <lteMacCEBSRSend+0x1c>
    83a0:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
    83a2:	e8 fc ff ff ff       	call   83a3 <lteMacCEBSRSend+0x23>

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    83a7:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    83ac:	31 d2                	xor    %edx,%edx
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);
    83ae:	89 c3                	mov    %eax,%ebx

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    83b0:	89 f0                	mov    %esi,%eax
    83b2:	e8 fc ff ff ff       	call   83b3 <lteMacCEBSRSend+0x33>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    83b7:	31 c0                	xor    %eax,%eax
    83b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
    83c0:	0f b6 94 c3 a5 01 00 	movzbl 0x1a5(%ebx,%eax,8),%edx
    83c7:	00 
    83c8:	80 fa 1d             	cmp    $0x1d,%dl
    83cb:	74 2b                	je     83f8 <lteMacCEBSRSend+0x78>
					*lcg_id=0;
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
    83cd:	80 fa 1e             	cmp    $0x1e,%dl
    83d0:	0f 84 92 00 00 00    	je     8468 <lteMacCEBSRSend+0xe8>
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    83d6:	83 c0 01             	add    $0x1,%eax
    83d9:	83 f8 08             	cmp    $0x8,%eax
    83dc:	75 e2                	jne    83c0 <lteMacCEBSRSend+0x40>
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    83de:	89 f0                	mov    %esi,%eax
	FRET(0);
    83e0:	31 db                	xor    %ebx,%ebx
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    83e2:	e8 fc ff ff ff       	call   83e3 <lteMacCEBSRSend+0x63>
	FRET(0);
}
    83e7:	89 d8                	mov    %ebx,%eax
    83e9:	83 c4 08             	add    $0x8,%esp
    83ec:	5b                   	pop    %ebx
    83ed:	5e                   	pop    %esi
    83ee:	5f                   	pop    %edi
    83ef:	5d                   	pop    %ebp
    83f0:	c3                   	ret    
    83f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    83f8:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    83ff:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    8404:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    8406:	31 db                	xor    %ebx,%ebx
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8408:	e8 fc ff ff ff       	call   8409 <lteMacCEBSRSend+0x89>
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    840d:	8b 46 06             	mov    0x6(%esi),%eax
    8410:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8413:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8415:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8418:	31 c0                	xor    %eax,%eax
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
    841a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    841e:	85 c9                	test   %ecx,%ecx
    8420:	74 36                	je     8458 <lteMacCEBSRSend+0xd8>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8422:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8424:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
					lcg_numb++;
    8428:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    842b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    842e:	83 fb 01             	cmp    $0x1,%ebx
    8431:	76 06                	jbe    8439 <lteMacCEBSRSend+0xb9>
					*lcg_id=0;
    8433:	c7 07 00 00 00 00    	movl   $0x0,(%edi)

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8439:	83 c0 01             	add    $0x1,%eax
    843c:	83 f8 04             	cmp    $0x4,%eax
    843f:	75 d9                	jne    841a <lteMacCEBSRSend+0x9a>
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
    8441:	89 f0                	mov    %esi,%eax
    8443:	e8 fc ff ff ff       	call   8444 <lteMacCEBSRSend+0xc4>
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
	FRET(0);
}
    8448:	83 c4 08             	add    $0x8,%esp
    844b:	89 d8                	mov    %ebx,%eax
    844d:	5b                   	pop    %ebx
    844e:	5e                   	pop    %esi
    844f:	5f                   	pop    %edi
    8450:	5d                   	pop    %ebp
    8451:	c3                   	ret    
    8452:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    8458:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    845f:	eb cd                	jmp    842e <lteMacCEBSRSend+0xae>
    8461:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8468:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    846f:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    8474:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    8476:	31 db                	xor    %ebx,%ebx
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8478:	e8 fc ff ff ff       	call   8479 <lteMacCEBSRSend+0xf9>
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    847d:	8b 46 06             	mov    0x6(%esi),%eax
    8480:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8483:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8485:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8488:	31 c0                	xor    %eax,%eax
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
    848a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    848e:	85 c9                	test   %ecx,%ecx
    8490:	74 36                	je     84c8 <lteMacCEBSRSend+0x148>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8492:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8494:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
					lcg_numb++;
    8498:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    849b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    849e:	83 fb 01             	cmp    $0x1,%ebx
    84a1:	76 06                	jbe    84a9 <lteMacCEBSRSend+0x129>
					*lcg_id=0;
    84a3:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    84a9:	83 c0 01             	add    $0x1,%eax
    84ac:	83 f8 04             	cmp    $0x4,%eax
    84af:	75 d9                	jne    848a <lteMacCEBSRSend+0x10a>
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    84b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
			fsm_mem_free(m_bsr_infor);
    84b4:	89 f0                	mov    %esi,%eax
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    84b6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			fsm_mem_free(m_bsr_infor);
    84bc:	e8 fc ff ff ff       	call   84bd <lteMacCEBSRSend+0x13d>
    84c1:	eb 85                	jmp    8448 <lteMacCEBSRSend+0xc8>
    84c3:	90                   	nop
    84c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    84c8:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    84cf:	eb cd                	jmp    849e <lteMacCEBSRSend+0x11e>
    84d1:	eb 0d                	jmp    84e0 <lteMacGetDlHeadLength>
    84d3:	90                   	nop
    84d4:	90                   	nop
    84d5:	90                   	nop
    84d6:	90                   	nop
    84d7:	90                   	nop
    84d8:	90                   	nop
    84d9:	90                   	nop
    84da:	90                   	nop
    84db:	90                   	nop
    84dc:	90                   	nop
    84dd:	90                   	nop
    84de:	90                   	nop
    84df:	90                   	nop

000084e0 <lteMacGetDlHeadLength>:
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    84e0:	55                   	push   %ebp
    84e1:	89 e5                	mov    %esp,%ebp
    84e3:	57                   	push   %edi
    84e4:	56                   	push   %esi
    84e5:	53                   	push   %ebx
    84e6:	83 ec 1c             	sub    $0x1c,%esp
    84e9:	e8 fc ff ff ff       	call   84ea <lteMacGetDlHeadLength+0xa>
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
    84ee:	31 db                	xor    %ebx,%ebx
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    84f0:	89 c7                	mov    %eax,%edi
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    84f2:	b8 03 00 00 00       	mov    $0x3,%eax
    84f7:	e8 fc ff ff ff       	call   84f8 <lteMacGetDlHeadLength+0x18>
    84fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
    84ff:	b8 01 00 00 00       	mov    $0x1,%eax
    8504:	e8 fc ff ff ff       	call   8505 <lteMacGetDlHeadLength+0x25>
    8509:	89 c6                	mov    %eax,%esi
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    850b:	b8 02 00 00 00       	mov    $0x2,%eax
    8510:	e8 fc ff ff ff       	call   8511 <lteMacGetDlHeadLength+0x31>

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8515:	31 d2                	xor    %edx,%edx
    8517:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    851c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    851f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8522:	e8 fc ff ff ff       	call   8523 <lteMacGetDlHeadLength+0x43>
	fsm_mem_set(fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8527:	31 d2                	xor    %edx,%edx
    8529:	b9 01 00 00 00       	mov    $0x1,%ecx
    852e:	89 f0                	mov    %esi,%eax
    8530:	e8 fc ff ff ff       	call   8531 <lteMacGetDlHeadLength+0x51>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8535:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8538:	31 d2                	xor    %edx,%edx
    853a:	b9 02 00 00 00       	mov    $0x2,%ecx
    853f:	e8 fc ff ff ff       	call   8540 <lteMacGetDlHeadLength+0x60>
	
	last_len=sizeof(MAC_SDU_subhead_last);
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
    8544:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    854a:	b9 01 00 00 00       	mov    $0x1,%ecx
    854f:	89 f0                	mov    %esi,%eax
    8551:	e8 fc ff ff ff       	call   8552 <lteMacGetDlHeadLength+0x72>
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
    8556:	0f b6 16             	movzbl (%esi),%edx
    8559:	89 d0                	mov    %edx,%eax
    855b:	c0 e8 05             	shr    $0x5,%al
	//20140626
	while(m_e==1){		//
    855e:	3c 01                	cmp    $0x1,%al
    8560:	74 50                	je     85b2 <lteMacGetDlHeadLength+0xd2>
    8562:	e9 89 00 00 00       	jmp    85f0 <lteMacGetDlHeadLength+0x110>
    8567:	90                   	nop
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
		switch(m_lcid){
    8568:	83 fa 1c             	cmp    $0x1c,%edx
    856b:	74 7b                	je     85e8 <lteMacGetDlHeadLength+0x108>
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
			break;
		default:
			fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    856d:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    8573:	b9 02 00 00 00       	mov    $0x2,%ecx
    8578:	8b 45 f0             	mov    -0x10(%ebp),%eax
    857b:	01 da                	add    %ebx,%edx
    857d:	e8 fc ff ff ff       	call   857e <lteMacGetDlHeadLength+0x9e>
			m_f=m_7bit_subhead->m_f_l>>7;
			if(m_f==1){
				from_len=from_len+subhead_15bit_len;
    8582:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8585:	8d 43 03             	lea    0x3(%ebx),%eax
    8588:	83 c3 02             	add    $0x2,%ebx
    858b:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    858f:	0f 48 d8             	cmovs  %eax,%ebx
			else{
				from_len=from_len+subhead_7bit_len;
			}
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
    8592:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    8598:	b9 01 00 00 00       	mov    $0x1,%ecx
    859d:	89 f0                	mov    %esi,%eax
    859f:	01 da                	add    %ebx,%edx
    85a1:	e8 fc ff ff ff       	call   85a2 <lteMacGetDlHeadLength+0xc2>
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
    85a6:	0f b6 16             	movzbl (%esi),%edx
    85a9:	89 d0                	mov    %edx,%eax
    85ab:	c0 e8 05             	shr    $0x5,%al
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
	//20140626
	while(m_e==1){		//
    85ae:	3c 01                	cmp    $0x1,%al
    85b0:	75 3e                	jne    85f0 <lteMacGetDlHeadLength+0x110>
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    85b2:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    85b5:	89 54 24 04          	mov    %edx,0x4(%esp)
    85b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    85bc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    85c0:	c7 04 24 94 27 00 00 	movl   $0x2794,(%esp)
    85c7:	e8 fc ff ff ff       	call   85c8 <lteMacGetDlHeadLength+0xe8>
		
		switch(m_lcid){
    85cc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    85cf:	83 fa 1d             	cmp    $0x1d,%edx
    85d2:	74 14                	je     85e8 <lteMacGetDlHeadLength+0x108>
    85d4:	76 92                	jbe    8568 <lteMacGetDlHeadLength+0x88>
    85d6:	83 fa 1e             	cmp    $0x1e,%edx
    85d9:	74 0d                	je     85e8 <lteMacGetDlHeadLength+0x108>
    85db:	83 fa 1f             	cmp    $0x1f,%edx
    85de:	66 90                	xchg   %ax,%ax
    85e0:	75 8b                	jne    856d <lteMacGetDlHeadLength+0x8d>
    85e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			break;
		case TIMING_ADVANCE_LCID :
			from_len=from_len+last_len;
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
    85e8:	83 c3 01             	add    $0x1,%ebx
			break;
    85eb:	eb a5                	jmp    8592 <lteMacGetDlHeadLength+0xb2>
    85ed:	8d 76 00             	lea    0x0(%esi),%esi
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    85f0:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    85f3:	89 54 24 04          	mov    %edx,0x4(%esp)
    85f7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    85fa:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    85fe:	c7 04 24 94 27 00 00 	movl   $0x2794,(%esp)
    8605:	e8 fc ff ff ff       	call   8606 <lteMacGetDlHeadLength+0x126>
		
	switch(m_lcid){		//while
    860a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		break;
	case DRX_LCID :
		from_len=from_len+last_len;
		break;
	case TIMING_ADVANCE_LCID :
		from_len=from_len+last_len;
    860d:	8d 43 01             	lea    0x1(%ebx),%eax
    8610:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    8613:	83 fa 1d             	cmp    $0x1d,%edx
    8616:	74 10                	je     8628 <lteMacGetDlHeadLength+0x148>
    8618:	76 36                	jbe    8650 <lteMacGetDlHeadLength+0x170>
    861a:	83 fa 1e             	cmp    $0x1e,%edx
    861d:	74 09                	je     8628 <lteMacGetDlHeadLength+0x148>
    861f:	83 fa 1f             	cmp    $0x1f,%edx
    8622:	75 31                	jne    8655 <lteMacGetDlHeadLength+0x175>
    8624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
			from_len=from_len+subhead_7bit_len;
		}
		break;
	}
	fsm_mem_free(m_15bit_subhead);
    8628:	8b 45 ec             	mov    -0x14(%ebp),%eax
    862b:	e8 fc ff ff ff       	call   862c <lteMacGetDlHeadLength+0x14c>
	fsm_mem_free(fixed_subhead);
    8630:	89 f0                	mov    %esi,%eax
    8632:	e8 fc ff ff ff       	call   8633 <lteMacGetDlHeadLength+0x153>
	fsm_mem_free(m_7bit_subhead);
    8637:	8b 45 f0             	mov    -0x10(%ebp),%eax
    863a:	e8 fc ff ff ff       	call   863b <lteMacGetDlHeadLength+0x15b>
	FRET(from_len);
}
    863f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8642:	83 c4 1c             	add    $0x1c,%esp
    8645:	5b                   	pop    %ebx
    8646:	5e                   	pop    %esi
    8647:	5f                   	pop    %edi
    8648:	5d                   	pop    %ebp
    8649:	c3                   	ret    
    864a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    8650:	83 fa 1c             	cmp    $0x1c,%edx
    8653:	74 d3                	je     8628 <lteMacGetDlHeadLength+0x148>
		break;
	case CONTENTION_RESOLUTION_LCID :
		from_len=from_len+last_len;
		break;
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    8655:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    865b:	b9 02 00 00 00       	mov    $0x2,%ecx
    8660:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8663:	01 da                	add    %ebx,%edx
    8665:	e8 fc ff ff ff       	call   8666 <lteMacGetDlHeadLength+0x186>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
    866a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    866d:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    8671:	78 14                	js     8687 <lteMacGetDlHeadLength+0x1a7>
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_7bit_len;
    8673:	83 c3 02             	add    $0x2,%ebx
		
			from_len=from_len+subhead_15bit_len;
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
    8676:	c7 04 24 1a 05 00 00 	movl   $0x51a,(%esp)
    867d:	e8 fc ff ff ff       	call   867e <lteMacGetDlHeadLength+0x19e>
		
			from_len=from_len+subhead_7bit_len;
    8682:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    8685:	eb a1                	jmp    8628 <lteMacGetDlHeadLength+0x148>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_15bit_len;
    8687:	83 c3 03             	add    $0x3,%ebx
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
    868a:	c7 04 24 d0 27 00 00 	movl   $0x27d0,(%esp)
    8691:	e8 fc ff ff ff       	call   8692 <lteMacGetDlHeadLength+0x1b2>
		
			from_len=from_len+subhead_15bit_len;
    8696:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    8699:	eb 8d                	jmp    8628 <lteMacGetDlHeadLength+0x148>
    869b:	90                   	nop
    869c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000086a0 <Pdcch_c_rnti>:
/**
 * @function: exclude the information in PCH, BCCH in the decomplexing to offer the result whether the MSG4 is successful
 * @param c_rnti: rnti in the PHY-T-MAC-ICI
 */

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
    86a0:	55                   	push   %ebp
    86a1:	89 e5                	mov    %esp,%ebp
    86a3:	53                   	push   %ebx
    86a4:	e8 fc ff ff ff       	call   86a5 <Pdcch_c_rnti+0x5>
    86a9:	89 c3                	mov    %eax,%ebx
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
    86ab:	e8 fc ff ff ff       	call   86ac <Pdcch_c_rnti+0xc>
	if(SV(sendmsg3)==1){//msg3
    86b0:	83 b8 ec 01 00 00 01 	cmpl   $0x1,0x1ec(%eax)
    86b7:	74 0f                	je     86c8 <Pdcch_c_rnti+0x28>
			fsm_schedule_self(0, ContentionResolution_Fail );//3
			//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution fail\n");
		}
	}
	else
		SV(pdcch_rnti)=0;
    86b9:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    86c0:	00 00 00 
	FOUT;
}
    86c3:	5b                   	pop    %ebx
    86c4:	5d                   	pop    %ebp
    86c5:	c3                   	ret    
    86c6:	66 90                	xchg   %ax,%ax

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    86c8:	0f b7 10             	movzwl (%eax),%edx
    86cb:	66 39 da             	cmp    %bx,%dx
    86ce:	74 20                	je     86f0 <Pdcch_c_rnti+0x50>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
				//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution successfully\n");
			}				
		}
		else if ((c_rnti !=SV(C_RNTI)) && SV(C_RNTI)!=0){//PDCCHCRNTI
    86d0:	66 85 d2             	test   %dx,%dx
    86d3:	74 ee                	je     86c3 <Pdcch_c_rnti+0x23>
			SV(pdcch_rnti)=0;//0
    86d5:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    86dc:	00 00 00 
			fsm_schedule_self(0, ContentionResolution_Fail );//3
    86df:	ba 05 00 00 00       	mov    $0x5,%edx
    86e4:	31 c0                	xor    %eax,%eax
    86e6:	e8 fc ff ff ff       	call   86e7 <Pdcch_c_rnti+0x47>
    86eb:	eb d6                	jmp    86c3 <Pdcch_c_rnti+0x23>
    86ed:	8d 76 00             	lea    0x0(%esi),%esi

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    86f0:	66 85 d2             	test   %dx,%dx
    86f3:	74 ce                	je     86c3 <Pdcch_c_rnti+0x23>
		{
			SV(pdcch_rnti)=1;//1
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    86f5:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
		{
			SV(pdcch_rnti)=1;//1
    86fc:	c7 80 f0 01 00 00 01 	movl   $0x1,0x1f0(%eax)
    8703:	00 00 00 
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8706:	74 bb                	je     86c3 <Pdcch_c_rnti+0x23>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
    8708:	ba 06 00 00 00       	mov    $0x6,%edx
    870d:	31 c0                	xor    %eax,%eax
    870f:	e8 fc ff ff ff       	call   8710 <Pdcch_c_rnti+0x70>
    8714:	eb ad                	jmp    86c3 <Pdcch_c_rnti+0x23>
    8716:	8d 76 00             	lea    0x0(%esi),%esi
    8719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008720 <compare>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
    8720:	55                   	push   %ebp
    8721:	89 e5                	mov    %esp,%ebp
    8723:	e8 fc ff ff ff       	call   8724 <compare+0x4>
	u32 ret=first<second?0:1;
	return ret;
}
    8728:	5d                   	pop    %ebp
/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
	u32 ret=first<second?0:1;
    8729:	39 d0                	cmp    %edx,%eax
    872b:	0f 93 c0             	setae  %al
    872e:	0f b6 c0             	movzbl %al,%eax
	return ret;
}
    8731:	c3                   	ret    
    8732:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    8739:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008740 <decomplexUeRARPdu>:
/**
 * @function: decomplex RAR PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
 void decomplexUeRARPdu(FSM_PKT *skb)
{
    8740:	55                   	push   %ebp
    8741:	89 e5                	mov    %esp,%ebp
    8743:	56                   	push   %esi
    8744:	53                   	push   %ebx
    8745:	83 ec 18             	sub    $0x18,%esp
    8748:	e8 fc ff ff ff       	call   8749 <decomplexUeRARPdu+0x9>
    874d:	89 c3                	mov    %eax,%ebx
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    874f:	e8 fc ff ff ff       	call   8750 <decomplexUeRARPdu+0x10>

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    8754:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
{
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    875a:	89 c6                	mov    %eax,%esi

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    875c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8762:	29 d0                	sub    %edx,%eax
    8764:	83 f8 06             	cmp    $0x6,%eax
    8767:	0f 86 98 01 00 00    	jbe    8905 <decomplexUeRARPdu+0x1c5>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    876d:	b9 07 00 00 00       	mov    $0x7,%ecx
    8772:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8775:	e8 fc ff ff ff       	call   8776 <decomplexUeRARPdu+0x36>
	if(m_phy_ici.tcid==BCH){
    877a:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    877e:	3c 01                	cmp    $0x1,%al
    8780:	0f 84 ca 00 00 00    	je     8850 <decomplexUeRARPdu+0x110>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    8786:	84 c0                	test   %al,%al
    8788:	74 0e                	je     8798 <decomplexUeRARPdu+0x58>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    878a:	3c 02                	cmp    $0x2,%al
    878c:	74 72                	je     8800 <decomplexUeRARPdu+0xc0>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    878e:	83 c4 18             	add    $0x18,%esp
    8791:	5b                   	pop    %ebx
    8792:	5e                   	pop    %esi
    8793:	5d                   	pop    %ebp
    8794:	c3                   	ret    
    8795:	8d 76 00             	lea    0x0(%esi),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8798:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    879f:	e8 fc ff ff ff       	call   87a0 <decomplexUeRARPdu+0x60>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    87a4:	e8 fc ff ff ff       	call   87a5 <decomplexUeRARPdu+0x65>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    87a9:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    87af:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    87b3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    87ba:	0f b7 00             	movzwl (%eax),%eax
    87bd:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    87c1:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    87c7:	29 c2                	sub    %eax,%edx
    87c9:	83 fa 06             	cmp    $0x6,%edx
    87cc:	0f 86 52 01 00 00    	jbe    8924 <decomplexUeRARPdu+0x1e4>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    87d2:	8d 55 ea             	lea    -0x16(%ebp),%edx
    87d5:	b9 07 00 00 00       	mov    $0x7,%ecx
    87da:	e8 fc ff ff ff       	call   87db <decomplexUeRARPdu+0x9b>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    87df:	31 c0                	xor    %eax,%eax
    87e1:	e8 fc ff ff ff       	call   87e2 <decomplexUeRARPdu+0xa2>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    87e6:	8b 43 50             	mov    0x50(%ebx),%eax
    87e9:	c7 04 24 f0 27 00 00 	movl   $0x27f0,(%esp)
    87f0:	89 44 24 04          	mov    %eax,0x4(%esp)
    87f4:	e8 fc ff ff ff       	call   87f5 <decomplexUeRARPdu+0xb5>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    87f9:	83 c4 18             	add    $0x18,%esp
    87fc:	5b                   	pop    %ebx
    87fd:	5e                   	pop    %esi
    87fe:	5d                   	pop    %ebp
    87ff:	c3                   	ret    
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code
    8800:	c7 04 24 14 28 00 00 	movl   $0x2814,(%esp)
    8807:	e8 fc ff ff ff       	call   8808 <decomplexUeRARPdu+0xc8>

		if(!compare(skb->tail-skb->data,len)){
    880c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8812:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8818:	83 f8 06             	cmp    $0x6,%eax
    881b:	0f 86 22 01 00 00    	jbe    8943 <decomplexUeRARPdu+0x203>
			fsm_pkt_destroy(skb);
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
    8821:	80 be 98 01 00 00 00 	cmpb   $0x0,0x198(%esi)
    8828:	0f 85 82 00 00 00    	jne    88b0 <decomplexUeRARPdu+0x170>
					fsm_schedule_self(0,RandomAcc_Fail);
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
				} 
		}
		else { //RAR
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test	
    882e:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		}
		fsm_pkt_destroy(skb);//
    8835:	89 d8                	mov    %ebx,%eax
    8837:	e8 fc ff ff ff       	call   8838 <decomplexUeRARPdu+0xf8>
		//printk("ue mac_pkthandler 796\n");
		fsm_printf("decomplex for RAR function done\n");//testing code
    883c:	c7 04 24 78 28 00 00 	movl   $0x2878,(%esp)
    8843:	e8 fc ff ff ff       	call   8844 <decomplexUeRARPdu+0x104>
			
		FOUT;
	}
		
}
    8848:	83 c4 18             	add    $0x18,%esp
    884b:	5b                   	pop    %ebx
    884c:	5e                   	pop    %esi
    884d:	5d                   	pop    %ebp
    884e:	c3                   	ret    
    884f:	90                   	nop
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8850:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    8857:	e8 fc ff ff ff       	call   8858 <decomplexUeRARPdu+0x118>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    885c:	e8 fc ff ff ff       	call   885d <decomplexUeRARPdu+0x11d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8861:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8867:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    886b:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8872:	0f b7 00             	movzwl (%eax),%eax
    8875:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8879:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    887f:	29 c2                	sub    %eax,%edx
    8881:	83 fa 06             	cmp    $0x6,%edx
    8884:	0f 87 48 ff ff ff    	ja     87d2 <decomplexUeRARPdu+0x92>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    888a:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8891:	89 d8                	mov    %ebx,%eax
    8893:	e8 fc ff ff ff       	call   8894 <decomplexUeRARPdu+0x154>
			printk("ue mac_pkthandler 715\n");
    8898:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    889f:	e8 fc ff ff ff       	call   88a0 <decomplexUeRARPdu+0x160>
			FOUT;
    88a4:	e9 e5 fe ff ff       	jmp    878e <decomplexUeRARPdu+0x4e>
    88a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    88b0:	8b 86 94 01 00 00    	mov    0x194(%esi),%eax
    88b6:	e8 fc ff ff ff       	call   88b7 <decomplexUeRARPdu+0x177>
				SV(WaitforRAresponseTimer.flag)=false;
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    88bb:	89 d8                	mov    %ebx,%eax
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
				SV(WaitforRAresponseTimer.flag)=false;
    88bd:	c6 86 98 01 00 00 00 	movb   $0x0,0x198(%esi)
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
    88c4:	c7 86 94 01 00 00 00 	movl   $0x0,0x194(%esi)
    88cb:	00 00 00 
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    88ce:	e8 fc ff ff ff       	call   88cf <decomplexUeRARPdu+0x18f>
    88d3:	84 c0                	test   %al,%al
    88d5:	74 11                	je     88e8 <decomplexUeRARPdu+0x1a8>
					fsm_schedule_self(0,RARrev_Success);
    88d7:	ba 04 00 00 00       	mov    $0x4,%edx
    88dc:	31 c0                	xor    %eax,%eax
    88de:	e8 fc ff ff ff       	call   88df <decomplexUeRARPdu+0x19f>
    88e3:	e9 4d ff ff ff       	jmp    8835 <decomplexUeRARPdu+0xf5>
				else{
					fsm_schedule_self(0,RandomAcc_Fail);
    88e8:	ba 03 00 00 00       	mov    $0x3,%edx
    88ed:	31 c0                	xor    %eax,%eax
    88ef:	e8 fc ff ff ff       	call   88f0 <decomplexUeRARPdu+0x1b0>
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
    88f4:	c7 04 24 44 28 00 00 	movl   $0x2844,(%esp)
    88fb:	e8 fc ff ff ff       	call   88fc <decomplexUeRARPdu+0x1bc>
    8900:	e9 30 ff ff ff       	jmp    8835 <decomplexUeRARPdu+0xf5>
	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8905:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		fsm_pkt_destroy(skb);
    890c:	89 d8                	mov    %ebx,%eax
    890e:	e8 fc ff ff ff       	call   890f <decomplexUeRARPdu+0x1cf>
		printk("ue mac_pkthandler 701\n");
    8913:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    891a:	e8 fc ff ff ff       	call   891b <decomplexUeRARPdu+0x1db>
		FOUT;
    891f:	e9 6a fe ff ff       	jmp    878e <decomplexUeRARPdu+0x4e>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8924:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    892b:	89 d8                	mov    %ebx,%eax
    892d:	e8 fc ff ff ff       	call   892e <decomplexUeRARPdu+0x1ee>
			printk("ue mac_pkthandler 740\n");
    8932:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    8939:	e8 fc ff ff ff       	call   893a <decomplexUeRARPdu+0x1fa>
			FOUT;
    893e:	e9 4b fe ff ff       	jmp    878e <decomplexUeRARPdu+0x4e>
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code

		if(!compare(skb->tail-skb->data,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8943:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    894a:	89 d8                	mov    %ebx,%eax
    894c:	e8 fc ff ff ff       	call   894d <decomplexUeRARPdu+0x20d>
			printk("ue mac_pkthandler 767\n");
    8951:	c7 04 24 b1 05 00 00 	movl   $0x5b1,(%esp)
    8958:	e8 fc ff ff ff       	call   8959 <decomplexUeRARPdu+0x219>
			FOUT;
    895d:	e9 2c fe ff ff       	jmp    878e <decomplexUeRARPdu+0x4e>
    8962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    8969:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008970 <decomplexUeDataPdu>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
void decomplexUeDataPdu(FSM_PKT *skb){		//  
    8970:	55                   	push   %ebp
    8971:	89 e5                	mov    %esp,%ebp
    8973:	57                   	push   %edi
    8974:	56                   	push   %esi
    8975:	53                   	push   %ebx
    8976:	83 ec 54             	sub    $0x54,%esp
    8979:	e8 fc ff ff ff       	call   897a <decomplexUeDataPdu+0xa>
    897e:	89 c3                	mov    %eax,%ebx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    8980:	e8 fc ff ff ff       	call   8981 <decomplexUeDataPdu+0x11>

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8985:	31 d2                	xor    %edx,%edx
    8987:	b9 03 00 00 00       	mov    $0x3,%ecx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    898c:	89 45 b8             	mov    %eax,-0x48(%ebp)

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    898f:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8992:	e8 fc ff ff ff       	call   8993 <decomplexUeDataPdu+0x23>
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8997:	31 d2                	xor    %edx,%edx
    8999:	b9 01 00 00 00       	mov    $0x1,%ecx
    899e:	8d 45 f1             	lea    -0xf(%ebp),%eax
    89a1:	e8 fc ff ff ff       	call   89a2 <decomplexUeDataPdu+0x32>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    89a6:	31 d2                	xor    %edx,%edx
    89a8:	b9 02 00 00 00       	mov    $0x2,%ecx
    89ad:	8d 45 ef             	lea    -0x11(%ebp),%eax
    89b0:	e8 fc ff ff ff       	call   89b1 <decomplexUeDataPdu+0x41>
	fsm_mem_set(&m_content_resolution,0,sizeof(MAC_CE_content_resolution_identity));	//20140430
    89b5:	31 d2                	xor    %edx,%edx
    89b7:	b9 06 00 00 00       	mov    $0x6,%ecx
    89bc:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    89bf:	e8 fc ff ff ff       	call   89c0 <decomplexUeDataPdu+0x50>
	fsm_mem_set(&m_time_advance,0,sizeof(MAC_CE_time_advance));	//20140430
    89c4:	31 d2                	xor    %edx,%edx
    89c6:	b9 01 00 00 00       	mov    $0x1,%ecx
    89cb:	8d 45 f3             	lea    -0xd(%ebp),%eax
    89ce:	e8 fc ff ff ff       	call   89cf <decomplexUeDataPdu+0x5f>
	fsm_mem_set(&m_rlc_type2_icimsg,0,sizeof(MACtoRLC_IciMsg));	//20140430
    89d3:	31 d2                	xor    %edx,%edx
    89d5:	b9 07 00 00 00       	mov    $0x7,%ecx
    89da:	8d 45 d8             	lea    -0x28(%ebp),%eax
    89dd:	e8 fc ff ff ff       	call   89de <decomplexUeDataPdu+0x6e>
	fsm_mem_set(&m_padding_subhead,0,sizeof(MAC_SH_padding));	//20140430
    89e2:	31 d2                	xor    %edx,%edx
    89e4:	b9 01 00 00 00       	mov    $0x1,%ecx
    89e9:	8d 45 f2             	lea    -0xe(%ebp),%eax
    89ec:	e8 fc ff ff ff       	call   89ed <decomplexUeDataPdu+0x7d>
	fsm_mem_set(&m_phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    89f1:	31 d2                	xor    %edx,%edx
    89f3:	b9 07 00 00 00       	mov    $0x7,%ecx
    89f8:	8d 45 df             	lea    -0x21(%ebp),%eax
    89fb:	e8 fc ff ff ff       	call   89fc <decomplexUeDataPdu+0x8c>
    //PHYICI  HQ 20140502

	/*
	 * for test
	 */
	SV(pkt_num_downlink)=SV(pkt_num_downlink)+1;
    8a00:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8a03:	83 80 10 02 00 00 01 	addl   $0x1,0x210(%eax)


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    8a0a:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    8a10:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8a16:	29 d0                	sub    %edx,%eax
    8a18:	83 f8 06             	cmp    $0x6,%eax
    8a1b:	0f 86 6c 06 00 00    	jbe    908d <decomplexUeDataPdu+0x71d>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    8a21:	b9 07 00 00 00       	mov    $0x7,%ecx
    8a26:	8d 45 df             	lea    -0x21(%ebp),%eax
    8a29:	e8 fc ff ff ff       	call   8a2a <decomplexUeDataPdu+0xba>
	if(m_phy_ici.tcid==BCH){
    8a2e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
    8a32:	3c 01                	cmp    $0x1,%al
    8a34:	0f 84 a6 00 00 00    	je     8ae0 <decomplexUeDataPdu+0x170>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    8a3a:	84 c0                	test   %al,%al
    8a3c:	74 32                	je     8a70 <decomplexUeDataPdu+0x100>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    8a3e:	3c 02                	cmp    $0x2,%al
    8a40:	0f 84 f2 00 00 00    	je     8b38 <decomplexUeDataPdu+0x1c8>
	
	/*
	 * for test
	 */
	 else{
	 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    8a46:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8a49:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
    8a50:	89 d8                	mov    %ebx,%eax
    8a52:	e8 fc ff ff ff       	call   8a53 <decomplexUeDataPdu+0xe3>
   	fsm_printf("decomplex function done\n");//testing code
    8a57:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    8a5e:	e8 fc ff ff ff       	call   8a5f <decomplexUeDataPdu+0xef>
	FOUT;
}
    8a63:	83 c4 54             	add    $0x54,%esp
    8a66:	5b                   	pop    %ebx
    8a67:	5e                   	pop    %esi
    8a68:	5f                   	pop    %edi
    8a69:	5d                   	pop    %ebp
    8a6a:	c3                   	ret    
    8a6b:	90                   	nop
    8a6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8a70:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    8a77:	e8 fc ff ff ff       	call   8a78 <decomplexUeDataPdu+0x108>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8a7c:	e8 fc ff ff ff       	call   8a7d <decomplexUeDataPdu+0x10d>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a81:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8a87:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8a8b:	c7 45 da 01 00 00 00 	movl   $0x1,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8a92:	0f b7 00             	movzwl (%eax),%eax
    8a95:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a99:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8a9f:	29 c2                	sub    %eax,%edx
    8aa1:	83 fa 06             	cmp    $0x6,%edx
    8aa4:	0f 86 99 06 00 00    	jbe    9143 <decomplexUeDataPdu+0x7d3>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8aaa:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8aad:	b9 07 00 00 00       	mov    $0x7,%ecx
    8ab2:	e8 fc ff ff ff       	call   8ab3 <decomplexUeDataPdu+0x143>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(skb);  //add in 20150804
    8ab7:	89 d8                	mov    %ebx,%eax
    8ab9:	e8 fc ff ff ff       	call   8aba <decomplexUeDataPdu+0x14a>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8abe:	8b 43 50             	mov    0x50(%ebx),%eax
    8ac1:	c7 04 24 f0 27 00 00 	movl   $0x27f0,(%esp)
    8ac8:	89 44 24 04          	mov    %eax,0x4(%esp)
    8acc:	e8 fc ff ff ff       	call   8acd <decomplexUeDataPdu+0x15d>
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
   	fsm_printf("decomplex function done\n");//testing code
	FOUT;
}
    8ad1:	83 c4 54             	add    $0x54,%esp
    8ad4:	5b                   	pop    %ebx
    8ad5:	5e                   	pop    %esi
    8ad6:	5f                   	pop    %edi
    8ad7:	5d                   	pop    %ebp
    8ad8:	c3                   	ret    
    8ad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8ae0:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    8ae7:	e8 fc ff ff ff       	call   8ae8 <decomplexUeDataPdu+0x178>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8aec:	e8 fc ff ff ff       	call   8aed <decomplexUeDataPdu+0x17d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8af1:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8af7:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8afb:	c7 45 da 02 00 00 00 	movl   $0x2,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8b02:	0f b7 00             	movzwl (%eax),%eax
    8b05:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8b09:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8b0f:	29 c2                	sub    %eax,%edx
    8b11:	83 fa 06             	cmp    $0x6,%edx
    8b14:	77 94                	ja     8aaa <decomplexUeDataPdu+0x13a>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8b16:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8b19:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    8b20:	89 d8                	mov    %ebx,%eax
    8b22:	e8 fc ff ff ff       	call   8b23 <decomplexUeDataPdu+0x1b3>
			printk("ue mac_pkthandler 715\n");
    8b27:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    8b2e:	e8 fc ff ff ff       	call   8b2f <decomplexUeDataPdu+0x1bf>
			FOUT;
    8b33:	e9 2b ff ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8b38:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)


		//fsm_mem_cpy(&m_type,skb->data,len);//  HQ 20140502;delete m_type in 20160222
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
    8b3f:	31 f6                	xor    %esi,%esi
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8b41:	e8 fc ff ff ff       	call   8b42 <decomplexUeDataPdu+0x1d2>
		//len=sizeof(char);
		len=0;	//modify by lxr in 20160225
		head_len=lteMacGetDlHeadLength(skb);	//SDU
    8b46:	89 d8                	mov    %ebx,%eax
    8b48:	e8 fc ff ff ff       	call   8b49 <decomplexUeDataPdu+0x1d9>
    8b4d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
    8b50:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
    8b54:	e8 fc ff ff ff       	call   8b55 <decomplexUeDataPdu+0x1e5>
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
    8b59:	c7 04 24 e5 05 00 00 	movl   $0x5e5,(%esp)
    8b60:	e8 fc ff ff ff       	call   8b61 <decomplexUeDataPdu+0x1f1>
    8b65:	8d 76 00             	lea    0x0(%esi),%esi
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
    8b68:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8b6e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8b74:	29 d0                	sub    %edx,%eax
    8b76:	39 c6                	cmp    %eax,%esi
    8b78:	0f 84 65 04 00 00    	je     8fe3 <decomplexUeDataPdu+0x673>
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8b7e:	01 f2                	add    %esi,%edx
    8b80:	b9 01 00 00 00       	mov    $0x1,%ecx
    8b85:	8d 45 f2             	lea    -0xe(%ebp),%eax
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8b88:	bf 1f 00 00 00       	mov    $0x1f,%edi
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8b8d:	e8 fc ff ff ff       	call   8b8e <decomplexUeDataPdu+0x21e>
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8b92:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
    8b96:	89 c2                	mov    %eax,%edx
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8b98:	21 c7                	and    %eax,%edi
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8b9a:	c0 ea 05             	shr    $0x5,%dl
    8b9d:	88 55 d4             	mov    %dl,-0x2c(%ebp)
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
    8ba0:	89 7c 24 04          	mov    %edi,0x4(%esp)
    8ba4:	c7 04 24 18 06 00 00 	movl   $0x618,(%esp)
    8bab:	e8 fc ff ff ff       	call   8bac <decomplexUeDataPdu+0x23c>
				switch(lcid){
    8bb0:	83 ff 1d             	cmp    $0x1d,%edi
    8bb3:	0f 84 67 03 00 00    	je     8f20 <decomplexUeDataPdu+0x5b0>
    8bb9:	0f 87 11 02 00 00    	ja     8dd0 <decomplexUeDataPdu+0x460>
    8bbf:	83 ff 1c             	cmp    $0x1c,%edi
    8bc2:	0f 84 28 02 00 00    	je     8df0 <decomplexUeDataPdu+0x480>
						break;
					
				}		
			}			
		
			if(lcid>=0&&lcid<11){
    8bc8:	83 ff 0a             	cmp    $0xa,%edi
    8bcb:	90                   	nop
    8bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8bd0:	0f 87 fb 04 00 00    	ja     90d1 <decomplexUeDataPdu+0x761>
    8bd6:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    8bd9:	e9 ff 00 00 00       	jmp    8cdd <decomplexUeDataPdu+0x36d>
    8bde:	66 90                	xchg   %ax,%ax
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8be0:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8be6:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8bec:	29 d0                	sub    %edx,%eax
    8bee:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8bf1:	83 f8 02             	cmp    $0x2,%eax
    8bf4:	0f 86 2d 04 00 00    	jbe    9027 <decomplexUeDataPdu+0x6b7>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 954\n");
							FOUT;
						}

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
    8bfa:	03 55 d4             	add    -0x2c(%ebp),%edx
    8bfd:	b9 03 00 00 00       	mov    $0x3,%ecx
    8c02:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8c05:	e8 fc ff ff ff       	call   8c06 <decomplexUeDataPdu+0x296>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8c0a:	e8 fc ff ff ff       	call   8c0b <decomplexUeDataPdu+0x29b>
	ici_msg->lcid=lcid;
    8c0f:	89 f2                	mov    %esi,%edx

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8c11:	0f b6 7d ee          	movzbl -0x12(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8c15:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8c18:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8c1f:	0f b7 00             	movzwl (%eax),%eax
    8c22:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
    8c26:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    8c2a:	83 e0 7f             	and    $0x7f,%eax
						sdu_len=sdu_len<<8;
    8c2d:	c1 e0 08             	shl    $0x8,%eax
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8c30:	01 c7                	add    %eax,%edi
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8c32:	8d 47 11             	lea    0x11(%edi),%eax
    8c35:	e8 fc ff ff ff       	call   8c36 <decomplexUeDataPdu+0x2c6>
						fsm_skb_reserve(newskb,sdu_len);
    8c3a:	89 fa                	mov    %edi,%edx
						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8c3c:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8c3e:	e8 fc ff ff ff       	call   8c3f <decomplexUeDataPdu+0x2cf>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
    8c43:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8c49:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    8c4f:	29 c2                	sub    %eax,%edx
    8c51:	83 fa 06             	cmp    $0x6,%edx
    8c54:	0f 86 ab 03 00 00    	jbe    9005 <decomplexUeDataPdu+0x695>
							printk("ue mac_pkthandler 976\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
    8c5a:	b9 07 00 00 00       	mov    $0x7,%ecx
    8c5f:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8c62:	e8 fc ff ff ff       	call   8c63 <decomplexUeDataPdu+0x2f3>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8c67:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8c6d:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8c73:	39 c7                	cmp    %eax,%edi
    8c75:	0f 87 24 03 00 00    	ja     8f9f <decomplexUeDataPdu+0x62f>
    8c7b:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8c81:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8c87:	29 d0                	sub    %edx,%eax
    8c89:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8c8c:	39 c7                	cmp    %eax,%edi
    8c8e:	0f 87 0b 03 00 00    	ja     8f9f <decomplexUeDataPdu+0x62f>

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;
    8c94:	83 45 d4 03          	addl   $0x3,-0x2c(%ebp)
							printk("ue mac_pkthandler 1026\n");
							FOUT;
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
    8c98:	03 55 d0             	add    -0x30(%ebp),%edx
    8c9b:	89 f0                	mov    %esi,%eax
    8c9d:	89 55 bc             	mov    %edx,-0x44(%ebp)
    8ca0:	89 fa                	mov    %edi,%edx
    8ca2:	e8 fc ff ff ff       	call   8ca3 <decomplexUeDataPdu+0x333>
    8ca7:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8caa:	89 f9                	mov    %edi,%ecx
    8cac:	e8 fc ff ff ff       	call   8cad <decomplexUeDataPdu+0x33d>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8cb1:	89 f0                	mov    %esi,%eax
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
    8cb3:	01 7d d0             	add    %edi,-0x30(%ebp)
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8cb6:	e8 fc ff ff ff       	call   8cb7 <decomplexUeDataPdu+0x347>
						//fsm_pkt_send(newskb,STRM_TO_IPADP);

						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
    8cbb:	8b 46 50             	mov    0x50(%esi),%eax
    8cbe:	c7 04 24 f0 27 00 00 	movl   $0x27f0,(%esp)
    8cc5:	89 44 24 04          	mov    %eax,0x4(%esp)
    8cc9:	e8 fc ff ff ff       	call   8cca <decomplexUeDataPdu+0x35a>
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8cce:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
    8cd2:	c0 e8 05             	shr    $0x5,%al
				}		
			}			
		
			if(lcid>=0&&lcid<11){
				continue_flag=1;
				while(continue_flag==1){
    8cd5:	3c 01                	cmp    $0x1,%al
    8cd7:	0f 85 73 fd ff ff    	jne    8a50 <decomplexUeDataPdu+0xe0>
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
    8cdd:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8ce3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8ce9:	29 d0                	sub    %edx,%eax
    8ceb:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8cee:	83 f8 01             	cmp    $0x1,%eax
    8cf1:	0f 86 ca 02 00 00    	jbe    8fc1 <decomplexUeDataPdu+0x651>
						fsm_pkt_destroy(skb);
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
    8cf7:	03 55 d4             	add    -0x2c(%ebp),%edx
    8cfa:	b9 02 00 00 00       	mov    $0x2,%ecx
    8cff:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8d02:	e8 fc ff ff ff       	call   8d03 <decomplexUeDataPdu+0x393>
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8d07:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8d0b:	89 d0                	mov    %edx,%eax
    8d0d:	83 e0 1f             	and    $0x1f,%eax
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8d10:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8d14:	89 c6                	mov    %eax,%esi
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8d16:	88 55 c0             	mov    %dl,-0x40(%ebp)
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8d19:	0f 88 c1 fe ff ff    	js     8be0 <decomplexUeDataPdu+0x270>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8d1f:	e8 fc ff ff ff       	call   8d20 <decomplexUeDataPdu+0x3b0>
	ici_msg->lcid=lcid;
    8d24:	89 f2                	mov    %esi,%edx
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8d26:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8d2a:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8d2d:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
    8d34:	83 45 d4 02          	addl   $0x2,-0x2c(%ebp)
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8d38:	83 e7 7f             	and    $0x7f,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    8d3b:	0f b7 00             	movzwl (%eax),%eax
    8d3e:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8d42:	8d 47 11             	lea    0x11(%edi),%eax
    8d45:	e8 fc ff ff ff       	call   8d46 <decomplexUeDataPdu+0x3d6>
						fsm_skb_reserve(newskb,sdu_len);
    8d4a:	89 fa                	mov    %edi,%edx
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8d4c:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8d4e:	e8 fc ff ff ff       	call   8d4f <decomplexUeDataPdu+0x3df>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8d53:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8d59:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8d5f:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8d62:	83 f8 06             	cmp    $0x6,%eax
    8d65:	0f 86 de 02 00 00    	jbe    9049 <decomplexUeDataPdu+0x6d9>
							printk("ue mac_pkthandler 1015\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);
    8d6b:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8d71:	b9 07 00 00 00       	mov    $0x7,%ecx
    8d76:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8d79:	e8 fc ff ff ff       	call   8d7a <decomplexUeDataPdu+0x40a>


						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8d7e:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8d84:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8d8a:	39 c7                	cmp    %eax,%edi
    8d8c:	77 19                	ja     8da7 <decomplexUeDataPdu+0x437>
    8d8e:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8d94:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8d9a:	29 d0                	sub    %edx,%eax
    8d9c:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8d9f:	39 c7                	cmp    %eax,%edi
    8da1:	0f 86 f1 fe ff ff    	jbe    8c98 <decomplexUeDataPdu+0x328>
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8da7:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8daa:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8db1:	89 d8                	mov    %ebx,%eax
    8db3:	e8 fc ff ff ff       	call   8db4 <decomplexUeDataPdu+0x444>
							printk("ue mac_pkthandler 1026\n");
    8db8:	c7 04 24 f9 06 00 00 	movl   $0x6f9,(%esp)
    8dbf:	e8 fc ff ff ff       	call   8dc0 <decomplexUeDataPdu+0x450>
							FOUT;
    8dc4:	e9 9a fc ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
    8dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
    8dd0:	83 ff 1e             	cmp    $0x1e,%edi
    8dd3:	74 09                	je     8dde <decomplexUeDataPdu+0x46e>
    8dd5:	83 ff 1f             	cmp    $0x1f,%edi
    8dd8:	0f 85 ea fd ff ff    	jne    8bc8 <decomplexUeDataPdu+0x258>
					case DRX_LCID:
						from_len=from_len+len;
						break;
					case PADDING_LCID:
						padding_flag=1;
						from_len=from_len+len;
    8dde:	83 c6 01             	add    $0x1,%esi
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
			while(continue_flag==1)
    8de1:	80 7d d4 01          	cmpb   $0x1,-0x2c(%ebp)
    8de5:	0f 84 7d fd ff ff    	je     8b68 <decomplexUeDataPdu+0x1f8>
    8deb:	e9 d8 fd ff ff       	jmp    8bc8 <decomplexUeDataPdu+0x258>
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
					case CONTENTION_RESOLUTION_LCID:	//20140428 
						if(SV(CRTimer.flag)==true){  // 	
    8df0:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8df3:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
    8dfa:	74 e5                	je     8de1 <decomplexUeDataPdu+0x471>
							fsm_schedule_cancel(SV(CRTimer.timer_sign));  //CR  HQ 20140424
    8dfc:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    8e02:	e8 fc ff ff ff       	call   8e03 <decomplexUeDataPdu+0x493>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
    8e07:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8e0a:	c6 80 74 01 00 00 00 	movb   $0x0,0x174(%eax)
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
    8e11:	c7 80 70 01 00 00 00 	movl   $0x0,0x170(%eax)
    8e18:	00 00 00 
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
    8e1b:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8e21:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8e27:	29 d0                	sub    %edx,%eax
    8e29:	39 c6                	cmp    %eax,%esi
    8e2b:	0f 84 f0 02 00 00    	je     9121 <decomplexUeDataPdu+0x7b1>
								printk("ue mac_pkthandler 834\n");
								FOUT;
							}


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
    8e31:	01 f2                	add    %esi,%edx
    8e33:	b9 01 00 00 00       	mov    $0x1,%ecx
    8e38:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8e3b:	e8 fc ff ff ff       	call   8e3c <decomplexUeDataPdu+0x4cc>
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);
    8e40:	89 74 24 04          	mov    %esi,0x4(%esp)
    8e44:	c7 04 24 9c 28 00 00 	movl   $0x289c,(%esp)
    8e4b:	e8 fc ff ff ff       	call   8e4c <decomplexUeDataPdu+0x4dc>

							from_len=from_len+len;
							len=sizeof(MAC_CE_content_resolution_identity);
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
    8e50:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8e53:	c7 04 24 d0 28 00 00 	movl   $0x28d0,(%esp)
    8e5a:	89 44 24 04          	mov    %eax,0x4(%esp)
    8e5e:	e8 fc ff ff ff       	call   8e5f <decomplexUeDataPdu+0x4ef>
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
    8e63:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8e69:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8e6f:	29 d0                	sub    %edx,%eax
    8e71:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8e74:	83 f8 05             	cmp    $0x5,%eax
    8e77:	0f 86 82 02 00 00    	jbe    90ff <decomplexUeDataPdu+0x78f>
								fsm_pkt_destroy(skb);
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
    8e7d:	03 55 d0             	add    -0x30(%ebp),%edx
    8e80:	b9 06 00 00 00       	mov    $0x6,%ecx
    8e85:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    8e88:	e8 fc ff ff ff       	call   8e89 <decomplexUeDataPdu+0x519>
							part1=m_content_resolution.m_resolusion_identity_1;
							part2=m_content_resolution.m_resolusion_identity_2;
    8e8d:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
							part1=m_content_resolution.m_resolusion_identity_1;
    8e91:	8b 4d e6             	mov    -0x1a(%ebp),%ecx
							part2=m_content_resolution.m_resolusion_identity_2;
    8e94:	66 89 55 c0          	mov    %dx,-0x40(%ebp)

							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);
    8e98:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8e9b:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8ea1:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    8ea5:	89 54 24 10          	mov    %edx,0x10(%esp)
    8ea9:	8b 00                	mov    (%eax),%eax
    8eab:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    8eaf:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
    8eb2:	c7 04 24 00 29 00 00 	movl   $0x2900,(%esp)
    8eb9:	89 44 24 0c          	mov    %eax,0xc(%esp)
    8ebd:	0f bf 45 c0          	movswl -0x40(%ebp),%eax
    8ec1:	89 44 24 08          	mov    %eax,0x8(%esp)
    8ec5:	e8 fc ff ff ff       	call   8ec6 <decomplexUeDataPdu+0x556>

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
    8eca:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8ecd:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    8ed0:	8b 82 00 02 00 00    	mov    0x200(%edx),%eax
    8ed6:	85 c0                	test   %eax,%eax
    8ed8:	74 11                	je     8eeb <decomplexUeDataPdu+0x57b>
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    8eda:	83 e8 01             	sub    $0x1,%eax
								part1=0;//
    8edd:	31 c9                	xor    %ecx,%ecx
							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    8edf:	89 82 00 02 00 00    	mov    %eax,0x200(%edx)
								part1=0;//
								part2=0;
    8ee5:	66 c7 45 c0 00 00    	movw   $0x0,-0x40(%ebp)
							}
							/*********************************/

							if(part1==SV(m_temp_cr)->m_part_1&&part2==SV(m_temp_cr)->m_part_2){
    8eeb:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8eee:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8ef4:	39 08                	cmp    %ecx,(%eax)
    8ef6:	0f 85 88 00 00 00    	jne    8f84 <decomplexUeDataPdu+0x614>
    8efc:	0f bf 55 c0          	movswl -0x40(%ebp),%edx
    8f00:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8f04:	39 c2                	cmp    %eax,%edx
    8f06:	75 7c                	jne    8f84 <decomplexUeDataPdu+0x614>
							//	SV(contention_resolution_flag)=true;	//flag
								fsm_schedule_self(0, Contention_Success);
    8f08:	ba 06 00 00 00       	mov    $0x6,%edx
    8f0d:	31 c0                	xor    %eax,%eax
    8f0f:	e8 fc ff ff ff       	call   8f10 <decomplexUeDataPdu+0x5a0>


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);

							from_len=from_len+len;
    8f14:	83 c6 01             	add    $0x1,%esi
								
								fsm_schedule_self(0, ContentionResolution_Fail);
								
								FOUT; 
							}
							head_len=head_len+len;
    8f17:	83 45 d0 06          	addl   $0x6,-0x30(%ebp)
    8f1b:	e9 c1 fe ff ff       	jmp    8de1 <decomplexUeDataPdu+0x471>
						}
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8f20:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8f26:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8f2c:	29 d0                	sub    %edx,%eax
    8f2e:	39 c6                	cmp    %eax,%esi
    8f30:	0f 84 35 01 00 00    	je     906b <decomplexUeDataPdu+0x6fb>
							printk("ue mac_pkthandler 896\n");
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
    8f36:	01 f2                	add    %esi,%edx
    8f38:	b9 01 00 00 00       	mov    $0x1,%ecx
    8f3d:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8f40:	e8 fc ff ff ff       	call   8f41 <decomplexUeDataPdu+0x5d1>
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
    8f45:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8f4b:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8f51:	29 d0                	sub    %edx,%eax
    8f53:	39 45 d0             	cmp    %eax,-0x30(%ebp)
    8f56:	0f 84 53 01 00 00    	je     90af <decomplexUeDataPdu+0x73f>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    8f5c:	03 55 d0             	add    -0x30(%ebp),%edx
    8f5f:	b9 01 00 00 00       	mov    $0x1,%ecx
    8f64:	8d 45 f3             	lea    -0xd(%ebp),%eax
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
    8f67:	83 c6 01             	add    $0x1,%esi
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    8f6a:	e8 fc ff ff ff       	call   8f6b <decomplexUeDataPdu+0x5fb>
						head_len=head_len+len;
						timing=(m_time_advance.m_r_r_command)&63;
    8f6f:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
						head_len=head_len+len;
    8f73:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
						timing=(m_time_advance.m_r_r_command)&63;

						MACCETA_handle(timing);
    8f77:	83 e0 3f             	and    $0x3f,%eax
    8f7a:	e8 fc ff ff ff       	call   8f7b <decomplexUeDataPdu+0x60b>
						break;
    8f7f:	e9 5d fe ff ff       	jmp    8de1 <decomplexUeDataPdu+0x471>
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f84:	8b 45 b8             	mov    -0x48(%ebp),%eax
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    8f87:	ba 05 00 00 00       	mov    $0x5,%edx
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f8c:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    8f93:	31 c0                	xor    %eax,%eax
    8f95:	e8 fc ff ff ff       	call   8f96 <decomplexUeDataPdu+0x626>
								
								FOUT; 
    8f9a:	e9 c4 fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>

						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f9f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8fa2:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8fa9:	89 d8                	mov    %ebx,%eax
    8fab:	e8 fc ff ff ff       	call   8fac <decomplexUeDataPdu+0x63c>
							printk("ue mac_pkthandler 987\n");
    8fb0:	c7 04 24 ca 06 00 00 	movl   $0x6ca,(%esp)
    8fb7:	e8 fc ff ff ff       	call   8fb8 <decomplexUeDataPdu+0x648>
							FOUT;
    8fbc:	e9 a2 fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
				continue_flag=1;
				while(continue_flag==1){
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
						SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8fc1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8fc4:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
						fsm_pkt_destroy(skb);
    8fcb:	89 d8                	mov    %ebx,%eax
    8fcd:	e8 fc ff ff ff       	call   8fce <decomplexUeDataPdu+0x65e>
						printk("ue mac_pkthandler 940\n");
    8fd2:	c7 04 24 85 06 00 00 	movl   $0x685,(%esp)
    8fd9:	e8 fc ff ff ff       	call   8fda <decomplexUeDataPdu+0x66a>
						FOUT;
    8fde:	e9 80 fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
					SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8fe3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8fe6:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
					fsm_pkt_destroy(skb);
    8fed:	89 d8                	mov    %ebx,%eax
    8fef:	e8 fc ff ff ff       	call   8ff0 <decomplexUeDataPdu+0x680>
					printk("ue mac_pkthandler 814\n");
    8ff4:	c7 04 24 01 06 00 00 	movl   $0x601,(%esp)
    8ffb:	e8 fc ff ff ff       	call   8ffc <decomplexUeDataPdu+0x68c>
					FOUT;
    9000:	e9 5e fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9005:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9008:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    900f:	89 d8                	mov    %ebx,%eax
    9011:	e8 fc ff ff ff       	call   9012 <decomplexUeDataPdu+0x6a2>
							printk("ue mac_pkthandler 976\n");
    9016:	c7 04 24 b3 06 00 00 	movl   $0x6b3,(%esp)
    901d:	e8 fc ff ff ff       	call   901e <decomplexUeDataPdu+0x6ae>
							FOUT;
    9022:	e9 3c fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9027:	8b 45 b8             	mov    -0x48(%ebp),%eax
    902a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9031:	89 d8                	mov    %ebx,%eax
    9033:	e8 fc ff ff ff       	call   9034 <decomplexUeDataPdu+0x6c4>
							printk("ue mac_pkthandler 954\n");
    9038:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    903f:	e8 fc ff ff ff       	call   9040 <decomplexUeDataPdu+0x6d0>
							FOUT;
    9044:	e9 1a fa ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9049:	8b 45 b8             	mov    -0x48(%ebp),%eax
    904c:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9053:	89 d8                	mov    %ebx,%eax
    9055:	e8 fc ff ff ff       	call   9056 <decomplexUeDataPdu+0x6e6>
							printk("ue mac_pkthandler 1015\n");
    905a:	c7 04 24 e1 06 00 00 	movl   $0x6e1,(%esp)
    9061:	e8 fc ff ff ff       	call   9062 <decomplexUeDataPdu+0x6f2>
							FOUT;
    9066:	e9 f8 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    906b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    906e:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9075:	89 d8                	mov    %ebx,%eax
    9077:	e8 fc ff ff ff       	call   9078 <decomplexUeDataPdu+0x708>
							printk("ue mac_pkthandler 896\n");
    907c:	c7 04 24 57 06 00 00 	movl   $0x657,(%esp)
    9083:	e8 fc ff ff ff       	call   9084 <decomplexUeDataPdu+0x714>
							FOUT;
    9088:	e9 d6 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    908d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9090:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
		fsm_pkt_destroy(skb);
    9097:	89 d8                	mov    %ebx,%eax
    9099:	e8 fc ff ff ff       	call   909a <decomplexUeDataPdu+0x72a>
		printk("ue mac_pkthandler 701\n");
    909e:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    90a5:	e8 fc ff ff ff       	call   90a6 <decomplexUeDataPdu+0x736>
		FOUT;
    90aa:	e9 b4 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90af:	8b 45 b8             	mov    -0x48(%ebp),%eax
    90b2:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    90b9:	89 d8                	mov    %ebx,%eax
    90bb:	e8 fc ff ff ff       	call   90bc <decomplexUeDataPdu+0x74c>
							printk("ue mac_pkthandler 908\n");
    90c0:	c7 04 24 6e 06 00 00 	movl   $0x66e,(%esp)
    90c7:	e8 fc ff ff ff       	call   90c8 <decomplexUeDataPdu+0x758>
							FOUT;
    90cc:	e9 92 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
			
			/*
			 * for test
			 */
			 else{
			 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    90d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    90d4:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			 	
			 	fsm_pkt_destroy(skb);
    90db:	89 d8                	mov    %ebx,%eax
    90dd:	e8 fc ff ff ff       	call   90de <decomplexUeDataPdu+0x76e>
			 	printk("ue mac_pkthandler 1052\n");
    90e2:	c7 04 24 11 07 00 00 	movl   $0x711,(%esp)
    90e9:	e8 fc ff ff ff       	call   90ea <decomplexUeDataPdu+0x77a>
   				fsm_printf("decomplex function done\n");//testing code
    90ee:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    90f5:	e8 fc ff ff ff       	call   90f6 <decomplexUeDataPdu+0x786>
				FOUT;
    90fa:	e9 64 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90ff:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9102:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    9109:	89 d8                	mov    %ebx,%eax
    910b:	e8 fc ff ff ff       	call   910c <decomplexUeDataPdu+0x79c>
								printk("ue mac_pkthandler 851\n");
    9110:	c7 04 24 40 06 00 00 	movl   $0x640,(%esp)
    9117:	e8 fc ff ff ff       	call   9118 <decomplexUeDataPdu+0x7a8>
								FOUT;
    911c:	e9 42 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9121:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9124:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    912b:	89 d8                	mov    %ebx,%eax
    912d:	e8 fc ff ff ff       	call   912e <decomplexUeDataPdu+0x7be>
								printk("ue mac_pkthandler 834\n");
    9132:	c7 04 24 29 06 00 00 	movl   $0x629,(%esp)
    9139:	e8 fc ff ff ff       	call   913a <decomplexUeDataPdu+0x7ca>
								FOUT;
    913e:	e9 20 f9 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9143:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9146:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    914d:	89 d8                	mov    %ebx,%eax
    914f:	e8 fc ff ff ff       	call   9150 <decomplexUeDataPdu+0x7e0>
			printk("ue mac_pkthandler 740\n");
    9154:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    915b:	e8 fc ff ff ff       	call   915c <decomplexUeDataPdu+0x7ec>
			FOUT;
    9160:	e9 fe f8 ff ff       	jmp    8a63 <decomplexUeDataPdu+0xf3>
    9165:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9169:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009170 <clean_CE_tags>:
}	//ICI()
	
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
    9170:	55                   	push   %ebp
    9171:	89 e5                	mov    %esp,%ebp
    9173:	56                   	push   %esi
    9174:	53                   	push   %ebx
    9175:	e8 fc ff ff ff       	call   9176 <clean_CE_tags+0x6>
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    917a:	31 db                	xor    %ebx,%ebx
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
    917c:	e8 fc ff ff ff       	call   917d <clean_CE_tags+0xd>
    9181:	89 c6                	mov    %eax,%esi
    9183:	90                   	nop
    9184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    9188:	8d 84 de a4 01 00 00 	lea    0x1a4(%esi,%ebx,8),%eax
    918f:	31 d2                	xor    %edx,%edx
    9191:	b9 08 00 00 00       	mov    $0x8,%ecx
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    9196:	83 c3 01             	add    $0x1,%ebx
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    9199:	e8 fc ff ff ff       	call   919a <clean_CE_tags+0x2a>
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    919e:	83 fb 08             	cmp    $0x8,%ebx
    91a1:	75 e5                	jne    9188 <clean_CE_tags+0x18>
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
	FOUT;
}
    91a3:	5b                   	pop    %ebx
    91a4:	5e                   	pop    %esi
    91a5:	5d                   	pop    %ebp
    91a6:	c3                   	ret    
    91a7:	89 f6                	mov    %esi,%esi
    91a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000091b0 <complexUeMacPdu>:

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    91b0:	55                   	push   %ebp
    91b1:	89 e5                	mov    %esp,%ebp
    91b3:	57                   	push   %edi
    91b4:	56                   	push   %esi
    91b5:	53                   	push   %ebx
    91b6:	83 ec 70             	sub    $0x70,%esp
    91b9:	e8 fc ff ff ff       	call   91ba <complexUeMacPdu+0xa>
    91be:	89 c3                	mov    %eax,%ebx
	u32 bsr_flag;	//bsr
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
    91c0:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    91c7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    91ce:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    91d5:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    91dc:	e8 fc ff ff ff       	call   91dd <complexUeMacPdu+0x2d>

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    91e1:	31 d2                	xor    %edx,%edx
    91e3:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    91e8:	89 c6                	mov    %eax,%esi

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    91ea:	8d 45 f1             	lea    -0xf(%ebp),%eax
    91ed:	e8 fc ff ff ff       	call   91ee <complexUeMacPdu+0x3e>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));		//20140430
    91f2:	31 d2                	xor    %edx,%edx
    91f4:	b9 02 00 00 00       	mov    $0x2,%ecx
    91f9:	8d 45 ed             	lea    -0x13(%ebp),%eax
    91fc:	e8 fc ff ff ff       	call   91fd <complexUeMacPdu+0x4d>
	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));		//20140430
    9201:	31 d2                	xor    %edx,%edx
    9203:	b9 03 00 00 00       	mov    $0x3,%ecx
    9208:	8d 45 e7             	lea    -0x19(%ebp),%eax
    920b:	e8 fc ff ff ff       	call   920c <complexUeMacPdu+0x5c>
	fsm_mem_set(&m_crnti,0,sizeof(MAC_CE_Crnti));		//20140430
    9210:	31 d2                	xor    %edx,%edx
    9212:	b9 02 00 00 00       	mov    $0x2,%ecx
    9217:	8d 45 ef             	lea    -0x11(%ebp),%eax
    921a:	e8 fc ff ff ff       	call   921b <complexUeMacPdu+0x6b>
	fsm_mem_set(&m_power_headroom,0,sizeof(MAC_CE_power_headroom));//20140430
    921f:	31 d2                	xor    %edx,%edx
    9221:	b9 01 00 00 00       	mov    $0x1,%ecx
    9226:	8d 45 f2             	lea    -0xe(%ebp),%eax
    9229:	e8 fc ff ff ff       	call   922a <complexUeMacPdu+0x7a>
	fsm_mem_set(&m_short_bsr,0,sizeof(MAC_CE_shortBSR));		//20140430
    922e:	31 d2                	xor    %edx,%edx
    9230:	b9 01 00 00 00       	mov    $0x1,%ecx
    9235:	8d 45 f3             	lea    -0xd(%ebp),%eax
    9238:	e8 fc ff ff ff       	call   9239 <complexUeMacPdu+0x89>
	fsm_mem_set(&m_long_bsr,0,sizeof(MAC_CE_longBSR));		//20140430
    923d:	31 d2                	xor    %edx,%edx
    923f:	b9 03 00 00 00       	mov    $0x3,%ecx
    9244:	8d 45 ea             	lea    -0x16(%ebp),%eax
    9247:	e8 fc ff ff ff       	call   9248 <complexUeMacPdu+0x98>
	//fsm_mem_set(m_rlc_type2_ici,0,sizeof(RLC_MAC_IciMsgPB));		//20140430
	fsm_mem_set(&m_rlc_type1_ici,0,sizeof(RLCtoMAC_IciMsg));		//20140430
    924c:	31 d2                	xor    %edx,%edx
    924e:	b9 04 00 00 00       	mov    $0x4,%ecx
    9253:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    9256:	e8 fc ff ff ff       	call   9257 <complexUeMacPdu+0xa7>
	fsm_mem_set(&m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    925b:	31 d2                	xor    %edx,%edx
    925d:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    9262:	8d 45 a6             	lea    -0x5a(%ebp),%eax
    9265:	e8 fc ff ff ff       	call   9266 <complexUeMacPdu+0xb6>
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506
    926a:	31 d2                	xor    %edx,%edx
    926c:	b9 07 00 00 00       	mov    $0x7,%ecx
    9271:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    9274:	e8 fc ff ff ff       	call   9275 <complexUeMacPdu+0xc5>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
    9279:	8b bb ac 00 00 00    	mov    0xac(%ebx),%edi
    927f:	2b bb a8 00 00 00    	sub    0xa8(%ebx),%edi



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    9285:	8d 47 0a             	lea    0xa(%edi),%eax
    9288:	e8 fc ff ff ff       	call   9289 <complexUeMacPdu+0xd9>

	if(!compare(skb->data-skb->head,re_len)){
    928d:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    9293:	89 45 a0             	mov    %eax,-0x60(%ebp)

	if(!compare(skb->data-skb->head,re_len)){
    9296:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    929c:	29 d0                	sub    %edx,%eax
    929e:	39 f8                	cmp    %edi,%eax
    92a0:	0f 82 ca 03 00 00    	jb     9670 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(head_backup,skb->head,re_len);
    92a6:	8b 45 a0             	mov    -0x60(%ebp),%eax
    92a9:	89 f9                	mov    %edi,%ecx
    92ab:	e8 fc ff ff ff       	call   92ac <complexUeMacPdu+0xfc>
	
	
	/*
	 * for test
	 */
	SV(pkt_num_uplink)=SV(pkt_num_uplink)+1;
    92b0:	83 86 08 02 00 00 01 	addl   $0x1,0x208(%esi)

	len=sizeof(RLCtoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    92b7:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    92bd:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    92c3:	29 d0                	sub    %edx,%eax
    92c5:	83 f8 03             	cmp    $0x3,%eax
    92c8:	0f 86 a2 03 00 00    	jbe    9670 <complexUeMacPdu+0x4c0>
		fsm_pkt_destroy(skb);
		FOUT;
	}


	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
    92ce:	b9 04 00 00 00       	mov    $0x4,%ecx
    92d3:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    92d6:	e8 fc ff ff ff       	call   92d7 <complexUeMacPdu+0x127>
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
    92db:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    92df:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
    92e3:	0f b7 c0             	movzwl %ax,%eax
    92e6:	89 44 24 04          	mov    %eax,0x4(%esp)
    92ea:	c7 04 24 44 29 00 00 	movl   $0x2944,(%esp)
    92f1:	e8 fc ff ff ff       	call   92f2 <complexUeMacPdu+0x142>
	if(skb->data==skb->tail){	//SDU,
    92f6:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    92fc:	89 45 98             	mov    %eax,-0x68(%ebp)
    92ff:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9305:	89 45 94             	mov    %eax,-0x6c(%ebp)
	}
	else
		e=1;	//20131110modified

	total_len=SV(Tbsize_Complex);
	fsm_printf("[COMPLEX]TBSIZE:%d\n",SV(Tbsize_Complex));	
    9308:	8b 86 f4 01 00 00    	mov    0x1f4(%esi),%eax
    930e:	c7 04 24 42 07 00 00 	movl   $0x742,(%esp)
    9315:	89 44 24 04          	mov    %eax,0x4(%esp)
    9319:	e8 fc ff ff ff       	call   931a <complexUeMacPdu+0x16a>
		len=sizeof(RLCtoMAC_IciMsg);
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
    931e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9324:	0f b7 55 e5          	movzwl -0x1b(%ebp),%edx
    9328:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    932e:	01 d0                	add    %edx,%eax
    9330:	3d fa 05 00 00       	cmp    $0x5fa,%eax
    9335:	0f 87 5d 03 00 00    	ja     9698 <complexUeMacPdu+0x4e8>
		fsm_pkt_destroy(skb);
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
    933b:	8d 45 ef             	lea    -0x11(%ebp),%eax
    933e:	e8 fc ff ff ff       	call   933f <complexUeMacPdu+0x18f>
    9343:	88 45 9c             	mov    %al,-0x64(%ebp)
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    9346:	8d 45 f2             	lea    -0xe(%ebp),%eax
    9349:	e8 fc ff ff ff       	call   934a <complexUeMacPdu+0x19a>
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    934e:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    9351:	8d 55 dc             	lea    -0x24(%ebp),%edx
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    9354:	88 45 9d             	mov    %al,-0x63(%ebp)
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    9357:	8d 45 d8             	lea    -0x28(%ebp),%eax
    935a:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    9361:	e8 fc ff ff ff       	call   9362 <complexUeMacPdu+0x1b2>
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    9366:	83 f8 01             	cmp    $0x1,%eax
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    9369:	89 c7                	mov    %eax,%edi
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    936b:	76 0c                	jbe    9379 <complexUeMacPdu+0x1c9>
	
		test_len++;
	
		if(con_flag)
			fsm_printf("[COMPLEX]LONG BSR CONTROL ELEMENT FOUND!\n");
    936d:	c7 04 24 8c 29 00 00 	movl   $0x298c,(%esp)
    9374:	e8 fc ff ff ff       	call   9375 <complexUeMacPdu+0x1c5>
	test_rnti=test_ici.rnti;
	fsm_printf("[HEXI]LCID AND RNTI OF CCCH AFTER REALLOC:%d %d\n",test_lcid,test_rnti);*/

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
    9379:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    937d:	74 2f                	je     93ae <complexUeMacPdu+0x1fe>
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST

		if(!compare(skb->data-skb->head,len)){
    937f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9385:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST
    938b:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)

		if(!compare(skb->data-skb->head,len)){
    938f:	0f 84 db 02 00 00    	je     9670 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_power_headroom,len);	//NEWSDU
    9395:	ba 01 00 00 00       	mov    $0x1,%edx
    939a:	89 d8                	mov    %ebx,%eax
    939c:	e8 fc ff ff ff       	call   939d <complexUeMacPdu+0x1ed>
    93a1:	b9 01 00 00 00       	mov    $0x1,%ecx
    93a6:	8d 55 f2             	lea    -0xe(%ebp),%edx
    93a9:	e8 fc ff ff ff       	call   93aa <complexUeMacPdu+0x1fa>
		
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti->m_crnti);
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR
    93ae:	85 ff                	test   %edi,%edi
    93b0:	0f 85 6a 02 00 00    	jne    9620 <complexUeMacPdu+0x470>
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL SUBHEAD:%d\n",(skb->tail-skb->data));
	
	if(crnti_flag){
    93b6:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    93ba:	74 4a                	je     9406 <complexUeMacPdu+0x256>
		len=sizeof(MAC_CE_Crnti);

		if(!compare(skb->data-skb->head,len)){
    93bc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    93c2:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    93c8:	83 f8 01             	cmp    $0x1,%eax
    93cb:	0f 86 9f 02 00 00    	jbe    9670 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_crnti,len);	//NEWSDU
    93d1:	ba 02 00 00 00       	mov    $0x2,%edx
    93d6:	89 d8                	mov    %ebx,%eax
    93d8:	e8 fc ff ff ff       	call   93d9 <complexUeMacPdu+0x229>
    93dd:	b9 02 00 00 00       	mov    $0x2,%ecx
    93e2:	8d 55 ef             	lea    -0x11(%ebp),%edx
    93e5:	e8 fc ff ff ff       	call   93e6 <complexUeMacPdu+0x236>
		rnti_to_ici=SV(T_C_RNTI);
    93ea:	0f b7 46 02          	movzwl 0x2(%esi),%eax
    93ee:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti.m_crnti);
    93f2:	0f b7 45 ef          	movzwl -0x11(%ebp),%eax
    93f6:	c7 04 24 b8 29 00 00 	movl   $0x29b8,(%esp)
    93fd:	89 44 24 04          	mov    %eax,0x4(%esp)
    9401:	e8 fc ff ff ff       	call   9402 <complexUeMacPdu+0x252>
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9406:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    940c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9412:	0f b7 4d e5          	movzwl -0x1b(%ebp),%ecx
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9416:	29 d0                	sub    %edx,%eax
    9418:	83 e8 04             	sub    $0x4,%eax
    941b:	83 f8 01             	cmp    $0x1,%eax
    941e:	0f 86 4c 02 00 00    	jbe    9670 <complexUeMacPdu+0x4c0>
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9424:	0f b7 c9             	movzwl %cx,%ecx
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    9427:	83 c2 04             	add    $0x4,%edx
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    942a:	89 4d 90             	mov    %ecx,-0x70(%ebp)
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    942d:	8d 45 ed             	lea    -0x13(%ebp),%eax
    9430:	b9 02 00 00 00       	mov    $0x2,%ecx
    9435:	e8 fc ff ff ff       	call   9436 <complexUeMacPdu+0x286>
	m_7bit_subhead.m_f_l=m_7bit_subhead.m_f_l>>7;
    943a:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    943e:	c0 e8 07             	shr    $0x7,%al
    9441:	88 45 ee             	mov    %al,-0x12(%ebp)
	fsm_printf("THE TYPE OF SDU:%d\n",m_7bit_subhead.m_f_l);
    9444:	0f b6 c0             	movzbl %al,%eax
    9447:	89 44 24 04          	mov    %eax,0x4(%esp)
    944b:	c7 04 24 56 07 00 00 	movl   $0x756,(%esp)
    9452:	e8 fc ff ff ff       	call   9453 <complexUeMacPdu+0x2a3>
	
	
	test_len+=head_len;
	//fsm_printf("[COMPLEX]THE ORIGINAL LENGTH AND LENGTH OF THE HEADS:%d,%d\n",m_rlc_type1_ici->len,head_len);
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING SDU SUBHEAD:%d\n",(skb->tail-skb->data));
	if(!compare(skb->data-skb->head-len,head_len)){
    9457:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    945d:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    9463:	83 e8 04             	sub    $0x4,%eax
    9466:	39 45 90             	cmp    %eax,-0x70(%ebp)
    9469:	0f 87 01 02 00 00    	ja     9670 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_skb_push(skb,head_len);		
    946f:	8b 55 90             	mov    -0x70(%ebp),%edx
    9472:	89 d8                	mov    %ebx,%eax
    9474:	e8 fc ff ff ff       	call   9475 <complexUeMacPdu+0x2c5>
	fsm_mem_cpy(skb->data,(u8*)head_backup+len,head_len);	//SDUdata 	//for test
    9479:	8b 55 a0             	mov    -0x60(%ebp),%edx
    947c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9482:	8b 4d 90             	mov    -0x70(%ebp),%ecx
    9485:	83 c2 04             	add    $0x4,%edx
    9488:	e8 fc ff ff ff       	call   9489 <complexUeMacPdu+0x2d9>

	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
    948d:	85 ff                	test   %edi,%edi
    948f:	0f 84 bb 02 00 00    	je     9750 <complexUeMacPdu+0x5a0>

	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
	if(skb->data==skb->tail){	//SDU,
		e=0;
    9495:	8b 45 94             	mov    -0x6c(%ebp),%eax
    9498:	39 45 98             	cmp    %eax,-0x68(%ebp)
    949b:	0f 95 c0             	setne  %al
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
    949e:	c1 e0 05             	shl    $0x5,%eax
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
    94a1:	83 ff 01             	cmp    $0x1,%edi
    94a4:	0f 84 46 02 00 00    	je     96f0 <complexUeMacPdu+0x540>
			//fsm_printf("PUT IN THE LONG BSR HEAD!\n");


			lcid=LONG_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    94aa:	83 c0 1e             	add    $0x1e,%eax
    94ad:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    94b0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    94b6:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    94bc:	0f 84 ae 01 00 00    	je     9670 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    94c2:	ba 01 00 00 00       	mov    $0x1,%edx
    94c7:	89 d8                	mov    %ebx,%eax
    94c9:	e8 fc ff ff ff       	call   94ca <complexUeMacPdu+0x31a>
    94ce:	b9 01 00 00 00       	mov    $0x1,%ecx
	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
    94d3:	31 ff                	xor    %edi,%edi
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    94d5:	8d 55 f1             	lea    -0xf(%ebp),%edx
    94d8:	e8 fc ff ff ff       	call   94d9 <complexUeMacPdu+0x329>
			head_len=head_len+len;
		}
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    94dd:	31 d2                	xor    %edx,%edx
    94df:	b9 01 00 00 00       	mov    $0x1,%ecx
    94e4:	8d 45 f1             	lea    -0xf(%ebp),%eax
    94e7:	e8 fc ff ff ff       	call   94e8 <complexUeMacPdu+0x338>
	if(crnti_flag){
    94ec:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    94f0:	74 39                	je     952b <complexUeMacPdu+0x37b>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    94f2:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=e<<5;
    94f5:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    94f8:	8d 47 1b             	lea    0x1b(%edi),%eax
    94fb:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    94fe:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9504:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    950a:	0f 84 60 01 00 00    	je     9670 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9510:	ba 01 00 00 00       	mov    $0x1,%edx
    9515:	89 d8                	mov    %ebx,%eax
    9517:	e8 fc ff ff ff       	call   9518 <complexUeMacPdu+0x368>
    951c:	b9 01 00 00 00       	mov    $0x1,%ecx
    9521:	31 ff                	xor    %edi,%edi
    9523:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9526:	e8 fc ff ff ff       	call   9527 <complexUeMacPdu+0x377>
		head_len=head_len+len;
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    952b:	31 d2                	xor    %edx,%edx
    952d:	b9 01 00 00 00       	mov    $0x1,%ecx
    9532:	8d 45 f1             	lea    -0xf(%ebp),%eax
    9535:	e8 fc ff ff ff       	call   9536 <complexUeMacPdu+0x386>
	if(ph_flag){
    953a:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    953e:	74 37                	je     9577 <complexUeMacPdu+0x3c7>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9540:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=(e<<5);
    9543:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9546:	8d 47 1a             	lea    0x1a(%edi),%eax
    9549:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    954c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9552:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9558:	0f 84 12 01 00 00    	je     9670 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    955e:	ba 01 00 00 00       	mov    $0x1,%edx
    9563:	89 d8                	mov    %ebx,%eax
    9565:	e8 fc ff ff ff       	call   9566 <complexUeMacPdu+0x3b6>
    956a:	b9 01 00 00 00       	mov    $0x1,%ecx
    956f:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9572:	e8 fc ff ff ff       	call   9573 <complexUeMacPdu+0x3c3>
		
		//fsm_printf("[COMPLEX]PH SUBHED:%c\n",m_fixed_subhead->m_lcid_e_r_r+10);
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL ELEMENTS:%d\n",(skb->tail-skb->data));
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    9577:	0f b7 4d 9e          	movzwl -0x62(%ebp),%ecx
    957b:	ba 02 00 00 00       	mov    $0x2,%edx
    9580:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    9583:	e8 fc ff ff ff       	call   9584 <complexUeMacPdu+0x3d4>
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 
    9588:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    958c:	89 44 24 08          	mov    %eax,0x8(%esp)
    9590:	0f b7 45 d5          	movzwl -0x2b(%ebp),%eax
    9594:	c7 04 24 dc 29 00 00 	movl   $0x29dc,(%esp)
    959b:	89 44 24 04          	mov    %eax,0x4(%esp)
    959f:	e8 fc ff ff ff       	call   95a0 <complexUeMacPdu+0x3f0>

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
    95a4:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    95aa:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    95b0:	29 c2                	sub    %eax,%edx
    95b2:	83 fa 06             	cmp    $0x6,%edx
    95b5:	0f 86 b5 00 00 00    	jbe    9670 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

    	fsm_mem_cpy(skb->head,&m_phy_ici,sizeof(MACtoPHYadapter_IciMsg));//ICIsk_buf//20140506 HQ
    95bb:	b9 07 00 00 00       	mov    $0x7,%ecx
    95c0:	8d 55 d1             	lea    -0x2f(%ebp),%edx
    95c3:	e8 fc ff ff ff       	call   95c4 <complexUeMacPdu+0x414>
    		fsm_printf("%c ",*(skb->data+i)+65);
    	}*/
    	
    	//fsm_octets_print(skb->data,7);
    	
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
    95c8:	ba 03 00 00 00       	mov    $0x3,%edx
    95cd:	89 d8                	mov    %ebx,%eax
    95cf:	e8 fc ff ff ff       	call   95d0 <complexUeMacPdu+0x420>
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
    95d4:	8b 43 50             	mov    0x50(%ebx),%eax
    95d7:	c7 04 24 08 2a 00 00 	movl   $0x2a08,(%esp)
    95de:	89 44 24 04          	mov    %eax,0x4(%esp)
    95e2:	e8 fc ff ff ff       	call   95e3 <complexUeMacPdu+0x433>
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping
    95e7:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    95ed:	ba 50 00 00 00       	mov    $0x50,%edx
    95f2:	e8 fc ff ff ff       	call   95f3 <complexUeMacPdu+0x443>
	SV(Tbsize_Complex)=0;

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    95f7:	8b 45 a0             	mov    -0x60(%ebp),%eax
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping

	SV(Tbsize_Complex)=0;
    95fa:	c7 86 f4 01 00 00 00 	movl   $0x0,0x1f4(%esi)
    9601:	00 00 00 

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9604:	e8 fc ff ff ff       	call   9605 <complexUeMacPdu+0x455>
	clean_CE_tags();// modified by HQ 20140512 
    9609:	e8 fc ff ff ff       	call   960a <complexUeMacPdu+0x45a>
	fsm_printf("complex function done\n");//testing code 
    960e:	c7 04 24 6a 07 00 00 	movl   $0x76a,(%esp)
    9615:	e8 fc ff ff ff       	call   9616 <complexUeMacPdu+0x466>
	fsm_printf("%c,\n",*(skb->data+from_len));
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
    961a:	eb 6f                	jmp    968b <complexUeMacPdu+0x4db>
    961c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
    9620:	83 ff 01             	cmp    $0x1,%edi
    9623:	0f 84 e7 00 00 00    	je     9710 <complexUeMacPdu+0x560>

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    9629:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		else{
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
    962c:	8b 45 c0             	mov    -0x40(%ebp),%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    962f:	89 ca                	mov    %ecx,%edx
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
    9631:	c1 e0 02             	shl    $0x2,%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    9634:	83 e2 30             	and    $0x30,%edx
    9637:	0f b6 c0             	movzbl %al,%eax
    963a:	01 d0                	add    %edx,%eax
    963c:	c1 e8 04             	shr    $0x4,%eax
    963f:	88 45 ea             	mov    %al,-0x16(%ebp)
			m_long_bsr.m_buffersize2=(longbsr_buf_sizes[1]&15);
    9642:	89 c8                	mov    %ecx,%eax
    9644:	83 e0 0f             	and    $0xf,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    9647:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[2];
    964a:	66 03 45 c8          	add    -0x38(%ebp),%ax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    964e:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[3];
    9651:	66 03 45 cc          	add    -0x34(%ebp),%ax
    9655:	66 89 45 eb          	mov    %ax,-0x15(%ebp)
			//
			//fsm_printf("[COMPLEX]BSR VALUE:%c,%d\n",m_long_bsr->m_buffersize1+65,m_long_bsr->m_buffersize2);

			len=sizeof(MAC_CE_longBSR);

			if(!compare(skb->data-skb->head,len)){
    9659:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    965f:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    9665:	83 f8 02             	cmp    $0x2,%eax
    9668:	77 5e                	ja     96c8 <complexUeMacPdu+0x518>
    966a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
			fsm_mem_free(head_backup);
    9670:	8b 45 a0             	mov    -0x60(%ebp),%eax
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    9673:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
			fsm_mem_free(head_backup);
    967a:	e8 fc ff ff ff       	call   967b <complexUeMacPdu+0x4cb>
			clean_CE_tags();
    967f:	e8 fc ff ff ff       	call   9680 <complexUeMacPdu+0x4d0>
			fsm_pkt_destroy(skb);
    9684:	89 d8                	mov    %ebx,%eax
    9686:	e8 fc ff ff ff       	call   9687 <complexUeMacPdu+0x4d7>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    968b:	83 c4 70             	add    $0x70,%esp
    968e:	5b                   	pop    %ebx
    968f:	5e                   	pop    %esi
    9690:	5f                   	pop    %edi
    9691:	5d                   	pop    %ebp
    9692:	c3                   	ret    
    9693:	90                   	nop
    9694:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9698:	8b 45 a0             	mov    -0x60(%ebp),%eax
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    969b:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    96a2:	e8 fc ff ff ff       	call   96a3 <complexUeMacPdu+0x4f3>
		clean_CE_tags();// modified by HQ 20140512 
    96a7:	e8 fc ff ff ff       	call   96a8 <complexUeMacPdu+0x4f8>
		fsm_printf("complex function done by error!\n");//testing code 
    96ac:	c7 04 24 68 29 00 00 	movl   $0x2968,(%esp)
    96b3:	e8 fc ff ff ff       	call   96b4 <complexUeMacPdu+0x504>
		fsm_pkt_destroy(skb);
    96b8:	89 d8                	mov    %ebx,%eax
    96ba:	e8 fc ff ff ff       	call   96bb <complexUeMacPdu+0x50b>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    96bf:	83 c4 70             	add    $0x70,%esp
    96c2:	5b                   	pop    %ebx
    96c3:	5e                   	pop    %esi
    96c4:	5f                   	pop    %edi
    96c5:	5d                   	pop    %ebp
    96c6:	c3                   	ret    
    96c7:	90                   	nop
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_long_bsr,len);	//BSR
    96c8:	ba 03 00 00 00       	mov    $0x3,%edx
    96cd:	89 d8                	mov    %ebx,%eax
    96cf:	e8 fc ff ff ff       	call   96d0 <complexUeMacPdu+0x520>
    96d4:	b9 03 00 00 00       	mov    $0x3,%ecx
    96d9:	8d 55 ea             	lea    -0x16(%ebp),%edx
    96dc:	e8 fc ff ff ff       	call   96dd <complexUeMacPdu+0x52d>
			}
			SV(RetxBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)*100;
			SV(RetxBSRTimer).timer_sign = fsm_schedule_self(SV(RetxBSRTimer).time_value,RexBSRTimer_Expire );
			SV(RetxBSRTimer).flag = true; */			
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
    96e1:	e8 fc ff ff ff       	call   96e2 <complexUeMacPdu+0x532>
    96e6:	e9 cb fc ff ff       	jmp    93b6 <complexUeMacPdu+0x206>
    96eb:	90                   	nop
    96ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    96f0:	83 c0 1d             	add    $0x1d,%eax
    96f3:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    96f6:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    96fc:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9702:	0f 85 ba fd ff ff    	jne    94c2 <complexUeMacPdu+0x312>
    9708:	e9 63 ff ff ff       	jmp    9670 <complexUeMacPdu+0x4c0>
    970d:	8d 76 00             	lea    0x0(%esi),%esi
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
			m_short_bsr.m_lcgid_buffersize=lcg_id;
    9710:	8b 45 d8             	mov    -0x28(%ebp),%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize<<6;
    9713:	c1 e0 06             	shl    $0x6,%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize+(shortbsr_buf_size);
    9716:	02 45 dc             	add    -0x24(%ebp),%al
    9719:	88 45 f3             	mov    %al,-0xd(%ebp)
			len=sizeof(MAC_CE_shortBSR);

			if(!compare(skb->data-skb->head,len)){
    971c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9722:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9728:	0f 84 42 ff ff ff    	je     9670 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_short_bsr,len);	//BSR
    972e:	ba 01 00 00 00       	mov    $0x1,%edx
    9733:	89 d8                	mov    %ebx,%eax
    9735:	e8 fc ff ff ff       	call   9736 <complexUeMacPdu+0x586>
    973a:	b9 01 00 00 00       	mov    $0x1,%ecx
    973f:	8d 55 f3             	lea    -0xd(%ebp),%edx
    9742:	e8 fc ff ff ff       	call   9743 <complexUeMacPdu+0x593>
    9747:	eb 98                	jmp    96e1 <complexUeMacPdu+0x531>
    9749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
	bool crnti_flag=false, ph_flag=false,first_flag=true,con_flag=true;	//crnti; 
    9750:	bf 01 00 00 00       	mov    $0x1,%edi
    9755:	e9 83 fd ff ff       	jmp    94dd <complexUeMacPdu+0x32d>
    975a:	90                   	nop
    975b:	90                   	nop
    975c:	90                   	nop
    975d:	90                   	nop
    975e:	90                   	nop
    975f:	90                   	nop

00009760 <Init_Uemac_Scheduler>:
->output:
->Special:
*******************************
*/
void Init_Uemac_Scheduler(void)
{
    9760:	55                   	push   %ebp
    9761:	89 e5                	mov    %esp,%ebp
    9763:	53                   	push   %ebx
    9764:	e8 fc ff ff ff       	call   9765 <Init_Uemac_Scheduler+0x5>
	FIN(Init_Uemac_Scheduler(void));
	SV_PTR_GET(rlc_mac_sv);
    9769:	e8 fc ff ff ff       	call   976a <Init_Uemac_Scheduler+0xa>
    976e:	89 c3                	mov    %eax,%ebx
	SV(LCGZeroToData)=false;
    9770:	c6 80 58 01 00 00 00 	movb   $0x0,0x158(%eax)
	SV(m_freshUlBsr)=false;
    9777:	c6 80 59 01 00 00 00 	movb   $0x0,0x159(%eax)
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;
    977e:	c6 80 5a 01 00 00 00 	movb   $0x0,0x15a(%eax)

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9785:	b8 1a 00 00 00       	mov    $0x1a,%eax
    978a:	e8 fc ff ff ff       	call   978b <Init_Uemac_Scheduler+0x2b>
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    978f:	31 d2                	xor    %edx,%edx
    9791:	b9 1a 00 00 00       	mov    $0x1a,%ecx
	SV(LCGZeroToData)=false;
	SV(m_freshUlBsr)=false;
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9796:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    979c:	e8 fc ff ff ff       	call   979d <Init_Uemac_Scheduler+0x3d>
	SV(Periodicbsr)=NULL;
	SV(Regularbsr)=NULL;
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    97a1:	b8 0d 00 00 00       	mov    $0xd,%eax
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
	SV(Periodicbsr)=NULL;
    97a6:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    97ad:	00 00 00 
	SV(Regularbsr)=NULL;
    97b0:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    97b7:	00 00 00 
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    97ba:	e8 fc ff ff ff       	call   97bb <Init_Uemac_Scheduler+0x5b>
    97bf:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
	SV(LogicalChannel_Bj)=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    97c5:	b8 0d 00 00 00       	mov    $0xd,%eax
    97ca:	e8 fc ff ff ff       	call   97cb <Init_Uemac_Scheduler+0x6b>
    97cf:	89 83 44 01 00 00    	mov    %eax,0x144(%ebx)
	SV(LogicalChannel_Config)=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    97d5:	b8 19 00 00 00       	mov    $0x19,%eax
    97da:	e8 fc ff ff ff       	call   97db <Init_Uemac_Scheduler+0x7b>
    97df:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
	INIT_LIST_HEAD(&(SV(MacBuffer_RLC)->list));
    97e5:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    97eb:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    97ee:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    97f1:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Bj)->list));
    97f4:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
    97fa:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    97fd:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9800:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Config)->list));
    9803:	8b 83 40 01 00 00    	mov    0x140(%ebx),%eax
    9809:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    980c:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    980f:	89 50 15             	mov    %edx,0x15(%eax)
	FOUT;
}
    9812:	5b                   	pop    %ebx
    9813:	5d                   	pop    %ebp
    9814:	c3                   	ret    
    9815:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9819:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009820 <RlcRequest_arraytolist>:
->Output:RlcBufferRequest 
->Special:
*******************************
*/
RlcBufferRequest * RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num)//num
{
    9820:	55                   	push   %ebp
    9821:	89 e5                	mov    %esp,%ebp
    9823:	57                   	push   %edi
    9824:	56                   	push   %esi
    9825:	53                   	push   %ebx
    9826:	83 ec 18             	sub    $0x18,%esp
    9829:	e8 fc ff ff ff       	call   982a <RlcRequest_arraytolist+0xa>
    982e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9831:	89 c6                	mov    %eax,%esi
	LogicalChannelConfigInfo *temp_lcc_info;
	u8 lcid;
	u32 flag;

	FIN(RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num));
	SV_PTR_GET(rlc_mac_sv);
    9833:	e8 fc ff ff ff       	call   9834 <RlcRequest_arraytolist+0x14>
    9838:	89 c7                	mov    %eax,%edi
	rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    983a:	b8 1b 00 00 00       	mov    $0x1b,%eax
    983f:	e8 fc ff ff ff       	call   9840 <RlcRequest_arraytolist+0x20>
    9844:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9847:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
    984a:	83 c0 13             	add    $0x13,%eax
    984d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9850:	89 42 13             	mov    %eax,0x13(%edx)
	list->prev = list;
    9853:	89 42 17             	mov    %eax,0x17(%edx)
	for(i=0;i<num;i++)
    9856:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9859:	85 c0                	test   %eax,%eax
    985b:	74 52                	je     98af <RlcRequest_arraytolist+0x8f>
    985d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9864:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9868:	8b 87 40 01 00 00    	mov    0x140(%edi),%eax
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
    986e:	0f b6 56 02          	movzbl 0x2(%esi),%edx
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9872:	8b 58 11             	mov    0x11(%eax),%ebx
    9875:	83 eb 11             	sub    $0x11,%ebx
    9878:	39 d8                	cmp    %ebx,%eax
    987a:	74 12                	je     988e <RlcRequest_arraytolist+0x6e>
		{
			if(lcid==temp_lcc_info->lcid)
    987c:	38 13                	cmp    %dl,(%ebx)
    987e:	74 48                	je     98c8 <RlcRequest_arraytolist+0xa8>
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9880:	8b 5b 11             	mov    0x11(%ebx),%ebx
    9883:	83 eb 11             	sub    $0x11,%ebx
    9886:	39 9f 40 01 00 00    	cmp    %ebx,0x140(%edi)
    988c:	75 ee                	jne    987c <RlcRequest_arraytolist+0x5c>
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
    988e:	c7 04 24 70 2a 00 00 	movl   $0x2a70,(%esp)
    9895:	e8 fc ff ff ff       	call   9896 <RlcRequest_arraytolist+0x76>
    989a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
    98a0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    98a4:	83 c6 13             	add    $0x13,%esi
    98a7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    98aa:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    98ad:	75 b9                	jne    9868 <RlcRequest_arraytolist+0x48>
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    98af:	8b 55 e8             	mov    -0x18(%ebp),%edx
	FRET(rlcrequest);
}
    98b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    98b5:	89 97 5c 01 00 00    	mov    %edx,0x15c(%edi)
	FRET(rlcrequest);
}
    98bb:	83 c4 18             	add    $0x18,%esp
    98be:	5b                   	pop    %ebx
    98bf:	5e                   	pop    %esi
    98c0:	5f                   	pop    %edi
    98c1:	5d                   	pop    %ebp
    98c2:	c3                   	ret    
    98c3:	90                   	nop
    98c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			if(lcid==temp_lcc_info->lcid)
			{
				if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    98c8:	83 7b 0d 03          	cmpl   $0x3,0xd(%ebx)
    98cc:	77 6a                	ja     9938 <RlcRequest_arraytolist+0x118>
				}
			}
		}
		if(flag==1)//requestMAC 
		{		
			rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    98ce:	b8 1b 00 00 00       	mov    $0x1b,%eax
    98d3:	e8 fc ff ff ff       	call   98d4 <RlcRequest_arraytolist+0xb4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    98d8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
			/*while(rlcrequest_temp==0)//
			{
				rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
			}*/
			INIT_LIST_HEAD(&(rlcrequest_temp->list));
    98db:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    98de:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    98e1:	89 50 17             	mov    %edx,0x17(%eax)
			rlcrequest_temp->rnti=rlc_request_array[i].rnti;
    98e4:	0f b7 0e             	movzwl (%esi),%ecx
    98e7:	66 89 08             	mov    %cx,(%eax)
			rlcrequest_temp->lcid=rlc_request_array[i].lcid;
    98ea:	0f b6 4e 02          	movzbl 0x2(%esi),%ecx
    98ee:	88 48 02             	mov    %cl,0x2(%eax)
			rlcrequest_temp->txQueueSize=rlc_request_array[i].txQueueSize;
    98f1:	8b 4e 03             	mov    0x3(%esi),%ecx
    98f4:	89 48 03             	mov    %ecx,0x3(%eax)
			rlcrequest_temp->txQueueHeader=rlc_request_array[i].txQueueHeader;
    98f7:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    98fb:	66 89 48 07          	mov    %cx,0x7(%eax)
			rlcrequest_temp->retxQueueSize=rlc_request_array[i].retxQueueSize;
    98ff:	8b 4e 09             	mov    0x9(%esi),%ecx
    9902:	89 48 09             	mov    %ecx,0x9(%eax)
			rlcrequest_temp->retxQueueHeader=rlc_request_array[i].retxQueueHeader;
    9905:	0f b7 4e 0d          	movzwl 0xd(%esi),%ecx
    9909:	66 89 48 0d          	mov    %cx,0xd(%eax)
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
    990d:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    9911:	66 89 48 0f          	mov    %cx,0xf(%eax)
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
    9915:	0f b7 4e 11          	movzwl 0x11(%esi),%ecx
    9919:	66 89 48 11          	mov    %cx,0x11(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    991d:	8b 4b 17             	mov    0x17(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9920:	89 53 17             	mov    %edx,0x17(%ebx)
	new->next = next;
    9923:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	new->prev = prev;
    9926:	89 48 17             	mov    %ecx,0x17(%eax)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    9929:	89 58 13             	mov    %ebx,0x13(%eax)
	new->prev = prev;
	prev->next = new;
    992c:	89 11                	mov    %edx,(%ecx)
    992e:	e9 6d ff ff ff       	jmp    98a0 <RlcRequest_arraytolist+0x80>
    9933:	90                   	nop
    9934:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					flag=1;
					break;
				}
				else
				{
					fsm_printf("[UEMAC][RLCreq_tolist]:lc_group error ,maybe it's rrc's mistake\n");
    9938:	88 55 e0             	mov    %dl,-0x20(%ebp)
    993b:	c7 04 24 2c 2a 00 00 	movl   $0x2a2c,(%esp)
    9942:	e8 fc ff ff ff       	call   9943 <RlcRequest_arraytolist+0x123>
    9947:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
					continue;
    994b:	e9 30 ff ff ff       	jmp    9880 <RlcRequest_arraytolist+0x60>

00009950 <RlcRequest_listtoarray>:
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9950:	55                   	push   %ebp
    9951:	89 e5                	mov    %esp,%ebp
    9953:	57                   	push   %edi
    9954:	56                   	push   %esi
    9955:	53                   	push   %ebx
    9956:	83 ec 10             	sub    $0x10,%esp
    9959:	e8 fc ff ff ff       	call   995a <RlcRequest_listtoarray+0xa>
	/*while(rlc_report==0)//
	{
		rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(int));
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;
    995e:	31 db                	xor    %ebx,%ebx
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9960:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9963:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void *rlc_report;
	u32 *temp_num;
	RLC_Request *rlc_report_temp;

	FIN(RlcRequest_listtoarray( RlcBufferRequest *rlc_request,int *num));
	SV_PTR_GET(rlc_mac_sv);
    9966:	e8 fc ff ff ff       	call   9967 <RlcRequest_listtoarray+0x17>
	rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(u32));//report
    996b:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
    9971:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    9974:	8d 44 50 04          	lea    0x4(%eax,%edx,2),%eax
    9978:	e8 fc ff ff ff       	call   9979 <RlcRequest_listtoarray+0x29>
    997d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9980:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9983:	8b 50 13             	mov    0x13(%eax),%edx
    9986:	89 c7                	mov    %eax,%edi
    9988:	b8 04 00 00 00       	mov    $0x4,%eax
    998d:	83 c7 13             	add    $0x13,%edi
    9990:	39 fa                	cmp    %edi,%edx
    9992:	8b 0a                	mov    (%edx),%ecx
    9994:	74 62                	je     99f8 <RlcRequest_listtoarray+0xa8>
    9996:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9999:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    999c:	eb 06                	jmp    99a4 <RlcRequest_listtoarray+0x54>
    999e:	66 90                	xchg   %ax,%ax
    99a0:	89 ca                	mov    %ecx,%edx
    99a2:	89 f1                	mov    %esi,%ecx
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    99a4:	0f b7 72 ed          	movzwl -0x13(%edx),%esi
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
    99a8:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    99ac:	66 89 70 04          	mov    %si,0x4(%eax)
		rlc_report_temp[i].lcid=temp->lcid;
    99b0:	0f b6 72 ef          	movzbl -0x11(%edx),%esi
    99b4:	89 f3                	mov    %esi,%ebx
    99b6:	88 58 06             	mov    %bl,0x6(%eax)
		rlc_report_temp[i].txQueueSize=temp->txQueueSize;
    99b9:	8b 72 f0             	mov    -0x10(%edx),%esi
    99bc:	89 70 07             	mov    %esi,0x7(%eax)
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
    99bf:	0f b7 72 f4          	movzwl -0xc(%edx),%esi
    99c3:	66 89 70 0b          	mov    %si,0xb(%eax)
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
    99c7:	8b 72 f6             	mov    -0xa(%edx),%esi
    99ca:	89 70 0d             	mov    %esi,0xd(%eax)
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
    99cd:	0f b7 72 fa          	movzwl -0x6(%edx),%esi
    99d1:	66 89 70 11          	mov    %si,0x11(%eax)
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
    99d5:	0f b7 72 fc          	movzwl -0x4(%edx),%esi
    99d9:	66 89 70 13          	mov    %si,0x13(%eax)
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
    99dd:	0f b7 52 fe          	movzwl -0x2(%edx),%edx
    99e1:	66 89 50 15          	mov    %dx,0x15(%eax)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    99e5:	83 c0 13             	add    $0x13,%eax
    99e8:	39 cf                	cmp    %ecx,%edi
    99ea:	8b 31                	mov    (%ecx),%esi
    99ec:	75 b2                	jne    99a0 <RlcRequest_listtoarray+0x50>
    99ee:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    99f1:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    99f4:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
    99f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    99fb:	89 1a                	mov    %ebx,(%edx)
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
    99fd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9a00:	89 02                	mov    %eax,(%edx)
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9a02:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a05:	8b 50 13             	mov    0x13(%eax),%edx
    9a08:	39 d7                	cmp    %edx,%edi
    9a0a:	8b 1a                	mov    (%edx),%ebx
    9a0c:	75 04                	jne    9a12 <RlcRequest_listtoarray+0xc2>
    9a0e:	eb 1f                	jmp    9a2f <RlcRequest_listtoarray+0xdf>
    9a10:	89 f2                	mov    %esi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    9a12:	8b 4a 04             	mov    0x4(%edx),%ecx
    9a15:	89 de                	mov    %ebx,%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    9a17:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    9a1a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    9a1d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a1f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    9a21:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);//
    9a24:	e8 fc ff ff ff       	call   9a25 <RlcRequest_listtoarray+0xd5>
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9a29:	39 fe                	cmp    %edi,%esi
    9a2b:	8b 1b                	mov    (%ebx),%ebx
    9a2d:	75 e1                	jne    9a10 <RlcRequest_listtoarray+0xc0>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);//
	}
	fsm_mem_free(rlc_request);
    9a2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9a32:	e8 fc ff ff ff       	call   9a33 <RlcRequest_listtoarray+0xe3>
	FRET(rlc_report);
}
    9a37:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9a3a:	83 c4 10             	add    $0x10,%esp
    9a3d:	5b                   	pop    %ebx
    9a3e:	5e                   	pop    %esi
    9a3f:	5f                   	pop    %edi
    9a40:	5d                   	pop    %ebp
    9a41:	c3                   	ret    
    9a42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    9a49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009a50 <Rlc_MacRequest_copy>:
->Output:RLC_Request
->Special:
*******************************
*/
RLC_Request* Rlc_MacRequest_copy(RlcBufferRequest *temp)
{
    9a50:	55                   	push   %ebp
    9a51:	89 e5                	mov    %esp,%ebp
    9a53:	53                   	push   %ebx
    9a54:	e8 fc ff ff ff       	call   9a55 <Rlc_MacRequest_copy+0x5>
    9a59:	89 c3                	mov    %eax,%ebx
	FIN(Rlc_MacRequest_copy(RlcBufferRequest *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9a5b:	b8 13 00 00 00       	mov    $0x13,%eax
    9a60:	e8 fc ff ff ff       	call   9a61 <Rlc_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9a65:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9a69:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9a6c:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9a70:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9a74:	8b 53 09             	mov    0x9(%ebx),%edx
    9a77:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9a7a:	0f b7 13             	movzwl (%ebx),%edx
    9a7d:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9a80:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9a84:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9a88:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9a8c:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9a90:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9a94:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9a98:	8b 53 03             	mov    0x3(%ebx),%edx
    9a9b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9a9e:	5b                   	pop    %ebx
    9a9f:	5d                   	pop    %ebp
    9aa0:	c3                   	ret    
    9aa1:	eb 0d                	jmp    9ab0 <LogicalChannel_ConfigInfo_copy>
    9aa3:	90                   	nop
    9aa4:	90                   	nop
    9aa5:	90                   	nop
    9aa6:	90                   	nop
    9aa7:	90                   	nop
    9aa8:	90                   	nop
    9aa9:	90                   	nop
    9aaa:	90                   	nop
    9aab:	90                   	nop
    9aac:	90                   	nop
    9aad:	90                   	nop
    9aae:	90                   	nop
    9aaf:	90                   	nop

00009ab0 <LogicalChannel_ConfigInfo_copy>:
->Output:LogicalChannelConfigInfo:MAC
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp)
{
    9ab0:	55                   	push   %ebp
    9ab1:	89 e5                	mov    %esp,%ebp
    9ab3:	53                   	push   %ebx
    9ab4:	e8 fc ff ff ff       	call   9ab5 <LogicalChannel_ConfigInfo_copy+0x5>
    9ab9:	89 c3                	mov    %eax,%ebx
	FIN(LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp));
	LogicalChannelConfigInfo *copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9abb:	b8 19 00 00 00       	mov    $0x19,%eax
    9ac0:	e8 fc ff ff ff       	call   9ac1 <LogicalChannel_ConfigInfo_copy+0x11>
	/*while(copy==0)//
	{
		copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9ac5:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9ac8:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9acb:	89 50 15             	mov    %edx,0x15(%eax)
	copy->lcid=temp->logicalChannelIdentity;
    9ace:	8b 13                	mov    (%ebx),%edx
    9ad0:	88 10                	mov    %dl,(%eax)
	copy->priority=(temp->logicalChannelConfig).ul_SpecificParameters.priority;
    9ad2:	8b 53 05             	mov    0x5(%ebx),%edx
    9ad5:	89 50 01             	mov    %edx,0x1(%eax)
	copy->prioritizedBitRateKbps=(temp->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    9ad8:	8b 53 09             	mov    0x9(%ebx),%edx
    9adb:	89 50 05             	mov    %edx,0x5(%eax)
	copy->bucketSizeDurationMs=(temp->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    9ade:	8b 53 0d             	mov    0xd(%ebx),%edx
    9ae1:	89 50 09             	mov    %edx,0x9(%eax)
	copy->logicalChannelGroup=(temp->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    9ae4:	8b 53 11             	mov    0x11(%ebx),%edx
    9ae7:	89 50 0d             	mov    %edx,0xd(%eax)
	FRET(copy);
}
    9aea:	5b                   	pop    %ebx
    9aeb:	5d                   	pop    %ebp
    9aec:	c3                   	ret    
    9aed:	8d 76 00             	lea    0x0(%esi),%esi

00009af0 <Mac_RlcRequest_copy>:
->Output:RlcBufferRequest:MACRLC request
->Special:
*******************************
*/
RlcBufferRequest* Mac_RlcRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9af0:	55                   	push   %ebp
    9af1:	89 e5                	mov    %esp,%ebp
    9af3:	53                   	push   %ebx
    9af4:	e8 fc ff ff ff       	call   9af5 <Mac_RlcRequest_copy+0x5>
    9af9:	89 c3                	mov    %eax,%ebx
	FIN(Mac_RlcRequest_copy(RLC_Request *temp));
	RlcBufferRequest *copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9afb:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9b00:	e8 fc ff ff ff       	call   9b01 <Mac_RlcRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9b05:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9b08:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9b0b:	89 50 17             	mov    %edx,0x17(%eax)
	copy->lcid=temp->lcid;
    9b0e:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9b12:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9b15:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9b19:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9b1d:	8b 53 09             	mov    0x9(%ebx),%edx
    9b20:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9b23:	0f b7 13             	movzwl (%ebx),%edx
    9b26:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9b29:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9b2d:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9b31:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9b35:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9b39:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9b3d:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9b41:	8b 53 03             	mov    0x3(%ebx),%edx
    9b44:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9b47:	5b                   	pop    %ebx
    9b48:	5d                   	pop    %ebp
    9b49:	c3                   	ret    
    9b4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00009b50 <Mac_MacRequest_copy>:
->Output:RLC_Request *
->Special:
*******************************
*/
RLC_Request* Mac_MacRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9b50:	55                   	push   %ebp
    9b51:	89 e5                	mov    %esp,%ebp
    9b53:	53                   	push   %ebx
    9b54:	e8 fc ff ff ff       	call   9b55 <Mac_MacRequest_copy+0x5>
    9b59:	89 c3                	mov    %eax,%ebx
	FIN(Mac_MacRequest_copy(RLC_Request *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9b5b:	b8 13 00 00 00       	mov    $0x13,%eax
    9b60:	e8 fc ff ff ff       	call   9b61 <Mac_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9b65:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9b69:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9b6c:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9b70:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9b74:	8b 53 09             	mov    0x9(%ebx),%edx
    9b77:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9b7a:	0f b7 13             	movzwl (%ebx),%edx
    9b7d:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9b80:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9b84:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9b88:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9b8c:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9b90:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9b94:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9b98:	8b 53 03             	mov    0x3(%ebx),%edx
    9b9b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9b9e:	5b                   	pop    %ebx
    9b9f:	5d                   	pop    %ebp
    9ba0:	c3                   	ret    
    9ba1:	eb 0d                	jmp    9bb0 <MacBufferStatus_BSR_Info_copy>
    9ba3:	90                   	nop
    9ba4:	90                   	nop
    9ba5:	90                   	nop
    9ba6:	90                   	nop
    9ba7:	90                   	nop
    9ba8:	90                   	nop
    9ba9:	90                   	nop
    9baa:	90                   	nop
    9bab:	90                   	nop
    9bac:	90                   	nop
    9bad:	90                   	nop
    9bae:	90                   	nop
    9baf:	90                   	nop

00009bb0 <MacBufferStatus_BSR_Info_copy>:
->Output:MacBufferStatus_BSR_Info *
->Special:
*******************************
*/
MacBufferStatus_BSR_Info* MacBufferStatus_BSR_Info_copy(void)//BSR
{
    9bb0:	55                   	push   %ebp
    9bb1:	89 e5                	mov    %esp,%ebp
    9bb3:	53                   	push   %ebx
    9bb4:	e8 fc ff ff ff       	call   9bb5 <MacBufferStatus_BSR_Info_copy+0x5>
	FIN(MacBufferStatus_BSR_Info_copy(void));
	SV_PTR_GET(rlc_mac_sv);
    9bb9:	e8 fc ff ff ff       	call   9bba <MacBufferStatus_BSR_Info_copy+0xa>
    9bbe:	89 c3                	mov    %eax,%ebx
	u32 j=0;
	MacBufferStatus_BSR_Info* copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9bc0:	b8 1a 00 00 00       	mov    $0x1a,%eax
    9bc5:	e8 fc ff ff ff       	call   9bc6 <MacBufferStatus_BSR_Info_copy+0x16>
	/*while(copy==0)//
	{
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
    9bca:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9bd0:	8b 52 02             	mov    0x2(%edx),%edx
    9bd3:	89 50 02             	mov    %edx,0x2(%eax)
	copy->m_rnti=SV(bsr)->m_rnti;
    9bd6:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9bdc:	0f b7 12             	movzwl (%edx),%edx
    9bdf:	66 89 10             	mov    %dx,(%eax)
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
    9be2:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9be8:	8b 52 06             	mov    0x6(%edx),%edx
    9beb:	89 50 06             	mov    %edx,0x6(%eax)
	for(j=0;j<LCG;j++)
    9bee:	31 d2                	xor    %edx,%edx
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
    9bf0:	8b 8b 54 01 00 00    	mov    0x154(%ebx),%ecx
    9bf6:	8b 4c 91 0a          	mov    0xa(%ecx,%edx,4),%ecx
    9bfa:	89 4c 90 0a          	mov    %ecx,0xa(%eax,%edx,4)
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
	copy->m_rnti=SV(bsr)->m_rnti;
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
	for(j=0;j<LCG;j++)
    9bfe:	83 c2 01             	add    $0x1,%edx
    9c01:	83 fa 04             	cmp    $0x4,%edx
    9c04:	75 ea                	jne    9bf0 <MacBufferStatus_BSR_Info_copy+0x40>
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
	FRET(copy);
}
    9c06:	5b                   	pop    %ebx
    9c07:	5d                   	pop    %ebp
    9c08:	c3                   	ret    
    9c09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009c10 <FlushBj>:
->Output:SV(LogicalChannel_Config)lcbj
->Special:lcbjMAX_BJ/8+1:
*******************************
*/
void FlushBj(void)
{
    9c10:	55                   	push   %ebp
    9c11:	89 e5                	mov    %esp,%ebp
    9c13:	57                   	push   %edi
    9c14:	56                   	push   %esi
    9c15:	53                   	push   %ebx
    9c16:	83 ec 04             	sub    $0x4,%esp
    9c19:	e8 fc ff ff ff       	call   9c1a <FlushBj+0xa>
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
    9c1e:	e8 fc ff ff ff       	call   9c1f <FlushBj+0xf>
    9c23:	89 c7                	mov    %eax,%edi
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9c25:	8b 80 44 01 00 00    	mov    0x144(%eax),%eax
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9c2b:	8b 70 05             	mov    0x5(%eax),%esi
{
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9c2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9c31:	83 ee 05             	sub    $0x5,%esi
    9c34:	39 f0                	cmp    %esi,%eax
    9c36:	74 63                	je     9c9b <FlushBj+0x8b>
	{
		temp_Bj_lcid=temp->lcid;
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9c38:	8b 8f 40 01 00 00    	mov    0x140(%edi),%ecx
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
	{
		temp_Bj_lcid=temp->lcid;
    9c3e:	0f b6 1e             	movzbl (%esi),%ebx
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9c41:	8b 51 11             	mov    0x11(%ecx),%edx
    9c44:	8d 42 ef             	lea    -0x11(%edx),%eax
    9c47:	39 c1                	cmp    %eax,%ecx
    9c49:	75 0f                	jne    9c5a <FlushBj+0x4a>
    9c4b:	eb 43                	jmp    9c90 <FlushBj+0x80>
    9c4d:	8d 76 00             	lea    0x0(%esi),%esi
    9c50:	8b 50 11             	mov    0x11(%eax),%edx
    9c53:	8d 42 ef             	lea    -0x11(%edx),%eax
    9c56:	39 c1                	cmp    %eax,%ecx
    9c58:	74 36                	je     9c90 <FlushBj+0x80>
		{
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
    9c5a:	38 5a ef             	cmp    %bl,-0x11(%edx)
    9c5d:	75 f1                	jne    9c50 <FlushBj+0x40>
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
    9c5f:	8b 50 05             	mov    0x5(%eax),%edx
    9c62:	83 fa ff             	cmp    $0xffffffff,%edx
    9c65:	74 49                	je     9cb0 <FlushBj+0xa0>
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9c67:	8b 40 09             	mov    0x9(%eax),%eax
					if(temp->lcbj < BucketSize)
    9c6a:	8b 4e 01             	mov    0x1(%esi),%ecx
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9c6d:	0f af c2             	imul   %edx,%eax
    9c70:	c1 e8 03             	shr    $0x3,%eax
					if(temp->lcbj < BucketSize)
    9c73:	0f b6 c0             	movzbl %al,%eax
    9c76:	39 c1                	cmp    %eax,%ecx
    9c78:	73 2e                	jae    9ca8 <FlushBj+0x98>
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
    9c7a:	85 d2                	test   %edx,%edx
    9c7c:	8d 42 07             	lea    0x7(%edx),%eax
    9c7f:	0f 48 d0             	cmovs  %eax,%edx
    9c82:	c1 fa 03             	sar    $0x3,%edx
    9c85:	01 ca                	add    %ecx,%edx
    9c87:	89 56 01             	mov    %edx,0x1(%esi)
    9c8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9c90:	8b 76 05             	mov    0x5(%esi),%esi
    9c93:	83 ee 05             	sub    $0x5,%esi
    9c96:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    9c99:	75 9d                	jne    9c38 <FlushBj+0x28>
		if(flag_tail==false)
			//fsm_printf("[UEMAC][FlushBj]FlushBj ERROR");//LogicalChannelConfigLogicalChannelConfigBj
		flag_tail=false;
	}
	FOUT;
}
    9c9b:	83 c4 04             	add    $0x4,%esp
    9c9e:	5b                   	pop    %ebx
    9c9f:	5e                   	pop    %esi
    9ca0:	5f                   	pop    %edi
    9ca1:	5d                   	pop    %ebp
    9ca2:	c3                   	ret    
    9ca3:	90                   	nop
    9ca4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
					if(temp->lcbj < BucketSize)
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
					else
						temp->lcbj=BucketSize;
    9ca8:	89 46 01             	mov    %eax,0x1(%esi)
    9cab:	eb e3                	jmp    9c90 <FlushBj+0x80>
    9cad:	8d 76 00             	lea    0x0(%esi),%esi
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
				{
					temp->lcbj=MAX_BJ/8+1;//1
    9cb0:	c7 46 01 01 7d 00 00 	movl   $0x7d01,0x1(%esi)
    9cb7:	eb d7                	jmp    9c90 <FlushBj+0x80>
    9cb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009cc0 <BufferSize2BsrSize>:
->Output:BufferSizeLevelBsrTableindex
->Special:
*******************************
*/
u32 BufferSize2BsrSize(u32 buffersize)
{
    9cc0:	55                   	push   %ebp
    9cc1:	89 e5                	mov    %esp,%ebp
    9cc3:	53                   	push   %ebx
    9cc4:	e8 fc ff ff ff       	call   9cc5 <BufferSize2BsrSize+0x5>
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
    9cc9:	31 d2                	xor    %edx,%edx
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9ccb:	85 c0                	test   %eax,%eax
    9ccd:	74 2b                	je     9cfa <BufferSize2BsrSize+0x3a>
    9ccf:	b2 01                	mov    $0x1,%dl
    9cd1:	31 c9                	xor    %ecx,%ecx
    9cd3:	eb 05                	jmp    9cda <BufferSize2BsrSize+0x1a>
    9cd5:	8d 76 00             	lea    0x0(%esi),%esi
    9cd8:	89 da                	mov    %ebx,%edx
			FRET(i);
		if(BufferSizeLevelBsrTable[i]< buffersize && BufferSizeLevelBsrTable[i+1]>= buffersize)
    9cda:	39 c8                	cmp    %ecx,%eax
    9cdc:	76 09                	jbe    9ce7 <BufferSize2BsrSize+0x27>
    9cde:	3b 04 95 40 33 00 00 	cmp    0x3340(,%edx,4),%eax
    9ce5:	76 13                	jbe    9cfa <BufferSize2BsrSize+0x3a>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
    9ce7:	83 fa 3f             	cmp    $0x3f,%edx
    9cea:	74 0e                	je     9cfa <BufferSize2BsrSize+0x3a>
    9cec:	8d 5a 01             	lea    0x1(%edx),%ebx
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9cef:	8b 0c 9d 3c 33 00 00 	mov    0x333c(,%ebx,4),%ecx
    9cf6:	39 c1                	cmp    %eax,%ecx
    9cf8:	75 de                	jne    9cd8 <BufferSize2BsrSize+0x18>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
			FRET(BSRTABLEINDEX-1);
	}
	FRET(-1);
}
    9cfa:	89 d0                	mov    %edx,%eax
    9cfc:	5b                   	pop    %ebx
    9cfd:	5d                   	pop    %ebp
    9cfe:	c3                   	ret    
    9cff:	90                   	nop

00009d00 <RefreshBufferStatusForBSR>:
->Output:SV(bsr)
->Special:
*******************************
*/
void RefreshBufferStatusForBSR(void)
{
    9d00:	55                   	push   %ebp
    9d01:	89 e5                	mov    %esp,%ebp
    9d03:	57                   	push   %edi
    9d04:	56                   	push   %esi
    9d05:	53                   	push   %ebx
    9d06:	83 ec 24             	sub    $0x24,%esp
    9d09:	e8 fc ff ff ff       	call   9d0a <RefreshBufferStatusForBSR+0xa>
	LogicalChannelConfigInfo *temp_lcc_info=NULL;
	MacBufferStatus *temp=NULL;
	struct list_head *pos1=NULL,*p1=NULL;
	struct list_head *pos=NULL,*p=NULL;
	u32 queue[LCG]={0,0,0,0};//LCG
    9d0e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    9d15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    9d1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    9d23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	u32 logicalchannelgroup;
	u32 i;
	bool flag_find=false;

	FIN(RefreshBufferStatusForBSR(void));
	SV_PTR_GET(rlc_mac_sv);
    9d2a:	e8 fc ff ff ff       	call   9d2b <RefreshBufferStatusForBSR+0x2b>
    9d2f:	89 c3                	mov    %eax,%ebx
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9d31:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9d37:	8d 50 05             	lea    0x5(%eax),%edx
    9d3a:	39 50 05             	cmp    %edx,0x5(%eax)
	{
		SV(bsr)->m_lcgnum=0;
    9d3d:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9d43:	0f 84 4e 01 00 00    	je     9e97 <RefreshBufferStatusForBSR+0x197>
	{
		SV(bsr)->m_lcgnum=0;
		//printk(KERN_INFO"No BSR report to transmit\n");
		FOUT;
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
    9d49:	0f b7 13             	movzwl (%ebx),%edx
    9d4c:	66 89 10             	mov    %dx,(%eax)
	SV(bsr)->m_lcgnum=0;
    9d4f:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9d55:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	SV(bsr)->m_TotalLcgData=0;		
    9d5c:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9d62:	c7 40 06 00 00 00 00 	movl   $0x0,0x6(%eax)
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9d69:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    9d6f:	8b 48 05             	mov    0x5(%eax),%ecx
    9d72:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9d75:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9d78:	31 c0                	xor    %eax,%eax
    9d7a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    9d7d:	8b 09                	mov    (%ecx),%ecx
    9d7f:	83 c2 05             	add    $0x5,%edx
    9d82:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    9d85:	0f 84 a1 00 00 00    	je     9e2c <RefreshBufferStatusForBSR+0x12c>
    9d8b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    9d8e:	89 cb                	mov    %ecx,%ebx
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9d90:	8b 45 d8             	mov    -0x28(%ebp),%eax
    9d93:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
    9d99:	8b 4e 11             	mov    0x11(%esi),%ecx
    9d9c:	83 c6 11             	add    $0x11,%esi
    9d9f:	8b 01                	mov    (%ecx),%eax
    9da1:	39 f1                	cmp    %esi,%ecx
    9da3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    9da6:	74 43                	je     9deb <RefreshBufferStatusForBSR+0xeb>
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9da8:	8b 51 fc             	mov    -0x4(%ecx),%edx
    9dab:	83 fa 03             	cmp    $0x3,%edx
    9dae:	77 52                	ja     9e02 <RefreshBufferStatusForBSR+0x102>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9db0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9db3:	0f b6 78 fb          	movzbl -0x5(%eax),%edi
    9db7:	89 f8                	mov    %edi,%eax
    9db9:	3a 41 ef             	cmp    -0x11(%ecx),%al
    9dbc:	0f 84 a8 00 00 00    	je     9e6a <RefreshBufferStatusForBSR+0x16a>
    9dc2:	89 fa                	mov    %edi,%edx
    9dc4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9dc7:	89 df                	mov    %ebx,%edi
    9dc9:	89 d3                	mov    %edx,%ebx
    9dcb:	eb 16                	jmp    9de3 <RefreshBufferStatusForBSR+0xe3>
    9dcd:	8d 76 00             	lea    0x0(%esi),%esi
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9dd0:	8b 50 fc             	mov    -0x4(%eax),%edx
    9dd3:	83 fa 03             	cmp    $0x3,%edx
    9dd6:	77 28                	ja     9e00 <RefreshBufferStatusForBSR+0x100>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9dd8:	38 58 ef             	cmp    %bl,-0x11(%eax)
    9ddb:	0f 84 87 00 00 00    	je     9e68 <RefreshBufferStatusForBSR+0x168>
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9de1:	89 c8                	mov    %ecx,%eax
    9de3:	39 c6                	cmp    %eax,%esi
    9de5:	8b 08                	mov    (%eax),%ecx
    9de7:	75 e7                	jne    9dd0 <RefreshBufferStatusForBSR+0xd0>
    9de9:	89 fb                	mov    %edi,%ebx
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9deb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9dee:	8b 13                	mov    (%ebx),%edx
    9df0:	83 c0 05             	add    $0x5,%eax
    9df3:	39 c3                	cmp    %eax,%ebx
    9df5:	74 2f                	je     9e26 <RefreshBufferStatusForBSR+0x126>
    9df7:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    9dfa:	89 d3                	mov    %edx,%ebx
    9dfc:	eb 92                	jmp    9d90 <RefreshBufferStatusForBSR+0x90>
    9dfe:	66 90                	xchg   %ax,%ax
    9e00:	89 fb                	mov    %edi,%ebx
					break;
				}
			}
			else
			{
				fsm_printf("[UEMAC][refreshBSR]:lc_group error\n");
    9e02:	c7 04 24 a8 2a 00 00 	movl   $0x2aa8,(%esp)
    9e09:	e8 fc ff ff ff       	call   9e0a <RefreshBufferStatusForBSR+0x10a>
    9e0e:	8b 45 d8             	mov    -0x28(%ebp),%eax
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9e11:	8b 13                	mov    (%ebx),%edx
    9e13:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9e19:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9e1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9e1f:	83 c0 05             	add    $0x5,%eax
    9e22:	39 c3                	cmp    %eax,%ebx
    9e24:	75 d1                	jne    9df7 <RefreshBufferStatusForBSR+0xf7>
    9e26:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    9e29:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9e2c:	31 f6                	xor    %esi,%esi
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
	{
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
    9e2e:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9e34:	01 42 06             	add    %eax,0x6(%edx)
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
    9e37:	8b bb 54 01 00 00    	mov    0x154(%ebx),%edi
    9e3d:	e8 fc ff ff ff       	call   9e3e <RefreshBufferStatusForBSR+0x13e>
    9e42:	89 44 b7 0a          	mov    %eax,0xa(%edi,%esi,4)
		if((SV(bsr)->m_bufferStatus[i])!=0)
    9e46:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9e4c:	8b 54 b0 0a          	mov    0xa(%eax,%esi,4),%edx
    9e50:	85 d2                	test   %edx,%edx
    9e52:	74 04                	je     9e58 <RefreshBufferStatusForBSR+0x158>
			SV(bsr)->m_lcgnum++;
    9e54:	83 40 02 01          	addl   $0x1,0x2(%eax)
		
		if(flag_find==false)
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
    9e58:	83 c6 01             	add    $0x1,%esi
    9e5b:	83 fe 04             	cmp    $0x4,%esi
    9e5e:	74 40                	je     9ea0 <RefreshBufferStatusForBSR+0x1a0>
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9e60:	8b 44 b5 e4          	mov    -0x1c(%ebp,%esi,4),%eax
    9e64:	eb c8                	jmp    9e2e <RefreshBufferStatusForBSR+0x12e>
    9e66:	66 90                	xchg   %ax,%ax
    9e68:	89 fb                	mov    %edi,%ebx
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
			{
				if(temp->lcid==temp_lcc_info->lcid)
				{
					logicalchannelgroup=temp_lcc_info->logicalChannelGroup;
					queue[logicalchannelgroup] =queue[logicalchannelgroup] + temp->RlcRequestparams->retxQueueHeader + temp->RlcRequestparams->retxQueueSize + temp->RlcRequestparams->statusPduHeader \
    9e6a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    9e6d:	8b 41 fc             	mov    -0x4(%ecx),%eax
    9e70:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
    9e74:	8b 48 03             	mov    0x3(%eax),%ecx
    9e77:	03 48 09             	add    0x9(%eax),%ecx
    9e7a:	01 f1                	add    %esi,%ecx
    9e7c:	0f b7 70 11          	movzwl 0x11(%eax),%esi
    9e80:	01 f1                	add    %esi,%ecx
					+ temp->RlcRequestparams->statusPduSize + temp->RlcRequestparams->txQueueHeader + temp->RlcRequestparams->txQueueSize;
    9e82:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    9e86:	0f b7 40 07          	movzwl 0x7(%eax),%eax
    9e8a:	01 f1                	add    %esi,%ecx
    9e8c:	01 c1                	add    %eax,%ecx
    9e8e:	01 4c 95 e4          	add    %ecx,-0x1c(%ebp,%edx,4)
					flag_find=true;
					break;
    9e92:	e9 54 ff ff ff       	jmp    9deb <RefreshBufferStatusForBSR+0xeb>
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
	{
		SV(bsr)->m_lcgnum=0;
    9e97:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
    9e9e:	66 90                	xchg   %ax,%ax
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
		if((SV(bsr)->m_bufferStatus[i])!=0)
			SV(bsr)->m_lcgnum++;
	}
}
    9ea0:	83 c4 24             	add    $0x24,%esp
    9ea3:	5b                   	pop    %ebx
    9ea4:	5e                   	pop    %esi
    9ea5:	5f                   	pop    %edi
    9ea6:	5d                   	pop    %ebp
    9ea7:	c3                   	ret    
    9ea8:	90                   	nop
    9ea9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009eb0 <GetTBsize_Allocation>:
->Output:
->Special:
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
    9eb0:	55                   	push   %ebp
    9eb1:	89 e5                	mov    %esp,%ebp
    9eb3:	83 ec 08             	sub    $0x8,%esp
    9eb6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    9eb9:	89 75 fc             	mov    %esi,-0x4(%ebp)
    9ebc:	e8 fc ff ff ff       	call   9ebd <GetTBsize_Allocation+0xd>
    9ec1:	89 c3                	mov    %eax,%ebx
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    9ec3:	e8 fc ff ff ff       	call   9ec4 <GetTBsize_Allocation+0x14>
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    9ec8:	c1 eb 03             	shr    $0x3,%ebx
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    9ecb:	89 c6                	mov    %eax,%esi
	RefreshBufferStatusForBSR();
    9ecd:	e8 fc ff ff ff       	call   9ece <GetTBsize_Allocation+0x1e>
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    9ed2:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
    9ed8:	3b 58 06             	cmp    0x6(%eax),%ebx
    9edb:	72 13                	jb     9ef0 <GetTBsize_Allocation+0x40>
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
	}
	else
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
    9edd:	c6 86 59 01 00 00 00 	movb   $0x0,0x159(%esi)
		FRET((tbsize)/8);
	}
}
    9ee4:	89 d8                	mov    %ebx,%eax
    9ee6:	8b 75 fc             	mov    -0x4(%ebp),%esi
    9ee9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    9eec:	89 ec                	mov    %ebp,%esp
    9eee:	5d                   	pop    %ebp
    9eef:	c3                   	ret    
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=true;
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
    9ef0:	83 eb 04             	sub    $0x4,%ebx
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
		FRET((tbsize)/8);
	}
}
    9ef3:	8b 75 fc             	mov    -0x4(%ebp),%esi
    9ef6:	89 d8                	mov    %ebx,%eax
    9ef8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    9efb:	89 ec                	mov    %ebp,%esp
    9efd:	5d                   	pop    %ebp
    9efe:	c3                   	ret    
    9eff:	90                   	nop

00009f00 <DoRefreshRLCBuffserRequest>:
->Output:SV(MacBuffer_RLC) :MAC
->Special:
*******************************
*/
void DoRefreshRLCBuffserRequest (RlcBufferRequest* params)	//
{
    9f00:	55                   	push   %ebp
    9f01:	89 e5                	mov    %esp,%ebp
    9f03:	57                   	push   %edi
    9f04:	56                   	push   %esi
    9f05:	53                   	push   %ebx
    9f06:	83 ec 14             	sub    $0x14,%esp
    9f09:	e8 fc ff ff ff       	call   9f0a <DoRefreshRLCBuffserRequest+0xa>
    9f0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos,*p;
	u8 temp_lcid,temp_mac_bufferstatus_lcid;
	FIN(DoRefreshRLCBuffserRequest(RlcBufferRequest* params));
	
	SV_PTR_GET(rlc_mac_sv);
    9f11:	e8 fc ff ff ff       	call   9f12 <DoRefreshRLCBuffserRequest+0x12>
    9f16:	89 45 f0             	mov    %eax,-0x10(%ebp)
	MacBufferStatus *temp_mac_bufferstatus=NULL;
	MacBufferStatus *temp_mac_findno=NULL;	
	bool flag=false;

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
    9f19:	e8 fc ff ff ff       	call   9f1a <DoRefreshRLCBuffserRequest+0x1a>
	if (SV(bsr)->m_lcgnum==0)
    9f1e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f21:	8b 82 54 01 00 00    	mov    0x154(%edx),%eax
    9f27:	8b 48 02             	mov    0x2(%eax),%ecx
    9f2a:	85 c9                	test   %ecx,%ecx
    9f2c:	75 07                	jne    9f35 <DoRefreshRLCBuffserRequest+0x35>
		SV(LCGZeroToData)=true;
    9f2e:	c6 82 58 01 00 00 01 	movb   $0x1,0x158(%edx)
	SV(DATA_WAIT_ALLOCATION)=true;
    9f35:	8b 45 f0             	mov    -0x10(%ebp),%eax
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f38:	8b 55 e4             	mov    -0x1c(%ebp),%edx

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
    9f3b:	c6 80 5a 01 00 00 01 	movb   $0x1,0x15a(%eax)
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f42:	8b 42 13             	mov    0x13(%edx),%eax
    9f45:	83 c2 13             	add    $0x13,%edx
    9f48:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9f4b:	39 d0                	cmp    %edx,%eax
    9f4d:	8b 38                	mov    (%eax),%edi
    9f4f:	0f 84 ea 00 00 00    	je     a03f <DoRefreshRLCBuffserRequest+0x13f>
    9f55:	8d 76 00             	lea    0x0(%esi),%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    9f58:	8d 48 ed             	lea    -0x13(%eax),%ecx
		temp_lcid=temp->lcid;
    9f5b:	0f b6 58 ef          	movzbl -0x11(%eax),%ebx
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    9f5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    9f62:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		temp_lcid=temp->lcid;
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    9f65:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    9f6b:	8b 42 05             	mov    0x5(%edx),%eax
    9f6e:	8d 70 fb             	lea    -0x5(%eax),%esi
    9f71:	39 f2                	cmp    %esi,%edx
    9f73:	75 0d                	jne    9f82 <DoRefreshRLCBuffserRequest+0x82>
    9f75:	eb 39                	jmp    9fb0 <DoRefreshRLCBuffserRequest+0xb0>
    9f77:	90                   	nop
    9f78:	8b 46 05             	mov    0x5(%esi),%eax
    9f7b:	8d 70 fb             	lea    -0x5(%eax),%esi
    9f7e:	39 f2                	cmp    %esi,%edx
    9f80:	74 2e                	je     9fb0 <DoRefreshRLCBuffserRequest+0xb0>
		{
			temp_mac_bufferstatus_lcid=temp_mac_bufferstatus->lcid;
			if(temp_lcid==temp_mac_bufferstatus_lcid)
    9f82:	3a 58 fb             	cmp    -0x5(%eax),%bl
    9f85:	75 f1                	jne    9f78 <DoRefreshRLCBuffserRequest+0x78>
			{
				temp_mac_bufferstatus->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9f87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9f8a:	e8 fc ff ff ff       	call   9f8b <DoRefreshRLCBuffserRequest+0x8b>
    9f8f:	89 46 01             	mov    %eax,0x1(%esi)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    9f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f95:	39 7d e8             	cmp    %edi,-0x18(%ebp)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    9f98:	c6 80 59 01 00 00 01 	movb   $0x1,0x159(%eax)
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    9f9f:	8b 17                	mov    (%edi),%edx
    9fa1:	74 65                	je     a008 <DoRefreshRLCBuffserRequest+0x108>
    9fa3:	89 f8                	mov    %edi,%eax
    9fa5:	89 d7                	mov    %edx,%edi
    9fa7:	eb af                	jmp    9f58 <DoRefreshRLCBuffserRequest+0x58>
    9fa9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9fb0:	b8 0d 00 00 00       	mov    $0xd,%eax
    9fb5:	e8 fc ff ff ff       	call   9fb6 <DoRefreshRLCBuffserRequest+0xb6>
			while(temp_mac_findno==0)//
    9fba:	85 c0                	test   %eax,%eax
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9fbc:	89 c6                	mov    %eax,%esi
			while(temp_mac_findno==0)//
    9fbe:	75 10                	jne    9fd0 <DoRefreshRLCBuffserRequest+0xd0>
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9fc0:	b8 0d 00 00 00       	mov    $0xd,%eax
    9fc5:	e8 fc ff ff ff       	call   9fc6 <DoRefreshRLCBuffserRequest+0xc6>
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
    9fca:	85 c0                	test   %eax,%eax
    9fcc:	74 f2                	je     9fc0 <DoRefreshRLCBuffserRequest+0xc0>
    9fce:	89 c6                	mov    %eax,%esi
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9fd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
    9fd3:	8d 56 05             	lea    0x5(%esi),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9fd6:	89 56 05             	mov    %edx,0x5(%esi)
	list->prev = list;
    9fd9:	89 56 09             	mov    %edx,0x9(%esi)
			temp_mac_findno->lcid=temp_lcid;
    9fdc:	88 1e                	mov    %bl,(%esi)
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9fde:	89 55 e0             	mov    %edx,-0x20(%ebp)
    9fe1:	e8 fc ff ff ff       	call   9fe2 <DoRefreshRLCBuffserRequest+0xe2>
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    9fe6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    9fe9:	89 46 01             	mov    %eax,0x1(%esi)
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    9fec:	8b 81 48 01 00 00    	mov    0x148(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9ff2:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9ff5:	8b 48 09             	mov    0x9(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9ff8:	89 50 09             	mov    %edx,0x9(%eax)
    9ffb:	83 c0 05             	add    $0x5,%eax
    9ffe:	89 46 05             	mov    %eax,0x5(%esi)
	new->next = next;
	new->prev = prev;
    a001:	89 4e 09             	mov    %ecx,0x9(%esi)
	prev->next = new;
    a004:	89 11                	mov    %edx,(%ecx)
    a006:	eb 8a                	jmp    9f92 <DoRefreshRLCBuffserRequest+0x92>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a008:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a00b:	8b 50 13             	mov    0x13(%eax),%edx
    a00e:	3b 55 e8             	cmp    -0x18(%ebp),%edx
    a011:	8b 1a                	mov    (%edx),%ebx
    a013:	74 2a                	je     a03f <DoRefreshRLCBuffserRequest+0x13f>
    a015:	89 d9                	mov    %ebx,%ecx
    a017:	8b 75 e8             	mov    -0x18(%ebp),%esi
    a01a:	eb 08                	jmp    a024 <DoRefreshRLCBuffserRequest+0x124>
    a01c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a020:	89 da                	mov    %ebx,%edx
    a022:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a024:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    a027:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a02a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a02d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a02f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a031:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);
    a034:	e8 fc ff ff ff       	call   a035 <DoRefreshRLCBuffserRequest+0x135>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a039:	39 f3                	cmp    %esi,%ebx
    a03b:	8b 0b                	mov    (%ebx),%ecx
    a03d:	75 e1                	jne    a020 <DoRefreshRLCBuffserRequest+0x120>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);
	}
	fsm_mem_free(RLChead);
    a03f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a042:	e8 fc ff ff ff       	call   a043 <DoRefreshRLCBuffserRequest+0x143>
	FOUT;
}
    a047:	83 c4 14             	add    $0x14,%esp
    a04a:	5b                   	pop    %ebx
    a04b:	5e                   	pop    %esi
    a04c:	5f                   	pop    %edi
    a04d:	5d                   	pop    %ebp
    a04e:	c3                   	ret    
    a04f:	90                   	nop

0000a050 <LogicalChannel_ConfigInfo_Rank_Priority>:
->Output:LogicalChannelConfigInfo 
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_Rank_Priority()
{
    a050:	55                   	push   %ebp
    a051:	89 e5                	mov    %esp,%ebp
    a053:	57                   	push   %edi
    a054:	56                   	push   %esi
    a055:	53                   	push   %ebx
    a056:	83 ec 0c             	sub    $0xc,%esp
    a059:	e8 fc ff ff ff       	call   a05a <LogicalChannel_ConfigInfo_Rank_Priority+0xa>
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
    a05e:	e8 fc ff ff ff       	call   a05f <LogicalChannel_ConfigInfo_Rank_Priority+0xf>
    a063:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a066:	b8 19 00 00 00       	mov    $0x19,%eax
    a06b:	e8 fc ff ff ff       	call   a06c <LogicalChannel_ConfigInfo_Rank_Priority+0x1c>
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a070:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a073:	8d 50 11             	lea    0x11(%eax),%edx
{
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a076:	89 c3                	mov    %eax,%ebx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a078:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a07b:	89 50 15             	mov    %edx,0x15(%eax)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a07e:	8b 81 40 01 00 00    	mov    0x140(%ecx),%eax
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a084:	89 55 ec             	mov    %edx,-0x14(%ebp)
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a087:	8b 70 11             	mov    0x11(%eax),%esi
    a08a:	83 ee 11             	sub    $0x11,%esi
    a08d:	39 f0                	cmp    %esi,%eax
    a08f:	0f 84 7f 00 00 00    	je     a114 <LogicalChannel_ConfigInfo_Rank_Priority+0xc4>
    a095:	8d 76 00             	lea    0x0(%esi),%esi
	{
		next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a098:	b8 19 00 00 00       	mov    $0x19,%eax
    a09d:	e8 fc ff ff ff       	call   a09e <LogicalChannel_ConfigInfo_Rank_Priority+0x4e>
		/*while(next_node==0)//
		{
			next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
		}*/
		next_node->lcid=temp->lcid;
    a0a2:	0f b6 16             	movzbl (%esi),%edx
    a0a5:	88 10                	mov    %dl,(%eax)
		next_node->priority=temp->priority;
    a0a7:	8b 7e 01             	mov    0x1(%esi),%edi
    a0aa:	89 78 01             	mov    %edi,0x1(%eax)
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
    a0ad:	8b 56 05             	mov    0x5(%esi),%edx
    a0b0:	89 50 05             	mov    %edx,0x5(%eax)
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
    a0b3:	8b 56 09             	mov    0x9(%esi),%edx
    a0b6:	89 50 09             	mov    %edx,0x9(%eax)
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
    a0b9:	8b 56 0d             	mov    0xd(%esi),%edx
    a0bc:	89 50 0d             	mov    %edx,0xd(%eax)
		INIT_LIST_HEAD(&(next_node->list));
    a0bf:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a0c2:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a0c5:	89 50 15             	mov    %edx,0x15(%eax)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    a0c8:	8b 4b 11             	mov    0x11(%ebx),%ecx
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a0cb:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
		next_node->lcid=temp->lcid;
		next_node->priority=temp->priority;
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
		INIT_LIST_HEAD(&(next_node->list));
    a0ce:	89 55 f0             	mov    %edx,-0x10(%ebp)
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a0d1:	74 4d                	je     a120 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			else
			{
				flag_add=false;
				list_for_each_entry(temp_next, &(lcc_info_priority->list),list)//
    a0d3:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a0d6:	39 d3                	cmp    %edx,%ebx
    a0d8:	75 10                	jne    a0ea <LogicalChannel_ConfigInfo_Rank_Priority+0x9a>
    a0da:	eb 44                	jmp    a120 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
    a0dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a0e0:	8b 4a 11             	mov    0x11(%edx),%ecx
    a0e3:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a0e6:	39 d3                	cmp    %edx,%ebx
    a0e8:	74 36                	je     a120 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				{
					//  if(temp_next->prioritizedBitRateKbps==-1)
						//  continue;
					if ((next_node->priority) <= (temp_next->priority))
    a0ea:	3b 79 f0             	cmp    -0x10(%ecx),%edi
    a0ed:	7f f1                	jg     a0e0 <LogicalChannel_ConfigInfo_Rank_Priority+0x90>
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a0ef:	8b 7d f0             	mov    -0x10(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a0f2:	8b 4a 15             	mov    0x15(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a0f5:	89 7a 15             	mov    %edi,0x15(%edx)
					{
						list_add_tail(&(next_node->list), &(temp_next->list));
    a0f8:	83 c2 11             	add    $0x11,%edx
    a0fb:	89 50 11             	mov    %edx,0x11(%eax)
	new->next = next;
	new->prev = prev;
    a0fe:	89 48 15             	mov    %ecx,0x15(%eax)
	prev->next = new;
    a101:	89 39                	mov    %edi,(%ecx)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a103:	8b 76 11             	mov    0x11(%esi),%esi
    a106:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a109:	83 ee 11             	sub    $0x11,%esi
    a10c:	39 b0 40 01 00 00    	cmp    %esi,0x140(%eax)
    a112:	75 84                	jne    a098 <LogicalChannel_ConfigInfo_Rank_Priority+0x48>
					list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			}

	}
	FRET(lcc_info_priority);
}
    a114:	83 c4 0c             	add    $0xc,%esp
    a117:	89 d8                	mov    %ebx,%eax
    a119:	5b                   	pop    %ebx
    a11a:	5e                   	pop    %esi
    a11b:	5f                   	pop    %edi
    a11c:	5d                   	pop    %ebp
    a11d:	c3                   	ret    
    a11e:	66 90                	xchg   %ax,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a120:	8b 53 15             	mov    0x15(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a123:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	new->next = next;
    a126:	8b 7d ec             	mov    -0x14(%ebp),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a129:	89 4b 15             	mov    %ecx,0x15(%ebx)
	new->next = next;
    a12c:	89 78 11             	mov    %edi,0x11(%eax)
	new->prev = prev;
    a12f:	89 50 15             	mov    %edx,0x15(%eax)
	prev->next = new;
    a132:	89 0a                	mov    %ecx,(%edx)
    a134:	eb cd                	jmp    a103 <LogicalChannel_ConfigInfo_Rank_Priority+0xb3>
    a136:	8d 76 00             	lea    0x0(%esi),%esi
    a139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a140 <PrioritySort>:
->Output:MacBufferStatus *:SV(MacBuffer_RLC)
->Special:
*******************************
*/
MacBufferStatus* PrioritySort(void)
{
    a140:	55                   	push   %ebp
    a141:	89 e5                	mov    %esp,%ebp
    a143:	57                   	push   %edi
    a144:	56                   	push   %esi
    a145:	53                   	push   %ebx
    a146:	83 ec 14             	sub    $0x14,%esp
    a149:	e8 fc ff ff ff       	call   a14a <PrioritySort+0xa>
	u8 temp_Bj_lcid;
	MacBufferStatus *temp_node;
	struct list_head *pos,*p;

	FIN(PrioritySort(void));
	SV_PTR_GET(rlc_mac_sv);
    a14e:	e8 fc ff ff ff       	call   a14f <PrioritySort+0xf>
    a153:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *Priority_logicalChannel=NULL,*temp_logicalChannel=NULL;
	MacBufferStatus *PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus)),*temp_mbs=NULL;
    a156:	b8 0d 00 00 00       	mov    $0xd,%eax
    a15b:	e8 fc ff ff ff       	call   a15c <PrioritySort+0x1c>
    a160:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a163:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(PriorityMacBufferStatus==0)//
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
    a166:	83 c0 05             	add    $0x5,%eax
    a169:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a16c:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    a16f:	89 42 09             	mov    %eax,0x9(%edx)
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a172:	e8 fc ff ff ff       	call   a173 <PrioritySort+0x33>
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a177:	8b 50 11             	mov    0x11(%eax),%edx
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a17a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a17d:	8d 72 ef             	lea    -0x11(%edx),%esi
    a180:	39 f0                	cmp    %esi,%eax
    a182:	74 7b                	je     a1ff <PrioritySort+0xbf>
    a184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a188:	8b 45 e8             	mov    -0x18(%ebp),%eax
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
    a18b:	0f b6 0e             	movzbl (%esi),%ecx
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a18e:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a194:	8b 42 05             	mov    0x5(%edx),%eax
    a197:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a19a:	39 da                	cmp    %ebx,%edx
    a19c:	75 0c                	jne    a1aa <PrioritySort+0x6a>
    a19e:	eb 4e                	jmp    a1ee <PrioritySort+0xae>
    a1a0:	8b 43 05             	mov    0x5(%ebx),%eax
    a1a3:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a1a6:	39 da                	cmp    %ebx,%edx
    a1a8:	74 44                	je     a1ee <PrioritySort+0xae>
		{
			if(temp_Bj_lcid==temp_node->lcid)
    a1aa:	38 48 fb             	cmp    %cl,-0x5(%eax)
    a1ad:	75 f1                	jne    a1a0 <PrioritySort+0x60>
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a1af:	b8 0d 00 00 00       	mov    $0xd,%eax
    a1b4:	e8 fc ff ff ff       	call   a1b5 <PrioritySort+0x75>
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
    a1b9:	8d 50 05             	lea    0x5(%eax),%edx
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
		{
			if(temp_Bj_lcid==temp_node->lcid)
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a1bc:	89 c7                	mov    %eax,%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a1be:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a1c1:	89 50 09             	mov    %edx,0x9(%eax)
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
				temp_mbs->lcid=temp_node->lcid;
    a1c4:	0f b6 03             	movzbl (%ebx),%eax
    a1c7:	88 07                	mov    %al,(%edi)
				temp_mbs->RlcRequestparams=Mac_MacRequest_copy(temp_node->RlcRequestparams);
    a1c9:	8b 43 01             	mov    0x1(%ebx),%eax
    a1cc:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a1cf:	e8 fc ff ff ff       	call   a1d0 <PrioritySort+0x90>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a1d4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a1d7:	89 47 01             	mov    %eax,0x1(%edi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a1da:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a1dd:	8b 41 09             	mov    0x9(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a1e0:	89 51 09             	mov    %edx,0x9(%ecx)
	new->next = next;
    a1e3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	new->prev = prev;
    a1e6:	89 47 09             	mov    %eax,0x9(%edi)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    a1e9:	89 4f 05             	mov    %ecx,0x5(%edi)
	new->prev = prev;
	prev->next = new;
    a1ec:	89 10                	mov    %edx,(%eax)
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a1ee:	8b 76 11             	mov    0x11(%esi),%esi
    a1f1:	83 ee 11             	sub    $0x11,%esi
    a1f4:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a1f7:	75 8f                	jne    a188 <PrioritySort+0x48>
    a1f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a1fc:	8b 50 11             	mov    0x11(%eax),%edx
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a1ff:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a202:	8b 1a                	mov    (%edx),%ebx
    a204:	83 c6 11             	add    $0x11,%esi
    a207:	39 f2                	cmp    %esi,%edx
    a209:	89 d9                	mov    %ebx,%ecx
    a20b:	75 07                	jne    a214 <PrioritySort+0xd4>
    a20d:	eb 20                	jmp    a22f <PrioritySort+0xef>
    a20f:	90                   	nop
    a210:	89 da                	mov    %ebx,%edx
    a212:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a214:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
    a217:	8d 42 ef             	lea    -0x11(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a21a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a21d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a21f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a221:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp_logicalChannel);//
    a224:	e8 fc ff ff ff       	call   a225 <PrioritySort+0xe5>
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a229:	39 de                	cmp    %ebx,%esi
    a22b:	8b 0b                	mov    (%ebx),%ecx
    a22d:	75 e1                	jne    a210 <PrioritySort+0xd0>
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
		fsm_mem_free(temp_logicalChannel);//
	}
	fsm_mem_free(Priority_logicalChannel);
    a22f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a232:	e8 fc ff ff ff       	call   a233 <PrioritySort+0xf3>
	FRET(PriorityMacBufferStatus);
}
    a237:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a23a:	83 c4 14             	add    $0x14,%esp
    a23d:	5b                   	pop    %ebx
    a23e:	5e                   	pop    %esi
    a23f:	5f                   	pop    %edi
    a240:	5d                   	pop    %ebp
    a241:	c3                   	ret    
    a242:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    a249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a250 <DoProduceBsr_LCGZeroToData>:
->Output: SV(Regularbsr) :BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
    a250:	55                   	push   %ebp
    a251:	89 e5                	mov    %esp,%ebp
    a253:	53                   	push   %ebx
    a254:	e8 fc ff ff ff       	call   a255 <DoProduceBsr_LCGZeroToData+0x5>
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a259:	e8 fc ff ff ff       	call   a25a <DoProduceBsr_LCGZeroToData+0xa>
	if(SV(LCGZeroToData) == true)
    a25e:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a265:	89 c3                	mov    %eax,%ebx
	if(SV(LCGZeroToData) == true)
    a267:	75 0f                	jne    a278 <DoProduceBsr_LCGZeroToData+0x28>
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a269:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a270:	5b                   	pop    %ebx
    a271:	5d                   	pop    %ebp
    a272:	c3                   	ret    
    a273:	90                   	nop
    a274:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(LCGZeroToData) == true)
	{
		RefreshBufferStatusForBSR();
    a278:	e8 fc ff ff ff       	call   a279 <DoProduceBsr_LCGZeroToData+0x29>
		if (SV(bsr)!=NULL)
    a27d:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a283:	85 c0                	test   %eax,%eax
    a285:	74 e2                	je     a269 <DoProduceBsr_LCGZeroToData+0x19>
		{
			//fsm_printf("[UEMAC][BSR]have BSR\n");
			if(SV(Regularbsr)!=NULL)
    a287:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a28d:	85 c0                	test   %eax,%eax
    a28f:	74 0f                	je     a2a0 <DoProduceBsr_LCGZeroToData+0x50>
			{
				fsm_mem_free(SV(Regularbsr));//Regularbsr
    a291:	e8 fc ff ff ff       	call   a292 <DoProduceBsr_LCGZeroToData+0x42>
				SV(Regularbsr)=NULL;
    a296:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a29d:	00 00 00 
			}
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a2a0:	e8 fc ff ff ff       	call   a2a1 <DoProduceBsr_LCGZeroToData+0x51>
    a2a5:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
			if((SV(Regularbsr)->m_lcgnum) >1)
    a2ab:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a2af:	76 1f                	jbe    a2d0 <DoProduceBsr_LCGZeroToData+0x80>
			{
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a2b1:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a2b8:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a2bf:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a2c5:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a2cc:	5b                   	pop    %ebx
    a2cd:	5d                   	pop    %ebp
    a2ce:	c3                   	ret    
    a2cf:	90                   	nop
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR long:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
			else if((SV(Regularbsr)->m_lcgnum) ==1)
    a2d0:	75 97                	jne    a269 <DoProduceBsr_LCGZeroToData+0x19>
			{
				SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a2d2:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a2d9:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a2e0:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
    a2e6:	eb 81                	jmp    a269 <DoProduceBsr_LCGZeroToData+0x19>
    a2e8:	90                   	nop
    a2e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a2f0 <DoProduceBsr_PeriodicBSRTimer>:
->Output: SV(Periodicbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
    a2f0:	55                   	push   %ebp
    a2f1:	89 e5                	mov    %esp,%ebp
    a2f3:	53                   	push   %ebx
    a2f4:	e8 fc ff ff ff       	call   a2f5 <DoProduceBsr_PeriodicBSRTimer+0x5>
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a2f9:	e8 fc ff ff ff       	call   a2fa <DoProduceBsr_PeriodicBSRTimer+0xa>
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a2fe:	80 b8 59 01 00 00 00 	cmpb   $0x0,0x159(%eax)
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a305:	89 c3                	mov    %eax,%ebx
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a307:	75 07                	jne    a310 <DoProduceBsr_PeriodicBSRTimer+0x20>
			}
		}
		SV(m_freshUlBsr)=false;
	}
	FOUT;
}
    a309:	5b                   	pop    %ebx
    a30a:	5d                   	pop    %ebp
    a30b:	c3                   	ret    
    a30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
	{
		RefreshBufferStatusForBSR ();
    a310:	e8 fc ff ff ff       	call   a311 <DoProduceBsr_PeriodicBSRTimer+0x21>
		if (SV(bsr)!=NULL)
    a315:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a31b:	85 c0                	test   %eax,%eax
    a31d:	74 34                	je     a353 <DoProduceBsr_PeriodicBSRTimer+0x63>
		{
			if(SV(Periodicbsr)==NULL)
    a31f:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a325:	85 c0                	test   %eax,%eax
    a327:	74 05                	je     a32e <DoProduceBsr_PeriodicBSRTimer+0x3e>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();
			else
			{
				fsm_mem_free(SV(Periodicbsr));//Regularbsr
    a329:	e8 fc ff ff ff       	call   a32a <DoProduceBsr_PeriodicBSRTimer+0x3a>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();//
    a32e:	e8 fc ff ff ff       	call   a32f <DoProduceBsr_PeriodicBSRTimer+0x3f>
    a333:	89 83 50 01 00 00    	mov    %eax,0x150(%ebx)
			}
			// if(SV(ALLOCATION_RESOURCE_BSR_INFO)==true)
			// {
			if((SV(Periodicbsr)->m_lcgnum) >1)
    a339:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a33d:	76 21                	jbe    a360 <DoProduceBsr_PeriodicBSRTimer+0x70>
			{
				SV(MAC_CE_Tags)[period_longBSR_CE].addinPDU_flag=true;
    a33f:	c6 83 dc 01 00 00 01 	movb   $0x1,0x1dc(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
    a346:	c6 83 dd 01 00 00 1e 	movb   $0x1e,0x1dd(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a34d:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
		}
		SV(m_freshUlBsr)=false;
    a353:	c6 83 59 01 00 00 00 	movb   $0x0,0x159(%ebx)
	}
	FOUT;
}
    a35a:	5b                   	pop    %ebx
    a35b:	5d                   	pop    %ebp
    a35c:	c3                   	ret    
    a35d:	8d 76 00             	lea    0x0(%esi),%esi
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
			else
			{
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
    a360:	c6 83 d4 01 00 00 01 	movb   $0x1,0x1d4(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a367:	c6 83 d5 01 00 00 1d 	movb   $0x1d,0x1d5(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a36e:	89 83 d8 01 00 00    	mov    %eax,0x1d8(%ebx)
    a374:	eb dd                	jmp    a353 <DoProduceBsr_PeriodicBSRTimer+0x63>
    a376:	8d 76 00             	lea    0x0(%esi),%esi
    a379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a380 <DoProduceBsr_RetxBSRTimer>:
->Output: SV(Regularbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_RetxBSRTimer(void)
{
    a380:	55                   	push   %ebp
    a381:	89 e5                	mov    %esp,%ebp
    a383:	53                   	push   %ebx
    a384:	e8 fc ff ff ff       	call   a385 <DoProduceBsr_RetxBSRTimer+0x5>
	FIN(DoProduceBsr_RetxBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a389:	e8 fc ff ff ff       	call   a38a <DoProduceBsr_RetxBSRTimer+0xa>
    a38e:	89 c3                	mov    %eax,%ebx
	if(list_empty((&(SV(MacBuffer_RLC)->list))))//BSRTTI BSR
    a390:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    a396:	8d 50 05             	lea    0x5(%eax),%edx
    a399:	39 50 05             	cmp    %edx,0x5(%eax)
    a39c:	74 43                	je     a3e1 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		FOUT;
	}
	RefreshBufferStatusForBSR ();
    a39e:	e8 fc ff ff ff       	call   a39f <DoProduceBsr_RetxBSRTimer+0x1f>
	if (SV(bsr)!=NULL)
    a3a3:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a3a9:	85 c0                	test   %eax,%eax
    a3ab:	74 34                	je     a3e1 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		if(SV(Regularbsr)==NULL)//Regularbsr
    a3ad:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a3b3:	85 c0                	test   %eax,%eax
    a3b5:	74 05                	je     a3bc <DoProduceBsr_RetxBSRTimer+0x3c>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();
		else
		{
			fsm_mem_free(SV(Regularbsr));//Regularbsr
    a3b7:	e8 fc ff ff ff       	call   a3b8 <DoProduceBsr_RetxBSRTimer+0x38>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a3bc:	e8 fc ff ff ff       	call   a3bd <DoProduceBsr_RetxBSRTimer+0x3d>
    a3c1:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
		}
		if((SV(Regularbsr)->m_lcgnum) >1)
    a3c7:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a3cb:	76 1b                	jbe    a3e8 <DoProduceBsr_RetxBSRTimer+0x68>
		{
			SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a3cd:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a3d4:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a3db:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
	}
	FOUT;
}
    a3e1:	5b                   	pop    %ebx
    a3e2:	5d                   	pop    %ebp
    a3e3:	c3                   	ret    
    a3e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
		else
		{
			SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a3e8:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a3ef:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a3f6:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
		}
	}
	FOUT;
}
    a3fc:	5b                   	pop    %ebx
    a3fd:	5d                   	pop    %ebp
    a3fe:	c3                   	ret    
    a3ff:	90                   	nop

0000a400 <Free_Bsr_Info>:
->Output: 
->Special:
*******************************
*/
void Free_Bsr_Info(void)
{
    a400:	55                   	push   %ebp
    a401:	89 e5                	mov    %esp,%ebp
    a403:	53                   	push   %ebx
    a404:	e8 fc ff ff ff       	call   a405 <Free_Bsr_Info+0x5>
	FIN(Free_Bsr_Info(void));
	SV_PTR_GET(rlc_mac_sv);
    a409:	e8 fc ff ff ff       	call   a40a <Free_Bsr_Info+0xa>
    a40e:	89 c3                	mov    %eax,%ebx
	if(SV(Regularbsr)!=NULL)
    a410:	8b 80 4c 01 00 00    	mov    0x14c(%eax),%eax
    a416:	85 c0                	test   %eax,%eax
    a418:	74 0f                	je     a429 <Free_Bsr_Info+0x29>
	{
		fsm_mem_free(SV(Regularbsr));
    a41a:	e8 fc ff ff ff       	call   a41b <Free_Bsr_Info+0x1b>
		SV(Regularbsr)=NULL;
    a41f:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a426:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    a429:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a42f:	85 c0                	test   %eax,%eax
    a431:	74 0f                	je     a442 <Free_Bsr_Info+0x42>
	{
		fsm_mem_free(SV(Periodicbsr));
    a433:	e8 fc ff ff ff       	call   a434 <Free_Bsr_Info+0x34>
		SV(Periodicbsr)=NULL;
    a438:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    a43f:	00 00 00 
	}
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    a442:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a448:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    a44d:	31 d2                	xor    %edx,%edx
    a44f:	e8 fc ff ff ff       	call   a450 <Free_Bsr_Info+0x50>
	FOUT;
}
    a454:	5b                   	pop    %ebx
    a455:	5d                   	pop    %ebp
    a456:	c3                   	ret    
    a457:	89 f6                	mov    %esi,%esi
    a459:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a460 <Zero_LogicalChannel_Bj_Reset>:
->Output: SV(LogicalChannel_Bj)lcbj0
->Special:
*******************************
*/
void Zero_LogicalChannel_Bj_Reset()
{
    a460:	55                   	push   %ebp
    a461:	89 e5                	mov    %esp,%ebp
    a463:	56                   	push   %esi
    a464:	53                   	push   %ebx
    a465:	e8 fc ff ff ff       	call   a466 <Zero_LogicalChannel_Bj_Reset+0x6>
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
    a46a:	e8 fc ff ff ff       	call   a46b <Zero_LogicalChannel_Bj_Reset+0xb>
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a46f:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
    a475:	8b 4b 05             	mov    0x5(%ebx),%ecx
    a478:	8d 73 05             	lea    0x5(%ebx),%esi
    a47b:	39 f1                	cmp    %esi,%ecx
    a47d:	8b 11                	mov    (%ecx),%edx
    a47f:	75 0b                	jne    a48c <Zero_LogicalChannel_Bj_Reset+0x2c>
    a481:	eb 28                	jmp    a4ab <Zero_LogicalChannel_Bj_Reset+0x4b>
    a483:	90                   	nop
    a484:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a488:	89 d1                	mov    %edx,%ecx
    a48a:	89 f2                	mov    %esi,%edx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
    a48c:	81 79 fc 01 7d 00 00 	cmpl   $0x7d01,-0x4(%ecx)
    a493:	74 0d                	je     a4a2 <Zero_LogicalChannel_Bj_Reset+0x42>
			temp->lcbj=0;//BJ0			
    a495:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
    a49c:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a4a2:	8d 4b 05             	lea    0x5(%ebx),%ecx
    a4a5:	8b 32                	mov    (%edx),%esi
    a4a7:	39 ca                	cmp    %ecx,%edx
    a4a9:	75 dd                	jne    a488 <Zero_LogicalChannel_Bj_Reset+0x28>
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
			temp->lcbj=0;//BJ0			
	}
	FOUT;
}
    a4ab:	5b                   	pop    %ebx
    a4ac:	5e                   	pop    %esi
    a4ad:	5d                   	pop    %ebp
    a4ae:	c3                   	ret    
    a4af:	90                   	nop

0000a4b0 <Init_LogicalChannel_ConfigInfo>:
->Output: SV(LogicalChannel_Bj)
->Special:
*******************************
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
    a4b0:	55                   	push   %ebp
    a4b1:	89 e5                	mov    %esp,%ebp
    a4b3:	57                   	push   %edi
    a4b4:	56                   	push   %esi
    a4b5:	53                   	push   %ebx
    a4b6:	83 ec 04             	sub    $0x4,%esp
    a4b9:	e8 fc ff ff ff       	call   a4ba <Init_LogicalChannel_ConfigInfo+0xa>
    a4be:	89 c3                	mov    %eax,%ebx
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a4c0:	e8 fc ff ff ff       	call   a4c1 <Init_LogicalChannel_ConfigInfo+0x11>
	bool flag=false;
	struct list_head *pos=NULL,*p=NULL;
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
    a4c5:	0f b6 3b             	movzbl (%ebx),%edi
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a4c8:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a4ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a4d1:	8b 56 11             	mov    0x11(%esi),%edx
    a4d4:	83 c6 11             	add    $0x11,%esi
    a4d7:	39 f2                	cmp    %esi,%edx
    a4d9:	8b 02                	mov    (%edx),%eax
    a4db:	75 0d                	jne    a4ea <Init_LogicalChannel_ConfigInfo+0x3a>
    a4dd:	eb 39                	jmp    a518 <Init_LogicalChannel_ConfigInfo+0x68>
    a4df:	90                   	nop
    a4e0:	39 c6                	cmp    %eax,%esi
    a4e2:	8b 08                	mov    (%eax),%ecx
    a4e4:	74 32                	je     a518 <Init_LogicalChannel_ConfigInfo+0x68>
    a4e6:	89 c2                	mov    %eax,%edx
    a4e8:	89 c8                	mov    %ecx,%eax
	{
		temp_lc_config=list_entry(pos,LogicalChannelConfigInfo,list);
		temp_lc_config_lcid=temp_lc_config->lcid;
		if(temp_lcid==temp_lc_config_lcid)
    a4ea:	89 f9                	mov    %edi,%ecx
    a4ec:	3a 4a ef             	cmp    -0x11(%edx),%cl
    a4ef:	75 ef                	jne    a4e0 <Init_LogicalChannel_ConfigInfo+0x30>
		{
			if((lc_info->logicalChannelConfig).haveUl_SpecificParameters==true)
    a4f1:	80 7b 04 00          	cmpb   $0x0,0x4(%ebx)
    a4f5:	74 e9                	je     a4e0 <Init_LogicalChannel_ConfigInfo+0x30>
			{
				temp_lc_config->priority=(lc_info->logicalChannelConfig).ul_SpecificParameters.priority;
    a4f7:	8b 43 05             	mov    0x5(%ebx),%eax
    a4fa:	89 42 f0             	mov    %eax,-0x10(%edx)
				temp_lc_config->prioritizedBitRateKbps=(lc_info->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    a4fd:	8b 43 09             	mov    0x9(%ebx),%eax
    a500:	89 42 f4             	mov    %eax,-0xc(%edx)
				temp_lc_config->bucketSizeDurationMs=(lc_info->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    a503:	8b 43 0d             	mov    0xd(%ebx),%eax
    a506:	89 42 f8             	mov    %eax,-0x8(%edx)
				temp_lc_config->logicalChannelGroup=(lc_info->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    a509:	8b 43 11             	mov    0x11(%ebx),%eax
    a50c:	89 42 fc             	mov    %eax,-0x4(%edx)
			temp_bj->lcbj=0;
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a50f:	83 c4 04             	add    $0x4,%esp
    a512:	5b                   	pop    %ebx
    a513:	5e                   	pop    %esi
    a514:	5f                   	pop    %edi
    a515:	5d                   	pop    %ebp
    a516:	c3                   	ret    
    a517:	90                   	nop
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a518:	89 d8                	mov    %ebx,%eax
    a51a:	e8 fc ff ff ff       	call   a51b <Init_LogicalChannel_ConfigInfo+0x6b>
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a51f:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a522:	89 c6                	mov    %eax,%esi
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a524:	8b 82 40 01 00 00    	mov    0x140(%edx),%eax
    a52a:	8d 4e 11             	lea    0x11(%esi),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a52d:	8b 50 15             	mov    0x15(%eax),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a530:	89 48 15             	mov    %ecx,0x15(%eax)
    a533:	83 c0 11             	add    $0x11,%eax
    a536:	89 46 11             	mov    %eax,0x11(%esi)
		temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    a539:	b8 0d 00 00 00       	mov    $0xd,%eax
	new->next = next;
	new->prev = prev;
    a53e:	89 56 15             	mov    %edx,0x15(%esi)
	prev->next = new;
    a541:	89 0a                	mov    %ecx,(%edx)
    a543:	e8 fc ff ff ff       	call   a544 <Init_LogicalChannel_ConfigInfo+0x94>
		/*while(temp_bj==0)//
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
    a548:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a54b:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a54e:	89 50 09             	mov    %edx,0x9(%eax)
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a551:	8b 0b                	mov    (%ebx),%ecx
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a553:	bb 01 7d 00 00       	mov    $0x7d01,%ebx
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a558:	88 08                	mov    %cl,(%eax)
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a55a:	31 c9                	xor    %ecx,%ecx
    a55c:	83 7e 05 ff          	cmpl   $0xffffffff,0x5(%esi)
    a560:	0f 44 cb             	cmove  %ebx,%ecx
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a563:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a566:	89 48 01             	mov    %ecx,0x1(%eax)
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a569:	8b 8b 44 01 00 00    	mov    0x144(%ebx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a56f:	8b 59 09             	mov    0x9(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a572:	89 51 09             	mov    %edx,0x9(%ecx)
    a575:	83 c1 05             	add    $0x5,%ecx
    a578:	89 48 05             	mov    %ecx,0x5(%eax)
	new->next = next;
	new->prev = prev;
    a57b:	89 58 09             	mov    %ebx,0x9(%eax)
	prev->next = new;
    a57e:	89 13                	mov    %edx,(%ebx)
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a580:	83 c4 04             	add    $0x4,%esp
    a583:	5b                   	pop    %ebx
    a584:	5e                   	pop    %esi
    a585:	5f                   	pop    %edi
    a586:	5d                   	pop    %ebp
    a587:	c3                   	ret    
    a588:	90                   	nop
    a589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a590 <leftresource_morethan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a590:	55                   	push   %ebp
    a591:	89 e5                	mov    %esp,%ebp
    a593:	83 ec 18             	sub    $0x18,%esp
    a596:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a599:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a59c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a59f:	e8 fc ff ff ff       	call   a5a0 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x10>
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a5a4:	8b 71 01             	mov    0x1(%ecx),%esi
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a5a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a5aa:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a5ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a5b0:	8b 45 14             	mov    0x14(%ebp),%eax
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a5b3:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a5b7:	66 89 72 0d          	mov    %si,0xd(%edx)
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a5bb:	8b 71 01             	mov    0x1(%ecx),%esi
    a5be:	8b 76 09             	mov    0x9(%esi),%esi
    a5c1:	89 72 09             	mov    %esi,0x9(%edx)
	*res_length=*res_length-retxlength;
    a5c4:	29 38                	sub    %edi,(%eax)
	temp_logicalchannel_bj->lcbj-=retxlength;
    a5c6:	29 7b 01             	sub    %edi,0x1(%ebx)
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a5c9:	8b 30                	mov    (%eax),%esi
    a5cb:	8b 7d 10             	mov    0x10(%ebp),%edi
    a5ce:	89 75 e8             	mov    %esi,-0x18(%ebp)
    a5d1:	39 fe                	cmp    %edi,%esi
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a5d3:	8b 71 01             	mov    0x1(%ecx),%esi
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
	*res_length=*res_length-retxlength;
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a5d6:	0f 83 b4 00 00 00    	jae    a690 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x100>
		*res_length-=txlength;
		//  break;
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
    a5dc:	0f b7 7e 07          	movzwl 0x7(%esi),%edi
    a5e0:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    a5e4:	0f b7 ff             	movzwl %di,%edi
    a5e7:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    a5ea:	73 4c                	jae    a638 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xa8>
			// break;
		}
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
    a5ec:	8b 76 03             	mov    0x3(%esi),%esi
    a5ef:	39 75 e8             	cmp    %esi,-0x18(%ebp)
    a5f2:	0f 83 d8 00 00 00    	jae    a6d0 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x140>
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a5f8:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a5fb:	8b 7d ec             	mov    -0x14(%ebp),%edi
				temp_rlc_report->txQueueHeader=0;
    a5fe:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a604:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
    a607:	8b 08                	mov    (%eax),%ecx
    a609:	29 4b 01             	sub    %ecx,0x1(%ebx)
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a60c:	89 fb                	mov    %edi,%ebx
    a60e:	8d 4a 13             	lea    0x13(%edx),%ecx
    a611:	83 c3 13             	add    $0x13,%ebx
			{
				temp_rlc_report->txQueueSize=*res_length;
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
    a614:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a61a:	8b 47 17             	mov    0x17(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a61d:	89 4f 17             	mov    %ecx,0x17(%edi)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a620:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a623:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a626:	89 08                	mov    %ecx,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a628:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a62b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a62e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a631:	89 ec                	mov    %ebp,%esp
    a633:	5d                   	pop    %ebp
    a634:	c3                   	ret    
    a635:	8d 76 00             	lea    0x0(%esi),%esi
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a638:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
    a63c:	66 89 72 07          	mov    %si,0x7(%edx)
			*res_length=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    a640:	8b 71 01             	mov    0x1(%ecx),%esi
    a643:	8b 38                	mov    (%eax),%edi
    a645:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a649:	29 f7                	sub    %esi,%edi
    a64b:	89 38                	mov    %edi,(%eax)
			temp_rlc_report->txQueueSize=*res_length;
    a64d:	89 7a 03             	mov    %edi,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=(temp_mac_buffer->RlcRequestparams->txQueueHeader+temp_rlc_report->txQueueSize);
    a650:	8b 49 01             	mov    0x1(%ecx),%ecx
    a653:	0f b7 71 07          	movzwl 0x7(%ecx),%esi
    a657:	8b 4b 01             	mov    0x1(%ebx),%ecx
    a65a:	29 f1                	sub    %esi,%ecx
    a65c:	29 f9                	sub    %edi,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a65e:	8b 7d ec             	mov    -0x14(%ebp),%edi
    a661:	89 4b 01             	mov    %ecx,0x1(%ebx)
			// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
			// temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a664:	8d 5a 13             	lea    0x13(%edx),%ebx
    a667:	8b 4f 17             	mov    0x17(%edi),%ecx
    a66a:	89 fe                	mov    %edi,%esi
    a66c:	83 c6 13             	add    $0x13,%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a66f:	89 5f 17             	mov    %ebx,0x17(%edi)
    a672:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a675:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a678:	89 19                	mov    %ebx,(%ecx)
			*res_length=0;
    a67a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a680:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a683:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a686:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a689:	89 ec                	mov    %ebp,%esp
    a68b:	5d                   	pop    %ebp
    a68c:	c3                   	ret    
    a68d:	8d 76 00             	lea    0x0(%esi),%esi
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a690:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a694:	66 89 72 07          	mov    %si,0x7(%edx)
		temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a698:	8b 49 01             	mov    0x1(%ecx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a69b:	8b 75 ec             	mov    -0x14(%ebp),%esi
    a69e:	8b 49 03             	mov    0x3(%ecx),%ecx
    a6a1:	89 4a 03             	mov    %ecx,0x3(%edx)
		temp_logicalchannel_bj->lcbj-=txlength;
    a6a4:	29 7b 01             	sub    %edi,0x1(%ebx)
    a6a7:	8b 4e 17             	mov    0x17(%esi),%ecx
		// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a6aa:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a6ad:	89 5e 17             	mov    %ebx,0x17(%esi)
    a6b0:	83 c6 13             	add    $0x13,%esi
    a6b3:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a6b6:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a6b9:	89 19                	mov    %ebx,(%ecx)
		*res_length-=txlength;
    a6bb:	29 38                	sub    %edi,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a6bd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a6c0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a6c3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a6c6:	89 ec                	mov    %ebp,%esp
    a6c8:	5d                   	pop    %ebp
    a6c9:	c3                   	ret    
    a6ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
			{
				temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a6d0:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);
    a6d3:	8b 49 01             	mov    0x1(%ecx),%ecx
    a6d6:	8b 30                	mov    (%eax),%esi
    a6d8:	66 2b 71 03          	sub    0x3(%ecx),%si
    a6dc:	66 89 72 07          	mov    %si,0x7(%edx)

				temp_logicalchannel_bj->lcbj-=*res_length;
    a6e0:	8b 08                	mov    (%eax),%ecx
    a6e2:	29 4b 01             	sub    %ecx,0x1(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a6e5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a6e8:	8d 4a 13             	lea    0x13(%edx),%ecx
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);

				temp_logicalchannel_bj->lcbj-=*res_length;
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
    a6eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a6f1:	8b 43 17             	mov    0x17(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a6f4:	89 4b 17             	mov    %ecx,0x17(%ebx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a6f7:	83 c3 13             	add    $0x13,%ebx
    a6fa:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a6fd:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a700:	89 08                	mov    %ecx,(%eax)
    a702:	e9 79 ff ff ff       	jmp    a680 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xf0>
    a707:	89 f6                	mov    %esi,%esi
    a709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a710 <leftresource_lessthan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a710:	55                   	push   %ebp
    a711:	89 e5                	mov    %esp,%ebp
    a713:	83 ec 10             	sub    $0x10,%esp
    a716:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a719:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a71c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a71f:	e8 fc ff ff ff       	call   a720 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x10>
    a724:	8b 5d 14             	mov    0x14(%ebp),%ebx
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
    a727:	8b 33                	mov    (%ebx),%esi
    a729:	89 75 f0             	mov    %esi,-0x10(%ebp)
    a72c:	8b 71 01             	mov    0x1(%ecx),%esi
    a72f:	0f b7 7e 0d          	movzwl 0xd(%esi),%edi
    a733:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    a736:	73 58                	jae    a790 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x80>
		*res_length=0;
		// break;
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
    a738:	8b 76 09             	mov    0x9(%esi),%esi
    a73b:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a73e:	0f 83 ac 00 00 00    	jae    a7f0 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0xe0>
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a744:	8b 7d f0             	mov    -0x10(%ebp),%edi
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
			temp_logicalchannel_bj->lcbj-=*res_length;
    a747:	8b 75 08             	mov    0x8(%ebp),%esi
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
			temp_rlc_report->retxQueueHeader=0;
    a74a:	66 c7 42 0d 00 00    	movw   $0x0,0xd(%edx)
			temp_rlc_report->txQueueHeader=0;
    a750:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a756:	89 7a 09             	mov    %edi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
    a759:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=*res_length;
    a760:	8b 0b                	mov    (%ebx),%ecx
    a762:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
			*res_length=0;
    a765:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a76b:	8b 48 17             	mov    0x17(%eax),%ecx
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a76e:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a771:	89 58 17             	mov    %ebx,0x17(%eax)
    a774:	83 c0 13             	add    $0x13,%eax
    a777:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a77a:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a77d:	89 19                	mov    %ebx,(%ecx)
			//break;
		}
	}
	FOUT;
}
    a77f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a782:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a785:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a788:	89 ec                	mov    %ebp,%esp
    a78a:	5d                   	pop    %ebp
    a78b:	c3                   	ret    
    a78c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
    a790:	8b 7d 08             	mov    0x8(%ebp),%edi
    a793:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a796:	29 77 01             	sub    %esi,0x1(%edi)
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a799:	89 df                	mov    %ebx,%edi
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a79b:	8b 71 01             	mov    0x1(%ecx),%esi
    a79e:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a7a2:	66 89 72 0d          	mov    %si,0xd(%edx)
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a7a6:	8b 49 01             	mov    0x1(%ecx),%ecx
		temp_rlc_report->retxQueueSize=*res_length;
		temp_rlc_report->txQueueHeader=0;
		temp_rlc_report->txQueueSize=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a7a9:	8d 72 13             	lea    0x13(%edx),%esi
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a7ac:	0f b7 49 0d          	movzwl 0xd(%ecx),%ecx
    a7b0:	c1 e1 02             	shl    $0x2,%ecx
    a7b3:	29 cf                	sub    %ecx,%edi
    a7b5:	89 3b                	mov    %edi,(%ebx)
		temp_rlc_report->retxQueueSize=*res_length;
    a7b7:	89 7a 09             	mov    %edi,0x9(%edx)
		temp_rlc_report->txQueueHeader=0;
    a7ba:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
		temp_rlc_report->txQueueSize=0;
    a7c0:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a7c7:	8b 48 17             	mov    0x17(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a7ca:	89 70 17             	mov    %esi,0x17(%eax)
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a7cd:	83 c0 13             	add    $0x13,%eax
    a7d0:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a7d3:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a7d6:	89 31                	mov    %esi,(%ecx)
		*res_length=0;
    a7d8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			//break;
		}
	}
	FOUT;
}
    a7de:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a7e1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a7e4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a7e7:	89 ec                	mov    %ebp,%esp
    a7e9:	5d                   	pop    %ebp
    a7ea:	c3                   	ret    
    a7eb:	90                   	nop
    a7ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
		{
			temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a7f0:	89 72 09             	mov    %esi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->retxQueueSize);
    a7f3:	8b 49 01             	mov    0x1(%ecx),%ecx
    a7f6:	8b 33                	mov    (%ebx),%esi
    a7f8:	66 2b 71 09          	sub    0x9(%ecx),%si
    a7fc:	66 89 72 0d          	mov    %si,0xd(%edx)

			temp_logicalchannel_bj->lcbj-=*res_length;
    a800:	8b 75 08             	mov    0x8(%ebp),%esi
    a803:	8b 0b                	mov    (%ebx),%ecx
    a805:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueHeader-=temp_rlc_report->retxQueueHeader;
			//temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
			temp_rlc_report->txQueueHeader=0;
    a808:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			temp_rlc_report->txQueueSize=0;
    a80e:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
    a815:	e9 4b ff ff ff       	jmp    a765 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x55>
    a81a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a820 <ResourceAllocation_logicalchannel_firstretxbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a820:	55                   	push   %ebp
    a821:	89 e5                	mov    %esp,%ebp
    a823:	83 ec 24             	sub    $0x24,%esp
    a826:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a829:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a82c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a82f:	e8 fc ff ff ff       	call   a830 <ResourceAllocation_logicalchannel_firstretxbuffer+0x10>
    a834:	8b 7d 10             	mov    0x10(%ebp),%edi
    a837:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a83a:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a83f:	89 d6                	mov    %edx,%esi
    a841:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a844:	e8 fc ff ff ff       	call   a845 <ResourceAllocation_logicalchannel_firstretxbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a849:	31 d2                	xor    %edx,%edx
    a84b:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a850:	89 c3                	mov    %eax,%ebx
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a852:	e8 fc ff ff ff       	call   a853 <ResourceAllocation_logicalchannel_firstretxbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
    a857:	8d 43 13             	lea    0x13(%ebx),%eax
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a85a:	89 f1                	mov    %esi,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a85c:	89 43 13             	mov    %eax,0x13(%ebx)
    a85f:	89 da                	mov    %ebx,%edx
	list->prev = list;
    a861:	89 43 17             	mov    %eax,0x17(%ebx)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    a864:	8b 46 01             	mov    0x1(%esi),%eax
    a867:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    a86b:	88 43 02             	mov    %al,0x2(%ebx)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a86e:	8b 46 01             	mov    0x1(%esi),%eax
    a871:	0f b7 00             	movzwl (%eax),%eax
	temp_rlc_report->statusPduHeader=0;
    a874:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
	temp_rlc_report->statusPduSize=0;//PDU
    a87a:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a880:	66 89 03             	mov    %ax,(%ebx)
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    a883:	8b 45 08             	mov    0x8(%ebp),%eax
    a886:	39 07                	cmp    %eax,(%edi)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a888:	8b 45 0c             	mov    0xc(%ebp),%eax
    a88b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    a88f:	89 44 24 08          	mov    %eax,0x8(%esp)
    a893:	8b 45 08             	mov    0x8(%ebp),%eax
    a896:	89 44 24 04          	mov    %eax,0x4(%esp)
    a89a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a89d:	89 04 24             	mov    %eax,(%esp)
    a8a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    a8a3:	73 13                	jae    a8b8 <ResourceAllocation_logicalchannel_firstretxbuffer+0x98>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    a8a5:	e8 fc ff ff ff       	call   a8a6 <ResourceAllocation_logicalchannel_firstretxbuffer+0x86>
	}
	FOUT;
}
    a8aa:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a8ad:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a8b0:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8b3:	89 ec                	mov    %ebp,%esp
    a8b5:	5d                   	pop    %ebp
    a8b6:	c3                   	ret    
    a8b7:	90                   	nop
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a8b8:	e8 fc ff ff ff       	call   a8b9 <ResourceAllocation_logicalchannel_firstretxbuffer+0x99>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    a8bd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a8c0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a8c3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8c6:	89 ec                	mov    %ebp,%esp
    a8c8:	5d                   	pop    %ebp
    a8c9:	c3                   	ret    
    a8ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a8d0 <ResourceAllocation_logicalchannel_firststatusbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a8d0:	55                   	push   %ebp
    a8d1:	89 e5                	mov    %esp,%ebp
    a8d3:	83 ec 24             	sub    $0x24,%esp
    a8d6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a8d9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a8dc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a8df:	e8 fc ff ff ff       	call   a8e0 <ResourceAllocation_logicalchannel_firststatusbuffer+0x10>
    a8e4:	8b 7d 14             	mov    0x14(%ebp),%edi
    a8e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a8ea:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a8ef:	89 d3                	mov    %edx,%ebx
    a8f1:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a8f4:	e8 fc ff ff ff       	call   a8f5 <ResourceAllocation_logicalchannel_firststatusbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a8f9:	31 d2                	xor    %edx,%edx
    a8fb:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a900:	89 c6                	mov    %eax,%esi
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a902:	e8 fc ff ff ff       	call   a903 <ResourceAllocation_logicalchannel_firststatusbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));
    a907:	8d 46 13             	lea    0x13(%esi),%eax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a90a:	89 d9                	mov    %ebx,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a90c:	89 46 13             	mov    %eax,0x13(%esi)
    a90f:	89 f2                	mov    %esi,%edx
	list->prev = list;
    a911:	89 46 17             	mov    %eax,0x17(%esi)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    a914:	8b 43 01             	mov    0x1(%ebx),%eax
    a917:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    a91b:	88 46 02             	mov    %al,0x2(%esi)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a91e:	8b 43 01             	mov    0x1(%ebx),%eax
    a921:	0f b7 00             	movzwl (%eax),%eax
    a924:	66 89 06             	mov    %ax,(%esi)
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
    a927:	8b 43 01             	mov    0x1(%ebx),%eax
    a92a:	0f b7 40 11          	movzwl 0x11(%eax),%eax
    a92e:	66 89 46 11          	mov    %ax,0x11(%esi)
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
    a932:	8b 43 01             	mov    0x1(%ebx),%eax
    a935:	0f b7 40 0f          	movzwl 0xf(%eax),%eax
    a939:	66 89 46 0f          	mov    %ax,0xf(%esi)
	*res_length=*res_length-statuslength;        
    a93d:	8b 07                	mov    (%edi),%eax
    a93f:	2b 45 08             	sub    0x8(%ebp),%eax
	if(*res_length >= retxlength)
    a942:	3b 45 0c             	cmp    0xc(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
    a945:	89 07                	mov    %eax,(%edi)
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a947:	8b 45 10             	mov    0x10(%ebp),%eax
    a94a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    a94e:	89 44 24 08          	mov    %eax,0x8(%esp)
    a952:	8b 45 0c             	mov    0xc(%ebp),%eax
    a955:	89 44 24 04          	mov    %eax,0x4(%esp)
    a959:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a95c:	89 04 24             	mov    %eax,(%esp)
    a95f:	8b 45 f0             	mov    -0x10(%ebp),%eax
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
    a962:	73 14                	jae    a978 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa8>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    a964:	e8 fc ff ff ff       	call   a965 <ResourceAllocation_logicalchannel_firststatusbuffer+0x95>
	}
	FOUT;
}
    a969:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a96c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a96f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a972:	89 ec                	mov    %ebp,%esp
    a974:	5d                   	pop    %ebp
    a975:	c3                   	ret    
    a976:	66 90                	xchg   %ax,%ax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a978:	e8 fc ff ff ff       	call   a979 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa9>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    a97d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a980:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a983:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a986:	89 ec                	mov    %ebp,%esp
    a988:	5d                   	pop    %ebp
    a989:	c3                   	ret    
    a98a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a990 <ResourceAllocation_foreach_logicalchannel>:
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a990:	55                   	push   %ebp
    a991:	89 e5                	mov    %esp,%ebp
    a993:	83 ec 30             	sub    $0x30,%esp
    a996:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a999:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a99c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a99f:	e8 fc ff ff ff       	call   a9a0 <ResourceAllocation_foreach_logicalchannel+0x10>
    a9a4:	8b 75 14             	mov    0x14(%ebp),%esi
    a9a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    a9aa:	89 55 e8             	mov    %edx,-0x18(%ebp)
    a9ad:	89 4d ec             	mov    %ecx,-0x14(%ebp)
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    a9b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    a9b3:	e8 fc ff ff ff       	call   a9b4 <ResourceAllocation_foreach_logicalchannel+0x24>
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    a9b8:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a9bb:	8b 06                	mov    (%esi),%eax
    a9bd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    a9c0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a9c3:	01 df                	add    %ebx,%edi
    a9c5:	03 7d 10             	add    0x10(%ebp),%edi
    a9c8:	39 f8                	cmp    %edi,%eax
    a9ca:	73 2c                	jae    a9f8 <ResourceAllocation_foreach_logicalchannel+0x68>
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
		*res_length=*res_length-(statuslength+retxlength+txlength);
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
    a9cc:	39 d8                	cmp    %ebx,%eax
    a9ce:	73 70                	jae    aa40 <ResourceAllocation_foreach_logicalchannel+0xb0>
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
	}
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    a9d0:	8b 5d 10             	mov    0x10(%ebp),%ebx
    a9d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a9d6:	89 74 24 08          	mov    %esi,0x8(%esp)
    a9da:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    a9de:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a9e1:	89 1c 24             	mov    %ebx,(%esp)
    a9e4:	e8 fc ff ff ff       	call   a9e5 <ResourceAllocation_foreach_logicalchannel+0x55>
	}
	FOUT;
}
    a9e9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a9ec:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a9ef:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a9f2:	89 ec                	mov    %ebp,%esp
    a9f4:	5d                   	pop    %ebp
    a9f5:	c3                   	ret    
    a9f6:	66 90                	xchg   %ax,%ax
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
	{
		temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    a9f8:	8b 42 01             	mov    0x1(%edx),%eax
    a9fb:	e8 fc ff ff ff       	call   a9fc <ResourceAllocation_foreach_logicalchannel+0x6c>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    aa00:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    aa03:	8b 5b 17             	mov    0x17(%ebx),%ebx
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    aa06:	8d 50 13             	lea    0x13(%eax),%edx
    aa09:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    aa0c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    aa0f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    aa12:	89 53 17             	mov    %edx,0x17(%ebx)
    aa15:	83 c3 13             	add    $0x13,%ebx
	new->next = next;
	new->prev = prev;
    aa18:	8b 55 e0             	mov    -0x20(%ebp),%edx
    aa1b:	89 58 13             	mov    %ebx,0x13(%eax)
	prev->next = new;
    aa1e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    aa21:	89 50 17             	mov    %edx,0x17(%eax)
	prev->next = new;
    aa24:	89 1a                	mov    %ebx,(%edx)
		*res_length=*res_length-(statuslength+retxlength+txlength);
    aa26:	29 3e                	sub    %edi,(%esi)
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
    aa28:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    aa2b:	29 79 01             	sub    %edi,0x1(%ecx)
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    aa2e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aa31:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aa34:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aa37:	89 ec                	mov    %ebp,%esp
    aa39:	5d                   	pop    %ebp
    aa3a:	c3                   	ret    
    aa3b:	90                   	nop
    aa3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    aa40:	8b 45 10             	mov    0x10(%ebp),%eax
    aa43:	89 74 24 0c          	mov    %esi,0xc(%esp)
    aa47:	89 1c 24             	mov    %ebx,(%esp)
    aa4a:	89 44 24 08          	mov    %eax,0x8(%esp)
    aa4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa51:	89 44 24 04          	mov    %eax,0x4(%esp)
    aa55:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aa58:	e8 fc ff ff ff       	call   aa59 <ResourceAllocation_foreach_logicalchannel+0xc9>
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    aa5d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aa60:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aa63:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aa66:	89 ec                	mov    %ebp,%esp
    aa68:	5d                   	pop    %ebp
    aa69:	c3                   	ret    
    aa6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000aa70 <Delete_LogicalChannel_ConfigInfo>:
->Output:int *num:reportvoid *:RLC report
->Special:
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
    aa70:	55                   	push   %ebp
    aa71:	89 e5                	mov    %esp,%ebp
    aa73:	57                   	push   %edi
    aa74:	56                   	push   %esi
    aa75:	53                   	push   %ebx
    aa76:	83 ec 04             	sub    $0x4,%esp
    aa79:	e8 fc ff ff ff       	call   aa7a <Delete_LogicalChannel_ConfigInfo+0xa>
    aa7e:	89 c6                	mov    %eax,%esi
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    aa80:	e8 fc ff ff ff       	call   aa81 <Delete_LogicalChannel_ConfigInfo+0x11>
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aa85:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    aa8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aa8e:	8b 51 11             	mov    0x11(%ecx),%edx
    aa91:	8d 41 11             	lea    0x11(%ecx),%eax
    aa94:	39 c2                	cmp    %eax,%edx
    aa96:	8b 1a                	mov    (%edx),%ebx
    aa98:	75 13                	jne    aaad <Delete_LogicalChannel_ConfigInfo+0x3d>
    aa9a:	eb 44                	jmp    aae0 <Delete_LogicalChannel_ConfigInfo+0x70>
    aa9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    aaa0:	8d 51 11             	lea    0x11(%ecx),%edx
    aaa3:	8b 03                	mov    (%ebx),%eax
    aaa5:	39 d3                	cmp    %edx,%ebx
    aaa7:	74 37                	je     aae0 <Delete_LogicalChannel_ConfigInfo+0x70>
    aaa9:	89 da                	mov    %ebx,%edx
    aaab:	89 c3                	mov    %eax,%ebx
	{
		temp_free=list_entry(pos,LogicalChannelConfigInfo,list);
		if(temp_free->lcid==lcid_delete)
    aaad:	0f b6 42 ef          	movzbl -0x11(%edx),%eax
    aab1:	66 39 f0             	cmp    %si,%ax
    aab4:	75 ea                	jne    aaa0 <Delete_LogicalChannel_ConfigInfo+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    aab6:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
    aab9:	8d 42 ef             	lea    -0x11(%edx),%eax
    aabc:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aabe:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    aac1:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aac3:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    aac5:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp_free);
    aac8:	e8 fc ff ff ff       	call   aac9 <Delete_LogicalChannel_ConfigInfo+0x59>
    aacd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aad0:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    aad6:	8b 03                	mov    (%ebx),%eax
    aad8:	8d 51 11             	lea    0x11(%ecx),%edx
    aadb:	39 d3                	cmp    %edx,%ebx
    aadd:	75 ca                	jne    aaa9 <Delete_LogicalChannel_ConfigInfo+0x39>
    aadf:	90                   	nop
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    aae0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    aae3:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
    aae9:	8b 51 05             	mov    0x5(%ecx),%edx
    aaec:	8d 41 05             	lea    0x5(%ecx),%eax
    aaef:	39 c2                	cmp    %eax,%edx
    aaf1:	8b 1a                	mov    (%edx),%ebx
    aaf3:	75 10                	jne    ab05 <Delete_LogicalChannel_ConfigInfo+0x95>
    aaf5:	eb 41                	jmp    ab38 <Delete_LogicalChannel_ConfigInfo+0xc8>
    aaf7:	90                   	nop
    aaf8:	8d 51 05             	lea    0x5(%ecx),%edx
    aafb:	8b 03                	mov    (%ebx),%eax
    aafd:	39 d3                	cmp    %edx,%ebx
    aaff:	74 37                	je     ab38 <Delete_LogicalChannel_ConfigInfo+0xc8>
    ab01:	89 da                	mov    %ebx,%edx
    ab03:	89 c3                	mov    %eax,%ebx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcid==lcid_delete)
    ab05:	0f b6 42 fb          	movzbl -0x5(%edx),%eax
    ab09:	66 39 f0             	cmp    %si,%ax
    ab0c:	75 ea                	jne    aaf8 <Delete_LogicalChannel_ConfigInfo+0x88>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ab0e:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
    ab11:	8d 42 fb             	lea    -0x5(%edx),%eax
    ab14:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ab16:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    ab19:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab1b:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    ab1d:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp);
    ab20:	e8 fc ff ff ff       	call   ab21 <Delete_LogicalChannel_ConfigInfo+0xb1>
    ab25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ab28:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    ab2e:	8b 03                	mov    (%ebx),%eax
    ab30:	8d 51 05             	lea    0x5(%ecx),%edx
    ab33:	39 d3                	cmp    %edx,%ebx
    ab35:	75 ca                	jne    ab01 <Delete_LogicalChannel_ConfigInfo+0x91>
    ab37:	90                   	nop
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
			fsm_mem_free(temp);
		}
	}
	FOUT;
}
    ab38:	83 c4 04             	add    $0x4,%esp
    ab3b:	5b                   	pop    %ebx
    ab3c:	5e                   	pop    %esi
    ab3d:	5f                   	pop    %edi
    ab3e:	5d                   	pop    %ebp
    ab3f:	c3                   	ret    

0000ab40 <Empty_MACBuffer_Rlc>:
->Output:
->Special:
*******************************
*/
void Empty_MACBuffer_Rlc(void)
{
    ab40:	55                   	push   %ebp
    ab41:	89 e5                	mov    %esp,%ebp
    ab43:	57                   	push   %edi
    ab44:	56                   	push   %esi
    ab45:	53                   	push   %ebx
    ab46:	e8 fc ff ff ff       	call   ab47 <Empty_MACBuffer_Rlc+0x7>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
    ab4b:	e8 fc ff ff ff       	call   ab4c <Empty_MACBuffer_Rlc+0xc>
    ab50:	89 c7                	mov    %eax,%edi
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    ab52:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    ab58:	8b 58 05             	mov    0x5(%eax),%ebx
    ab5b:	83 c0 05             	add    $0x5,%eax
    ab5e:	39 c3                	cmp    %eax,%ebx
    ab60:	8b 33                	mov    (%ebx),%esi
    ab62:	75 08                	jne    ab6c <Empty_MACBuffer_Rlc+0x2c>
    ab64:	eb 34                	jmp    ab9a <Empty_MACBuffer_Rlc+0x5a>
    ab66:	66 90                	xchg   %ax,%ax
    ab68:	89 f3                	mov    %esi,%ebx
    ab6a:	89 d6                	mov    %edx,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    ab6c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    ab6f:	e8 fc ff ff ff       	call   ab70 <Empty_MACBuffer_Rlc+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ab74:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_free->list));
    ab77:	8d 43 fb             	lea    -0x5(%ebx),%eax
    ab7a:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ab7c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    ab7f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab81:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ab83:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ab86:	e8 fc ff ff ff       	call   ab87 <Empty_MACBuffer_Rlc+0x47>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    ab8b:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
    ab91:	8b 16                	mov    (%esi),%edx
    ab93:	83 c0 05             	add    $0x5,%eax
    ab96:	39 c6                	cmp    %eax,%esi
    ab98:	75 ce                	jne    ab68 <Empty_MACBuffer_Rlc+0x28>
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}	
	FOUT;
}
    ab9a:	5b                   	pop    %ebx
    ab9b:	5e                   	pop    %esi
    ab9c:	5f                   	pop    %edi
    ab9d:	5d                   	pop    %ebp
    ab9e:	c3                   	ret    
    ab9f:	90                   	nop

0000aba0 <ResourceAllocation_Algorithm>:
->Special:
*******************************
*/

void * ResourceAllocation_Algorithm(u32 resource_len,u32 *num)//numreport
{
    aba0:	55                   	push   %ebp
    aba1:	89 e5                	mov    %esp,%ebp
    aba3:	57                   	push   %edi
    aba4:	56                   	push   %esi
    aba5:	53                   	push   %ebx
    aba6:	83 ec 3c             	sub    $0x3c,%esp
    aba9:	e8 fc ff ff ff       	call   abaa <ResourceAllocation_Algorithm+0xa>
    abae:	89 55 c8             	mov    %edx,-0x38(%ebp)
    abb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	u32 *res_length;
	u32 statuslength,retxlength,txlength;
	struct list_head *pos,*p;

	FIN(ResourceAllocation_Algorithm(int resource_len));
	SV_PTR_GET(rlc_mac_sv);
    abb4:	e8 fc ff ff ff       	call   abb5 <ResourceAllocation_Algorithm+0x15>
    abb9:	89 45 dc             	mov    %eax,-0x24(%ebp)
	priority_mac_buffer=NULL;
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    abbc:	b8 1b 00 00 00       	mov    $0x1b,%eax
    abc1:	e8 fc ff ff ff       	call   abc2 <ResourceAllocation_Algorithm+0x22>
    abc6:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    abc9:	b8 0d 00 00 00       	mov    $0xd,%eax
    abce:	e8 fc ff ff ff       	call   abcf <ResourceAllocation_Algorithm+0x2f>
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
    abd3:	8b 75 d8             	mov    -0x28(%ebp),%esi
    abd6:	83 c6 13             	add    $0x13,%esi
    abd9:	89 75 cc             	mov    %esi,-0x34(%ebp)
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    abdc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    abdf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
    abe2:	83 c0 05             	add    $0x5,%eax
    abe5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    abe8:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    abeb:	89 42 09             	mov    %eax,0x9(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    abee:	8b 45 d8             	mov    -0x28(%ebp),%eax
    abf1:	89 70 13             	mov    %esi,0x13(%eax)
	list->prev = list;
    abf4:	89 70 17             	mov    %esi,0x17(%eax)
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    abf7:	e8 fc ff ff ff       	call   abf8 <ResourceAllocation_Algorithm+0x58>
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    abfc:	89 c2                	mov    %eax,%edx
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    abfe:	89 45 e0             	mov    %eax,-0x20(%ebp)
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ac01:	8b 40 05             	mov    0x5(%eax),%eax
    ac04:	8d 78 fb             	lea    -0x5(%eax),%edi
    ac07:	39 fa                	cmp    %edi,%edx
    ac09:	0f 84 cc 02 00 00    	je     aedb <ResourceAllocation_Algorithm+0x33b>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ac0f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ac12:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ac16:	85 c9                	test   %ecx,%ecx
    ac18:	0f 84 e5 00 00 00    	je     ad03 <ResourceAllocation_Algorithm+0x163>
    ac1e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ac25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ac2c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ac33:	90                   	nop
    ac34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    ac38:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ac3b:	8b b0 44 01 00 00    	mov    0x144(%eax),%esi
    ac41:	8b 46 05             	mov    0x5(%esi),%eax
    ac44:	8d 58 fb             	lea    -0x5(%eax),%ebx
    ac47:	39 de                	cmp    %ebx,%esi
    ac49:	75 13                	jne    ac5e <ResourceAllocation_Algorithm+0xbe>
    ac4b:	e9 68 01 00 00       	jmp    adb8 <ResourceAllocation_Algorithm+0x218>
    ac50:	8b 43 05             	mov    0x5(%ebx),%eax
    ac53:	8d 58 fb             	lea    -0x5(%eax),%ebx
    ac56:	39 de                	cmp    %ebx,%esi
    ac58:	0f 84 5a 01 00 00    	je     adb8 <ResourceAllocation_Algorithm+0x218>
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
    ac5e:	38 50 fb             	cmp    %dl,-0x5(%eax)
    ac61:	75 ed                	jne    ac50 <ResourceAllocation_Algorithm+0xb0>
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    ac63:	8b 47 01             	mov    0x1(%edi),%eax
    ac66:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    ac6a:	0f b7 50 11          	movzwl 0x11(%eax),%edx
    ac6e:	01 f2                	add    %esi,%edx
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    ac70:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    ac74:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    ac77:	8b 50 09             	mov    0x9(%eax),%edx
    ac7a:	01 d6                	add    %edx,%esi
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ac7c:	8b 50 03             	mov    0x3(%eax),%edx
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    ac7f:	89 75 ec             	mov    %esi,-0x14(%ebp)
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ac82:	0f b7 70 07          	movzwl 0x7(%eax),%esi
    ac86:	01 d6                	add    %edx,%esi
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    ac88:	81 7b 01 01 7d 00 00 	cmpl   $0x7d01,0x1(%ebx)
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ac8f:	89 75 e8             	mov    %esi,-0x18(%ebp)
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    ac92:	0f 85 a0 01 00 00    	jne    ae38 <ResourceAllocation_Algorithm+0x298>
    ac98:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ac9b:	09 f2                	or     %esi,%edx
    ac9d:	0b 55 e4             	or     -0x1c(%ebp),%edx
    aca0:	0f 84 92 01 00 00    	je     ae38 <ResourceAllocation_Algorithm+0x298>
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    aca6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    aca9:	01 f2                	add    %esi,%edx
    acab:	03 55 e4             	add    -0x1c(%ebp),%edx
    acae:	39 ca                	cmp    %ecx,%edx
    acb0:	0f 86 b3 01 00 00    	jbe    ae69 <ResourceAllocation_Algorithm+0x2c9>
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    acb6:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    acb9:	8d 45 f0             	lea    -0x10(%ebp),%eax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    acbc:	0f 86 eb 01 00 00    	jbe    aead <ResourceAllocation_Algorithm+0x30d>
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    acc2:	8b 75 e8             	mov    -0x18(%ebp),%esi
    acc5:	89 d9                	mov    %ebx,%ecx
    acc7:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    acc9:	89 44 24 08          	mov    %eax,0x8(%esp)
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    accd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    acd0:	89 74 24 04          	mov    %esi,0x4(%esp)
    acd4:	8b 75 ec             	mov    -0x14(%ebp),%esi
    acd7:	89 34 24             	mov    %esi,(%esp)
						break;
    acda:	89 de                	mov    %ebx,%esi
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    acdc:	e8 fc ff ff ff       	call   acdd <ResourceAllocation_Algorithm+0x13d>
    ace1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ace4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ace8:	8b 47 05             	mov    0x5(%edi),%eax
    aceb:	8d 78 fb             	lea    -0x5(%eax),%edi
    acee:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    acf1:	0f 84 d3 00 00 00    	je     adca <ResourceAllocation_Algorithm+0x22a>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    acf7:	85 c9                	test   %ecx,%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    acf9:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    acfd:	0f 85 35 ff ff ff    	jne    ac38 <ResourceAllocation_Algorithm+0x98>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
    ad03:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ad06:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ad09:	e8 fc ff ff ff       	call   ad0a <ResourceAllocation_Algorithm+0x16a>
    ad0e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    ad11:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ad14:	8b 58 05             	mov    0x5(%eax),%ebx
    ad17:	89 c7                	mov    %eax,%edi
    ad19:	83 c7 05             	add    $0x5,%edi
    ad1c:	39 fb                	cmp    %edi,%ebx
    ad1e:	8b 33                	mov    (%ebx),%esi
    ad20:	75 0a                	jne    ad2c <ResourceAllocation_Algorithm+0x18c>
    ad22:	eb 2d                	jmp    ad51 <ResourceAllocation_Algorithm+0x1b1>
    ad24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ad28:	89 f3                	mov    %esi,%ebx
    ad2a:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    ad2c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    ad2f:	e8 fc ff ff ff       	call   ad30 <ResourceAllocation_Algorithm+0x190>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ad34:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    ad36:	8d 43 fb             	lea    -0x5(%ebx),%eax
    ad39:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ad3c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    ad3f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad41:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ad43:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ad46:	e8 fc ff ff ff       	call   ad47 <ResourceAllocation_Algorithm+0x1a7>
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    ad4b:	39 fe                	cmp    %edi,%esi
    ad4d:	8b 06                	mov    (%esi),%eax
    ad4f:	75 d7                	jne    ad28 <ResourceAllocation_Algorithm+0x188>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
    ad51:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ad54:	e8 fc ff ff ff       	call   ad55 <ResourceAllocation_Algorithm+0x1b5>
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    ad59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ad5c:	8b 7d d0             	mov    -0x30(%ebp),%edi
    ad5f:	8b 58 05             	mov    0x5(%eax),%ebx
    ad62:	39 5d d0             	cmp    %ebx,-0x30(%ebp)
    ad65:	8b 33                	mov    (%ebx),%esi
    ad67:	75 0b                	jne    ad74 <ResourceAllocation_Algorithm+0x1d4>
    ad69:	eb 2e                	jmp    ad99 <ResourceAllocation_Algorithm+0x1f9>
    ad6b:	90                   	nop
    ad6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ad70:	89 f3                	mov    %esi,%ebx
    ad72:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    ad74:	8b 43 fc             	mov    -0x4(%ebx),%eax
    ad77:	e8 fc ff ff ff       	call   ad78 <ResourceAllocation_Algorithm+0x1d8>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ad7c:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    ad7e:	8d 43 fb             	lea    -0x5(%ebx),%eax
    ad81:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ad84:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    ad87:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad89:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ad8b:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ad8e:	e8 fc ff ff ff       	call   ad8f <ResourceAllocation_Algorithm+0x1ef>
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    ad93:	39 f7                	cmp    %esi,%edi
    ad95:	8b 06                	mov    (%esi),%eax
    ad97:	75 d7                	jne    ad70 <ResourceAllocation_Algorithm+0x1d0>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(lcbj_lessthan_zero);
    ad99:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ad9c:	e8 fc ff ff ff       	call   ad9d <ResourceAllocation_Algorithm+0x1fd>
	Empty_MACBuffer_Rlc();//MacBufferStatus
    ada1:	e8 fc ff ff ff       	call   ada2 <ResourceAllocation_Algorithm+0x202>
	FRET(report_array);
}
    ada6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ada9:	83 c4 3c             	add    $0x3c,%esp
    adac:	5b                   	pop    %ebx
    adad:	5e                   	pop    %esi
    adae:	5f                   	pop    %edi
    adaf:	5d                   	pop    %ebp
    adb0:	c3                   	ret    
    adb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    adb8:	8b 47 05             	mov    0x5(%edi),%eax
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    adbb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    adbe:	8d 78 fb             	lea    -0x5(%eax),%edi
    adc1:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    adc4:	0f 85 2d ff ff ff    	jne    acf7 <ResourceAllocation_Algorithm+0x157>
				}			
				break;
			}
		}
	}
	if(*res_length>0)
    adca:	85 c9                	test   %ecx,%ecx
    adcc:	0f 84 31 ff ff ff    	je     ad03 <ResourceAllocation_Algorithm+0x163>
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    add2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    add5:	8b 58 05             	mov    0x5(%eax),%ebx
    add8:	83 eb 05             	sub    $0x5,%ebx
    addb:	39 d8                	cmp    %ebx,%eax
    addd:	0f 84 20 ff ff ff    	je     ad03 <ResourceAllocation_Algorithm+0x163>
    ade3:	8b 7d e8             	mov    -0x18(%ebp),%edi
    ade6:	0b 7d ec             	or     -0x14(%ebp),%edi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ade9:	89 75 dc             	mov    %esi,-0x24(%ebp)
    adec:	89 c6                	mov    %eax,%esi
		}
	}
	if(*res_length>0)
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    adee:	0b 7d e4             	or     -0x1c(%ebp),%edi
    adf1:	eb 13                	jmp    ae06 <ResourceAllocation_Algorithm+0x266>
    adf3:	90                   	nop
    adf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    adf8:	8b 5b 05             	mov    0x5(%ebx),%ebx
    adfb:	83 eb 05             	sub    $0x5,%ebx
    adfe:	39 de                	cmp    %ebx,%esi
    ae00:	0f 84 fd fe ff ff    	je     ad03 <ResourceAllocation_Algorithm+0x163>
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
    ae06:	85 ff                	test   %edi,%edi
    ae08:	74 ee                	je     adf8 <ResourceAllocation_Algorithm+0x258>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    ae0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae0d:	8d 55 f0             	lea    -0x10(%ebp),%edx
    ae10:	89 54 24 0c          	mov    %edx,0xc(%esp)
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    ae14:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ae17:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ae1a:	89 44 24 08          	mov    %eax,0x8(%esp)
    ae1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ae21:	89 54 24 04          	mov    %edx,0x4(%esp)
    ae25:	89 da                	mov    %ebx,%edx
    ae27:	89 04 24             	mov    %eax,(%esp)
    ae2a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae2d:	e8 fc ff ff ff       	call   ae2e <ResourceAllocation_Algorithm+0x28e>
    ae32:	eb c4                	jmp    adf8 <ResourceAllocation_Algorithm+0x258>
    ae34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae38:	8b 75 e8             	mov    -0x18(%ebp),%esi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae3b:	8d 45 f0             	lea    -0x10(%ebp),%eax
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae3e:	89 d9                	mov    %ebx,%ecx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae40:	89 44 24 0c          	mov    %eax,0xc(%esp)
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae44:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae47:	89 fa                	mov    %edi,%edx
    ae49:	89 74 24 08          	mov    %esi,0x8(%esp)
    ae4d:	8b 75 ec             	mov    -0x14(%ebp),%esi
    ae50:	89 74 24 04          	mov    %esi,0x4(%esp)
    ae54:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    ae57:	89 34 24             	mov    %esi,(%esp)
					break;
    ae5a:	89 de                	mov    %ebx,%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    ae5c:	e8 fc ff ff ff       	call   ae5d <ResourceAllocation_Algorithm+0x2bd>
    ae61:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					break;
    ae64:	e9 7f fe ff ff       	jmp    ace8 <ResourceAllocation_Algorithm+0x148>
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    ae69:	e8 fc ff ff ff       	call   ae6a <ResourceAllocation_Algorithm+0x2ca>
    ae6e:	89 c2                	mov    %eax,%edx
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    ae70:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ae73:	66 03 42 0f          	add    0xf(%edx),%ax
    ae77:	66 2b 45 ec          	sub    -0x14(%ebp),%ax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    ae7b:	8d 4a 13             	lea    0x13(%edx),%ecx
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    ae7e:	66 29 f0             	sub    %si,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ae81:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ae84:	66 2b 45 e4          	sub    -0x1c(%ebp),%ax
    ae88:	66 89 42 0f          	mov    %ax,0xf(%edx)
    ae8c:	8b 46 17             	mov    0x17(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ae8f:	89 4e 17             	mov    %ecx,0x17(%esi)
	new->next = next;
    ae92:	8b 75 cc             	mov    -0x34(%ebp),%esi
	new->prev = prev;
    ae95:	89 42 17             	mov    %eax,0x17(%edx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    ae98:	89 72 13             	mov    %esi,0x13(%edx)
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    ae9b:	89 de                	mov    %ebx,%esi
	new->prev = prev;
	prev->next = new;
    ae9d:	89 08                	mov    %ecx,(%eax)
    ae9f:	31 c9                	xor    %ecx,%ecx
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
    aea1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    aea8:	e9 3b fe ff ff       	jmp    ace8 <ResourceAllocation_Algorithm+0x148>
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    aead:	8b 75 e8             	mov    -0x18(%ebp),%esi
    aeb0:	89 d9                	mov    %ebx,%ecx
    aeb2:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    aeb4:	89 44 24 0c          	mov    %eax,0xc(%esp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    aeb8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    aebb:	89 74 24 08          	mov    %esi,0x8(%esp)
    aebf:	8b 75 ec             	mov    -0x14(%ebp),%esi
    aec2:	89 74 24 04          	mov    %esi,0x4(%esp)
    aec6:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    aec9:	89 34 24             	mov    %esi,(%esp)
						break;
    aecc:	89 de                	mov    %ebx,%esi
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    aece:	e8 fc ff ff ff       	call   aecf <ResourceAllocation_Algorithm+0x32f>
    aed3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
						break;
    aed6:	e9 0d fe ff ff       	jmp    ace8 <ResourceAllocation_Algorithm+0x148>
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    aedb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
    aede:	31 f6                	xor    %esi,%esi
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
    aee0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    aee7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    aeee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    aef5:	e9 d0 fe ff ff       	jmp    adca <ResourceAllocation_Algorithm+0x22a>
    aefa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000af00 <DoResourceAllocation>:
->Output: RLC report
->Special:
*******************************
*/
void DoResourceAllocation(u32 tb_size)//
{
    af00:	55                   	push   %ebp
    af01:	89 e5                	mov    %esp,%ebp
    af03:	83 ec 10             	sub    $0x10,%esp
    af06:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    af09:	89 75 f8             	mov    %esi,-0x8(%ebp)
    af0c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    af0f:	e8 fc ff ff ff       	call   af10 <DoResourceAllocation+0x10>
    af14:	89 c7                	mov    %eax,%edi
	u32 num;
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
    af16:	b8 04 00 00 00       	mov    $0x4,%eax
    af1b:	e8 fc ff ff ff       	call   af1c <DoResourceAllocation+0x1c>
    af20:	89 c3                	mov    %eax,%ebx
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    af22:	e8 fc ff ff ff       	call   af23 <DoResourceAllocation+0x23>
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    af27:	89 da                	mov    %ebx,%edx
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    af29:	89 c6                	mov    %eax,%esi
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    af2b:	89 f8                	mov    %edi,%eax
    af2d:	e8 fc ff ff ff       	call   af2e <DoResourceAllocation+0x2e>
	SV(DATA_WAIT_ALLOCATION)=false;
    af32:	c6 86 5a 01 00 00 00 	movb   $0x0,0x15a(%esi)

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    af39:	89 c7                	mov    %eax,%edi
		printk(KERN_INFO" rlc_Report_statusPduSize:%d\n",rlc_temp[j].statusPduSize);
		printk(KERN_INFO" rlc_Report_statusPduHeader:%d\n",rlc_temp[j].statusPduHeader);
	}*/
	//fsm_printf("MAC :%d\n",sizeof(RLC_Request));
	//fsm_do_ioctrl(STRM_TO_RLC,IOCCMD_MACtoRLC_datasend_Allow,UEmac_Rlc_Report,*rlc_report_num);//MACRLC
	fsm_printf("[UEMAC][SCHEDULER]SEND DATA ALLOW IOCTL\n");
    af3b:	c7 04 24 cc 2a 00 00 	movl   $0x2acc,(%esp)
    af42:	e8 fc ff ff ff       	call   af43 <DoResourceAllocation+0x43>
	
	PMRLC_TRANSOP_IND ((void *)UEmac_Rlc_Report); 	//modify in 20150804
    af47:	89 f8                	mov    %edi,%eax
    af49:	e8 fc ff ff ff       	call   af4a <DoResourceAllocation+0x4a>
	//fsm_mem_free(UEmac_Rlc_Report);//report 
	fsm_mem_free(rlc_report_num);
    af4e:	89 d8                	mov    %ebx,%eax
    af50:	e8 fc ff ff ff       	call   af51 <DoResourceAllocation+0x51>
	FOUT;

}
    af55:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    af58:	8b 75 f8             	mov    -0x8(%ebp),%esi
    af5b:	8b 7d fc             	mov    -0x4(%ebp),%edi
    af5e:	89 ec                	mov    %ebp,%esp
    af60:	5d                   	pop    %ebp
    af61:	c3                   	ret    
    af62:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    af69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000af70 <Free_Uemac_Scheduler_Resource>:
->Output:
->Special:
*******************************
*/
void Free_Uemac_Scheduler_Resource(void)
{
    af70:	55                   	push   %ebp
    af71:	89 e5                	mov    %esp,%ebp
    af73:	57                   	push   %edi
    af74:	56                   	push   %esi
    af75:	53                   	push   %ebx
    af76:	e8 fc ff ff ff       	call   af77 <Free_Uemac_Scheduler_Resource+0x7>
	struct list_head *pos,*p;
	MacBufferStatus *temp_rlc_free=NULL;
	LogicalChannelBj *temp_bj_free=NULL;
	LogicalChannelConfigInfo *temp_lcginfo_free=NULL;//

	SV_PTR_GET(rlc_mac_sv);
    af7b:	e8 fc ff ff ff       	call   af7c <Free_Uemac_Scheduler_Resource+0xc>
    af80:	89 c6                	mov    %eax,%esi
	fsm_mem_free(SV(bsr));
    af82:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
    af88:	e8 fc ff ff ff       	call   af89 <Free_Uemac_Scheduler_Resource+0x19>
	//fsm_mem_free(Frame_No_Allocation);
	if(SV(Regularbsr)!=NULL)
    af8d:	8b 86 4c 01 00 00    	mov    0x14c(%esi),%eax
    af93:	85 c0                	test   %eax,%eax
    af95:	74 0f                	je     afa6 <Free_Uemac_Scheduler_Resource+0x36>
	{
		fsm_mem_free(SV(Regularbsr));
    af97:	e8 fc ff ff ff       	call   af98 <Free_Uemac_Scheduler_Resource+0x28>
		SV(Regularbsr)=NULL;
    af9c:	c7 86 4c 01 00 00 00 	movl   $0x0,0x14c(%esi)
    afa3:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    afa6:	8b 86 50 01 00 00    	mov    0x150(%esi),%eax
    afac:	85 c0                	test   %eax,%eax
    afae:	74 0f                	je     afbf <Free_Uemac_Scheduler_Resource+0x4f>
	{
		fsm_mem_free(SV(Periodicbsr));
    afb0:	e8 fc ff ff ff       	call   afb1 <Free_Uemac_Scheduler_Resource+0x41>
		SV(Periodicbsr)=NULL;
    afb5:	c7 86 50 01 00 00 00 	movl   $0x0,0x150(%esi)
    afbc:	00 00 00 
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    afbf:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    afc5:	8b 58 05             	mov    0x5(%eax),%ebx
    afc8:	83 c0 05             	add    $0x5,%eax
    afcb:	39 c3                	cmp    %eax,%ebx
    afcd:	8b 3b                	mov    (%ebx),%edi
    afcf:	75 0b                	jne    afdc <Free_Uemac_Scheduler_Resource+0x6c>
    afd1:	eb 37                	jmp    b00a <Free_Uemac_Scheduler_Resource+0x9a>
    afd3:	90                   	nop
    afd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    afd8:	89 fb                	mov    %edi,%ebx
    afda:	89 d7                	mov    %edx,%edi
	{
		temp_rlc_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_rlc_free->RlcRequestparams);
    afdc:	8b 43 fc             	mov    -0x4(%ebx),%eax
    afdf:	e8 fc ff ff ff       	call   afe0 <Free_Uemac_Scheduler_Resource+0x70>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    afe4:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_rlc_free->list));
    afe7:	8d 43 fb             	lea    -0x5(%ebx),%eax
    afea:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    afec:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    afef:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aff1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    aff3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_rlc_free);
    aff6:	e8 fc ff ff ff       	call   aff7 <Free_Uemac_Scheduler_Resource+0x87>
	if(SV(Periodicbsr)!=NULL)
	{
		fsm_mem_free(SV(Periodicbsr));
		SV(Periodicbsr)=NULL;
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    affb:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b001:	8b 17                	mov    (%edi),%edx
    b003:	83 c0 05             	add    $0x5,%eax
    b006:	39 c7                	cmp    %eax,%edi
    b008:	75 ce                	jne    afd8 <Free_Uemac_Scheduler_Resource+0x68>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b00a:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b010:	8b 50 05             	mov    0x5(%eax),%edx
    b013:	83 c0 05             	add    $0x5,%eax
    b016:	39 c2                	cmp    %eax,%edx
    b018:	8b 1a                	mov    (%edx),%ebx
    b01a:	75 06                	jne    b022 <Free_Uemac_Scheduler_Resource+0xb2>
    b01c:	eb 2a                	jmp    b048 <Free_Uemac_Scheduler_Resource+0xd8>
    b01e:	66 90                	xchg   %ax,%ax
    b020:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b022:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
    b025:	8d 42 fb             	lea    -0x5(%edx),%eax
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b028:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b02a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b02d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b02f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b031:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
    b034:	e8 fc ff ff ff       	call   b035 <Free_Uemac_Scheduler_Resource+0xc5>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b039:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b03f:	8b 1b                	mov    (%ebx),%ebx
    b041:	83 c0 05             	add    $0x5,%eax
    b044:	39 c7                	cmp    %eax,%edi
    b046:	75 d8                	jne    b020 <Free_Uemac_Scheduler_Resource+0xb0>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b048:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b04e:	8b 50 11             	mov    0x11(%eax),%edx
    b051:	83 c0 11             	add    $0x11,%eax
    b054:	39 c2                	cmp    %eax,%edx
    b056:	8b 1a                	mov    (%edx),%ebx
    b058:	75 08                	jne    b062 <Free_Uemac_Scheduler_Resource+0xf2>
    b05a:	eb 2c                	jmp    b088 <Free_Uemac_Scheduler_Resource+0x118>
    b05c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b060:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b062:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
    b065:	8d 42 ef             	lea    -0x11(%edx),%eax
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b068:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b06a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b06d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b06f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b071:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
    b074:	e8 fc ff ff ff       	call   b075 <Free_Uemac_Scheduler_Resource+0x105>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b079:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b07f:	8b 1b                	mov    (%ebx),%ebx
    b081:	83 c0 11             	add    $0x11,%eax
    b084:	39 c7                	cmp    %eax,%edi
    b086:	75 d8                	jne    b060 <Free_Uemac_Scheduler_Resource+0xf0>
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
	}
	fsm_mem_free(SV(MacBuffer_RLC));
    b088:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b08e:	e8 fc ff ff ff       	call   b08f <Free_Uemac_Scheduler_Resource+0x11f>
	fsm_mem_free(SV(LogicalChannel_Bj));
    b093:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b099:	e8 fc ff ff ff       	call   b09a <Free_Uemac_Scheduler_Resource+0x12a>
	fsm_mem_free(SV(LogicalChannel_Config));
    b09e:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b0a4:	e8 fc ff ff ff       	call   b0a5 <Free_Uemac_Scheduler_Resource+0x135>
	
	FOUT;
}
    b0a9:	5b                   	pop    %ebx
    b0aa:	5e                   	pop    %esi
    b0ab:	5f                   	pop    %edi
    b0ac:	5d                   	pop    %ebp
    b0ad:	c3                   	ret    
    b0ae:	66 90                	xchg   %ax,%ax

0000b0b0 <GetRbsize>:
->Output:
->Special:
*******************************
*/
u32 GetRbsize(u32  channel_bandwidth)
{
    b0b0:	55                   	push   %ebp
    b0b1:	89 e5                	mov    %esp,%ebp
    b0b3:	83 ec 04             	sub    $0x4,%esp
    b0b6:	e8 fc ff ff ff       	call   b0b7 <GetRbsize+0x7>

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b0bb:	83 e8 03             	sub    $0x3,%eax
    b0be:	83 f8 11             	cmp    $0x11,%eax
    b0c1:	76 15                	jbe    b0d8 <GetRbsize+0x28>
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
    b0c3:	c7 04 24 f8 2a 00 00 	movl   $0x2af8,(%esp)
    b0ca:	e8 fc ff ff ff       	call   b0cb <GetRbsize+0x1b>
    b0cf:	31 c0                	xor    %eax,%eax
	}
	//}
	FRET(rbsize);
}
    b0d1:	c9                   	leave  
    b0d2:	c3                   	ret    
    b0d3:	90                   	nop
    b0d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b0d8:	ff 24 85 e0 03 00 00 	jmp    *0x3e0(,%eax,4)
    b0df:	90                   	nop
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
    b0e0:	b8 64 00 00 00       	mov    $0x64,%eax
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b0e5:	c9                   	leave  
    b0e6:	c3                   	ret    
    b0e7:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b0e8:	b8 0f 00 00 00       	mov    $0xf,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b0ed:	c9                   	leave  
    b0ee:	c3                   	ret    
    b0ef:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b0f0:	b8 19 00 00 00       	mov    $0x19,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b0f5:	c9                   	leave  
    b0f6:	c3                   	ret    
    b0f7:	90                   	nop
	// {
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
    b0f8:	b8 32 00 00 00       	mov    $0x32,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b0fd:	c9                   	leave  
    b0fe:	c3                   	ret    
    b0ff:	90                   	nop
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
    b100:	b8 4b 00 00 00       	mov    $0x4b,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b105:	c9                   	leave  
    b106:	c3                   	ret    
    b107:	89 f6                	mov    %esi,%esi
    b109:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b110 <DoReceiveULgrant_Tbsize>:
    //???????????????? delay
    FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    b110:	55                   	push   %ebp
    b111:	89 e5                	mov    %esp,%ebp
    b113:	83 ec 20             	sub    $0x20,%esp
    b116:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b119:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b11c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b11f:	e8 fc ff ff ff       	call   b120 <DoReceiveULgrant_Tbsize+0x10>
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b124:	89 c7                	mov    %eax,%edi
    u16 mcs=receive_ulgrant.m_mcs;//20140725
    b126:	c1 e8 0f             	shr    $0xf,%eax
    b129:	83 e0 1f             	and    $0x1f,%eax
    b12c:	88 45 e4             	mov    %al,-0x1c(%ebp)
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b12f:	c1 ef 02             	shr    $0x2,%edi
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b132:	e8 fc ff ff ff       	call   b133 <DoReceiveULgrant_Tbsize+0x23>
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b137:	66 81 e7 ff 1f       	and    $0x1fff,%di
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b13c:	89 c3                	mov    %eax,%ebx
    rb_number=GetRbsize(BANDWIDTH);
    b13e:	b8 14 00 00 00       	mov    $0x14,%eax
    b143:	e8 fc ff ff ff       	call   b144 <DoReceiveULgrant_Tbsize+0x34>
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b148:	31 d2                	xor    %edx,%edx
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    b14a:	89 c6                	mov    %eax,%esi
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b14c:	89 f8                	mov    %edi,%eax
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b14e:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b152:	66 f7 f6             	div    %si
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b155:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b15b:	8d 4e 01             	lea    0x1(%esi),%ecx
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b15e:	01 c2                	add    %eax,%edx
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b160:	66 29 c1             	sub    %ax,%cx
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    b163:	83 c0 01             	add    $0x1,%eax
    b166:	66 39 d6             	cmp    %dx,%si
    b169:	0f 47 c8             	cmova  %eax,%ecx
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b16c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b170:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME2 && (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME7)
    b176:	8d 50 01             	lea    0x1(%eax),%edx
    b179:	83 fa 04             	cmp    $0x4,%edx
    b17c:	77 3a                	ja     b1b8 <DoReceiveULgrant_Tbsize+0xa8>
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
    b17e:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b182:	66 c7 43 10 07 00    	movw   $0x7,0x10(%ebx)
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b188:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b18c:	0f b7 c9             	movzwl %cx,%ecx
    b18f:	8d 44 49 fd          	lea    -0x3(%ecx,%ecx,2),%eax
    b193:	8d 04 c0             	lea    (%eax,%eax,8),%eax
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b196:	83 e2 1f             	and    $0x1f,%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b199:	03 04 95 40 04 00 00 	add    0x440(,%edx,4),%eax
    b1a0:	8b 34 85 c0 04 00 00 	mov    0x4c0(,%eax,4),%esi
    //FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}
    b1a7:	89 f0                	mov    %esi,%eax
    b1a9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b1ac:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b1af:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b1b2:	89 ec                	mov    %ebp,%esp
    b1b4:	5d                   	pop    %ebp
    b1b5:	c3                   	ret    
    b1b6:	66 90                	xchg   %ax,%ax
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME7 && (SCHEDULE_ADVANCE+temp_subframe)<=9)
    b1b8:	8d 50 fc             	lea    -0x4(%eax),%edx
    b1bb:	83 fa 01             	cmp    $0x1,%edx
    b1be:	76 26                	jbe    b1e6 <DoReceiveULgrant_Tbsize+0xd6>
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b1c0:	83 c0 04             	add    $0x4,%eax
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
    b1c3:	31 f6                	xor    %esi,%esi
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b1c5:	83 f8 09             	cmp    $0x9,%eax
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b1c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b1cb:	7e da                	jle    b1a7 <DoReceiveULgrant_Tbsize+0x97>
    b1cd:	ba 67 66 66 66       	mov    $0x66666667,%edx
    b1d2:	f7 ea                	imul   %edx
    b1d4:	c1 ea 02             	shr    $0x2,%edx
    b1d7:	8d 04 92             	lea    (%edx,%edx,4),%eax
    b1da:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b1dd:	01 c0                	add    %eax,%eax
    b1df:	29 c2                	sub    %eax,%edx
    b1e1:	83 fa 02             	cmp    $0x2,%edx
    b1e4:	7f c1                	jg     b1a7 <DoReceiveULgrant_Tbsize+0x97>
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b1e6:	83 c7 01             	add    $0x1,%edi
    b1e9:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b1ed:	66 c7 43 10 02 00    	movw   $0x2,0x10(%ebx)
    b1f3:	eb 93                	jmp    b188 <DoReceiveULgrant_Tbsize+0x78>
    b1f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b1f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b200 <My_Pow>:
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b200:	55                   	push   %ebp
    b201:	89 e5                	mov    %esp,%ebp
    b203:	53                   	push   %ebx
    b204:	e8 fc ff ff ff       	call   b205 <My_Pow+0x5>
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b209:	85 d2                	test   %edx,%edx
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b20b:	89 c1                	mov    %eax,%ecx
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b20d:	b8 01 00 00 00       	mov    $0x1,%eax
    b212:	74 16                	je     b22a <My_Pow+0x2a>
    b214:	bb 01 00 00 00       	mov    $0x1,%ebx
    b219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b220:	83 c3 01             	add    $0x1,%ebx
		powint*=num;
    b223:	0f af c1             	imul   %ecx,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b226:	39 da                	cmp    %ebx,%edx
    b228:	73 f6                	jae    b220 <My_Pow+0x20>
		powint*=num;
	FRET(powint);
}
    b22a:	5b                   	pop    %ebx
    b22b:	5d                   	pop    %ebp
    b22c:	c3                   	ret    
    b22d:	8d 76 00             	lea    0x0(%esi),%esi

0000b230 <My_Log2>:
->Output:log2(rb)
->Special:
*******************************
*/
u32 My_Log2(u32 rb)
{
    b230:	55                   	push   %ebp
    b231:	89 e5                	mov    %esp,%ebp
    b233:	83 ec 04             	sub    $0x4,%esp
    b236:	e8 fc ff ff ff       	call   b237 <My_Log2+0x7>
	ret=0;
	switch(rb)//20140514modified by lhl float
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
    b23b:	ba 98 20 00 00       	mov    $0x2098,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b240:	83 f8 19             	cmp    $0x19,%eax
    b243:	74 23                	je     b268 <My_Log2+0x38>
    b245:	76 29                	jbe    b270 <My_Log2+0x40>
    b247:	83 f8 4b             	cmp    $0x4b,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
    b24a:	ba d5 2c 00 00       	mov    $0x2cd5,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b24f:	74 17                	je     b268 <My_Log2+0x38>
    b251:	83 f8 64             	cmp    $0x64,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
    b254:	66 ba 0e 30          	mov    $0x300e,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b258:	74 0e                	je     b268 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b25a:	c7 04 24 2c 2b 00 00 	movl   $0x2b2c,(%esp)
    b261:	e8 fc ff ff ff       	call   b262 <My_Log2+0x32>
    b266:	31 d2                	xor    %edx,%edx
	}
	FRET(ret);
}//2
    b268:	89 d0                	mov    %edx,%eax
    b26a:	c9                   	leave  
    b26b:	c3                   	ret    
    b26c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b270:	83 f8 06             	cmp    $0x6,%eax
	{
		case 6   : ret=4392 ;break;
    b273:	66 ba 28 11          	mov    $0x1128,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b277:	74 ef                	je     b268 <My_Log2+0x38>
    b279:	83 f8 0f             	cmp    $0xf,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
    b27c:	66 ba fb 1a          	mov    $0x1afb,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b280:	74 e6                	je     b268 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b282:	c7 04 24 2c 2b 00 00 	movl   $0x2b2c,(%esp)
    b289:	e8 fc ff ff ff       	call   b28a <My_Log2+0x5a>
    b28e:	31 d2                	xor    %edx,%edx
    b290:	eb d6                	jmp    b268 <My_Log2+0x38>
    b292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b2a0 <DoReceiveRARULgrant_Tbsize>:
->Output:
->Special:
*******************************
*/
u32 DoReceiveRARULgrant_Tbsize(RAR_ULgrant *receive_rar_ulgrant)
{
    b2a0:	55                   	push   %ebp
    b2a1:	89 e5                	mov    %esp,%ebp
    b2a3:	57                   	push   %edi
    b2a4:	56                   	push   %esi
    b2a5:	53                   	push   %ebx
    b2a6:	83 ec 1c             	sub    $0x1c,%esp
    b2a9:	e8 fc ff ff ff       	call   b2aa <DoReceiveRARULgrant_Tbsize+0xa>
    b2ae:	89 c6                	mov    %eax,%esi
	u16 rb_number;
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
    b2b0:	e8 fc ff ff ff       	call   b2b1 <DoReceiveRARULgrant_Tbsize+0x11>
    b2b5:	89 c7                	mov    %eax,%edi
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
    b2b7:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b2bb:	c0 e8 03             	shr    $0x3,%al
    b2be:	83 e0 0f             	and    $0xf,%eax
    b2c1:	88 45 f1             	mov    %al,-0xf(%ebp)
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b2c4:	0f b6 06             	movzbl (%esi),%eax
    b2c7:	89 c3                	mov    %eax,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b2c9:	d0 e8                	shr    %al
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b2cb:	83 e3 01             	and    $0x1,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b2ce:	0f b6 d0             	movzbl %al,%edx
    b2d1:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b2d5:	83 e0 07             	and    $0x7,%eax
    b2d8:	c1 e0 07             	shl    $0x7,%eax
    b2db:	09 d0                	or     %edx,%eax
    b2dd:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b2e1:	0f b6 56 02          	movzbl 0x2(%esi),%edx
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b2e5:	b8 14 00 00 00       	mov    $0x14,%eax
	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b2ea:	c0 ea 02             	shr    $0x2,%dl
    b2ed:	83 e2 01             	and    $0x1,%edx
    b2f0:	88 55 f0             	mov    %dl,-0x10(%ebp)
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b2f3:	e8 fc ff ff ff       	call   b2f4 <DoReceiveRARULgrant_Tbsize+0x54>
	if(rb_number<=44)
    b2f8:	66 83 f8 2c          	cmp    $0x2c,%ax
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b2fc:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	if(rb_number<=44)
    b300:	0f 86 6a 01 00 00    	jbe    b470 <DoReceiveRARULgrant_Tbsize+0x1d0>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b306:	84 db                	test   %bl,%bl
    b308:	0f 85 b2 00 00 00    	jne    b3c0 <DoReceiveRARULgrant_Tbsize+0x120>
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b30e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b312:	bb 0a 00 00 00       	mov    $0xa,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b317:	e8 fc ff ff ff       	call   b318 <DoReceiveRARULgrant_Tbsize+0x78>
    b31c:	31 d2                	xor    %edx,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b31e:	b8 01 00 00 00       	mov    $0x1,%eax
    b323:	b9 01 00 00 00       	mov    $0x1,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b328:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b32b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b32d:	39 d8                	cmp    %ebx,%eax
    b32f:	76 f7                	jbe    b328 <DoReceiveRARULgrant_Tbsize+0x88>
    b331:	83 e9 01             	sub    $0x1,%ecx
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
    b334:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b338:	09 d1                	or     %edx,%ecx
    b33a:	31 d2                	xor    %edx,%edx
    b33c:	89 c8                	mov    %ecx,%eax
    b33e:	66 f7 75 f2          	divw   -0xe(%ebp)
    b342:	89 d3                	mov    %edx,%ebx
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b344:	89 c8                	mov    %ecx,%eax
    b346:	31 d2                	xor    %edx,%edx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b348:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b34c:	66 f7 75 f2          	divw   -0xe(%ebp)
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b350:	83 c1 01             	add    $0x1,%ecx
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b353:	66 29 c1             	sub    %ax,%cx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b356:	01 c3                	add    %eax,%ebx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b358:	66 39 5d f2          	cmp    %bx,-0xe(%ebp)
    b35c:	8d 50 01             	lea    0x1(%eax),%edx
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b35f:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b363:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b369:	0f 46 d1             	cmovbe %ecx,%edx
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b36c:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if(ulDelay == true)//?????????????????????????????,delay
    b370:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b374:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
	if(ulDelay == true)//?????????????????????????????,delay
    b37a:	0f 84 b8 00 00 00    	je     b438 <DoReceiveRARULgrant_Tbsize+0x198>
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b380:	66 83 f8 01          	cmp    $0x1,%ax
    b384:	76 19                	jbe    b39f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b386:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b389:	66 83 fb 04          	cmp    $0x4,%bx
    b38d:	0f 86 c5 00 00 00    	jbe    b458 <DoReceiveRARULgrant_Tbsize+0x1b8>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b393:	83 e8 07             	sub    $0x7,%eax
    b396:	66 83 f8 02          	cmp    $0x2,%ax
    b39a:	77 0d                	ja     b3a9 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b39c:	83 c1 01             	add    $0x1,%ecx
    b39f:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b3a3:	66 c7 47 10 07 00    	movw   $0x7,0x10(%edi)
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b3a9:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    b3ad:	0f b7 d2             	movzwl %dx,%edx
}
    b3b0:	83 c4 1c             	add    $0x1c,%esp
    b3b3:	5b                   	pop    %ebx
    b3b4:	5e                   	pop    %esi
    b3b5:	5f                   	pop    %edi
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b3b6:	6b c0 54             	imul   $0x54,%eax,%eax
}
    b3b9:	5d                   	pop    %ebp
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b3ba:	0f af c2             	imul   %edx,%eax
}
    b3bd:	c3                   	ret    
    b3be:	66 90                	xchg   %ax,%ax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b3c0:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3c5:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b3c9:	19 c9                	sbb    %ecx,%ecx
    b3cb:	f7 d1                	not    %ecx
    b3cd:	83 c1 09             	add    $0x9,%ecx
    b3d0:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
    b3d5:	89 cb                	mov    %ecx,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3d7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b3da:	19 f6                	sbb    %esi,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3dc:	e8 fc ff ff ff       	call   b3dd <DoReceiveRARULgrant_Tbsize+0x13d>
    b3e1:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b3e6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b3e9:	83 c6 02             	add    $0x2,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3ec:	f7 e2                	mul    %edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b3ee:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3f2:	c1 ea 06             	shr    $0x6,%edx
    b3f5:	83 ea 09             	sub    $0x9,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b3f8:	d3 f8                	sar    %cl,%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b3fa:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b3fe:	ba 01 00 00 00       	mov    $0x1,%edx
    b403:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    b407:	b8 01 00 00 00       	mov    $0x1,%eax
    b40c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b410:	83 c2 01             	add    $0x1,%edx
		powint*=num;
    b413:	01 c0                	add    %eax,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b415:	39 d6                	cmp    %edx,%esi
    b417:	73 f7                	jae    b410 <DoReceiveRARULgrant_Tbsize+0x170>
    b419:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
    b41d:	83 e8 01             	sub    $0x1,%eax
    b420:	66 23 45 dc          	and    -0x24(%ebp),%ax
    b424:	29 f2                	sub    %esi,%edx
    b426:	0f b7 c0             	movzwl %ax,%eax
    b429:	8d 4a 0a             	lea    0xa(%edx),%ecx
    b42c:	89 c2                	mov    %eax,%edx
    b42e:	d3 e2                	shl    %cl,%edx
    b430:	e9 e9 fe ff ff       	jmp    b31e <DoReceiveRARULgrant_Tbsize+0x7e>
    b435:	8d 76 00             	lea    0x0(%esi),%esi
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
	}
	else
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b438:	66 83 f8 01          	cmp    $0x1,%ax
    b43c:	76 1d                	jbe    b45b <DoReceiveRARULgrant_Tbsize+0x1bb>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b43e:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b441:	66 83 fb 04          	cmp    $0x4,%bx
    b445:	0f 86 54 ff ff ff    	jbe    b39f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b44b:	83 e8 07             	sub    $0x7,%eax
    b44e:	66 83 f8 02          	cmp    $0x2,%ax
    b452:	0f 87 51 ff ff ff    	ja     b3a9 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b458:	83 c1 01             	add    $0x1,%ecx
    b45b:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b45f:	66 c7 47 10 02 00    	movw   $0x2,0x10(%edi)
    b465:	e9 3f ff ff ff       	jmp    b3a9 <DoReceiveRARULgrant_Tbsize+0x109>
    b46a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
    b470:	0f b7 c0             	movzwl %ax,%eax
    b473:	e8 fc ff ff ff       	call   b474 <DoReceiveRARULgrant_Tbsize+0x1d4>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b478:	b9 01 00 00 00       	mov    $0x1,%ecx
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b47d:	66 c1 e8 03          	shr    $0x3,%ax
    b481:	0f b7 d0             	movzwl %ax,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b484:	b8 01 00 00 00       	mov    $0x1,%eax
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b489:	69 d2 c5 20 00 00    	imul   $0x20c5,%edx,%edx
    b48f:	c1 ea 14             	shr    $0x14,%edx
    b492:	83 c2 01             	add    $0x1,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b495:	0f b7 d2             	movzwl %dx,%edx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b498:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b49b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b49d:	39 c2                	cmp    %eax,%edx
    b49f:	73 f7                	jae    b498 <DoReceiveRARULgrant_Tbsize+0x1f8>
    b4a1:	83 e9 01             	sub    $0x1,%ecx
    b4a4:	31 d2                	xor    %edx,%edx
    b4a6:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b4aa:	89 c8                	mov    %ecx,%eax
    b4ac:	66 f7 75 f2          	divw   -0xe(%ebp)
    b4b0:	89 d3                	mov    %edx,%ebx
    b4b2:	e9 8d fe ff ff       	jmp    b344 <DoReceiveRARULgrant_Tbsize+0xa4>
    b4b7:	90                   	nop
    b4b8:	90                   	nop
    b4b9:	90                   	nop
    b4ba:	90                   	nop
    b4bb:	90                   	nop
    b4bc:	90                   	nop
    b4bd:	90                   	nop
    b4be:	90                   	nop
    b4bf:	90                   	nop

0000b4c0 <creat_subhead.isra.0>:
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b4c0:	55                   	push   %ebp
    b4c1:	89 e5                	mov    %esp,%ebp
    b4c3:	83 ec 10             	sub    $0x10,%esp
    b4c6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b4c9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b4cc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b4cf:	e8 fc ff ff ff       	call   b4d0 <creat_subhead.isra.0+0x10>
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b4d4:	83 38 7f             	cmpl   $0x7f,(%eax)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b4d7:	8b 75 0c             	mov    0xc(%ebp),%esi
    b4da:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
    b4de:	89 4d f0             	mov    %ecx,-0x10(%ebp)
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b4e1:	76 3d                	jbe    b520 <creat_subhead.isra.0+0x60>
		*data += 2;
		//fsm_printf("the data is %d\n",  *data);
	}
	else
	{
		subfif= (MRLC_subHead_fif_IciMsg *)*ptr;
    b4e3:	8b 1a                	mov    (%edx),%ebx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
    b4e5:	83 e7 1f             	and    $0x1f,%edi
    b4e8:	83 cf 20             	or     $0x20,%edi
    b4eb:	89 f9                	mov    %edi,%ecx
    b4ed:	88 0b                	mov    %cl,(%ebx)
		subfif->fandl1 = skb->len>>8;
    b4ef:	8b 38                	mov    (%eax),%edi
    b4f1:	c1 ef 08             	shr    $0x8,%edi
		subfif->fandl1 |= 0x80;
    b4f4:	83 cf 80             	or     $0xffffff80,%edi
    b4f7:	89 f9                	mov    %edi,%ecx
    b4f9:	88 4b 01             	mov    %cl,0x1(%ebx)
		subfif->fandl2 = skb->len&0xff;
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b4fc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
		subfif->fandl1 = skb->len>>8;
		subfif->fandl1 |= 0x80;
		subfif->fandl2 = skb->len&0xff;
    b4ff:	8b 00                	mov    (%eax),%eax
    b501:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b504:	89 19                	mov    %ebx,(%ecx)
		*ptr = subfif + 1;
    b506:	83 c3 03             	add    $0x3,%ebx
    b509:	89 1a                	mov    %ebx,(%edx)
		*data += 3;
    b50b:	83 06 03             	addl   $0x3,(%esi)
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b50e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b511:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b514:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b517:	89 ec                	mov    %ebp,%esp
    b519:	5d                   	pop    %ebp
    b51a:	c3                   	ret    
    b51b:	90                   	nop
    b51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
	{
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
    b520:	8b 0a                	mov    (%edx),%ecx
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
    b522:	83 e7 1f             	and    $0x1f,%edi
    b525:	83 cf 20             	or     $0x20,%edi
    b528:	89 fb                	mov    %edi,%ebx
    b52a:	88 19                	mov    %bl,(%ecx)
		subsev->fandl = skb->len;
    b52c:	8b 00                	mov    (%eax),%eax
		subsev->fandl  &= 0x7f;
		*preptr = subsev;
		*ptr = subsev+1;
    b52e:	8d 59 02             	lea    0x2(%ecx),%ebx
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
		subsev->fandl = skb->len;
		subsev->fandl  &= 0x7f;
    b531:	83 e0 7f             	and    $0x7f,%eax
    b534:	88 41 01             	mov    %al,0x1(%ecx)
		*preptr = subsev;
    b537:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b53a:	89 08                	mov    %ecx,(%eax)
		*ptr = subsev+1;
    b53c:	89 1a                	mov    %ebx,(%edx)
		*data += 2;
    b53e:	83 06 02             	addl   $0x2,(%esi)
		*preptr = subfif;
		*ptr = subfif + 1;
		*data += 3;
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b541:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b544:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b547:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b54a:	89 ec                	mov    %ebp,%esp
    b54c:	5d                   	pop    %ebp
    b54d:	c3                   	ret    
    b54e:	66 90                	xchg   %ax,%ax

0000b550 <PCRLC_CONFIG_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_CONFIG_REQ(void)
{
    b550:	55                   	push   %ebp
    b551:	89 e5                	mov    %esp,%ebp
    b553:	56                   	push   %esi
    b554:	53                   	push   %ebx
    b555:	83 ec 10             	sub    $0x10,%esp
    b558:	e8 fc ff ff ff       	call   b559 <PCRLC_CONFIG_REQ+0x9>
	CRLC_ReConfigReq_IoctrlMsg *cIoctrl = (CRLC_ReConfigReq_IoctrlMsg*)fsm_data_get();
    b55d:	e8 fc ff ff ff       	call   b55e <PCRLC_CONFIG_REQ+0xe>
    b562:	89 c3                	mov    %eax,%ebx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b564:	e8 fc ff ff ff       	call   b565 <PCRLC_CONFIG_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b569:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b56c:	89 c6                	mov    %eax,%esi
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b56e:	0f b6 03             	movzbl (%ebx),%eax
    b571:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    b577:	89 14 24             	mov    %edx,(%esp)
    b57a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    b57d:	e8 fc ff ff ff       	call   b57e <PCRLC_CONFIG_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
    b582:	c7 04 24 50 2b 00 00 	movl   $0x2b50,(%esp)
    b589:	e8 fc ff ff ff       	call   b58a <PCRLC_CONFIG_REQ+0x3a>
	switch(cIoctrl->Mode)
    b58e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
    b592:	66 83 f8 02          	cmp    $0x2,%ax
    b596:	0f 84 b4 00 00 00    	je     b650 <PCRLC_CONFIG_REQ+0x100>
    b59c:	77 2a                	ja     b5c8 <PCRLC_CONFIG_REQ+0x78>
    b59e:	66 83 f8 01          	cmp    $0x1,%ax
    b5a2:	0f 84 e0 00 00 00    	je     b688 <PCRLC_CONFIG_REQ+0x138>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
		}
		break;

	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
    b5a8:	c7 04 24 b0 2d 00 00 	movl   $0x2db0,(%esp)
    b5af:	e8 fc ff ff ff       	call   b5b0 <PCRLC_CONFIG_REQ+0x60>
		break;

	}
	fsm_data_destroy(cIoctrl);
    b5b4:	89 d8                	mov    %ebx,%eax
    b5b6:	e8 fc ff ff ff       	call   b5b7 <PCRLC_CONFIG_REQ+0x67>
	cIoctrl = NULL;
	FOUT;
}
    b5bb:	83 c4 10             	add    $0x10,%esp
    b5be:	5b                   	pop    %ebx
    b5bf:	5e                   	pop    %esi
    b5c0:	5d                   	pop    %ebp
    b5c1:	c3                   	ret    
    b5c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
    b5c8:	66 83 f8 03          	cmp    $0x3,%ax
    b5cc:	74 4a                	je     b618 <PCRLC_CONFIG_REQ+0xc8>
    b5ce:	66 83 f8 04          	cmp    $0x4,%ax
    b5d2:	75 d4                	jne    b5a8 <PCRLC_CONFIG_REQ+0x58>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
		}
		break;

	case UM_DOWN:			//UM
		if(SV(ins_mode) == UM_MODE)
    b5d4:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b5db:	0f 85 3f 01 00 00    	jne    b720 <PCRLC_CONFIG_REQ+0x1d0>
		{
			if(insptrd == NULL)
    b5e1:	8b 75 f4             	mov    -0xc(%ebp),%esi
    b5e4:	85 f6                	test   %esi,%esi
    b5e6:	74 cc                	je     b5b4 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b5e8:	0f b6 03             	movzbl (%ebx),%eax
    b5eb:	c7 04 24 74 2c 00 00 	movl   $0x2c74,(%esp)
    b5f2:	89 44 24 04          	mov    %eax,0x4(%esp)
    b5f6:	e8 fc ff ff ff       	call   b5f7 <PCRLC_CONFIG_REQ+0xa7>
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b5fb:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
    b5ff:	66 89 46 06          	mov    %ax,0x6(%esi)
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
    b603:	8b 43 08             	mov    0x8(%ebx),%eax
    b606:	89 46 10             	mov    %eax,0x10(%esi)
	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
		break;

	}
	fsm_data_destroy(cIoctrl);
    b609:	89 d8                	mov    %ebx,%eax
    b60b:	e8 fc ff ff ff       	call   b60c <PCRLC_CONFIG_REQ+0xbc>
	cIoctrl = NULL;
	FOUT;
}
    b610:	83 c4 10             	add    $0x10,%esp
    b613:	5b                   	pop    %ebx
    b614:	5e                   	pop    %esi
    b615:	5d                   	pop    %ebp
    b616:	c3                   	ret    
    b617:	90                   	nop
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
		}
		break;

	case UM_UP:			//UM
		if(SV(ins_mode) ==  UM_MODE)
    b618:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b61f:	0f 85 e3 00 00 00    	jne    b708 <PCRLC_CONFIG_REQ+0x1b8>
		{
			if(insptru == NULL)
    b625:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b628:	85 f6                	test   %esi,%esi
    b62a:	74 88                	je     b5b4 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b62c:	0f b6 03             	movzbl (%ebx),%eax
    b62f:	c7 04 24 20 2c 00 00 	movl   $0x2c20,(%esp)
    b636:	89 44 24 04          	mov    %eax,0x4(%esp)
    b63a:	e8 fc ff ff ff       	call   b63b <PCRLC_CONFIG_REQ+0xeb>
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b63f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b643:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b647:	e9 68 ff ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b64c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
		}
		break;

	case UM_UPDOWN:              	 //UM
		if(SV(ins_mode) == UM_MODE)
    b650:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b657:	0f 85 93 00 00 00    	jne    b6f0 <PCRLC_CONFIG_REQ+0x1a0>
		{
			if(insptru != NULL)
    b65d:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b660:	85 f6                	test   %esi,%esi
    b662:	0f 84 79 ff ff ff    	je     b5e1 <PCRLC_CONFIG_REQ+0x91>
			{
				umTxIns = (UM_TX_Instance *)insptru;
				fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b668:	0f b6 03             	movzbl (%ebx),%eax
    b66b:	c7 04 24 20 2c 00 00 	movl   $0x2c20,(%esp)
    b672:	89 44 24 04          	mov    %eax,0x4(%esp)
    b676:	e8 fc ff ff ff       	call   b677 <PCRLC_CONFIG_REQ+0x127>
				umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b67b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b67f:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b683:	e9 59 ff ff ff       	jmp    b5e1 <PCRLC_CONFIG_REQ+0x91>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		if(SV(ins_mode) == AM_MODE)
    b688:	83 be 18 02 00 00 03 	cmpl   $0x3,0x218(%esi)
    b68f:	0f 85 a3 00 00 00    	jne    b738 <PCRLC_CONFIG_REQ+0x1e8>
		{
			if(insptru == NULL)
    b695:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b698:	85 f6                	test   %esi,%esi
    b69a:	0f 84 14 ff ff ff    	je     b5b4 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			amIns = (AM_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:am instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b6a0:	0f b6 03             	movzbl (%ebx),%eax
    b6a3:	c7 04 24 84 2b 00 00 	movl   $0x2b84,(%esp)
    b6aa:	89 44 24 04          	mov    %eax,0x4(%esp)
    b6ae:	e8 fc ff ff ff       	call   b6af <PCRLC_CONFIG_REQ+0x15f>
			amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
    b6b3:	8b 43 14             	mov    0x14(%ebx),%eax
    b6b6:	89 46 1c             	mov    %eax,0x1c(%esi)
			amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
    b6b9:	8b 43 10             	mov    0x10(%ebx),%eax
    b6bc:	89 46 28             	mov    %eax,0x28(%esi)
			amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
    b6bf:	8b 43 18             	mov    0x18(%ebx),%eax
    b6c2:	89 46 10             	mov    %eax,0x10(%esi)
			amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    b6c5:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
    b6c9:	66 89 86 f6 22 00 00 	mov    %ax,0x22f6(%esi)
			amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    b6d0:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
    b6d4:	66 89 86 f8 22 00 00 	mov    %ax,0x22f8(%esi)
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    b6db:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
    b6df:	66 89 86 fa 22 00 00 	mov    %ax,0x22fa(%esi)
			break;
    b6e6:	e9 c9 fe ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b6eb:	90                   	nop
    b6ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
    b6f0:	c7 04 24 c8 2c 00 00 	movl   $0x2cc8,(%esp)
    b6f7:	e8 fc ff ff ff       	call   b6f8 <PCRLC_CONFIG_REQ+0x1a8>
    b6fc:	e9 b3 fe ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b701:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
    b708:	c7 04 24 14 2d 00 00 	movl   $0x2d14,(%esp)
    b70f:	e8 fc ff ff ff       	call   b710 <PCRLC_CONFIG_REQ+0x1c0>
    b714:	e9 9b fe ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
    b720:	c7 04 24 60 2d 00 00 	movl   $0x2d60,(%esp)
    b727:	e8 fc ff ff ff       	call   b728 <PCRLC_CONFIG_REQ+0x1d8>
    b72c:	e9 83 fe ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
			break;
		}
		else
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
    b738:	c7 04 24 d4 2b 00 00 	movl   $0x2bd4,(%esp)
    b73f:	e8 fc ff ff ff       	call   b740 <PCRLC_CONFIG_REQ+0x1f0>
		}
		break;
    b744:	e9 6b fe ff ff       	jmp    b5b4 <PCRLC_CONFIG_REQ+0x64>
    b749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000b750 <PCRLC_BULID_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_BULID_REQ(void)
{
    b750:	55                   	push   %ebp
    b751:	89 e5                	mov    %esp,%ebp
    b753:	57                   	push   %edi
    b754:	56                   	push   %esi
    b755:	53                   	push   %ebx
    b756:	83 ec 0c             	sub    $0xc,%esp
    b759:	e8 fc ff ff ff       	call   b75a <PCRLC_BULID_REQ+0xa>
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
	
	SV_PTR_GET(rlc_mac_sv);
    b75e:	e8 fc ff ff ff       	call   b75f <PCRLC_BULID_REQ+0xf>
    b763:	89 c6                	mov    %eax,%esi
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
    b765:	c7 04 24 e0 2d 00 00 	movl   $0x2de0,(%esp)
    b76c:	e8 fc ff ff ff       	call   b76d <PCRLC_BULID_REQ+0x1d>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
    b771:	e8 fc ff ff ff       	call   b772 <PCRLC_BULID_REQ+0x22>
    b776:	89 c7                	mov    %eax,%edi
	switch(cIoctrl->Mode)
    b778:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b77c:	66 83 f8 02          	cmp    $0x2,%ax
    b780:	0f 84 e2 01 00 00    	je     b968 <PCRLC_BULID_REQ+0x218>
    b786:	77 38                	ja     b7c0 <PCRLC_BULID_REQ+0x70>
    b788:	66 83 f8 01          	cmp    $0x1,%ax
    b78c:	0f 84 4f 03 00 00    	je     bae1 <PCRLC_BULID_REQ+0x391>
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
		break;

	default:
		fsm_printf("[RLC][PCRLC_BULID_REQ] wrong CRLC_BULID_REQ");
    b792:	c7 04 24 0c 30 00 00 	movl   $0x300c,(%esp)
    b799:	e8 fc ff ff ff       	call   b79a <PCRLC_BULID_REQ+0x4a>
		break;

	}
	
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    b79e:	b8 01 00 00 00       	mov    $0x1,%eax
    b7a3:	e8 fc ff ff ff       	call   b7a4 <PCRLC_BULID_REQ+0x54>
	cItrl->V_Flag = true;
    b7a8:	c6 00 01             	movb   $0x1,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    b7ab:	e8 fc ff ff ff       	call   b7ac <PCRLC_BULID_REQ+0x5c>
	cItrl = NULL;
	fsm_data_destroy(cIoctrl);
    b7b0:	89 f8                	mov    %edi,%eax
    b7b2:	e8 fc ff ff ff       	call   b7b3 <PCRLC_BULID_REQ+0x63>
	cIoctrl = NULL;
	FOUT;
}
    b7b7:	83 c4 0c             	add    $0xc,%esp
    b7ba:	5b                   	pop    %ebx
    b7bb:	5e                   	pop    %esi
    b7bc:	5f                   	pop    %edi
    b7bd:	5d                   	pop    %ebp
    b7be:	c3                   	ret    
    b7bf:	90                   	nop
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
    b7c0:	66 83 f8 03          	cmp    $0x3,%ax
    b7c4:	0f 84 22 01 00 00    	je     b8ec <PCRLC_BULID_REQ+0x19c>
    b7ca:	66 83 f8 04          	cmp    $0x4,%ax
    b7ce:	75 c2                	jne    b792 <PCRLC_BULID_REQ+0x42>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    b7d0:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    b7d5:	e8 fc ff ff ff       	call   b7d6 <PCRLC_BULID_REQ+0x86>
    b7da:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b7dc:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    b7e0:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b7e4:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    b7e8:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b7ef:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    b7f2:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    b7f6:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    b7f9:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b7fc:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    b803:	00 00 
    b805:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    b80c:	00 00 
    b80e:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    b815:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    b817:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    b81a:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b81c:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    b822:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    b829:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    b830:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    b836:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    b83c:	eb 0d                	jmp    b84b <PCRLC_BULID_REQ+0xfb>
    b83e:	66 90                	xchg   %ax,%ax
    b840:	83 fa 32             	cmp    $0x32,%edx
    b843:	0f 84 52 05 00 00    	je     bd9b <PCRLC_BULID_REQ+0x64b>
    b849:	89 d0                	mov    %edx,%eax
    b84b:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    b852:	ff 
    b853:	8d 50 01             	lea    0x1(%eax),%edx
    b856:	74 e8                	je     b840 <PCRLC_BULID_REQ+0xf0>
		if(i >= MAX_CODE) 
    b858:	83 fa 32             	cmp    $0x32,%edx
    b85b:	0f 84 3a 05 00 00    	je     bd9b <PCRLC_BULID_REQ+0x64b>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    b861:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    b864:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    b86b:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    b86f:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b872:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    b875:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b878:	31 c0                	xor    %eax,%eax
    b87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    b880:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    b887:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b888:	83 c0 01             	add    $0x1,%eax
    b88b:	83 f8 20             	cmp    $0x20,%eax
    b88e:	75 f0                	jne    b880 <PCRLC_BULID_REQ+0x130>
    b890:	30 c0                	xor    %al,%al
    b892:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    b898:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    b89f:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    b8a3:	83 c0 01             	add    $0x1,%eax
    b8a6:	3d 00 04 00 00       	cmp    $0x400,%eax
    b8ab:	75 eb                	jne    b898 <PCRLC_BULID_REQ+0x148>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b8ad:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    b8b3:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b8b9:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    b8bf:	81 c6 c0 36 00 00    	add    $0x36c0,%esi
    b8c5:	89 b3 c4 10 00 00    	mov    %esi,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    b8cb:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    b8d1:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
    b8d3:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    b8d7:	c7 04 24 b4 2f 00 00 	movl   $0x2fb4,(%esp)
    b8de:	89 44 24 04          	mov    %eax,0x4(%esp)
    b8e2:	e8 fc ff ff ff       	call   b8e3 <PCRLC_BULID_REQ+0x193>
		break;
    b8e7:	e9 b2 fe ff ff       	jmp    b79e <PCRLC_BULID_REQ+0x4e>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
    b8ec:	b8 38 00 00 00       	mov    $0x38,%eax
    b8f1:	e8 fc ff ff ff       	call   b8f2 <PCRLC_BULID_REQ+0x1a2>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b8f6:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    b8fa:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    b8fe:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    b902:	8d 48 30             	lea    0x30(%eax),%ecx
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    b905:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    b908:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    b90b:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    b90f:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    b915:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    b91c:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    b91f:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    b922:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b929:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    b92c:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b92f:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b935:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    b93b:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    b941:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    b944:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    b947:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
    b949:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    b94d:	c7 04 24 5c 2f 00 00 	movl   $0x2f5c,(%esp)
    b954:	89 44 24 04          	mov    %eax,0x4(%esp)
    b958:	e8 fc ff ff ff       	call   b959 <PCRLC_BULID_REQ+0x209>
		break;
    b95d:	e9 3c fe ff ff       	jmp    b79e <PCRLC_BULID_REQ+0x4e>
    b962:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    b968:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    b96d:	e8 fc ff ff ff       	call   b96e <PCRLC_BULID_REQ+0x21e>
    b972:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b974:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    b978:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b97c:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    b980:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b987:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    b98a:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    b98e:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    b991:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b994:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    b99b:	00 00 
    b99d:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    b9a4:	00 00 
    b9a6:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    b9ad:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    b9af:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    b9b2:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b9b4:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    b9ba:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    b9c1:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    b9c8:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    b9ce:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    b9d4:	eb 0d                	jmp    b9e3 <PCRLC_BULID_REQ+0x293>
    b9d6:	66 90                	xchg   %ax,%ax
    b9d8:	83 fa 32             	cmp    $0x32,%edx
    b9db:	0f 84 a9 03 00 00    	je     bd8a <PCRLC_BULID_REQ+0x63a>
    b9e1:	89 d0                	mov    %edx,%eax
    b9e3:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    b9ea:	ff 
    b9eb:	8d 50 01             	lea    0x1(%eax),%edx
    b9ee:	74 e8                	je     b9d8 <PCRLC_BULID_REQ+0x288>
		if(i >= MAX_CODE) 
    b9f0:	83 fa 32             	cmp    $0x32,%edx
    b9f3:	0f 84 91 03 00 00    	je     bd8a <PCRLC_BULID_REQ+0x63a>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    b9f9:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    b9fc:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    ba03:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    ba07:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ba0a:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    ba0d:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    ba10:	31 c0                	xor    %eax,%eax
    ba12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    ba18:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    ba1f:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    ba20:	83 c0 01             	add    $0x1,%eax
    ba23:	83 f8 20             	cmp    $0x20,%eax
    ba26:	75 f0                	jne    ba18 <PCRLC_BULID_REQ+0x2c8>
    ba28:	30 c0                	xor    %al,%al
    ba2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    ba30:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    ba37:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    ba3b:	83 c0 01             	add    $0x1,%eax
    ba3e:	3d 00 04 00 00       	cmp    $0x400,%eax
    ba43:	75 eb                	jne    ba30 <PCRLC_BULID_REQ+0x2e0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ba45:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    ba4b:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
    ba51:	8d 8e c0 36 00 00    	lea    0x36c0(%esi),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ba57:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    ba5d:	89 8b c4 10 00 00    	mov    %ecx,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    ba63:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    ba69:	89 10                	mov    %edx,(%eax)
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
    ba6b:	b8 38 00 00 00       	mov    $0x38,%eax
    ba70:	e8 fc ff ff ff       	call   ba71 <PCRLC_BULID_REQ+0x321>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    ba75:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    ba79:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    ba7d:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    ba81:	8d 48 30             	lea    0x30(%eax),%ecx
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    ba84:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba87:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    ba8a:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    ba8e:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    ba94:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba9b:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    ba9e:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    baa1:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    baa8:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    baab:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    baae:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bab4:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    baba:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    bac0:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    bac3:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    bac6:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
    bac8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    bacc:	c7 04 24 fc 2e 00 00 	movl   $0x2efc,(%esp)
    bad3:	89 44 24 04          	mov    %eax,0x4(%esp)
    bad7:	e8 fc ff ff ff       	call   bad8 <PCRLC_BULID_REQ+0x388>
		break;
    badc:	e9 bd fc ff ff       	jmp    b79e <PCRLC_BULID_REQ+0x4e>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		amIns =  instance_create(struct AM_Instance);
    bae1:	b8 0c 23 00 00       	mov    $0x230c,%eax
    bae6:	e8 fc ff ff ff       	call   bae7 <PCRLC_BULID_REQ+0x397>
    baeb:	89 c3                	mov    %eax,%ebx
		amIns->rbId = cIoctrl->rbIdentity;
    baed:	0f b6 07             	movzbl (%edi),%eax
    baf0:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
    baf3:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    baf7:	88 43 03             	mov    %al,0x3(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
    bafa:	0f b6 c0             	movzbl %al,%eax
    bafd:	89 44 24 04          	mov    %eax,0x4(%esp)
    bb01:	c7 04 24 14 2e 00 00 	movl   $0x2e14,(%esp)
    bb08:	e8 fc ff ff ff       	call   bb09 <PCRLC_BULID_REQ+0x3b9>
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    bb0d:	31 d2                	xor    %edx,%edx
		amIns =  instance_create(struct AM_Instance);
		amIns->rbId = cIoctrl->rbIdentity;
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
    bb0f:	6b 47 14 64          	imul   $0x64,0x14(%edi),%eax
    bb13:	89 43 1c             	mov    %eax,0x1c(%ebx)
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
    bb16:	6b 47 10 64          	imul   $0x64,0x10(%edi),%eax
    bb1a:	89 43 28             	mov    %eax,0x28(%ebx)
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
    bb1d:	6b 47 18 64          	imul   $0x64,0x18(%edi),%eax
    bb21:	89 43 10             	mov    %eax,0x10(%ebx)
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    bb24:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
    bb28:	66 89 83 f6 22 00 00 	mov    %ax,0x22f6(%ebx)
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    bb2f:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
    bb33:	66 89 83 f8 22 00 00 	mov    %ax,0x22f8(%ebx)
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bb3a:	0f b7 47 20          	movzwl 0x20(%edi),%eax
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bb3e:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%ebx)
    bb45:	00 00 00 
    bb48:	c7 83 b8 01 00 00 00 	movl   $0x0,0x1b8(%ebx)
    bb4f:	00 00 00 
    bb52:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bb59:	66 89 83 fa 22 00 00 	mov    %ax,0x22fa(%ebx)
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bb60:	c7 83 a4 01 00 00 00 	movl   $0x0,0x1a4(%ebx)
    bb67:	00 00 00 
		amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = amIns->amTransmittedBufferNum = 0;
    bb6a:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
    bb71:	00 00 00 
    bb74:	c7 83 bc 01 00 00 00 	movl   $0x0,0x1bc(%ebx)
    bb7b:	00 00 00 
    bb7e:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
    bb85:	c7 83 a8 01 00 00 00 	movl   $0x0,0x1a8(%ebx)
    bb8c:	00 00 00 
		amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
    bb8f:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    bb96:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    bb9d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		amIns->currentStatVar = ST_TRAN;
    bba4:	66 c7 43 2c 08 00    	movw   $0x8,0x2c(%ebx)
		amIns->pduLft.sduLeft = NULL;
    bbaa:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
		amIns->pduLft.SN_Left = -1;
    bbb1:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
		amIns->pduLft.SN5_Left = -1;
    bbb7:	66 c7 43 30 ff ff    	movw   $0xffff,0x30(%ebx)
		//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
		//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    bbbd:	eb 0c                	jmp    bbcb <PCRLC_BULID_REQ+0x47b>
    bbbf:	90                   	nop
    bbc0:	83 f8 32             	cmp    $0x32,%eax
    bbc3:	0f 84 ab 01 00 00    	je     bd74 <PCRLC_BULID_REQ+0x624>
    bbc9:	89 c2                	mov    %eax,%edx
    bbcb:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bbd2:	ff 
    bbd3:	8d 42 01             	lea    0x1(%edx),%eax
    bbd6:	74 e8                	je     bbc0 <PCRLC_BULID_REQ+0x470>
		if(i >= MAX_CODE) 
    bbd8:	83 f8 32             	cmp    $0x32,%eax
    bbdb:	0f 84 93 01 00 00    	je     bd74 <PCRLC_BULID_REQ+0x624>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->pollRetxTimerCode = i - 1;
    bbe1:	89 53 0c             	mov    %edx,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bbe4:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bbeb:	ff ff ff ff 
    bbef:	eb 09                	jmp    bbfa <PCRLC_BULID_REQ+0x4aa>
    bbf1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bbf8:	89 d0                	mov    %edx,%eax
    bbfa:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bc01:	ff 
    bc02:	8d 50 01             	lea    0x1(%eax),%edx
    bc05:	0f 85 a1 01 00 00    	jne    bdac <PCRLC_BULID_REQ+0x65c>
    bc0b:	83 fa 31             	cmp    $0x31,%edx
    bc0e:	7e e8                	jle    bbf8 <PCRLC_BULID_REQ+0x4a8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bc10:	89 55 f0             	mov    %edx,-0x10(%ebp)
    bc13:	c7 04 24 4c 2e 00 00 	movl   $0x2e4c,(%esp)
    bc1a:	e8 fc ff ff ff       	call   bc1b <PCRLC_BULID_REQ+0x4cb>
    bc1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bc22:	eb 06                	jmp    bc2a <PCRLC_BULID_REQ+0x4da>
    bc24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		else
		{
			amIns->reorderTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bc28:	89 c2                	mov    %eax,%edx
    bc2a:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bc31:	ff 
    bc32:	8d 42 01             	lea    0x1(%edx),%eax
    bc35:	0f 85 8d 01 00 00    	jne    bdc8 <PCRLC_BULID_REQ+0x678>
    bc3b:	83 f8 31             	cmp    $0x31,%eax
    bc3e:	7e e8                	jle    bc28 <PCRLC_BULID_REQ+0x4d8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bc40:	c7 04 24 4c 2e 00 00 	movl   $0x2e4c,(%esp)
    bc47:	e8 fc ff ff ff       	call   bc48 <PCRLC_BULID_REQ+0x4f8>
		else
		{
			amIns->statProhTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
    bc4c:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
    bc53:	00 00 
    bc55:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
    bc5c:	00 00 
    bc5e:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
    bc65:	00 00 
    bc67:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
    bc6e:	00 00 
    bc70:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
    bc77:	00 00 
    bc79:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
    bc80:	00 00 
		amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
    bc82:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
    bc89:	00 02 
    bc8b:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
    bc92:	00 02 
		amIns->SN = 0;
    bc94:	66 c7 43 2e 00 00    	movw   $0x0,0x2e(%ebx)
		amIns->statFlag = false;
    bc9a:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] init SN is %d\n",amIns->SN);
    bc9e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    bca5:	00 
    bca6:	c7 04 24 80 2e 00 00 	movl   $0x2e80,(%esp)
    bcad:	e8 fc ff ff ff       	call   bcae <PCRLC_BULID_REQ+0x55e>
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
    bcb2:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bcb5:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
    bcb8:	89 43 48             	mov    %eax,0x48(%ebx)
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
    bcbb:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bcc1:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
    bcc7:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
    bccd:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bcd3:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
    bcd9:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
    bcdf:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bce5:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
    bceb:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
    bcf1:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bcf7:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
    bcfd:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
		for(i = 0;  i < 1024; ++i )
    bd03:	31 c0                	xor    %eax,%eax
    bd05:	8d 76 00             	lea    0x0(%esi),%esi
		{
			amIns->amRecvWindow[i] = NULL;
    bd08:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
    bd0f:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
    bd13:	83 c0 01             	add    $0x1,%eax
    bd16:	3d 00 04 00 00       	cmp    $0x400,%eax
    bd1b:	75 eb                	jne    bd08 <PCRLC_BULID_REQ+0x5b8>
    bd1d:	66 31 c0             	xor    %ax,%ax
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amTranWindow[i]= NULL;
    bd20:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
    bd27:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
    bd2b:	83 c0 01             	add    $0x1,%eax
    bd2e:	3d 00 04 00 00       	cmp    $0x400,%eax
    bd33:	75 eb                	jne    bd20 <PCRLC_BULID_REQ+0x5d0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bd35:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		{
			amIns->amTranWindow[i]= NULL;
		}
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
    bd3b:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bd41:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
    bd47:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
    bd4d:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
    bd53:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
    bd59:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
    bd5b:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    bd5f:	c7 04 24 a8 2e 00 00 	movl   $0x2ea8,(%esp)
    bd66:	89 44 24 04          	mov    %eax,0x4(%esp)
    bd6a:	e8 fc ff ff ff       	call   bd6b <PCRLC_BULID_REQ+0x61b>
		break;
    bd6f:	e9 2a fa ff ff       	jmp    b79e <PCRLC_BULID_REQ+0x4e>
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd74:	c7 04 24 4c 2e 00 00 	movl   $0x2e4c,(%esp)
    bd7b:	e8 fc ff ff ff       	call   bd7c <PCRLC_BULID_REQ+0x62c>
    bd80:	b8 32 00 00 00       	mov    $0x32,%eax
    bd85:	e9 70 fe ff ff       	jmp    bbfa <PCRLC_BULID_REQ+0x4aa>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd8a:	c7 04 24 4c 2e 00 00 	movl   $0x2e4c,(%esp)
    bd91:	e8 fc ff ff ff       	call   bd92 <PCRLC_BULID_REQ+0x642>
    bd96:	e9 6c fc ff ff       	jmp    ba07 <PCRLC_BULID_REQ+0x2b7>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd9b:	c7 04 24 4c 2e 00 00 	movl   $0x2e4c,(%esp)
    bda2:	e8 fc ff ff ff       	call   bda3 <PCRLC_BULID_REQ+0x653>
    bda7:	e9 c3 fa ff ff       	jmp    b86f <PCRLC_BULID_REQ+0x11f>
		{
			amIns->pollRetxTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bdac:	83 fa 31             	cmp    $0x31,%edx
    bdaf:	0f 8f 5b fe ff ff    	jg     bc10 <PCRLC_BULID_REQ+0x4c0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->reorderTimerCode = i - 1;
    bdb5:	89 43 18             	mov    %eax,0x18(%ebx)
			SV(allocCode[i - 1]) = -1;
    bdb8:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    bdbf:	ff ff ff ff 
    bdc3:	e9 62 fe ff ff       	jmp    bc2a <PCRLC_BULID_REQ+0x4da>
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bdc8:	83 f8 31             	cmp    $0x31,%eax
    bdcb:	0f 8f 6f fe ff ff    	jg     bc40 <PCRLC_BULID_REQ+0x4f0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->statProhTimerCode = i - 1;
    bdd1:	89 53 24             	mov    %edx,0x24(%ebx)
			SV(allocCode[i - 1]) = -1;
    bdd4:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bddb:	ff ff ff ff 
    bddf:	e9 68 fe ff ff       	jmp    bc4c <PCRLC_BULID_REQ+0x4fc>
    bde4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    bdea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0000bdf0 <PCRLC_DEACT_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_DEACT_REQ(void)
{
    bdf0:	55                   	push   %ebp
    bdf1:	89 e5                	mov    %esp,%ebp
    bdf3:	57                   	push   %edi
    bdf4:	56                   	push   %esi
    bdf5:	53                   	push   %ebx
    bdf6:	83 ec 20             	sub    $0x20,%esp
    bdf9:	e8 fc ff ff ff       	call   bdfa <PCRLC_DEACT_REQ+0xa>
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
    bdfe:	e8 fc ff ff ff       	call   bdff <PCRLC_DEACT_REQ+0xf>
    be03:	89 c3                	mov    %eax,%ebx
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    be05:	e8 fc ff ff ff       	call   be06 <PCRLC_DEACT_REQ+0x16>
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    be0a:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    be10:	8d 4d f0             	lea    -0x10(%ebp),%ecx
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    be13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    be16:	0f b6 00             	movzbl (%eax),%eax
    be19:	89 14 24             	mov    %edx,(%esp)
    be1c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    be1f:	e8 fc ff ff ff       	call   be20 <PCRLC_DEACT_REQ+0x30>
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
    be24:	c7 04 24 38 30 00 00 	movl   $0x3038,(%esp)
    be2b:	e8 fc ff ff ff       	call   be2c <PCRLC_DEACT_REQ+0x3c>
	switch(SV(ins_mode))
    be30:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    be36:	83 f8 02             	cmp    $0x2,%eax
    be39:	74 3d                	je     be78 <PCRLC_DEACT_REQ+0x88>
    be3b:	83 f8 03             	cmp    $0x3,%eax
    be3e:	0f 84 a4 01 00 00    	je     bfe8 <PCRLC_DEACT_REQ+0x1f8>
		//AM
		fsm_mem_free(amIns);
		amIns = NULL;
		break;
	default:
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:cannot distinguish the instance to distinguish.\n");
    be44:	c7 04 24 70 31 00 00 	movl   $0x3170,(%esp)
    be4b:	e8 fc ff ff ff       	call   be4c <PCRLC_DEACT_REQ+0x5c>
		break;
	}
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    be50:	b8 01 00 00 00       	mov    $0x1,%eax
    be55:	e8 fc ff ff ff       	call   be56 <PCRLC_DEACT_REQ+0x66>
	cItrl->V_Flag = false;
    be5a:	c6 00 00             	movb   $0x0,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    be5d:	e8 fc ff ff ff       	call   be5e <PCRLC_DEACT_REQ+0x6e>
	cItrl = NULL;
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    be62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    be65:	e8 fc ff ff ff       	call   be66 <PCRLC_DEACT_REQ+0x76>
	cIoctrl = NULL;

	FOUT;
}
    be6a:	83 c4 20             	add    $0x20,%esp
    be6d:	5b                   	pop    %ebx
    be6e:	5e                   	pop    %esi
    be6f:	5f                   	pop    %edi
    be70:	5d                   	pop    %ebp
    be71:	c3                   	ret    
    be72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    be78:	8b 55 f0             	mov    -0x10(%ebp),%edx
    be7b:	85 d2                	test   %edx,%edx
    be7d:	0f 84 b7 00 00 00    	je     bf3a <PCRLC_DEACT_REQ+0x14a>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    be83:	8b 8a c4 10 00 00    	mov    0x10c4(%edx),%ecx
    be89:	8b 82 c8 10 00 00    	mov    0x10c8(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    be8f:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
    be92:	89 08                	mov    %ecx,(%eax)
		{
			umRxIns = (UM_RX_Instance *)insptrd;
			//UM
			list_del(&umRxIns->umRxList);
			fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um recv instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    be94:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    be97:	c7 82 c4 10 00 00 00 	movl   $0x100100,0x10c4(%edx)
    be9e:	01 10 00 
	entry->prev = LIST_POISON2;
    bea1:	c7 82 c8 10 00 00 00 	movl   $0x200200,0x10c8(%edx)
    bea8:	02 20 00 
    beab:	0f b6 01             	movzbl (%ecx),%eax
    beae:	89 55 dc             	mov    %edx,-0x24(%ebp)
    beb1:	c7 04 24 6c 30 00 00 	movl   $0x306c,(%esp)
    beb8:	89 44 24 04          	mov    %eax,0x4(%esp)
    bebc:	e8 fc ff ff ff       	call   bebd <PCRLC_DEACT_REQ+0xcd>
			//
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    bec1:	8b 55 dc             	mov    -0x24(%ebp),%edx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    bec4:	8b 72 30             	mov    0x30(%edx),%esi
    bec7:	8d 4a 30             	lea    0x30(%edx),%ecx
    beca:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    becd:	39 f1                	cmp    %esi,%ecx
    becf:	74 62                	je     bf33 <PCRLC_DEACT_REQ+0x143>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    bed1:	8b 06                	mov    (%esi),%eax
    bed3:	83 ee 10             	sub    $0x10,%esi
    bed6:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    bed9:	89 d3                	mov    %edx,%ebx
    bedb:	8d 78 f0             	lea    -0x10(%eax),%edi
    bede:	eb 12                	jmp    bef2 <PCRLC_DEACT_REQ+0x102>
    bee0:	8b 47 10             	mov    0x10(%edi),%eax
    bee3:	8d 4f 10             	lea    0x10(%edi),%ecx
    bee6:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    bee9:	8d 50 f0             	lea    -0x10(%eax),%edx
    beec:	74 43                	je     bf31 <PCRLC_DEACT_REQ+0x141>
    beee:	89 fe                	mov    %edi,%esi
    bef0:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bef2:	8b 56 14             	mov    0x14(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bef5:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    bef8:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
    befa:	8b 55 e0             	mov    -0x20(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    befd:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    bf04:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    bf0b:	8b 43 0c             	mov    0xc(%ebx),%eax
    bf0e:	89 84 82 28 02 00 00 	mov    %eax,0x228(%edx,%eax,4)
					fsm_pkt_destroy(umBuffer->pkt);
    bf15:	8b 06                	mov    (%esi),%eax
    bf17:	e8 fc ff ff ff       	call   bf18 <PCRLC_DEACT_REQ+0x128>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    bf1c:	89 f0                	mov    %esi,%eax
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    bf1e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(umBuffer);
    bf24:	e8 fc ff ff ff       	call   bf25 <PCRLC_DEACT_REQ+0x135>
					umBuffer = NULL;
					if(list_empty(&umRxIns->umRecvBuffer.list))
    bf29:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    bf2c:	3b 4b 30             	cmp    0x30(%ebx),%ecx
    bf2f:	75 af                	jne    bee0 <PCRLC_DEACT_REQ+0xf0>
    bf31:	89 da                	mov    %ebx,%edx
						break;
					}
				}
			}
			//UM
			fsm_mem_free(umRxIns);
    bf33:	89 d0                	mov    %edx,%eax
    bf35:	e8 fc ff ff ff       	call   bf36 <PCRLC_DEACT_REQ+0x146>
			umRxIns = NULL;
		}
		if(insptru == NULL)
    bf3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bf3d:	85 c0                	test   %eax,%eax
    bf3f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bf42:	0f 84 08 ff ff ff    	je     be50 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bf48:	8b 50 30             	mov    0x30(%eax),%edx
    bf4b:	89 c1                	mov    %eax,%ecx
    bf4d:	8b 40 34             	mov    0x34(%eax),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bf50:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    bf53:	89 10                	mov    %edx,(%eax)
		}
		umTxIns = (UM_TX_Instance *)insptru;

		//UM
		list_del(&umTxIns->umTxList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um tran instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    bf55:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bf58:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    bf5f:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    bf66:	0f b6 02             	movzbl (%edx),%eax
    bf69:	c7 04 24 c4 30 00 00 	movl   $0x30c4,(%esp)
    bf70:	89 44 24 04          	mov    %eax,0x4(%esp)
    bf74:	e8 fc ff ff ff       	call   bf75 <PCRLC_DEACT_REQ+0x185>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    bf79:	8b 45 e8             	mov    -0x18(%ebp),%eax
		//UM
		if(!list_empty(&umTxIns->umSduBuffer.list))
    bf7c:	8b 7d e8             	mov    -0x18(%ebp),%edi
    bf7f:	8b 58 18             	mov    0x18(%eax),%ebx
    bf82:	83 c7 18             	add    $0x18,%edi
    bf85:	39 df                	cmp    %ebx,%edi
    bf87:	74 52                	je     bfdb <PCRLC_DEACT_REQ+0x1eb>
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    bf89:	8b 03                	mov    (%ebx),%eax
    bf8b:	83 eb 10             	sub    $0x10,%ebx
    bf8e:	8d 70 f0             	lea    -0x10(%eax),%esi
    bf91:	eb 16                	jmp    bfa9 <PCRLC_DEACT_REQ+0x1b9>
    bf93:	90                   	nop
    bf94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    bf98:	8b 46 10             	mov    0x10(%esi),%eax
    bf9b:	8d 4e 10             	lea    0x10(%esi),%ecx
    bf9e:	39 cf                	cmp    %ecx,%edi
    bfa0:	8d 50 f0             	lea    -0x10(%eax),%edx
    bfa3:	74 36                	je     bfdb <PCRLC_DEACT_REQ+0x1eb>
    bfa5:	89 f3                	mov    %esi,%ebx
    bfa7:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bfa9:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bfac:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    bfaf:	89 02                	mov    %eax,(%edx)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
    bfb1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bfb3:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    bfba:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    bfc1:	e8 fc ff ff ff       	call   bfc2 <PCRLC_DEACT_REQ+0x1d2>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    bfc6:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    bfc8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    bfce:	e8 fc ff ff ff       	call   bfcf <PCRLC_DEACT_REQ+0x1df>
				umBuffer = NULL;
				if(list_empty(&umTxIns->umSduBuffer.list))
    bfd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfd6:	3b 78 18             	cmp    0x18(%eax),%edi
    bfd9:	75 bd                	jne    bf98 <PCRLC_DEACT_REQ+0x1a8>
					break;
				}
			}
		}
		//UM
		fsm_mem_free(umTxIns);
    bfdb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bfde:	e8 fc ff ff ff       	call   bfdf <PCRLC_DEACT_REQ+0x1ef>
		umTxIns = NULL;
		break;
    bfe3:	e9 68 fe ff ff       	jmp    be50 <PCRLC_DEACT_REQ+0x60>
	case AM_MODE:
		amIns = (AM_Instance *)insptru;
    bfe8:	8b 75 ec             	mov    -0x14(%ebp),%esi
		if(amIns == NULL)
    bfeb:	85 f6                	test   %esi,%esi
    bfed:	0f 84 5d fe ff ff    	je     be50 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bff3:	8b 96 04 23 00 00    	mov    0x2304(%esi),%edx
    bff9:	8b 86 08 23 00 00    	mov    0x2308(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bfff:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    c002:	89 10                	mov    %edx,(%eax)
		{
			break;
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c004:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c007:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    c00e:	01 10 00 
	entry->prev = LIST_POISON2;
    c011:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    c018:	02 20 00 
    c01b:	0f b6 02             	movzbl (%edx),%eax
    c01e:	c7 04 24 1c 31 00 00 	movl   $0x311c,(%esp)
    c025:	89 44 24 04          	mov    %eax,0x4(%esp)
    c029:	e8 fc ff ff ff       	call   c02a <PCRLC_DEACT_REQ+0x23a>
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c02e:	8b 46 0c             	mov    0xc(%esi),%eax
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c031:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c037:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
    c03e:	8b 46 18             	mov    0x18(%esi),%eax
    c041:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
    c048:	8b 46 24             	mov    0x24(%esi),%eax
    c04b:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c052:	8b 9e 9c 01 00 00    	mov    0x19c(%esi),%ebx
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c058:	39 da                	cmp    %ebx,%edx
    c05a:	74 77                	je     c0d3 <PCRLC_DEACT_REQ+0x2e3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    c05c:	8b 03                	mov    (%ebx),%eax
    c05e:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c064:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c067:	89 d6                	mov    %edx,%esi
    c069:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c06f:	eb 21                	jmp    c092 <PCRLC_DEACT_REQ+0x2a2>
    c071:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c07e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c084:	39 ce                	cmp    %ecx,%esi
    c086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c08c:	74 42                	je     c0d0 <PCRLC_DEACT_REQ+0x2e0>
    c08e:	89 fb                	mov    %edi,%ebx
    c090:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c092:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c098:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c09b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c09d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c09f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c0a6:	01 10 00 
	entry->prev = LIST_POISON2;
    c0a9:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c0b0:	02 20 00 
    c0b3:	e8 fc ff ff ff       	call   c0b4 <PCRLC_DEACT_REQ+0x2c4>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c0b8:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c0ba:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c0c0:	e8 fc ff ff ff       	call   c0c1 <PCRLC_DEACT_REQ+0x2d1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRetxBuffer.list))
    c0c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c0c8:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    c0ce:	75 a8                	jne    c078 <PCRLC_DEACT_REQ+0x288>
    c0d0:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c0d3:	8b 9e f0 00 00 00    	mov    0xf0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amTransmittedBuffer.list))
    c0d9:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    c0df:	39 da                	cmp    %ebx,%edx
    c0e1:	74 70                	je     c153 <PCRLC_DEACT_REQ+0x363>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    c0e3:	8b 03                	mov    (%ebx),%eax
    c0e5:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c0eb:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c0ee:	89 d6                	mov    %edx,%esi
    c0f0:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c0f6:	eb 1a                	jmp    c112 <PCRLC_DEACT_REQ+0x322>
    c0f8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c0fe:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c104:	39 ce                	cmp    %ecx,%esi
    c106:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c10c:	74 42                	je     c150 <PCRLC_DEACT_REQ+0x360>
    c10e:	89 fb                	mov    %edi,%ebx
    c110:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c112:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c118:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c11b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c11d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c11f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c126:	01 10 00 
	entry->prev = LIST_POISON2;
    c129:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c130:	02 20 00 
    c133:	e8 fc ff ff ff       	call   c134 <PCRLC_DEACT_REQ+0x344>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c138:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c13a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c140:	e8 fc ff ff ff       	call   c141 <PCRLC_DEACT_REQ+0x351>
				amBuffer = NULL;
				if(list_empty(&amIns->amTransmittedBuffer.list))
    c145:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c148:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    c14e:	75 a8                	jne    c0f8 <PCRLC_DEACT_REQ+0x308>
    c150:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c153:	8b 5e 44             	mov    0x44(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amSduBuffer.list))
    c156:	8d 56 44             	lea    0x44(%esi),%edx
    c159:	39 da                	cmp    %ebx,%edx
    c15b:	74 59                	je     c1b6 <PCRLC_DEACT_REQ+0x3c6>
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    c15d:	8b 03                	mov    (%ebx),%eax
    c15f:	83 eb 0c             	sub    $0xc,%ebx
    c162:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c165:	89 d6                	mov    %edx,%esi
    c167:	8d 78 f4             	lea    -0xc(%eax),%edi
    c16a:	eb 15                	jmp    c181 <PCRLC_DEACT_REQ+0x391>
    c16c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c170:	8b 47 0c             	mov    0xc(%edi),%eax
    c173:	8d 4f 0c             	lea    0xc(%edi),%ecx
    c176:	39 ce                	cmp    %ecx,%esi
    c178:	8d 50 f4             	lea    -0xc(%eax),%edx
    c17b:	74 36                	je     c1b3 <PCRLC_DEACT_REQ+0x3c3>
    c17d:	89 fb                	mov    %edi,%ebx
    c17f:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c181:	8b 53 10             	mov    0x10(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c184:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c187:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
    c189:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c18b:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    c192:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
    c199:	e8 fc ff ff ff       	call   c19a <PCRLC_DEACT_REQ+0x3aa>
				amsBuffer->pkt = NULL;
				fsm_mem_free(amsBuffer);
    c19e:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
				amsBuffer->pkt = NULL;
    c1a0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amsBuffer);
    c1a6:	e8 fc ff ff ff       	call   c1a7 <PCRLC_DEACT_REQ+0x3b7>
				amsBuffer = NULL;
				if(list_empty(&amIns->amSduBuffer.list))
    c1ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1ae:	3b 70 44             	cmp    0x44(%eax),%esi
    c1b1:	75 bd                	jne    c170 <PCRLC_DEACT_REQ+0x380>
    c1b3:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c1b6:	8b 9e b0 01 00 00    	mov    0x1b0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->ctrlPduBuffer.list))
    c1bc:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    c1c2:	39 da                	cmp    %ebx,%edx
    c1c4:	74 5b                	je     c221 <PCRLC_DEACT_REQ+0x431>
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    c1c6:	8b 03                	mov    (%ebx),%eax
    c1c8:	83 eb 04             	sub    $0x4,%ebx
    c1cb:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c1ce:	89 d6                	mov    %edx,%esi
    c1d0:	8d 78 fc             	lea    -0x4(%eax),%edi
    c1d3:	eb 14                	jmp    c1e9 <PCRLC_DEACT_REQ+0x3f9>
    c1d5:	8d 76 00             	lea    0x0(%esi),%esi
    c1d8:	8b 47 04             	mov    0x4(%edi),%eax
    c1db:	8d 4f 04             	lea    0x4(%edi),%ecx
    c1de:	39 ce                	cmp    %ecx,%esi
    c1e0:	8d 50 fc             	lea    -0x4(%eax),%edx
    c1e3:	74 39                	je     c21e <PCRLC_DEACT_REQ+0x42e>
    c1e5:	89 fb                	mov    %edi,%ebx
    c1e7:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c1e9:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c1ec:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c1ef:	89 02                	mov    %eax,(%edx)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
    c1f1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c1f3:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    c1fa:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    c201:	e8 fc ff ff ff       	call   c202 <PCRLC_DEACT_REQ+0x412>
				buffer->pkt = NULL;
				fsm_mem_free(buffer);
    c206:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
				buffer->pkt = NULL;
    c208:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(buffer);
    c20e:	e8 fc ff ff ff       	call   c20f <PCRLC_DEACT_REQ+0x41f>
				buffer = NULL;
				if(list_empty(&amIns->ctrlPduBuffer.list))
    c213:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c216:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    c21c:	75 ba                	jne    c1d8 <PCRLC_DEACT_REQ+0x3e8>
    c21e:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c221:	8b 9e 5c 02 00 00    	mov    0x25c(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amRecvBuffer.list))
    c227:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    c22d:	39 da                	cmp    %ebx,%edx
    c22f:	74 72                	je     c2a3 <PCRLC_DEACT_REQ+0x4b3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    c231:	8b 03                	mov    (%ebx),%eax
    c233:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c239:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c23c:	89 d6                	mov    %edx,%esi
    c23e:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c244:	eb 1c                	jmp    c262 <PCRLC_DEACT_REQ+0x472>
    c246:	66 90                	xchg   %ax,%ax
    c248:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c24e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c254:	39 ce                	cmp    %ecx,%esi
    c256:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c25c:	74 42                	je     c2a0 <PCRLC_DEACT_REQ+0x4b0>
    c25e:	89 fb                	mov    %edi,%ebx
    c260:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c262:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c268:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c26b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c26d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c26f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c276:	01 10 00 
	entry->prev = LIST_POISON2;
    c279:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c280:	02 20 00 
    c283:	e8 fc ff ff ff       	call   c284 <PCRLC_DEACT_REQ+0x494>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c288:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c28a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c290:	e8 fc ff ff ff       	call   c291 <PCRLC_DEACT_REQ+0x4a1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRecvBuffer.list))
    c295:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c298:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    c29e:	75 a8                	jne    c248 <PCRLC_DEACT_REQ+0x458>
    c2a0:	8b 75 e8             	mov    -0x18(%ebp),%esi
					break;
				}
			}
		}
		//AM
		fsm_mem_free(amIns);
    c2a3:	89 f0                	mov    %esi,%eax
    c2a5:	e8 fc ff ff ff       	call   c2a6 <PCRLC_DEACT_REQ+0x4b6>
		amIns = NULL;
		break;
    c2aa:	e9 a1 fb ff ff       	jmp    be50 <PCRLC_DEACT_REQ+0x60>
    c2af:	90                   	nop

0000c2b0 <PCRLC_SUSPEND_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_SUSPEND_REQ(void)
{
    c2b0:	55                   	push   %ebp
    c2b1:	89 e5                	mov    %esp,%ebp
    c2b3:	56                   	push   %esi
    c2b4:	53                   	push   %ebx
    c2b5:	83 ec 14             	sub    $0x14,%esp
    c2b8:	e8 fc ff ff ff       	call   c2b9 <PCRLC_SUSPEND_REQ+0x9>
	CRLC_SuspendReq_IoctrlMsg *cIoctrl = (CRLC_SuspendReq_IoctrlMsg*) fsm_data_get();
    c2bd:	e8 fc ff ff ff       	call   c2be <PCRLC_SUSPEND_REQ+0xe>
    c2c2:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c2c4:	e8 fc ff ff ff       	call   c2c5 <PCRLC_SUSPEND_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c2c9:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c2cc:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c2ce:	0f b6 06             	movzbl (%esi),%eax
    c2d1:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c2d7:	89 14 24             	mov    %edx,(%esp)
    c2da:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c2dd:	e8 fc ff ff ff       	call   c2de <PCRLC_SUSPEND_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
    c2e2:	0f b6 06             	movzbl (%esi),%eax
    c2e5:	89 44 24 08          	mov    %eax,0x8(%esp)
    c2e9:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c2ef:	c7 04 24 c8 31 00 00 	movl   $0x31c8,(%esp)
    c2f6:	89 44 24 04          	mov    %eax,0x4(%esp)
    c2fa:	e8 fc ff ff ff       	call   c2fb <PCRLC_SUSPEND_REQ+0x4b>
	switch(SV(ins_mode))
    c2ff:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c305:	83 f8 02             	cmp    $0x2,%eax
    c308:	74 26                	je     c330 <PCRLC_SUSPEND_REQ+0x80>
    c30a:	83 f8 03             	cmp    $0x3,%eax
    c30d:	0f 84 85 00 00 00    	je     c398 <PCRLC_SUSPEND_REQ+0xe8>
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
		}
		break;
	default:
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:cannot distinguish the instance \n");
    c313:	c7 04 24 30 33 00 00 	movl   $0x3330,(%esp)
    c31a:	e8 fc ff ff ff       	call   c31b <PCRLC_SUSPEND_REQ+0x6b>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c31f:	89 f0                	mov    %esi,%eax
    c321:	e8 fc ff ff ff       	call   c322 <PCRLC_SUSPEND_REQ+0x72>
	cIoctrl = NULL;
	FOUT;
}
    c326:	83 c4 14             	add    $0x14,%esp
    c329:	5b                   	pop    %ebx
    c32a:	5e                   	pop    %esi
    c32b:	5d                   	pop    %ebp
    c32c:	c3                   	ret    
    c32d:	8d 76 00             	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    c330:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c333:	85 db                	test   %ebx,%ebx
    c335:	74 2e                	je     c365 <PCRLC_SUSPEND_REQ+0xb5>
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c337:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
	case UM_MODE:
		if(insptrd != NULL)
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
    c33b:	c6 83 c2 10 00 00 09 	movb   $0x9,0x10c2(%ebx)
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c342:	c7 04 24 2c 32 00 00 	movl   $0x322c,(%esp)
    c349:	89 44 24 04          	mov    %eax,0x4(%esp)
    c34d:	e8 fc ff ff ff       	call   c34e <PCRLC_SUSPEND_REQ+0x9e>
			if(umRxIns->reorderTimer)
    c352:	8b 43 08             	mov    0x8(%ebx),%eax
    c355:	85 c0                	test   %eax,%eax
    c357:	74 0c                	je     c365 <PCRLC_SUSPEND_REQ+0xb5>
			{
				fsm_schedule_cancel(umRxIns->reorderTimer);
    c359:	e8 fc ff ff ff       	call   c35a <PCRLC_SUSPEND_REQ+0xaa>
				umRxIns->reorderTimer = 0;
    c35e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			}
		}
		if(insptru == NULL)
    c365:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c368:	85 c0                	test   %eax,%eax
    c36a:	74 b3                	je     c31f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		umTxIns = (UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_SUSPEND;
    c36c:	c6 40 2c 09          	movb   $0x9,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
    c370:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    c374:	c7 04 24 84 32 00 00 	movl   $0x3284,(%esp)
    c37b:	89 44 24 04          	mov    %eax,0x4(%esp)
    c37f:	e8 fc ff ff ff       	call   c380 <PCRLC_SUSPEND_REQ+0xd0>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c384:	89 f0                	mov    %esi,%eax
    c386:	e8 fc ff ff ff       	call   c387 <PCRLC_SUSPEND_REQ+0xd7>
	cIoctrl = NULL;
	FOUT;
}
    c38b:	83 c4 14             	add    $0x14,%esp
    c38e:	5b                   	pop    %ebx
    c38f:	5e                   	pop    %esi
    c390:	5d                   	pop    %ebp
    c391:	c3                   	ret    
    c392:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c398:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    c39b:	85 db                	test   %ebx,%ebx
    c39d:	0f 84 7c ff ff ff    	je     c31f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c3a3:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
		if(insptru == NULL)
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
    c3a7:	66 c7 43 2c 09 00    	movw   $0x9,0x2c(%ebx)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c3ad:	c7 04 24 dc 32 00 00 	movl   $0x32dc,(%esp)
    c3b4:	89 44 24 04          	mov    %eax,0x4(%esp)
    c3b8:	e8 fc ff ff ff       	call   c3b9 <PCRLC_SUSPEND_REQ+0x109>
		if(amIns->pollRetxTimer)
    c3bd:	8b 43 08             	mov    0x8(%ebx),%eax
    c3c0:	85 c0                	test   %eax,%eax
    c3c2:	74 0c                	je     c3d0 <PCRLC_SUSPEND_REQ+0x120>
		{
			fsm_schedule_cancel(amIns->pollRetxTimer);
    c3c4:	e8 fc ff ff ff       	call   c3c5 <PCRLC_SUSPEND_REQ+0x115>
			amIns->pollRetxTimer = 0;
    c3c9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		}
		if(amIns->reorderTimer)
    c3d0:	8b 43 14             	mov    0x14(%ebx),%eax
    c3d3:	85 c0                	test   %eax,%eax
    c3d5:	74 0c                	je     c3e3 <PCRLC_SUSPEND_REQ+0x133>
		{
			fsm_schedule_cancel(amIns->reorderTimer);
    c3d7:	e8 fc ff ff ff       	call   c3d8 <PCRLC_SUSPEND_REQ+0x128>
			amIns->reorderTimer = 0;
    c3dc:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		}
		if(amIns->statProhTimer)
    c3e3:	8b 43 20             	mov    0x20(%ebx),%eax
    c3e6:	85 c0                	test   %eax,%eax
    c3e8:	0f 84 31 ff ff ff    	je     c31f <PCRLC_SUSPEND_REQ+0x6f>
		{
			fsm_schedule_cancel(amIns->statProhTimer);
    c3ee:	e8 fc ff ff ff       	call   c3ef <PCRLC_SUSPEND_REQ+0x13f>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c3f3:	89 f0                	mov    %esi,%eax
			amIns->reorderTimer = 0;
		}
		if(amIns->statProhTimer)
		{
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
    c3f5:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c3fc:	e8 fc ff ff ff       	call   c3fd <PCRLC_SUSPEND_REQ+0x14d>
	cIoctrl = NULL;
	FOUT;
}
    c401:	83 c4 14             	add    $0x14,%esp
    c404:	5b                   	pop    %ebx
    c405:	5e                   	pop    %esi
    c406:	5d                   	pop    %ebp
    c407:	c3                   	ret    
    c408:	90                   	nop
    c409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c410 <PCRLC_RESUME_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_RESUME_REQ(void)
{
    c410:	55                   	push   %ebp
    c411:	89 e5                	mov    %esp,%ebp
    c413:	56                   	push   %esi
    c414:	53                   	push   %ebx
    c415:	83 ec 10             	sub    $0x10,%esp
    c418:	e8 fc ff ff ff       	call   c419 <PCRLC_RESUME_REQ+0x9>
	CRLC_ResumeReq_IoctrlMsg *cIoctrl = (CRLC_ResumeReq_IoctrlMsg*) fsm_data_get();
    c41d:	e8 fc ff ff ff       	call   c41e <PCRLC_RESUME_REQ+0xe>
    c422:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c424:	e8 fc ff ff ff       	call   c425 <PCRLC_RESUME_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c429:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c42c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c42e:	0f b6 06             	movzbl (%esi),%eax
    c431:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c437:	89 14 24             	mov    %edx,(%esp)
    c43a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c43d:	e8 fc ff ff ff       	call   c43e <PCRLC_RESUME_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
    c442:	c7 04 24 80 33 00 00 	movl   $0x3380,(%esp)
    c449:	e8 fc ff ff ff       	call   c44a <PCRLC_RESUME_REQ+0x3a>
	switch(SV(ins_mode))
    c44e:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c454:	83 f8 02             	cmp    $0x2,%eax
    c457:	74 1f                	je     c478 <PCRLC_RESUME_REQ+0x68>
    c459:	83 f8 03             	cmp    $0x3,%eax
    c45c:	74 6a                	je     c4c8 <PCRLC_RESUME_REQ+0xb8>
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
    c45e:	c7 04 24 81 07 00 00 	movl   $0x781,(%esp)
    c465:	e8 fc ff ff ff       	call   c466 <PCRLC_RESUME_REQ+0x56>
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c46a:	89 f0                	mov    %esi,%eax
    c46c:	e8 fc ff ff ff       	call   c46d <PCRLC_RESUME_REQ+0x5d>
	FOUT;
}
    c471:	83 c4 10             	add    $0x10,%esp
    c474:	5b                   	pop    %ebx
    c475:	5e                   	pop    %esi
    c476:	5d                   	pop    %ebp
    c477:	c3                   	ret    
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd == NULL)
    c478:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c47b:	85 c0                	test   %eax,%eax
    c47d:	74 eb                	je     c46a <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umRxIns = ( UM_RX_Instance *)insptrd;
		umRxIns->currentStatVar = ST_TRAN;
    c47f:	c6 80 c2 10 00 00 08 	movb   $0x8,0x10c2(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um recv instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c486:	0f b6 06             	movzbl (%esi),%eax
    c489:	c7 04 24 b4 33 00 00 	movl   $0x33b4,(%esp)
    c490:	89 44 24 04          	mov    %eax,0x4(%esp)
    c494:	e8 fc ff ff ff       	call   c495 <PCRLC_RESUME_REQ+0x85>

		if(insptru == NULL)
    c499:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c49c:	85 c0                	test   %eax,%eax
    c49e:	74 ca                	je     c46a <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umTxIns = ( UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_TRAN;
    c4a0:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c4a4:	0f b6 06             	movzbl (%esi),%eax
    c4a7:	c7 04 24 08 34 00 00 	movl   $0x3408,(%esp)
    c4ae:	89 44 24 04          	mov    %eax,0x4(%esp)
    c4b2:	e8 fc ff ff ff       	call   c4b3 <PCRLC_RESUME_REQ+0xa3>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c4b7:	89 f0                	mov    %esi,%eax
    c4b9:	e8 fc ff ff ff       	call   c4ba <PCRLC_RESUME_REQ+0xaa>
	FOUT;
}
    c4be:	83 c4 10             	add    $0x10,%esp
    c4c1:	5b                   	pop    %ebx
    c4c2:	5e                   	pop    %esi
    c4c3:	5d                   	pop    %ebp
    c4c4:	c3                   	ret    
    c4c5:	8d 76 00             	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c4c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c4cb:	85 c0                	test   %eax,%eax
    c4cd:	74 9b                	je     c46a <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
    c4cf:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c4d5:	0f b6 06             	movzbl (%esi),%eax
    c4d8:	c7 04 24 5c 34 00 00 	movl   $0x345c,(%esp)
    c4df:	89 44 24 04          	mov    %eax,0x4(%esp)
    c4e3:	e8 fc ff ff ff       	call   c4e4 <PCRLC_RESUME_REQ+0xd4>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c4e8:	89 f0                	mov    %esi,%eax
    c4ea:	e8 fc ff ff ff       	call   c4eb <PCRLC_RESUME_REQ+0xdb>
	FOUT;
}
    c4ef:	83 c4 10             	add    $0x10,%esp
    c4f2:	5b                   	pop    %ebx
    c4f3:	5e                   	pop    %esi
    c4f4:	5d                   	pop    %ebp
    c4f5:	c3                   	ret    
    c4f6:	8d 76 00             	lea    0x0(%esi),%esi
    c4f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c500 <PCRLC_STATUS_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c500:	55                   	push   %ebp
    c501:	89 e5                	mov    %esp,%ebp
    c503:	83 ec 10             	sub    $0x10,%esp
    c506:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    c509:	89 75 f8             	mov    %esi,-0x8(%ebp)
    c50c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    c50f:	e8 fc ff ff ff       	call   c510 <PCRLC_STATUS_IND+0x10>
    c514:	89 c6                	mov    %eax,%esi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c516:	b8 04 00 00 00       	mov    $0x4,%eax
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c51b:	89 d7                	mov    %edx,%edi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c51d:	e8 fc ff ff ff       	call   c51e <PCRLC_STATUS_IND+0x1e>
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c522:	ba 51 00 00 00       	mov    $0x51,%edx
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c527:	89 c3                	mov    %eax,%ebx
	cioctrl->eventCode = evCode;
    c529:	66 89 38             	mov    %di,(%eax)
	cioctrl->rbIdentity = rbid;
    c52c:	89 f0                	mov    %esi,%eax
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c52e:	89 d9                	mov    %ebx,%ecx
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
    c530:	88 43 02             	mov    %al,0x2(%ebx)
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c533:	b8 05 00 00 00       	mov    $0x5,%eax
    c538:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    c53f:	e8 fc ff ff ff       	call   c540 <PCRLC_STATUS_IND+0x40>
	fsm_mem_free(cioctrl);
    c544:	89 d8                	mov    %ebx,%eax
    c546:	e8 fc ff ff ff       	call   c547 <PCRLC_STATUS_IND+0x47>
	//fsm_data_destroy(cioctrl);
	cioctrl = NULL;
	FOUT;
}
    c54b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c54e:	8b 75 f8             	mov    -0x8(%ebp),%esi
    c551:	8b 7d fc             	mov    -0x4(%ebp),%edi
    c554:	89 ec                	mov    %ebp,%esp
    c556:	5d                   	pop    %ebp
    c557:	c3                   	ret    
    c558:	90                   	nop
    c559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c560 <PPRLC_DISC_REQ>:

//
inline void PPRLC_DISC_REQ(void)  {}
    c560:	55                   	push   %ebp
    c561:	89 e5                	mov    %esp,%ebp
    c563:	5d                   	pop    %ebp
    c564:	c3                   	ret    
    c565:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c569:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c570 <PMRLC_BUFFERREP_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void* PMRLC_BUFFERREP_REQ(void)
{
    c570:	55                   	push   %ebp
    c571:	89 e5                	mov    %esp,%ebp
    c573:	57                   	push   %edi
    c574:	56                   	push   %esi
    c575:	53                   	push   %ebx
    c576:	83 ec 20             	sub    $0x20,%esp
    c579:	e8 fc ff ff ff       	call   c57a <PMRLC_BUFFERREP_REQ+0xa>
	struct AM_Instance * amIns;
	struct UM_TX_Instance *umTxIns;
	struct TM_TX_Instance *tmTxIns;
	struct AmBuffer *amBuffer;
	CtrlBuffer *ctrlBf;
	u32 num = 0,*nump;  //
    c57e:	31 db                	xor    %ebx,%ebx

	SV_PTR_GET(rlc_mac_sv);
    c580:	e8 fc ff ff ff       	call   c581 <PMRLC_BUFFERREP_REQ+0x11>
    c585:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c588:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c58b:	05 f4 25 00 00       	add    $0x25f4,%eax
    c590:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c593:	8b 82 f4 25 00 00    	mov    0x25f4(%edx),%eax
    c599:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    c59c:	74 33                	je     c5d1 <PMRLC_BUFFERREP_REQ+0x61>
    c59e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c5a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c5a8:	8b b8 48 dd ff ff    	mov    -0x22b8(%eax),%edi
    c5ae:	85 ff                	test   %edi,%edi
    c5b0:	75 16                	jne    c5c8 <PMRLC_BUFFERREP_REQ+0x58>
    c5b2:	8b b0 a0 de ff ff    	mov    -0x2160(%eax),%esi
    c5b8:	85 f6                	test   %esi,%esi
    c5ba:	75 0c                	jne    c5c8 <PMRLC_BUFFERREP_REQ+0x58>
    c5bc:	8b 88 b4 de ff ff    	mov    -0x214c(%eax),%ecx
    c5c2:	85 c9                	test   %ecx,%ecx
    c5c4:	74 05                	je     c5cb <PMRLC_BUFFERREP_REQ+0x5b>
    c5c6:	66 90                	xchg   %ax,%ax
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] am instance (rbid is %d) has data to report\n", amIns->rbId);
				num++;
    c5c8:	83 c3 01             	add    $0x1,%ebx

	SV_PTR_GET(rlc_mac_sv);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c5cb:	8b 00                	mov    (%eax),%eax
    c5cd:	39 c2                	cmp    %eax,%edx
    c5cf:	75 d7                	jne    c5a8 <PMRLC_BUFFERREP_REQ+0x38>
				num++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c5d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c5d4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c5d7:	05 f8 36 00 00       	add    $0x36f8,%eax
    c5dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c5df:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
    c5e5:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c5e8:	74 13                	je     c5fd <PMRLC_BUFFERREP_REQ+0x8d>
    c5ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c5ed:	8d 76 00             	lea    0x0(%esi),%esi
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c5f0:	83 78 f0 01          	cmpl   $0x1,-0x10(%eax)
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c5f4:	8b 00                	mov    (%eax),%eax
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c5f6:	83 db ff             	sbb    $0xffffffff,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c5f9:	39 c2                	cmp    %eax,%edx
    c5fb:	75 f3                	jne    c5f0 <PMRLC_BUFFERREP_REQ+0x80>
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c5fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c600:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c603:	05 2c 37 00 00       	add    $0x372c,%eax
    c608:	89 45 dc             	mov    %eax,-0x24(%ebp)
    c60b:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
    c611:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c614:	74 17                	je     c62d <PMRLC_BUFFERREP_REQ+0xbd>
    c616:	8b 55 dc             	mov    -0x24(%ebp),%edx
    c619:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c620:	83 78 f8 01          	cmpl   $0x1,-0x8(%eax)
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c624:	8b 00                	mov    (%eax),%eax
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c626:	83 db ff             	sbb    $0xffffffff,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c629:	39 c2                	cmp    %eax,%edx
    c62b:	75 f3                	jne    c620 <PMRLC_BUFFERREP_REQ+0xb0>
				num++;
			}
		}
	}
	
	if(num == 0)
    c62d:	85 db                	test   %ebx,%ebx
    c62f:	0f 84 9f 02 00 00    	je     c8d4 <PMRLC_BUFFERREP_REQ+0x364>
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c635:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    c638:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
    c63c:	e8 fc ff ff ff       	call   c63d <PMRLC_BUFFERREP_REQ+0xcd>
	*nump = num;
    c641:	89 18                	mov    %ebx,(%eax)
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c643:	89 c3                	mov    %eax,%ebx
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c645:	89 45 d8             	mov    %eax,-0x28(%ebp)
    c648:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c64b:	83 c3 04             	add    $0x4,%ebx
    c64e:	8b b8 f4 25 00 00    	mov    0x25f4(%eax),%edi
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c654:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c657:	0f 84 47 01 00 00    	je     c7a4 <PMRLC_BUFFERREP_REQ+0x234>
    c65d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c660:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    c666:	8d 97 fc dc ff ff    	lea    -0x2304(%edi),%edx
    c66c:	89 55 f0             	mov    %edx,-0x10(%ebp)
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c66f:	85 c0                	test   %eax,%eax
    c671:	75 1d                	jne    c690 <PMRLC_BUFFERREP_REQ+0x120>
    c673:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
    c679:	85 c0                	test   %eax,%eax
    c67b:	75 13                	jne    c690 <PMRLC_BUFFERREP_REQ+0x120>
    c67d:	8b b7 b4 de ff ff    	mov    -0x214c(%edi),%esi
    c683:	85 f6                	test   %esi,%esi
    c685:	0f 84 0e 01 00 00    	je     c799 <PMRLC_BUFFERREP_REQ+0x229>
    c68b:	90                   	nop
    c68c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			{
				mioctrl->rnti = 0;
    c690:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = amIns->lcId;
    c695:	0f b6 87 ff dc ff ff 	movzbl -0x2301(%edi),%eax
    c69c:	88 43 02             	mov    %al,0x2(%ebx)
				mioctrl->txQueueSize = amIns->amSduBufferSize;
    c69f:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
    c6a5:	89 43 03             	mov    %eax,0x3(%ebx)
				mioctrl->txQueueHeader = 2 + 2* amIns->amSduBufferNum;
    c6a8:	8b 97 4c dd ff ff    	mov    -0x22b4(%edi),%edx
    c6ae:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
    c6b2:	66 89 53 07          	mov    %dx,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c6b6:	0f b7 d2             	movzwl %dx,%edx
    c6b9:	01 c2                	add    %eax,%edx
    c6bb:	83 fa 7f             	cmp    $0x7f,%edx
    c6be:	0f 87 6c 01 00 00    	ja     c830 <PMRLC_BUFFERREP_REQ+0x2c0>
				{
					mioctrl->txQueueSize += 2;
    c6c4:	83 c0 02             	add    $0x2,%eax
    c6c7:	89 43 03             	mov    %eax,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c6ca:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
				mioctrl->retxQueueHeader = 2;
    c6d0:	66 c7 43 0d 02 00    	movw   $0x2,0xd(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c6d6:	89 43 09             	mov    %eax,0x9(%ebx)
    c6d9:	8b b7 98 de ff ff    	mov    -0x2168(%edi),%esi
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
    c6df:	8d 87 98 de ff ff    	lea    -0x2168(%edi),%eax
    c6e5:	39 f0                	cmp    %esi,%eax
    c6e7:	74 55                	je     c73e <PMRLC_BUFFERREP_REQ+0x1ce>
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c6e9:	89 7d e8             	mov    %edi,-0x18(%ebp)
    c6ec:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
    c6f2:	89 c7                	mov    %eax,%edi
    c6f4:	eb 16                	jmp    c70c <PMRLC_BUFFERREP_REQ+0x19c>
    c6f6:	66 90                	xchg   %ax,%ax
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
						{
							if( amBuffer->pkt->len < 128 )
							{
								mioctrl->retxQueueSize += 2;
    c6f8:	83 43 09 02          	addl   $0x2,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c6fc:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c702:	39 c7                	cmp    %eax,%edi
    c704:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c70a:	74 2f                	je     c73b <PMRLC_BUFFERREP_REQ+0x1cb>
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
    c70c:	0f bf 96 94 00 00 00 	movswl 0x94(%esi),%edx
    c713:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c716:	e8 fc ff ff ff       	call   c717 <PMRLC_BUFFERREP_REQ+0x1a7>
    c71b:	84 c0                	test   %al,%al
    c71d:	74 dd                	je     c6fc <PMRLC_BUFFERREP_REQ+0x18c>
						{
							if( amBuffer->pkt->len < 128 )
    c71f:	8b 06                	mov    (%esi),%eax
    c721:	83 78 50 7f          	cmpl   $0x7f,0x50(%eax)
    c725:	76 d1                	jbe    c6f8 <PMRLC_BUFFERREP_REQ+0x188>
							{
								mioctrl->retxQueueSize += 2;
							}
							else
							{
								mioctrl->retxQueueSize += 3;
    c727:	83 43 09 03          	addl   $0x3,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c72b:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c731:	39 c7                	cmp    %eax,%edi
    c733:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c739:	75 d1                	jne    c70c <PMRLC_BUFFERREP_REQ+0x19c>
    c73b:	8b 7d e8             	mov    -0x18(%ebp),%edi
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c73e:	8b 87 b4 de ff ff    	mov    -0x214c(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c744:	8d b7 ac de ff ff    	lea    -0x2154(%edi),%esi
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
    c74a:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c750:	89 c2                	mov    %eax,%edx
    c752:	66 89 43 0f          	mov    %ax,0xf(%ebx)
    c756:	8b 87 ac de ff ff    	mov    -0x2154(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c75c:	39 c6                	cmp    %eax,%esi
    c75e:	74 36                	je     c796 <PMRLC_BUFFERREP_REQ+0x226>
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c760:	83 e8 04             	sub    $0x4,%eax
    c763:	eb 18                	jmp    c77d <PMRLC_BUFFERREP_REQ+0x20d>
    c765:	8d 76 00             	lea    0x0(%esi),%esi
					{
						if( ctrlBf->pkt->len < 128 )
						{
							mioctrl->statusPduSize += 2;
    c768:	83 c2 02             	add    $0x2,%edx
    c76b:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c76f:	8b 50 04             	mov    0x4(%eax),%edx
    c772:	39 d6                	cmp    %edx,%esi
    c774:	8d 42 fc             	lea    -0x4(%edx),%eax
    c777:	74 1d                	je     c796 <PMRLC_BUFFERREP_REQ+0x226>
    c779:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
					{
						if( ctrlBf->pkt->len < 128 )
    c77d:	8b 08                	mov    (%eax),%ecx
    c77f:	83 79 50 7f          	cmpl   $0x7f,0x50(%ecx)
    c783:	76 e3                	jbe    c768 <PMRLC_BUFFERREP_REQ+0x1f8>
						{
							mioctrl->statusPduSize += 2;
						}
						else
						{
							mioctrl->statusPduSize += 3;
    c785:	83 c2 03             	add    $0x3,%edx
    c788:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c78c:	8b 50 04             	mov    0x4(%eax),%edx
    c78f:	39 d6                	cmp    %edx,%esi
    c791:	8d 42 fc             	lea    -0x4(%edx),%eax
    c794:	75 e3                	jne    c779 <PMRLC_BUFFERREP_REQ+0x209>
				}
				else
				{
					mioctrl->statusPduSize += 3;
				}*/
				mioctrl++;
    c796:	83 c3 13             	add    $0x13,%ebx
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c799:	8b 3f                	mov    (%edi),%edi
    c79b:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c79e:	0f 85 bc fe ff ff    	jne    c660 <PMRLC_BUFFERREP_REQ+0xf0>
    c7a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c7a7:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
				mioctrl++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c7ad:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c7b0:	0f 84 b2 00 00 00    	je     c868 <PMRLC_BUFFERREP_REQ+0x2f8>
    c7b6:	8b 75 e0             	mov    -0x20(%ebp),%esi
    c7b9:	eb 18                	jmp    c7d3 <PMRLC_BUFFERREP_REQ+0x263>
    c7bb:	90                   	nop
    c7bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c7c0:	83 c2 02             	add    $0x2,%edx
    c7c3:	89 53 03             	mov    %edx,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
    c7c6:	83 c3 13             	add    $0x13,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c7c9:	8b 00                	mov    (%eax),%eax
    c7cb:	39 c6                	cmp    %eax,%esi
    c7cd:	0f 84 95 00 00 00    	je     c868 <PMRLC_BUFFERREP_REQ+0x2f8>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
    c7d3:	8b 48 f0             	mov    -0x10(%eax),%ecx
    c7d6:	85 c9                	test   %ecx,%ecx
    c7d8:	74 ef                	je     c7c9 <PMRLC_BUFFERREP_REQ+0x259>
			{
				mioctrl->rnti = 0;
    c7da:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = umTxIns->lcid;
    c7df:	0f b6 50 d3          	movzbl -0x2d(%eax),%edx
    c7e3:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c7e6:	8b 50 f0             	mov    -0x10(%eax),%edx
				mioctrl->retxQueueSize = 0;
    c7e9:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->retxQueueHeader = 0;
    c7f0:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				mioctrl->statusPduSize = 0;
    c7f6:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = umTxIns->lcid;
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c7fc:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->retxQueueSize = 0;
				mioctrl->retxQueueHeader = 0;
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;
    c7ff:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)

				if(umTxIns->snFiledLength == 5)
    c805:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c809:	66 83 f9 05          	cmp    $0x5,%cx
    c80d:	74 41                	je     c850 <PMRLC_BUFFERREP_REQ+0x2e0>
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
    c80f:	66 83 f9 0a          	cmp    $0xa,%cx
    c813:	74 2b                	je     c840 <PMRLC_BUFFERREP_REQ+0x2d0>
    c815:	0f b7 4b 07          	movzwl 0x7(%ebx),%ecx
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c819:	0f b7 c9             	movzwl %cx,%ecx
    c81c:	01 d1                	add    %edx,%ecx
    c81e:	83 f9 7f             	cmp    $0x7f,%ecx
    c821:	76 9d                	jbe    c7c0 <PMRLC_BUFFERREP_REQ+0x250>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c823:	83 c2 03             	add    $0x3,%edx
    c826:	89 53 03             	mov    %edx,0x3(%ebx)
    c829:	eb 9b                	jmp    c7c6 <PMRLC_BUFFERREP_REQ+0x256>
    c82b:	90                   	nop
    c82c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c830:	83 c0 03             	add    $0x3,%eax
    c833:	89 43 03             	mov    %eax,0x3(%ebx)
    c836:	e9 8f fe ff ff       	jmp    c6ca <PMRLC_BUFFERREP_REQ+0x15a>
    c83b:	90                   	nop
    c83c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
    c840:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c843:	8d 4c 09 02          	lea    0x2(%ecx,%ecx,1),%ecx
    c847:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c84b:	eb cc                	jmp    c819 <PMRLC_BUFFERREP_REQ+0x2a9>
    c84d:	8d 76 00             	lea    0x0(%esi),%esi
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;

				if(umTxIns->snFiledLength == 5)
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
    c850:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c853:	8d 4c 09 01          	lea    0x1(%ecx,%ecx,1),%ecx
    c857:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c85b:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c85f:	eb ae                	jmp    c80f <PMRLC_BUFFERREP_REQ+0x29f>
    c861:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c868:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c86b:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c871:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c874:	74 72                	je     c8e8 <PMRLC_BUFFERREP_REQ+0x378>
    c876:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    c879:	eb 2d                	jmp    c8a8 <PMRLC_BUFFERREP_REQ+0x338>
    c87b:	90                   	nop
    c87c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c880:	83 c2 02             	add    $0x2,%edx
    c883:	89 53 03             	mov    %edx,0x3(%ebx)
				}
				else
				{
					mioctrl->txQueueSize += 3;
				}
				mioctrl->retxQueueSize = 0;
    c886:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->statusPduSize = 0;
    c88d:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
				mioctrl->statusPduHeader = 0;
    c893:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
				mioctrl->retxQueueHeader = 0;
    c899:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				//fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize, mioctrl->lcid);
				mioctrl++;
    c89f:	83 c3 13             	add    $0x13,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c8a2:	8b 00                	mov    (%eax),%eax
    c8a4:	39 c1                	cmp    %eax,%ecx
    c8a6:	74 40                	je     c8e8 <PMRLC_BUFFERREP_REQ+0x378>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
    c8a8:	8b 50 f8             	mov    -0x8(%eax),%edx
    c8ab:	85 d2                	test   %edx,%edx
    c8ad:	74 f3                	je     c8a2 <PMRLC_BUFFERREP_REQ+0x332>
			{
				mioctrl->rnti = 0;
    c8af:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = tmTxIns->lcId;
    c8b4:	0f b6 50 e7          	movzbl -0x19(%eax),%edx
    c8b8:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    c8bb:	8b 50 f8             	mov    -0x8(%eax),%edx
				mioctrl->txQueueHeader = 0;
    c8be:	66 c7 43 07 00 00    	movw   $0x0,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c8c4:	83 fa 7f             	cmp    $0x7f,%edx
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    c8c7:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c8ca:	76 b4                	jbe    c880 <PMRLC_BUFFERREP_REQ+0x310>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c8cc:	83 c2 03             	add    $0x3,%edx
    c8cf:	89 53 03             	mov    %edx,0x3(%ebx)
    c8d2:	eb b2                	jmp    c886 <PMRLC_BUFFERREP_REQ+0x316>
		}
	}
	
	if(num == 0)
	{
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] There is no data to report\n");
    c8d4:	c7 04 24 ac 34 00 00 	movl   $0x34ac,(%esp)
    c8db:	e8 fc ff ff ff       	call   c8dc <PMRLC_BUFFERREP_REQ+0x36c>
		if( SV(bufferReqTimer) )
		{
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}*/
		return NULL; 	//modify 20150901
    c8e0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    c8e7:	90                   	nop
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    c8e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
    c8eb:	83 c4 20             	add    $0x20,%esp
    c8ee:	5b                   	pop    %ebx
    c8ef:	5e                   	pop    %esi
    c8f0:	5f                   	pop    %edi
    c8f1:	5d                   	pop    %ebp
    c8f2:	c3                   	ret    
    c8f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    c8f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c900 <PMRLC_TRANSOP_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
{
    c900:	55                   	push   %ebp
    c901:	89 e5                	mov    %esp,%ebp
    c903:	57                   	push   %edi
    c904:	56                   	push   %esi
    c905:	53                   	push   %ebx
    c906:	83 ec 70             	sub    $0x70,%esp
    c909:	e8 fc ff ff ff       	call   c90a <PMRLC_TRANSOP_IND+0xa>
    c90e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	u32 subHeadLen;
	u32 size = 0;     //the total size in a buffer to transimit	
	u16 rnti;
	//int i=0;  //FOR TEST
	
	SV_PTR_GET(rlc_mac_sv);
    c911:	e8 fc ff ff ff       	call   c912 <PMRLC_TRANSOP_IND+0x12>
    c916:	89 45 cc             	mov    %eax,-0x34(%ebp)
	SV(isBufferReq) = 0;
    c919:	c6 80 24 02 00 00 00 	movb   $0x0,0x224(%eax)
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    c920:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	if(hptr == NULL)
    c923:	85 c0                	test   %eax,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	SV(isBufferReq) = 0;
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    c925:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(hptr == NULL)
    c928:	0f 84 d4 01 00 00    	je     cb02 <PMRLC_TRANSOP_IND+0x202>
	{
		FOUT;
	}	
	nump = (u32*)hptr;
	num = *nump;
    c92e:	89 c2                	mov    %eax,%edx
    c930:	8b 00                	mov    (%eax),%eax
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
    c932:	85 c0                	test   %eax,%eax
    c934:	0f 84 40 0a 00 00    	je     d37a <PMRLC_TRANSOP_IND+0xa7a>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c93a:	8b 75 b4             	mov    -0x4c(%ebp),%esi
    c93d:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    c940:	8d 04 50             	lea    (%eax,%edx,2),%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c943:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	subhead = data = sevNum = fifNum = 0;
    c946:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    c94d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c954:	83 ee 0f             	sub    $0xf,%esi
    c957:	01 f0                	add    %esi,%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c959:	83 c1 04             	add    $0x4,%ecx
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    c95c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    c95f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c962:	89 75 ac             	mov    %esi,-0x54(%ebp)
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    c965:	89 ce                	mov    %ecx,%esi
    c967:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    c96a:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    c96d:	05 18 02 00 00       	add    $0x218,%eax
    c972:	89 45 c0             	mov    %eax,-0x40(%ebp)
    c975:	8d 76 00             	lea    0x0(%esi),%esi
	subhead = data = sevNum = fifNum = 0;
	//controlelm = 14 + 10;
	while(num > 0)
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    c978:	8b 55 c0             	mov    -0x40(%ebp),%edx
    c97b:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    c97e:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    c982:	89 14 24             	mov    %edx,(%esp)
    c985:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    c988:	e8 fc ff ff ff       	call   c989 <PMRLC_TRANSOP_IND+0x89>
		switch(SV(ins_mode))
    c98d:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    c990:	8b 81 18 02 00 00    	mov    0x218(%ecx),%eax
    c996:	83 f8 02             	cmp    $0x2,%eax
    c999:	0f 84 b9 08 00 00    	je     d258 <PMRLC_TRANSOP_IND+0x958>
    c99f:	83 f8 03             	cmp    $0x3,%eax
    c9a2:	0f 84 58 07 00 00    	je     d100 <PMRLC_TRANSOP_IND+0x800>
    c9a8:	83 f8 01             	cmp    $0x1,%eax
    c9ab:	0f 84 bf 06 00 00    	je     d070 <PMRLC_TRANSOP_IND+0x770>
			}

			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    c9b1:	c7 04 24 e4 34 00 00 	movl   $0x34e4,(%esp)
    c9b8:	e8 fc ff ff ff       	call   c9b9 <PMRLC_TRANSOP_IND+0xb9>
			break;
		}	
		num--;
		if(num>0)
    c9bd:	3b 75 d0             	cmp    -0x30(%ebp),%esi
    c9c0:	74 06                	je     c9c8 <PMRLC_TRANSOP_IND+0xc8>
		{
			mIoctrl++;
    c9c2:	83 c6 13             	add    $0x13,%esi
    c9c5:	eb b1                	jmp    c978 <PMRLC_TRANSOP_IND+0x78>
    c9c7:	90                   	nop
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    c9c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    c9cb:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    c9ce:	83 c0 04             	add    $0x4,%eax
    c9d1:	e8 fc ff ff ff       	call   c9d2 <PMRLC_TRANSOP_IND+0xd2>
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c9d6:	8b 75 dc             	mov    -0x24(%ebp),%esi
    c9d9:	83 c6 04             	add    $0x4,%esi
			mIoctrl++;
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    c9dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c9df:	89 f0                	mov    %esi,%eax
    c9e1:	e8 fc ff ff ff       	call   c9e2 <PMRLC_TRANSOP_IND+0xe2>
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    c9e6:	89 f2                	mov    %esi,%edx
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    c9e8:	89 45 b8             	mov    %eax,-0x48(%ebp)
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    c9eb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c9ee:	e8 fc ff ff ff       	call   c9ef <PMRLC_TRANSOP_IND+0xef>

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    c9f3:	8b 45 b8             	mov    -0x48(%ebp),%eax
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    c9f6:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
	data = 0;     //
    c9f9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    ca00:	83 c0 04             	add    $0x4,%eax
    ca03:	89 45 ec             	mov    %eax,-0x14(%ebp)
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    ca06:	8b 01                	mov    (%ecx),%eax
	while(num > 0)
    ca08:	85 c0                	test   %eax,%eax
    ca0a:	74 60                	je     ca6c <PMRLC_TRANSOP_IND+0x16c>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    ca0c:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    ca0f:	8d 04 50             	lea    (%eax,%edx,2),%eax
    ca12:	03 45 ac             	add    -0x54(%ebp),%eax
    ca15:	89 45 bc             	mov    %eax,-0x44(%ebp)
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
	while(num > 0)
	{
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] number %d:\n", num);
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    ca18:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ca1b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    ca1e:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    ca21:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    ca25:	8b 75 c0             	mov    -0x40(%ebp),%esi
    ca28:	89 34 24             	mov    %esi,(%esp)
    ca2b:	e8 fc ff ff ff       	call   ca2c <PMRLC_TRANSOP_IND+0x12c>
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
    ca30:	8b 55 cc             	mov    -0x34(%ebp),%edx
    ca33:	8b 82 18 02 00 00    	mov    0x218(%edx),%eax
    ca39:	83 f8 02             	cmp    $0x2,%eax
    ca3c:	0f 84 5e 04 00 00    	je     cea0 <PMRLC_TRANSOP_IND+0x5a0>
    ca42:	83 f8 03             	cmp    $0x3,%eax
    ca45:	0f 84 dd 01 00 00    	je     cc28 <PMRLC_TRANSOP_IND+0x328>
    ca4b:	83 f8 01             	cmp    $0x1,%eax
    ca4e:	0f 84 cc 00 00 00    	je     cb20 <PMRLC_TRANSOP_IND+0x220>
				}          
            }
			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    ca54:	c7 04 24 e4 34 00 00 	movl   $0x34e4,(%esp)
    ca5b:	e8 fc ff ff ff       	call   ca5c <PMRLC_TRANSOP_IND+0x15c>
			break;
		}
	
		num--;
		if(num>0)
    ca60:	8b 75 bc             	mov    -0x44(%ebp),%esi
    ca63:	39 75 d8             	cmp    %esi,-0x28(%ebp)
    ca66:	0f 85 a4 00 00 00    	jne    cb10 <PMRLC_TRANSOP_IND+0x210>
		{
			mIoctrl++;
		}
	}
		
	if(0 == pkptr->len)
    ca6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ca6f:	8b 48 50             	mov    0x50(%eax),%ecx
    ca72:	85 c9                	test   %ecx,%ecx
    ca74:	0f 84 7d 08 00 00    	je     d2f7 <PMRLC_TRANSOP_IND+0x9f7>
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
		SV(bufferReqTimer) = 0;
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
    ca7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
	fix->E = 0;    //E0
    ca7d:	80 20 df             	andb   $0xdf,(%eax)
	icimsg->len = data;
    ca80:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ca83:	8b 55 b8             	mov    -0x48(%ebp),%edx
	icimsg->rnti = mIoctrl->rnti;
    ca86:	8b 75 d8             	mov    -0x28(%ebp),%esi
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
	fix->E = 0;    //E0
	icimsg->len = data;
    ca89:	66 89 42 02          	mov    %ax,0x2(%edx)
	icimsg->rnti = mIoctrl->rnti;
    ca8d:	0f b7 06             	movzwl (%esi),%eax
    ca90:	66 89 02             	mov    %ax,(%edx)
	fsm_mem_cpy(pkptr->head, head,  data + sizeof(MRLC_toMac_IciMsg));
    ca93:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ca96:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    ca99:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
    ca9f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    caa2:	83 c1 04             	add    $0x4,%ecx
    caa5:	e8 fc ff ff ff       	call   caa6 <PMRLC_TRANSOP_IND+0x1a6>
	fsm_mem_free(head);
    caaa:	8b 45 b8             	mov    -0x48(%ebp),%eax
    caad:	e8 fc ff ff ff       	call   caae <PMRLC_TRANSOP_IND+0x1ae>
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cab2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cab5:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
	{
		send_msg3(pkptr);
    caba:	8b 45 d0             	mov    -0x30(%ebp),%eax
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cabd:	0f 85 d9 08 00 00    	jne    d39c <PMRLC_TRANSOP_IND+0xa9c>
		send_msg3(pkptr);
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
		FOUT;
	}
	else{
		complexUeMacPdu(pkptr); //add in 20150804
    cac3:	e8 fc ff ff ff       	call   cac4 <PMRLC_TRANSOP_IND+0x1c4>
		if(SV(Tbsize_Complex)!=0)
    cac8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cacb:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    cad1:	85 d2                	test   %edx,%edx
    cad3:	74 0a                	je     cadf <PMRLC_TRANSOP_IND+0x1df>
				SV(Tbsize_Complex)=0;
    cad5:	c7 80 f4 01 00 00 00 	movl   $0x0,0x1f4(%eax)
    cadc:	00 00 00 
		
		fsm_printf("[RLC][PMRLC_TRANSOP_IND][<--] send to MAC\n");
    cadf:	c7 04 24 3c 37 00 00 	movl   $0x373c,(%esp)
    cae6:	e8 fc ff ff ff       	call   cae7 <PMRLC_TRANSOP_IND+0x1e7>
		SV(countSentToLower)++;
    caeb:	8b 45 cc             	mov    -0x34(%ebp),%eax
    caee:	83 80 98 5a 00 00 01 	addl   $0x1,0x5a98(%eax)
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] bufferReqTimer restart\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));*/
		fsm_data_destroy(hptr);
    caf5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    caf8:	e8 fc ff ff ff       	call   caf9 <PMRLC_TRANSOP_IND+0x1f9>
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
    cafd:	e8 fc ff ff ff       	call   cafe <PMRLC_TRANSOP_IND+0x1fe>
		FOUT;
	}
}
    cb02:	83 c4 70             	add    $0x70,%esp
    cb05:	5b                   	pop    %ebx
    cb06:	5e                   	pop    %esi
    cb07:	5f                   	pop    %edi
    cb08:	5d                   	pop    %ebp
    cb09:	c3                   	ret    
    cb0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
	
		num--;
		if(num>0)
		{
			mIoctrl++;
    cb10:	83 45 d8 13          	addl   $0x13,-0x28(%ebp)
    cb14:	e9 ff fe ff ff       	jmp    ca18 <PMRLC_TRANSOP_IND+0x118>
    cb19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    cb20:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cb23:	85 f6                	test   %esi,%esi
    cb25:	0f 84 35 ff ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
    cb2b:	8b 46 0c             	mov    0xc(%esi),%eax
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    cb2e:	8d 4e 0c             	lea    0xc(%esi),%ecx
    cb31:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    cb34:	39 c1                	cmp    %eax,%ecx
    cb36:	0f 84 24 ff ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
    cb3c:	8b 38                	mov    (%eax),%edi
    cb3e:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cb41:	83 ef 04             	sub    $0x4,%edi
    cb44:	eb 18                	jmp    cb5e <PMRLC_TRANSOP_IND+0x25e>
    cb46:	66 90                	xchg   %ax,%ax
    cb48:	8b 47 04             	mov    0x4(%edi),%eax
    cb4b:	8d 57 04             	lea    0x4(%edi),%edx
    cb4e:	89 fb                	mov    %edi,%ebx
    cb50:	83 e8 04             	sub    $0x4,%eax
    cb53:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cb56:	0f 84 04 ff ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
    cb5c:	89 c7                	mov    %eax,%edi
				{
					if(buffer->pkt->len < 128)
    cb5e:	8b 03                	mov    (%ebx),%eax
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cb60:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
    cb63:	8b 40 50             	mov    0x50(%eax),%eax
					{
						subHeadLen = 2;
    cb66:	3d 80 00 00 00       	cmp    $0x80,%eax
    cb6b:	19 d2                	sbb    %edx,%edx
    cb6d:	83 c2 03             	add    $0x3,%edx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cb70:	01 d0                	add    %edx,%eax
    cb72:	3b 41 03             	cmp    0x3(%ecx),%eax
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
					{
						subHeadLen = 2;
    cb75:	89 55 dc             	mov    %edx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cb78:	0f 87 e2 fe ff ff    	ja     ca60 <PMRLC_TRANSOP_IND+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cb7e:	8b 53 04             	mov    0x4(%ebx),%edx
    cb81:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cb84:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cb87:	89 10                	mov    %edx,(%eax)
						break;
					}
					else
					{
						list_del(&buffer->list);
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
    cb89:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cb8b:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cb92:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cb99:	8b 40 50             	mov    0x50(%eax),%eax
    cb9c:	29 46 14             	sub    %eax,0x14(%esi)
						tmTxIns->tmSduBufferNum--;
    cb9f:	83 6e 18 01          	subl   $0x1,0x18(%esi)
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
    cba3:	8b 03                	mov    (%ebx),%eax
    cba5:	8b 48 50             	mov    0x50(%eax),%ecx
    cba8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cbae:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cbb1:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cbb7:	89 45 a0             	mov    %eax,-0x60(%ebp)
    cbba:	e8 fc ff ff ff       	call   cbbb <PMRLC_TRANSOP_IND+0x2bb>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cbbf:	8b 03                	mov    (%ebx),%eax
    cbc1:	8b 50 50             	mov    0x50(%eax),%edx
    cbc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cbc7:	e8 fc ff ff ff       	call   cbc8 <PMRLC_TRANSOP_IND+0x2c8>

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cbcc:	8d 55 e0             	lea    -0x20(%ebp),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cbcf:	8b 03                	mov    (%ebx),%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cbd1:	8d 4d f0             	lea    -0x10(%ebp),%ecx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cbd4:	83 c0 50             	add    $0x50,%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cbd7:	89 54 24 04          	mov    %edx,0x4(%esp)
    cbdb:	0f b6 56 03          	movzbl 0x3(%esi),%edx
    cbdf:	89 14 24             	mov    %edx,(%esp)
    cbe2:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cbe5:	e8 d6 e8 ff ff       	call   b4c0 <creat_subhead.isra.0>
						mIoctrl->txQueueSize -= subHeadLen + buffer->pkt->len;
    cbea:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cbed:	8b 13                	mov    (%ebx),%edx
    cbef:	8b 41 03             	mov    0x3(%ecx),%eax
    cbf2:	2b 42 50             	sub    0x50(%edx),%eax
    cbf5:	2b 45 dc             	sub    -0x24(%ebp),%eax
    cbf8:	89 41 03             	mov    %eax,0x3(%ecx)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
    cbfb:	8b 03                	mov    (%ebx),%eax
    cbfd:	e8 fc ff ff ff       	call   cbfe <PMRLC_TRANSOP_IND+0x2fe>
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
    cc02:	89 d8                	mov    %ebx,%eax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
    cc04:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(buffer);  //20140922
    cc0a:	e8 fc ff ff ff       	call   cc0b <PMRLC_TRANSOP_IND+0x30b>
						buffer = NULL;
						if(list_empty(&tmTxIns->tmSduBuffer.list))
    cc0f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cc12:	3b 46 0c             	cmp    0xc(%esi),%eax
    cc15:	0f 85 2d ff ff ff    	jne    cb48 <PMRLC_TRANSOP_IND+0x248>
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
						buffer = NULL;
    cc1b:	31 db                	xor    %ebx,%ebx
    cc1d:	e9 3e fe ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
    cc22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
				break;
			}

		case AM_MODE:
			if(insptru == NULL)
    cc28:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cc2b:	85 f6                	test   %esi,%esi
    cc2d:	0f 84 2d fe ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cc33:	8b 86 b0 01 00 00    	mov    0x1b0(%esi),%eax
				break;
			}*/

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    cc39:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    cc3f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    cc42:	39 c2                	cmp    %eax,%edx
    cc44:	0f 84 10 01 00 00    	je     cd5a <PMRLC_TRANSOP_IND+0x45a>
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cc4a:	8b 38                	mov    (%eax),%edi
    cc4c:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cc4f:	83 ef 04             	sub    $0x4,%edi
    cc52:	e9 c0 00 00 00       	jmp    cd17 <PMRLC_TRANSOP_IND+0x417>
    cc57:	90                   	nop
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cc58:	8b 53 04             	mov    0x4(%ebx),%edx
    cc5b:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cc5e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cc61:	89 10                	mov    %edx,(%eax)
					else
					{
						list_del(&buffer->list);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu has been remove from list\n");
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] buffer->pkt->len=%d\n",buffer->pkt->len);
						SV(countSendCtrlPdu)++;
    cc63:	8b 45 cc             	mov    -0x34(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cc66:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cc6d:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cc74:	83 80 a0 5a 00 00 01 	addl   $0x1,0x5aa0(%eax)
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
    cc7b:	8b 03                	mov    (%ebx),%eax
    cc7d:	8b 40 50             	mov    0x50(%eax),%eax
    cc80:	29 86 b8 01 00 00    	sub    %eax,0x1b8(%esi)
						amIns->ctrlPduBufferNum--;
    cc86:	83 ae bc 01 00 00 01 	subl   $0x1,0x1bc(%esi)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
    cc8d:	8b 03                	mov    (%ebx),%eax
    cc8f:	8b 48 50             	mov    0x50(%eax),%ecx
    cc92:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cc98:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cc9b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cca1:	89 45 98             	mov    %eax,-0x68(%ebp)
    cca4:	e8 fc ff ff ff       	call   cca5 <PMRLC_TRANSOP_IND+0x3a5>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cca9:	8b 03                	mov    (%ebx),%eax
    ccab:	8b 50 50             	mov    0x50(%eax),%edx
    ccae:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ccb1:	e8 fc ff ff ff       	call   ccb2 <PMRLC_TRANSOP_IND+0x3b2>
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    ccb6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ccb9:	8b 13                	mov    (%ebx),%edx
    ccbb:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    ccbf:	66 2b 42 50          	sub    0x50(%edx),%ax
    ccc3:	66 2b 45 dc          	sub    -0x24(%ebp),%ax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ccc7:	8d 55 e0             	lea    -0x20(%ebp),%edx
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
						amIns->ctrlPduBufferNum--;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    ccca:	66 89 41 0f          	mov    %ax,0xf(%ecx)
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ccce:	8b 03                	mov    (%ebx),%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ccd0:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    ccd3:	89 54 24 04          	mov    %edx,0x4(%esp)
    ccd7:	0f b6 56 03          	movzbl 0x3(%esi),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ccdb:	83 c0 50             	add    $0x50,%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ccde:	89 14 24             	mov    %edx,(%esp)
    cce1:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cce4:	e8 d7 e7 ff ff       	call   b4c0 <creat_subhead.isra.0>
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] am instance mIoctrl->statusPduSize is %d, buffer->pkt->len is %d\n", \
						//	mIoctrl->statusPduSize, buffer->pkt->len);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] ctrl data transport\n");
						//fsm_octets_print(buffer->pkt->data,10);
						
						if(buffer->pkt != NULL)
    cce9:	8b 03                	mov    (%ebx),%eax
    cceb:	85 c0                	test   %eax,%eax
    cced:	74 0b                	je     ccfa <PMRLC_TRANSOP_IND+0x3fa>
						{
							fsm_pkt_destroy(buffer->pkt);  //20140922
    ccef:	e8 fc ff ff ff       	call   ccf0 <PMRLC_TRANSOP_IND+0x3f0>
							buffer->pkt = NULL;
    ccf4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						}
						if(buffer != NULL)
    ccfa:	85 db                	test   %ebx,%ebx
    ccfc:	74 07                	je     cd05 <PMRLC_TRANSOP_IND+0x405>
						{
							fsm_mem_free(buffer);  //20140922
    ccfe:	89 d8                	mov    %ebx,%eax
    cd00:	e8 fc ff ff ff       	call   cd01 <PMRLC_TRANSOP_IND+0x401>

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cd05:	8b 47 04             	mov    0x4(%edi),%eax
    cd08:	8d 57 04             	lea    0x4(%edi),%edx
    cd0b:	89 fb                	mov    %edi,%ebx
    cd0d:	83 e8 04             	sub    $0x4,%eax
    cd10:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cd13:	74 3a                	je     cd4f <PMRLC_TRANSOP_IND+0x44f>
    cd15:	89 c7                	mov    %eax,%edi
				{
					if( buffer->pkt->len < 128 )
    cd17:	8b 03                	mov    (%ebx),%eax
    cd19:	8b 50 50             	mov    0x50(%eax),%edx
					{
						subHeadLen = 2;
    cd1c:	81 fa 80 00 00 00    	cmp    $0x80,%edx
    cd22:	19 c9                	sbb    %ecx,%ecx
    cd24:	83 c1 03             	add    $0x3,%ecx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    cd27:	01 ca                	add    %ecx,%edx
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
				{
					if( buffer->pkt->len < 128 )
					{
						subHeadLen = 2;
    cd29:	89 4d dc             	mov    %ecx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    cd2c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cd2f:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    cd33:	39 c2                	cmp    %eax,%edx
    cd35:	0f 86 1d ff ff ff    	jbe    cc58 <PMRLC_TRANSOP_IND+0x358>
					{
						fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->statusPduSize is %d, data is %d\n", \
    cd3b:	89 54 24 08          	mov    %edx,0x8(%esp)
    cd3f:	89 44 24 04          	mov    %eax,0x4(%esp)
    cd43:	c7 04 24 9c 35 00 00 	movl   $0x359c,(%esp)
    cd4a:	e8 fc ff ff ff       	call   cd4b <PMRLC_TRANSOP_IND+0x44b>
							break;
						}*/
					}
				}
				//
				if( !amIns->statProhTimer )
    cd4f:	8b 7e 20             	mov    0x20(%esi),%edi
    cd52:	85 ff                	test   %edi,%edi
    cd54:	0f 84 2f 06 00 00    	je     d389 <PMRLC_TRANSOP_IND+0xa89>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    cd5a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    cd5d:	8b 48 09             	mov    0x9(%eax),%ecx
    cd60:	0f b7 50 0d          	movzwl 0xd(%eax),%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cd64:	8d 86 9c 01 00 00    	lea    0x19c(%esi),%eax
    cd6a:	89 45 c8             	mov    %eax,-0x38(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cd6d:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
    cd73:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    cd76:	0f 84 cf 01 00 00    	je     cf4b <PMRLC_TRANSOP_IND+0x64b>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    cd7c:	0f b7 d2             	movzwl %dx,%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cd7f:	01 ca                	add    %ecx,%edx
    cd81:	89 55 dc             	mov    %edx,-0x24(%ebp)
    cd84:	0f 84 c1 01 00 00    	je     cf4b <PMRLC_TRANSOP_IND+0x64b>
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    cd8a:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    cd90:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    cd93:	e9 b8 00 00 00       	jmp    ce50 <PMRLC_TRANSOP_IND+0x550>
						}
						if( subHeadLen < size )
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
    cd98:	ba 78 05 00 00       	mov    $0x578,%edx
    cd9d:	89 f8                	mov    %edi,%eax
    cd9f:	e8 fc ff ff ff       	call   cda0 <PMRLC_TRANSOP_IND+0x4a0>
    cda4:	89 c3                	mov    %eax,%ebx
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
							}

							if( amIns->pduWithoutPoll >= amIns->pollPDU || amIns->byteWithoutPoll >= amIns->pollBYTE )
    cda6:	0f b7 86 f6 22 00 00 	movzwl 0x22f6(%esi),%eax
    cdad:	66 39 86 fc 22 00 00 	cmp    %ax,0x22fc(%esi)
    cdb4:	73 10                	jae    cdc6 <PMRLC_TRANSOP_IND+0x4c6>
    cdb6:	0f b7 96 f8 22 00 00 	movzwl 0x22f8(%esi),%edx
    cdbd:	66 39 96 fe 22 00 00 	cmp    %dx,0x22fe(%esi)
    cdc4:	72 09                	jb     cdcf <PMRLC_TRANSOP_IND+0x4cf>
							{
								rlc_poll(amIns, pkp);
    cdc6:	89 da                	mov    %ebx,%edx
    cdc8:	89 f0                	mov    %esi,%eax
    cdca:	e8 fc ff ff ff       	call   cdcb <PMRLC_TRANSOP_IND+0x4cb>
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
    cdcf:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cdd2:	8b 4b 50             	mov    0x50(%ebx),%ecx
    cdd5:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    cddb:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cde1:	89 45 94             	mov    %eax,-0x6c(%ebp)
    cde4:	e8 fc ff ff ff       	call   cde5 <PMRLC_TRANSOP_IND+0x4e5>
							fsm_skb_put( pkptr,pkp->len);
    cde9:	8b 53 50             	mov    0x50(%ebx),%edx
    cdec:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cdef:	e8 fc ff ff ff       	call   cdf0 <PMRLC_TRANSOP_IND+0x4f0>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cdf4:	8d 43 50             	lea    0x50(%ebx),%eax
    cdf7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
								rlc_poll(amIns, pkp);
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
    cdfa:	8d 45 e0             	lea    -0x20(%ebp),%eax
    cdfd:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    ce00:	8d 55 ec             	lea    -0x14(%ebp),%edx
    ce03:	89 44 24 04          	mov    %eax,0x4(%esp)
    ce07:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    ce0b:	89 04 24             	mov    %eax,(%esp)
    ce0e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ce11:	e8 aa e6 ff ff       	call   b4c0 <creat_subhead.isra.0>
							size -= pkp->len + subHeadLen;
    ce16:	8b 53 50             	mov    0x50(%ebx),%edx
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND] am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, pkp->len);

							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
    ce19:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    ce20:	01 
							amIns->byteWithoutPoll += pkp->len;  //??
    ce21:	8b 43 50             	mov    0x50(%ebx),%eax
    ce24:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    ce2b:	89 d8                	mov    %ebx,%eax
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
							size -= pkp->len + subHeadLen;
    ce2d:	29 55 dc             	sub    %edx,-0x24(%ebp)
    ce30:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    ce33:	29 4d dc             	sub    %ecx,-0x24(%ebp)
							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
							amIns->byteWithoutPoll += pkp->len;  //??
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    ce36:	e8 fc ff ff ff       	call   ce37 <PMRLC_TRANSOP_IND+0x537>
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    ce3b:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    ce41:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    ce44:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    ce4a:	0f 84 f8 00 00 00    	je     cf48 <PMRLC_TRANSOP_IND+0x648>
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
    ce50:	0f bf 97 94 00 00 00 	movswl 0x94(%edi),%edx
    ce57:	89 f0                	mov    %esi,%eax
    ce59:	e8 fc ff ff ff       	call   ce5a <PMRLC_TRANSOP_IND+0x55a>
    ce5e:	84 c0                	test   %al,%al
    ce60:	74 d9                	je     ce3b <PMRLC_TRANSOP_IND+0x53b>
					{
						if( amBuffer->pkt->len < 128 )
    ce62:	8b 07                	mov    (%edi),%eax
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    ce64:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
    ce67:	8b 40 50             	mov    0x50(%eax),%eax
						{
							subHeadLen = 2;
    ce6a:	3d 80 00 00 00       	cmp    $0x80,%eax
    ce6f:	19 d2                	sbb    %edx,%edx
    ce71:	83 c2 03             	add    $0x3,%edx
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    ce74:	39 ca                	cmp    %ecx,%edx
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
						{
							subHeadLen = 2;
    ce76:	89 55 d4             	mov    %edx,-0x2c(%ebp)
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    ce79:	0f 83 a1 04 00 00    	jae    d320 <PMRLC_TRANSOP_IND+0xa20>
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
    ce7f:	89 ca                	mov    %ecx,%edx
    ce81:	2b 55 d4             	sub    -0x2c(%ebp),%edx
    ce84:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    ce8a:	0f 87 08 ff ff ff    	ja     cd98 <PMRLC_TRANSOP_IND+0x498>
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
							}
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
    ce90:	89 f8                	mov    %edi,%eax
    ce92:	e8 fc ff ff ff       	call   ce93 <PMRLC_TRANSOP_IND+0x593>
    ce97:	89 c3                	mov    %eax,%ebx
    ce99:	e9 08 ff ff ff       	jmp    cda6 <PMRLC_TRANSOP_IND+0x4a6>
    ce9e:	66 90                	xchg   %ax,%ax
				}
			}
			break;

		case UM_MODE:
			if(insptru == NULL)
    cea0:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    cea3:	85 ff                	test   %edi,%edi
    cea5:	0f 84 b5 fb ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ceab:	8b 75 d8             	mov    -0x28(%ebp),%esi
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    ceae:	81 7f 20 80 00 00 00 	cmpl   $0x80,0x20(%edi)
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ceb5:	8b 4e 03             	mov    0x3(%esi),%ecx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    ceb8:	19 c0                	sbb    %eax,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    ceba:	0f b7 56 07          	movzwl 0x7(%esi),%edx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    cebe:	83 c0 03             	add    $0x3,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    cec1:	01 ca                	add    %ecx,%edx
    cec3:	39 d0                	cmp    %edx,%eax
    cec5:	0f 83 cd 03 00 00    	jae    d298 <PMRLC_TRANSOP_IND+0x998>
			{
				//pkp = rlc_UM_segment(umTxIns , mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);//mIoctrl->txQueueHeader,  /20140726
				if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen > MAX_PDU_SIZE )
    cecb:	29 c2                	sub    %eax,%edx
    cecd:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    ced3:	0f 86 af 03 00 00    	jbe    d288 <PMRLC_TRANSOP_IND+0x988>
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
    ced9:	ba 78 05 00 00       	mov    $0x578,%edx
    cede:	89 f8                	mov    %edi,%eax
    cee0:	e8 fc ff ff ff       	call   cee1 <PMRLC_TRANSOP_IND+0x5e1>
    cee5:	89 c6                	mov    %eax,%esi
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
    cee7:	85 f6                	test   %esi,%esi
    cee9:	0f 84 e2 04 00 00    	je     d3d1 <PMRLC_TRANSOP_IND+0xad1>
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    ceef:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cef2:	8b 4e 50             	mov    0x50(%esi),%ecx
    cef5:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    cefb:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cf01:	89 45 9c             	mov    %eax,-0x64(%ebp)
    cf04:	e8 fc ff ff ff       	call   cf05 <PMRLC_TRANSOP_IND+0x605>
				fsm_skb_put( pkptr,pkp->len);
    cf09:	8b 56 50             	mov    0x50(%esi),%edx
    cf0c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf0f:	e8 fc ff ff ff       	call   cf10 <PMRLC_TRANSOP_IND+0x610>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cf14:	8d 46 50             	lea    0x50(%esi),%eax
    cf17:	89 45 dc             	mov    %eax,-0x24(%ebp)
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
				fsm_skb_put( pkptr,pkp->len);
				creat_subhead(pkp, &ptr,  &preptr, umTxIns->lcid, &data);
    cf1a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    cf1d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cf20:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cf23:	89 44 24 04          	mov    %eax,0x4(%esp)
    cf27:	0f b6 47 03          	movzbl 0x3(%edi),%eax
    cf2b:	89 04 24             	mov    %eax,(%esp)
    cf2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cf31:	e8 8a e5 ff ff       	call   b4c0 <creat_subhead.isra.0>

				fsm_pkt_destroy(pkp);  //20140922
    cf36:	89 f0                	mov    %esi,%eax
    cf38:	e8 fc ff ff ff       	call   cf39 <PMRLC_TRANSOP_IND+0x639>
				pkp = NULL;
				break;
    cf3d:	e9 1e fb ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
    cf42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    cf48:	8b 5d b0             	mov    -0x50(%ebp),%ebx
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    cf4b:	8b 55 d8             	mov    -0x28(%ebp),%edx
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cf4e:	89 f0                	mov    %esi,%eax
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    cf50:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cf53:	8b 52 03             	mov    0x3(%edx),%edx
    cf56:	0f b7 79 07          	movzwl 0x7(%ecx),%edi
    cf5a:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cf5d:	0f bf 56 2e          	movswl 0x2e(%esi),%edx
    cf61:	e8 fc ff ff ff       	call   cf62 <PMRLC_TRANSOP_IND+0x662>
    cf66:	84 c0                	test   %al,%al
    cf68:	0f 84 f2 fa ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    cf6e:	0f b7 ff             	movzwl %di,%edi
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    cf71:	03 7d dc             	add    -0x24(%ebp),%edi
    cf74:	0f 84 e6 fa ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
    cf7a:	8d 46 44             	lea    0x44(%esi),%eax
    cf7d:	39 46 44             	cmp    %eax,0x44(%esi)
    cf80:	0f 84 da fa ff ff    	je     ca60 <PMRLC_TRANSOP_IND+0x160>
			//if(((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
			{
				//fsm_printf("[RLC][PMRLC_TRANSOP_IND] run to am sdu transport\n");
				if( amIns->amSduBufferSize < 128 )
				{
					subHeadLen = 2;
    cf86:	81 7e 4c 80 00 00 00 	cmpl   $0x80,0x4c(%esi)
    cf8d:	19 c0                	sbb    %eax,%eax
    cf8f:	83 c0 03             	add    $0x3,%eax
				}
				else
				{
					subHeadLen = 3;
				}
				if( size > subHeadLen )
    cf92:	39 f8                	cmp    %edi,%eax
    cf94:	0f 83 b8 03 00 00    	jae    d352 <PMRLC_TRANSOP_IND+0xa52>
				{
					if( size - subHeadLen > MAX_PDU_SIZE )
    cf9a:	29 c7                	sub    %eax,%edi
    cf9c:	81 ff 78 05 00 00    	cmp    $0x578,%edi
    cfa2:	0f 86 9a 03 00 00    	jbe    d342 <PMRLC_TRANSOP_IND+0xa42>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
    cfa8:	ba 78 05 00 00       	mov    $0x578,%edx
    cfad:	89 f0                	mov    %esi,%eax
    cfaf:	e8 fc ff ff ff       	call   cfb0 <PMRLC_TRANSOP_IND+0x6b0>
    cfb4:	89 c7                	mov    %eax,%edi
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
    cfb6:	85 ff                	test   %edi,%edi
    cfb8:	0f 84 02 04 00 00    	je     d3c0 <PMRLC_TRANSOP_IND+0xac0>
						//fsm_printf("[RLC] pduWithoutPoll is %d\n",amIns->pduWithoutPoll);
						//fsm_printf("[RLC] byteWithoutPoll is %d\n",amIns->byteWithoutPoll);
						rlc_poll(amIns,pkp);
					}*/
					//printk("[RLC][PMRLC_TRANSOP_IND] size=%d, pkp->len=%d, subHeadLen=%d\n",size,pkp->len,subHeadLen);
					fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    cfbe:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cfc1:	8b 4f 50             	mov    0x50(%edi),%ecx
    cfc4:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    cfca:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cfd0:	89 45 90             	mov    %eax,-0x70(%ebp)
    cfd3:	e8 fc ff ff ff       	call   cfd4 <PMRLC_TRANSOP_IND+0x6d4>
					if(pkptr->tail+pkp->len > pkptr->end)
    cfd8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    cfdb:	8b 57 50             	mov    0x50(%edi),%edx
    cfde:	89 d0                	mov    %edx,%eax
    cfe0:	03 81 a0 00 00 00    	add    0xa0(%ecx),%eax
    cfe6:	39 81 a4 00 00 00    	cmp    %eax,0xa4(%ecx)
    cfec:	0f 82 10 fb ff ff    	jb     cb02 <PMRLC_TRANSOP_IND+0x202>
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
    cff2:	89 c8                	mov    %ecx,%eax
    cff4:	e8 fc ff ff ff       	call   cff5 <PMRLC_TRANSOP_IND+0x6f5>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cff9:	8d 47 50             	lea    0x50(%edi),%eax
    cffc:	89 45 dc             	mov    %eax,-0x24(%ebp)
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
    cfff:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d002:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d005:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d008:	89 44 24 04          	mov    %eax,0x4(%esp)
    d00c:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    d010:	89 04 24             	mov    %eax,(%esp)
    d013:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d016:	e8 a5 e4 ff ff       	call   b4c0 <creat_subhead.isra.0>
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d01b:	0f bf 86 64 12 00 00 	movswl 0x1264(%esi),%eax
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
    d022:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    d029:	01 
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d02a:	83 c0 01             	add    $0x1,%eax
    d02d:	89 c2                	mov    %eax,%edx
    d02f:	c1 fa 1f             	sar    $0x1f,%edx
    d032:	c1 ea 16             	shr    $0x16,%edx
    d035:	01 d0                	add    %edx,%eax
    d037:	25 ff 03 00 00       	and    $0x3ff,%eax
    d03c:	29 d0                	sub    %edx,%eax

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d03e:	ba 0a 00 00 00       	mov    $0xa,%edx
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d043:	66 89 86 64 12 00 00 	mov    %ax,0x1264(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
    d04a:	8b 47 50             	mov    0x50(%edi),%eax
    d04d:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d054:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    d05a:	e8 fc ff ff ff       	call   d05b <PMRLC_TRANSOP_IND+0x75b>

					fsm_pkt_destroy(pkp);  //20140922
    d05f:	89 f8                	mov    %edi,%eax
    d061:	e8 fc ff ff ff       	call   d062 <PMRLC_TRANSOP_IND+0x762>
    d066:	e9 f5 f9 ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
    d06b:	90                   	nop
    d06c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    d070:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d073:	85 c0                	test   %eax,%eax
    d075:	0f 84 42 f9 ff ff    	je     c9bd <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d07b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d07e:	8d 78 0c             	lea    0xc(%eax),%edi
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d081:	8b 56 03             	mov    0x3(%esi),%edx
    d084:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    d088:	01 d3                	add    %edx,%ebx
    d08a:	01 d9                	add    %ebx,%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d08c:	31 db                	xor    %ebx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d08e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d091:	8b 48 0c             	mov    0xc(%eax),%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d094:	39 cf                	cmp    %ecx,%edi
    d096:	74 5c                	je     d0f4 <PMRLC_TRANSOP_IND+0x7f4>
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
    d098:	8b 41 fc             	mov    -0x4(%ecx),%eax
    d09b:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d09e:	29 c2                	sub    %eax,%edx
    d0a0:	78 52                	js     d0f4 <PMRLC_TRANSOP_IND+0x7f4>
    d0a2:	89 75 c8             	mov    %esi,-0x38(%ebp)
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d0a5:	83 e9 04             	sub    $0x4,%ecx
    d0a8:	31 f6                	xor    %esi,%esi
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
    d0aa:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    d0b1:	eb 20                	jmp    d0d3 <PMRLC_TRANSOP_IND+0x7d3>
    d0b3:	90                   	nop
    d0b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d0b8:	8b 41 04             	mov    0x4(%ecx),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
			{
				if(txBuffer->pkt->len < 127)
				{
					(*sevNum)++;
    d0bb:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d0be:	39 c7                	cmp    %eax,%edi
    d0c0:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d0c3:	74 20                	je     d0e5 <PMRLC_TRANSOP_IND+0x7e5>
		{
			size -= txBuffer->pkt->len;
    d0c5:	8b 40 fc             	mov    -0x4(%eax),%eax
    d0c8:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d0cb:	29 c2                	sub    %eax,%edx
    d0cd:	0f 88 e5 01 00 00    	js     d2b8 <PMRLC_TRANSOP_IND+0x9b8>
			{
				if(txBuffer->pkt->len < 127)
    d0d3:	83 f8 7e             	cmp    $0x7e,%eax
    d0d6:	76 e0                	jbe    d0b8 <PMRLC_TRANSOP_IND+0x7b8>
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d0d8:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d0db:	83 c3 01             	add    $0x1,%ebx
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d0de:	39 c7                	cmp    %eax,%edi
    d0e0:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d0e3:	75 e0                	jne    d0c5 <PMRLC_TRANSOP_IND+0x7c5>
    d0e5:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    d0e8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d0eb:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d0ee:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d0f1:	8d 1c 48             	lea    (%eax,%ecx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d0f4:	01 5d dc             	add    %ebx,-0x24(%ebp)
			break;
    d0f7:	e9 c1 f8 ff ff       	jmp    c9bd <PMRLC_TRANSOP_IND+0xbd>
    d0fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			//fsm_printf("[RLC][PMRLC_TRANSOP_IND] um instance(lcid is %d)'s buffer's subhead is %d \n",umTxIns->lcid,subhead);
			break;

		case AM_MODE:
			if(insptru == NULL)
    d100:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d103:	85 ff                	test   %edi,%edi
    d105:	0f 84 b2 f8 ff ff    	je     c9bd <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d10b:	8b 56 03             	mov    0x3(%esi),%edx
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d10e:	8d 9f 9c 01 00 00    	lea    0x19c(%edi),%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d114:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d118:	8b 4d e0             	mov    -0x20(%ebp),%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d11b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    d122:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d129:	01 d0                	add    %edx,%eax
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d12b:	8b 56 09             	mov    0x9(%esi),%edx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d12e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    d131:	0f b7 46 0d          	movzwl 0xd(%esi),%eax
    d135:	01 d1                	add    %edx,%ecx
    d137:	01 c1                	add    %eax,%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d139:	0f b7 46 11          	movzwl 0x11(%esi),%eax
    d13d:	01 c8                	add    %ecx,%eax
    d13f:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    d143:	01 c8                	add    %ecx,%eax
    d145:	89 4d bc             	mov    %ecx,-0x44(%ebp)
    d148:	8b 8f 9c 01 00 00    	mov    0x19c(%edi),%ecx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d14e:	03 45 d4             	add    -0x2c(%ebp),%eax
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d151:	39 cb                	cmp    %ecx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d153:	89 45 e0             	mov    %eax,-0x20(%ebp)
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d156:	74 78                	je     d1d0 <PMRLC_TRANSOP_IND+0x8d0>
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d158:	8b 81 64 ff ff ff    	mov    -0x9c(%ecx),%eax
    d15e:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d161:	29 c2                	sub    %eax,%edx
    d163:	0f 88 4c 02 00 00    	js     d3b5 <PMRLC_TRANSOP_IND+0xab5>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d169:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
    d16f:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
    d172:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
    d175:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d178:	31 f6                	xor    %esi,%esi
    d17a:	89 7d a8             	mov    %edi,-0x58(%ebp)
    d17d:	31 ff                	xor    %edi,%edi
    d17f:	eb 2b                	jmp    d1ac <PMRLC_TRANSOP_IND+0x8ac>
    d181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    d188:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
			size -= amBuffer->pkt->len;
			if(0 <= size)
			{
				if(amBuffer->pkt->len  <  128)
				{
					(*sevNum)++;
    d18e:	83 c7 01             	add    $0x1,%edi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d191:	39 c3                	cmp    %eax,%ebx
    d193:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d199:	74 29                	je     d1c4 <PMRLC_TRANSOP_IND+0x8c4>
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d19b:	8b 80 64 ff ff ff    	mov    -0x9c(%eax),%eax
    d1a1:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d1a4:	29 c2                	sub    %eax,%edx
    d1a6:	0f 88 24 01 00 00    	js     d2d0 <PMRLC_TRANSOP_IND+0x9d0>
			{
				if(amBuffer->pkt->len  <  128)
    d1ac:	83 f8 7f             	cmp    $0x7f,%eax
    d1af:	76 d7                	jbe    d188 <PMRLC_TRANSOP_IND+0x888>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d1b1:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d1b7:	83 c6 01             	add    $0x1,%esi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d1ba:	39 c3                	cmp    %eax,%ebx
    d1bc:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d1c2:	75 d7                	jne    d19b <PMRLC_TRANSOP_IND+0x89b>
    d1c4:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d1c7:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d1ca:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d1cd:	8b 7d a8             	mov    -0x58(%ebp),%edi
    d1d0:	8b 8f b0 01 00 00    	mov    0x1b0(%edi),%ecx
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d1d6:	8d 9f b0 01 00 00    	lea    0x1b0(%edi),%ebx

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
    d1dc:	31 ff                	xor    %edi,%edi
    d1de:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d1e5:	39 cb                	cmp    %ecx,%ebx
    d1e7:	74 46                	je     d22f <PMRLC_TRANSOP_IND+0x92f>
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d1e9:	8b 41 fc             	mov    -0x4(%ecx),%eax
			if(0 <= size)
    d1ec:	8b 55 bc             	mov    -0x44(%ebp),%edx
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d1ef:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d1f2:	29 c2                	sub    %eax,%edx
    d1f4:	78 39                	js     d22f <PMRLC_TRANSOP_IND+0x92f>
    d1f6:	89 75 bc             	mov    %esi,-0x44(%ebp)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d1f9:	83 e9 04             	sub    $0x4,%ecx
    d1fc:	31 f6                	xor    %esi,%esi
    d1fe:	eb 17                	jmp    d217 <PMRLC_TRANSOP_IND+0x917>
    d200:	8b 41 04             	mov    0x4(%ecx),%eax
			size -= statBuffer->pkt->len;
			if(0 <= size)
			{
				if(statBuffer->pkt->len< 128)
				{
					(*sevNum)++;
    d203:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d206:	39 c3                	cmp    %eax,%ebx
    d208:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d20b:	74 1c                	je     d229 <PMRLC_TRANSOP_IND+0x929>
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d20d:	8b 40 fc             	mov    -0x4(%eax),%eax
    d210:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d213:	29 c2                	sub    %eax,%edx
    d215:	78 12                	js     d229 <PMRLC_TRANSOP_IND+0x929>
			{
				if(statBuffer->pkt->len< 128)
    d217:	83 f8 7f             	cmp    $0x7f,%eax
    d21a:	76 e4                	jbe    d200 <PMRLC_TRANSOP_IND+0x900>
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d21c:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					( *fifNum)++;
    d21f:	83 c7 01             	add    $0x1,%edi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d222:	39 c3                	cmp    %eax,%ebx
    d224:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d227:	75 e4                	jne    d20d <PMRLC_TRANSOP_IND+0x90d>
    d229:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d22c:	8b 75 bc             	mov    -0x44(%ebp),%esi
    d22f:	03 7d c8             	add    -0x38(%ebp),%edi
    d232:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d235:	03 45 c4             	add    -0x3c(%ebp),%eax
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d238:	8d 14 7f             	lea    (%edi,%edi,2),%edx
    d23b:	8d 04 42             	lea    (%edx,%eax,2),%eax
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
			check_stat_num(amIns,mIoctrl->statusPduSize, &sevNum, &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d23e:	03 45 dc             	add    -0x24(%ebp),%eax
			//fsm_printf("am instance(lcid is %d)'s status buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{				
				subhead += 2;
    d241:	8d 50 02             	lea    0x2(%eax),%edx
    d244:	83 c0 03             	add    $0x3,%eax
    d247:	83 7d d4 7f          	cmpl   $0x7f,-0x2c(%ebp)
    d24b:	0f 46 c2             	cmovbe %edx,%eax
    d24e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    d251:	e9 67 f7 ff ff       	jmp    c9bd <PMRLC_TRANSOP_IND+0xbd>
    d256:	66 90                	xchg   %ax,%ax
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			break;

		case UM_MODE:
			if(insptru == NULL)
    d258:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d25b:	85 c0                	test   %eax,%eax
    d25d:	0f 84 5a f7 ff ff    	je     c9bd <PMRLC_TRANSOP_IND+0xbd>
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d263:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d266:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d269:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d26d:	03 46 03             	add    0x3(%esi),%eax
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d270:	83 c2 02             	add    $0x2,%edx
    d273:	83 c1 03             	add    $0x3,%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d276:	01 45 e0             	add    %eax,-0x20(%ebp)
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d279:	83 f8 7f             	cmp    $0x7f,%eax
    d27c:	0f 47 d1             	cmova  %ecx,%edx
    d27f:	89 55 dc             	mov    %edx,-0x24(%ebp)
    d282:	e9 36 f7 ff ff       	jmp    c9bd <PMRLC_TRANSOP_IND+0xbd>
    d287:	90                   	nop
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
				}
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
    d288:	89 f8                	mov    %edi,%eax
    d28a:	e8 fc ff ff ff       	call   d28b <PMRLC_TRANSOP_IND+0x98b>
    d28f:	89 c6                	mov    %eax,%esi
    d291:	e9 51 fc ff ff       	jmp    cee7 <PMRLC_TRANSOP_IND+0x5e7>
    d296:	66 90                	xchg   %ax,%ax
				pkp = NULL;
				break;
			}
			else
			{
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
    d298:	8b 13                	mov    (%ebx),%edx
    d29a:	03 42 50             	add    0x50(%edx),%eax
    d29d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    d2a1:	c7 04 24 44 35 00 00 	movl   $0x3544,(%esp)
    d2a8:	89 44 24 08          	mov    %eax,0x8(%esp)
    d2ac:	e8 fc ff ff ff       	call   d2ad <PMRLC_TRANSOP_IND+0x9ad>
				break;
    d2b1:	e9 aa f7 ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
    d2b6:	66 90                	xchg   %ax,%ax
    d2b8:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d2bb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d2be:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d2c1:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d2c4:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d2c7:	01 5d dc             	add    %ebx,-0x24(%ebp)
    d2ca:	e9 ee f6 ff ff       	jmp    c9bd <PMRLC_TRANSOP_IND+0xbd>
    d2cf:	90                   	nop
    d2d0:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d2d3:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d2d6:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d2d9:	8b 7d a8             	mov    -0x58(%ebp),%edi
					(*fifNum)++;
				}
			}
			else
			{
				if(( size + amBuffer->pkt->len + 2 ) < 128)
    d2dc:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    d2e0:	83 f8 7f             	cmp    $0x7f,%eax
    d2e3:	77 09                	ja     d2ee <PMRLC_TRANSOP_IND+0x9ee>
				{
					(*sevNum)++;
    d2e5:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
    d2e9:	e9 e2 fe ff ff       	jmp    d1d0 <PMRLC_TRANSOP_IND+0x8d0>
				}
				else
				{
					(*fifNum)++;
    d2ee:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
    d2f2:	e9 d9 fe ff ff       	jmp    d1d0 <PMRLC_TRANSOP_IND+0x8d0>
		}
	}
		
	if(0 == pkptr->len)
	{
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
    d2f7:	c7 04 24 e8 36 00 00 	movl   $0x36e8,(%esp)
    d2fe:	e8 fc ff ff ff       	call   d2ff <PMRLC_TRANSOP_IND+0x9ff>
		SV(bufferReqTimer) = 0;
    d303:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d306:	c7 80 34 37 00 00 00 	movl   $0x0,0x3734(%eax)
    d30d:	00 00 00 
		fsm_data_destroy(hptr);
    d310:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d313:	e8 fc ff ff ff       	call   d314 <PMRLC_TRANSOP_IND+0xa14>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d318:	83 c4 70             	add    $0x70,%esp
    d31b:	5b                   	pop    %ebx
    d31c:	5e                   	pop    %esi
    d31d:	5f                   	pop    %edi
    d31e:	5d                   	pop    %ebp
    d31f:	c3                   	ret    
							fsm_pkt_destroy(pkp);  //20140922
							pkp = NULL;
						}
						else
						{
							fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] break:am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, amBuffer->pkt->len+subHeadLen);
    d320:	03 45 d4             	add    -0x2c(%ebp),%eax
    d323:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    d326:	c7 04 24 f4 35 00 00 	movl   $0x35f4,(%esp)
    d32d:	89 44 24 08          	mov    %eax,0x8(%esp)
    d331:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d334:	89 44 24 04          	mov    %eax,0x4(%esp)
    d338:	e8 fc ff ff ff       	call   d339 <PMRLC_TRANSOP_IND+0xa39>
							break;
    d33d:	e9 09 fc ff ff       	jmp    cf4b <PMRLC_TRANSOP_IND+0x64b>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
    d342:	89 fa                	mov    %edi,%edx
    d344:	89 f0                	mov    %esi,%eax
    d346:	e8 fc ff ff ff       	call   d347 <PMRLC_TRANSOP_IND+0xa47>
    d34b:	89 c7                	mov    %eax,%edi
    d34d:	e9 64 fc ff ff       	jmp    cfb6 <PMRLC_TRANSOP_IND+0x6b6>
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
    d352:	8b 13                	mov    (%ebx),%edx
					fsm_pkt_destroy(pkp);  //20140922
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
    d354:	8b 75 d8             	mov    -0x28(%ebp),%esi
    d357:	03 42 50             	add    0x50(%edx),%eax
    d35a:	89 44 24 08          	mov    %eax,0x8(%esp)
    d35e:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d362:	03 46 03             	add    0x3(%esi),%eax
    d365:	c7 04 24 7c 36 00 00 	movl   $0x367c,(%esp)
    d36c:	89 44 24 04          	mov    %eax,0x4(%esp)
    d370:	e8 fc ff ff ff       	call   d371 <PMRLC_TRANSOP_IND+0xa71>
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
					break;
    d375:	e9 e6 f6 ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
	nump = (u32*)hptr;
	num = *nump;
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
	{
		fsm_data_destroy(hptr);
    d37a:	89 d0                	mov    %edx,%eax
    d37c:	e8 fc ff ff ff       	call   d37d <PMRLC_TRANSOP_IND+0xa7d>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d381:	83 c4 70             	add    $0x70,%esp
    d384:	5b                   	pop    %ebx
    d385:	5e                   	pop    %esi
    d386:	5f                   	pop    %edi
    d387:	5d                   	pop    %ebp
    d388:	c3                   	ret    
				}
				//
				if( !amIns->statProhTimer )
				{
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] the statProhTimer start\n");
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    d389:	8b 56 24             	mov    0x24(%esi),%edx
    d38c:	8b 46 28             	mov    0x28(%esi),%eax
    d38f:	e8 fc ff ff ff       	call   d390 <PMRLC_TRANSOP_IND+0xa90>
    d394:	89 46 20             	mov    %eax,0x20(%esi)
    d397:	e9 be f9 ff ff       	jmp    cd5a <PMRLC_TRANSOP_IND+0x45a>
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
	{
		send_msg3(pkptr);
    d39c:	e8 fc ff ff ff       	call   d39d <PMRLC_TRANSOP_IND+0xa9d>
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
    d3a1:	c7 04 24 1c 37 00 00 	movl   $0x371c,(%esp)
    d3a8:	e8 fc ff ff ff       	call   d3a9 <PMRLC_TRANSOP_IND+0xaa9>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d3ad:	83 c4 70             	add    $0x70,%esp
    d3b0:	5b                   	pop    %ebx
    d3b1:	5e                   	pop    %esi
    d3b2:	5f                   	pop    %edi
    d3b3:	5d                   	pop    %ebp
    d3b4:	c3                   	ret    
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d3b5:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d3b8:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d3bb:	e9 1c ff ff ff       	jmp    d2dc <PMRLC_TRANSOP_IND+0x9dc>
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
					{
						printk("[RLC][PMRLC_TRANSOP_IND][AM] pkp == NULL\n");
    d3c0:	c7 04 24 50 36 00 00 	movl   $0x3650,(%esp)
    d3c7:	e8 fc ff ff ff       	call   d3c8 <PMRLC_TRANSOP_IND+0xac8>
						break;
    d3cc:	e9 8f f6 ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
    d3d1:	c7 04 24 18 35 00 00 	movl   $0x3518,(%esp)
    d3d8:	e8 fc ff ff ff       	call   d3d9 <PMRLC_TRANSOP_IND+0xad9>
					break;
    d3dd:	e9 7e f6 ff ff       	jmp    ca60 <PMRLC_TRANSOP_IND+0x160>
    d3e2:	90                   	nop
    d3e3:	90                   	nop
    d3e4:	90                   	nop
    d3e5:	90                   	nop
    d3e6:	90                   	nop
    d3e7:	90                   	nop
    d3e8:	90                   	nop
    d3e9:	90                   	nop
    d3ea:	90                   	nop
    d3eb:	90                   	nop
    d3ec:	90                   	nop
    d3ed:	90                   	nop
    d3ee:	90                   	nop
    d3ef:	90                   	nop

0000d3f0 <get_AmPduhdExt>:
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d3f0:	55                   	push   %ebp
    d3f1:	89 e5                	mov    %esp,%ebp
    d3f3:	83 ec 14             	sub    $0x14,%esp
    d3f6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d3f9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d3fc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d3ff:	e8 fc ff ff ff       	call   d400 <get_AmPduhdExt+0x10>
    d404:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d407:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d40b:	89 d6                	mov    %edx,%esi
    d40d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d40f:	74 0f                	je     d420 <get_AmPduhdExt+0x30>
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
	}
	return count;
}
    d411:	89 d8                	mov    %ebx,%eax
    d413:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d416:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d419:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d41c:	89 ec                	mov    %ebp,%esp
    d41e:	5d                   	pop    %ebp
    d41f:	c3                   	ret    
u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d420:	8b 02                	mov    (%edx),%eax
    d422:	b9 02 00 00 00       	mov    $0x2,%ecx

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d427:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d42d:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d433:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d436:	e8 fc ff ff ff       	call   d437 <get_AmPduhdExt+0x47>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d43b:	8b 06                	mov    (%esi),%eax
    d43d:	ba 02 00 00 00       	mov    $0x2,%edx
    d442:	e8 fc ff ff ff       	call   d443 <get_AmPduhdExt+0x53>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d447:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d44b:	0f b7 d3             	movzwl %bx,%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
    d44e:	83 c3 01             	add    $0x1,%ebx
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d451:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d454:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d45a:	66 25 ff 7f          	and    $0x7fff,%ax
    d45e:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d463:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d468:	89 f2                	mov    %esi,%edx
    d46a:	89 3c 24             	mov    %edi,(%esp)
    d46d:	e8 fc ff ff ff       	call   d46e <get_AmPduhdExt+0x7e>
	}
	return count;
}
    d472:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d475:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d478:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d47a:	89 d8                	mov    %ebx,%eax
    d47c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d47f:	89 ec                	mov    %ebp,%esp
    d481:	5d                   	pop    %ebp
    d482:	c3                   	ret    
    d483:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d489:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000d490 <get_UmPduhdExt>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d490:	55                   	push   %ebp
    d491:	89 e5                	mov    %esp,%ebp
    d493:	83 ec 18             	sub    $0x18,%esp
    d496:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d499:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d49c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d49f:	e8 fc ff ff ff       	call   d4a0 <get_UmPduhdExt+0x10>
    d4a4:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d4a7:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d4ab:	89 d6                	mov    %edx,%esi
    d4ad:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d4af:	74 0f                	je     d4c0 <get_UmPduhdExt+0x30>

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
	}
	return count;
}
    d4b1:	89 d8                	mov    %ebx,%eax
    d4b3:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d4b6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d4b9:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d4bc:	89 ec                	mov    %ebp,%esp
    d4be:	5d                   	pop    %ebp
    d4bf:	c3                   	ret    
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d4c0:	0f b7 c1             	movzwl %cx,%eax
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d4c3:	b9 02 00 00 00       	mov    $0x2,%ecx
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d4c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d4cb:	8b 02                	mov    (%edx),%eax
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
    d4cd:	83 c3 01             	add    $0x1,%ebx

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d4d0:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d4d6:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d4dc:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d4df:	e8 fc ff ff ff       	call   d4e0 <get_UmPduhdExt+0x50>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d4e4:	8b 06                	mov    (%esi),%eax
    d4e6:	ba 02 00 00 00       	mov    $0x2,%edx
    d4eb:	e8 fc ff ff ff       	call   d4ec <get_UmPduhdExt+0x5c>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d4f0:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d4f4:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d4f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
    d4fa:	66 25 ff 7f          	and    $0x7fff,%ax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d4fe:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d504:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d509:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d50e:	89 f2                	mov    %esi,%edx
    d510:	89 3c 24             	mov    %edi,(%esp)
    d513:	e8 fc ff ff ff       	call   d514 <get_UmPduhdExt+0x84>
	}
	return count;
}
    d518:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d51b:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d51e:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d520:	89 d8                	mov    %ebx,%eax
    d522:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d525:	89 ec                	mov    %ebp,%esp
    d527:	5d                   	pop    %ebp
    d528:	c3                   	ret    
    d529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000d530 <clear_left_pdu>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void clear_left_pdu(struct pduLeft *pdu_left)
{	
    d530:	55                   	push   %ebp
    d531:	89 e5                	mov    %esp,%ebp
    d533:	53                   	push   %ebx
    d534:	e8 fc ff ff ff       	call   d535 <clear_left_pdu+0x5>
    d539:	89 c3                	mov    %eax,%ebx
	pdu_left->SN_Left = -1;
    d53b:	66 c7 40 02 ff ff    	movw   $0xffff,0x2(%eax)
	pdu_left->SN5_Left = -1;
    d541:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
	if(pdu_left->sduLeft != NULL)
    d546:	8b 40 04             	mov    0x4(%eax),%eax
    d549:	85 c0                	test   %eax,%eax
    d54b:	74 0c                	je     d559 <clear_left_pdu+0x29>
	{
	    fsm_pkt_destroy(pdu_left->sduLeft);
    d54d:	e8 fc ff ff ff       	call   d54e <clear_left_pdu+0x1e>
		pdu_left->sduLeft = NULL;
    d552:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	}               
}
    d559:	5b                   	pop    %ebx
    d55a:	5d                   	pop    %ebp
    d55b:	c3                   	ret    
    d55c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000d560 <rlc_AM_segment>:
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d560:	55                   	push   %ebp
    d561:	89 e5                	mov    %esp,%ebp
    d563:	57                   	push   %edi
    d564:	56                   	push   %esi
    d565:	53                   	push   %ebx
    d566:	83 ec 38             	sub    $0x38,%esp
    d569:	e8 fc ff ff ff       	call   d56a <rlc_AM_segment+0xa>
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d56e:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d572:	89 c7                	mov    %eax,%edi

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d574:	8b 40 50             	mov    0x50(%eax),%eax
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d577:	66 81 e6 00 fc       	and    $0xfc00,%si
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d57c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d57f:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
    d583:	66 25 ff 03          	and    $0x3ff,%ax
    d587:	09 c6                	or     %eax,%esi
    d589:	66 89 75 f2          	mov    %si,-0xe(%ebp)
	fixhead->DorC=1;
    d58d:	66 c1 ee 08          	shr    $0x8,%si
	fixhead->RF=0;
    d591:	83 e6 1f             	and    $0x1f,%esi
	fixhead->P=1;
    d594:	83 ce a0             	or     $0xffffffa0,%esi
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d597:	83 fa 02             	cmp    $0x2,%edx
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
	fixhead->DorC=1;
	fixhead->RF=0;
	fixhead->P=1;
    d59a:	89 f1                	mov    %esi,%ecx
    d59c:	88 4d f3             	mov    %cl,-0xd(%ebp)
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d59f:	0f 86 e1 06 00 00    	jbe    dc86 <rlc_AM_segment+0x726>
    d5a5:	8b 47 44             	mov    0x44(%edi),%eax
	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
	FSM_PKT *skb;//*skb_copy;
	struct list_head *head =&(amIns->amSduBuffer.list);
    d5a8:	8d 5f 44             	lea    0x44(%edi),%ebx
    d5ab:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
    d5ae:	39 c3                	cmp    %eax,%ebx
    d5b0:	0f 84 02 05 00 00    	je     dab8 <rlc_AM_segment+0x558>
	{
		list_for_each_entry(amBuffer,head,list)
    d5b6:	8d 58 f4             	lea    -0xc(%eax),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d5b9:	8b 40 f4             	mov    -0xc(%eax),%eax
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
    d5bc:	83 ea 02             	sub    $0x2,%edx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d5bf:	8b 40 50             	mov    0x50(%eax),%eax
    d5c2:	39 c2                	cmp    %eax,%edx
    d5c4:	0f 82 5f 06 00 00    	jb     dc29 <rlc_AM_segment+0x6c9>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d5ca:	0f 84 2a 06 00 00    	je     dbfa <rlc_AM_segment+0x69a>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d5d0:	8d 48 02             	lea    0x2(%eax),%ecx
    d5d3:	39 ca                	cmp    %ecx,%edx
    d5d5:	0f 86 7d 06 00 00    	jbe    dc58 <rlc_AM_segment+0x6f8>
    d5db:	89 7d e0             	mov    %edi,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    d5de:	b9 01 00 00 00       	mov    $0x1,%ecx
    d5e3:	bf 01 00 00 00       	mov    $0x1,%edi
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d5e8:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    d5ee:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d5f4:	eb 56                	jmp    d64c <rlc_AM_segment+0xec>
    d5f6:	66 90                	xchg   %ax,%ax
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(amBuffer->pktstatus != FULL_SDU && flag)
    d5f8:	84 c9                	test   %cl,%cl
    d5fa:	74 08                	je     d604 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
    d5fc:	83 ce 14             	or     $0x14,%esi
    d5ff:	89 f1                	mov    %esi,%ecx
    d601:	88 4d f3             	mov    %cl,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    d604:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
    d608:	74 66                	je     d670 <rlc_AM_segment+0x110>
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d60a:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    d60d:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
    d610:	8d 59 f4             	lea    -0xc(%ecx),%ebx
    d613:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    d616:	0f 84 a9 03 00 00    	je     d9c5 <rlc_AM_segment+0x465>
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d61c:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d621:	83 c7 01             	add    $0x1,%edi
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d624:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d626:	8b 41 f4             	mov    -0xc(%ecx),%eax
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d629:	01 da                	add    %ebx,%edx
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d62b:	8b 5d dc             	mov    -0x24(%ebp),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d62e:	8b 40 50             	mov    0x50(%eax),%eax
    d631:	39 d0                	cmp    %edx,%eax
    d633:	0f 87 98 03 00 00    	ja     d9d1 <rlc_AM_segment+0x471>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d639:	0f 84 e7 03 00 00    	je     da26 <rlc_AM_segment+0x4c6>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d63f:	8d 48 02             	lea    0x2(%eax),%ecx
    d642:	39 d1                	cmp    %edx,%ecx
    d644:	0f 83 1b 04 00 00    	jae    da65 <rlc_AM_segment+0x505>
    d64a:	31 c9                	xor    %ecx,%ecx
			{

				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
    d64c:	66 01 45 ec          	add    %ax,-0x14(%ebp)
				if(amBuffer->pktstatus == FULL_SDU && flag)
    d650:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d654:	75 a2                	jne    d5f8 <rlc_AM_segment+0x98>
    d656:	84 c9                	test   %cl,%cl
    d658:	74 aa                	je     d604 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=0;
    d65a:	83 e6 ef             	and    $0xffffffef,%esi
					fixhead->E=1;
    d65d:	83 ce 04             	or     $0x4,%esi
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d660:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
				if(amBuffer->pktstatus == FULL_SDU && flag)
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
    d664:	89 f1                	mov    %esi,%ecx
    d666:	88 4d f3             	mov    %cl,-0xd(%ebp)
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d669:	75 9f                	jne    d60a <rlc_AM_segment+0xaa>
    d66b:	90                   	nop
    d66c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    d670:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d674:	8b 7d e0             	mov    -0x20(%ebp),%edi
				{
					if((amIns->amSduBufferNum)==1)
					{
						fixhead->E=0;
    d677:	89 f0                	mov    %esi,%eax
    d679:	83 e0 fb             	and    $0xfffffffb,%eax
    d67c:	83 7f 50 01          	cmpl   $0x1,0x50(%edi)
    d680:	0f 45 c6             	cmovne %esi,%eax
					}
					fixhead->FIsecond=0;
    d683:	83 e0 f7             	and    $0xfffffff7,%eax
    d686:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=amBuffer->pkt->len;
    d689:	8b 03                	mov    (%ebx),%eax
    d68b:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    d68f:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d693:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
    d697:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d69b:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d69f:	8d 34 58             	lea    (%eax,%ebx,2),%esi
    d6a2:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
    d6a5:	0f b7 de             	movzwl %si,%ebx
    d6a8:	89 55 e0             	mov    %edx,-0x20(%ebp)
    d6ab:	89 55 c8             	mov    %edx,-0x38(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    d6ae:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    d6b2:	0f b7 d0             	movzwl %ax,%edx
    d6b5:	c1 e2 08             	shl    $0x8,%edx
    d6b8:	66 c1 e8 08          	shr    $0x8,%ax
    d6bc:	09 d0                	or     %edx,%eax
	fsm_octets_print(fixhead,2);
    d6be:	ba 02 00 00 00       	mov    $0x2,%edx
    d6c3:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    d6c7:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d6ca:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d6cd:	e8 fc ff ff ff       	call   d6ce <rlc_AM_segment+0x16e>
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d6d2:	89 d8                	mov    %ebx,%eax
    d6d4:	e8 fc ff ff ff       	call   d6d5 <rlc_AM_segment+0x175>
	pos = head->next;
    d6d9:	8b 5f 44             	mov    0x44(%edi),%ebx
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d6dc:	66 83 7d da 01       	cmpw   $0x1,-0x26(%ebp)
    d6e1:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
	fsm_octets_print(fixhead,2);
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d6e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	pos = head->next;
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d6e7:	0f 84 f1 03 00 00    	je     dade <rlc_AM_segment+0x57e>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			amIns->amSduBufferSize -= lastCopyLen;
			tbuff->pktstatus = LAST_SEGMENT;
		}		
	}
	else if(count > 1)
    d6ed:	0f 86 79 01 00 00    	jbe    d86c <rlc_AM_segment+0x30c>
	{
		fsm_skb_reserve(skb,2*count);		
    d6f3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    d6f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d6f9:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d6fc:	e8 fc ff ff ff       	call   d6fd <rlc_AM_segment+0x19d>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d701:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    d704:	83 e9 01             	sub    $0x1,%ecx
    d707:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d70a:	01 c9                	add    %ecx,%ecx
    d70c:	89 c8                	mov    %ecx,%eax
    d70e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    d711:	e8 fc ff ff ff       	call   d712 <rlc_AM_segment+0x1b2>
    d716:	89 45 d0             	mov    %eax,-0x30(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d719:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d71c:	e8 fc ff ff ff       	call   d71d <rlc_AM_segment+0x1bd>
    d721:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		i = 0;
		u8 *des = skb->data;
    d724:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d727:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    d72d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d730:	8b 47 44             	mov    0x44(%edi),%eax
    d733:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
    d736:	8b 30                	mov    (%eax),%esi
    d738:	8d 58 f4             	lea    -0xc(%eax),%ebx
    d73b:	0f 84 cf 00 00 00    	je     d810 <rlc_AM_segment+0x2b0>
    d741:	83 ee 0c             	sub    $0xc,%esi
	else if(count > 1)
	{
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
    d744:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d74a:	eb 20                	jmp    d76c <rlc_AM_segment+0x20c>
    d74c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
			}
			else if(i==count-1)
    d750:	0f 84 fa 01 00 00    	je     d950 <rlc_AM_segment+0x3f0>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d756:	8b 46 0c             	mov    0xc(%esi),%eax
    d759:	8d 56 0c             	lea    0xc(%esi),%edx
    d75c:	83 e8 0c             	sub    $0xc,%eax
    d75f:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d762:	0f 84 a8 00 00 00    	je     d810 <rlc_AM_segment+0x2b0>
    d768:	89 f3                	mov    %esi,%ebx
    d76a:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    d76c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d770:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    d773:	7e db                	jle    d750 <rlc_AM_segment+0x1f0>
			{
				*(LI+i) = amBuffer->pkt->len;
    d775:	8b 13                	mov    (%ebx),%edx
    d777:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d77a:	8b 52 50             	mov    0x50(%edx),%edx
    d77d:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				*(headExt+i) = 0x8000|(*(LI+i));
    d781:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d784:	66 81 ca 00 80       	or     $0x8000,%dx
    d789:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				fsm_skb_put(skb,amBuffer->pkt->len);
    d78d:	8b 03                	mov    (%ebx),%eax
    d78f:	8b 50 50             	mov    0x50(%eax),%edx
    d792:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d795:	e8 fc ff ff ff       	call   d796 <rlc_AM_segment+0x236>
				fsm_mem_cpy(des,amBuffer->pkt->data,amBuffer->pkt->len);
    d79a:	8b 03                	mov    (%ebx),%eax
    d79c:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d7a2:	8b 48 50             	mov    0x50(%eax),%ecx
    d7a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d7a8:	e8 fc ff ff ff       	call   d7a9 <rlc_AM_segment+0x249>
				des = des + amBuffer->pkt->len ;
    d7ad:	8b 03                	mov    (%ebx),%eax
    d7af:	8b 50 50             	mov    0x50(%eax),%edx
    d7b2:	01 55 dc             	add    %edx,-0x24(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    d7b5:	8b 43 10             	mov    0x10(%ebx),%eax
    d7b8:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    d7bb:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    d7be:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    d7c0:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    d7c7:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				list_del(&amBuffer->list);
				amIns->amSduBufferNum--;
    d7ce:	83 6f 50 01          	subl   $0x1,0x50(%edi)
				amIns->amSduBufferSize -= amBuffer->pkt->len;
    d7d2:	8b 03                	mov    (%ebx),%eax
    d7d4:	8b 40 50             	mov    0x50(%eax),%eax
    d7d7:	29 47 4c             	sub    %eax,0x4c(%edi)

				if(amBuffer->pkt != NULL)
    d7da:	8b 03                	mov    (%ebx),%eax
    d7dc:	85 c0                	test   %eax,%eax
    d7de:	74 0b                	je     d7eb <rlc_AM_segment+0x28b>
				{
					fsm_pkt_destroy(amBuffer->pkt);
    d7e0:	e8 fc ff ff ff       	call   d7e1 <rlc_AM_segment+0x281>
					amBuffer->pkt = NULL;
    d7e5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				}
				if(amBuffer != NULL)
    d7eb:	85 db                	test   %ebx,%ebx
    d7ed:	74 07                	je     d7f6 <rlc_AM_segment+0x296>
				{
					fsm_mem_free(amBuffer);
    d7ef:	89 d8                	mov    %ebx,%eax
    d7f1:	e8 fc ff ff ff       	call   d7f2 <rlc_AM_segment+0x292>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d7f6:	8b 46 0c             	mov    0xc(%esi),%eax
    d7f9:	8d 56 0c             	lea    0xc(%esi),%edx
				if(amBuffer != NULL)
				{
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
    d7fc:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d801:	83 e8 0c             	sub    $0xc,%eax
    d804:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d807:	0f 85 5b ff ff ff    	jne    d768 <rlc_AM_segment+0x208>
    d80d:	8d 76 00             	lea    0x0(%esi),%esi
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d810:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    d814:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d817:	8b 55 cc             	mov    -0x34(%ebp),%edx
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d81a:	66 81 64 41 fc ff 7f 	andw   $0x7fff,-0x4(%ecx,%eax,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d821:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d824:	e8 fc ff ff ff       	call   d825 <rlc_AM_segment+0x2c5>
    d829:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    d82c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d82f:	e8 fc ff ff ff       	call   d830 <rlc_AM_segment+0x2d0>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    d834:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d837:	ba 02 00 00 00       	mov    $0x2,%edx
    d83c:	e8 fc ff ff ff       	call   d83d <rlc_AM_segment+0x2dd>
    d841:	8d 55 f2             	lea    -0xe(%ebp),%edx
    d844:	b9 02 00 00 00       	mov    $0x2,%ecx
    d849:	e8 fc ff ff ff       	call   d84a <rlc_AM_segment+0x2ea>
		if(LI != NULL)
    d84e:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d851:	85 d2                	test   %edx,%edx
    d853:	74 08                	je     d85d <rlc_AM_segment+0x2fd>
		{
			fsm_mem_free(LI);
    d855:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d858:	e8 fc ff ff ff       	call   d859 <rlc_AM_segment+0x2f9>
			LI = NULL;
		}
		if(headExt != NULL)
    d85d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d860:	85 c0                	test   %eax,%eax
    d862:	74 08                	je     d86c <rlc_AM_segment+0x30c>
		{
			fsm_mem_free(headExt);
    d864:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d867:	e8 fc ff ff ff       	call   d868 <rlc_AM_segment+0x308>
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d86c:	b8 a4 00 00 00       	mov    $0xa4,%eax
    d871:	e8 fc ff ff ff       	call   d872 <rlc_AM_segment+0x312>
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d876:	8b 55 e8             	mov    -0x18(%ebp),%edx
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d879:	89 c3                	mov    %eax,%ebx
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d87b:	8b 82 b0 00 00 00    	mov    0xb0(%edx),%eax
    d881:	e8 fc ff ff ff       	call   d882 <rlc_AM_segment+0x322>
    d886:	89 03                	mov    %eax,(%ebx)
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d888:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d88b:	e8 fc ff ff ff       	call   d88c <rlc_AM_segment+0x32c>
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
    d890:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d893:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d896:	89 03                	mov    %eax,(%ebx)
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    d898:	8b 40 50             	mov    0x50(%eax),%eax
	amBuf->segnum = 0;
    d89b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
    d8a2:	00 00 00 
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    d8a5:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    d8ab:	31 c0                	xor    %eax,%eax
    d8ad:	8d 76 00             	lea    0x0(%esi),%esi
	{
		amBuf->segStart[j] = -1;
    d8b0:	c7 44 83 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%eax,4)
    d8b7:	ff 
		amBuf->segEnd[j] = -1;
    d8b8:	c7 44 83 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%eax,4)
    d8bf:	ff 
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    d8c0:	83 c0 01             	add    $0x1,%eax
    d8c3:	83 f8 10             	cmp    $0x10,%eax
    d8c6:	75 e8                	jne    d8b0 <rlc_AM_segment+0x350>
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    d8c8:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d8cc:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
    d8d2:	66 c7 83 96 00 00 00 	movw   $0xffff,0x96(%ebx)
    d8d9:	ff ff 
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d8db:	8d 8f f0 00 00 00    	lea    0xf0(%edi),%ecx
	for( j = 0; j < segNumMax; j++ )
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    d8e1:	66 89 83 94 00 00 00 	mov    %ax,0x94(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    d8e8:	8b 87 f4 00 00 00    	mov    0xf4(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    d8ee:	89 97 f4 00 00 00    	mov    %edx,0xf4(%edi)
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    d8f4:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    d8fa:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    d900:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
    d902:	8b 03                	mov    (%ebx),%eax
    d904:	8b 40 50             	mov    0x50(%eax),%eax
    d907:	01 87 f8 00 00 00    	add    %eax,0xf8(%edi)
	amIns->amTransmittedBufferNum++;
	amIns->SN++;
    d90d:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
	amIns->amTransmittedBufferNum++;
    d911:	83 87 fc 00 00 00 01 	addl   $0x1,0xfc(%edi)
	amIns->SN++;
    d918:	83 c0 01             	add    $0x1,%eax
	amIns->SN %= 1024;
    d91b:	89 c2                	mov    %eax,%edx
    d91d:	66 c1 fa 0f          	sar    $0xf,%dx
    d921:	66 c1 ea 06          	shr    $0x6,%dx
    d925:	01 d0                	add    %edx,%eax
    d927:	66 25 ff 03          	and    $0x3ff,%ax
    d92b:	66 29 d0             	sub    %dx,%ax
    d92e:	66 89 47 2e          	mov    %ax,0x2e(%edi)
	fsm_printf("[RLC][rlc_AM_segment] SN = %d\n",amIns->SN);
    d932:	98                   	cwtl   
    d933:	89 44 24 04          	mov    %eax,0x4(%esp)
    d937:	c7 04 24 8c 37 00 00 	movl   $0x378c,(%esp)
    d93e:	e8 fc ff ff ff       	call   d93f <rlc_AM_segment+0x3df>
	return skb;
}
    d943:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d946:	83 c4 38             	add    $0x38,%esp
    d949:	5b                   	pop    %ebx
    d94a:	5e                   	pop    %esi
    d94b:	5f                   	pop    %edi
    d94c:	5d                   	pop    %ebp
    d94d:	c3                   	ret    
    d94e:	66 90                	xchg   %ax,%ax
				}				
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    d950:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    d954:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d957:	89 f2                	mov    %esi,%edx
    d959:	e8 fc ff ff ff       	call   d95a <rlc_AM_segment+0x3fa>
				fsm_mem_cpy(des,amBuffer->pkt->data,lastCopyLen);
    d95e:	8b 03                	mov    (%ebx),%eax
    d960:	89 f1                	mov    %esi,%ecx
    d962:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d968:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d96b:	e8 fc ff ff ff       	call   d96c <rlc_AM_segment+0x40c>
				
				if(amBuffer->pkt->len == lastCopyLen)
    d970:	8b 03                	mov    (%ebx),%eax
    d972:	3b 70 50             	cmp    0x50(%eax),%esi
    d975:	0f 85 fc 01 00 00    	jne    db77 <rlc_AM_segment+0x617>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    d97b:	8b 43 10             	mov    0x10(%ebx),%eax
    d97e:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    d981:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    d984:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    d986:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    d98d:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				{
					list_del(&amBuffer->list);
					amIns->amSduBufferNum--;
    d994:	83 6f 50 01          	subl   $0x1,0x50(%edi)
					amIns->amSduBufferSize -= amBuffer->pkt->len;
    d998:	8b 03                	mov    (%ebx),%eax
    d99a:	8b 40 50             	mov    0x50(%eax),%eax
    d99d:	29 47 4c             	sub    %eax,0x4c(%edi)
					if(amBuffer->pkt != NULL)
    d9a0:	8b 03                	mov    (%ebx),%eax
    d9a2:	85 c0                	test   %eax,%eax
    d9a4:	74 0b                	je     d9b1 <rlc_AM_segment+0x451>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    d9a6:	e8 fc ff ff ff       	call   d9a7 <rlc_AM_segment+0x447>
						amBuffer->pkt = NULL;
    d9ab:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    d9b1:	85 db                	test   %ebx,%ebx
    d9b3:	0f 84 57 fe ff ff    	je     d810 <rlc_AM_segment+0x2b0>
					{
						fsm_mem_free(amBuffer);
    d9b9:	89 d8                	mov    %ebx,%eax
    d9bb:	e8 fc ff ff ff       	call   d9bc <rlc_AM_segment+0x45c>
    d9c0:	e9 4b fe ff ff       	jmp    d810 <rlc_AM_segment+0x2b0>
    d9c5:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d9c9:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d9cc:	e9 c2 fc ff ff       	jmp    d693 <rlc_AM_segment+0x133>
    d9d1:	66 89 7d da          	mov    %di,-0x26(%ebp)
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d9d5:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    d9d9:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d9dd:	8b 7d e0             	mov    -0x20(%ebp),%edi
    d9e0:	01 c0                	add    %eax,%eax
    d9e2:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    d9e6:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    d9e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    d9ec:	89 45 c8             	mov    %eax,-0x38(%ebp)
    d9ef:	31 c0                	xor    %eax,%eax
			{
				if(amBuffer->pktstatus ==FULL_SDU)
    d9f1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d9f5:	0f 84 92 01 00 00    	je     db8d <rlc_AM_segment+0x62d>
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    d9fb:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    d9fd:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    d9ff:	0f 84 8e 01 00 00    	je     db93 <rlc_AM_segment+0x633>
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    da05:	83 e0 e3             	and    $0xffffffe3,%eax
						fixhead->FIsecond=1;
    da08:	83 c8 18             	or     $0x18,%eax
    da0b:	88 45 f3             	mov    %al,-0xd(%ebp)
    da0e:	66 90                	xchg   %ax,%ax
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
				length = length + size;
    da10:	0f b7 75 e8          	movzwl -0x18(%ebp),%esi
    da14:	66 03 75 ec          	add    -0x14(%ebp),%si
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
    da18:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    da1c:	01 d6                	add    %edx,%esi
    da1e:	0f b7 de             	movzwl %si,%ebx
				length = length + size;
				break;
    da21:	e9 88 fc ff ff       	jmp    d6ae <rlc_AM_segment+0x14e>
    da26:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    da2a:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    da2e:	8b 7d e0             	mov    -0x20(%ebp),%edi
    da31:	01 c9                	add    %ecx,%ecx
    da33:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
    da37:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    da3b:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    da3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    da41:	89 45 c8             	mov    %eax,-0x38(%ebp)
    da44:	31 c0                	xor    %eax,%eax
			{

				if(amBuffer->pktstatus == FULL_SDU)
    da46:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    da4a:	0f 84 88 01 00 00    	je     dbd8 <rlc_AM_segment+0x678>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da50:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    da52:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da54:	0f 84 44 01 00 00    	je     db9e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=1;
    da5a:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    da5d:	83 e0 f3             	and    $0xfffffff3,%eax
    da60:	88 45 f3             	mov    %al,-0xd(%ebp)
    da63:	eb ab                	jmp    da10 <rlc_AM_segment+0x4b0>
    da65:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    da69:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    da6d:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
    da71:	8b 7d e0             	mov    -0x20(%ebp),%edi
    da74:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    da77:	89 45 e0             	mov    %eax,-0x20(%ebp)
    da7a:	01 d2                	add    %edx,%edx
    da7c:	89 45 c8             	mov    %eax,-0x38(%ebp)
    da7f:	31 c0                	xor    %eax,%eax
					break;
				}				
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
    da81:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    da85:	0f 84 5e 01 00 00    	je     dbe9 <rlc_AM_segment+0x689>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da8b:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    da8d:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    da8f:	0f 84 14 01 00 00    	je     dba9 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=1;
    da95:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    da98:	83 e0 f3             	and    $0xfffffff3,%eax
    da9b:	88 45 f3             	mov    %al,-0xd(%ebp)
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    da9e:	8b 03                	mov    (%ebx),%eax
				length = length + amBuffer->pkt->len;
    daa0:	0f b7 75 ec          	movzwl -0x14(%ebp),%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    daa4:	0f b7 40 50          	movzwl 0x50(%eax),%eax
				length = length + amBuffer->pkt->len;
    daa8:	01 d6                	add    %edx,%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    daaa:	01 c6                	add    %eax,%esi
    daac:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    dab0:	0f b7 de             	movzwl %si,%ebx
				length = length + amBuffer->pkt->len;
				break;
    dab3:	e9 f6 fb ff ff       	jmp    d6ae <rlc_AM_segment+0x14e>
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dab8:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    dabc:	31 c9                	xor    %ecx,%ecx
    dabe:	31 db                	xor    %ebx,%ebx
    dac0:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    dac7:	31 f6                	xor    %esi,%esi
    dac9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dad0:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dad6:	0f b7 d0             	movzwl %ax,%edx
    dad9:	e9 d7 fb ff ff       	jmp    d6b5 <rlc_AM_segment+0x155>
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    dade:	0f b7 d6             	movzwl %si,%edx
    dae1:	e8 fc ff ff ff       	call   dae2 <rlc_AM_segment+0x582>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    dae6:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dae9:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    daed:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    daf3:	89 f2                	mov    %esi,%edx
    daf5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    daf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dafb:	e8 fc ff ff ff       	call   dafc <rlc_AM_segment+0x59c>
    db00:	8b 55 ec             	mov    -0x14(%ebp),%edx
    db03:	89 f1                	mov    %esi,%ecx
    db05:	e8 fc ff ff ff       	call   db06 <rlc_AM_segment+0x5a6>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    db0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    db0d:	ba 02 00 00 00       	mov    $0x2,%edx
    db12:	e8 fc ff ff ff       	call   db13 <rlc_AM_segment+0x5b3>
    db17:	b9 02 00 00 00       	mov    $0x2,%ecx
    db1c:	8d 55 f2             	lea    -0xe(%ebp),%edx
    db1f:	e8 fc ff ff ff       	call   db20 <rlc_AM_segment+0x5c0>
		
		if(lastCopyLen == tbuff->pkt->len)
    db24:	8b 43 f4             	mov    -0xc(%ebx),%eax
    db27:	3b 70 50             	cmp    0x50(%eax),%esi
    db2a:	0f 85 84 00 00 00    	jne    dbb4 <rlc_AM_segment+0x654>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    db30:	8b 43 04             	mov    0x4(%ebx),%eax
    db33:	8b 13                	mov    (%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    db35:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    db38:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    db3a:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
	entry->prev = LIST_POISON2;
    db40:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
		{
			list_del(&tbuff->list);
			amIns->amSduBufferNum--;
    db47:	83 6f 50 01          	subl   $0x1,0x50(%edi)
			amIns->amSduBufferSize -= tbuff->pkt->len;
    db4b:	8b 43 f4             	mov    -0xc(%ebx),%eax
    db4e:	8b 40 50             	mov    0x50(%eax),%eax
    db51:	29 47 4c             	sub    %eax,0x4c(%edi)
			if(tbuff->pkt != NULL)
    db54:	8b 43 f4             	mov    -0xc(%ebx),%eax
    db57:	85 c0                	test   %eax,%eax
    db59:	74 0c                	je     db67 <rlc_AM_segment+0x607>
			{
				fsm_pkt_destroy(tbuff->pkt);
    db5b:	e8 fc ff ff ff       	call   db5c <rlc_AM_segment+0x5fc>
				tbuff->pkt = NULL;
    db60:	c7 43 f4 00 00 00 00 	movl   $0x0,-0xc(%ebx)
			}
			if(tbuff != NULL)
    db67:	89 d8                	mov    %ebx,%eax
    db69:	83 e8 0c             	sub    $0xc,%eax
    db6c:	0f 85 f5 fc ff ff    	jne    d867 <rlc_AM_segment+0x307>
    db72:	e9 f5 fc ff ff       	jmp    d86c <rlc_AM_segment+0x30c>
						amBuffer = NULL;
					}				
				}
				else
				{
					fsm_skb_pull(amBuffer->pkt,lastCopyLen);
    db77:	89 f2                	mov    %esi,%edx
    db79:	e8 fc ff ff ff       	call   db7a <rlc_AM_segment+0x61a>
					amIns->amSduBufferSize -= lastCopyLen;
    db7e:	29 77 4c             	sub    %esi,0x4c(%edi)
					amBuffer->pktstatus = LAST_SEGMENT;
    db81:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    db88:	e9 83 fc ff ff       	jmp    d810 <rlc_AM_segment+0x2b0>
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    db8d:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    db8f:	89 f0                	mov    %esi,%eax
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    db91:	75 37                	jne    dbca <rlc_AM_segment+0x66a>
						fixhead->FIsecond=1;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=1;
    db93:	83 c8 08             	or     $0x8,%eax
    db96:	88 45 f3             	mov    %al,-0xd(%ebp)
    db99:	e9 72 fe ff ff       	jmp    da10 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    db9e:	83 e0 f7             	and    $0xfffffff7,%eax
    dba1:	88 45 f3             	mov    %al,-0xd(%ebp)
    dba4:	e9 67 fe ff ff       	jmp    da10 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    dba9:	83 e0 f7             	and    $0xfffffff7,%eax
    dbac:	88 45 f3             	mov    %al,-0xd(%ebp)
    dbaf:	e9 ea fe ff ff       	jmp    da9e <rlc_AM_segment+0x53e>
				tbuff = NULL;
			}		
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    dbb4:	89 f2                	mov    %esi,%edx
    dbb6:	e8 fc ff ff ff       	call   dbb7 <rlc_AM_segment+0x657>
			amIns->amSduBufferSize -= lastCopyLen;
    dbbb:	29 77 4c             	sub    %esi,0x4c(%edi)
			tbuff->pktstatus = LAST_SEGMENT;
    dbbe:	c7 43 f8 02 00 00 00 	movl   $0x2,-0x8(%ebx)
    dbc5:	e9 a2 fc ff ff       	jmp    d86c <rlc_AM_segment+0x30c>
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    dbca:	83 e0 eb             	and    $0xffffffeb,%eax
						fixhead->FIsecond=1;
    dbcd:	83 c8 08             	or     $0x8,%eax
    dbd0:	88 45 f3             	mov    %al,-0xd(%ebp)
    dbd3:	e9 38 fe ff ff       	jmp    da10 <rlc_AM_segment+0x4b0>
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dbd8:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbda:	89 f0                	mov    %esi,%eax
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dbdc:	74 c0                	je     db9e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbde:	83 e0 e3             	and    $0xffffffe3,%eax
    dbe1:	88 45 f3             	mov    %al,-0xd(%ebp)
    dbe4:	e9 27 fe ff ff       	jmp    da10 <rlc_AM_segment+0x4b0>
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dbe9:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbeb:	89 f0                	mov    %esi,%eax
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dbed:	74 ba                	je     dba9 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbef:	83 e0 e3             	and    $0xffffffe3,%eax
    dbf2:	88 45 f3             	mov    %al,-0xd(%ebp)
    dbf5:	e9 a4 fe ff ff       	jmp    da9e <rlc_AM_segment+0x53e>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    dbfa:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dc01:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dc06:	b8 01 00 00 00       	mov    $0x1,%eax
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    dc0b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    dc12:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dc18:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dc1e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dc24:	e9 1d fe ff ff       	jmp    da46 <rlc_AM_segment+0x4e6>
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dc29:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dc30:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dc35:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dc3a:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    dc41:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dc47:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dc4d:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dc53:	e9 99 fd ff ff       	jmp    d9f1 <rlc_AM_segment+0x491>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    dc58:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dc5f:	b9 01 00 00 00       	mov    $0x1,%ecx
    dc64:	ba 02 00 00 00       	mov    $0x2,%edx
    dc69:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dc70:	b8 01 00 00 00       	mov    $0x1,%eax
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dc75:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dc7b:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dc81:	e9 fb fd ff ff       	jmp    da81 <rlc_AM_segment+0x521>
	fixhead->P=1;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
    dc86:	c7 04 24 68 37 00 00 	movl   $0x3768,(%esp)
    dc8d:	e8 fc ff ff ff       	call   dc8e <rlc_AM_segment+0x72e>
		return NULL;
    dc92:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dc99:	e9 a5 fc ff ff       	jmp    d943 <rlc_AM_segment+0x3e3>
    dc9e:	66 90                	xchg   %ax,%ax

0000dca0 <rlc_UM_segment>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    dca0:	55                   	push   %ebp
    dca1:	89 e5                	mov    %esp,%ebp
    dca3:	57                   	push   %edi
    dca4:	56                   	push   %esi
    dca5:	53                   	push   %ebx
    dca6:	83 ec 34             	sub    $0x34,%esp
    dca9:	e8 fc ff ff ff       	call   dcaa <rlc_UM_segment+0xa>
    dcae:	89 d3                	mov    %edx,%ebx
		u32 size;
		int num = umIns->umSduBufferNum;
    dcb0:	8b 50 24             	mov    0x24(%eax),%edx
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    dcb3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		u32 size;
		int num = umIns->umSduBufferNum;
    dcb6:	89 55 e8             	mov    %edx,-0x18(%ebp)
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    dcb9:	0f b7 50 28          	movzwl 0x28(%eax),%edx
    dcbd:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    dcc1:	c7 04 24 9c 07 00 00 	movl   $0x79c,(%esp)
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    dcc8:	66 81 e2 ff 03       	and    $0x3ff,%dx
    dccd:	66 25 00 fc          	and    $0xfc00,%ax
    dcd1:	09 d0                	or     %edx,%eax
    dcd3:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		fixhead->R11=0;
    dcd7:	66 c1 e8 08          	shr    $0x8,%ax
		fixhead->R12=0;
		fixhead->R13=0;
    dcdb:	83 e0 1f             	and    $0x1f,%eax
    dcde:	88 45 f3             	mov    %al,-0xd(%ebp)
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    dce1:	e8 fc ff ff ff       	call   dce2 <rlc_UM_segment+0x42>
		if(sizeFromMac <= 2)
    dce6:	83 fb 02             	cmp    $0x2,%ebx
    dce9:	0f 86 7e 05 00 00    	jbe    e26d <rlc_UM_segment+0x5cd>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    dcef:	8b 75 e4             	mov    -0x1c(%ebp),%esi

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
		u32 size;
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
    dcf2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    dcf5:	8b 46 18             	mov    0x18(%esi),%eax
    dcf8:	83 c1 18             	add    $0x18,%ecx
    dcfb:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
    dcfe:	39 c1                	cmp    %eax,%ecx
    dd00:	0f 84 82 03 00 00    	je     e088 <rlc_UM_segment+0x3e8>
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
    dd06:	8d 53 fe             	lea    -0x2(%ebx),%edx
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dd09:	8d 58 f0             	lea    -0x10(%eax),%ebx
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dd0c:	8b 40 f0             	mov    -0x10(%eax),%eax
    dd0f:	8b 40 50             	mov    0x50(%eax),%eax
    dd12:	39 c2                	cmp    %eax,%edx
    dd14:	0f 82 11 05 00 00    	jb     e22b <rlc_UM_segment+0x58b>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dd1a:	0f 84 21 05 00 00    	je     e241 <rlc_UM_segment+0x5a1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dd20:	8d 48 02             	lea    0x2(%eax),%ecx
    dd23:	39 ca                	cmp    %ecx,%edx
    dd25:	0f 86 2c 05 00 00    	jbe    e257 <rlc_UM_segment+0x5b7>
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    dd2b:	31 f6                	xor    %esi,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dd2d:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    dd32:	b9 01 00 00 00       	mov    $0x1,%ecx
    dd37:	66 89 75 e0          	mov    %si,-0x20(%ebp)
    dd3b:	eb 4c                	jmp    dd89 <rlc_UM_segment+0xe9>
    dd3d:	8d 76 00             	lea    0x0(%esi),%esi
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
						flag=false;
					}
					else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    dd40:	84 c9                	test   %cl,%cl
    dd42:	74 04                	je     dd48 <rlc_UM_segment+0xa8>
					{
	
						fixhead->FIfirst=1;
						fixhead->E=1;
    dd44:	80 4d f3 14          	orb    $0x14,-0xd(%ebp)
						flag=false;
					}
					if(num == 0)
    dd48:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    dd4b:	74 63                	je     ddb0 <rlc_UM_segment+0x110>
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dd4d:	8b 4b 10             	mov    0x10(%ebx),%ecx
    dd50:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
    dd53:	8d 59 f0             	lea    -0x10(%ecx),%ebx
    dd56:	0f 84 b4 02 00 00    	je     e010 <rlc_UM_segment+0x370>
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dd5c:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dd61:	83 c7 01             	add    $0x1,%edi
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dd64:	29 c6                	sub    %eax,%esi
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dd66:	8b 41 f0             	mov    -0x10(%ecx),%eax
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dd69:	01 f2                	add    %esi,%edx
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dd6b:	8b 40 50             	mov    0x50(%eax),%eax
    dd6e:	39 d0                	cmp    %edx,%eax
    dd70:	0f 87 aa 02 00 00    	ja     e020 <rlc_UM_segment+0x380>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dd76:	0f 84 dc 02 00 00    	je     e058 <rlc_UM_segment+0x3b8>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dd7c:	8d 48 02             	lea    0x2(%eax),%ecx
    dd7f:	39 d1                	cmp    %edx,%ecx
    dd81:	0f 83 19 03 00 00    	jae    e0a0 <rlc_UM_segment+0x400>
    dd87:	31 c9                	xor    %ecx,%ecx
				{
	
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
    dd89:	66 01 45 e0          	add    %ax,-0x20(%ebp)
					if(umBuffer->pktstatus==FULL_SDU &&flag)
    dd8d:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dd91:	75 ad                	jne    dd40 <rlc_UM_segment+0xa0>
    dd93:	84 c9                	test   %cl,%cl
    dd95:	74 b1                	je     dd48 <rlc_UM_segment+0xa8>
					{	
						fixhead->FIfirst=0;
    dd97:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    dd9b:	83 e1 ef             	and    $0xffffffef,%ecx
						fixhead->E=1;
    dd9e:	83 c9 04             	or     $0x4,%ecx
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    dda1:	39 7d e8             	cmp    %edi,-0x18(%ebp)
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
					if(umBuffer->pktstatus==FULL_SDU &&flag)
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
    dda4:	88 4d f3             	mov    %cl,-0xd(%ebp)
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    dda7:	75 a4                	jne    dd4d <rlc_UM_segment+0xad>
    dda9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    ddb0:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    ddb4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    ddb7:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    ddbb:	89 d0                	mov    %edx,%eax
    ddbd:	83 e0 fb             	and    $0xfffffffb,%eax
    ddc0:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
						fixhead->FIsecond=0;
						lastCopyLen = umBuffer->pkt->len;
    ddc4:	8d 34 7e             	lea    (%esi,%edi,2),%esi
						flag=false;
					}
					if(num == 0)
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    ddc7:	0f 45 c2             	cmovne %edx,%eax
						fixhead->FIsecond=0;
    ddca:	83 e0 f7             	and    $0xfffffff7,%eax
    ddcd:	88 45 f3             	mov    %al,-0xd(%ebp)
						lastCopyLen = umBuffer->pkt->len;
    ddd0:	8b 03                	mov    (%ebx),%eax
    ddd2:	0f b7 de             	movzwl %si,%ebx
    ddd5:	8b 40 50             	mov    0x50(%eax),%eax
    ddd8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    dddb:	90                   	nop
    dddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    dde0:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    dde4:	0f b7 d0             	movzwl %ax,%edx
    dde7:	c1 e2 08             	shl    $0x8,%edx
    ddea:	66 c1 e8 08          	shr    $0x8,%ax
    ddee:	09 d0                	or     %edx,%eax
		fsm_octets_print(fixhead,2);
    ddf0:	ba 02 00 00 00       	mov    $0x2,%edx
    ddf5:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    ddf9:	8d 45 f2             	lea    -0xe(%ebp),%eax
    ddfc:	e8 fc ff ff ff       	call   ddfd <rlc_UM_segment+0x15d>
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    de01:	89 d8                	mov    %ebx,%eax
    de03:	e8 fc ff ff ff       	call   de04 <rlc_UM_segment+0x164>
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    de08:	83 ff 01             	cmp    $0x1,%edi
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    de0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		pos = head->next;
    de0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    de11:	8b 58 18             	mov    0x18(%eax),%ebx
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    de14:	0f 84 c2 02 00 00    	je     e0dc <rlc_UM_segment+0x43c>
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
				umIns->umSduBufferSize -= lastCopyLen;
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
    de1a:	0f 8e 59 01 00 00    	jle    df79 <rlc_UM_segment+0x2d9>
		{
			fsm_skb_reserve(skb,2*count);
    de20:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de23:	8d 14 3f             	lea    (%edi,%edi,1),%edx
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    de26:	8d 77 ff             	lea    -0x1(%edi),%esi
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
    de29:	e8 fc ff ff ff       	call   de2a <rlc_UM_segment+0x18a>
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    de2e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    de31:	01 f6                	add    %esi,%esi
    de33:	89 f0                	mov    %esi,%eax
    de35:	89 75 cc             	mov    %esi,-0x34(%ebp)
    de38:	e8 fc ff ff ff       	call   de39 <rlc_UM_segment+0x199>
    de3d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    de40:	89 f0                	mov    %esi,%eax
    de42:	e8 fc ff ff ff       	call   de43 <rlc_UM_segment+0x1a3>
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    de47:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    de4a:	89 45 d8             	mov    %eax,-0x28(%ebp)
			int i = 0;
			unsigned char *des = skb->data;
    de4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de50:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    de56:	89 45 e0             	mov    %eax,-0x20(%ebp)
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    de59:	8b 42 18             	mov    0x18(%edx),%eax
    de5c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    de5f:	8b 30                	mov    (%eax),%esi
    de61:	8d 58 f0             	lea    -0x10(%eax),%ebx
    de64:	0f 84 c5 00 00 00    	je     df2f <rlc_UM_segment+0x28f>
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
    de6a:	31 c0                	xor    %eax,%eax
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    de6c:	83 ee 10             	sub    $0x10,%esi
    de6f:	89 7d c8             	mov    %edi,-0x38(%ebp)
    de72:	89 c7                	mov    %eax,%edi
    de74:	eb 1e                	jmp    de94 <rlc_UM_segment+0x1f4>
    de76:	66 90                	xchg   %ax,%ax
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
    de78:	0f 84 42 01 00 00    	je     dfc0 <rlc_UM_segment+0x320>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    de7e:	8b 46 10             	mov    0x10(%esi),%eax
    de81:	8d 56 10             	lea    0x10(%esi),%edx
    de84:	83 e8 10             	sub    $0x10,%eax
    de87:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    de8a:	0f 84 9c 00 00 00    	je     df2c <rlc_UM_segment+0x28c>
    de90:	89 f3                	mov    %esi,%ebx
    de92:	89 c6                	mov    %eax,%esi
			{
				if(i<count-1)
    de94:	3b 7d e8             	cmp    -0x18(%ebp),%edi
    de97:	7d df                	jge    de78 <rlc_UM_segment+0x1d8>
				{
					*(LI+i) = umBuffer->pkt->len;
    de99:	8b 03                	mov    (%ebx),%eax
    de9b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
					*(headExt+i) = 0x8000|(*(LI+i));
    de9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
    dea1:	8b 40 50             	mov    0x50(%eax),%eax
    dea4:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
					*(headExt+i) = 0x8000|(*(LI+i));
    dea8:	66 0d 00 80          	or     $0x8000,%ax
    deac:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
					fsm_skb_put(skb,umBuffer->pkt->len);
    deb0:	8b 03                	mov    (%ebx),%eax
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
    deb2:	83 c7 01             	add    $0x1,%edi
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
    deb5:	8b 50 50             	mov    0x50(%eax),%edx
    deb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    debb:	e8 fc ff ff ff       	call   debc <rlc_UM_segment+0x21c>
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    dec0:	8b 03                	mov    (%ebx),%eax
    dec2:	8b 48 50             	mov    0x50(%eax),%ecx
    dec5:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    decb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dece:	e8 fc ff ff ff       	call   decf <rlc_UM_segment+0x22f>
					des = des + umBuffer->pkt->len ;
    ded3:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ded5:	8b 53 10             	mov    0x10(%ebx),%edx
    ded8:	8b 48 50             	mov    0x50(%eax),%ecx
    dedb:	8b 43 14             	mov    0x14(%ebx),%eax
    dede:	01 4d e0             	add    %ecx,-0x20(%ebp)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dee1:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dee4:	89 10                	mov    %edx,(%eax)
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    dee6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    dee9:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    def0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    def3:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    defa:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    defe:	8b 03                	mov    (%ebx),%eax
    df00:	8b 40 50             	mov    0x50(%eax),%eax
    df03:	29 42 20             	sub    %eax,0x20(%edx)
					fsm_pkt_destroy(umBuffer->pkt);
    df06:	8b 03                	mov    (%ebx),%eax
    df08:	e8 fc ff ff ff       	call   df09 <rlc_UM_segment+0x269>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    df0d:	89 d8                	mov    %ebx,%eax
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    df0f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer);
    df15:	e8 fc ff ff ff       	call   df16 <rlc_UM_segment+0x276>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    df1a:	8b 46 10             	mov    0x10(%esi),%eax
    df1d:	8d 56 10             	lea    0x10(%esi),%edx
    df20:	83 e8 10             	sub    $0x10,%eax
    df23:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    df26:	0f 85 64 ff ff ff    	jne    de90 <rlc_UM_segment+0x1f0>
    df2c:	8b 7d c8             	mov    -0x38(%ebp),%edi
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    df2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    df32:	8b 55 cc             	mov    -0x34(%ebp),%edx
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    df35:	66 81 64 78 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%edi,2)
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    df3c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df3f:	e8 fc ff ff ff       	call   df40 <rlc_UM_segment+0x2a0>
    df44:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    df47:	8b 55 d8             	mov    -0x28(%ebp),%edx
    df4a:	e8 fc ff ff ff       	call   df4b <rlc_UM_segment+0x2ab>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    df4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df52:	ba 02 00 00 00       	mov    $0x2,%edx
    df57:	e8 fc ff ff ff       	call   df58 <rlc_UM_segment+0x2b8>
    df5c:	b9 02 00 00 00       	mov    $0x2,%ecx
    df61:	8d 55 f2             	lea    -0xe(%ebp),%edx
    df64:	e8 fc ff ff ff       	call   df65 <rlc_UM_segment+0x2c5>
			fsm_mem_free(LI);
    df69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    df6c:	e8 fc ff ff ff       	call   df6d <rlc_UM_segment+0x2cd>
			fsm_mem_free(headExt);
    df71:	8b 45 d8             	mov    -0x28(%ebp),%eax
    df74:	e8 fc ff ff ff       	call   df75 <rlc_UM_segment+0x2d5>
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    df79:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		umIns->SN %= 1024;
    df7c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
			fsm_mem_free(headExt);
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    df7f:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    df83:	83 c0 01             	add    $0x1,%eax
		umIns->SN %= 1024;
    df86:	89 c2                	mov    %eax,%edx
    df88:	66 c1 fa 0f          	sar    $0xf,%dx
    df8c:	66 c1 ea 06          	shr    $0x6,%dx
    df90:	01 d0                	add    %edx,%eax
    df92:	66 25 ff 03          	and    $0x3ff,%ax
    df96:	66 29 d0             	sub    %dx,%ax
    df99:	66 89 41 28          	mov    %ax,0x28(%ecx)
		fsm_printf("[RLC][rlc_UM_segment] SN = %d\n",umIns->SN);
    df9d:	98                   	cwtl   
    df9e:	89 44 24 04          	mov    %eax,0x4(%esp)
    dfa2:	c7 04 24 d0 37 00 00 	movl   $0x37d0,(%esp)
    dfa9:	e8 fc ff ff ff       	call   dfaa <rlc_UM_segment+0x30a>
		return skb;

}
    dfae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dfb1:	83 c4 34             	add    $0x34,%esp
    dfb4:	5b                   	pop    %ebx
    dfb5:	5e                   	pop    %esi
    dfb6:	5f                   	pop    %edi
    dfb7:	5d                   	pop    %ebp
    dfb8:	c3                   	ret    
    dfb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
				{
					fsm_skb_put(skb,lastCopyLen);
    dfc0:	8b 55 d0             	mov    -0x30(%ebp),%edx
    dfc3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dfc6:	8b 7d c8             	mov    -0x38(%ebp),%edi
    dfc9:	e8 fc ff ff ff       	call   dfca <rlc_UM_segment+0x32a>
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    dfce:	8b 03                	mov    (%ebx),%eax
    dfd0:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    dfd3:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    dfd9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dfdc:	e8 fc ff ff ff       	call   dfdd <rlc_UM_segment+0x33d>
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    dfe1:	8b 55 d0             	mov    -0x30(%ebp),%edx
    dfe4:	8b 03                	mov    (%ebx),%eax
    dfe6:	e8 fc ff ff ff       	call   dfe7 <rlc_UM_segment+0x347>
					if(umBuffer->pkt->len == lastCopyLen)
    dfeb:	8b 03                	mov    (%ebx),%eax
    dfed:	8b 75 d0             	mov    -0x30(%ebp),%esi
    dff0:	39 70 50             	cmp    %esi,0x50(%eax)
    dff3:	0f 84 ee 01 00 00    	je     e1e7 <rlc_UM_segment+0x547>
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
						umIns->umSduBufferSize -= lastCopyLen;
    dff9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    dffc:	8b 75 d0             	mov    -0x30(%ebp),%esi
						fsm_mem_free(umBuffer);
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
    dfff:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
						umIns->umSduBufferSize -= lastCopyLen;
    e006:	29 70 20             	sub    %esi,0x20(%eax)
    e009:	e9 21 ff ff ff       	jmp    df2f <rlc_UM_segment+0x28f>
    e00e:	66 90                	xchg   %ax,%ax
    e010:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    e014:	8d 34 7e             	lea    (%esi,%edi,2),%esi
    e017:	0f b7 de             	movzwl %si,%ebx
    e01a:	e9 c1 fd ff ff       	jmp    dde0 <rlc_UM_segment+0x140>
    e01f:	90                   	nop
    e020:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e024:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e027:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e029:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e02d:	0f 84 3e 01 00 00    	je     e171 <rlc_UM_segment+0x4d1>
							fixhead->FIsecond=1;
						}
					}
					else
					{
						if(flag)
    e033:	84 c0                	test   %al,%al
    e035:	0f 84 0d 01 00 00    	je     e148 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=1;
    e03b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e03f:	83 e0 e3             	and    $0xffffffe3,%eax
							fixhead->FIsecond=1;
    e042:	83 c8 18             	or     $0x18,%eax
    e045:	88 45 f3             	mov    %al,-0xd(%ebp)
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = size;
					length += size;
    e048:	01 ce                	add    %ecx,%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e04a:	01 d6                	add    %edx,%esi
    e04c:	0f b7 de             	movzwl %si,%ebx
						}
					}
					lastCopyLen = size;
					length += size;
					break;
    e04f:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e052:	e9 89 fd ff ff       	jmp    dde0 <rlc_UM_segment+0x140>
    e057:	90                   	nop
    e058:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e05c:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e05f:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e061:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e065:	0f 84 1c 01 00 00    	je     e187 <rlc_UM_segment+0x4e7>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e06b:	84 c0                	test   %al,%al
    e06d:	0f 84 e5 00 00 00    	je     e158 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=1;
    e073:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e077:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e07a:	83 e0 f3             	and    $0xfffffff3,%eax
    e07d:	88 45 f3             	mov    %al,-0xd(%ebp)
    e080:	eb c6                	jmp    e048 <rlc_UM_segment+0x3a8>
    e082:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e088:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    e08c:	31 db                	xor    %ebx,%ebx
    e08e:	31 f6                	xor    %esi,%esi
		fixhead->SN=umIns->SN;
		fixhead->R11=0;
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
    e090:	31 ff                	xor    %edi,%edi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e092:	0f b7 d0             	movzwl %ax,%edx
    e095:	e9 4d fd ff ff       	jmp    dde7 <rlc_UM_segment+0x147>
    e09a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e0a0:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e0a4:	8d 14 3f             	lea    (%edi,%edi,1),%edx
    e0a7:	31 c0                	xor    %eax,%eax
						break;
					}
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e0a9:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e0ad:	0f 84 e1 00 00 00    	je     e194 <rlc_UM_segment+0x4f4>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e0b3:	84 c0                	test   %al,%al
    e0b5:	0f 84 ad 00 00 00    	je     e168 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=1;
    e0bb:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e0bf:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e0c2:	83 e0 f3             	and    $0xfffffff3,%eax
    e0c5:	88 45 f3             	mov    %al,-0xd(%ebp)
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e0c8:	8b 03                	mov    (%ebx),%eax
					length += umBuffer->pkt->len;
    e0ca:	01 d6                	add    %edx,%esi
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e0cc:	8b 40 50             	mov    0x50(%eax),%eax
    e0cf:	01 c6                	add    %eax,%esi
    e0d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e0d4:	0f b7 de             	movzwl %si,%ebx
					length += umBuffer->pkt->len;
					break;
    e0d7:	e9 04 fd ff ff       	jmp    dde0 <rlc_UM_segment+0x140>
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
		{
			fsm_skb_reserve(skb,length);
    e0dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e0df:	0f b7 d6             	movzwl %si,%edx
    e0e2:	e8 fc ff ff ff       	call   e0e3 <rlc_UM_segment+0x443>
			fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e0e7:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e0ea:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e0ed:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e0f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e0f6:	e8 fc ff ff ff       	call   e0f7 <rlc_UM_segment+0x457>
    e0fb:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e0fe:	89 f2                	mov    %esi,%edx
    e100:	e8 fc ff ff ff       	call   e101 <rlc_UM_segment+0x461>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e105:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e108:	ba 02 00 00 00       	mov    $0x2,%edx
    e10d:	e8 fc ff ff ff       	call   e10e <rlc_UM_segment+0x46e>
    e112:	b9 02 00 00 00       	mov    $0x2,%ecx
    e117:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e11a:	e8 fc ff ff ff       	call   e11b <rlc_UM_segment+0x47b>
			
			if(lastCopyLen == tbuff->pkt->len)
    e11f:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e122:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e125:	39 70 50             	cmp    %esi,0x50(%eax)
    e128:	74 77                	je     e1a1 <rlc_UM_segment+0x501>
				fsm_mem_free(tbuff);
				tbuff = NULL;
			}
			else
			{
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e12a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e12d:	e8 fc ff ff ff       	call   e12e <rlc_UM_segment+0x48e>
				umIns->umSduBufferSize -= lastCopyLen;
    e132:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e135:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e138:	29 70 20             	sub    %esi,0x20(%eax)
				tbuff->pktstatus = LAST_SEGMENT;
    e13b:	c7 43 f4 02 00 00 00 	movl   $0x2,-0xc(%ebx)
    e142:	e9 32 fe ff ff       	jmp    df79 <rlc_UM_segment+0x2d9>
    e147:	90                   	nop
							fixhead->FIsecond=1;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=1;
    e148:	80 4d f3 08          	orb    $0x8,-0xd(%ebp)
    e14c:	e9 f7 fe ff ff       	jmp    e048 <rlc_UM_segment+0x3a8>
    e151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e158:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e15c:	e9 e7 fe ff ff       	jmp    e048 <rlc_UM_segment+0x3a8>
    e161:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e168:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e16c:	e9 57 ff ff ff       	jmp    e0c8 <rlc_UM_segment+0x428>
				num--;
				if(size < umBuffer->pkt->len)
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e171:	84 c0                	test   %al,%al
    e173:	74 d3                	je     e148 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=0;
    e175:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e179:	83 e0 eb             	and    $0xffffffeb,%eax
							fixhead->FIsecond=1;
    e17c:	83 c8 08             	or     $0x8,%eax
    e17f:	88 45 f3             	mov    %al,-0xd(%ebp)
    e182:	e9 c1 fe ff ff       	jmp    e048 <rlc_UM_segment+0x3a8>
				}
				else if(size == umBuffer->pkt->len) 
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e187:	84 c0                	test   %al,%al
    e189:	74 cd                	je     e158 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e18b:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e18f:	e9 b4 fe ff ff       	jmp    e048 <rlc_UM_segment+0x3a8>
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e194:	84 c0                	test   %al,%al
    e196:	74 d0                	je     e168 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e198:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e19c:	e9 27 ff ff ff       	jmp    e0c8 <rlc_UM_segment+0x428>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e1a1:	8b 13                	mov    (%ebx),%edx
    e1a3:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e1a6:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e1a9:	89 10                	mov    %edx,(%eax)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e1ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e1ae:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e1b4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e1b7:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e1be:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e1c2:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e1c5:	8b 40 50             	mov    0x50(%eax),%eax
    e1c8:	29 42 20             	sub    %eax,0x20(%edx)
				fsm_pkt_destroy(tbuff->pkt);
    e1cb:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e1ce:	e8 fc ff ff ff       	call   e1cf <rlc_UM_segment+0x52f>
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
    e1d3:	8d 43 f0             	lea    -0x10(%ebx),%eax
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(tbuff->pkt);
				tbuff->pkt = NULL;
    e1d6:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
				fsm_mem_free(tbuff);
    e1dd:	e8 fc ff ff ff       	call   e1de <rlc_UM_segment+0x53e>
    e1e2:	e9 92 fd ff ff       	jmp    df79 <rlc_UM_segment+0x2d9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e1e7:	8b 53 10             	mov    0x10(%ebx),%edx
    e1ea:	8b 43 14             	mov    0x14(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e1ed:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e1f0:	89 10                	mov    %edx,(%eax)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e1f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e1f5:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e1fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e1ff:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e206:	83 68 24 01          	subl   $0x1,0x24(%eax)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e20a:	8b 03                	mov    (%ebx),%eax
    e20c:	8b 40 50             	mov    0x50(%eax),%eax
    e20f:	29 42 20             	sub    %eax,0x20(%edx)
						fsm_pkt_destroy(umBuffer->pkt);
    e212:	8b 03                	mov    (%ebx),%eax
    e214:	e8 fc ff ff ff       	call   e215 <rlc_UM_segment+0x575>
						umBuffer->pkt = NULL;
						fsm_mem_free(umBuffer);
    e219:	89 d8                	mov    %ebx,%eax
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
						umIns->umSduBufferSize -= umBuffer->pkt->len;
						fsm_pkt_destroy(umBuffer->pkt);
						umBuffer->pkt = NULL;
    e21b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(umBuffer);
    e221:	e8 fc ff ff ff       	call   e222 <rlc_UM_segment+0x582>
    e226:	e9 04 fd ff ff       	jmp    df2f <rlc_UM_segment+0x28f>
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e22b:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e230:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e235:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e23a:	31 f6                	xor    %esi,%esi
    e23c:	e9 e8 fd ff ff       	jmp    e029 <rlc_UM_segment+0x389>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e241:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e246:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e24b:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e250:	31 f6                	xor    %esi,%esi
    e252:	e9 0a fe ff ff       	jmp    e061 <rlc_UM_segment+0x3c1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e257:	ba 02 00 00 00       	mov    $0x2,%edx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e25c:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e261:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e266:	31 f6                	xor    %esi,%esi
    e268:	e9 3c fe ff ff       	jmp    e0a9 <rlc_UM_segment+0x409>
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
    e26d:	c7 04 24 ac 37 00 00 	movl   $0x37ac,(%esp)
    e274:	e8 fc ff ff ff       	call   e275 <rlc_UM_segment+0x5d5>
			return NULL;
    e279:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    e280:	e9 29 fd ff ff       	jmp    dfae <rlc_UM_segment+0x30e>
    e285:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000e290 <rlc_UM5_segment>:
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e290:	55                   	push   %ebp
    e291:	89 e5                	mov    %esp,%ebp
    e293:	57                   	push   %edi
    e294:	56                   	push   %esi
    e295:	53                   	push   %ebx
    e296:	83 ec 38             	sub    $0x38,%esp
    e299:	e8 fc ff ff ff       	call   e29a <rlc_UM5_segment+0xa>
	u32 size;
	int num = umIns->umSduBufferNum;
    e29e:	8b 78 24             	mov    0x24(%eax),%edi
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e2a1:	89 d3                	mov    %edx,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e2a3:	0f b7 50 28          	movzwl 0x28(%eax),%edx
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e2a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e2aa:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e2ae:	83 e2 1f             	and    $0x1f,%edx
    e2b1:	83 e0 e0             	and    $0xffffffe0,%eax
    e2b4:	09 d0                	or     %edx,%eax
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e2b6:	83 fb 01             	cmp    $0x1,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e2b9:	88 45 f3             	mov    %al,-0xd(%ebp)
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e2bc:	0f 86 9f 05 00 00    	jbe    e861 <rlc_UM5_segment+0x5d1>
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e2c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e2c5:	c7 04 24 14 38 00 00 	movl   $0x3814,(%esp)
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e2cc:	83 c0 18             	add    $0x18,%eax
    e2cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e2d2:	e8 fc ff ff ff       	call   e2d3 <rlc_UM5_segment+0x43>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    e2d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e2da:	8b 42 18             	mov    0x18(%edx),%eax
	if(!list_empty(head))
    e2dd:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e2e0:	0f 84 72 03 00 00    	je     e658 <rlc_UM5_segment+0x3c8>
	{
		list_for_each_entry(umBuffer,head,list)
    e2e6:	8d 70 f0             	lea    -0x10(%eax),%esi
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e2e9:	8b 40 f0             	mov    -0x10(%eax),%eax
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
    e2ec:	8d 53 ff             	lea    -0x1(%ebx),%edx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e2ef:	8b 40 50             	mov    0x50(%eax),%eax
    e2f2:	39 c2                	cmp    %eax,%edx
    e2f4:	0f 82 22 05 00 00    	jb     e81c <rlc_UM5_segment+0x58c>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e2fa:	0f 84 33 05 00 00    	je     e833 <rlc_UM5_segment+0x5a3>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e300:	8d 48 02             	lea    0x2(%eax),%ecx
    e303:	39 ca                	cmp    %ecx,%edx
    e305:	0f 86 3f 05 00 00    	jbe    e84a <rlc_UM5_segment+0x5ba>

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e30b:	31 db                	xor    %ebx,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e30d:	83 ef 01             	sub    $0x1,%edi
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e310:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e316:	b9 01 00 00 00       	mov    $0x1,%ecx
    e31b:	66 89 5d e0          	mov    %bx,-0x20(%ebp)
    e31f:	eb 54                	jmp    e375 <rlc_UM5_segment+0xe5>
    e321:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    e328:	84 c9                	test   %cl,%cl
    e32a:	74 04                	je     e330 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=1;
					fixhead->E=1;
    e32c:	80 4d f3 a0          	orb    $0xa0,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    e330:	85 ff                	test   %edi,%edi
    e332:	74 64                	je     e398 <rlc_UM5_segment+0x108>
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e334:	8b 4e 10             	mov    0x10(%esi),%ecx
    e337:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    e33a:	8d 71 f0             	lea    -0x10(%ecx),%esi
    e33d:	0f 84 95 02 00 00    	je     e5d8 <rlc_UM5_segment+0x348>
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e343:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e348:	83 ef 01             	sub    $0x1,%edi
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e34b:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e34d:	8b 41 f0             	mov    -0x10(%ecx),%eax
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e350:	01 da                	add    %ebx,%edx
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e352:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
			num--;
			if(size < umBuffer->pkt->len)
    e357:	8b 40 50             	mov    0x50(%eax),%eax
    e35a:	39 d0                	cmp    %edx,%eax
    e35c:	0f 87 86 02 00 00    	ja     e5e8 <rlc_UM5_segment+0x358>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e362:	0f 84 c0 02 00 00    	je     e628 <rlc_UM5_segment+0x398>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e368:	8d 48 02             	lea    0x2(%eax),%ecx
    e36b:	39 d1                	cmp    %edx,%ecx
    e36d:	0f 83 05 03 00 00    	jae    e678 <rlc_UM5_segment+0x3e8>
    e373:	31 c9                	xor    %ecx,%ecx
			{

				size = size - umBuffer->pkt->len - 2;
				length += umBuffer->pkt->len;
    e375:	66 01 45 e0          	add    %ax,-0x20(%ebp)
				if(umBuffer->pktstatus==FULL_SDU &&flag)
    e379:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e37d:	75 a9                	jne    e328 <rlc_UM5_segment+0x98>
    e37f:	84 c9                	test   %cl,%cl
    e381:	74 ad                	je     e330 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=0;
    e383:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    e387:	83 e1 7f             	and    $0x7f,%ecx
					fixhead->E=1;
    e38a:	83 c9 20             	or     $0x20,%ecx

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e38d:	85 ff                	test   %edi,%edi
				length += umBuffer->pkt->len;
				if(umBuffer->pktstatus==FULL_SDU &&flag)
				{

					fixhead->FIfirst=0;
					fixhead->E=1;
    e38f:	88 4d f3             	mov    %cl,-0xd(%ebp)

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e392:	75 a0                	jne    e334 <rlc_UM5_segment+0xa4>
    e394:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e398:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e39c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e39f:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e3a3:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
					flag=false;
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e3a7:	89 d0                	mov    %edx,%eax
    e3a9:	83 e0 df             	and    $0xffffffdf,%eax
    e3ac:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
    e3b0:	0f 45 c2             	cmovne %edx,%eax
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e3b3:	01 ff                	add    %edi,%edi
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
					fixhead->FIsecond=0;
    e3b5:	83 e0 bf             	and    $0xffffffbf,%eax
    e3b8:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=umBuffer->pkt->len;
    e3bb:	8b 06                	mov    (%esi),%eax
    e3bd:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e3c1:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
    e3c5:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e3c8:	ba 02 00 00 00       	mov    $0x2,%edx
    e3cd:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e3d0:	e8 fc ff ff ff       	call   e3d1 <rlc_UM5_segment+0x141>
	length = length + (2*count-1);
    e3d5:	8d 5c 3b ff          	lea    -0x1(%ebx,%edi,1),%ebx
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e3d9:	0f b7 db             	movzwl %bx,%ebx
    e3dc:	89 d8                	mov    %ebx,%eax
    e3de:	e8 fc ff ff ff       	call   e3df <rlc_UM5_segment+0x14f>
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e3e3:	66 83 7d ec 01       	cmpw   $0x1,-0x14(%ebp)
	}
	
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e3e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pos = head->next;
    e3eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e3ee:	8b 40 18             	mov    0x18(%eax),%eax
    e3f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e3f4:	0f 84 be 02 00 00    	je     e6b8 <rlc_UM5_segment+0x428>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			tbuff->pktstatus = LAST_SEGMENT;
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
    e3fa:	0f 86 4d 01 00 00    	jbe    e54d <rlc_UM5_segment+0x2bd>
	{
		fsm_skb_reserve(skb,(2*count-1));
    e400:	0f b7 5d ec          	movzwl -0x14(%ebp),%ebx
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
    e404:	31 ff                	xor    %edi,%edi
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e406:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e409:	8d 54 1b ff          	lea    -0x1(%ebx,%ebx,1),%edx
    e40d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e410:	83 eb 01             	sub    $0x1,%ebx
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e413:	e8 fc ff ff ff       	call   e414 <rlc_UM5_segment+0x184>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e418:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    e41b:	01 db                	add    %ebx,%ebx
    e41d:	89 d8                	mov    %ebx,%eax
    e41f:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    e422:	e8 fc ff ff ff       	call   e423 <rlc_UM5_segment+0x193>
    e427:	89 45 c8             	mov    %eax,-0x38(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e42a:	89 d8                	mov    %ebx,%eax
    e42c:	e8 fc ff ff ff       	call   e42d <rlc_UM5_segment+0x19d>
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e431:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e434:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int i = 0;
		unsigned char *des = skb->data;
    e437:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e43a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e440:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e443:	8b 42 18             	mov    0x18(%edx),%eax
    e446:	8b 30                	mov    (%eax),%esi
    e448:	8d 58 f0             	lea    -0x10(%eax),%ebx
    e44b:	83 ee 10             	sub    $0x10,%esi
    e44e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e451:	75 21                	jne    e474 <rlc_UM5_segment+0x1e4>
    e453:	e9 b8 00 00 00       	jmp    e510 <rlc_UM5_segment+0x280>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
    e458:	0f 84 32 01 00 00    	je     e590 <rlc_UM5_segment+0x300>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e45e:	8b 46 10             	mov    0x10(%esi),%eax
    e461:	8d 56 10             	lea    0x10(%esi),%edx
    e464:	83 e8 10             	sub    $0x10,%eax
    e467:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e46a:	0f 84 a0 00 00 00    	je     e510 <rlc_UM5_segment+0x280>
    e470:	89 f3                	mov    %esi,%ebx
    e472:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    e474:	3b 7d ec             	cmp    -0x14(%ebp),%edi
    e477:	7d df                	jge    e458 <rlc_UM5_segment+0x1c8>
			{
				*(LI+i) = umBuffer->pkt->len;
    e479:	8b 03                	mov    (%ebx),%eax
    e47b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
				*(headExt+i) = 0x80|(*(LI+i));
    e47e:	8b 55 d8             	mov    -0x28(%ebp),%edx
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
    e481:	8b 40 50             	mov    0x50(%eax),%eax
    e484:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
				*(headExt+i) = 0x80|(*(LI+i));
    e488:	0c 80                	or     $0x80,%al
    e48a:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
				fsm_skb_put(skb,umBuffer->pkt->len);
    e48e:	8b 03                	mov    (%ebx),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
    e490:	83 c7 01             	add    $0x1,%edi
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
    e493:	8b 50 50             	mov    0x50(%eax),%edx
    e496:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e499:	e8 fc ff ff ff       	call   e49a <rlc_UM5_segment+0x20a>
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e49e:	8b 03                	mov    (%ebx),%eax
    e4a0:	8b 48 50             	mov    0x50(%eax),%ecx
    e4a3:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e4a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e4ac:	e8 fc ff ff ff       	call   e4ad <rlc_UM5_segment+0x21d>
				des = des + umBuffer->pkt->len ;
    e4b1:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e4b3:	8b 53 10             	mov    0x10(%ebx),%edx
    e4b6:	8b 48 50             	mov    0x50(%eax),%ecx
    e4b9:	8b 43 14             	mov    0x14(%ebx),%eax
    e4bc:	01 4d dc             	add    %ecx,-0x24(%ebp)
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e4bf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e4c2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e4c5:	89 10                	mov    %edx,(%eax)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e4c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e4ca:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e4cd:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e4d4:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e4db:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e4df:	8b 42 f0             	mov    -0x10(%edx),%eax
    e4e2:	8b 40 50             	mov    0x50(%eax),%eax
    e4e5:	29 41 20             	sub    %eax,0x20(%ecx)
				fsm_pkt_destroy(umBuffer->pkt);
    e4e8:	8b 03                	mov    (%ebx),%eax
    e4ea:	e8 fc ff ff ff       	call   e4eb <rlc_UM5_segment+0x25b>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    e4ef:	89 d8                	mov    %ebx,%eax
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    e4f1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    e4f7:	e8 fc ff ff ff       	call   e4f8 <rlc_UM5_segment+0x268>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e4fc:	8b 46 10             	mov    0x10(%esi),%eax
    e4ff:	8d 56 10             	lea    0x10(%esi),%edx
    e502:	83 e8 10             	sub    $0x10,%eax
    e505:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e508:	0f 85 62 ff ff ff    	jne    e470 <rlc_UM5_segment+0x1e0>
    e50e:	66 90                	xchg   %ax,%ax
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e510:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e513:	8b 5d cc             	mov    -0x34(%ebp),%ebx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e516:	8b 55 d0             	mov    -0x30(%ebp),%edx
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e519:	66 81 64 58 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%ebx,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e520:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e523:	e8 fc ff ff ff       	call   e524 <rlc_UM5_segment+0x294>
    e528:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e52b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e52e:	e8 fc ff ff ff       	call   e52f <rlc_UM5_segment+0x29f>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e533:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e536:	ba 01 00 00 00       	mov    $0x1,%edx
    e53b:	e8 fc ff ff ff       	call   e53c <rlc_UM5_segment+0x2ac>
    e540:	b9 01 00 00 00       	mov    $0x1,%ecx
    e545:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e548:	e8 fc ff ff ff       	call   e549 <rlc_UM5_segment+0x2b9>
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e54d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	umIns->SN %= 32;
    e550:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e553:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e557:	83 c0 01             	add    $0x1,%eax
	umIns->SN %= 32;
    e55a:	89 c2                	mov    %eax,%edx
    e55c:	66 c1 fa 0f          	sar    $0xf,%dx
    e560:	66 c1 ea 0b          	shr    $0xb,%dx
    e564:	01 d0                	add    %edx,%eax
    e566:	83 e0 1f             	and    $0x1f,%eax
    e569:	66 29 d0             	sub    %dx,%ax
    e56c:	66 89 41 28          	mov    %ax,0x28(%ecx)
	fsm_printf("[RLC][rlc_UM5_segment] SN = %d\n",umIns->SN);
    e570:	98                   	cwtl   
    e571:	89 44 24 04          	mov    %eax,0x4(%esp)
    e575:	c7 04 24 34 38 00 00 	movl   $0x3834,(%esp)
    e57c:	e8 fc ff ff ff       	call   e57d <rlc_UM5_segment+0x2ed>
	return skb;
}
    e581:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e584:	83 c4 38             	add    $0x38,%esp
    e587:	5b                   	pop    %ebx
    e588:	5e                   	pop    %esi
    e589:	5f                   	pop    %edi
    e58a:	5d                   	pop    %ebp
    e58b:	c3                   	ret    
    e58c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    e590:	0f b7 75 c6          	movzwl -0x3a(%ebp),%esi
    e594:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e597:	89 f2                	mov    %esi,%edx
    e599:	e8 fc ff ff ff       	call   e59a <rlc_UM5_segment+0x30a>
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e59e:	8b 03                	mov    (%ebx),%eax
    e5a0:	89 f1                	mov    %esi,%ecx
    e5a2:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e5a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e5ab:	e8 fc ff ff ff       	call   e5ac <rlc_UM5_segment+0x31c>
				
				if(umBuffer->pkt->len == lastCopyLen)
    e5b0:	8b 03                	mov    (%ebx),%eax
    e5b2:	3b 70 50             	cmp    0x50(%eax),%esi
    e5b5:	0f 84 9e 01 00 00    	je     e759 <rlc_UM5_segment+0x4c9>
					fsm_mem_free(umBuffer); 
					umBuffer = NULL;
				}
				else
				{
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e5bb:	89 f2                	mov    %esi,%edx
    e5bd:	e8 fc ff ff ff       	call   e5be <rlc_UM5_segment+0x32e>
					umIns->umSduBufferSize -=lastCopyLen;
    e5c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e5c5:	29 70 20             	sub    %esi,0x20(%eax)
					umBuffer->pktstatus=LAST_SEGMENT;
    e5c8:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    e5cf:	e9 3c ff ff ff       	jmp    e510 <rlc_UM5_segment+0x280>
    e5d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e5d8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e5dc:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e5e0:	01 ff                	add    %edi,%edi
    e5e2:	e9 e1 fd ff ff       	jmp    e3c8 <rlc_UM5_segment+0x138>
    e5e7:	90                   	nop
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e5e8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e5ec:	31 c0                	xor    %eax,%eax
    e5ee:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e5f2:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e5f4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e5f8:	0f 84 a3 01 00 00    	je     e7a1 <rlc_UM5_segment+0x511>
					else
						fixhead->FIsecond=1;
				}
				else
				{
					if(flag)
    e5fe:	84 c0                	test   %al,%al
    e600:	0f 84 2a 01 00 00    	je     e730 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=1;
    e606:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e60a:	83 e0 1f             	and    $0x1f,%eax
						fixhead->FIsecond=1;
    e60d:	83 c8 c0             	or     $0xffffffc0,%eax
    e610:	88 45 f3             	mov    %al,-0xd(%ebp)
    e613:	90                   	nop
    e614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = size;
    e618:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
				length += size;
    e61c:	01 d3                	add    %edx,%ebx
				break;
    e61e:	e9 a5 fd ff ff       	jmp    e3c8 <rlc_UM5_segment+0x138>
    e623:	90                   	nop
    e624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e628:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e62c:	31 c0                	xor    %eax,%eax
    e62e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e632:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e634:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e638:	0f 84 79 01 00 00    	je     e7b7 <rlc_UM5_segment+0x527>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e63e:	84 c0                	test   %al,%al
    e640:	0f 84 fa 00 00 00    	je     e740 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=1;
    e646:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e64a:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e64d:	83 e0 9f             	and    $0xffffff9f,%eax
    e650:	88 45 f3             	mov    %al,-0xd(%ebp)
    e653:	eb c3                	jmp    e618 <rlc_UM5_segment+0x388>
    e655:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e658:	ba 02 00 00 00       	mov    $0x2,%edx
    e65d:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e660:	e8 fc ff ff ff       	call   e661 <rlc_UM5_segment+0x3d1>
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e665:	b8 ff ff 00 00       	mov    $0xffff,%eax
    e66a:	e8 fc ff ff ff       	call   e66b <rlc_UM5_segment+0x3db>
    e66f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e672:	e9 d6 fe ff ff       	jmp    e54d <rlc_UM5_segment+0x2bd>
    e677:	90                   	nop
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e678:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e67c:	31 c0                	xor    %eax,%eax
    e67e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e682:	01 ff                	add    %edi,%edi
				}
			}
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e684:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e688:	0f 84 36 01 00 00    	je     e7c4 <rlc_UM5_segment+0x534>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e68e:	84 c0                	test   %al,%al
    e690:	0f 84 ba 00 00 00    	je     e750 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=1;
    e696:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e69a:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e69d:	83 e0 9f             	and    $0xffffff9f,%eax
    e6a0:	88 45 f3             	mov    %al,-0xd(%ebp)
						flag=false;
					}
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = umBuffer->pkt->len ;
    e6a3:	8b 06                	mov    (%esi),%eax
    e6a5:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e6a9:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
				length += umBuffer->pkt->len;
    e6ad:	01 c3                	add    %eax,%ebx
				break;
    e6af:	e9 14 fd ff ff       	jmp    e3c8 <rlc_UM5_segment+0x138>
    e6b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    e6b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6bb:	89 da                	mov    %ebx,%edx
    e6bd:	e8 fc ff ff ff       	call   e6be <rlc_UM5_segment+0x42e>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e6c2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    e6c5:	0f b7 5d c6          	movzwl -0x3a(%ebp),%ebx
    e6c9:	8b 42 f0             	mov    -0x10(%edx),%eax
    e6cc:	89 da                	mov    %ebx,%edx
    e6ce:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e6d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6d7:	e8 fc ff ff ff       	call   e6d8 <rlc_UM5_segment+0x448>
    e6dc:	89 d9                	mov    %ebx,%ecx
    e6de:	89 f2                	mov    %esi,%edx
    e6e0:	e8 fc ff ff ff       	call   e6e1 <rlc_UM5_segment+0x451>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e6e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6e8:	ba 01 00 00 00       	mov    $0x1,%edx
    e6ed:	e8 fc ff ff ff       	call   e6ee <rlc_UM5_segment+0x45e>
    e6f2:	b9 01 00 00 00       	mov    $0x1,%ecx
    e6f7:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e6fa:	e8 fc ff ff ff       	call   e6fb <rlc_UM5_segment+0x46b>
		
		if(lastCopyLen == tbuff->pkt->len)
    e6ff:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e702:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e705:	3b 58 50             	cmp    0x50(%eax),%ebx
    e708:	0f 84 c3 00 00 00    	je     e7d1 <rlc_UM5_segment+0x541>
			fsm_mem_free(tbuff);
			tbuff = NULL;
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e70e:	89 da                	mov    %ebx,%edx
    e710:	e8 fc ff ff ff       	call   e711 <rlc_UM5_segment+0x481>
			tbuff->pktstatus = LAST_SEGMENT;
    e715:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e718:	c7 40 f4 02 00 00 00 	movl   $0x2,-0xc(%eax)
			umIns->umSduBufferSize -=lastCopyLen;
    e71f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e722:	29 58 20             	sub    %ebx,0x20(%eax)
    e725:	e9 23 fe ff ff       	jmp    e54d <rlc_UM5_segment+0x2bd>
    e72a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
						fixhead->E=0;
						fixhead->FIsecond=1;
						flag=false;
					}
					else
						fixhead->FIsecond=1;
    e730:	80 4d f3 40          	orb    $0x40,-0xd(%ebp)
    e734:	e9 df fe ff ff       	jmp    e618 <rlc_UM5_segment+0x388>
    e739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
    e740:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e744:	e9 cf fe ff ff       	jmp    e618 <rlc_UM5_segment+0x388>
    e749:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}
					else
						fixhead->FIsecond=0;
    e750:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e754:	e9 4a ff ff ff       	jmp    e6a3 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e759:	8b 53 10             	mov    0x10(%ebx),%edx
    e75c:	8b 43 14             	mov    0x14(%ebx),%eax
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e75f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e762:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e765:	89 10                	mov    %edx,(%eax)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e767:	8b 45 e4             	mov    -0x1c(%ebp),%eax
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e76a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e76d:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e774:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e77b:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e77f:	8b 42 f0             	mov    -0x10(%edx),%eax
    e782:	8b 40 50             	mov    0x50(%eax),%eax
    e785:	29 41 20             	sub    %eax,0x20(%ecx)
					fsm_pkt_destroy(umBuffer->pkt);
    e788:	8b 03                	mov    (%ebx),%eax
    e78a:	e8 fc ff ff ff       	call   e78b <rlc_UM5_segment+0x4fb>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer); 
    e78f:	89 d8                	mov    %ebx,%eax
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    e791:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer); 
    e797:	e8 fc ff ff ff       	call   e798 <rlc_UM5_segment+0x508>
    e79c:	e9 6f fd ff ff       	jmp    e510 <rlc_UM5_segment+0x280>
			if(size < umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e7a1:	84 c0                	test   %al,%al
    e7a3:	74 8b                	je     e730 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=0;
    e7a5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e7a9:	83 e0 5f             	and    $0x5f,%eax
						fixhead->FIsecond=1;
    e7ac:	83 c8 40             	or     $0x40,%eax
    e7af:	88 45 f3             	mov    %al,-0xd(%ebp)
    e7b2:	e9 61 fe ff ff       	jmp    e618 <rlc_UM5_segment+0x388>
			else if(size == umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e7b7:	84 c0                	test   %al,%al
    e7b9:	74 85                	je     e740 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e7bb:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e7bf:	e9 54 fe ff ff       	jmp    e618 <rlc_UM5_segment+0x388>
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e7c4:	84 c0                	test   %al,%al
    e7c6:	74 88                	je     e750 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e7c8:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e7cc:	e9 d2 fe ff ff       	jmp    e6a3 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e7d1:	8b 11                	mov    (%ecx),%edx
    e7d3:	8b 41 04             	mov    0x4(%ecx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e7d6:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e7d9:	89 10                	mov    %edx,(%eax)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e7db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e7de:	c7 01 00 01 10 00    	movl   $0x100100,(%ecx)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e7e4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e7e7:	c7 41 04 00 02 20 00 	movl   $0x200200,0x4(%ecx)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e7ee:	83 68 24 01          	subl   $0x1,0x24(%eax)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e7f2:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e7f5:	8b 40 50             	mov    0x50(%eax),%eax
    e7f8:	29 42 20             	sub    %eax,0x20(%edx)
			fsm_pkt_destroy(tbuff->pkt);
    e7fb:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e7fe:	e8 fc ff ff ff       	call   e7ff <rlc_UM5_segment+0x56f>
			tbuff->pkt = NULL;
    e803:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e806:	89 d8                	mov    %ebx,%eax
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
    e808:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e80f:	83 e8 10             	sub    $0x10,%eax
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
			fsm_mem_free(tbuff);
    e812:	e8 fc ff ff ff       	call   e813 <rlc_UM5_segment+0x583>
    e817:	e9 31 fd ff ff       	jmp    e54d <rlc_UM5_segment+0x2bd>
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e81c:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e821:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e826:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e82c:	31 db                	xor    %ebx,%ebx
    e82e:	e9 c1 fd ff ff       	jmp    e5f4 <rlc_UM5_segment+0x364>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e833:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e838:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e83d:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e843:	31 db                	xor    %ebx,%ebx
    e845:	e9 ea fd ff ff       	jmp    e634 <rlc_UM5_segment+0x3a4>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e84a:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e84f:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e854:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e85a:	31 db                	xor    %ebx,%ebx
    e85c:	e9 23 fe ff ff       	jmp    e684 <rlc_UM5_segment+0x3f4>
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
    e861:	c7 04 24 f0 37 00 00 	movl   $0x37f0,(%esp)
    e868:	e8 fc ff ff ff       	call   e869 <rlc_UM5_segment+0x5d9>
		return NULL;
    e86d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    e874:	e9 08 fd ff ff       	jmp    e581 <rlc_UM5_segment+0x2f1>
    e879:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000e880 <rlc_resegment>:
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e880:	55                   	push   %ebp
    e881:	89 e5                	mov    %esp,%ebp
    e883:	57                   	push   %edi
    e884:	56                   	push   %esi
    e885:	53                   	push   %ebx
    e886:	83 ec 20             	sub    $0x20,%esp
    e889:	e8 fc ff ff ff       	call   e88a <rlc_resegment+0xa>
	if(tbuff->segStart[0] != -1)
    e88e:	83 78 10 ff          	cmpl   $0xffffffff,0x10(%eax)
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e892:	89 c3                	mov    %eax,%ebx
    e894:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if(tbuff->segStart[0] != -1)
    e897:	0f 84 63 02 00 00    	je     eb00 <rlc_resegment+0x280>
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    e89d:	b8 02 00 00 00       	mov    $0x2,%eax
    e8a2:	e8 fc ff ff ff       	call   e8a3 <rlc_resegment+0x23>
		int start = tbuff->segStart[0];
    e8a7:	8b 4b 10             	mov    0x10(%ebx),%ecx
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
    e8aa:	8b 73 0c             	mov    0xc(%ebx),%esi
    e8ad:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    e8b0:	83 c6 02             	add    $0x2,%esi
{
	if(tbuff->segStart[0] != -1)
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    e8b3:	89 c7                	mov    %eax,%edi
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    e8b5:	8b 43 50             	mov    0x50(%ebx),%eax
		int headLen = tbuff->headLen + 2;
    e8b8:	89 75 ec             	mov    %esi,-0x14(%ebp)
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    e8bb:	8b b3 90 00 00 00    	mov    0x90(%ebx),%esi
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    e8c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
    e8c4:	29 c8                	sub    %ecx,%eax
    e8c6:	83 c0 01             	add    $0x1,%eax
    e8c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int retxSize = headLen + dataLen;
    e8cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e8cf:	03 45 e8             	add    -0x18(%ebp),%eax
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    e8d2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    e8d5:	89 75 e0             	mov    %esi,-0x20(%ebp)
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
    e8d8:	88 0f                	mov    %cl,(%edi)
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    e8da:	0f 87 48 01 00 00    	ja     ea28 <rlc_resegment+0x1a8>
		{
			exthead->SO = start;
    e8e0:	0f b6 d5             	movzbl %ch,%edx
    e8e3:	83 e2 7f             	and    $0x7f,%edx
    e8e6:	89 d6                	mov    %edx,%esi
    e8e8:	0f b6 57 01          	movzbl 0x1(%edi),%edx
    e8ec:	83 e2 80             	and    $0xffffff80,%edx
    e8ef:	09 f2                	or     %esi,%edx
    e8f1:	88 57 01             	mov    %dl,0x1(%edi)
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
    e8f4:	8b 75 d8             	mov    -0x28(%ebp),%esi
    e8f7:	03 75 ec             	add    -0x14(%ebp),%esi
    e8fa:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    e8fd:	8b 33                	mov    (%ebx),%esi
    e8ff:	8b b6 ac 00 00 00    	mov    0xac(%esi),%esi
    e905:	01 75 e4             	add    %esi,-0x1c(%ebp)
    e908:	8b 33                	mov    (%ebx),%esi
    e90a:	8b b6 a0 00 00 00    	mov    0xa0(%esi),%esi
    e910:	83 ee 01             	sub    $0x1,%esi
    e913:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
    e916:	0f 84 d4 01 00 00    	je     eaf0 <rlc_resegment+0x270>
			{
				exthead->LSF = 1;
			}
			else
			{
				exthead->LSF = 0;
    e91c:	83 e2 7f             	and    $0x7f,%edx
    e91f:	88 57 01             	mov    %dl,0x1(%edi)
			}
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    e922:	8b 13                	mov    (%ebx),%edx
    e924:	8b 92 ac 00 00 00    	mov    0xac(%edx),%edx
    e92a:	89 55 f0             	mov    %edx,-0x10(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    e92d:	80 4a 01 40          	orb    $0x40,0x1(%edx)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    e931:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    e934:	e8 fc ff ff ff       	call   e935 <rlc_resegment+0xb5>
			fsm_skb_reserve(skb,headLen);
    e939:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    e93c:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    e93e:	e8 fc ff ff ff       	call   e93f <rlc_resegment+0xbf>
			tail = fsm_skb_put(skb,dataLen);
    e943:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e946:	89 f0                	mov    %esi,%eax
    e948:	e8 fc ff ff ff       	call   e949 <rlc_resegment+0xc9>
			fsm_mem_cpy(skb->data,(tbuff->pkt->data + tbuff->headLen  + start),dataLen); 
    e94d:	8b 03                	mov    (%ebx),%eax
    e94f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e952:	8b 53 0c             	mov    0xc(%ebx),%edx
    e955:	01 ca                	add    %ecx,%edx
    e957:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    e95a:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    e960:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    e966:	e8 fc ff ff ff       	call   e967 <rlc_resegment+0xe7>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4); //kuo zhan tou fu zhi
    e96b:	8b 03                	mov    (%ebx),%eax
    e96d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    e970:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e976:	83 e9 04             	sub    $0x4,%ecx
    e979:	89 ca                	mov    %ecx,%edx
    e97b:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    e97e:	83 c0 02             	add    $0x2,%eax
    e981:	89 45 ec             	mov    %eax,-0x14(%ebp)
    e984:	89 f0                	mov    %esi,%eax
    e986:	e8 fc ff ff ff       	call   e987 <rlc_resegment+0x107>
    e98b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e98e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e991:	e8 fc ff ff ff       	call   e992 <rlc_resegment+0x112>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    e996:	ba 02 00 00 00       	mov    $0x2,%edx
    e99b:	89 f0                	mov    %esi,%eax
    e99d:	e8 fc ff ff ff       	call   e99e <rlc_resegment+0x11e>
    e9a2:	b9 02 00 00 00       	mov    $0x2,%ecx
    e9a7:	89 fa                	mov    %edi,%edx
    e9a9:	e8 fc ff ff ff       	call   e9aa <rlc_resegment+0x12a>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e9ae:	ba 02 00 00 00       	mov    $0x2,%edx
    e9b3:	89 f0                	mov    %esi,%eax
    e9b5:	e8 fc ff ff ff       	call   e9b6 <rlc_resegment+0x136>
    e9ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e9bd:	b9 02 00 00 00       	mov    $0x2,%ecx
    e9c2:	e8 fc ff ff ff       	call   e9c3 <rlc_resegment+0x143>

			if(count == 1)
    e9c7:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
    e9cb:	0f 84 47 01 00 00    	je     eb18 <rlc_resegment+0x298>
			{
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
    e9d1:	7e 3e                	jle    ea11 <rlc_resegment+0x191>
			{				
				for(i=0; i < count-1; i++)
    e9d3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    e9d6:	89 d8                	mov    %ebx,%eax
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    e9d8:	31 d2                	xor    %edx,%edx
    e9da:	89 75 ec             	mov    %esi,-0x14(%ebp)
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    e9dd:	83 e9 01             	sub    $0x1,%ecx
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    e9e0:	89 ce                	mov    %ecx,%esi
    e9e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
    e9e8:	8b 48 14             	mov    0x14(%eax),%ecx
    e9eb:	83 c2 01             	add    $0x1,%edx
    e9ee:	89 48 10             	mov    %ecx,0x10(%eax)
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
    e9f1:	8b 48 54             	mov    0x54(%eax),%ecx
    e9f4:	89 48 50             	mov    %ecx,0x50(%eax)
    e9f7:	83 c0 04             	add    $0x4,%eax
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    e9fa:	39 f2                	cmp    %esi,%edx
    e9fc:	75 ea                	jne    e9e8 <rlc_resegment+0x168>
    e9fe:	8b 75 ec             	mov    -0x14(%ebp),%esi
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
				}
				tbuff->segStart[count-1] = -1;
    ea01:	c7 44 93 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%edx,4)
    ea08:	ff 
				tbuff->segEnd[count-1] = -1;
    ea09:	c7 44 93 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%edx,4)
    ea10:	ff 
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			tbuff->segStart[0] += len;
		}
		if(exthead != NULL)
    ea11:	85 ff                	test   %edi,%edi
    ea13:	74 07                	je     ea1c <rlc_resegment+0x19c>
		{
			fsm_mem_free(exthead);
    ea15:	89 f8                	mov    %edi,%eax
    ea17:	e8 fc ff ff ff       	call   ea18 <rlc_resegment+0x198>
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    ea1c:	83 c4 20             	add    $0x20,%esp
		if(exthead != NULL)
		{
			fsm_mem_free(exthead);
			exthead=NULL;
		}
		return skb;
    ea1f:	89 f0                	mov    %esi,%eax
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    ea21:	5b                   	pop    %ebx
    ea22:	5e                   	pop    %esi
    ea23:	5f                   	pop    %edi
    ea24:	5d                   	pop    %ebp
    ea25:	c3                   	ret    
    ea26:	66 90                	xchg   %ax,%ax
				count--;
			}
		}
		else                    //need resegment
		{
			exthead->SO = start;
    ea28:	0f b6 c5             	movzbl %ch,%eax
			exthead->LSF = 0;
    ea2b:	83 e0 7f             	and    $0x7f,%eax
    ea2e:	88 47 01             	mov    %al,0x1(%edi)
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    ea31:	8b 03                	mov    (%ebx),%eax
    ea33:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ea39:	89 45 e8             	mov    %eax,-0x18(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    ea3c:	80 48 01 40          	orb    $0x40,0x1(%eax)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    ea40:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea43:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ea46:	e8 fc ff ff ff       	call   ea47 <rlc_resegment+0x1c7>
			fsm_skb_reserve(skb,headLen);
    ea4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    ea4e:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    ea50:	e8 fc ff ff ff       	call   ea51 <rlc_resegment+0x1d1>
			len = sizeFromMac - headLen;
    ea55:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea58:	2b 45 ec             	sub    -0x14(%ebp),%eax
			tail = fsm_skb_put(skb,len);
    ea5b:	89 c2                	mov    %eax,%edx
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
			fsm_skb_reserve(skb,headLen);
			len = sizeFromMac - headLen;
    ea5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
			tail = fsm_skb_put(skb,len);
    ea60:	89 f0                	mov    %esi,%eax
    ea62:	e8 fc ff ff ff       	call   ea63 <rlc_resegment+0x1e3>
			fsm_mem_cpy(skb->data,tbuff->pkt->data + tbuff->headLen  + start,len); 
    ea67:	8b 03                	mov    (%ebx),%eax
    ea69:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ea6c:	8b 53 0c             	mov    0xc(%ebx),%edx
    ea6f:	01 ca                	add    %ecx,%edx
    ea71:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ea74:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    ea7a:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    ea80:	e8 fc ff ff ff       	call   ea81 <rlc_resegment+0x201>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
    ea85:	8b 03                	mov    (%ebx),%eax
    ea87:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    ea8a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ea90:	83 e9 02             	sub    $0x2,%ecx
    ea93:	89 ca                	mov    %ecx,%edx
    ea95:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ea98:	83 c0 02             	add    $0x2,%eax
    ea9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ea9e:	89 f0                	mov    %esi,%eax
    eaa0:	e8 fc ff ff ff       	call   eaa1 <rlc_resegment+0x221>
    eaa5:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    eaa8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eaab:	e8 fc ff ff ff       	call   eaac <rlc_resegment+0x22c>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    eab0:	ba 02 00 00 00       	mov    $0x2,%edx
    eab5:	89 f0                	mov    %esi,%eax
    eab7:	e8 fc ff ff ff       	call   eab8 <rlc_resegment+0x238>
    eabc:	b9 02 00 00 00       	mov    $0x2,%ecx
    eac1:	89 fa                	mov    %edi,%edx
    eac3:	e8 fc ff ff ff       	call   eac4 <rlc_resegment+0x244>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    eac8:	ba 02 00 00 00       	mov    $0x2,%edx
    eacd:	89 f0                	mov    %esi,%eax
    eacf:	e8 fc ff ff ff       	call   ead0 <rlc_resegment+0x250>
    ead4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ead7:	b9 02 00 00 00       	mov    $0x2,%ecx
    eadc:	e8 fc ff ff ff       	call   eadd <rlc_resegment+0x25d>
			tbuff->segStart[0] += len;
    eae1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eae4:	01 53 10             	add    %edx,0x10(%ebx)
    eae7:	e9 25 ff ff ff       	jmp    ea11 <rlc_resegment+0x191>
    eaec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
			{
				exthead->LSF = 1;
    eaf0:	83 ca 80             	or     $0xffffff80,%edx
    eaf3:	88 57 01             	mov    %dl,0x1(%edi)
    eaf6:	e9 27 fe ff ff       	jmp    e922 <rlc_resegment+0xa2>
    eafb:	90                   	nop
    eafc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		return skb;
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
    eb00:	c7 04 24 54 38 00 00 	movl   $0x3854,(%esp)
    eb07:	e8 fc ff ff ff       	call   eb08 <rlc_resegment+0x288>
	}
}
    eb0c:	83 c4 20             	add    $0x20,%esp
    eb0f:	5b                   	pop    %ebx
    eb10:	5e                   	pop    %esi
    eb11:	5f                   	pop    %edi
    eb12:	5d                   	pop    %ebp
    eb13:	c3                   	ret    
    eb14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);

			if(count == 1)
			{
				tbuff->segStart[0]=-1;
    eb18:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
				tbuff->segEnd[0]=-1;
    eb1f:	c7 43 50 ff ff ff ff 	movl   $0xffffffff,0x50(%ebx)
    eb26:	e9 e6 fe ff ff       	jmp    ea11 <rlc_resegment+0x191>
    eb2b:	90                   	nop
    eb2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000eb30 <rlc_AM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
{
    eb30:	55                   	push   %ebp
    eb31:	89 e5                	mov    %esp,%ebp
    eb33:	57                   	push   %edi
    eb34:	56                   	push   %esi
    eb35:	53                   	push   %ebx
    eb36:	83 ec 44             	sub    $0x44,%esp
    eb39:	e8 fc ff ff ff       	call   eb3a <rlc_AM_reassemble_deliver+0xa>
    eb3e:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eb41:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    eb44:	e8 fc ff ff ff       	call   eb45 <rlc_AM_reassemble_deliver+0x15>
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    eb49:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    eb4c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    eb4f:	0f bf 82 ee 22 00 00 	movswl 0x22ee(%edx),%eax
    eb56:	89 44 24 08          	mov    %eax,0x8(%esp)
    eb5a:	0f bf 82 f4 22 00 00 	movswl 0x22f4(%edx),%eax
    eb61:	c7 04 24 90 38 00 00 	movl   $0x3890,(%esp)
    eb68:	89 44 24 04          	mov    %eax,0x4(%esp)
    eb6c:	e8 fc ff ff ff       	call   eb6d <rlc_AM_reassemble_deliver+0x3d>
	u16 h=(amIns->vr_h + 1)%1024;
    eb71:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    eb74:	0f bf 81 ee 22 00 00 	movswl 0x22ee(%ecx),%eax
    eb7b:	83 c0 01             	add    $0x1,%eax
    eb7e:	89 c2                	mov    %eax,%edx
    eb80:	c1 fa 1f             	sar    $0x1f,%edx
    eb83:	c1 ea 16             	shr    $0x16,%edx
    eb86:	01 d0                	add    %edx,%eax
    eb88:	25 ff 03 00 00       	and    $0x3ff,%eax
    eb8d:	29 d0                	sub    %edx,%eax
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    eb8f:	0f b7 c0             	movzwl %ax,%eax
    eb92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    eb95:	0f b7 81 f4 22 00 00 	movzwl 0x22f4(%ecx),%eax
    eb9c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    eb9f:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    eba5:	89 d0                	mov    %edx,%eax
    eba7:	c1 f8 1f             	sar    $0x1f,%eax
    ebaa:	c1 e8 16             	shr    $0x16,%eax
    ebad:	01 c2                	add    %eax,%edx
    ebaf:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    ebb5:	29 c2                	sub    %eax,%edx
    ebb7:	85 d2                	test   %edx,%edx
    ebb9:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ebbc:	0f 8e 16 04 00 00    	jle    efd8 <rlc_AM_reassemble_deliver+0x4a8>
    ebc2:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    ebc5:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    ebc8:	e9 8d 00 00 00       	jmp    ec5a <rlc_AM_reassemble_deliver+0x12a>
    ebcd:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    ebd0:	84 c0                	test   %al,%al
    ebd2:	0f 84 88 01 00 00    	je     ed60 <rlc_AM_reassemble_deliver+0x230>
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
					//fsm_octets_print(tbuff->pkt->data,64);
				}
			}
			else if(pduhdr->E==1)
    ebd8:	83 e2 04             	and    $0x4,%edx
    ebdb:	0f 85 e7 01 00 00    	jne    edc8 <rlc_AM_reassemble_deliver+0x298>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ebe1:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    ebe7:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ebed:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ebf0:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
				{
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
    ebf2:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ebf4:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
    ebfb:	01 10 00 
	entry->prev = LIST_POISON2;
    ebfe:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
    ec05:	02 20 00 
    ec08:	e8 fc ff ff ff       	call   ec09 <rlc_AM_reassemble_deliver+0xd9>
					tbuff = NULL;
				}
			if(icimsg != NULL)
    ec0d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ec10:	85 c9                	test   %ecx,%ecx
    ec12:	74 08                	je     ec1c <rlc_AM_reassemble_deliver+0xec>
			{
				fsm_mem_free(icimsg);
    ec14:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ec17:	e8 fc ff ff ff       	call   ec18 <rlc_AM_reassemble_deliver+0xe8>
				icimsg=NULL;
			}
			amIns->amRecvWindow[i]=NULL;
    ec1c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    ec1f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ec22:	c7 44 98 0c 00 00 00 	movl   $0x0,0xc(%eax,%ebx,4)
    ec29:	00 
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
	u16 h=(amIns->vr_h + 1)%1024;
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    ec2a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec2e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    ec35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec38:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    ec3b:	05 00 04 00 00       	add    $0x400,%eax
    ec40:	89 c2                	mov    %eax,%edx
    ec42:	c1 fa 1f             	sar    $0x1f,%edx
    ec45:	c1 ea 16             	shr    $0x16,%edx
    ec48:	01 d0                	add    %edx,%eax
    ec4a:	25 ff 03 00 00       	and    $0x3ff,%eax
    ec4f:	29 d0                	sub    %edx,%eax
    ec51:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    ec54:	0f 8d 7e 03 00 00    	jge    efd8 <rlc_AM_reassemble_deliver+0x4a8>
	//for(i=0; i<=AM_WINDOW_SIZE; i++)
	{
		if(amIns->amRecvWindow[i] != NULL)
    ec5a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    ec5d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ec60:	81 c3 98 04 00 00    	add    $0x498,%ebx
    ec66:	8b 74 98 0c          	mov    0xc(%eax,%ebx,4),%esi
    ec6a:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    ec6d:	85 f6                	test   %esi,%esi
    ec6f:	74 b9                	je     ec2a <rlc_AM_reassemble_deliver+0xfa>
		{
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    ec71:	8b 06                	mov    (%esi),%eax
    ec73:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    ec79:	b8 02 00 00 00       	mov    $0x2,%eax
    ec7e:	e8 fc ff ff ff       	call   ec7f <rlc_AM_reassemble_deliver+0x14f>
    ec83:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    ec86:	8b 43 02             	mov    0x2(%ebx),%eax
    ec89:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec8c:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    ec8e:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    ec92:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ec95:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ec97:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ec9c:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    eca2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    eca5:	e8 fc ff ff ff       	call   eca6 <rlc_AM_reassemble_deliver+0x176>
    		fsm_printf("[RLC][rlc_AM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    ecaa:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ecae:	c0 e8 03             	shr    $0x3,%al
    ecb1:	83 e0 01             	and    $0x1,%eax
    ecb4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ecb8:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ecbc:	c0 e8 04             	shr    $0x4,%al
    ecbf:	83 e0 01             	and    $0x1,%eax
    ecc2:	89 44 24 08          	mov    %eax,0x8(%esp)
    ecc6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ecca:	c7 04 24 c4 38 00 00 	movl   $0x38c4,(%esp)
    ecd1:	c0 e8 02             	shr    $0x2,%al
    ecd4:	83 e0 01             	and    $0x1,%eax
    ecd7:	89 44 24 04          	mov    %eax,0x4(%esp)
    ecdb:	e8 fc ff ff ff       	call   ecdc <rlc_AM_reassemble_deliver+0x1ac>
			//fsm_octets_print(tbuff->pkt->data,64);
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    ece0:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    ece4:	89 d0                	mov    %edx,%eax
    ece6:	83 e0 14             	and    $0x14,%eax
    ece9:	3c 10                	cmp    $0x10,%al
    eceb:	0f 85 df fe ff ff    	jne    ebd0 <rlc_AM_reassemble_deliver+0xa0>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ecf1:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ecf4:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    ecf8:	66 83 f9 ff          	cmp    $0xffff,%cx
    ecfc:	74 2f                	je     ed2d <rlc_AM_reassemble_deliver+0x1fd>
    ecfe:	0f bf c9             	movswl %cx,%ecx
    ed01:	0f b6 13             	movzbl (%ebx),%edx
    ed04:	83 c1 01             	add    $0x1,%ecx
    ed07:	89 c8                	mov    %ecx,%eax
    ed09:	c1 f8 1f             	sar    $0x1f,%eax
    ed0c:	c1 e8 16             	shr    $0x16,%eax
    ed0f:	01 c1                	add    %eax,%ecx
    ed11:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ed17:	29 c1                	sub    %eax,%ecx
    ed19:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ed1d:	83 e0 03             	and    $0x3,%eax
    ed20:	c1 e0 08             	shl    $0x8,%eax
    ed23:	09 d0                	or     %edx,%eax
    ed25:	39 c1                	cmp    %eax,%ecx
    ed27:	0f 84 e3 03 00 00    	je     f110 <rlc_AM_reassemble_deliver+0x5e0>
						//fsm_octets_print(new_skb->data,new_skb->len);
					}
				}
				else
				{
					SV(countDropPacket)++;
    ed2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ed30:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    ed37:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ed3a:	e8 fc ff ff ff       	call   ed3b <rlc_AM_reassemble_deliver+0x20b>
                    
					if(tbuff->pkt != NULL)
    ed3f:	8b 06                	mov    (%esi),%eax
    ed41:	85 c0                	test   %eax,%eax
    ed43:	0f 84 98 fe ff ff    	je     ebe1 <rlc_AM_reassemble_deliver+0xb1>
					{
						fsm_pkt_destroy(tbuff->pkt);
    ed49:	e8 fc ff ff ff       	call   ed4a <rlc_AM_reassemble_deliver+0x21a>
						tbuff->pkt = NULL;
    ed4e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    ed54:	e9 88 fe ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
    ed59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{
				clear_left_pdu(pdu_left);
    ed60:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ed63:	e8 fc ff ff ff       	call   ed64 <rlc_AM_reassemble_deliver+0x234>
				if(pduhdr->FIsecond==0)
    ed68:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    ed6b:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    ed6f:	0f 85 6b 02 00 00    	jne    efe0 <rlc_AM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    ed75:	8b 1e                	mov    (%esi),%ebx
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ed77:	89 d8                	mov    %ebx,%eax
    ed79:	e8 fc ff ff ff       	call   ed7a <rlc_AM_reassemble_deliver+0x24a>
    ed7e:	83 f8 01             	cmp    $0x1,%eax
    ed81:	0f 86 9f 04 00 00    	jbe    f226 <rlc_AM_reassemble_deliver+0x6f6>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ed87:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ed8a:	b9 02 00 00 00       	mov    $0x2,%ecx
    ed8f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ed95:	e8 fc ff ff ff       	call   ed96 <rlc_AM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ed9a:	89 d8                	mov    %ebx,%eax
    ed9c:	ba 06 00 00 00       	mov    $0x6,%edx
    eda1:	e8 fc ff ff ff       	call   eda2 <rlc_AM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					//list_del(&tbuff->list);
					//fsm_mem_free(tbuff);
					//tbuff=NULL;
					SV(countSendToUpper)++;
    eda6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    eda9:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP2\n");
    edb0:	c7 04 24 88 39 00 00 	movl   $0x3988,(%esp)
    edb7:	e8 fc ff ff ff       	call   edb8 <rlc_AM_reassemble_deliver+0x288>
    edbc:	e9 20 fe ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
    edc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    edc8:	b8 40 00 00 00       	mov    $0x40,%eax
    edcd:	e8 fc ff ff ff       	call   edce <rlc_AM_reassemble_deliver+0x29e>
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    edd2:	31 c9                	xor    %ecx,%ecx
    edd4:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    edd6:	89 45 d0             	mov    %eax,-0x30(%ebp)
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    edd9:	89 04 24             	mov    %eax,(%esp)
    eddc:	b8 01 00 00 00       	mov    $0x1,%eax
    ede1:	e8 fc ff ff ff       	call   ede2 <rlc_AM_reassemble_deliver+0x2b2>
               
				if(pduhdr->FIfirst==1)
    ede6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ede9:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
               
				if(pduhdr->FIfirst==1)
    eded:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    edf1:	0f 84 81 02 00 00    	je     f078 <rlc_AM_reassemble_deliver+0x548>
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    edf7:	8b 55 c0             	mov    -0x40(%ebp),%edx
    edfa:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    edfe:	66 83 f8 ff          	cmp    $0xffff,%ax
    ee02:	74 2d                	je     ee31 <rlc_AM_reassemble_deliver+0x301>
    ee04:	98                   	cwtl   
    ee05:	0f b6 13             	movzbl (%ebx),%edx
    ee08:	8d 48 01             	lea    0x1(%eax),%ecx
    ee0b:	89 c8                	mov    %ecx,%eax
    ee0d:	c1 f8 1f             	sar    $0x1f,%eax
    ee10:	c1 e8 16             	shr    $0x16,%eax
    ee13:	01 c1                	add    %eax,%ecx
    ee15:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ee1b:	29 c1                	sub    %eax,%ecx
    ee1d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ee21:	83 e0 03             	and    $0x3,%eax
    ee24:	c1 e0 08             	shl    $0x8,%eax
    ee27:	09 d0                	or     %edx,%eax
    ee29:	39 c1                	cmp    %eax,%ecx
    ee2b:	0f 84 08 04 00 00    	je     f239 <rlc_AM_reassemble_deliver+0x709>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    ee31:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ee34:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    ee3b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ee3e:	e8 fc ff ff ff       	call   ee3f <rlc_AM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    ee43:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ee46:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    ee4a:	8b 06                	mov    (%esi),%eax
    ee4c:	e8 fc ff ff ff       	call   ee4d <rlc_AM_reassemble_deliver+0x31d>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ee51:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    ee55:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    ee57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ee5e:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ee62:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    ee65:	89 5d cc             	mov    %ebx,-0x34(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    ee68:	7f 47                	jg     eeb1 <rlc_AM_reassemble_deliver+0x381>
    ee6a:	e9 ab 00 00 00       	jmp    ef1a <rlc_AM_reassemble_deliver+0x3ea>
    ee6f:	90                   	nop
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ee70:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ee76:	b9 02 00 00 00       	mov    $0x2,%ecx
    ee7b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ee7e:	e8 fc ff ff ff       	call   ee7f <rlc_AM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ee83:	89 d8                	mov    %ebx,%eax
    ee85:	ba 06 00 00 00       	mov    $0x6,%edx
    ee8a:	e8 fc ff ff ff       	call   ee8b <rlc_AM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ee8f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ee92:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    ee99:	c7 04 24 24 3a 00 00 	movl   $0x3a24,(%esp)
    eea0:	e8 fc ff ff ff       	call   eea1 <rlc_AM_reassemble_deliver+0x371>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    eea5:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    eea8:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    eeac:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    eeaf:	74 67                	je     ef18 <rlc_AM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    eeb1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    eeb4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eeb7:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    eebc:	89 d8                	mov    %ebx,%eax
    eebe:	e8 fc ff ff ff       	call   eebf <rlc_AM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    eec3:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1;  j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    eec5:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    eec7:	e8 fc ff ff ff       	call   eec8 <rlc_AM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    eecc:	8b 07                	mov    (%edi),%eax
    eece:	89 da                	mov    %ebx,%edx
    eed0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    eed6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    eed9:	89 f0                	mov    %esi,%eax
    eedb:	e8 fc ff ff ff       	call   eedc <rlc_AM_reassemble_deliver+0x3ac>
    eee0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    eee3:	89 d9                	mov    %ebx,%ecx
    eee5:	e8 fc ff ff ff       	call   eee6 <rlc_AM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    eeea:	8b 07                	mov    (%edi),%eax
    eeec:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    eeee:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    eef0:	e8 fc ff ff ff       	call   eef1 <rlc_AM_reassemble_deliver+0x3c1>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    eef5:	89 f0                	mov    %esi,%eax
    eef7:	e8 fc ff ff ff       	call   eef8 <rlc_AM_reassemble_deliver+0x3c8>
    eefc:	83 f8 01             	cmp    $0x1,%eax
    eeff:	0f 87 6b ff ff ff    	ja     ee70 <rlc_AM_reassemble_deliver+0x340>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    ef05:	ba 02 00 00 00       	mov    $0x2,%edx
    ef0a:	89 f0                	mov    %esi,%eax
    ef0c:	e8 fc ff ff ff       	call   ef0d <rlc_AM_reassemble_deliver+0x3dd>
    ef11:	89 c3                	mov    %eax,%ebx
    ef13:	e9 58 ff ff ff       	jmp    ee70 <rlc_AM_reassemble_deliver+0x340>
    ef18:	89 fe                	mov    %edi,%esi
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    ef1a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    ef1d:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    ef1f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ef23:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    ef27:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    ef29:	0f 85 e1 00 00 00    	jne    f010 <rlc_AM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ef2f:	e8 fc ff ff ff       	call   ef30 <rlc_AM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    ef34:	89 da                	mov    %ebx,%edx
                }
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ef36:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    ef38:	e8 fc ff ff ff       	call   ef39 <rlc_AM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ef3d:	8b 06                	mov    (%esi),%eax
    ef3f:	89 da                	mov    %ebx,%edx
    ef41:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ef47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ef4a:	89 f8                	mov    %edi,%eax
    ef4c:	e8 fc ff ff ff       	call   ef4d <rlc_AM_reassemble_deliver+0x41d>
    ef51:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ef54:	89 d9                	mov    %ebx,%ecx
    ef56:	e8 fc ff ff ff       	call   ef57 <rlc_AM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    ef5b:	8b 06                	mov    (%esi),%eax
    ef5d:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    ef5f:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    ef61:	e8 fc ff ff ff       	call   ef62 <rlc_AM_reassemble_deliver+0x432>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ef66:	89 f8                	mov    %edi,%eax
    ef68:	e8 fc ff ff ff       	call   ef69 <rlc_AM_reassemble_deliver+0x439>
    ef6d:	83 f8 01             	cmp    $0x1,%eax
    ef70:	0f 86 9d 02 00 00    	jbe    f213 <rlc_AM_reassemble_deliver+0x6e3>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ef76:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ef79:	b9 02 00 00 00       	mov    $0x2,%ecx
    ef7e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ef84:	e8 fc ff ff ff       	call   ef85 <rlc_AM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ef89:	ba 06 00 00 00       	mov    $0x6,%edx
    ef8e:	89 d8                	mov    %ebx,%eax
    ef90:	e8 fc ff ff ff       	call   ef91 <rlc_AM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ef95:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ef98:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP6\n");
    ef9f:	c7 04 24 58 3a 00 00 	movl   $0x3a58,(%esp)
    efa6:	e8 fc ff ff ff       	call   efa7 <rlc_AM_reassemble_deliver+0x477>
					//fsm_octets_print(skb->data,64);

					//list_del(&tbuff->list);
					if(tbuff->pkt != NULL)
    efab:	8b 06                	mov    (%esi),%eax
    efad:	85 c0                	test   %eax,%eax
    efaf:	74 0b                	je     efbc <rlc_AM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
                    {
                    	fsm_pkt_destroy(tbuff->pkt);
    efb1:	e8 fc ff ff ff       	call   efb2 <rlc_AM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    efb6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					{
						fsm_mem_free(tbuff);
						tbuff = NULL;
					}*/
				}
				if(pPduhdrExt != NULL)
    efbc:	8b 5d d0             	mov    -0x30(%ebp),%ebx
    efbf:	85 db                	test   %ebx,%ebx
    efc1:	0f 84 1a fc ff ff    	je     ebe1 <rlc_AM_reassemble_deliver+0xb1>
				{
					fsm_mem_free(pPduhdrExt);
    efc7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    efca:	e8 fc ff ff ff       	call   efcb <rlc_AM_reassemble_deliver+0x49b>
    efcf:	e9 0d fc ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
    efd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			amIns->amRecvWindow[i]=NULL;
		}//end if
	}//end for
	FOUT;
}
    efd8:	83 c4 44             	add    $0x44,%esp
    efdb:	5b                   	pop    %ebx
    efdc:	5e                   	pop    %esi
    efdd:	5f                   	pop    %edi
    efde:	5d                   	pop    %ebp
    efdf:	c3                   	ret    
					//fsm_printf("[RLC][rlc_AM_reassemble_deliver] data len = %d\n", skb->len);
					//fsm_octets_print(skb->data,skb->len);
				}
				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    efe0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    efe3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    efe7:	0f b6 13             	movzbl (%ebx),%edx
    efea:	83 e0 03             	and    $0x3,%eax
    efed:	c1 e0 08             	shl    $0x8,%eax
    eff0:	09 d0                	or     %edx,%eax
    eff2:	8b 55 c0             	mov    -0x40(%ebp),%edx
    eff5:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = tbuff->pkt;
    eff9:	8b 06                	mov    (%esi),%eax
    effb:	89 42 04             	mov    %eax,0x4(%edx)
					/*list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    effe:	c7 04 24 50 39 00 00 	movl   $0x3950,(%esp)
    f005:	e8 fc ff ff ff       	call   f006 <rlc_AM_reassemble_deliver+0x4d6>
    f00a:	e9 d2 fb ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
    f00f:	90                   	nop
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f010:	e8 fc ff ff ff       	call   f011 <rlc_AM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f015:	89 da                	mov    %ebx,%edx
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f017:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f019:	e8 fc ff ff ff       	call   f01a <rlc_AM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f01e:	8b 06                	mov    (%esi),%eax
    f020:	89 da                	mov    %ebx,%edx
    f022:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f028:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f02b:	89 f8                	mov    %edi,%eax
    f02d:	e8 fc ff ff ff       	call   f02e <rlc_AM_reassemble_deliver+0x4fe>
    f032:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f035:	89 d9                	mov    %ebx,%ecx
    f037:	e8 fc ff ff ff       	call   f038 <rlc_AM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f03c:	8b 06                	mov    (%esi),%eax
    f03e:	8b 50 50             	mov    0x50(%eax),%edx
    f041:	e8 fc ff ff ff       	call   f042 <rlc_AM_reassemble_deliver+0x512>

					pdu_left->SN_Left = pduhdr->SN;
    f046:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f049:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f04d:	0f b6 13             	movzbl (%ebx),%edx
    f050:	83 e0 03             	and    $0x3,%eax
    f053:	c1 e0 08             	shl    $0x8,%eax
    f056:	09 d0                	or     %edx,%eax
    f058:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f05b:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f05f:	89 7a 04             	mov    %edi,0x4(%edx)
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
    f062:	8b 06                	mov    (%esi),%eax
    f064:	85 c0                	test   %eax,%eax
    f066:	0f 85 45 ff ff ff    	jne    efb1 <rlc_AM_reassemble_deliver+0x481>
    f06c:	e9 4b ff ff ff       	jmp    efbc <rlc_AM_reassemble_deliver+0x48c>
    f071:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f078:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f07b:	e8 fc ff ff ff       	call   f07c <rlc_AM_reassemble_deliver+0x54c>
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f080:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f083:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f087:	89 d8                	mov    %ebx,%eax
    f089:	e8 fc ff ff ff       	call   f08a <rlc_AM_reassemble_deliver+0x55a>

					fsm_skb_reserve(new_skb,length);
    f08e:	89 da                	mov    %ebx,%edx
				}
				else
				{
					clear_left_pdu(pdu_left);
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f090:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
    f092:	e8 fc ff ff ff       	call   f093 <rlc_AM_reassemble_deliver+0x563>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f097:	8b 06                	mov    (%esi),%eax
    f099:	89 da                	mov    %ebx,%edx
    f09b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f0a1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f0a4:	89 f8                	mov    %edi,%eax
    f0a6:	e8 fc ff ff ff       	call   f0a7 <rlc_AM_reassemble_deliver+0x577>
    f0ab:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f0ae:	89 d9                	mov    %ebx,%ecx
    f0b0:	e8 fc ff ff ff       	call   f0b1 <rlc_AM_reassemble_deliver+0x581>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f0b5:	8b 06                	mov    (%esi),%eax
    f0b7:	89 da                	mov    %ebx,%edx


					skb = new_skb;
    f0b9:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f0bb:	e8 fc ff ff ff       	call   f0bc <rlc_AM_reassemble_deliver+0x58c>


					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f0c0:	89 f8                	mov    %edi,%eax
    f0c2:	e8 fc ff ff ff       	call   f0c3 <rlc_AM_reassemble_deliver+0x593>
    f0c7:	83 f8 01             	cmp    $0x1,%eax
    f0ca:	0f 86 34 02 00 00    	jbe    f304 <rlc_AM_reassemble_deliver+0x7d4>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f0d0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f0d3:	b9 02 00 00 00       	mov    $0x2,%ecx
    f0d8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f0de:	e8 fc ff ff ff       	call   f0df <rlc_AM_reassemble_deliver+0x5af>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f0e3:	89 d8                	mov    %ebx,%eax
    f0e5:	ba 06 00 00 00       	mov    $0x6,%edx
    f0ea:	e8 fc ff ff ff       	call   f0eb <rlc_AM_reassemble_deliver+0x5bb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f0ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f0f2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP4\n");
    f0f9:	c7 04 24 f0 39 00 00 	movl   $0x39f0,(%esp)
    f100:	e8 fc ff ff ff       	call   f101 <rlc_AM_reassemble_deliver+0x5d1>
    f105:	e9 47 fd ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0x321>
    f10a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f110:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f113:	8b 16                	mov    (%esi),%edx
    f115:	8b 41 04             	mov    0x4(%ecx),%eax
    f118:	8b 40 50             	mov    0x50(%eax),%eax
    f11b:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f11f:	0f b7 d8             	movzwl %ax,%ebx
    f122:	89 d8                	mov    %ebx,%eax
    f124:	e8 fc ff ff ff       	call   f125 <rlc_AM_reassemble_deliver+0x5f5>
					fsm_skb_reserve(new_skb,length);
    f129:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f12b:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f12d:	e8 fc ff ff ff       	call   f12e <rlc_AM_reassemble_deliver+0x5fe>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f132:	8b 06                	mov    (%esi),%eax
    f134:	8b 58 50             	mov    0x50(%eax),%ebx
    f137:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f13d:	89 f8                	mov    %edi,%eax
    f13f:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f142:	89 da                	mov    %ebx,%edx
    f144:	e8 fc ff ff ff       	call   f145 <rlc_AM_reassemble_deliver+0x615>
    f149:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f14c:	89 d9                	mov    %ebx,%ecx
    f14e:	e8 fc ff ff ff       	call   f14f <rlc_AM_reassemble_deliver+0x61f>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f153:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f156:	8b 42 04             	mov    0x4(%edx),%eax
    f159:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f15f:	8b 58 50             	mov    0x50(%eax),%ebx
    f162:	89 f8                	mov    %edi,%eax
    f164:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f167:	89 da                	mov    %ebx,%edx
    f169:	e8 fc ff ff ff       	call   f16a <rlc_AM_reassemble_deliver+0x63a>
    f16e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f171:	89 d9                	mov    %ebx,%ecx
    f173:	e8 fc ff ff ff       	call   f174 <rlc_AM_reassemble_deliver+0x644>
					clear_left_pdu(pdu_left);
    f178:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f17b:	e8 fc ff ff ff       	call   f17c <rlc_AM_reassemble_deliver+0x64c>
					if(tbuff->pkt != NULL)
    f180:	8b 06                	mov    (%esi),%eax
    f182:	85 c0                	test   %eax,%eax
    f184:	74 0b                	je     f191 <rlc_AM_reassemble_deliver+0x661>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f186:	e8 fc ff ff ff       	call   f187 <rlc_AM_reassemble_deliver+0x657>
						tbuff->pkt = NULL;							
    f18b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f191:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f194:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f198:	75 4c                	jne    f1e6 <rlc_AM_reassemble_deliver+0x6b6>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f19a:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;							
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f19c:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f19e:	e8 fc ff ff ff       	call   f19f <rlc_AM_reassemble_deliver+0x66f>
    f1a3:	83 f8 01             	cmp    $0x1,%eax
    f1a6:	0f 86 6b 01 00 00    	jbe    f317 <rlc_AM_reassemble_deliver+0x7e7>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f1ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f1af:	b9 02 00 00 00       	mov    $0x2,%ecx
    f1b4:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f1ba:	e8 fc ff ff ff       	call   f1bb <rlc_AM_reassemble_deliver+0x68b>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f1bf:	89 d8                	mov    %ebx,%eax
    f1c1:	ba 06 00 00 00       	mov    $0x6,%edx
    f1c6:	e8 fc ff ff ff       	call   f1c7 <rlc_AM_reassemble_deliver+0x697>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f1cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f1ce:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP1\n");
    f1d5:	c7 04 24 1c 39 00 00 	movl   $0x391c,(%esp)
    f1dc:	e8 fc ff ff ff       	call   f1dd <rlc_AM_reassemble_deliver+0x6ad>
    f1e1:	e9 fb f9 ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
						//fsm_octets_print(skb->data,skb->len);
						//list_del(&tbuff->list);//20150123
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f1e6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f1e9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f1ed:	0f b6 13             	movzbl (%ebx),%edx
    f1f0:	83 e0 03             	and    $0x3,%eax
    f1f3:	c1 e0 08             	shl    $0x8,%eax
    f1f6:	09 d0                	or     %edx,%eax
    f1f8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f1fb:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    f1ff:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f202:	c7 04 24 50 39 00 00 	movl   $0x3950,(%esp)
    f209:	e8 fc ff ff ff       	call   f20a <rlc_AM_reassemble_deliver+0x6da>
    f20e:	e9 ce f9 ff ff       	jmp    ebe1 <rlc_AM_reassemble_deliver+0xb1>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f213:	ba 02 00 00 00       	mov    $0x2,%edx
    f218:	89 f8                	mov    %edi,%eax
    f21a:	e8 fc ff ff ff       	call   f21b <rlc_AM_reassemble_deliver+0x6eb>
    f21f:	89 c3                	mov    %eax,%ebx
    f221:	e9 50 fd ff ff       	jmp    ef76 <rlc_AM_reassemble_deliver+0x446>
				if(pduhdr->FIsecond==0)
				{
					skb = tbuff->pkt;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f226:	89 d8                	mov    %ebx,%eax
    f228:	ba 02 00 00 00       	mov    $0x2,%edx
    f22d:	e8 fc ff ff ff       	call   f22e <rlc_AM_reassemble_deliver+0x6fe>
    f232:	89 c3                	mov    %eax,%ebx
    f234:	e9 4e fb ff ff       	jmp    ed87 <rlc_AM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    f239:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f23c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    f23f:	8b 42 04             	mov    0x4(%edx),%eax
    f242:	8b 40 50             	mov    0x50(%eax),%eax
    f245:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    f249:	0f b7 d8             	movzwl %ax,%ebx
    f24c:	89 d8                	mov    %ebx,%eax
    f24e:	e8 fc ff ff ff       	call   f24f <rlc_AM_reassemble_deliver+0x71f>

						fsm_skb_reserve(new_skb,length);
    f253:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    f255:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
    f257:	e8 fc ff ff ff       	call   f258 <rlc_AM_reassemble_deliver+0x728>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    f25c:	8b 06                	mov    (%esi),%eax
    f25e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f264:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f267:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f26a:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f26e:	89 f8                	mov    %edi,%eax
    f270:	89 da                	mov    %ebx,%edx
    f272:	e8 fc ff ff ff       	call   f273 <rlc_AM_reassemble_deliver+0x743>
    f277:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f27a:	89 d9                	mov    %ebx,%ecx
    f27c:	e8 fc ff ff ff       	call   f27d <rlc_AM_reassemble_deliver+0x74d>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f281:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f284:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f288:	8b 06                	mov    (%esi),%eax
    f28a:	e8 fc ff ff ff       	call   f28b <rlc_AM_reassemble_deliver+0x75b>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f28f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f292:	8b 42 04             	mov    0x4(%edx),%eax
    f295:	8b 58 50             	mov    0x50(%eax),%ebx
    f298:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f29e:	89 f8                	mov    %edi,%eax
    f2a0:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f2a3:	89 da                	mov    %ebx,%edx
    f2a5:	e8 fc ff ff ff       	call   f2a6 <rlc_AM_reassemble_deliver+0x776>
    f2aa:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f2ad:	89 d9                	mov    %ebx,%ecx
						skb = new_skb;
    f2af:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f2b1:	e8 fc ff ff ff       	call   f2b2 <rlc_AM_reassemble_deliver+0x782>
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f2b6:	89 f8                	mov    %edi,%eax
    f2b8:	e8 fc ff ff ff       	call   f2b9 <rlc_AM_reassemble_deliver+0x789>
    f2bd:	83 f8 01             	cmp    $0x1,%eax
    f2c0:	76 68                	jbe    f32a <rlc_AM_reassemble_deliver+0x7fa>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f2c2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f2c5:	b9 02 00 00 00       	mov    $0x2,%ecx
    f2ca:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f2d0:	e8 fc ff ff ff       	call   f2d1 <rlc_AM_reassemble_deliver+0x7a1>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f2d5:	ba 06 00 00 00       	mov    $0x6,%edx
    f2da:	89 d8                	mov    %ebx,%eax
    f2dc:	e8 fc ff ff ff       	call   f2dd <rlc_AM_reassemble_deliver+0x7ad>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f2e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f2e4:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP3\n");
    f2eb:	c7 04 24 bc 39 00 00 	movl   $0x39bc,(%esp)
    f2f2:	e8 fc ff ff ff       	call   f2f3 <rlc_AM_reassemble_deliver+0x7c3>
						//fsm_octets_print(skb->data,64);
						clear_left_pdu(pdu_left);
    f2f7:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f2fa:	e8 fc ff ff ff       	call   f2fb <rlc_AM_reassemble_deliver+0x7cb>
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
               
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    f2ff:	e9 4d fb ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0x321>

					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f304:	ba 02 00 00 00       	mov    $0x2,%edx
    f309:	89 f8                	mov    %edi,%eax
    f30b:	e8 fc ff ff ff       	call   f30c <rlc_AM_reassemble_deliver+0x7dc>
    f310:	89 c3                	mov    %eax,%ebx
    f312:	e9 b9 fd ff ff       	jmp    f0d0 <rlc_AM_reassemble_deliver+0x5a0>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f317:	ba 02 00 00 00       	mov    $0x2,%edx
    f31c:	89 f8                	mov    %edi,%eax
    f31e:	e8 fc ff ff ff       	call   f31f <rlc_AM_reassemble_deliver+0x7ef>
    f323:	89 c3                	mov    %eax,%ebx
    f325:	e9 82 fe ff ff       	jmp    f1ac <rlc_AM_reassemble_deliver+0x67c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f32a:	ba 02 00 00 00       	mov    $0x2,%edx
    f32f:	89 f8                	mov    %edi,%eax
    f331:	e8 fc ff ff ff       	call   f332 <rlc_AM_reassemble_deliver+0x802>
    f336:	89 c3                	mov    %eax,%ebx
    f338:	eb 88                	jmp    f2c2 <rlc_AM_reassemble_deliver+0x792>
    f33a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f340 <rlc_UM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    f340:	55                   	push   %ebp
    f341:	89 e5                	mov    %esp,%ebp
    f343:	57                   	push   %edi
    f344:	56                   	push   %esi
    f345:	53                   	push   %ebx
    f346:	83 ec 44             	sub    $0x44,%esp
    f349:	e8 fc ff ff ff       	call   f34a <rlc_UM_reassemble_deliver+0xa>
    f34e:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f351:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
    f354:	c7 04 24 8c 3a 00 00 	movl   $0x3a8c,(%esp)
    f35b:	e8 fc ff ff ff       	call   f35c <rlc_UM_reassemble_deliver+0x1c>
	SV_PTR_GET(rlc_mac_sv);
    f360:	e8 fc ff ff ff       	call   f361 <rlc_UM_reassemble_deliver+0x21>
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f365:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f368:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
	SV_PTR_GET(rlc_mac_sv);
    f36b:	89 45 e0             	mov    %eax,-0x20(%ebp)
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f36e:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    f375:	83 c0 01             	add    $0x1,%eax
    f378:	89 c2                	mov    %eax,%edx
    f37a:	c1 fa 1f             	sar    $0x1f,%edx
    f37d:	c1 ea 16             	shr    $0x16,%edx
    f380:	01 d0                	add    %edx,%eax
    f382:	25 ff 03 00 00       	and    $0x3ff,%eax
    f387:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f389:	0f b7 c0             	movzwl %ax,%eax
    f38c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    f38f:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    f396:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f399:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    f39f:	89 d0                	mov    %edx,%eax
    f3a1:	c1 f8 1f             	sar    $0x1f,%eax
    f3a4:	c1 e8 16             	shr    $0x16,%eax
    f3a7:	01 c2                	add    %eax,%edx
    f3a9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    f3af:	29 c2                	sub    %eax,%edx
    f3b1:	85 d2                	test   %edx,%edx
    f3b3:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f3b6:	0f 8e 2c 04 00 00    	jle    f7e8 <rlc_UM_reassemble_deliver+0x4a8>
    f3bc:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    f3bf:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    f3c2:	e9 83 00 00 00       	jmp    f44a <rlc_UM_reassemble_deliver+0x10a>
    f3c7:	90                   	nop
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    f3c8:	84 c0                	test   %al,%al
    f3ca:	0f 84 a0 01 00 00    	je     f570 <rlc_UM_reassemble_deliver+0x230>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft=tbuff->pkt;
					fsm_printf("[RLC] Not a complet SDU\n");
				}
			}
			else if(pduhdr->E==1)
    f3d0:	83 e2 04             	and    $0x4,%edx
    f3d3:	0f 85 ff 01 00 00    	jne    f5d8 <rlc_UM_reassemble_deliver+0x298>
				{
					fsm_mem_free(pPduhdrExt);
					pPduhdrExt = NULL;
				}
			}
			if(tbuff != NULL)
    f3d9:	85 f6                	test   %esi,%esi
    f3db:	74 20                	je     f3fd <rlc_UM_reassemble_deliver+0xbd>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    f3dd:	8b 46 14             	mov    0x14(%esi),%eax
    f3e0:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    f3e3:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    f3e6:	89 10                	mov    %edx,(%eax)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    f3e8:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    f3ea:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    f3f1:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    f3f8:	e8 fc ff ff ff       	call   f3f9 <rlc_UM_reassemble_deliver+0xb9>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    f3fd:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    f400:	85 f6                	test   %esi,%esi
    f402:	74 08                	je     f40c <rlc_UM_reassemble_deliver+0xcc>
			{
				fsm_mem_free(icimsg);
    f404:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f407:	e8 fc ff ff ff       	call   f408 <rlc_UM_reassemble_deliver+0xc8>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    f40c:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f40f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f412:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
    f419:	00 
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f41a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f41e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    f425:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f428:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f42b:	05 00 04 00 00       	add    $0x400,%eax
    f430:	89 c2                	mov    %eax,%edx
    f432:	c1 fa 1f             	sar    $0x1f,%edx
    f435:	c1 ea 16             	shr    $0x16,%edx
    f438:	01 d0                	add    %edx,%eax
    f43a:	25 ff 03 00 00       	and    $0x3ff,%eax
    f43f:	29 d0                	sub    %edx,%eax
    f441:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    f444:	0f 8d 9e 03 00 00    	jge    f7e8 <rlc_UM_reassemble_deliver+0x4a8>
	{
		if(umIns->umRecvWindow10[i] != NULL)
    f44a:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f44d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f450:	83 c3 2c             	add    $0x2c,%ebx
    f453:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
    f457:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    f45a:	85 c0                	test   %eax,%eax
    f45c:	74 bc                	je     f41a <rlc_UM_reassemble_deliver+0xda>
		{
			fsm_printf("[RLC]  umIns->umRecvWindow10[i] != NULL, i = %d\n",i);
    f45e:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f461:	c7 04 24 b4 3a 00 00 	movl   $0x3ab4,(%esp)
    f468:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    f46c:	e8 fc ff ff ff       	call   f46d <rlc_UM_reassemble_deliver+0x12d>
			tbuff = umIns->umRecvWindow10[i];
    f471:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f474:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f477:	8b 74 98 08          	mov    0x8(%eax,%ebx,4),%esi
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    f47b:	8b 06                	mov    (%esi),%eax
    f47d:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    f483:	b8 02 00 00 00       	mov    $0x2,%eax
    f488:	e8 fc ff ff ff       	call   f489 <rlc_UM_reassemble_deliver+0x149>
    f48d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    f490:	8b 43 02             	mov    0x2(%ebx),%eax
    f493:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f496:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    f498:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    f49c:	88 42 01             	mov    %al,0x1(%edx)
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f49f:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f4a1:	ba 02 00 00 00       	mov    $0x2,%edx
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f4a6:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    f4ac:	89 5d e8             	mov    %ebx,-0x18(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f4af:	e8 fc ff ff ff       	call   f4b0 <rlc_UM_reassemble_deliver+0x170>
			//get_UmPduhead(umIns->umRecvWindow10[i],pduhdr) ;
			fsm_octets_print(pduhdr,2);
    f4b4:	ba 02 00 00 00       	mov    $0x2,%edx
    f4b9:	89 d8                	mov    %ebx,%eax
    f4bb:	e8 fc ff ff ff       	call   f4bc <rlc_UM_reassemble_deliver+0x17c>
          	fsm_printf("[RLC][rlc_UM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    f4c0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f4c4:	c0 e8 03             	shr    $0x3,%al
    f4c7:	83 e0 01             	and    $0x1,%eax
    f4ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f4ce:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f4d2:	c0 e8 04             	shr    $0x4,%al
    f4d5:	83 e0 01             	and    $0x1,%eax
    f4d8:	89 44 24 08          	mov    %eax,0x8(%esp)
    f4dc:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f4e0:	c7 04 24 e8 3a 00 00 	movl   $0x3ae8,(%esp)
    f4e7:	c0 e8 02             	shr    $0x2,%al
    f4ea:	83 e0 01             	and    $0x1,%eax
    f4ed:	89 44 24 04          	mov    %eax,0x4(%esp)
    f4f1:	e8 fc ff ff ff       	call   f4f2 <rlc_UM_reassemble_deliver+0x1b2>
			
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    f4f6:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    f4fa:	89 d0                	mov    %edx,%eax
    f4fc:	83 e0 14             	and    $0x14,%eax
    f4ff:	3c 10                	cmp    $0x10,%al
    f501:	0f 85 c1 fe ff ff    	jne    f3c8 <rlc_UM_reassemble_deliver+0x88>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f507:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f50a:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    f50e:	66 83 f9 ff          	cmp    $0xffff,%cx
    f512:	74 2f                	je     f543 <rlc_UM_reassemble_deliver+0x203>
    f514:	0f bf c9             	movswl %cx,%ecx
    f517:	0f b6 13             	movzbl (%ebx),%edx
    f51a:	83 c1 01             	add    $0x1,%ecx
    f51d:	89 c8                	mov    %ecx,%eax
    f51f:	c1 f8 1f             	sar    $0x1f,%eax
    f522:	c1 e8 16             	shr    $0x16,%eax
    f525:	01 c1                	add    %eax,%ecx
    f527:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f52d:	29 c1                	sub    %eax,%ecx
    f52f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f533:	83 e0 03             	and    $0x3,%eax
    f536:	c1 e0 08             	shl    $0x8,%eax
    f539:	09 d0                	or     %edx,%eax
    f53b:	39 c1                	cmp    %eax,%ecx
    f53d:	0f 84 e5 03 00 00    	je     f928 <rlc_UM_reassemble_deliver+0x5e8>
						fsm_printf("[RLC] Not a complet SDU\n");
					}
				}
				else
				{
					SV(countDropPacket)++;
    f543:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f546:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    f54d:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f550:	e8 fc ff ff ff       	call   f551 <rlc_UM_reassemble_deliver+0x211>
					if(tbuff->pkt != NULL)
    f555:	8b 06                	mov    (%esi),%eax
    f557:	85 c0                	test   %eax,%eax
    f559:	0f 84 7a fe ff ff    	je     f3d9 <rlc_UM_reassemble_deliver+0x99>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f55f:	e8 fc ff ff ff       	call   f560 <rlc_UM_reassemble_deliver+0x220>
						tbuff->pkt = NULL;
    f564:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    f56a:	e9 6a fe ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
    f56f:	90                   	nop
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    f570:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f573:	e8 fc ff ff ff       	call   f574 <rlc_UM_reassemble_deliver+0x234>

				if(pduhdr->FIsecond==0)
    f578:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f57b:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f57f:	0f 85 6b 02 00 00    	jne    f7f0 <rlc_UM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    f585:	8b 1e                	mov    (%esi),%ebx
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f587:	89 d8                	mov    %ebx,%eax
    f589:	e8 fc ff ff ff       	call   f58a <rlc_UM_reassemble_deliver+0x24a>
    f58e:	83 f8 01             	cmp    $0x1,%eax
    f591:	0f 86 a7 04 00 00    	jbe    fa3e <rlc_UM_reassemble_deliver+0x6fe>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f597:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f59a:	b9 02 00 00 00       	mov    $0x2,%ecx
    f59f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f5a5:	e8 fc ff ff ff       	call   f5a6 <rlc_UM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f5aa:	89 d8                	mov    %ebx,%eax
    f5ac:	ba 06 00 00 00       	mov    $0x6,%edx
    f5b1:	e8 fc ff ff ff       	call   f5b2 <rlc_UM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f5b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f5b9:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
    f5c0:	c7 04 24 74 3b 00 00 	movl   $0x3b74,(%esp)
    f5c7:	e8 fc ff ff ff       	call   f5c8 <rlc_UM_reassemble_deliver+0x288>
    f5cc:	e9 08 fe ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
    f5d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f5d8:	b8 40 00 00 00       	mov    $0x40,%eax
    f5dd:	e8 fc ff ff ff       	call   f5de <rlc_UM_reassemble_deliver+0x29e>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f5e2:	31 c9                	xor    %ecx,%ecx
    f5e4:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f5e6:	89 45 d0             	mov    %eax,-0x30(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f5e9:	89 04 24             	mov    %eax,(%esp)
    f5ec:	b8 01 00 00 00       	mov    $0x1,%eax
    f5f1:	e8 fc ff ff ff       	call   f5f2 <rlc_UM_reassemble_deliver+0x2b2>
                
				if(pduhdr->FIfirst==1)
    f5f6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f5f9:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
                
				if(pduhdr->FIfirst==1)
    f5fd:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    f601:	0f 84 89 02 00 00    	je     f890 <rlc_UM_reassemble_deliver+0x550>
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f607:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f60a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    f60e:	66 83 f8 ff          	cmp    $0xffff,%ax
    f612:	74 2d                	je     f641 <rlc_UM_reassemble_deliver+0x301>
    f614:	98                   	cwtl   
    f615:	0f b6 13             	movzbl (%ebx),%edx
    f618:	8d 48 01             	lea    0x1(%eax),%ecx
    f61b:	89 c8                	mov    %ecx,%eax
    f61d:	c1 f8 1f             	sar    $0x1f,%eax
    f620:	c1 e8 16             	shr    $0x16,%eax
    f623:	01 c1                	add    %eax,%ecx
    f625:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f62b:	29 c1                	sub    %eax,%ecx
    f62d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f631:	83 e0 03             	and    $0x3,%eax
    f634:	c1 e0 08             	shl    $0x8,%eax
    f637:	09 d0                	or     %edx,%eax
    f639:	39 c1                	cmp    %eax,%ecx
    f63b:	0f 84 10 04 00 00    	je     fa51 <rlc_UM_reassemble_deliver+0x711>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    f641:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f644:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    f64b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f64e:	e8 fc ff ff ff       	call   f64f <rlc_UM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f653:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f656:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f65a:	8b 06                	mov    (%esi),%eax
    f65c:	e8 fc ff ff ff       	call   f65d <rlc_UM_reassemble_deliver+0x31d>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f661:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    f665:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f667:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f66e:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f672:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f675:	89 5d cc             	mov    %ebx,-0x34(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f678:	7f 47                	jg     f6c1 <rlc_UM_reassemble_deliver+0x381>
    f67a:	e9 ab 00 00 00       	jmp    f72a <rlc_UM_reassemble_deliver+0x3ea>
    f67f:	90                   	nop
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f680:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f686:	b9 02 00 00 00       	mov    $0x2,%ecx
    f68b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f68e:	e8 fc ff ff ff       	call   f68f <rlc_UM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f693:	89 d8                	mov    %ebx,%eax
    f695:	ba 06 00 00 00       	mov    $0x6,%edx
    f69a:	e8 fc ff ff ff       	call   f69b <rlc_UM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f69f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f6a2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f6a9:	c7 04 24 10 3c 00 00 	movl   $0x3c10,(%esp)
    f6b0:	e8 fc ff ff ff       	call   f6b1 <rlc_UM_reassemble_deliver+0x371>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f6b5:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f6b8:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f6bc:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f6bf:	74 67                	je     f728 <rlc_UM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f6c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f6c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f6c7:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f6cc:	89 d8                	mov    %ebx,%eax
    f6ce:	e8 fc ff ff ff       	call   f6cf <rlc_UM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f6d3:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f6d5:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f6d7:	e8 fc ff ff ff       	call   f6d8 <rlc_UM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f6dc:	8b 07                	mov    (%edi),%eax
    f6de:	89 da                	mov    %ebx,%edx
    f6e0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f6e6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f6e9:	89 f0                	mov    %esi,%eax
    f6eb:	e8 fc ff ff ff       	call   f6ec <rlc_UM_reassemble_deliver+0x3ac>
    f6f0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f6f3:	89 d9                	mov    %ebx,%ecx
    f6f5:	e8 fc ff ff ff       	call   f6f6 <rlc_UM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f6fa:	8b 07                	mov    (%edi),%eax
    f6fc:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f6fe:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f700:	e8 fc ff ff ff       	call   f701 <rlc_UM_reassemble_deliver+0x3c1>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f705:	89 f0                	mov    %esi,%eax
    f707:	e8 fc ff ff ff       	call   f708 <rlc_UM_reassemble_deliver+0x3c8>
    f70c:	83 f8 01             	cmp    $0x1,%eax
    f70f:	0f 87 6b ff ff ff    	ja     f680 <rlc_UM_reassemble_deliver+0x340>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f715:	ba 02 00 00 00       	mov    $0x2,%edx
    f71a:	89 f0                	mov    %esi,%eax
    f71c:	e8 fc ff ff ff       	call   f71d <rlc_UM_reassemble_deliver+0x3dd>
    f721:	89 c3                	mov    %eax,%ebx
    f723:	e9 58 ff ff ff       	jmp    f680 <rlc_UM_reassemble_deliver+0x340>
    f728:	89 fe                	mov    %edi,%esi
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f72a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f72d:	8b 06                	mov    (%esi),%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f72f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f733:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f737:	89 d8                	mov    %ebx,%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f739:	0f 85 e1 00 00 00    	jne    f820 <rlc_UM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f73f:	e8 fc ff ff ff       	call   f740 <rlc_UM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f744:	89 da                	mov    %ebx,%edx
				}
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f746:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f748:	e8 fc ff ff ff       	call   f749 <rlc_UM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f74d:	8b 06                	mov    (%esi),%eax
    f74f:	89 da                	mov    %ebx,%edx
    f751:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f757:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f75a:	89 f8                	mov    %edi,%eax
    f75c:	e8 fc ff ff ff       	call   f75d <rlc_UM_reassemble_deliver+0x41d>
    f761:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f764:	89 d9                	mov    %ebx,%ecx
    f766:	e8 fc ff ff ff       	call   f767 <rlc_UM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f76b:	8b 06                	mov    (%esi),%eax
    f76d:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    f76f:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f771:	e8 fc ff ff ff       	call   f772 <rlc_UM_reassemble_deliver+0x432>
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f776:	89 f8                	mov    %edi,%eax
    f778:	e8 fc ff ff ff       	call   f779 <rlc_UM_reassemble_deliver+0x439>
    f77d:	83 f8 01             	cmp    $0x1,%eax
    f780:	0f 86 a5 02 00 00    	jbe    fa2b <rlc_UM_reassemble_deliver+0x6eb>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f786:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f789:	b9 02 00 00 00       	mov    $0x2,%ecx
    f78e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f794:	e8 fc ff ff ff       	call   f795 <rlc_UM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f799:	ba 06 00 00 00       	mov    $0x6,%edx
    f79e:	89 d8                	mov    %ebx,%eax
    f7a0:	e8 fc ff ff ff       	call   f7a1 <rlc_UM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f7a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f7a8:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP6\n");				
    f7af:	c7 04 24 44 3c 00 00 	movl   $0x3c44,(%esp)
    f7b6:	e8 fc ff ff ff       	call   f7b7 <rlc_UM_reassemble_deliver+0x477>
					if(tbuff->pkt != NULL)
    f7bb:	8b 06                	mov    (%esi),%eax
    f7bd:	85 c0                	test   %eax,%eax
    f7bf:	74 0b                	je     f7cc <rlc_UM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					fsm_printf("[RLC]Not a complet SDU\n");
					if(tbuff->pkt != NULL)
					{
						fsm_pkt_destroy(tbuff->pkt);
    f7c1:	e8 fc ff ff ff       	call   f7c2 <rlc_UM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    f7c6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
				}
				if(pPduhdrExt != NULL)
    f7cc:	8b 7d d0             	mov    -0x30(%ebp),%edi
    f7cf:	85 ff                	test   %edi,%edi
    f7d1:	0f 84 02 fc ff ff    	je     f3d9 <rlc_UM_reassemble_deliver+0x99>
				{
					fsm_mem_free(pPduhdrExt);
    f7d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f7da:	e8 fc ff ff ff       	call   f7db <rlc_UM_reassemble_deliver+0x49b>
    f7df:	e9 f5 fb ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
    f7e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			umIns->umRecvWindow10[i]=NULL;
			
		}//end if
	}//end for
}
    f7e8:	83 c4 44             	add    $0x44,%esp
    f7eb:	5b                   	pop    %ebx
    f7ec:	5e                   	pop    %esi
    f7ed:	5f                   	pop    %edi
    f7ee:	5d                   	pop    %ebp
    f7ef:	c3                   	ret    
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
				}

				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    f7f0:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f7f3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f7f7:	0f b6 13             	movzbl (%ebx),%edx
    f7fa:	83 e0 03             	and    $0x3,%eax
    f7fd:	c1 e0 08             	shl    $0x8,%eax
    f800:	09 d0                	or     %edx,%eax
    f802:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f805:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    f809:	8b 06                	mov    (%esi),%eax
    f80b:	89 42 04             	mov    %eax,0x4(%edx)
					fsm_printf("[RLC] Not a complet SDU\n");
    f80e:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    f815:	e8 fc ff ff ff       	call   f816 <rlc_UM_reassemble_deliver+0x4d6>
    f81a:	e9 ba fb ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
    f81f:	90                   	nop
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f820:	e8 fc ff ff ff       	call   f821 <rlc_UM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f825:	89 da                	mov    %ebx,%edx
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f827:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f829:	e8 fc ff ff ff       	call   f82a <rlc_UM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f82e:	8b 06                	mov    (%esi),%eax
    f830:	89 da                	mov    %ebx,%edx
    f832:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f838:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f83b:	89 f8                	mov    %edi,%eax
    f83d:	e8 fc ff ff ff       	call   f83e <rlc_UM_reassemble_deliver+0x4fe>
    f842:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f845:	89 d9                	mov    %ebx,%ecx
    f847:	e8 fc ff ff ff       	call   f848 <rlc_UM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f84c:	8b 06                	mov    (%esi),%eax
    f84e:	8b 50 50             	mov    0x50(%eax),%edx
    f851:	e8 fc ff ff ff       	call   f852 <rlc_UM_reassemble_deliver+0x512>
                   
					pdu_left->SN_Left = pduhdr->SN;
    f856:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f859:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f85d:	0f b6 13             	movzbl (%ebx),%edx
    f860:	83 e0 03             	and    $0x3,%eax
    f863:	c1 e0 08             	shl    $0x8,%eax
    f866:	09 d0                	or     %edx,%eax
    f868:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f86b:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f86f:	89 7a 04             	mov    %edi,0x4(%edx)
					fsm_printf("[RLC]Not a complet SDU\n");
    f872:	c7 04 24 d3 07 00 00 	movl   $0x7d3,(%esp)
    f879:	e8 fc ff ff ff       	call   f87a <rlc_UM_reassemble_deliver+0x53a>
					if(tbuff->pkt != NULL)
    f87e:	8b 06                	mov    (%esi),%eax
    f880:	85 c0                	test   %eax,%eax
    f882:	0f 85 39 ff ff ff    	jne    f7c1 <rlc_UM_reassemble_deliver+0x481>
    f888:	e9 3f ff ff ff       	jmp    f7cc <rlc_UM_reassemble_deliver+0x48c>
    f88d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f890:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f893:	e8 fc ff ff ff       	call   f894 <rlc_UM_reassemble_deliver+0x554>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f898:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f89b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f89f:	89 d8                	mov    %ebx,%eax
    f8a1:	e8 fc ff ff ff       	call   f8a2 <rlc_UM_reassemble_deliver+0x562>
					fsm_skb_reserve(new_skb,length);
    f8a6:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f8a8:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f8aa:	e8 fc ff ff ff       	call   f8ab <rlc_UM_reassemble_deliver+0x56b>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f8af:	8b 06                	mov    (%esi),%eax
    f8b1:	89 da                	mov    %ebx,%edx
    f8b3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f8b9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f8bc:	89 f8                	mov    %edi,%eax
    f8be:	e8 fc ff ff ff       	call   f8bf <rlc_UM_reassemble_deliver+0x57f>
    f8c3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f8c6:	89 d9                	mov    %ebx,%ecx
    f8c8:	e8 fc ff ff ff       	call   f8c9 <rlc_UM_reassemble_deliver+0x589>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f8cd:	8b 06                	mov    (%esi),%eax
    f8cf:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f8d1:	89 fb                	mov    %edi,%ebx

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f8d3:	e8 fc ff ff ff       	call   f8d4 <rlc_UM_reassemble_deliver+0x594>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f8d8:	89 f8                	mov    %edi,%eax
    f8da:	e8 fc ff ff ff       	call   f8db <rlc_UM_reassemble_deliver+0x59b>
    f8df:	83 f8 01             	cmp    $0x1,%eax
    f8e2:	0f 86 34 02 00 00    	jbe    fb1c <rlc_UM_reassemble_deliver+0x7dc>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f8e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f8eb:	b9 02 00 00 00       	mov    $0x2,%ecx
    f8f0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f8f6:	e8 fc ff ff ff       	call   f8f7 <rlc_UM_reassemble_deliver+0x5b7>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f8fb:	89 d8                	mov    %ebx,%eax
    f8fd:	ba 06 00 00 00       	mov    $0x6,%edx
    f902:	e8 fc ff ff ff       	call   f903 <rlc_UM_reassemble_deliver+0x5c3>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f907:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f90a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
    f911:	c7 04 24 dc 3b 00 00 	movl   $0x3bdc,(%esp)
    f918:	e8 fc ff ff ff       	call   f919 <rlc_UM_reassemble_deliver+0x5d9>
    f91d:	e9 3f fd ff ff       	jmp    f661 <rlc_UM_reassemble_deliver+0x321>
    f922:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f928:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f92b:	8b 16                	mov    (%esi),%edx
    f92d:	8b 41 04             	mov    0x4(%ecx),%eax
    f930:	8b 40 50             	mov    0x50(%eax),%eax
    f933:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f937:	0f b7 d8             	movzwl %ax,%ebx
    f93a:	89 d8                	mov    %ebx,%eax
    f93c:	e8 fc ff ff ff       	call   f93d <rlc_UM_reassemble_deliver+0x5fd>
					fsm_skb_reserve(new_skb,length);
    f941:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f943:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f945:	e8 fc ff ff ff       	call   f946 <rlc_UM_reassemble_deliver+0x606>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f94a:	8b 06                	mov    (%esi),%eax
    f94c:	8b 58 50             	mov    0x50(%eax),%ebx
    f94f:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f955:	89 f8                	mov    %edi,%eax
    f957:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f95a:	89 da                	mov    %ebx,%edx
    f95c:	e8 fc ff ff ff       	call   f95d <rlc_UM_reassemble_deliver+0x61d>
    f961:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f964:	89 d9                	mov    %ebx,%ecx
    f966:	e8 fc ff ff ff       	call   f967 <rlc_UM_reassemble_deliver+0x627>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f96b:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f96e:	8b 42 04             	mov    0x4(%edx),%eax
    f971:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f977:	8b 58 50             	mov    0x50(%eax),%ebx
    f97a:	89 f8                	mov    %edi,%eax
    f97c:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f97f:	89 da                	mov    %ebx,%edx
    f981:	e8 fc ff ff ff       	call   f982 <rlc_UM_reassemble_deliver+0x642>
    f986:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f989:	89 d9                	mov    %ebx,%ecx
    f98b:	e8 fc ff ff ff       	call   f98c <rlc_UM_reassemble_deliver+0x64c>
					clear_left_pdu(pdu_left);
    f990:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f993:	e8 fc ff ff ff       	call   f994 <rlc_UM_reassemble_deliver+0x654>
					if(tbuff->pkt != NULL)
    f998:	8b 06                	mov    (%esi),%eax
    f99a:	85 c0                	test   %eax,%eax
    f99c:	74 0b                	je     f9a9 <rlc_UM_reassemble_deliver+0x669>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f99e:	e8 fc ff ff ff       	call   f99f <rlc_UM_reassemble_deliver+0x65f>
						tbuff->pkt = NULL;
    f9a3:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f9a9:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f9ac:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f9b0:	75 4c                	jne    f9fe <rlc_UM_reassemble_deliver+0x6be>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f9b2:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f9b4:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f9b6:	e8 fc ff ff ff       	call   f9b7 <rlc_UM_reassemble_deliver+0x677>
    f9bb:	83 f8 01             	cmp    $0x1,%eax
    f9be:	0f 86 6b 01 00 00    	jbe    fb2f <rlc_UM_reassemble_deliver+0x7ef>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f9c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f9c7:	b9 02 00 00 00       	mov    $0x2,%ecx
    f9cc:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f9d2:	e8 fc ff ff ff       	call   f9d3 <rlc_UM_reassemble_deliver+0x693>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f9d7:	89 d8                	mov    %ebx,%eax
    f9d9:	ba 06 00 00 00       	mov    $0x6,%edx
    f9de:	e8 fc ff ff ff       	call   f9df <rlc_UM_reassemble_deliver+0x69f>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f9e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f9e6:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP1\n");
    f9ed:	c7 04 24 40 3b 00 00 	movl   $0x3b40,(%esp)
    f9f4:	e8 fc ff ff ff       	call   f9f5 <rlc_UM_reassemble_deliver+0x6b5>
    f9f9:	e9 db f9 ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f9fe:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fa01:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    fa05:	0f b6 13             	movzbl (%ebx),%edx
    fa08:	83 e0 03             	and    $0x3,%eax
    fa0b:	c1 e0 08             	shl    $0x8,%eax
    fa0e:	09 d0                	or     %edx,%eax
    fa10:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fa13:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    fa17:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC] Not a complet SDU\n");
    fa1a:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    fa21:	e8 fc ff ff ff       	call   fa22 <rlc_UM_reassemble_deliver+0x6e2>
    fa26:	e9 ae f9 ff ff       	jmp    f3d9 <rlc_UM_reassemble_deliver+0x99>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fa2b:	ba 02 00 00 00       	mov    $0x2,%edx
    fa30:	89 f8                	mov    %edi,%eax
    fa32:	e8 fc ff ff ff       	call   fa33 <rlc_UM_reassemble_deliver+0x6f3>
    fa37:	89 c3                	mov    %eax,%ebx
    fa39:	e9 48 fd ff ff       	jmp    f786 <rlc_UM_reassemble_deliver+0x446>
				{
					skb = tbuff->pkt;
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fa3e:	89 d8                	mov    %ebx,%eax
    fa40:	ba 02 00 00 00       	mov    $0x2,%edx
    fa45:	e8 fc ff ff ff       	call   fa46 <rlc_UM_reassemble_deliver+0x706>
    fa4a:	89 c3                	mov    %eax,%ebx
    fa4c:	e9 46 fb ff ff       	jmp    f597 <rlc_UM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    fa51:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fa54:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    fa57:	8b 42 04             	mov    0x4(%edx),%eax
    fa5a:	8b 40 50             	mov    0x50(%eax),%eax
    fa5d:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    fa61:	0f b7 d8             	movzwl %ax,%ebx
    fa64:	89 d8                	mov    %ebx,%eax
    fa66:	e8 fc ff ff ff       	call   fa67 <rlc_UM_reassemble_deliver+0x727>
						fsm_skb_reserve(new_skb,length);
    fa6b:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    fa6d:	89 c7                	mov    %eax,%edi
						fsm_skb_reserve(new_skb,length);
    fa6f:	e8 fc ff ff ff       	call   fa70 <rlc_UM_reassemble_deliver+0x730>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    fa74:	8b 06                	mov    (%esi),%eax
    fa76:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fa7c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    fa7f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fa82:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    fa86:	89 f8                	mov    %edi,%eax
    fa88:	89 da                	mov    %ebx,%edx
    fa8a:	e8 fc ff ff ff       	call   fa8b <rlc_UM_reassemble_deliver+0x74b>
    fa8f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa92:	89 d9                	mov    %ebx,%ecx
    fa94:	e8 fc ff ff ff       	call   fa95 <rlc_UM_reassemble_deliver+0x755>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fa99:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fa9c:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    faa0:	8b 06                	mov    (%esi),%eax
    faa2:	e8 fc ff ff ff       	call   faa3 <rlc_UM_reassemble_deliver+0x763>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    faa7:	8b 55 c0             	mov    -0x40(%ebp),%edx
    faaa:	8b 42 04             	mov    0x4(%edx),%eax
    faad:	8b 58 50             	mov    0x50(%eax),%ebx
    fab0:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fab6:	89 f8                	mov    %edi,%eax
    fab8:	89 55 d8             	mov    %edx,-0x28(%ebp)
    fabb:	89 da                	mov    %ebx,%edx
    fabd:	e8 fc ff ff ff       	call   fabe <rlc_UM_reassemble_deliver+0x77e>
    fac2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fac5:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
    fac7:	89 fb                	mov    %edi,%ebx
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fac9:	e8 fc ff ff ff       	call   faca <rlc_UM_reassemble_deliver+0x78a>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    face:	89 f8                	mov    %edi,%eax
    fad0:	e8 fc ff ff ff       	call   fad1 <rlc_UM_reassemble_deliver+0x791>
    fad5:	83 f8 01             	cmp    $0x1,%eax
    fad8:	76 68                	jbe    fb42 <rlc_UM_reassemble_deliver+0x802>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fada:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fadd:	b9 02 00 00 00       	mov    $0x2,%ecx
    fae2:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fae8:	e8 fc ff ff ff       	call   fae9 <rlc_UM_reassemble_deliver+0x7a9>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    faed:	ba 06 00 00 00       	mov    $0x6,%edx
    faf2:	89 d8                	mov    %ebx,%eax
    faf4:	e8 fc ff ff ff       	call   faf5 <rlc_UM_reassemble_deliver+0x7b5>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    faf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fafc:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP3\n");
    fb03:	c7 04 24 a8 3b 00 00 	movl   $0x3ba8,(%esp)
    fb0a:	e8 fc ff ff ff       	call   fb0b <rlc_UM_reassemble_deliver+0x7cb>
						
						clear_left_pdu(pdu_left);
    fb0f:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fb12:	e8 fc ff ff ff       	call   fb13 <rlc_UM_reassemble_deliver+0x7d3>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    fb17:	e9 45 fb ff ff       	jmp    f661 <rlc_UM_reassemble_deliver+0x321>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fb1c:	ba 02 00 00 00       	mov    $0x2,%edx
    fb21:	89 f8                	mov    %edi,%eax
    fb23:	e8 fc ff ff ff       	call   fb24 <rlc_UM_reassemble_deliver+0x7e4>
    fb28:	89 c3                	mov    %eax,%ebx
    fb2a:	e9 b9 fd ff ff       	jmp    f8e8 <rlc_UM_reassemble_deliver+0x5a8>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fb2f:	ba 02 00 00 00       	mov    $0x2,%edx
    fb34:	89 f8                	mov    %edi,%eax
    fb36:	e8 fc ff ff ff       	call   fb37 <rlc_UM_reassemble_deliver+0x7f7>
    fb3b:	89 c3                	mov    %eax,%ebx
    fb3d:	e9 82 fe ff ff       	jmp    f9c4 <rlc_UM_reassemble_deliver+0x684>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fb42:	ba 02 00 00 00       	mov    $0x2,%edx
    fb47:	89 f8                	mov    %edi,%eax
    fb49:	e8 fc ff ff ff       	call   fb4a <rlc_UM_reassemble_deliver+0x80a>
    fb4e:	89 c3                	mov    %eax,%ebx
    fb50:	eb 88                	jmp    fada <rlc_UM_reassemble_deliver+0x79a>
    fb52:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    fb59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000fb60 <rlc_UM5_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fb60:	55                   	push   %ebp
    fb61:	89 e5                	mov    %esp,%ebp
    fb63:	57                   	push   %edi
    fb64:	56                   	push   %esi
    fb65:	53                   	push   %ebx
    fb66:	83 ec 34             	sub    $0x34,%esp
    fb69:	e8 fc ff ff ff       	call   fb6a <rlc_UM5_reassemble_deliver+0xa>
    fb6e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    fb71:	89 45 d8             	mov    %eax,-0x28(%ebp)
	SV_PTR_GET(rlc_mac_sv);
    fb74:	e8 fc ff ff ff       	call   fb75 <rlc_UM5_reassemble_deliver+0x15>
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fb79:	8b 55 d8             	mov    -0x28(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fb7c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
	SV_PTR_GET(rlc_mac_sv);
    fb7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fb82:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    fb89:	83 c0 01             	add    $0x1,%eax
    fb8c:	89 c2                	mov    %eax,%edx
    fb8e:	c1 fa 1f             	sar    $0x1f,%edx
    fb91:	c1 ea 1b             	shr    $0x1b,%edx
    fb94:	01 d0                	add    %edx,%eax
    fb96:	83 e0 1f             	and    $0x1f,%eax
    fb99:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fb9b:	0f b7 c0             	movzwl %ax,%eax
    fb9e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    fba1:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    fba8:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fbab:	8d 50 20             	lea    0x20(%eax),%edx
    fbae:	89 d0                	mov    %edx,%eax
    fbb0:	c1 f8 1f             	sar    $0x1f,%eax
    fbb3:	c1 e8 1b             	shr    $0x1b,%eax
    fbb6:	01 c2                	add    %eax,%edx
    fbb8:	83 e2 1f             	and    $0x1f,%edx
    fbbb:	29 c2                	sub    %eax,%edx
    fbbd:	85 d2                	test   %edx,%edx
    fbbf:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fbc2:	0f 8e d8 03 00 00    	jle    ffa0 <rlc_UM5_reassemble_deliver+0x440>
    fbc8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fbcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fbce:	e9 8d 00 00 00       	jmp    fc60 <rlc_UM5_reassemble_deliver+0x100>
    fbd3:	90                   	nop
    fbd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    fbd8:	84 d2                	test   %dl,%dl
    fbda:	0f 84 38 01 00 00    	je     fd18 <rlc_UM5_reassemble_deliver+0x1b8>
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;
				}
			}
			else if(pduhdr->E==1)
    fbe0:	a8 20                	test   $0x20,%al
    fbe2:	0f 85 98 01 00 00    	jne    fd80 <rlc_UM5_reassemble_deliver+0x220>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    fbe8:	8b 46 14             	mov    0x14(%esi),%eax
    fbeb:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    fbee:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    fbf1:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    fbf3:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    fbf5:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    fbfc:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    fc03:	e8 fc ff ff ff       	call   fc04 <rlc_UM5_reassemble_deliver+0xa4>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    fc08:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc0b:	85 c0                	test   %eax,%eax
    fc0d:	74 08                	je     fc17 <rlc_UM5_reassemble_deliver+0xb7>
			{
				fsm_mem_free(icimsg);
    fc0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fc12:	e8 fc ff ff ff       	call   fc13 <rlc_UM5_reassemble_deliver+0xb3>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    fc17:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    fc1a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fc1d:	c7 84 88 b8 00 00 00 	movl   $0x0,0xb8(%eax,%ecx,4)
    fc24:	00 00 00 00 
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fc28:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fc2b:	83 c2 01             	add    $0x1,%edx
    fc2e:	89 d0                	mov    %edx,%eax
    fc30:	c1 f8 1f             	sar    $0x1f,%eax
    fc33:	c1 e8 1b             	shr    $0x1b,%eax
    fc36:	01 c2                	add    %eax,%edx
    fc38:	83 e2 1f             	and    $0x1f,%edx
    fc3b:	29 c2                	sub    %eax,%edx
    fc3d:	89 d0                	mov    %edx,%eax
    fc3f:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fc42:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fc45:	83 c0 20             	add    $0x20,%eax
    fc48:	89 c2                	mov    %eax,%edx
    fc4a:	c1 fa 1f             	sar    $0x1f,%edx
    fc4d:	c1 ea 1b             	shr    $0x1b,%edx
    fc50:	01 d0                	add    %edx,%eax
    fc52:	83 e0 1f             	and    $0x1f,%eax
    fc55:	29 d0                	sub    %edx,%eax
    fc57:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    fc5a:	0f 8d 40 03 00 00    	jge    ffa0 <rlc_UM5_reassemble_deliver+0x440>
	{
		if(umIns->umRecvWindow5[i] != NULL)
    fc60:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fc63:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fc66:	8b 74 90 38          	mov    0x38(%eax,%edx,4),%esi
    fc6a:	85 f6                	test   %esi,%esi
    fc6c:	74 ba                	je     fc28 <rlc_UM5_reassemble_deliver+0xc8>
		{

			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    fc6e:	8b 06                	mov    (%esi),%eax
    fc70:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    fc76:	b8 02 00 00 00       	mov    $0x2,%eax
    fc7b:	e8 fc ff ff ff       	call   fc7c <rlc_UM5_reassemble_deliver+0x11c>
    fc80:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    fc83:	8b 43 02             	mov    0x2(%ebx),%eax
    fc86:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fc89:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    fc8b:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    fc8f:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fc92:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fc94:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fc99:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
    fc9f:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fca2:	e8 fc ff ff ff       	call   fca3 <rlc_UM5_reassemble_deliver+0x143>
          
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    fca7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fcaa:	0f b6 02             	movzbl (%edx),%eax
    fcad:	89 c2                	mov    %eax,%edx
    fcaf:	83 e2 a0             	and    $0xffffffa0,%edx
    fcb2:	80 fa 80             	cmp    $0x80,%dl
    fcb5:	0f 85 1d ff ff ff    	jne    fbd8 <rlc_UM5_reassemble_deliver+0x78>
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
    fcbb:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    fcbe:	0f b7 11             	movzwl (%ecx),%edx
    fcc1:	66 83 fa ff          	cmp    $0xffff,%dx
    fcc5:	74 20                	je     fce7 <rlc_UM5_reassemble_deliver+0x187>
    fcc7:	0f bf d2             	movswl %dx,%edx
    fcca:	83 e0 1f             	and    $0x1f,%eax
    fccd:	83 c2 01             	add    $0x1,%edx
    fcd0:	89 d1                	mov    %edx,%ecx
    fcd2:	c1 f9 1f             	sar    $0x1f,%ecx
    fcd5:	c1 e9 1b             	shr    $0x1b,%ecx
    fcd8:	01 ca                	add    %ecx,%edx
    fcda:	83 e2 1f             	and    $0x1f,%edx
    fcdd:	29 ca                	sub    %ecx,%edx
    fcdf:	39 c2                	cmp    %eax,%edx
    fce1:	0f 84 c1 03 00 00    	je     100a8 <rlc_UM5_reassemble_deliver+0x548>
						pdu_left->sduLeft = new_skb;
					}
				}
				else
				{
					SV(countDropPacket)++;
    fce7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fcea:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    fcf1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fcf4:	e8 fc ff ff ff       	call   fcf5 <rlc_UM5_reassemble_deliver+0x195>
					if(tbuff->pkt != NULL)
    fcf9:	8b 06                	mov    (%esi),%eax
    fcfb:	85 c0                	test   %eax,%eax
    fcfd:	0f 84 e5 fe ff ff    	je     fbe8 <rlc_UM5_reassemble_deliver+0x88>
					{
						fsm_pkt_destroy(tbuff->pkt);
    fd03:	e8 fc ff ff ff       	call   fd04 <rlc_UM5_reassemble_deliver+0x1a4>
						tbuff->pkt = NULL;
    fd08:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    fd0e:	e9 d5 fe ff ff       	jmp    fbe8 <rlc_UM5_reassemble_deliver+0x88>
    fd13:	90                   	nop
    fd14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    fd18:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fd1b:	e8 fc ff ff ff       	call   fd1c <rlc_UM5_reassemble_deliver+0x1bc>

				if(pduhdr->FIsecond==0)
    fd20:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fd23:	0f b6 02             	movzbl (%edx),%eax
    fd26:	a8 40                	test   $0x40,%al
    fd28:	0f 85 7a 02 00 00    	jne    ffa8 <rlc_UM5_reassemble_deliver+0x448>
				{

					skb = tbuff->pkt;
    fd2e:	8b 1e                	mov    (%esi),%ebx
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fd30:	89 d8                	mov    %ebx,%eax
    fd32:	e8 fc ff ff ff       	call   fd33 <rlc_UM5_reassemble_deliver+0x1d3>
    fd37:	83 f8 01             	cmp    $0x1,%eax
    fd3a:	0f 86 35 04 00 00    	jbe    10175 <rlc_UM5_reassemble_deliver+0x615>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fd40:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fd43:	b9 02 00 00 00       	mov    $0x2,%ecx
    fd48:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fd4e:	e8 fc ff ff ff       	call   fd4f <rlc_UM5_reassemble_deliver+0x1ef>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fd53:	89 d8                	mov    %ebx,%eax
    fd55:	ba 06 00 00 00       	mov    $0x6,%edx
    fd5a:	e8 fc ff ff ff       	call   fd5b <rlc_UM5_reassemble_deliver+0x1fb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fd5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fd62:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fd69:	c7 04 24 78 3c 00 00 	movl   $0x3c78,(%esp)
    fd70:	e8 fc ff ff ff       	call   fd71 <rlc_UM5_reassemble_deliver+0x211>
    fd75:	e9 6e fe ff ff       	jmp    fbe8 <rlc_UM5_reassemble_deliver+0x88>
    fd7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fd80:	b8 40 00 00 00       	mov    $0x40,%eax
    fd85:	e8 fc ff ff ff       	call   fd86 <rlc_UM5_reassemble_deliver+0x226>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fd8a:	31 c9                	xor    %ecx,%ecx
    fd8c:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fd8e:	89 45 dc             	mov    %eax,-0x24(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fd91:	89 04 24             	mov    %eax,(%esp)
    fd94:	b8 01 00 00 00       	mov    $0x1,%eax
    fd99:	e8 fc ff ff ff       	call   fd9a <rlc_UM5_reassemble_deliver+0x23a>
    fd9e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
                
				if(pduhdr->FIfirst==1)
    fda2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fda5:	0f b6 08             	movzbl (%eax),%ecx
    fda8:	84 c9                	test   %cl,%cl
    fdaa:	0f 89 60 02 00 00    	jns    10010 <rlc_UM5_reassemble_deliver+0x4b0>
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
    fdb0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    fdb3:	0f b7 02             	movzwl (%edx),%eax
    fdb6:	66 83 f8 ff          	cmp    $0xffff,%ax
    fdba:	74 20                	je     fddc <rlc_UM5_reassemble_deliver+0x27c>
    fdbc:	98                   	cwtl   
    fdbd:	83 e1 1f             	and    $0x1f,%ecx
    fdc0:	83 c0 01             	add    $0x1,%eax
    fdc3:	89 c2                	mov    %eax,%edx
    fdc5:	c1 fa 1f             	sar    $0x1f,%edx
    fdc8:	c1 ea 17             	shr    $0x17,%edx
    fdcb:	01 d0                	add    %edx,%eax
    fdcd:	25 ff 01 00 00       	and    $0x1ff,%eax
    fdd2:	29 d0                	sub    %edx,%eax
    fdd4:	39 c8                	cmp    %ecx,%eax
    fdd6:	0f 84 ac 03 00 00    	je     10188 <rlc_UM5_reassemble_deliver+0x628>
						clear_left_pdu(pdu_left);
                        
					}
					else
					{
						SV(countDropPacket)++;
    fddc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fddf:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    fde6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fde9:	e8 fc ff ff ff       	call   fdea <rlc_UM5_reassemble_deliver+0x28a>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fdee:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fdf1:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    fdf5:	8b 06                	mov    (%esi),%eax
    fdf7:	e8 fc ff ff ff       	call   fdf8 <rlc_UM5_reassemble_deliver+0x298>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fdfc:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    fe00:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    fe02:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    fe09:	8d 54 00 fe          	lea    -0x2(%eax,%eax,1),%edx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fe0d:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    fe10:	89 55 d0             	mov    %edx,-0x30(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fe13:	7f 4c                	jg     fe61 <rlc_UM5_reassemble_deliver+0x301>
    fe15:	e9 b0 00 00 00       	jmp    feca <rlc_UM5_reassemble_deliver+0x36a>
    fe1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fe20:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fe23:	b9 02 00 00 00       	mov    $0x2,%ecx
    fe28:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fe2e:	e8 fc ff ff ff       	call   fe2f <rlc_UM5_reassemble_deliver+0x2cf>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fe33:	ba 06 00 00 00       	mov    $0x6,%edx
    fe38:	89 d8                	mov    %ebx,%eax
    fe3a:	e8 fc ff ff ff       	call   fe3b <rlc_UM5_reassemble_deliver+0x2db>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fe3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fe42:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fe49:	c7 04 24 78 3c 00 00 	movl   $0x3c78,(%esp)
    fe50:	e8 fc ff ff ff       	call   fe51 <rlc_UM5_reassemble_deliver+0x2f1>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fe55:	8b 55 d0             	mov    -0x30(%ebp),%edx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fe58:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    fe5c:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    fe5f:	74 67                	je     fec8 <rlc_UM5_reassemble_deliver+0x368>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe61:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe64:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fe67:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    fe6c:	89 d8                	mov    %ebx,%eax
    fe6e:	e8 fc ff ff ff       	call   fe6f <rlc_UM5_reassemble_deliver+0x30f>

					fsm_skb_reserve(new_skb,length);
    fe73:	89 da                	mov    %ebx,%edx
                
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fe75:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    fe77:	e8 fc ff ff ff       	call   fe78 <rlc_UM5_reassemble_deliver+0x318>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fe7c:	8b 07                	mov    (%edi),%eax
    fe7e:	89 da                	mov    %ebx,%edx
    fe80:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fe86:	89 45 e0             	mov    %eax,-0x20(%ebp)
    fe89:	89 f0                	mov    %esi,%eax
    fe8b:	e8 fc ff ff ff       	call   fe8c <rlc_UM5_reassemble_deliver+0x32c>
    fe90:	8b 55 e0             	mov    -0x20(%ebp),%edx
    fe93:	89 d9                	mov    %ebx,%ecx
    fe95:	e8 fc ff ff ff       	call   fe96 <rlc_UM5_reassemble_deliver+0x336>
					fsm_skb_pull(tbuff->pkt,length ) ;
    fe9a:	8b 07                	mov    (%edi),%eax
    fe9c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    fe9e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    fea0:	e8 fc ff ff ff       	call   fea1 <rlc_UM5_reassemble_deliver+0x341>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fea5:	89 f0                	mov    %esi,%eax
    fea7:	e8 fc ff ff ff       	call   fea8 <rlc_UM5_reassemble_deliver+0x348>
    feac:	83 f8 01             	cmp    $0x1,%eax
    feaf:	0f 87 6b ff ff ff    	ja     fe20 <rlc_UM5_reassemble_deliver+0x2c0>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    feb5:	ba 02 00 00 00       	mov    $0x2,%edx
    feba:	89 f0                	mov    %esi,%eax
    febc:	e8 fc ff ff ff       	call   febd <rlc_UM5_reassemble_deliver+0x35d>
    fec1:	89 c3                	mov    %eax,%ebx
    fec3:	e9 58 ff ff ff       	jmp    fe20 <rlc_UM5_reassemble_deliver+0x2c0>
    fec8:	89 fe                	mov    %edi,%esi
                    
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
    feca:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fecc:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fecf:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fed3:	f6 01 40             	testb  $0x40,(%ecx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fed6:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
    fed8:	0f 85 e2 00 00 00    	jne    ffc0 <rlc_UM5_reassemble_deliver+0x460>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fede:	e8 fc ff ff ff       	call   fedf <rlc_UM5_reassemble_deliver+0x37f>
					fsm_skb_reserve(new_skb,length);
    fee3:	89 da                	mov    %ebx,%edx
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fee5:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fee7:	e8 fc ff ff ff       	call   fee8 <rlc_UM5_reassemble_deliver+0x388>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    feec:	8b 06                	mov    (%esi),%eax
    feee:	89 da                	mov    %ebx,%edx
    fef0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fef6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fef9:	89 f8                	mov    %edi,%eax
    fefb:	e8 fc ff ff ff       	call   fefc <rlc_UM5_reassemble_deliver+0x39c>
    ff00:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ff03:	89 d9                	mov    %ebx,%ecx
    ff05:	e8 fc ff ff ff       	call   ff06 <rlc_UM5_reassemble_deliver+0x3a6>
					fsm_skb_pull(tbuff->pkt,length) ;
    ff0a:	8b 06                	mov    (%esi),%eax
    ff0c:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    ff0e:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    ff10:	e8 fc ff ff ff       	call   ff11 <rlc_UM5_reassemble_deliver+0x3b1>
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ff15:	89 f8                	mov    %edi,%eax
    ff17:	e8 fc ff ff ff       	call   ff18 <rlc_UM5_reassemble_deliver+0x3b8>
    ff1c:	83 f8 01             	cmp    $0x1,%eax
    ff1f:	0f 86 1f 02 00 00    	jbe    10144 <rlc_UM5_reassemble_deliver+0x5e4>
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
			    	}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ff25:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ff28:	b9 02 00 00 00       	mov    $0x2,%ecx
    ff2d:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ff33:	e8 fc ff ff ff       	call   ff34 <rlc_UM5_reassemble_deliver+0x3d4>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ff38:	89 d8                	mov    %ebx,%eax
    ff3a:	ba 06 00 00 00       	mov    $0x6,%edx
    ff3f:	e8 fc ff ff ff       	call   ff40 <rlc_UM5_reassemble_deliver+0x3e0>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ff44:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ff47:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");                  
    ff4e:	c7 04 24 78 3c 00 00 	movl   $0x3c78,(%esp)
    ff55:	e8 fc ff ff ff       	call   ff56 <rlc_UM5_reassemble_deliver+0x3f6>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ff5a:	8b 56 10             	mov    0x10(%esi),%edx
    ff5d:	8b 46 14             	mov    0x14(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ff60:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ff63:	89 10                	mov    %edx,(%eax)
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
    ff65:	8b 06                	mov    (%esi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ff67:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    ff6e:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    ff75:	e8 fc ff ff ff       	call   ff76 <rlc_UM5_reassemble_deliver+0x416>
					tbuff->pkt = NULL;
					fsm_mem_free(tbuff);
    ff7a:	89 f0                	mov    %esi,%eax
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
					tbuff->pkt = NULL;
    ff7c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(tbuff);
    ff82:	e8 fc ff ff ff       	call   ff83 <rlc_UM5_reassemble_deliver+0x423>
					tbuff = NULL;
				}
				if(pPduhdrExt != NULL)
    ff87:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff8a:	85 c0                	test   %eax,%eax
    ff8c:	0f 84 76 fc ff ff    	je     fc08 <rlc_UM5_reassemble_deliver+0xa8>
				{
					fsm_mem_free(pPduhdrExt);
    ff92:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff95:	e8 fc ff ff ff       	call   ff96 <rlc_UM5_reassemble_deliver+0x436>
    ff9a:	e9 69 fc ff ff       	jmp    fc08 <rlc_UM5_reassemble_deliver+0xa8>
    ff9f:	90                   	nop
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    ffa0:	83 c4 34             	add    $0x34,%esp
    ffa3:	5b                   	pop    %ebx
    ffa4:	5e                   	pop    %esi
    ffa5:	5f                   	pop    %edi
    ffa6:	5d                   	pop    %ebp
    ffa7:	c3                   	ret    
					tbuff=NULL;
				}

				else
				{
					pdu_left->SN5_Left = pduhdr->SN;
    ffa8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ffab:	83 e0 1f             	and    $0x1f,%eax
    ffae:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    ffb1:	8b 06                	mov    (%esi),%eax
    ffb3:	89 42 04             	mov    %eax,0x4(%edx)
    ffb6:	e9 2d fc ff ff       	jmp    fbe8 <rlc_UM5_reassemble_deliver+0x88>
    ffbb:	90                   	nop
    ffbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ffc0:	e8 fc ff ff ff       	call   ffc1 <rlc_UM5_reassemble_deliver+0x461>
					fsm_skb_reserve(new_skb,length);
    ffc5:	89 da                	mov    %ebx,%edx
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ffc7:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    ffc9:	e8 fc ff ff ff       	call   ffca <rlc_UM5_reassemble_deliver+0x46a>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ffce:	8b 06                	mov    (%esi),%eax
    ffd0:	89 da                	mov    %ebx,%edx
    ffd2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ffd8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ffdb:	89 f8                	mov    %edi,%eax
    ffdd:	e8 fc ff ff ff       	call   ffde <rlc_UM5_reassemble_deliver+0x47e>
    ffe2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ffe5:	89 d9                	mov    %ebx,%ecx
    ffe7:	e8 fc ff ff ff       	call   ffe8 <rlc_UM5_reassemble_deliver+0x488>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    ffec:	8b 06                	mov    (%esi),%eax
    ffee:	8b 50 50             	mov    0x50(%eax),%edx
    fff1:	e8 fc ff ff ff       	call   fff2 <rlc_UM5_reassemble_deliver+0x492>
                    
					pdu_left->SN5_Left = pduhdr->SN;
    fff6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fff9:	0f b6 02             	movzbl (%edx),%eax
    fffc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ffff:	83 e0 1f             	and    $0x1f,%eax
   10002:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft = new_skb;
   10005:	89 7a 04             	mov    %edi,0x4(%edx)
   10008:	e9 4d ff ff ff       	jmp    ff5a <rlc_UM5_reassemble_deliver+0x3fa>
   1000d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
   10010:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10013:	e8 fc ff ff ff       	call   10014 <rlc_UM5_reassemble_deliver+0x4b4>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10018:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1001b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1001f:	89 d8                	mov    %ebx,%eax
   10021:	e8 fc ff ff ff       	call   10022 <rlc_UM5_reassemble_deliver+0x4c2>

					fsm_skb_reserve(new_skb,length);
   10026:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10028:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   1002a:	e8 fc ff ff ff       	call   1002b <rlc_UM5_reassemble_deliver+0x4cb>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1002f:	8b 06                	mov    (%esi),%eax
   10031:	89 da                	mov    %ebx,%edx
   10033:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10039:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1003c:	89 f8                	mov    %edi,%eax
   1003e:	e8 fc ff ff ff       	call   1003f <rlc_UM5_reassemble_deliver+0x4df>
   10043:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10046:	89 d9                	mov    %ebx,%ecx
   10048:	e8 fc ff ff ff       	call   10049 <rlc_UM5_reassemble_deliver+0x4e9>
					fsm_skb_pull(tbuff->pkt,length ) ;
   1004d:	8b 06                	mov    (%esi),%eax
   1004f:	89 da                	mov    %ebx,%edx
					skb = new_skb;
   10051:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
   10053:	e8 fc ff ff ff       	call   10054 <rlc_UM5_reassemble_deliver+0x4f4>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10058:	89 f8                	mov    %edi,%eax
   1005a:	e8 fc ff ff ff       	call   1005b <rlc_UM5_reassemble_deliver+0x4fb>
   1005f:	83 f8 01             	cmp    $0x1,%eax
   10062:	0f 86 f7 01 00 00    	jbe    1025f <rlc_UM5_reassemble_deliver+0x6ff>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   10068:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1006b:	b9 02 00 00 00       	mov    $0x2,%ecx
   10070:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   10076:	e8 fc ff ff ff       	call   10077 <rlc_UM5_reassemble_deliver+0x517>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   1007b:	89 d8                	mov    %ebx,%eax
   1007d:	ba 06 00 00 00       	mov    $0x6,%edx
   10082:	e8 fc ff ff ff       	call   10083 <rlc_UM5_reassemble_deliver+0x523>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   10087:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1008a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   10091:	c7 04 24 78 3c 00 00 	movl   $0x3c78,(%esp)
   10098:	e8 fc ff ff ff       	call   10099 <rlc_UM5_reassemble_deliver+0x539>
   1009d:	e9 5a fd ff ff       	jmp    fdfc <rlc_UM5_reassemble_deliver+0x29c>
   100a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
   100a8:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
   100ab:	8b 16                	mov    (%esi),%edx
   100ad:	8b 41 04             	mov    0x4(%ecx),%eax
   100b0:	8b 40 50             	mov    0x50(%eax),%eax
   100b3:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
   100b7:	0f b7 d8             	movzwl %ax,%ebx
   100ba:	89 d8                	mov    %ebx,%eax
   100bc:	e8 fc ff ff ff       	call   100bd <rlc_UM5_reassemble_deliver+0x55d>

					fsm_skb_reserve(new_skb,length);
   100c1:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
   100c3:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   100c5:	e8 fc ff ff ff       	call   100c6 <rlc_UM5_reassemble_deliver+0x566>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
   100ca:	8b 06                	mov    (%esi),%eax
   100cc:	8b 58 50             	mov    0x50(%eax),%ebx
   100cf:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   100d5:	89 f8                	mov    %edi,%eax
   100d7:	89 55 ec             	mov    %edx,-0x14(%ebp)
   100da:	89 da                	mov    %ebx,%edx
   100dc:	e8 fc ff ff ff       	call   100dd <rlc_UM5_reassemble_deliver+0x57d>
   100e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   100e4:	89 d9                	mov    %ebx,%ecx
   100e6:	e8 fc ff ff ff       	call   100e7 <rlc_UM5_reassemble_deliver+0x587>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   100eb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   100ee:	8b 42 04             	mov    0x4(%edx),%eax
   100f1:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   100f7:	8b 58 50             	mov    0x50(%eax),%ebx
   100fa:	89 f8                	mov    %edi,%eax
   100fc:	89 55 ec             	mov    %edx,-0x14(%ebp)
   100ff:	89 da                	mov    %ebx,%edx
   10101:	e8 fc ff ff ff       	call   10102 <rlc_UM5_reassemble_deliver+0x5a2>
   10106:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10109:	89 d9                	mov    %ebx,%ecx
   1010b:	e8 fc ff ff ff       	call   1010c <rlc_UM5_reassemble_deliver+0x5ac>
					clear_left_pdu(pdu_left);
   10110:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10113:	e8 fc ff ff ff       	call   10114 <rlc_UM5_reassemble_deliver+0x5b4>
					if(tbuff->pkt != NULL)
   10118:	8b 06                	mov    (%esi),%eax
   1011a:	85 c0                	test   %eax,%eax
   1011c:	74 0b                	je     10129 <rlc_UM5_reassemble_deliver+0x5c9>
					{
						fsm_pkt_destroy(tbuff->pkt);
   1011e:	e8 fc ff ff ff       	call   1011f <rlc_UM5_reassemble_deliver+0x5bf>
						tbuff->pkt = NULL;
   10123:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
   10129:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1012c:	0f b6 01             	movzbl (%ecx),%eax
   1012f:	a8 40                	test   $0x40,%al
   10131:	74 24                	je     10157 <rlc_UM5_reassemble_deliver+0x5f7>
						SV(countSendToUpper)++;
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n"); 
					}
					else
					{
						pdu_left->SN5_Left = pduhdr->SN;
   10133:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10136:	83 e0 1f             	and    $0x1f,%eax
   10139:	66 89 02             	mov    %ax,(%edx)
						pdu_left->sduLeft = new_skb;
   1013c:	89 7a 04             	mov    %edi,0x4(%edx)
   1013f:	e9 a4 fa ff ff       	jmp    fbe8 <rlc_UM5_reassemble_deliver+0x88>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   10144:	ba 02 00 00 00       	mov    $0x2,%edx
   10149:	89 f8                	mov    %edi,%eax
   1014b:	e8 fc ff ff ff       	call   1014c <rlc_UM5_reassemble_deliver+0x5ec>
   10150:	89 c3                	mov    %eax,%ebx
   10152:	e9 ce fd ff ff       	jmp    ff25 <rlc_UM5_reassemble_deliver+0x3c5>
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10157:	ba 06 00 00 00       	mov    $0x6,%edx
   1015c:	89 f8                	mov    %edi,%eax
   1015e:	e8 fc ff ff ff       	call   1015f <rlc_UM5_reassemble_deliver+0x5ff>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10163:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
   10165:	89 fb                	mov    %edi,%ebx
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10167:	e8 fc ff ff ff       	call   10168 <rlc_UM5_reassemble_deliver+0x608>
   1016c:	83 f8 01             	cmp    $0x1,%eax
   1016f:	0f 87 cb fb ff ff    	ja     fd40 <rlc_UM5_reassemble_deliver+0x1e0>

					skb = tbuff->pkt;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   10175:	89 d8                	mov    %ebx,%eax
   10177:	ba 02 00 00 00       	mov    $0x2,%edx
   1017c:	e8 fc ff ff ff       	call   1017d <rlc_UM5_reassemble_deliver+0x61d>
   10181:	89 c3                	mov    %eax,%ebx
   10183:	e9 b8 fb ff ff       	jmp    fd40 <rlc_UM5_reassemble_deliver+0x1e0>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
   10188:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1018b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   1018e:	8b 42 04             	mov    0x4(%edx),%eax
   10191:	8b 40 50             	mov    0x50(%eax),%eax
   10194:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
   10198:	0f b7 d8             	movzwl %ax,%ebx
   1019b:	89 d8                	mov    %ebx,%eax
   1019d:	e8 fc ff ff ff       	call   1019e <rlc_UM5_reassemble_deliver+0x63e>

						fsm_skb_reserve(new_skb,length);
   101a2:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
   101a4:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
   101a6:	e8 fc ff ff ff       	call   101a7 <rlc_UM5_reassemble_deliver+0x647>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
   101ab:	8b 06                	mov    (%esi),%eax
   101ad:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   101b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
   101b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   101b9:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   101bd:	89 f8                	mov    %edi,%eax
   101bf:	89 da                	mov    %ebx,%edx
   101c1:	e8 fc ff ff ff       	call   101c2 <rlc_UM5_reassemble_deliver+0x662>
   101c6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   101c9:	89 d9                	mov    %ebx,%ecx
   101cb:	e8 fc ff ff ff       	call   101cc <rlc_UM5_reassemble_deliver+0x66c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
   101d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   101d3:	0f b7 50 20          	movzwl 0x20(%eax),%edx
   101d7:	8b 06                	mov    (%esi),%eax
   101d9:	e8 fc ff ff ff       	call   101da <rlc_UM5_reassemble_deliver+0x67a>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   101de:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   101e1:	8b 42 04             	mov    0x4(%edx),%eax
   101e4:	8b 58 50             	mov    0x50(%eax),%ebx
   101e7:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   101ed:	89 f8                	mov    %edi,%eax
   101ef:	89 55 e0             	mov    %edx,-0x20(%ebp)
   101f2:	89 da                	mov    %ebx,%edx
   101f4:	e8 fc ff ff ff       	call   101f5 <rlc_UM5_reassemble_deliver+0x695>
   101f9:	8b 55 e0             	mov    -0x20(%ebp),%edx
   101fc:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
   101fe:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   10200:	e8 fc ff ff ff       	call   10201 <rlc_UM5_reassemble_deliver+0x6a1>

						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10205:	ba 06 00 00 00       	mov    $0x6,%edx
   1020a:	89 f8                	mov    %edi,%eax
   1020c:	e8 fc ff ff ff       	call   1020d <rlc_UM5_reassemble_deliver+0x6ad>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10211:	89 f8                	mov    %edi,%eax
   10213:	e8 fc ff ff ff       	call   10214 <rlc_UM5_reassemble_deliver+0x6b4>
   10218:	83 f8 01             	cmp    $0x1,%eax
   1021b:	76 55                	jbe    10272 <rlc_UM5_reassemble_deliver+0x712>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   1021d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10220:	b9 02 00 00 00       	mov    $0x2,%ecx
   10225:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1022b:	e8 fc ff ff ff       	call   1022c <rlc_UM5_reassemble_deliver+0x6cc>
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10230:	ba 06 00 00 00       	mov    $0x6,%edx
   10235:	89 d8                	mov    %ebx,%eax
   10237:	e8 fc ff ff ff       	call   10238 <rlc_UM5_reassemble_deliver+0x6d8>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
   1023c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1023f:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   10246:	c7 04 24 78 3c 00 00 	movl   $0x3c78,(%esp)
   1024d:	e8 fc ff ff ff       	call   1024e <rlc_UM5_reassemble_deliver+0x6ee>
                      
						clear_left_pdu(pdu_left);
   10252:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10255:	e8 fc ff ff ff       	call   10256 <rlc_UM5_reassemble_deliver+0x6f6>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
   1025a:	e9 9d fb ff ff       	jmp    fdfc <rlc_UM5_reassemble_deliver+0x29c>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   1025f:	ba 02 00 00 00       	mov    $0x2,%edx
   10264:	89 f8                	mov    %edi,%eax
   10266:	e8 fc ff ff ff       	call   10267 <rlc_UM5_reassemble_deliver+0x707>
   1026b:	89 c3                	mov    %eax,%ebx
   1026d:	e9 f6 fd ff ff       	jmp    10068 <rlc_UM5_reassemble_deliver+0x508>
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   10272:	ba 02 00 00 00       	mov    $0x2,%edx
   10277:	89 f8                	mov    %edi,%eax
   10279:	e8 fc ff ff ff       	call   1027a <rlc_UM5_reassemble_deliver+0x71a>
   1027e:	89 c3                	mov    %eax,%ebx
   10280:	eb 9b                	jmp    1021d <rlc_UM5_reassemble_deliver+0x6bd>
   10282:	90                   	nop
   10283:	90                   	nop
   10284:	90                   	nop
   10285:	90                   	nop
   10286:	90                   	nop
   10287:	90                   	nop
   10288:	90                   	nop
   10289:	90                   	nop
   1028a:	90                   	nop
   1028b:	90                   	nop
   1028c:	90                   	nop
   1028d:	90                   	nop
   1028e:	90                   	nop
   1028f:	90                   	nop

00010290 <Am_instance_build>:
void skb_printf(FSM_PKT *pkt);
void buff_printf(struct AM_Instance *amIns);


void Am_instance_build()
{
   10290:	55                   	push   %ebp
   10291:	89 e5                	mov    %esp,%ebp
   10293:	57                   	push   %edi
   10294:	56                   	push   %esi
   10295:	53                   	push   %ebx
   10296:	83 ec 08             	sub    $0x8,%esp
   10299:	e8 fc ff ff ff       	call   1029a <Am_instance_build+0xa>
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
   1029e:	e8 fc ff ff ff       	call   1029f <Am_instance_build+0xf>
   102a3:	89 c2                	mov    %eax,%edx
	amIns =  instance_create(struct AM_Instance);
   102a5:	b8 0c 23 00 00       	mov    $0x230c,%eax
   102aa:	89 55 f0             	mov    %edx,-0x10(%ebp)
   102ad:	e8 fc ff ff ff       	call   102ae <Am_instance_build+0x1e>
	amIns->rbId = 4;
   102b2:	c6 40 02 04          	movb   $0x4,0x2(%eax)
void Am_instance_build()
{
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   102b6:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 4;
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 4;
   102b8:	c6 40 03 04          	movb   $0x4,0x3(%eax)
	amIns->reorderTimerValue= 100*100;
   102bc:	c7 40 1c 10 27 00 00 	movl   $0x2710,0x1c(%eax)
	amIns->statProhTimerValue =150*150;
   102c3:	c7 40 28 e4 57 00 00 	movl   $0x57e4,0x28(%eax)
	amIns->pollRetxTimerValue = 100*100;
   102ca:	c7 40 10 10 27 00 00 	movl   $0x2710,0x10(%eax)
	amIns->pollPDU = 32;
   102d1:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   102d8:	20 00 
	amIns->pollBYTE = 1000;
   102da:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   102e1:	e8 03 
	amIns->maxRetxThreshold = 4;
   102e3:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   102ea:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   102ec:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   102f3:	00 00 00 
   102f6:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   102fd:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10304:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10307:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   1030e:	00 00 00 
   10311:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10318:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   1031f:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10322:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10329:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   10330:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   10337:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   1033d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10340:	eb 08                	jmp    1034a <Am_instance_build+0xba>
   10342:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10348:	89 fe                	mov    %edi,%esi
   1034a:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   10351:	ff 
   10352:	8d 7e 01             	lea    0x1(%esi),%edi
   10355:	0f 85 b4 01 00 00    	jne    1050f <Am_instance_build+0x27f>
   1035b:	83 ff 31             	cmp    $0x31,%edi
   1035e:	7e e8                	jle    10348 <Am_instance_build+0xb8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10360:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10363:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1036a:	e8 fc ff ff ff       	call   1036b <Am_instance_build+0xdb>
   1036f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10372:	eb 06                	jmp    1037a <Am_instance_build+0xea>
   10374:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10378:	89 f7                	mov    %esi,%edi
   1037a:	83 bc ba 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%edi,4)
   10381:	ff 
   10382:	8d 77 01             	lea    0x1(%edi),%esi
   10385:	0f 85 68 01 00 00    	jne    104f3 <Am_instance_build+0x263>
   1038b:	83 fe 31             	cmp    $0x31,%esi
   1038e:	7e e8                	jle    10378 <Am_instance_build+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10390:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10393:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1039a:	e8 fc ff ff ff       	call   1039b <Am_instance_build+0x10b>
   1039f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   103a2:	eb 06                	jmp    103aa <Am_instance_build+0x11a>
   103a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   103a8:	89 c6                	mov    %eax,%esi
   103aa:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   103b1:	ff 
   103b2:	8d 46 01             	lea    0x1(%esi),%eax
   103b5:	0f 85 1c 01 00 00    	jne    104d7 <Am_instance_build+0x247>
   103bb:	83 f8 31             	cmp    $0x31,%eax
   103be:	7e e8                	jle    103a8 <Am_instance_build+0x118>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   103c0:	89 55 f0             	mov    %edx,-0x10(%ebp)
   103c3:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   103ca:	e8 fc ff ff ff       	call   103cb <Am_instance_build+0x13b>
   103cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   103d2:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   103d5:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   103d8:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   103db:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   103e1:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   103e7:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   103ed:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   103f3:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   103f9:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   103ff:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10405:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   1040b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10411:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10417:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   1041d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10423:	31 c0                	xor    %eax,%eax
	else
		{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10425:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   1042c:	00 00 
   1042e:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   10435:	00 00 
   10437:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   1043e:	00 00 
   10440:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   10447:	00 00 
   10449:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   10450:	00 00 
   10452:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   10459:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   1045b:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   10462:	00 02 
   10464:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   1046b:	00 02 
   1046d:	8d 76 00             	lea    0x0(%esi),%esi
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   10470:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   10477:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   1047b:	83 c0 01             	add    $0x1,%eax
   1047e:	3d 00 04 00 00       	cmp    $0x400,%eax
   10483:	75 eb                	jne    10470 <Am_instance_build+0x1e0>
   10485:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   10488:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   1048f:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10493:	83 c0 01             	add    $0x1,%eax
   10496:	3d 00 04 00 00       	cmp    $0x400,%eax
   1049b:	75 eb                	jne    10488 <Am_instance_build+0x1f8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1049d:	8b 82 f8 25 00 00    	mov    0x25f8(%edx),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   104a3:	8d 8b 04 23 00 00    	lea    0x2304(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   104a9:	89 8a f8 25 00 00    	mov    %ecx,0x25f8(%edx)
   104af:	81 c2 f4 25 00 00    	add    $0x25f4,%edx
   104b5:	89 93 04 23 00 00    	mov    %edx,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   104bb:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   104c1:	89 08                	mov    %ecx,(%eax)
	fsm_printf(" am instance has established\n");
   104c3:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   104ca:	e8 fc ff ff ff       	call   104cb <Am_instance_build+0x23b>

    FOUT;
}
   104cf:	83 c4 08             	add    $0x8,%esp
   104d2:	5b                   	pop    %ebx
   104d3:	5e                   	pop    %esi
   104d4:	5f                   	pop    %edi
   104d5:	5d                   	pop    %ebp
   104d6:	c3                   	ret    
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   104d7:	83 f8 31             	cmp    $0x31,%eax
   104da:	0f 8f e0 fe ff ff    	jg     103c0 <Am_instance_build+0x130>
	else
		{
		amIns->statProhTimerCode = i - 1;
   104e0:	89 73 24             	mov    %esi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   104e3:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   104ea:	ff ff ff ff 
   104ee:	e9 df fe ff ff       	jmp    103d2 <Am_instance_build+0x142>
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   104f3:	83 fe 31             	cmp    $0x31,%esi
   104f6:	0f 8f 94 fe ff ff    	jg     10390 <Am_instance_build+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   104fc:	89 7b 18             	mov    %edi,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   104ff:	c7 84 ba 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%edi,4)
   10506:	ff ff ff ff 
   1050a:	e9 9b fe ff ff       	jmp    103aa <Am_instance_build+0x11a>
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   1050f:	83 ff 31             	cmp    $0x31,%edi
   10512:	0f 8f 48 fe ff ff    	jg     10360 <Am_instance_build+0xd0>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10518:	89 73 0c             	mov    %esi,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   1051b:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   10522:	ff ff ff ff 
   10526:	e9 4f fe ff ff       	jmp    1037a <Am_instance_build+0xea>
   1052b:	90                   	nop
   1052c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00010530 <UM_instance_bulid>:

    FOUT;
}

void UM_instance_bulid(void)
{
   10530:	55                   	push   %ebp
   10531:	89 e5                	mov    %esp,%ebp
   10533:	83 ec 08             	sub    $0x8,%esp
   10536:	e8 fc ff ff ff       	call   10537 <UM_instance_bulid+0x7>
	SV_PTR_GET(rlc_mac_sv);
   1053b:	e8 fc ff ff ff       	call   1053c <UM_instance_bulid+0xc>
	SV(umText).snFiledLength = 5;
	SV(umText).lcid = 2;
	SV(umText).rbid = 2 ;
	SV(umText).CurrentStatVar = ST_TRAN;
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
   10540:	8d 90 64 5a 00 00    	lea    0x5a64(%eax),%edx

void UM_instance_bulid(void)
{
	SV_PTR_GET(rlc_mac_sv);
 //    SV(umText) =  instance_create(UM_TX_Instance);
	SV(umText).snFiledLength = 5;
   10546:	66 c7 80 76 5a 00 00 	movw   $0x5,0x5a76(%eax)
   1054d:	05 00 
	SV(umText).lcid = 2;
   1054f:	c6 80 4f 5a 00 00 02 	movb   $0x2,0x5a4f(%eax)
	SV(umText).rbid = 2 ;
   10556:	c6 80 4e 5a 00 00 02 	movb   $0x2,0x5a4e(%eax)
	SV(umText).CurrentStatVar = ST_TRAN;
   1055d:	c6 80 78 5a 00 00 08 	movb   $0x8,0x5a78(%eax)
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
   10564:	c7 80 6c 5a 00 00 00 	movl   $0x0,0x5a6c(%eax)
   1056b:	00 00 00 
   1056e:	c7 80 70 5a 00 00 00 	movl   $0x0,0x5a70(%eax)
   10575:	00 00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10578:	89 90 64 5a 00 00    	mov    %edx,0x5a64(%eax)
	list->prev = list;
   1057e:	89 90 68 5a 00 00    	mov    %edx,0x5a68(%eax)
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
   10584:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
   1058b:	00 
   1058c:	c7 04 24 ac 3c 00 00 	movl   $0x3cac,(%esp)
   10593:	e8 fc ff ff ff       	call   10594 <UM_instance_bulid+0x64>
}
   10598:	c9                   	leave  
   10599:	c3                   	ret    
   1059a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000105a0 <test>:
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
void test()
{
   105a0:	55                   	push   %ebp
   105a1:	89 e5                	mov    %esp,%ebp
   105a3:	53                   	push   %ebx
   105a4:	83 ec 10             	sub    $0x10,%esp
   105a7:	e8 fc ff ff ff       	call   105a8 <test+0x8>
	struct AM_Instance *amIns;
	void *up, *down;
	SV_PTR_GET(rlc_mac_sv);
   105ac:	e8 fc ff ff ff       	call   105ad <test+0xd>
	//fsm_schedule_self(0,SEGMENT);
	//
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
   105b1:	8d 4d f8             	lea    -0x8(%ebp),%ecx
   105b4:	8d 55 f4             	lea    -0xc(%ebp),%edx
   105b7:	05 18 02 00 00       	add    $0x218,%eax
   105bc:	89 04 24             	mov    %eax,(%esp)
   105bf:	b8 08 00 00 00       	mov    $0x8,%eax
   105c4:	e8 fc ff ff ff       	call   105c5 <test+0x25>
	amIns = (AM_Instance *)up;	
   105c9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   105cc:	85 db                	test   %ebx,%ebx
   105ce:	74 30                	je     10600 <test+0x60>
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
   105d0:	8b 53 18             	mov    0x18(%ebx),%edx
   105d3:	b8 40 0d 03 00       	mov    $0x30d40,%eax
   105d8:	e8 fc ff ff ff       	call   105d9 <test+0x39>
   105dd:	89 43 14             	mov    %eax,0x14(%ebx)
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
   105e0:	8b 43 18             	mov    0x18(%ebx),%eax
   105e3:	c7 04 24 ec 3c 00 00 	movl   $0x3cec,(%esp)
   105ea:	89 44 24 04          	mov    %eax,0x4(%esp)
   105ee:	e8 fc ff ff ff       	call   105ef <test+0x4f>
}
   105f3:	83 c4 10             	add    $0x10,%esp
   105f6:	5b                   	pop    %ebx
   105f7:	5d                   	pop    %ebp
   105f8:	c3                   	ret    
   105f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
	amIns = (AM_Instance *)up;	
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   10600:	c7 04 24 25 08 00 00 	movl   $0x825,(%esp)
   10607:	e8 fc ff ff ff       	call   10608 <test+0x68>
   1060c:	eb d2                	jmp    105e0 <test+0x40>
   1060e:	66 90                	xchg   %ax,%ax

00010610 <skb_printf>:
	}
	nposBf = NULL;
}

void skb_printf(FSM_PKT *pkt)
{
   10610:	55                   	push   %ebp
   10611:	89 e5                	mov    %esp,%ebp
   10613:	83 ec 08             	sub    $0x8,%esp
   10616:	e8 fc ff ff ff       	call   10617 <skb_printf+0x7>
	fsm_printf("%s\n",(char *)(pkt->data+4));
   1061b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10621:	c7 04 24 40 08 00 00 	movl   $0x840,(%esp)
   10628:	83 c0 04             	add    $0x4,%eax
   1062b:	89 44 24 04          	mov    %eax,0x4(%esp)
   1062f:	e8 fc ff ff ff       	call   10630 <skb_printf+0x20>
	FOUT;
}
   10634:	c9                   	leave  
   10635:	c3                   	ret    
   10636:	8d 76 00             	lea    0x0(%esi),%esi
   10639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010640 <buff_printf>:
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
}

void buff_printf(struct AM_Instance *amIns)
{
   10640:	55                   	push   %ebp
   10641:	89 e5                	mov    %esp,%ebp
   10643:	57                   	push   %edi
   10644:	56                   	push   %esi
   10645:	53                   	push   %ebx
   10646:	83 ec 08             	sub    $0x8,%esp
   10649:	e8 fc ff ff ff       	call   1064a <buff_printf+0xa>
   1064e:	89 c3                	mov    %eax,%ebx
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   10650:	c7 04 24 44 08 00 00 	movl   $0x844,(%esp)
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
   10657:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   1065d:	e8 fc ff ff ff       	call   1065e <buff_printf+0x1e>
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
   10662:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   10668:	c7 04 24 5d 08 00 00 	movl   $0x85d,(%esp)
   1066f:	89 44 24 04          	mov    %eax,0x4(%esp)
   10673:	e8 fc ff ff ff       	call   10674 <buff_printf+0x34>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   10678:	8b b3 9c 01 00 00    	mov    0x19c(%ebx),%esi
	if( !list_empty(&amIns->amRetxBuffer.list) )
   1067e:	39 f7                	cmp    %esi,%edi
   10680:	74 56                	je     106d8 <buff_printf+0x98>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   10682:	8b 1e                	mov    (%esi),%ebx
   10684:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   1068a:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
   10690:	eb 0a                	jmp    1069c <buff_printf+0x5c>
   10692:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10698:	89 de                	mov    %ebx,%esi
   1069a:	89 d3                	mov    %edx,%ebx
		{
			fsm_printf("The PDU SN is %d\n",amRetxBf->SN);
   1069c:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   106a3:	c7 04 24 79 08 00 00 	movl   $0x879,(%esp)
   106aa:	89 44 24 04          	mov    %eax,0x4(%esp)
   106ae:	e8 fc ff ff ff       	call   106af <buff_printf+0x6f>
			skb_printf(amRetxBf->pkt);
   106b3:	8b 06                	mov    (%esi),%eax
   106b5:	e8 fc ff ff ff       	call   106b6 <buff_printf+0x76>
	//
	fsm_printf("printf the amRetxBuffer\n");
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   106ba:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   106c0:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   106c6:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   106cc:	39 c7                	cmp    %eax,%edi
   106ce:	75 c8                	jne    10698 <buff_printf+0x58>
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
	}
	nposBf = NULL;
}
   106d0:	83 c4 08             	add    $0x8,%esp
   106d3:	5b                   	pop    %ebx
   106d4:	5e                   	pop    %esi
   106d5:	5f                   	pop    %edi
   106d6:	5d                   	pop    %ebp
   106d7:	c3                   	ret    
			skb_printf(amRetxBf->pkt);
		}
	}
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
   106d8:	c7 04 24 8b 08 00 00 	movl   $0x88b,(%esp)
   106df:	e8 fc ff ff ff       	call   106e0 <buff_printf+0xa0>
   106e4:	eb ea                	jmp    106d0 <buff_printf+0x90>
   106e6:	8d 76 00             	lea    0x0(%esi),%esi
   106e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000106f0 <add_data_retx>:
{
	fsm_printf("%s\n",(char *)(pkt->data+4));
	FOUT;
}
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
   106f0:	55                   	push   %ebp
   106f1:	89 e5                	mov    %esp,%ebp
   106f3:	57                   	push   %edi
   106f4:	56                   	push   %esi
   106f5:	53                   	push   %ebx
   106f6:	83 ec 04             	sub    $0x4,%esp
   106f9:	e8 fc ff ff ff       	call   106fa <add_data_retx+0xa>
   106fe:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
   10700:	e8 fc ff ff ff       	call   10701 <add_data_retx+0x11>
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10705:	b8 1a 00 00 00       	mov    $0x1a,%eax
   1070a:	e8 fc ff ff ff       	call   1070b <add_data_retx+0x1b>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   1070f:	ba 02 00 00 00       	mov    $0x2,%edx
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
	SV_PTR_GET(rlc_mac_sv);
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10714:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->data;;
   10716:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
   1071c:	c6 00 00             	movb   $0x0,(%eax)
   1071f:	c6 40 01 84          	movb   $0x84,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10723:	89 d8                	mov    %ebx,%eax
   10725:	e8 fc ff ff ff       	call   10726 <add_data_retx+0x36>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   1072a:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10730:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10735:	c6 00 0b             	movb   $0xb,(%eax)
   10738:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   1073c:	89 d8                	mov    %ebx,%eax
   1073e:	e8 fc ff ff ff       	call   1073f <add_data_retx+0x4f>
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
   10743:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   10748:	e8 fc ff ff ff       	call   10749 <add_data_retx+0x59>
   1074d:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   10753:	ba a6 08 00 00       	mov    $0x8a6,%edx
   10758:	89 c1                	mov    %eax,%ecx
   1075a:	89 f8                	mov    %edi,%eax
   1075c:	e8 fc ff ff ff       	call   1075d <add_data_retx+0x6d>
	fsm_skb_put(skb,strlen(sdu1));
   10761:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   10766:	e8 fc ff ff ff       	call   10767 <add_data_retx+0x77>
   1076b:	89 c2                	mov    %eax,%edx
   1076d:	89 d8                	mov    %ebx,%eax
   1076f:	e8 fc ff ff ff       	call   10770 <add_data_retx+0x80>
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
   10774:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   10779:	e8 fc ff ff ff       	call   1077a <add_data_retx+0x8a>
   1077e:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   10784:	ba b1 08 00 00       	mov    $0x8b1,%edx
   10789:	89 c1                	mov    %eax,%ecx
   1078b:	89 f8                	mov    %edi,%eax
   1078d:	e8 fc ff ff ff       	call   1078e <add_data_retx+0x9e>
	fsm_skb_put(skb,strlen(sdu2));
   10792:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   10797:	e8 fc ff ff ff       	call   10798 <add_data_retx+0xa8>
   1079c:	89 c2                	mov    %eax,%edx
   1079e:	89 d8                	mov    %ebx,%eax
   107a0:	e8 fc ff ff ff       	call   107a1 <add_data_retx+0xb1>

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   107a5:	b8 a4 00 00 00       	mov    $0xa4,%eax
   107aa:	e8 fc ff ff ff       	call   107ab <add_data_retx+0xbb>
	ambuf->pkt = skb;
   107af:	89 18                	mov    %ebx,(%eax)
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
	fsm_skb_put(skb,strlen(sdu1));
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
	fsm_skb_put(skb,strlen(sdu2));

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   107b1:	89 c7                	mov    %eax,%edi
	ambuf->pkt = skb;
	ambuf->pktstatus = FULL_SDU;
   107b3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	ambuf->pos = 0;
   107ba:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   107c1:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   107c8:	00 00 00 
	ambuf->segStart[0] = 0;
   107cb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	ambuf->segEnd[0] = 20;
   107d2:	c7 40 50 14 00 00 00 	movl   $0x14,0x50(%eax)
	ambuf->retxCount = 0;
   107d9:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   107e0:	00 00 
	ambuf->SN = 0;
   107e2:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   107e9:	00 00 
	ambuf->headLen = 2*2;
   107eb:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 20;
   107f2:	c7 80 98 00 00 00 14 	movl   $0x14,0x98(%eax)
   107f9:	00 00 00 
	fsm_printf("add data in retx buffer\n");
   107fc:	c7 04 24 bc 08 00 00 	movl   $0x8bc,(%esp)
   10803:	e8 fc ff ff ff       	call   10804 <add_data_retx+0x114>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10808:	8b 86 a0 01 00 00    	mov    0x1a0(%esi),%eax
	list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
   1080e:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10814:	89 96 a0 01 00 00    	mov    %edx,0x1a0(%esi)
   1081a:	81 c6 9c 01 00 00    	add    $0x19c,%esi
   10820:	89 b7 9c 00 00 00    	mov    %esi,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   10826:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   1082c:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   1082e:	83 c4 04             	add    $0x4,%esp
   10831:	5b                   	pop    %ebx
   10832:	5e                   	pop    %esi
   10833:	5f                   	pop    %edi
   10834:	5d                   	pop    %ebp
   10835:	c3                   	ret    
   10836:	8d 76 00             	lea    0x0(%esi),%esi
   10839:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010840 <Am_instance_add>:
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
}

void Am_instance_add()
{
   10840:	55                   	push   %ebp
   10841:	89 e5                	mov    %esp,%ebp
   10843:	57                   	push   %edi
   10844:	56                   	push   %esi
   10845:	53                   	push   %ebx
   10846:	83 ec 04             	sub    $0x4,%esp
   10849:	e8 fc ff ff ff       	call   1084a <Am_instance_add+0xa>
    struct AM_Instance *amIns;
    int i = 0;
    SV_PTR_GET(rlc_mac_sv);
   1084e:	e8 fc ff ff ff       	call   1084f <Am_instance_add+0xf>
   10853:	89 c6                	mov    %eax,%esi
	amIns =  instance_create(struct AM_Instance);
   10855:	b8 0c 23 00 00       	mov    $0x230c,%eax
   1085a:	e8 fc ff ff ff       	call   1085b <Am_instance_add+0x1b>
}

void Am_instance_add()
{
    struct AM_Instance *amIns;
    int i = 0;
   1085f:	31 d2                	xor    %edx,%edx
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   10861:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 8;
   10863:	c6 40 02 08          	movb   $0x8,0x2(%eax)
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 8;
   10867:	c6 40 03 08          	movb   $0x8,0x3(%eax)
	amIns->reorderTimerValue= 1000*100;
   1086b:	c7 40 1c a0 86 01 00 	movl   $0x186a0,0x1c(%eax)
	amIns->statProhTimerValue = 2000*100;
   10872:	c7 40 28 40 0d 03 00 	movl   $0x30d40,0x28(%eax)
	amIns->pollRetxTimerValue = 1000*100;
   10879:	c7 40 10 a0 86 01 00 	movl   $0x186a0,0x10(%eax)
	amIns->pollPDU = 32;
   10880:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10887:	20 00 
	amIns->pollBYTE = 1000;
   10889:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10890:	e8 03 
	amIns->maxRetxThreshold = 4;
   10892:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   10899:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   1089b:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   108a2:	00 00 00 
   108a5:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   108ac:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   108b3:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   108b6:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   108bd:	00 00 00 
   108c0:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   108c7:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   108ce:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   108d1:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   108d8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   108df:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   108e6:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   108ec:	eb 0d                	jmp    108fb <Am_instance_add+0xbb>
   108ee:	66 90                	xchg   %ax,%ax
   108f0:	83 f8 32             	cmp    $0x32,%eax
   108f3:	0f 84 8a 01 00 00    	je     10a83 <Am_instance_add+0x243>
   108f9:	89 c2                	mov    %eax,%edx
   108fb:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
   10902:	ff 
   10903:	8d 42 01             	lea    0x1(%edx),%eax
   10906:	74 e8                	je     108f0 <Am_instance_add+0xb0>
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10908:	83 f8 32             	cmp    $0x32,%eax
   1090b:	0f 84 72 01 00 00    	je     10a83 <Am_instance_add+0x243>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10911:	89 53 0c             	mov    %edx,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   10914:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
   1091b:	ff ff ff ff 
   1091f:	eb 09                	jmp    1092a <Am_instance_add+0xea>
   10921:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10928:	89 f8                	mov    %edi,%eax
   1092a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10931:	ff 
   10932:	8d 78 01             	lea    0x1(%eax),%edi
   10935:	0f 85 6a 01 00 00    	jne    10aa5 <Am_instance_add+0x265>
   1093b:	83 ff 31             	cmp    $0x31,%edi
   1093e:	7e e8                	jle    10928 <Am_instance_add+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10940:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10947:	e8 fc ff ff ff       	call   10948 <Am_instance_add+0x108>
   1094c:	eb 04                	jmp    10952 <Am_instance_add+0x112>
   1094e:	66 90                	xchg   %ax,%ax
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10950:	89 c7                	mov    %eax,%edi
   10952:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10959:	ff 
   1095a:	8d 47 01             	lea    0x1(%edi),%eax
   1095d:	0f 85 6a 01 00 00    	jne    10acd <Am_instance_add+0x28d>
   10963:	83 f8 31             	cmp    $0x31,%eax
   10966:	7e e8                	jle    10950 <Am_instance_add+0x110>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10968:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1096f:	e8 fc ff ff ff       	call   10970 <Am_instance_add+0x130>
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10974:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10977:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   1097a:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   1097d:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10983:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10989:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   1098f:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10995:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   1099b:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   109a1:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   109a7:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   109ad:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   109b3:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   109b9:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   109bf:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   109c5:	31 c0                	xor    %eax,%eax
	else
	{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   109c7:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   109ce:	00 00 
   109d0:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   109d7:	00 00 
   109d9:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   109e0:	00 00 
   109e2:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   109e9:	00 00 
   109eb:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   109f2:	00 00 
   109f4:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   109fb:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   109fd:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   10a04:	00 02 
   10a06:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   10a0d:	00 02 
   10a0f:	90                   	nop
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   10a10:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   10a17:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   10a1b:	83 c0 01             	add    $0x1,%eax
   10a1e:	3d 00 04 00 00       	cmp    $0x400,%eax
   10a23:	75 eb                	jne    10a10 <Am_instance_add+0x1d0>
   10a25:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   10a28:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   10a2f:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10a33:	83 c0 01             	add    $0x1,%eax
   10a36:	3d 00 04 00 00       	cmp    $0x400,%eax
   10a3b:	75 eb                	jne    10a28 <Am_instance_add+0x1e8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10a3d:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10a43:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10a49:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
   10a4f:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
   10a55:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   10a5b:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10a61:	89 10                	mov    %edx,(%eax)
	fsm_printf(" am instance has established\n");
   10a63:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   10a6a:	e8 fc ff ff ff       	call   10a6b <Am_instance_add+0x22b>

//
	add_data_retx(amIns,8);
   10a6f:	89 d8                	mov    %ebx,%eax
   10a71:	ba 08 00 00 00       	mov    $0x8,%edx
   10a76:	e8 fc ff ff ff       	call   10a77 <Am_instance_add+0x237>
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
   10a7b:	83 c4 04             	add    $0x4,%esp
   10a7e:	5b                   	pop    %ebx
   10a7f:	5e                   	pop    %esi
   10a80:	5f                   	pop    %edi
   10a81:	5d                   	pop    %ebp
   10a82:	c3                   	ret    
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10a83:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10a8a:	e8 fc ff ff ff       	call   10a8b <Am_instance_add+0x24b>
   10a8f:	b8 32 00 00 00       	mov    $0x32,%eax
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10a94:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10a9b:	ff 
   10a9c:	8d 78 01             	lea    0x1(%eax),%edi
   10a9f:	0f 84 96 fe ff ff    	je     1093b <Am_instance_add+0xfb>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10aa5:	83 ff 31             	cmp    $0x31,%edi
   10aa8:	0f 8f 92 fe ff ff    	jg     10940 <Am_instance_add+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   10aae:	89 43 18             	mov    %eax,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   10ab1:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
   10ab8:	ff ff ff ff 
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10abc:	8d 47 01             	lea    0x1(%edi),%eax
   10abf:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10ac6:	ff 
   10ac7:	0f 84 96 fe ff ff    	je     10963 <Am_instance_add+0x123>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10acd:	83 f8 31             	cmp    $0x31,%eax
   10ad0:	0f 8f 92 fe ff ff    	jg     10968 <Am_instance_add+0x128>
	else
	{
		amIns->statProhTimerCode = i - 1;
   10ad6:	89 7b 24             	mov    %edi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10ad9:	c7 84 be 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edi,4)
   10ae0:	ff ff ff ff 
   10ae4:	e9 8b fe ff ff       	jmp    10974 <Am_instance_add+0x134>
   10ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00010af0 <addPollData>:
}


//build()
void addPollData()
{
   10af0:	55                   	push   %ebp
   10af1:	89 e5                	mov    %esp,%ebp
   10af3:	57                   	push   %edi
   10af4:	56                   	push   %esi
   10af5:	53                   	push   %ebx
   10af6:	83 ec 04             	sub    $0x4,%esp
   10af9:	e8 fc ff ff ff       	call   10afa <addPollData+0xa>
	FSM_PKT *skb = NULL;
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
   10afe:	66 c7 45 f0 01 80    	movw   $0x8001,-0x10(%ebp)
	unsigned short data = 0x0002;
   10b04:	66 c7 45 f2 02 00    	movw   $0x2,-0xe(%ebp)
	SV_PTR_GET(rlc_mac_sv);
   10b0a:	e8 fc ff ff ff       	call   10b0b <addPollData+0x1b>
   10b0f:	89 c6                	mov    %eax,%esi
	skb = fsm_pkt_create(4);
   10b11:	b8 04 00 00 00       	mov    $0x4,%eax
   10b16:	e8 fc ff ff ff       	call   10b17 <addPollData+0x27>
   10b1b:	89 c7                	mov    %eax,%edi
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10b1d:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10b22:	e8 fc ff ff ff       	call   10b23 <addPollData+0x33>

	fsm_mem_cpy(skb->tail,&hdr,2);
   10b27:	b9 02 00 00 00       	mov    $0x2,%ecx
   10b2c:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
	unsigned short data = 0x0002;
	SV_PTR_GET(rlc_mac_sv);
	skb = fsm_pkt_create(4);
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10b2f:	89 c3                	mov    %eax,%ebx

	fsm_mem_cpy(skb->tail,&hdr,2);
   10b31:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10b37:	e8 fc ff ff ff       	call   10b38 <addPollData+0x48>
	fsm_skb_put(skb,2);
   10b3c:	ba 02 00 00 00       	mov    $0x2,%edx
   10b41:	89 f8                	mov    %edi,%eax
   10b43:	e8 fc ff ff ff       	call   10b44 <addPollData+0x54>
	fsm_mem_cpy(skb->tail,&data,2);
   10b48:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10b4e:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10b51:	b9 02 00 00 00       	mov    $0x2,%ecx
   10b56:	e8 fc ff ff ff       	call   10b57 <addPollData+0x67>
	fsm_skb_put(skb,2);
   10b5b:	ba 02 00 00 00       	mov    $0x2,%edx
   10b60:	89 f8                	mov    %edi,%eax
   10b62:	e8 fc ff ff ff       	call   10b63 <addPollData+0x73>
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10b67:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx

	fsm_mem_cpy(skb->tail,&hdr,2);
	fsm_skb_put(skb,2);
	fsm_mem_cpy(skb->tail,&data,2);
	fsm_skb_put(skb,2);
	amTxedBuffer->pkt = skb;
   10b6d:	89 3b                	mov    %edi,(%ebx)
	amTxedBuffer->SN = 0x0001;
   10b6f:	66 c7 83 94 00 00 00 	movw   $0x1,0x94(%ebx)
   10b76:	01 00 
	amTxedBuffer->pktstatus = 1;
   10b78:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	amTxedBuffer->headLen = 2;
   10b7f:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amTxedBuffer->retxCount = 0;
   10b86:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   10b8d:	00 00 
	amTxedBuffer->segnum = 0;
   10b8f:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
   10b96:	00 00 00 
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
   10b99:	83 86 e8 38 00 00 01 	addl   $0x1,0x38e8(%esi)
	amTxedBuffer->SN = 0x0001;
	amTxedBuffer->pktstatus = 1;
	amTxedBuffer->headLen = 2;
	amTxedBuffer->retxCount = 0;
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
   10ba0:	66 c7 86 3c 5a 00 00 	movw   $0x20,0x5a3c(%esi)
   10ba7:	20 00 
	SV(amText).byteWithoutPoll = 1000;
   10ba9:	66 c7 86 3e 5a 00 00 	movw   $0x3e8,0x5a3e(%esi)
   10bb0:	e8 03 
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
   10bb2:	8b 47 50             	mov    0x50(%edi),%eax
   10bb5:	01 86 e4 38 00 00    	add    %eax,0x38e4(%esi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10bbb:	8b 86 e0 38 00 00    	mov    0x38e0(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10bc1:	89 96 e0 38 00 00    	mov    %edx,0x38e0(%esi)
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10bc7:	81 c6 dc 38 00 00    	add    $0x38dc,%esi
   10bcd:	89 b3 9c 00 00 00    	mov    %esi,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
   10bd3:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
   10bd9:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   10bdb:	83 c4 04             	add    $0x4,%esp
   10bde:	5b                   	pop    %ebx
   10bdf:	5e                   	pop    %esi
   10be0:	5f                   	pop    %edi
   10be1:	5d                   	pop    %ebp
   10be2:	c3                   	ret    
   10be3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10be9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010bf0 <addPollRetxData>:
void addPollRetxData(struct AM_Instance*amIns)
{
   10bf0:	55                   	push   %ebp
   10bf1:	89 e5                	mov    %esp,%ebp
   10bf3:	57                   	push   %edi
   10bf4:	56                   	push   %esi
   10bf5:	53                   	push   %ebx
   10bf6:	e8 fc ff ff ff       	call   10bf7 <addPollRetxData+0x7>
   10bfb:	89 c6                	mov    %eax,%esi
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10bfd:	b8 1a 00 00 00       	mov    $0x1a,%eax
   10c02:	e8 fc ff ff ff       	call   10c03 <addPollRetxData+0x13>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10c07:	ba 02 00 00 00       	mov    $0x2,%edx
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10c0c:	8d be f0 00 00 00    	lea    0xf0(%esi),%edi
void addPollRetxData(struct AM_Instance*amIns)
{
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10c12:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->tail;
   10c14:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
   10c1a:	c6 00 00             	movb   $0x0,(%eax)
   10c1d:	c6 40 01 dc          	movb   $0xdc,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10c21:	89 d8                	mov    %ebx,%eax
   10c23:	e8 fc ff ff ff       	call   10c24 <addPollRetxData+0x34>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   10c28:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10c2e:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10c33:	c6 00 0b             	movb   $0xb,(%eax)
   10c36:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10c3a:	89 d8                	mov    %ebx,%eax
   10c3c:	e8 fc ff ff ff       	call   10c3d <addPollRetxData+0x4d>
	fsm_mem_cpy(skb->tail, sdu1, 11);
   10c41:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10c47:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10c4c:	ba d5 08 00 00       	mov    $0x8d5,%edx
   10c51:	e8 fc ff ff ff       	call   10c52 <addPollRetxData+0x62>
	fsm_skb_put(skb,11);
   10c56:	ba 0b 00 00 00       	mov    $0xb,%edx
   10c5b:	89 d8                	mov    %ebx,%eax
   10c5d:	e8 fc ff ff ff       	call   10c5e <addPollRetxData+0x6e>
	fsm_mem_cpy(skb->tail, sdu2, 11);
   10c62:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10c68:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10c6d:	ba e1 08 00 00       	mov    $0x8e1,%edx
   10c72:	e8 fc ff ff ff       	call   10c73 <addPollRetxData+0x83>
	fsm_skb_put(skb,11);
   10c77:	ba 0b 00 00 00       	mov    $0xb,%edx
   10c7c:	89 d8                	mov    %ebx,%eax
   10c7e:	e8 fc ff ff ff       	call   10c7f <addPollRetxData+0x8f>

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
   10c83:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10c88:	e8 fc ff ff ff       	call   10c89 <addPollRetxData+0x99>
	ambuf->pkt = skb;
   10c8d:	89 18                	mov    %ebx,(%eax)
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10c8f:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
	fsm_mem_cpy(skb->tail, sdu2, 11);
	fsm_skb_put(skb,11);

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
	ambuf->pkt = skb;
	ambuf->pktstatus = ANY_SEGMENT;
   10c95:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	ambuf->pos = 0;
   10c9c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10ca3:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10caa:	00 00 00 
	ambuf->segStart[0] = 3;
   10cad:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
	ambuf->segEnd[0] = 18;
   10cb4:	c7 40 50 12 00 00 00 	movl   $0x12,0x50(%eax)
	ambuf->retxCount = 0;
   10cbb:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10cc2:	00 00 
	ambuf->SN = 0;
   10cc4:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10ccb:	00 00 
	ambuf->headLen = 2*2;
   10ccd:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 22;
   10cd4:	c7 80 98 00 00 00 16 	movl   $0x16,0x98(%eax)
   10cdb:	00 00 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10cde:	8b 96 f4 00 00 00    	mov    0xf4(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10ce4:	89 8e f4 00 00 00    	mov    %ecx,0xf4(%esi)
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10cea:	89 b8 9c 00 00 00    	mov    %edi,0x9c(%eax)
	new->next = next;
	new->prev = prev;
   10cf0:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
   10cf6:	89 0a                	mov    %ecx,(%edx)
	amIns->amTransmittedBufferNum++;
   10cf8:	83 86 fc 00 00 00 01 	addl   $0x1,0xfc(%esi)
	amIns->amTransmittedBufferSize += skb->len;
   10cff:	8b 43 50             	mov    0x50(%ebx),%eax
   10d02:	01 86 f8 00 00 00    	add    %eax,0xf8(%esi)
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10d08:	5b                   	pop    %ebx
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
   10d09:	66 83 86 64 12 00 00 	addw   $0x1,0x1264(%esi)
   10d10:	01 
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10d11:	5e                   	pop    %esi
   10d12:	5f                   	pop    %edi
   10d13:	5d                   	pop    %ebp
   10d14:	c3                   	ret    
   10d15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   10d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010d20 <addpkt_recvData>:


void addpkt_recvData(struct AM_Instance *amIns)
{
   10d20:	55                   	push   %ebp
   10d21:	89 e5                	mov    %esp,%ebp
   10d23:	57                   	push   %edi
   10d24:	56                   	push   %esi
   10d25:	53                   	push   %ebx
   10d26:	83 ec 20             	sub    $0x20,%esp
   10d29:	e8 fc ff ff ff       	call   10d2a <addpkt_recvData+0xa>
   10d2e:	89 c3                	mov    %eax,%ebx
	unsigned short hdr;
	unsigned char *str1 = "pkt1";
	unsigned char *str2 = "pkt2";
	unsigned char *str3 = "pkt3";
	unsigned char *str4 = "pkt4";
	SV_PTR_GET(rlc_mac_sv);
   10d30:	e8 fc ff ff ff       	call   10d31 <addpkt_recvData+0x11>

	skb1 = fsm_pkt_create(6);
   10d35:	b8 06 00 00 00       	mov    $0x6,%eax
   10d3a:	e8 fc ff ff ff       	call   10d3b <addpkt_recvData+0x1b>
   10d3f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	amTxedBuffer1= (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));	
   10d42:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d47:	e8 fc ff ff ff       	call   10d48 <addpkt_recvData+0x28>
   10d4c:	89 c7                	mov    %eax,%edi
	skb2 = fsm_pkt_create(6);
   10d4e:	b8 06 00 00 00       	mov    $0x6,%eax
   10d53:	e8 fc ff ff ff       	call   10d54 <addpkt_recvData+0x34>
   10d58:	89 45 e0             	mov    %eax,-0x20(%ebp)
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d5b:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d60:	e8 fc ff ff ff       	call   10d61 <addpkt_recvData+0x41>
   10d65:	89 45 ec             	mov    %eax,-0x14(%ebp)
	skb3 = fsm_pkt_create(6);
   10d68:	b8 06 00 00 00       	mov    $0x6,%eax
   10d6d:	e8 fc ff ff ff       	call   10d6e <addpkt_recvData+0x4e>
   10d72:	89 45 dc             	mov    %eax,-0x24(%ebp)
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d75:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d7a:	e8 fc ff ff ff       	call   10d7b <addpkt_recvData+0x5b>
   10d7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	skb4 = fsm_pkt_create(6);
   10d82:	b8 06 00 00 00       	mov    $0x6,%eax
   10d87:	e8 fc ff ff ff       	call   10d88 <addpkt_recvData+0x68>
   10d8c:	89 45 d8             	mov    %eax,-0x28(%ebp)
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d8f:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d94:	e8 fc ff ff ff       	call   10d95 <addpkt_recvData+0x75>

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10d99:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10d9c:	b9 02 00 00 00       	mov    $0x2,%ecx
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));

	hdr = 0x8000;
   10da1:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	skb2 = fsm_pkt_create(6);
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10da7:	89 c6                	mov    %eax,%esi

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10da9:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   10daf:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10db2:	e8 fc ff ff ff       	call   10db3 <addpkt_recvData+0x93>
	fsm_skb_put(skb1,2);
   10db7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dba:	ba 02 00 00 00       	mov    $0x2,%edx
   10dbf:	e8 fc ff ff ff       	call   10dc0 <addpkt_recvData+0xa0>
	fsm_mem_cpy(skb1->tail,str1,4);
   10dc4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10dc7:	ba ed 08 00 00       	mov    $0x8ed,%edx
   10dcc:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   10dd2:	b9 04 00 00 00       	mov    $0x4,%ecx
   10dd7:	e8 fc ff ff ff       	call   10dd8 <addpkt_recvData+0xb8>
	fsm_skb_put(skb1,4);
   10ddc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ddf:	ba 04 00 00 00       	mov    $0x4,%edx
   10de4:	e8 fc ff ff ff       	call   10de5 <addpkt_recvData+0xc5>
	amTxedBuffer1->pkt = skb1;
   10de9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10dec:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
   10df2:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   10df9:	00 00 
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10dfb:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
   10e01:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amTxedBuffer1->headLen = 2;
   10e08:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
   10e0f:	89 07                	mov    %eax,(%edi)
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
	amTxedBuffer1->headLen = 2;
	amTxedBuffer1->datalen = 4;
   10e11:	c7 87 98 00 00 00 04 	movl   $0x4,0x98(%edi)
   10e18:	00 00 00 
	amTxedBuffer1->retxCount = -1;
   10e1b:	66 c7 87 96 00 00 00 	movw   $0xffff,0x96(%edi)
   10e22:	ff ff 
	amTxedBuffer1->segnum = 0;
   10e24:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   10e2b:	00 00 00 
	amTxedBuffer1->pos = 0;
   10e2e:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	amTxedBuffer1->segEnd[0] = -1;
   10e35:	c7 47 50 ff ff ff ff 	movl   $0xffffffff,0x50(%edi)
	amTxedBuffer1->segStart[0] = -1;
   10e3c:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edi)
	amIns->amTransmittedBufferNum++;
   10e43:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb1->len;
   10e4a:	8b 40 50             	mov    0x50(%eax),%eax
   10e4d:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10e53:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   10e59:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10e60:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10e61:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10e67:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->prev = prev;
   10e6d:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10e73:	8b 7d e0             	mov    -0x20(%ebp),%edi
	prev->next = new;
   10e76:	89 10                	mov    %edx,(%eax)
   10e78:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10e7b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10e7e:	b9 02 00 00 00       	mov    $0x2,%ecx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
   10e83:	66 c7 45 f2 01 80    	movw   $0x8001,-0xe(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10e89:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10e8f:	e8 fc ff ff ff       	call   10e90 <addpkt_recvData+0x170>
	fsm_skb_put(skb2,2);
   10e94:	ba 02 00 00 00       	mov    $0x2,%edx
   10e99:	89 f8                	mov    %edi,%eax
   10e9b:	e8 fc ff ff ff       	call   10e9c <addpkt_recvData+0x17c>
	fsm_mem_cpy(skb2->tail,str2,4);
   10ea0:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10ea6:	b9 04 00 00 00       	mov    $0x4,%ecx
   10eab:	ba f2 08 00 00       	mov    $0x8f2,%edx
   10eb0:	e8 fc ff ff ff       	call   10eb1 <addpkt_recvData+0x191>
	fsm_skb_put(skb2,4);
   10eb5:	ba 04 00 00 00       	mov    $0x4,%edx
   10eba:	89 f8                	mov    %edi,%eax
   10ebc:	e8 fc ff ff ff       	call   10ebd <addpkt_recvData+0x19d>
	amTxedBuffer2->pkt = skb2;
   10ec1:	8b 45 ec             	mov    -0x14(%ebp),%eax
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   10ec4:	8b 55 ec             	mov    -0x14(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   10ec7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
   10eca:	89 38                	mov    %edi,(%eax)
	amTxedBuffer2->SN = 0x0001;
   10ecc:	66 c7 80 94 00 00 00 	movw   $0x1,0x94(%eax)
   10ed3:	01 00 
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   10ed5:	81 c2 9c 00 00 00    	add    $0x9c,%edx
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
	amTxedBuffer2->SN = 0x0001;
	amTxedBuffer2->pktstatus = FULL_SDU;
   10edb:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	amTxedBuffer2->headLen = 2;
   10ee2:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer2->datalen = 4;
   10ee9:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   10ef0:	00 00 00 
	amTxedBuffer2->retxCount = -1;
   10ef3:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   10efa:	ff ff 
	amTxedBuffer2->segnum = 0;
   10efc:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
   10f03:	00 00 00 
	amTxedBuffer2->pos = 0;
   10f06:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer2->segEnd[0] = -1;
   10f0d:	c7 40 50 ff ff ff ff 	movl   $0xffffffff,0x50(%eax)
	amTxedBuffer2->segStart[0] = -1;
   10f14:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   10f1b:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb2->len;
   10f22:	8b 47 50             	mov    0x50(%edi),%eax
   10f25:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
   10f2b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10f2e:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   10f34:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10f3b:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10f3c:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10f42:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)
	new->prev = prev;
   10f48:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
   10f4e:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   10f53:	89 10                	mov    %edx,(%eax)
   10f55:	8b 55 dc             	mov    -0x24(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
   10f58:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	fsm_mem_cpy(skb3->tail,&hdr,2);
   10f5e:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   10f64:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10f67:	e8 fc ff ff ff       	call   10f68 <addpkt_recvData+0x248>
	fsm_skb_put(skb3,2);
   10f6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f6f:	ba 02 00 00 00       	mov    $0x2,%edx
   10f74:	e8 fc ff ff ff       	call   10f75 <addpkt_recvData+0x255>
	fsm_mem_cpy(skb3->tail,str3,4);
   10f79:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10f7c:	ba f7 08 00 00       	mov    $0x8f7,%edx
   10f81:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   10f87:	b9 04 00 00 00       	mov    $0x4,%ecx
   10f8c:	e8 fc ff ff ff       	call   10f8d <addpkt_recvData+0x26d>
	fsm_skb_put(skb3,4);
   10f91:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f94:	ba 04 00 00 00       	mov    $0x4,%edx
   10f99:	e8 fc ff ff ff       	call   10f9a <addpkt_recvData+0x27a>
	amTxedBuffer3->pkt = skb3;
   10f9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10fa1:	8b 55 dc             	mov    -0x24(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   10fa4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	amTxedBuffer3->SN = 0x0002;
   10fa7:	66 c7 80 94 00 00 00 	movw   $0x2,0x94(%eax)
   10fae:	02 00 
	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
	fsm_skb_put(skb3,2);
	fsm_mem_cpy(skb3->tail,str3,4);
	fsm_skb_put(skb3,4);
	amTxedBuffer3->pkt = skb3;
   10fb0:	89 10                	mov    %edx,(%eax)
	amTxedBuffer3->SN = 0x0002;
	amTxedBuffer3->pktstatus = ANY_SEGMENT;
   10fb2:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	amTxedBuffer3->headLen = 2;
   10fb9:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer3->datalen = 4;
   10fc0:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   10fc7:	00 00 00 
	amTxedBuffer3->retxCount = -1;
   10fca:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   10fd1:	ff ff 
	amTxedBuffer3->segnum = 1;
   10fd3:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10fda:	00 00 00 
	amTxedBuffer3->pos = 0;
   10fdd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer3->segEnd[0] = 6;
   10fe4:	c7 40 50 06 00 00 00 	movl   $0x6,0x50(%eax)
	amTxedBuffer3->segStart[0] = 2;
   10feb:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   10ff2:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb3->len;
   10ff9:	8b 42 50             	mov    0x50(%edx),%eax
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   10ffc:	8b 55 e8             	mov    -0x18(%ebp),%edx
	amTxedBuffer3->segnum = 1;
	amTxedBuffer3->pos = 0;
	amTxedBuffer3->segEnd[0] = 6;
	amTxedBuffer3->segStart[0] = 2;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
   10fff:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->vt_s++;
   11005:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   1100c:	01 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1100d:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   11013:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11019:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1101f:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)

	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
   11025:	8b 7d d8             	mov    -0x28(%ebp),%edi
	new->prev = prev;
   11028:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   1102e:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   11033:	89 10                	mov    %edx,(%eax)
   11035:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8003;
   11038:	66 c7 45 f2 03 80    	movw   $0x8003,-0xe(%ebp)
	fsm_mem_cpy(skb4->tail,&hdr,2);
   1103e:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   11044:	e8 fc ff ff ff       	call   11045 <addpkt_recvData+0x325>
	fsm_skb_put(skb4,2);
   11049:	ba 02 00 00 00       	mov    $0x2,%edx
   1104e:	89 f8                	mov    %edi,%eax
   11050:	e8 fc ff ff ff       	call   11051 <addpkt_recvData+0x331>
	fsm_mem_cpy(skb4->tail,str4,4);
   11055:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   1105b:	b9 04 00 00 00       	mov    $0x4,%ecx
   11060:	ba fc 08 00 00       	mov    $0x8fc,%edx
   11065:	e8 fc ff ff ff       	call   11066 <addpkt_recvData+0x346>
	fsm_skb_put(skb4,4);
   1106a:	ba 04 00 00 00       	mov    $0x4,%edx
   1106f:	89 f8                	mov    %edi,%eax
   11071:	e8 fc ff ff ff       	call   11072 <addpkt_recvData+0x352>
	amTxedBuffer4->segStart[1] = 8;

	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb4->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
   11076:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
	fsm_skb_put(skb4,2);
	fsm_mem_cpy(skb4->tail,str4,4);
	fsm_skb_put(skb4,4);
	amTxedBuffer4->pkt = skb4;
   1107c:	89 3e                	mov    %edi,(%esi)
	amTxedBuffer4->SN = 0x0003;
   1107e:	66 c7 86 94 00 00 00 	movw   $0x3,0x94(%esi)
   11085:	03 00 
	amTxedBuffer4->pktstatus = ANY_SEGMENT;
   11087:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
	amTxedBuffer4->headLen = 2;
   1108e:	c7 46 0c 02 00 00 00 	movl   $0x2,0xc(%esi)
	amTxedBuffer4->datalen = 4;
   11095:	c7 86 98 00 00 00 04 	movl   $0x4,0x98(%esi)
   1109c:	00 00 00 
	amTxedBuffer4->retxCount = -1;
   1109f:	66 c7 86 96 00 00 00 	movw   $0xffff,0x96(%esi)
   110a6:	ff ff 
	amTxedBuffer4->segnum = 2;
   110a8:	c7 86 90 00 00 00 02 	movl   $0x2,0x90(%esi)
   110af:	00 00 00 
	amTxedBuffer4->pos = 0;
   110b2:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	amTxedBuffer4->segEnd[0] = 7;
   110b9:	c7 46 50 07 00 00 00 	movl   $0x7,0x50(%esi)
	amTxedBuffer4->segStart[0] = 5;
   110c0:	c7 46 10 05 00 00 00 	movl   $0x5,0x10(%esi)
	amTxedBuffer4->segEnd[1] = 10;
   110c7:	c7 46 54 0a 00 00 00 	movl   $0xa,0x54(%esi)
	amTxedBuffer4->segStart[1] = 8;
   110ce:	c7 46 14 08 00 00 00 	movl   $0x8,0x14(%esi)

	amIns->amTransmittedBufferNum++;
   110d5:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb4->len;
   110dc:	8b 47 50             	mov    0x50(%edi),%eax
   110df:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   110e5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   110e8:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   110ee:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   110f5:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   110f6:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   110fc:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
	new->prev = prev;
   11102:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   11108:	89 10                	mov    %edx,(%eax)
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
	fsm_printf("has added data for ctrl_pkt_recv\n");
   1110a:	c7 04 24 0c 3d 00 00 	movl   $0x3d0c,(%esp)
   11111:	e8 fc ff ff ff       	call   11112 <addpkt_recvData+0x3f2>
	FOUT;
}
   11116:	83 c4 20             	add    $0x20,%esp
   11119:	5b                   	pop    %ebx
   1111a:	5e                   	pop    %esi
   1111b:	5f                   	pop    %edi
   1111c:	5d                   	pop    %ebp
   1111d:	c3                   	ret    
   1111e:	66 90                	xchg   %ax,%ax

00011120 <addPktTranData>:

void addPktTranData(struct AM_Instance*amIns)
{
   11120:	55                   	push   %ebp
   11121:	89 e5                	mov    %esp,%ebp
   11123:	57                   	push   %edi
   11124:	56                   	push   %esi
   11125:	53                   	push   %ebx
   11126:	83 ec 0c             	sub    $0xc,%esp
   11129:	e8 fc ff ff ff       	call   1112a <addPktTranData+0xa>
   1112e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	FSM_PKT *skb1 = NULL;
	struct AmBuffer *amRecvBuffer1 = NULL;
	FSM_PKT *skb2 = NULL;
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
   11131:	b8 06 00 00 00       	mov    $0x6,%eax
   11136:	e8 fc ff ff ff       	call   11137 <addPktTranData+0x17>
   1113b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1113e:	b8 a4 00 00 00       	mov    $0xa4,%eax
   11143:	e8 fc ff ff ff       	call   11144 <addPktTranData+0x24>
   11148:	89 c7                	mov    %eax,%edi
	skb2= fsm_pkt_create(2+6);
   1114a:	b8 08 00 00 00       	mov    $0x8,%eax
   1114f:	e8 fc ff ff ff       	call   11150 <addPktTranData+0x30>
   11154:	89 c6                	mov    %eax,%esi
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   11156:	b8 a4 00 00 00       	mov    $0xa4,%eax
   1115b:	e8 fc ff ff ff       	call   1115c <addPktTranData+0x3c>

	unsigned short data = 0x0000;
   11160:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	unsigned short hdr = 0X0000;
   11166:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb2= fsm_pkt_create(2+6);
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1116c:	89 c3                	mov    %eax,%ebx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);
   1116e:	e8 fc ff ff ff       	call   1116f <addPktTranData+0x4f>

	hdr = 0x8000;
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
   11173:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11176:	b9 02 00 00 00       	mov    $0x2,%ecx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);

	hdr = 0x8000;
   1117b:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	data = 0x0001;	
   11181:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
	fsm_mem_cpy(skb1->tail,&hdr,2);
   11187:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   1118d:	8d 55 f2             	lea    -0xe(%ebp),%edx
   11190:	e8 fc ff ff ff       	call   11191 <addPktTranData+0x71>
	fsm_skb_put(skb1,2);
   11195:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11198:	ba 02 00 00 00       	mov    $0x2,%edx
   1119d:	e8 fc ff ff ff       	call   1119e <addPktTranData+0x7e>
	fsm_mem_cpy(skb1->tail,&data,2);
   111a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
   111a5:	b9 02 00 00 00       	mov    $0x2,%ecx
   111aa:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   111b0:	8d 55 f0             	lea    -0x10(%ebp),%edx
   111b3:	e8 fc ff ff ff       	call   111b4 <addPktTranData+0x94>
	fsm_skb_put(skb1,2);
   111b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   111bb:	ba 02 00 00 00       	mov    $0x2,%edx
   111c0:	e8 fc ff ff ff       	call   111c1 <addPktTranData+0xa1>
	amRecvBuffer1->pkt = skb1;
   111c5:	8b 45 e8             	mov    -0x18(%ebp),%eax

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   111c8:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
   111cd:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   111d4:	00 00 

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   111d6:	8d 55 f2             	lea    -0xe(%ebp),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
   111d9:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amRecvBuffer1->headLen = 2;
   111e0:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
   111e7:	89 07                	mov    %eax,(%edi)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   111e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
   111ec:	66 c7 87 96 00 00 00 	movw   $0x0,0x96(%edi)
   111f3:	00 00 
	amRecvBuffer1->segnum = 0;
   111f5:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   111fc:	00 00 00 
	amIns->vr_r++;
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
   111ff:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11205:	66 83 80 f4 22 00 00 	addw   $0x1,0x22f4(%eax)
   1120c:	01 
	amIns->amRecvWindow[0] = amRecvBuffer1;
   1120d:	89 b8 6c 12 00 00    	mov    %edi,0x126c(%eax)

	amIns->amRecvWindow[1] = NULL;
   11213:	c7 80 70 12 00 00 00 	movl   $0x0,0x1270(%eax)
   1121a:	00 00 00 

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   1121d:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
   11223:	66 c7 45 f0 03 00    	movw   $0x3,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11229:	e8 fc ff ff ff       	call   1122a <addPktTranData+0x10a>
	fsm_skb_put(skb2,2);
   1122e:	ba 02 00 00 00       	mov    $0x2,%edx
   11233:	89 f0                	mov    %esi,%eax
   11235:	e8 fc ff ff ff       	call   11236 <addPktTranData+0x116>
	fsm_mem_cpy(skb2->tail,&data,2);
   1123a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   11240:	b9 02 00 00 00       	mov    $0x2,%ecx
   11245:	8d 55 f0             	lea    -0x10(%ebp),%edx
   11248:	e8 fc ff ff ff       	call   11249 <addPktTranData+0x129>
	fsm_skb_put(skb2,2);
   1124d:	ba 02 00 00 00       	mov    $0x2,%edx
   11252:	89 f0                	mov    %esi,%eax
   11254:	e8 fc ff ff ff       	call   11255 <addPktTranData+0x135>
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
   11259:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   1125f:	8d 55 f0             	lea    -0x10(%ebp),%edx
   11262:	b9 02 00 00 00       	mov    $0x2,%ecx
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);
	data = 0x0004;
   11267:	66 c7 45 f0 04 00    	movw   $0x4,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&data,2);
   1126d:	e8 fc ff ff ff       	call   1126e <addPktTranData+0x14e>
	fsm_skb_put(skb2,2);
   11272:	89 f0                	mov    %esi,%eax
   11274:	ba 02 00 00 00       	mov    $0x2,%edx
   11279:	e8 fc ff ff ff       	call   1127a <addPktTranData+0x15a>
	amRecvBuffer2->segEnd[0] = 1;
	amRecvBuffer2->segStart[1] = -1;
	amRecvBuffer2->segEnd[1] = -1;
	amRecvBuffer2->segStart[2] = -1;
	amRecvBuffer2->segEnd[2] = -1;
	amIns->amRecvWindow[2] = amRecvBuffer2;
   1127e:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb2,2);
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);

	amRecvBuffer2->pkt = skb2;
   11281:	89 33                	mov    %esi,(%ebx)
	amRecvBuffer2->SN = 0x0002;
   11283:	66 c7 83 94 00 00 00 	movw   $0x2,0x94(%ebx)
   1128a:	02 00 
	amRecvBuffer2->pktstatus = 2;
   1128c:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	amRecvBuffer2->headLen = 2;
   11293:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amRecvBuffer2->retxCount = 0;
   1129a:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   112a1:	00 00 
	amRecvBuffer2->segnum = 3;
   112a3:	c7 83 90 00 00 00 03 	movl   $0x3,0x90(%ebx)
   112aa:	00 00 00 
	amRecvBuffer2->segStart[0] = 0;
   112ad:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	amRecvBuffer2->segEnd[0] = 1;
   112b4:	c7 43 50 01 00 00 00 	movl   $0x1,0x50(%ebx)
	amRecvBuffer2->segStart[1] = -1;
   112bb:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
	amRecvBuffer2->segEnd[1] = -1;
   112c2:	c7 43 54 ff ff ff ff 	movl   $0xffffffff,0x54(%ebx)
	amRecvBuffer2->segStart[2] = -1;
   112c9:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
	amRecvBuffer2->segEnd[2] = -1;
   112d0:	c7 43 58 ff ff ff ff 	movl   $0xffffffff,0x58(%ebx)
	amIns->amRecvWindow[2] = amRecvBuffer2;
   112d7:	89 98 74 12 00 00    	mov    %ebx,0x1274(%eax)
	amIns->vr_h = 3;
   112dd:	66 c7 80 ee 22 00 00 	movw   $0x3,0x22ee(%eax)
   112e4:	03 00 
	amIns->vr_ms = 1;
   112e6:	66 c7 80 f2 22 00 00 	movw   $0x1,0x22f2(%eax)
   112ed:	01 00 
   112ef:	83 c4 0c             	add    $0xc,%esp
   112f2:	5b                   	pop    %ebx
   112f3:	5e                   	pop    %esi
   112f4:	5f                   	pop    %edi
   112f5:	5d                   	pop    %ebp
   112f6:	c3                   	ret    
   112f7:	90                   	nop
   112f8:	90                   	nop
   112f9:	90                   	nop
   112fa:	90                   	nop
   112fb:	90                   	nop
   112fc:	90                   	nop
   112fd:	90                   	nop
   112fe:	90                   	nop
   112ff:	90                   	nop

00011300 <Assemble_ctrlPduPart2>:
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11300:	55                   	push   %ebp
   11301:	89 e5                	mov    %esp,%ebp
   11303:	57                   	push   %edi
   11304:	56                   	push   %esi
   11305:	53                   	push   %ebx
   11306:	83 ec 1c             	sub    $0x1c,%esp
   11309:	e8 fc ff ff ff       	call   1130a <Assemble_ctrlPduPart2+0xa>
   1130e:	89 c7                	mov    %eax,%edi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11310:	b8 02 00 00 00       	mov    $0x2,%eax
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11315:	89 ce                	mov    %ecx,%esi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11317:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1131a:	e8 fc ff ff ff       	call   1131b <Assemble_ctrlPduPart2+0x1b>
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1131f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11322:	89 d1                	mov    %edx,%ecx
   11324:	c1 e1 06             	shl    $0x6,%ecx
   11327:	66 c1 ea 02          	shr    $0x2,%dx
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   1132b:	89 c3                	mov    %eax,%ebx
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1132d:	88 50 01             	mov    %dl,0x1(%eax)
	part2->E2 = 1;	
   11330:	89 c8                	mov    %ecx,%eax
   11332:	83 c8 10             	or     $0x10,%eax
   11335:	88 45 eb             	mov    %al,-0x15(%ebp)
   11338:	88 03                	mov    %al,(%ebx)
	if (*pduLen + 6 < size)
   1133a:	8b 06                	mov    (%esi),%eax
   1133c:	8d 50 06             	lea    0x6(%eax),%edx
   1133f:	89 55 f0             	mov    %edx,-0x10(%ebp)
   11342:	8b 55 08             	mov    0x8(%ebp),%edx
   11345:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   11348:	73 66                	jae    113b0 <Assemble_ctrlPduPart2+0xb0>
	{
		part2->E1 =1;
   1134a:	83 c9 30             	or     $0x30,%ecx
   1134d:	ba 01 00 00 00       	mov    $0x1,%edx
   11352:	88 0b                	mov    %cl,(%ebx)
   11354:	8b 06                	mov    (%esi),%eax
	}
	else if (*pduLen + 6 == size)
	{
		part2->E1 =0;
	}
	fsm_printf("[RLC][Assemble_ctrlPduPart2] pdulen = %d, size = %d, E1 = %d\n",*pduLen,size,part2->E1);
   11356:	89 54 24 0c          	mov    %edx,0xc(%esp)
   1135a:	8b 55 08             	mov    0x8(%ebp),%edx
   1135d:	89 44 24 04          	mov    %eax,0x4(%esp)
   11361:	c7 04 24 30 3d 00 00 	movl   $0x3d30,(%esp)
   11368:	89 54 24 08          	mov    %edx,0x8(%esp)
   1136c:	e8 fc ff ff ff       	call   1136d <Assemble_ctrlPduPart2+0x6d>
	*(u16 *)part2 = htons(*(u16 *)part2);
	fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   11371:	b9 02 00 00 00       	mov    $0x2,%ecx
   11376:	89 da                	mov    %ebx,%edx
   11378:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1137c:	8b 07                	mov    (%edi),%eax
   1137e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11384:	e8 fc ff ff ff       	call   11385 <Assemble_ctrlPduPart2+0x85>
	fsm_skb_put(ctrlBf->pkt,2);
   11389:	8b 07                	mov    (%edi),%eax
   1138b:	ba 02 00 00 00       	mov    $0x2,%edx
   11390:	e8 fc ff ff ff       	call   11391 <Assemble_ctrlPduPart2+0x91>
	*pduLen += 2;
   11395:	83 06 02             	addl   $0x2,(%esi)
	if ( part2 != NULL )
   11398:	85 db                	test   %ebx,%ebx
   1139a:	74 07                	je     113a3 <Assemble_ctrlPduPart2+0xa3>
	{
		fsm_mem_free(part2);
   1139c:	89 d8                	mov    %ebx,%eax
   1139e:	e8 fc ff ff ff       	call   1139f <Assemble_ctrlPduPart2+0x9f>
		part2=NULL;
	}
}
   113a3:	83 c4 1c             	add    $0x1c,%esp
   113a6:	5b                   	pop    %ebx
   113a7:	5e                   	pop    %esi
   113a8:	5f                   	pop    %edi
   113a9:	5d                   	pop    %ebp
   113aa:	c3                   	ret    
   113ab:	90                   	nop
   113ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	part2->E2 = 1;	
	if (*pduLen + 6 < size)
	{
		part2->E1 =1;
	}
	else if (*pduLen + 6 == size)
   113b0:	74 06                	je     113b8 <Assemble_ctrlPduPart2+0xb8>
	{
		part2->E1 =0;
   113b2:	31 d2                	xor    %edx,%edx
   113b4:	eb a0                	jmp    11356 <Assemble_ctrlPduPart2+0x56>
   113b6:	66 90                	xchg   %ax,%ax
   113b8:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   113bc:	83 e2 df             	and    $0xffffffdf,%edx
   113bf:	88 13                	mov    %dl,(%ebx)
   113c1:	31 d2                	xor    %edx,%edx
   113c3:	8b 06                	mov    (%esi),%eax
   113c5:	eb 8f                	jmp    11356 <Assemble_ctrlPduPart2+0x56>
   113c7:	89 f6                	mov    %esi,%esi
   113c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000113d0 <size_of_ctrl_pdu>:
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
{
   113d0:	55                   	push   %ebp
   113d1:	89 e5                	mov    %esp,%ebp
   113d3:	57                   	push   %edi
   113d4:	56                   	push   %esi
   113d5:	53                   	push   %ebx
   113d6:	83 ec 0c             	sub    $0xc,%esp
   113d9:	e8 fc ff ff ff       	call   113da <size_of_ctrl_pdu+0xa>
	u32 size = 0;
	int i;
	//PDU
	size = 2;  //
   113de:	bb 02 00 00 00       	mov    $0x2,%ebx
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
   113e3:	0f bf 90 ee 22 00 00 	movswl 0x22ee(%eax),%edx
   113ea:	0f bf 88 f4 22 00 00 	movswl 0x22f4(%eax),%ecx
   113f1:	83 ea 01             	sub    $0x1,%edx
   113f4:	39 d1                	cmp    %edx,%ecx
   113f6:	7c 20                	jl     11418 <size_of_ctrl_pdu+0x48>
					}
				}
			}
		}
	}
	fsm_printf("[RLC][size_of_ctrl_pdu] size of ctrl pdu is %d\n",size);
   113f8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
   113fc:	c7 04 24 70 3d 00 00 	movl   $0x3d70,(%esp)
   11403:	e8 fc ff ff ff       	call   11404 <size_of_ctrl_pdu+0x34>
	return size;
}
   11408:	89 d8                	mov    %ebx,%eax
   1140a:	83 c4 0c             	add    $0xc,%esp
   1140d:	5b                   	pop    %ebx
   1140e:	5e                   	pop    %esi
   1140f:	5f                   	pop    %edi
   11410:	5d                   	pop    %ebp
   11411:	c3                   	ret    
   11412:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   11418:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
   1141f:	39 d1                	cmp    %edx,%ecx
   11421:	7d d5                	jge    113f8 <size_of_ctrl_pdu+0x28>
**Created Date: 2014/10/15
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
   11423:	29 ca                	sub    %ecx,%edx
   11425:	c1 e2 02             	shl    $0x2,%edx
   11428:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1142b:	8d 3c 88             	lea    (%eax,%ecx,4),%edi
   1142e:	31 d2                	xor    %edx,%edx
   11430:	eb 13                	jmp    11445 <size_of_ctrl_pdu+0x75>
   11432:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
   11438:	83 f9 03             	cmp    $0x3,%ecx
   1143b:	74 43                	je     11480 <size_of_ctrl_pdu+0xb0>
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   1143d:	83 c2 04             	add    $0x4,%edx
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   11440:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   11443:	74 b3                	je     113f8 <size_of_ctrl_pdu+0x28>
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
   11445:	8b 84 17 6c 12 00 00 	mov    0x126c(%edi,%edx,1),%eax
   1144c:	85 c0                	test   %eax,%eax
   1144e:	74 28                	je     11478 <size_of_ctrl_pdu+0xa8>
			{
				size += 2;//2
			}
			else //PDU
			{
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)
   11450:	8b 48 04             	mov    0x4(%eax),%ecx
   11453:	83 f9 01             	cmp    $0x1,%ecx
   11456:	74 e5                	je     1143d <size_of_ctrl_pdu+0x6d>
				{
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{
						size += 6;//soendsostart6
   11458:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   1145c:	8d 73 06             	lea    0x6(%ebx),%esi
   1145f:	0f 4f de             	cmovg  %esi,%ebx
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
   11462:	83 f9 02             	cmp    $0x2,%ecx
   11465:	75 d1                	jne    11438 <size_of_ctrl_pdu+0x68>
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
   11467:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   1146d:	8d 04 40             	lea    (%eax,%eax,2),%eax
   11470:	8d 5c 43 fa          	lea    -0x6(%ebx,%eax,2),%ebx
   11474:	eb c7                	jmp    1143d <size_of_ctrl_pdu+0x6d>
   11476:	66 90                	xchg   %ax,%ax
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
			{
				size += 2;//2
   11478:	83 c3 02             	add    $0x2,%ebx
   1147b:	eb c0                	jmp    1143d <size_of_ctrl_pdu+0x6d>
   1147d:	8d 76 00             	lea    0x0(%esi),%esi
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   11480:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   11486:	8d 04 40             	lea    (%eax,%eax,2),%eax
   11489:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
   1148c:	eb af                	jmp    1143d <size_of_ctrl_pdu+0x6d>
   1148e:	66 90                	xchg   %ax,%ax

00011490 <rlc_ctrl_pkt_trans>:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   11490:	55                   	push   %ebp
   11491:	89 e5                	mov    %esp,%ebp
   11493:	57                   	push   %edi
   11494:	56                   	push   %esi
   11495:	53                   	push   %ebx
   11496:	83 ec 30             	sub    $0x30,%esp
   11499:	e8 fc ff ff ff       	call   1149a <rlc_ctrl_pkt_trans+0xa>
   1149e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32 pduLen;
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
   114a1:	c7 04 24 a0 3d 00 00 	movl   $0x3da0,(%esp)
   114a8:	e8 fc ff ff ff       	call   114a9 <rlc_ctrl_pkt_trans+0x19>
	pduLen = 0;
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   114ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
	pduLen = 0;
   114b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   114b7:	e8 fc ff ff ff       	call   114b8 <rlc_ctrl_pkt_trans+0x28>
   114bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
   114bf:	89 44 24 04          	mov    %eax,0x4(%esp)
   114c3:	c7 04 24 dc 3d 00 00 	movl   $0x3ddc,(%esp)
   114ca:	e8 fc ff ff ff       	call   114cb <rlc_ctrl_pkt_trans+0x3b>
	if( size < 2)  //PDU2
   114cf:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
   114d3:	0f 86 fc 04 00 00    	jbe    119d5 <rlc_ctrl_pkt_trans+0x545>
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
   114d9:	b8 0c 00 00 00       	mov    $0xc,%eax
   114de:	e8 fc ff ff ff       	call   114df <rlc_ctrl_pkt_trans+0x4f>
   114e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	memset(ctrlBf,0,sizeof(struct Buffer));
   114e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   114ec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   114f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ctrlBf->pkt = fsm_pkt_create(size);
   114fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   114fd:	e8 fc ff ff ff       	call   114fe <rlc_ctrl_pkt_trans+0x6e>
   11502:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11505:	89 02                	mov    %eax,(%edx)
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11507:	b8 02 00 00 00       	mov    $0x2,%eax
   1150c:	e8 fc ff ff ff       	call   1150d <rlc_ctrl_pkt_trans+0x7d>
	memset(part1,0,sizeof(ctrlPduPart1));
   11511:	66 c7 00 00 00       	movw   $0x0,(%eax)
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
	memset(ctrlBf,0,sizeof(struct Buffer));
	ctrlBf->pkt = fsm_pkt_create(size);
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11516:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	part1->D_C = 0;
	part1->CPT = 0;
   11518:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	part1->ACK_SN = amIns->vr_ms;	
   1151c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1151f:	0f b6 90 f2 22 00 00 	movzbl 0x22f2(%eax),%edx
   11526:	0f b6 03             	movzbl (%ebx),%eax
   11529:	c1 e2 02             	shl    $0x2,%edx
   1152c:	83 e0 03             	and    $0x3,%eax
   1152f:	09 d0                	or     %edx,%eax
   11531:	88 03                	mov    %al,(%ebx)
   11533:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11536:	0f b7 82 f2 22 00 00 	movzwl 0x22f2(%edx),%eax
   1153d:	66 c1 e8 06          	shr    $0x6,%ax
   11541:	83 e0 0f             	and    $0xf,%eax
   11544:	88 43 01             	mov    %al,0x1(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
   11547:	0f bf 82 f2 22 00 00 	movswl 0x22f2(%edx),%eax
   1154e:	c7 04 24 30 3e 00 00 	movl   $0x3e30,(%esp)
   11555:	89 44 24 04          	mov    %eax,0x4(%esp)
   11559:	e8 fc ff ff ff       	call   1155a <rlc_ctrl_pkt_trans+0xca>
	fsm_octets_print(part1,2);
   1155e:	ba 02 00 00 00       	mov    $0x2,%edx
   11563:	89 d8                	mov    %ebx,%eax
   11565:	e8 fc ff ff ff       	call   11566 <rlc_ctrl_pkt_trans+0xd6>
	if( size == 2 )  //PDU
   1156a:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
   1156e:	0f 84 9b 02 00 00    	je     1180f <rlc_ctrl_pkt_trans+0x37f>
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
   11574:	c7 04 24 58 3e 00 00 	movl   $0x3e58,(%esp)
   1157b:	e8 fc ff ff ff       	call   1157c <rlc_ctrl_pkt_trans+0xec>
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11580:	b9 02 00 00 00       	mov    $0x2,%ecx
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
   11585:	80 0b 02             	orb    $0x2,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11588:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1158b:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1158f:	8b 02                	mov    (%edx),%eax
   11591:	89 da                	mov    %ebx,%edx
   11593:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11599:	e8 fc ff ff ff       	call   1159a <rlc_ctrl_pkt_trans+0x10a>
		fsm_skb_put(ctrlBf->pkt,2);
   1159e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   115a1:	ba 02 00 00 00       	mov    $0x2,%edx
   115a6:	8b 01                	mov    (%ecx),%eax
   115a8:	e8 fc ff ff ff       	call   115a9 <rlc_ctrl_pkt_trans+0x119>
		pduLen += 2;
   115ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   115b0:	83 c0 02             	add    $0x2,%eax
		if( part1 != NULL )
   115b3:	85 db                	test   %ebx,%ebx
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
   115b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if( part1 != NULL )
   115b8:	74 0a                	je     115c4 <rlc_ctrl_pkt_trans+0x134>
		{
			fsm_mem_free(part1);
   115ba:	89 d8                	mov    %ebx,%eax
   115bc:	e8 fc ff ff ff       	call   115bd <rlc_ctrl_pkt_trans+0x12d>
   115c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
   115c4:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   115c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
   115cb:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   115d2:	89 44 24 08          	mov    %eax,0x8(%esp)
   115d6:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
   115dd:	c7 04 24 84 3e 00 00 	movl   $0x3e84,(%esp)
   115e4:	89 44 24 04          	mov    %eax,0x4(%esp)
   115e8:	e8 fc ff ff ff       	call   115e9 <rlc_ctrl_pkt_trans+0x159>
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   115ed:	0f b7 83 f4 22 00 00 	movzwl 0x22f4(%ebx),%eax
   115f4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   115f7:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   115fa:	0f bf d0             	movswl %ax,%edx
   115fd:	0f 83 3d 02 00 00    	jae    11840 <rlc_ctrl_pkt_trans+0x3b0>
   11603:	0f bf 8b f2 22 00 00 	movswl 0x22f2(%ebx),%ecx
   1160a:	39 ca                	cmp    %ecx,%edx
   1160c:	0f 8d 2e 02 00 00    	jge    11840 <rlc_ctrl_pkt_trans+0x3b0>
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11612:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11615:	8d 5a 01             	lea    0x1(%edx),%ebx
   11618:	89 5d dc             	mov    %ebx,-0x24(%ebp)
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1161b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   1161f:	8d b4 91 6c 12 00 00 	lea    0x126c(%ecx,%edx,4),%esi
   11626:	66 90                	xchg   %ax,%ax
   11628:	8b 45 dc             	mov    -0x24(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   1162b:	c7 04 24 c4 3e 00 00 	movl   $0x3ec4,(%esp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11632:	83 e8 01             	sub    $0x1,%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   11635:	89 44 24 04          	mov    %eax,0x4(%esp)
   11639:	e8 fc ff ff ff       	call   1163a <rlc_ctrl_pkt_trans+0x1aa>
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
   1163e:	8b 0e                	mov    (%esi),%ecx
   11640:	85 c9                	test   %ecx,%ecx
   11642:	0f 84 f8 02 00 00    	je     11940 <rlc_ctrl_pkt_trans+0x4b0>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] != NULL\n");
   11648:	c7 04 24 24 3f 00 00 	movl   $0x3f24,(%esp)
   1164f:	e8 fc ff ff ff       	call   11650 <rlc_ctrl_pkt_trans+0x1c0>
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
   11654:	8b 06                	mov    (%esi),%eax
   11656:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   1165a:	0f 84 80 01 00 00    	je     117e0 <rlc_ctrl_pkt_trans+0x350>
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
   11660:	8b 50 10             	mov    0x10(%eax),%edx
   11663:	85 d2                	test   %edx,%edx
   11665:	0f 8e 8d 00 00 00    	jle    116f8 <rlc_ctrl_pkt_trans+0x268>
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
   1166b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1166e:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   11671:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   11675:	89 04 24             	mov    %eax,(%esp)
   11678:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1167b:	e8 fc ff ff ff       	call   1167c <rlc_ctrl_pkt_trans+0x1ec>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11680:	b8 04 00 00 00       	mov    $0x4,%eax
   11685:	e8 fc ff ff ff       	call   11686 <rlc_ctrl_pkt_trans+0x1f6>
						memset(part3,0,sizeof(ctrlPduPart3));
   1168a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11690:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
   11692:	c6 40 02 00          	movb   $0x0,0x2(%eax)
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   11696:	8b 06                	mov    (%esi),%eax
   11698:	8b 50 10             	mov    0x10(%eax),%edx
   1169b:	0f b6 03             	movzbl (%ebx),%eax
   1169e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
   116a5:	83 e0 03             	and    $0x3,%eax
   116a8:	09 c8                	or     %ecx,%eax
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   116aa:	b9 04 00 00 00       	mov    $0x4,%ecx
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   116af:	88 03                	mov    %al,(%ebx)
   116b1:	89 d0                	mov    %edx,%eax
   116b3:	66 c1 e8 06          	shr    $0x6,%ax
   116b7:	88 43 01             	mov    %al,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   116ba:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   116bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   116c0:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
						*(u32 *)part3 = htons(*(u32 *)part3);
   116c4:	0f b7 c0             	movzwl %ax,%eax
   116c7:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   116c9:	8b 02                	mov    (%edx),%eax
   116cb:	89 da                	mov    %ebx,%edx
   116cd:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   116d3:	e8 fc ff ff ff       	call   116d4 <rlc_ctrl_pkt_trans+0x244>
						fsm_skb_put(ctrlBf->pkt,4);
   116d8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   116db:	ba 04 00 00 00       	mov    $0x4,%edx
   116e0:	8b 01                	mov    (%ecx),%eax
   116e2:	e8 fc ff ff ff       	call   116e3 <rlc_ctrl_pkt_trans+0x253>
						pduLen += 4;
   116e7:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   116eb:	85 db                	test   %ebx,%ebx
   116ed:	74 07                	je     116f6 <rlc_ctrl_pkt_trans+0x266>
						{
							fsm_mem_free(part3);
   116ef:	89 d8                	mov    %ebx,%eax
   116f1:	e8 fc ff ff ff       	call   116f2 <rlc_ctrl_pkt_trans+0x262>
   116f6:	8b 06                	mov    (%esi),%eax
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   116f8:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   116fe:	31 ff                	xor    %edi,%edi
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11700:	0f bf 5d e8          	movswl -0x18(%ebp),%ebx
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11704:	83 ea 01             	sub    $0x1,%edx
   11707:	39 d7                	cmp    %edx,%edi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11709:	89 5d e0             	mov    %ebx,-0x20(%ebp)
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   1170c:	0f 83 c4 00 00 00    	jae    117d6 <rlc_ctrl_pkt_trans+0x346>
   11712:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11718:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1171b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1171e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11721:	89 04 24             	mov    %eax,(%esp)
   11724:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11727:	e8 fc ff ff ff       	call   11728 <rlc_ctrl_pkt_trans+0x298>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1172c:	b8 04 00 00 00       	mov    $0x4,%eax
   11731:	e8 fc ff ff ff       	call   11732 <rlc_ctrl_pkt_trans+0x2a2>
						memset(part3,0,sizeof(ctrlPduPart3));
   11736:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1173c:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   1173e:	8b 06                	mov    (%esi),%eax
   11740:	8b 54 b8 50          	mov    0x50(%eax,%edi,4),%edx
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   11744:	83 c7 01             	add    $0x1,%edi
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   11747:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
   1174b:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
   1174e:	83 e0 01             	and    $0x1,%eax
   11751:	09 c8                	or     %ecx,%eax
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11753:	b9 04 00 00 00       	mov    $0x4,%ecx
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   11758:	66 c1 ea 07          	shr    $0x7,%dx
   1175c:	88 43 02             	mov    %al,0x2(%ebx)
   1175f:	88 53 03             	mov    %dl,0x3(%ebx)
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   11762:	8b 16                	mov    (%esi),%edx
   11764:	8b 54 ba 10          	mov    0x10(%edx,%edi,4),%edx
   11768:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   1176b:	c1 e2 02             	shl    $0x2,%edx
   1176e:	88 55 eb             	mov    %dl,-0x15(%ebp)
   11771:	0f b6 13             	movzbl (%ebx),%edx
   11774:	83 e2 03             	and    $0x3,%edx
   11777:	0a 55 eb             	or     -0x15(%ebp),%dl
   1177a:	88 13                	mov    %dl,(%ebx)
   1177c:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
   11780:	66 c1 ea 06          	shr    $0x6,%dx
   11784:	88 53 01             	mov    %dl,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   11787:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1178a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1178d:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
   11791:	0f b7 c0             	movzwl %ax,%eax
   11794:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11796:	8b 02                	mov    (%edx),%eax
   11798:	89 da                	mov    %ebx,%edx
   1179a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   117a0:	e8 fc ff ff ff       	call   117a1 <rlc_ctrl_pkt_trans+0x311>
						fsm_skb_put(ctrlBf->pkt,4);
   117a5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   117a8:	ba 04 00 00 00       	mov    $0x4,%edx
   117ad:	8b 01                	mov    (%ecx),%eax
   117af:	e8 fc ff ff ff       	call   117b0 <rlc_ctrl_pkt_trans+0x320>
						pduLen += 4;
   117b4:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   117b8:	85 db                	test   %ebx,%ebx
   117ba:	74 07                	je     117c3 <rlc_ctrl_pkt_trans+0x333>
						{
							fsm_mem_free(part3);
   117bc:	89 d8                	mov    %ebx,%eax
   117be:	e8 fc ff ff ff       	call   117bf <rlc_ctrl_pkt_trans+0x32f>
   117c3:	8b 06                	mov    (%esi),%eax
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   117c5:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   117cb:	83 ea 01             	sub    $0x1,%edx
   117ce:	39 d7                	cmp    %edx,%edi
   117d0:	0f 82 42 ff ff ff    	jb     11718 <rlc_ctrl_pkt_trans+0x288>
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
   117d6:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
   117da:	0f 84 e1 00 00 00    	je     118c1 <rlc_ctrl_pkt_trans+0x431>
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
						if( part3 != NULL )
						{
							fsm_mem_free(part3);
   117e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   117e3:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   117e6:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
   117e9:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   117f0:	0f 97 c2             	seta   %dl
   117f3:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   117f6:	0f 9f c0             	setg   %al
   117f9:	83 c6 04             	add    $0x4,%esi
   117fc:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   11800:	66 83 45 e8 01       	addw   $0x1,-0x18(%ebp)
   11805:	84 c2                	test   %al,%dl
   11807:	0f 85 1b fe ff ff    	jne    11628 <rlc_ctrl_pkt_trans+0x198>
   1180d:	eb 31                	jmp    11840 <rlc_ctrl_pkt_trans+0x3b0>
	part1->ACK_SN = amIns->vr_ms;	
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
	fsm_octets_print(part1,2);
	if( size == 2 )  //PDU
	{
		part1->E1 = 0;
   1180f:	80 23 fd             	andb   $0xfd,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11812:	89 da                	mov    %ebx,%edx
   11814:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11817:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1181b:	8b 01                	mov    (%ecx),%eax
   1181d:	b9 02 00 00 00       	mov    $0x2,%ecx
   11822:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11828:	e8 fc ff ff ff       	call   11829 <rlc_ctrl_pkt_trans+0x399>
		fsm_skb_put(ctrlBf->pkt,2);
   1182d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   11830:	ba 02 00 00 00       	mov    $0x2,%edx
   11835:	8b 03                	mov    (%ebx),%eax
   11837:	e8 fc ff ff ff       	call   11838 <rlc_ctrl_pkt_trans+0x3a8>
		pduLen += 2;
   1183c:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   11840:	8b 45 d8             	mov    -0x28(%ebp),%eax
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   11843:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11846:	8b 5d d8             	mov    -0x28(%ebp),%ebx
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   11849:	8b 90 bc 01 00 00    	mov    0x1bc(%eax),%edx
   1184f:	83 c2 01             	add    $0x1,%edx
   11852:	89 90 bc 01 00 00    	mov    %edx,0x1bc(%eax)
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   11858:	8b 01                	mov    (%ecx),%eax
   1185a:	8b 40 50             	mov    0x50(%eax),%eax
   1185d:	03 83 b8 01 00 00    	add    0x1b8(%ebx),%eax
   11863:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
   11869:	89 54 24 04          	mov    %edx,0x4(%esp)
   1186d:	89 44 24 08          	mov    %eax,0x8(%esp)
   11871:	c7 04 24 60 3f 00 00 	movl   $0x3f60,(%esp)
   11878:	e8 fc ff ff ff       	call   11879 <rlc_ctrl_pkt_trans+0x3e9>
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
   1187d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11880:	89 d9                	mov    %ebx,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11882:	8b 83 b4 01 00 00    	mov    0x1b4(%ebx),%eax
   11888:	81 c1 b0 01 00 00    	add    $0x1b0,%ecx
   1188e:	83 c2 04             	add    $0x4,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11891:	89 93 b4 01 00 00    	mov    %edx,0x1b4(%ebx)
   11897:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	new->next = next;
	new->prev = prev;
   1189a:	89 43 08             	mov    %eax,0x8(%ebx)
   1189d:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = new;
   118a0:	89 10                	mov    %edx,(%eax)
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
   118a2:	8b 03                	mov    (%ebx),%eax
   118a4:	8b 50 50             	mov    0x50(%eax),%edx
   118a7:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   118ad:	e8 fc ff ff ff       	call   118ae <rlc_ctrl_pkt_trans+0x41e>
	amIns->statFlag = false;
   118b2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   118b5:	c6 40 06 00          	movb   $0x0,0x6(%eax)
	FOUT;
}
   118b9:	83 c4 30             	add    $0x30,%esp
   118bc:	5b                   	pop    %ebx
   118bd:	5e                   	pop    %esi
   118be:	5f                   	pop    %edi
   118bf:	5d                   	pop    %ebp
   118c0:	c3                   	ret    
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   118c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118c4:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   118c7:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   118cb:	89 04 24             	mov    %eax,(%esp)
   118ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118d1:	e8 fc ff ff ff       	call   118d2 <rlc_ctrl_pkt_trans+0x442>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   118d6:	b8 04 00 00 00       	mov    $0x4,%eax
   118db:	e8 fc ff ff ff       	call   118dc <rlc_ctrl_pkt_trans+0x44c>
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   118e0:	b9 04 00 00 00       	mov    $0x4,%ecx
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
   118e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   118eb:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
   118ed:	80 08 fc             	orb    $0xfc,(%eax)
   118f0:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
						*(u32 *)part3 = htons(*(u32 *)part3);
   118f4:	0f b7 00             	movzwl (%eax),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   118f7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   118fa:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
   118fe:	0f b7 c0             	movzwl %ax,%eax
   11901:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11903:	8b 02                	mov    (%edx),%eax
   11905:	89 da                	mov    %ebx,%edx
   11907:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1190d:	e8 fc ff ff ff       	call   1190e <rlc_ctrl_pkt_trans+0x47e>
						fsm_skb_put(ctrlBf->pkt,4);
   11912:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11915:	ba 04 00 00 00       	mov    $0x4,%edx
   1191a:	8b 01                	mov    (%ecx),%eax
   1191c:	e8 fc ff ff ff       	call   1191d <rlc_ctrl_pkt_trans+0x48d>
						pduLen += 4;
   11921:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11924:	83 c0 04             	add    $0x4,%eax
						if( part3 != NULL )
   11927:	85 db                	test   %ebx,%ebx
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
   11929:	89 45 f0             	mov    %eax,-0x10(%ebp)
						if( part3 != NULL )
   1192c:	0f 84 b1 fe ff ff    	je     117e3 <rlc_ctrl_pkt_trans+0x353>
						{
							fsm_mem_free(part3);
   11932:	89 d8                	mov    %ebx,%eax
   11934:	e8 fc ff ff ff       	call   11935 <rlc_ctrl_pkt_trans+0x4a5>
   11939:	e9 a2 fe ff ff       	jmp    117e0 <rlc_ctrl_pkt_trans+0x350>
   1193e:	66 90                	xchg   %ax,%ax
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] == NULL\n");
   11940:	c7 04 24 e8 3e 00 00 	movl   $0x3ee8,(%esp)
   11947:	e8 fc ff ff ff       	call   11948 <rlc_ctrl_pkt_trans+0x4b8>
				if( pduLen+2<=size )
   1194c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1194f:	8d 50 02             	lea    0x2(%eax),%edx
   11952:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
   11955:	0f 82 88 fe ff ff    	jb     117e3 <rlc_ctrl_pkt_trans+0x353>
				{
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   1195b:	b8 02 00 00 00       	mov    $0x2,%eax
   11960:	e8 fc ff ff ff       	call   11961 <rlc_ctrl_pkt_trans+0x4d1>
   11965:	89 c3                	mov    %eax,%ebx
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
   11967:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   1196b:	c1 e0 06             	shl    $0x6,%eax
   1196e:	88 03                	mov    %al,(%ebx)
   11970:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   11974:	66 c1 ea 02          	shr    $0x2,%dx
   11978:	88 53 01             	mov    %dl,0x1(%ebx)
					if( pduLen+2==size )
   1197b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1197e:	83 c2 02             	add    $0x2,%edx
   11981:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
   11984:	74 48                	je     119ce <rlc_ctrl_pkt_trans+0x53e>
					{
						part2->E1=0; //E11
					}
					else
					{
						part2->E1=1;
   11986:	83 c8 20             	or     $0x20,%eax
   11989:	88 03                	mov    %al,(%ebx)
					}
					part2->E2=0;
   1198b:	80 23 ef             	andb   $0xef,(%ebx)
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   1198e:	b9 02 00 00 00       	mov    $0x2,%ecx
   11993:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11996:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1199a:	8b 02                	mov    (%edx),%eax
   1199c:	89 da                	mov    %ebx,%edx
   1199e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   119a4:	e8 fc ff ff ff       	call   119a5 <rlc_ctrl_pkt_trans+0x515>
					fsm_skb_put(ctrlBf->pkt,2);
   119a9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   119ac:	ba 02 00 00 00       	mov    $0x2,%edx
   119b1:	8b 01                	mov    (%ecx),%eax
   119b3:	e8 fc ff ff ff       	call   119b4 <rlc_ctrl_pkt_trans+0x524>
					pduLen += 2;
   119b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   119bb:	83 c0 02             	add    $0x2,%eax
					if( part2 != NULL )
   119be:	85 db                	test   %ebx,%ebx
					}
					part2->E2=0;
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
					fsm_skb_put(ctrlBf->pkt,2);
					pduLen += 2;
   119c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if( part2 != NULL )
   119c3:	0f 85 69 ff ff ff    	jne    11932 <rlc_ctrl_pkt_trans+0x4a2>
   119c9:	e9 15 fe ff ff       	jmp    117e3 <rlc_ctrl_pkt_trans+0x353>
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
					if( pduLen+2==size )
					{
						part2->E1=0; //E11
   119ce:	83 e0 df             	and    $0xffffffdf,%eax
   119d1:	88 03                	mov    %al,(%ebx)
   119d3:	eb b6                	jmp    1198b <rlc_ctrl_pkt_trans+0x4fb>
	size = 0;
	size = size_of_ctrl_pdu(amIns);
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
	if( size < 2)  //PDU2
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
   119d5:	c7 04 24 04 3e 00 00 	movl   $0x3e04,(%esp)
   119dc:	e8 fc ff ff ff       	call   119dd <rlc_ctrl_pkt_trans+0x54d>
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
	amIns->statFlag = false;
	FOUT;
}
   119e1:	83 c4 30             	add    $0x30,%esp
   119e4:	5b                   	pop    %ebx
   119e5:	5e                   	pop    %esi
   119e6:	5f                   	pop    %edi
   119e7:	5d                   	pop    %ebp
   119e8:	c3                   	ret    
   119e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000119f0 <ack_handler>:
**----------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014/10/13
**********************************************************************************************/
void ack_handler(struct AM_Instance *amIns,SequenceNumber ackSn)   //20141013
{
   119f0:	55                   	push   %ebp
   119f1:	89 e5                	mov    %esp,%ebp
   119f3:	57                   	push   %edi
   119f4:	56                   	push   %esi
   119f5:	53                   	push   %ebx
   119f6:	83 ec 10             	sub    $0x10,%esp
   119f9:	e8 fc ff ff ff       	call   119fa <ack_handler+0xa>
   119fe:	89 c3                	mov    %eax,%ebx
   11a00:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11a04:	0f b7 90 66 12 00 00 	movzwl 0x1266(%eax),%edx
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11a0b:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
   11a0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11a12:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
   11a18:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11a1b:	90                   	nop
   11a1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11a20:	66 39 55 ee          	cmp    %dx,-0x12(%ebp)
   11a24:	7f 12                	jg     11a38 <ack_handler+0x48>
   11a26:	0f bf c2             	movswl %dx,%eax
   11a29:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11a2f:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
   11a32:	0f 8d 17 02 00 00    	jge    11c4f <ack_handler+0x25f>
   11a38:	0f b7 b3 64 12 00 00 	movzwl 0x1264(%ebx),%esi
   11a3f:	66 39 d6             	cmp    %dx,%si
   11a42:	7f 14                	jg     11a58 <ack_handler+0x68>
   11a44:	0f bf c2             	movswl %dx,%eax
   11a47:	0f bf f6             	movswl %si,%esi
   11a4a:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11a50:	39 ce                	cmp    %ecx,%esi
   11a52:	0f 8d f7 01 00 00    	jge    11c4f <ack_handler+0x25f>
	{
		if( amIns->vt_a == amIns->pollSn )
   11a58:	66 39 93 00 23 00 00 	cmp    %dx,0x2300(%ebx)
   11a5f:	0f 84 bb 01 00 00    	je     11c20 <ack_handler+0x230>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11a65:	8b 8b f0 00 00 00    	mov    0xf0(%ebx),%ecx
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11a6b:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   11a6e:	74 45                	je     11ab5 <ack_handler+0xc5>
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11a70:	8b 01                	mov    (%ecx),%eax
   11a72:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11a78:	8b 7d f0             	mov    -0x10(%ebp),%edi
   11a7b:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11a80:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11a84:	75 19                	jne    11a9f <ack_handler+0xaf>
   11a86:	e9 2f 01 00 00       	jmp    11bba <ack_handler+0x1ca>
   11a8b:	90                   	nop
   11a8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11a90:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11a97:	0f 84 1b 01 00 00    	je     11bb8 <ack_handler+0x1c8>
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11a9d:	89 f0                	mov    %esi,%eax
   11a9f:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11aa5:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11aab:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11ab1:	39 cf                	cmp    %ecx,%edi
   11ab3:	75 db                	jne    11a90 <ack_handler+0xa0>
   11ab5:	8b 8b 9c 01 00 00    	mov    0x19c(%ebx),%ecx
			}
			//nposBf = NULL;
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
   11abb:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
   11ac1:	39 cf                	cmp    %ecx,%edi
   11ac3:	74 3c                	je     11b01 <ack_handler+0x111>
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11ac5:	8b 01                	mov    (%ecx),%eax
   11ac7:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11acd:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amRetxBf->SN == amIns->vt_a )
   11ad2:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11ad6:	75 13                	jne    11aeb <ack_handler+0xfb>
   11ad8:	eb 50                	jmp    11b2a <ack_handler+0x13a>
   11ada:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11ae0:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11ae7:	74 3f                	je     11b28 <ack_handler+0x138>
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11ae9:	89 f0                	mov    %esi,%eax
   11aeb:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11af1:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11af7:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11afd:	39 cf                	cmp    %ecx,%edi
   11aff:	75 df                	jne    11ae0 <ack_handler+0xf0>
					break;
				}
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
   11b01:	0f bf c2             	movswl %dx,%eax
   11b04:	83 c0 01             	add    $0x1,%eax
   11b07:	89 c1                	mov    %eax,%ecx
   11b09:	c1 f9 1f             	sar    $0x1f,%ecx
   11b0c:	c1 e9 16             	shr    $0x16,%ecx
   11b0f:	01 c8                	add    %ecx,%eax
   11b11:	25 ff 03 00 00       	and    $0x3ff,%eax
   11b16:	29 c8                	sub    %ecx,%eax
   11b18:	89 c2                	mov    %eax,%edx
   11b1a:	66 89 83 66 12 00 00 	mov    %ax,0x1266(%ebx)
   11b21:	e9 fa fe ff ff       	jmp    11a20 <ack_handler+0x30>
   11b26:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
   11b28:	89 c6                	mov    %eax,%esi
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11b2a:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
   11b30:	31 d2                	xor    %edx,%edx
   11b32:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   11b38:	85 ff                	test   %edi,%edi
   11b3a:	74 1d                	je     11b59 <ack_handler+0x169>
   11b3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11b40:	03 44 96 10          	add    0x10(%esi,%edx,4),%eax
   11b44:	2b 44 96 50          	sub    0x50(%esi,%edx,4),%eax
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11b48:	83 c2 01             	add    $0x1,%edx
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11b4b:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11b51:	3b 96 90 00 00 00    	cmp    0x90(%esi),%edx
   11b57:	72 e7                	jb     11b40 <ack_handler+0x150>
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11b59:	2b 46 0c             	sub    0xc(%esi),%eax
					amIns->amRetxBufferNum--;
   11b5c:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				{
					for( i = 0; i <amRetxBf->segnum; i++)
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11b63:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
					amIns->amRetxBufferNum--;
					if(amRetxBf->pkt != NULL)
   11b69:	8b 06                	mov    (%esi),%eax
   11b6b:	85 c0                	test   %eax,%eax
   11b6d:	74 0b                	je     11b7a <ack_handler+0x18a>
					{
						fsm_pkt_destroy( amRetxBf->pkt );
   11b6f:	e8 fc ff ff ff       	call   11b70 <ack_handler+0x180>
						amRetxBf->pkt = NULL;
   11b74:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11b7a:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amRetxBf->list);
					if(amRetxBf != NULL)
   11b80:	85 f6                	test   %esi,%esi
   11b82:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11b88:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11b8b:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11b8d:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11b94:	01 10 00 
	entry->prev = LIST_POISON2;
   11b97:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11b9e:	02 20 00 
   11ba1:	74 07                	je     11baa <ack_handler+0x1ba>
					{
						fsm_mem_free(amRetxBf);
   11ba3:	89 f0                	mov    %esi,%eax
   11ba5:	e8 fc ff ff ff       	call   11ba6 <ack_handler+0x1b6>
   11baa:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11bb1:	e9 4b ff ff ff       	jmp    11b01 <ack_handler+0x111>
   11bb6:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11bb8:	89 c6                	mov    %eax,%esi
				{
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11bba:	8b 06                	mov    (%esi),%eax
   11bbc:	8b 40 50             	mov    0x50(%eax),%eax
   11bbf:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11bc5:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					if(amTxedBuffer->pkt != NULL)
   11bcc:	8b 06                	mov    (%esi),%eax
   11bce:	85 c0                	test   %eax,%eax
   11bd0:	74 0b                	je     11bdd <ack_handler+0x1ed>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   11bd2:	e8 fc ff ff ff       	call   11bd3 <ack_handler+0x1e3>
						amTxedBuffer->pkt = NULL;
   11bd7:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11bdd:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   11be3:	85 f6                	test   %esi,%esi
   11be5:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11beb:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11bee:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11bf0:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11bf7:	01 10 00 
	entry->prev = LIST_POISON2;
   11bfa:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11c01:	02 20 00 
   11c04:	74 07                	je     11c0d <ack_handler+0x21d>
					{
						fsm_mem_free(amTxedBuffer);
   11c06:	89 f0                	mov    %esi,%eax
   11c08:	e8 fc ff ff ff       	call   11c09 <ack_handler+0x219>
   11c0d:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11c14:	e9 9c fe ff ff       	jmp    11ab5 <ack_handler+0xc5>
   11c19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
	{
		if( amIns->vt_a == amIns->pollSn )
		{
			//
			if(amIns->pollRetxTimer)
   11c20:	8b 43 08             	mov    0x8(%ebx),%eax
   11c23:	85 c0                	test   %eax,%eax
   11c25:	0f 84 3a fe ff ff    	je     11a65 <ack_handler+0x75>
			{
				fsm_schedule_cancel(amIns->pollRetxTimer);
   11c2b:	e8 fc ff ff ff       	call   11c2c <ack_handler+0x23c>
				amIns->pollRetxTimer = 0;
   11c30:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
   11c37:	c7 04 24 a4 3f 00 00 	movl   $0x3fa4,(%esp)
   11c3e:	e8 fc ff ff ff       	call   11c3f <ack_handler+0x24f>
   11c43:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11c4a:	e9 16 fe ff ff       	jmp    11a65 <ack_handler+0x75>
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
	}
	amIns->vt_ms = (amIns->vt_a + AM_WINDOW_SIZE)%(AM_WINDOW_SIZE*2);
   11c4f:	05 00 02 00 00       	add    $0x200,%eax
   11c54:	89 c2                	mov    %eax,%edx
   11c56:	c1 fa 1f             	sar    $0x1f,%edx
   11c59:	c1 ea 16             	shr    $0x16,%edx
   11c5c:	01 d0                	add    %edx,%eax
   11c5e:	25 ff 03 00 00       	and    $0x3ff,%eax
   11c63:	29 d0                	sub    %edx,%eax
   11c65:	66 89 83 68 12 00 00 	mov    %ax,0x1268(%ebx)
}
   11c6c:	83 c4 10             	add    $0x10,%esp
   11c6f:	5b                   	pop    %ebx
   11c70:	5e                   	pop    %esi
   11c71:	5f                   	pop    %edi
   11c72:	5d                   	pop    %ebp
   11c73:	c3                   	ret    
   11c74:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11c7a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00011c80 <no_so_handler>:
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11c80:	55                   	push   %ebp
   11c81:	89 e5                	mov    %esp,%ebp
   11c83:	57                   	push   %edi
   11c84:	56                   	push   %esi
   11c85:	53                   	push   %ebx
   11c86:	83 ec 14             	sub    $0x14,%esp
   11c89:	e8 fc ff ff ff       	call   11c8a <no_so_handler+0xa>
   11c8e:	89 c3                	mov    %eax,%ebx
   11c90:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11c93:	8d bb f0 00 00 00    	lea    0xf0(%ebx),%edi
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11c99:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	struct AmBuffer *amTxedBuffer;	//
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
   11c9c:	c7 04 24 d0 3f 00 00 	movl   $0x3fd0,(%esp)
   11ca3:	e8 fc ff ff ff       	call   11ca4 <no_so_handler+0x24>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11ca8:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11cae:	39 c7                	cmp    %eax,%edi
   11cb0:	74 61                	je     11d13 <no_so_handler+0x93>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11cb2:	8b 10                	mov    (%eax),%edx
   11cb4:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11cba:	8b 75 f0             	mov    -0x10(%ebp),%esi
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11cbd:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   11cc0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11cc3:	0f b6 16             	movzbl (%esi),%edx
   11cc6:	0f b6 76 01          	movzbl 0x1(%esi),%esi
   11cca:	c0 ea 06             	shr    $0x6,%dl
   11ccd:	0f b6 d2             	movzbl %dl,%edx
   11cd0:	c1 e6 02             	shl    $0x2,%esi
   11cd3:	09 d6                	or     %edx,%esi
   11cd5:	0f bf 50 f8          	movswl -0x8(%eax),%edx
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11cd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cdc:	2d 9c 00 00 00       	sub    $0x9c,%eax
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11ce1:	39 d6                	cmp    %edx,%esi
   11ce3:	75 18                	jne    11cfd <no_so_handler+0x7d>
   11ce5:	e9 e7 01 00 00       	jmp    11ed1 <no_so_handler+0x251>
   11cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11cf0:	0f bf 90 94 00 00 00 	movswl 0x94(%eax),%edx
   11cf7:	39 f2                	cmp    %esi,%edx
   11cf9:	74 25                	je     11d20 <no_so_handler+0xa0>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11cfb:	89 c8                	mov    %ecx,%eax
   11cfd:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   11d03:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   11d09:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   11d0f:	39 d7                	cmp    %edx,%edi
   11d11:	75 dd                	jne    11cf0 <no_so_handler+0x70>
				break;
			}
		}
	}
	FOUT;
}
   11d13:	83 c4 14             	add    $0x14,%esp
   11d16:	5b                   	pop    %ebx
   11d17:	5e                   	pop    %esi
   11d18:	5f                   	pop    %edi
   11d19:	5d                   	pop    %ebp
   11d1a:	c3                   	ret    
   11d1b:	90                   	nop
   11d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11d20:	89 c6                	mov    %eax,%esi
			{
				*isPduFound = true;
   11d22:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11d25:	c6 01 01             	movb   $0x1,(%ecx)
				amTxedBuffer->segStart[0] = 0;
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11d28:	8b 06                	mov    (%esi),%eax
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
			{
				*isPduFound = true;
				amTxedBuffer->segStart[0] = 0;
   11d2a:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11d31:	8b 40 50             	mov    0x50(%eax),%eax
   11d34:	89 46 50             	mov    %eax,0x50(%esi)

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   11d37:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   11d3e:	66 83 f8 ff          	cmp    $0xffff,%ax
   11d42:	0f 84 28 01 00 00    	je     11e70 <no_so_handler+0x1f0>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   11d48:	83 c0 01             	add    $0x1,%eax
   11d4b:	66 89 86 96 00 00 00 	mov    %ax,0x96(%esi)
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
   11d52:	c7 04 24 00 40 00 00 	movl   $0x4000,(%esp)
   11d59:	e8 fc ff ff ff       	call   11d5a <no_so_handler+0xda>
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   11d5e:	0f bf 96 96 00 00 00 	movswl 0x96(%esi),%edx
   11d65:	0f b7 83 fa 22 00 00 	movzwl 0x22fa(%ebx),%eax
   11d6c:	39 c2                	cmp    %eax,%edx
   11d6e:	74 18                	je     11d88 <no_so_handler+0x108>
						}
					}
				}
				else
				{
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   11d70:	c7 04 24 28 40 00 00 	movl   $0x4028,(%esp)
   11d77:	e8 fc ff ff ff       	call   11d78 <no_so_handler+0xf8>
				break;
			}
		}
	}
	FOUT;
}
   11d7c:	83 c4 14             	add    $0x14,%esp
   11d7f:	5b                   	pop    %ebx
   11d80:	5e                   	pop    %esi
   11d81:	5f                   	pop    %edi
   11d82:	5d                   	pop    %ebp
   11d83:	c3                   	ret    
   11d84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   11d88:	b8 04 00 00 00       	mov    $0x4,%eax
   11d8d:	e8 fc ff ff ff       	call   11d8e <no_so_handler+0x10e>
					mioctrl->eventCode = 0;
   11d92:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   11d97:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
   11d9b:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   11d9e:	e8 fc ff ff ff       	call   11d9f <no_so_handler+0x11f>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11da3:	8b 06                	mov    (%esi),%eax
   11da5:	8b 40 50             	mov    0x50(%eax),%eax
   11da8:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11dae:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   11db5:	8b 06                	mov    (%esi),%eax
   11db7:	e8 fc ff ff ff       	call   11db8 <no_so_handler+0x138>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11dbc:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   11dc2:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
					amTxedBuffer->pkt = NULL;
   11dc8:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11dce:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11dd1:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   11dd3:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11dd5:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11ddc:	01 10 00 
	entry->prev = LIST_POISON2;
   11ddf:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11de6:	02 20 00 
   11de9:	e8 fc ff ff ff       	call   11dea <no_so_handler+0x16a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11dee:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   11df4:	8d 93 9c 01 00 00    	lea    0x19c(%ebx),%edx
   11dfa:	39 c2                	cmp    %eax,%edx
   11dfc:	0f 84 11 ff ff ff    	je     11d13 <no_so_handler+0x93>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e02:	8b 30                	mov    (%eax),%esi
   11e04:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11e0a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e0d:	89 7d ec             	mov    %edi,-0x14(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11e10:	0f bf 40 f8          	movswl -0x8(%eax),%eax
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e14:	89 75 e8             	mov    %esi,-0x18(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11e17:	0f b6 31             	movzbl (%ecx),%esi
   11e1a:	89 f1                	mov    %esi,%ecx
   11e1c:	c0 e9 06             	shr    $0x6,%cl
   11e1f:	89 ce                	mov    %ecx,%esi
   11e21:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11e24:	81 e6 ff 00 00 00    	and    $0xff,%esi
   11e2a:	0f b6 79 01          	movzbl 0x1(%ecx),%edi
   11e2e:	c1 e7 02             	shl    $0x2,%edi
   11e31:	09 f7                	or     %esi,%edi
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e33:	8b 75 e8             	mov    -0x18(%ebp),%esi
   11e36:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11e3c:	39 f8                	cmp    %edi,%eax
   11e3e:	75 15                	jne    11e55 <no_so_handler+0x1d5>
   11e40:	eb 3c                	jmp    11e7e <no_so_handler+0x1fe>
   11e42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11e48:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   11e4f:	39 f8                	cmp    %edi,%eax
   11e51:	74 2e                	je     11e81 <no_so_handler+0x201>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e53:	89 ce                	mov    %ecx,%esi
   11e55:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
   11e5b:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   11e61:	8d 86 9c 00 00 00    	lea    0x9c(%esi),%eax
   11e67:	39 c2                	cmp    %eax,%edx
   11e69:	75 dd                	jne    11e48 <no_so_handler+0x1c8>
   11e6b:	e9 a3 fe ff ff       	jmp    11d13 <no_so_handler+0x93>
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   11e70:	66 c7 86 96 00 00 00 	movw   $0x0,0x96(%esi)
   11e77:	00 00 
   11e79:	e9 d4 fe ff ff       	jmp    11d52 <no_so_handler+0xd2>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11e7e:	8b 75 ec             	mov    -0x14(%ebp),%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
							{
								amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   11e81:	8b 06                	mov    (%esi),%eax
   11e83:	8b 40 50             	mov    0x50(%eax),%eax
   11e86:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
								amIns->amRetxBufferNum--;
   11e8c:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
								fsm_pkt_destroy( amRetxBf->pkt );
   11e93:	8b 06                	mov    (%esi),%eax
   11e95:	e8 fc ff ff ff       	call   11e96 <no_so_handler+0x216>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11e9a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   11ea0:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
								amRetxBf->pkt = NULL;
   11ea6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11eac:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11eaf:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   11eb1:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11eb3:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11eba:	01 10 00 
	entry->prev = LIST_POISON2;
   11ebd:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11ec4:	02 20 00 
   11ec7:	e8 fc ff ff ff       	call   11ec8 <no_so_handler+0x248>
								amRetxBf = NULL;
								break;
   11ecc:	e9 42 fe ff ff       	jmp    11d13 <no_so_handler+0x93>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11ed1:	89 ce                	mov    %ecx,%esi
   11ed3:	e9 4a fe ff ff       	jmp    11d22 <no_so_handler+0xa2>
   11ed8:	90                   	nop
   11ed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00011ee0 <rlc_ctrl_pkt_recv>:
**Modified by:
**Modified Date:
************************************************************************/

void rlc_ctrl_pkt_recv(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   11ee0:	55                   	push   %ebp
   11ee1:	89 e5                	mov    %esp,%ebp
   11ee3:	56                   	push   %esi
   11ee4:	53                   	push   %ebx
   11ee5:	83 ec 08             	sub    $0x8,%esp
   11ee8:	e8 fc ff ff ff       	call   11ee9 <rlc_ctrl_pkt_recv+0x9>
   11eed:	89 d6                	mov    %edx,%esi
	u32 pduLen=0;
	u8 E1=0;
	bool isPduFound = false;

	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
   11eef:	c7 04 24 54 40 00 00 	movl   $0x4054,(%esp)
   11ef6:	e8 fc ff ff ff       	call   11ef7 <rlc_ctrl_pkt_recv+0x17>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
   11efb:	8b 46 50             	mov    0x50(%esi),%eax
   11efe:	c7 04 24 94 40 00 00 	movl   $0x4094,(%esp)
   11f05:	89 44 24 04          	mov    %eax,0x4(%esp)
   11f09:	e8 fc ff ff ff       	call   11f0a <rlc_ctrl_pkt_recv+0x2a>
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11f0e:	b8 02 00 00 00       	mov    $0x2,%eax
   11f13:	e8 fc ff ff ff       	call   11f14 <rlc_ctrl_pkt_recv+0x34>
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11f18:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
	memset(part1,0,sizeof(ctrlPduPart1));
   11f1d:	66 c7 00 00 00       	movw   $0x0,(%eax)
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11f22:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11f28:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   11f2a:	e8 fc ff ff ff       	call   11f2b <rlc_ctrl_pkt_recv+0x4b>
	fsm_skb_pull(pkt,2);
   11f2f:	ba 02 00 00 00       	mov    $0x2,%edx
   11f34:	89 f0                	mov    %esi,%eax
   11f36:	e8 fc ff ff ff       	call   11f37 <rlc_ctrl_pkt_recv+0x57>
	*(u16 *)part1 = ntohs(*(u16 *)part1);
	pduLen -= 2;
	fsm_octets_print(part1,2);
   11f3b:	ba 02 00 00 00       	mov    $0x2,%edx
   11f40:	89 d8                	mov    %ebx,%eax
   11f42:	66 c1 03 08          	rolw   $0x8,(%ebx)
   11f46:	e8 fc ff ff ff       	call   11f47 <rlc_ctrl_pkt_recv+0x67>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->E1 is %d)\n",part1->E1);	
   11f4b:	0f b6 03             	movzbl (%ebx),%eax
   11f4e:	d0 e8                	shr    %al
   11f50:	83 e0 01             	and    $0x1,%eax
   11f53:	89 44 24 04          	mov    %eax,0x4(%esp)
   11f57:	c7 04 24 c0 40 00 00 	movl   $0x40c0,(%esp)
   11f5e:	e8 fc ff ff ff       	call   11f5f <rlc_ctrl_pkt_recv+0x7f>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->acksn is %d)\n",part1->ACK_SN);
   11f63:	0f b6 03             	movzbl (%ebx),%eax
   11f66:	c0 e8 02             	shr    $0x2,%al
   11f69:	0f b6 d0             	movzbl %al,%edx
   11f6c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   11f70:	c7 04 24 ec 40 00 00 	movl   $0x40ec,(%esp)
   11f77:	83 e0 0f             	and    $0xf,%eax
   11f7a:	c1 e0 06             	shl    $0x6,%eax
   11f7d:	09 d0                	or     %edx,%eax
   11f7f:	89 44 24 04          	mov    %eax,0x4(%esp)
   11f83:	e8 fc ff ff ff       	call   11f84 <rlc_ctrl_pkt_recv+0xa4>
		{
			fsm_mem_free(part3);
			part3=NULL;
		}
	}
}
   11f88:	83 c4 08             	add    $0x8,%esp
   11f8b:	5b                   	pop    %ebx
   11f8c:	5e                   	pop    %esi
   11f8d:	5d                   	pop    %ebp
   11f8e:	c3                   	ret    
   11f8f:	90                   	nop

00011f90 <rlc_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_retx(struct AM_Instance *amIns,struct AmBuffer *amTxedBuffer)
{
   11f90:	55                   	push   %ebp
   11f91:	89 e5                	mov    %esp,%ebp
   11f93:	57                   	push   %edi
   11f94:	56                   	push   %esi
   11f95:	53                   	push   %ebx
   11f96:	83 ec 10             	sub    $0x10,%esp
   11f99:	e8 fc ff ff ff       	call   11f9a <rlc_retx+0xa>
   11f9e:	89 c3                	mov    %eax,%ebx
   11fa0:	89 d6                	mov    %edx,%esi
	struct AmBuffer *amRetxBf;
	struct AmBuffer *nposBf;
	int i;

	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
   11fa2:	c7 04 24 1c 41 00 00 	movl   $0x411c,(%esp)
   11fa9:	e8 fc ff ff ff       	call   11faa <rlc_retx+0x1a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11fae:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
   11fb4:	8d 8b 9c 01 00 00    	lea    0x19c(%ebx),%ecx
   11fba:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   11fbd:	39 c1                	cmp    %eax,%ecx
   11fbf:	74 5a                	je     1201b <rlc_retx+0x8b>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11fc1:	8b 38                	mov    (%eax),%edi
   11fc3:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   11fc9:	0f b7 8e 94 00 00 00 	movzwl 0x94(%esi),%ecx
   11fd0:	0f b7 40 f8          	movzwl -0x8(%eax),%eax
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11fd4:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   11fda:	66 39 c8             	cmp    %cx,%ax
   11fdd:	0f 84 a2 02 00 00    	je     12285 <rlc_retx+0x2f5>
   11fe3:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   11fe6:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11fe9:	eb 17                	jmp    12002 <rlc_retx+0x72>
   11feb:	90                   	nop
   11fec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11ff0:	0f b7 87 94 00 00 00 	movzwl 0x94(%edi),%eax
   11ff7:	66 39 c8             	cmp    %cx,%ax
   11ffa:	0f 84 b8 01 00 00    	je     121b8 <rlc_retx+0x228>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12000:	89 d7                	mov    %edx,%edi
   12002:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
   12008:	8d 87 9c 00 00 00    	lea    0x9c(%edi),%eax
   1200e:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12014:	39 c3                	cmp    %eax,%ebx
   12016:	75 d8                	jne    11ff0 <rlc_retx+0x60>
   12018:	8b 5d ec             	mov    -0x14(%ebp),%ebx
		}
		//nposBf = NULL;
	}

	//
	amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   1201b:	8b 06                	mov    (%esi),%eax
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   1201d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12020:	8b 40 50             	mov    0x50(%eax),%eax
   12023:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum--;
   12029:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12030:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   12036:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1203c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1203f:	89 10                	mov    %edx,(%eax)
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
   12041:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12047:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   1204e:	01 10 00 
	entry->prev = LIST_POISON2;
   12051:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   12058:	02 20 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1205b:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   12061:	89 93 a0 01 00 00    	mov    %edx,0x1a0(%ebx)
	new->next = next;
   12067:	89 8e 9c 00 00 00    	mov    %ecx,0x9c(%esi)
	new->prev = prev;
   1206d:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   12073:	89 10                	mov    %edx,(%eax)
	if( amTxedBuffer->pktstatus != FULL_SDU )
   12075:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
   12079:	0f 84 e9 01 00 00    	je     12268 <rlc_retx+0x2d8>
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   1207f:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12085:	8b 93 a4 01 00 00    	mov    0x1a4(%ebx),%edx
   1208b:	85 c0                	test   %eax,%eax
   1208d:	74 29                	je     120b8 <rlc_retx+0x128>
   1208f:	31 c0                	xor    %eax,%eax
   12091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			if( amTxedBuffer->segStart[i] != -1 )
   12098:	8b 4c 86 10          	mov    0x10(%esi,%eax,4),%ecx
   1209c:	83 f9 ff             	cmp    $0xffffffff,%ecx
   1209f:	74 0c                	je     120ad <rlc_retx+0x11d>
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
   120a1:	29 ca                	sub    %ecx,%edx
   120a3:	03 54 86 50          	add    0x50(%esi,%eax,4),%edx
   120a7:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	amIns->amTransmittedBufferNum--;
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
	if( amTxedBuffer->pktstatus != FULL_SDU )
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   120ad:	83 c0 01             	add    $0x1,%eax
   120b0:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   120b6:	72 e0                	jb     12098 <rlc_retx+0x108>
			if( amTxedBuffer->segStart[i] != -1 )
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
			}
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
   120b8:	03 56 0c             	add    0xc(%esi),%edx
   120bb:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
	}
	amIns->amRetxBufferNum++;
   120c1:	83 83 a8 01 00 00 01 	addl   $0x1,0x1a8(%ebx)
	fsm_printf("[RLC][rlc_retx] has move to RetxBuffer,%d\n",amTxedBuffer->SN);
   120c8:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   120cf:	c7 04 24 80 41 00 00 	movl   $0x4180,(%esp)
   120d6:	89 44 24 04          	mov    %eax,0x4(%esp)
   120da:	e8 fc ff ff ff       	call   120db <rlc_retx+0x14b>
	//
	amTxedBf = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   120df:	b8 a4 00 00 00       	mov    $0xa4,%eax
   120e4:	e8 fc ff ff ff       	call   120e5 <rlc_retx+0x155>
   120e9:	89 c7                	mov    %eax,%edi
	//amTxedBf->pkt = fsm_pkt_create(amTxedBuffer->pkt->len+fsm_skb_headroom(amTxedBuffer->pkt));
	amTxedBf->pkt = fsm_pkt_duplicate(amTxedBuffer->pkt);
   120eb:	8b 06                	mov    (%esi),%eax
   120ed:	e8 fc ff ff ff       	call   120ee <rlc_retx+0x15e>
   120f2:	89 07                	mov    %eax,(%edi)
	//fsm_mem_cpy(amTxedBf->pkt->data,amTxedBuffer->pkt->data,amTxedBuffer->pkt->len);
	//fsm_skb_put(amTxedBf->pkt,amTxedBuffer->pkt->len);
	amTxedBf->datalen = amTxedBuffer->datalen;
   120f4:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
   120fa:	89 87 98 00 00 00    	mov    %eax,0x98(%edi)
	amTxedBf->headLen = amTxedBuffer->headLen;
   12100:	8b 46 0c             	mov    0xc(%esi),%eax
   12103:	89 47 0c             	mov    %eax,0xc(%edi)
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
   12106:	8b 46 04             	mov    0x4(%esi),%eax
   12109:	89 47 04             	mov    %eax,0x4(%edi)
	amTxedBf->pos = amTxedBuffer->pos;
   1210c:	8b 46 08             	mov    0x8(%esi),%eax
   1210f:	89 47 08             	mov    %eax,0x8(%edi)
	amTxedBf->retxCount = amTxedBuffer->retxCount;
   12112:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   12119:	66 89 87 96 00 00 00 	mov    %ax,0x96(%edi)
	amTxedBf->segnum = amTxedBuffer->segnum;
   12120:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12126:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
	for( i = 0;i < amTxedBuffer->segnum; i++)
   1212c:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12132:	85 c0                	test   %eax,%eax
   12134:	74 1d                	je     12153 <rlc_retx+0x1c3>
   12136:	31 c0                	xor    %eax,%eax
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
   12138:	8b 54 86 10          	mov    0x10(%esi,%eax,4),%edx
   1213c:	89 54 87 10          	mov    %edx,0x10(%edi,%eax,4)
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
   12140:	8b 54 86 50          	mov    0x50(%esi,%eax,4),%edx
   12144:	89 54 87 50          	mov    %edx,0x50(%edi,%eax,4)
	amTxedBf->headLen = amTxedBuffer->headLen;
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
	amTxedBf->pos = amTxedBuffer->pos;
	amTxedBf->retxCount = amTxedBuffer->retxCount;
	amTxedBf->segnum = amTxedBuffer->segnum;
	for( i = 0;i < amTxedBuffer->segnum; i++)
   12148:	83 c0 01             	add    $0x1,%eax
   1214b:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   12151:	72 e5                	jb     12138 <rlc_retx+0x1a8>
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   12153:	0f b7 86 94 00 00 00 	movzwl 0x94(%esi),%eax
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   1215a:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   12160:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	for( i = 0;i < amTxedBuffer->segnum; i++)
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   12166:	66 89 87 94 00 00 00 	mov    %ax,0x94(%edi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1216d:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   12173:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   12179:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   1217f:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   12185:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amTxedBf->pkt->len;
   12187:	8b 07                	mov    (%edi),%eax
   12189:	8b 40 50             	mov    0x50(%eax),%eax
   1218c:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum++;
   12192:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	fsm_printf("[RLC][rlc_retx] has copy to amTxedBuffer,%d\n",amTxedBuffer->SN);
   12199:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   121a0:	c7 04 24 ac 41 00 00 	movl   $0x41ac,(%esp)
   121a7:	89 44 24 04          	mov    %eax,0x4(%esp)
   121ab:	e8 fc ff ff ff       	call   121ac <rlc_retx+0x21c>
	FOUT;
}
   121b0:	83 c4 10             	add    $0x10,%esp
   121b3:	5b                   	pop    %ebx
   121b4:	5e                   	pop    %esi
   121b5:	5f                   	pop    %edi
   121b6:	5d                   	pop    %ebp
   121b7:	c3                   	ret    
   121b8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
   121bb:	98                   	cwtl   
   121bc:	89 44 24 04          	mov    %eax,0x4(%esp)
   121c0:	c7 04 24 4c 41 00 00 	movl   $0x414c,(%esp)
   121c7:	e8 fc ff ff ff       	call   121c8 <rlc_retx+0x238>
				if( amRetxBf->pktstatus != FULL_SDU )
   121cc:	83 7f 04 01          	cmpl   $0x1,0x4(%edi)
   121d0:	0f 84 a2 00 00 00    	je     12278 <rlc_retx+0x2e8>
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   121d6:	8b 87 90 00 00 00    	mov    0x90(%edi),%eax
   121dc:	8b 8b a4 01 00 00    	mov    0x1a4(%ebx),%ecx
   121e2:	85 c0                	test   %eax,%eax
   121e4:	74 22                	je     12208 <rlc_retx+0x278>
   121e6:	31 c0                	xor    %eax,%eax
					{
						if( amRetxBf->segStart[i] != -1 )
   121e8:	8b 54 87 10          	mov    0x10(%edi,%eax,4),%edx
   121ec:	83 fa ff             	cmp    $0xffffffff,%edx
   121ef:	74 0c                	je     121fd <rlc_retx+0x26d>
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   121f1:	2b 54 87 50          	sub    0x50(%edi,%eax,4),%edx
   121f5:	01 d1                	add    %edx,%ecx
   121f7:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
				if( amRetxBf->pktstatus != FULL_SDU )
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   121fd:	83 c0 01             	add    $0x1,%eax
   12200:	3b 87 90 00 00 00    	cmp    0x90(%edi),%eax
   12206:	72 e0                	jb     121e8 <rlc_retx+0x258>
						if( amRetxBf->segStart[i] != -1 )
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
						}
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   12208:	2b 4f 0c             	sub    0xc(%edi),%ecx
   1220b:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
				}
				amIns->amRetxBufferNum--;
   12211:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				if(amRetxBf->pkt != NULL)
   12218:	8b 07                	mov    (%edi),%eax
   1221a:	85 c0                	test   %eax,%eax
   1221c:	74 0b                	je     12229 <rlc_retx+0x299>
				{
					fsm_pkt_destroy( amRetxBf->pkt );
   1221e:	e8 fc ff ff ff       	call   1221f <rlc_retx+0x28f>
					amRetxBf->pkt = NULL;
   12223:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12229:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
				}
				list_del(&amRetxBf->list);
				if(amRetxBf != NULL)
   1222f:	85 ff                	test   %edi,%edi
   12231:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12237:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1223a:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1223c:	c7 87 9c 00 00 00 00 	movl   $0x100100,0x9c(%edi)
   12243:	01 10 00 
	entry->prev = LIST_POISON2;
   12246:	c7 87 a0 00 00 00 00 	movl   $0x200200,0xa0(%edi)
   1224d:	02 20 00 
   12250:	0f 84 c5 fd ff ff    	je     1201b <rlc_retx+0x8b>
				{
					fsm_mem_free(amRetxBf);
   12256:	89 f8                	mov    %edi,%eax
   12258:	e8 fc ff ff ff       	call   12259 <rlc_retx+0x2c9>
   1225d:	e9 b9 fd ff ff       	jmp    1201b <rlc_retx+0x8b>
   12262:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
   12268:	8b 06                	mov    (%esi),%eax
   1226a:	8b 40 50             	mov    0x50(%eax),%eax
   1226d:	01 83 a4 01 00 00    	add    %eax,0x1a4(%ebx)
   12273:	e9 49 fe ff ff       	jmp    120c1 <rlc_retx+0x131>
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   12278:	8b 07                	mov    (%edi),%eax
   1227a:	8b 40 50             	mov    0x50(%eax),%eax
   1227d:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
   12283:	eb 8c                	jmp    12211 <rlc_retx+0x281>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12285:	89 d7                	mov    %edx,%edi
   12287:	e9 2f ff ff ff       	jmp    121bb <rlc_retx+0x22b>
   1228c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00012290 <so_handler>:
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12290:	55                   	push   %ebp
   12291:	89 e5                	mov    %esp,%ebp
   12293:	57                   	push   %edi
   12294:	56                   	push   %esi
   12295:	53                   	push   %ebx
   12296:	83 ec 20             	sub    $0x20,%esp
   12299:	e8 fc ff ff ff       	call   1229a <so_handler+0xa>
   1229e:	0f b7 75 08          	movzwl 0x8(%ebp),%esi
   122a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
   122a5:	89 cf                	mov    %ecx,%edi
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   122a7:	89 c1                	mov    %eax,%ecx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   122a9:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
   122af:	81 c1 f0 00 00 00    	add    $0xf0,%ecx
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   122b5:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   122b8:	39 c1                	cmp    %eax,%ecx
   122ba:	74 3d                	je     122f9 <so_handler+0x69>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   122bc:	8b 18                	mov    (%eax),%ebx
   122be:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   122c4:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
		{
			if( nackSn == amTxedBuffer->SN )
   122ca:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   122ce:	75 13                	jne    122e3 <so_handler+0x53>
   122d0:	eb 2f                	jmp    12301 <so_handler+0x71>
   122d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   122d8:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   122df:	74 27                	je     12308 <so_handler+0x78>
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   122e1:	89 d3                	mov    %edx,%ebx
   122e3:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   122e9:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   122ef:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   122f5:	39 c1                	cmp    %eax,%ecx
   122f7:	75 df                	jne    122d8 <so_handler+0x48>
				break;
			}
		}
	}
	FOUT;
}
   122f9:	83 c4 20             	add    $0x20,%esp
   122fc:	5b                   	pop    %ebx
   122fd:	5e                   	pop    %esi
   122fe:	5f                   	pop    %edi
   122ff:	5d                   	pop    %ebp
   12300:	c3                   	ret    
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12301:	89 d3                	mov    %edx,%ebx
   12303:	90                   	nop
   12304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			if( nackSn == amTxedBuffer->SN )
			{
				*isPduFound = true;
   12308:	c6 07 01             	movb   $0x1,(%edi)
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
   1230b:	0f bf c6             	movswl %si,%eax
   1230e:	89 44 24 04          	mov    %eax,0x4(%esp)
   12312:	c7 04 24 dc 41 00 00 	movl   $0x41dc,(%esp)
   12319:	e8 fc ff ff ff       	call   1231a <so_handler+0x8a>
				for( i = 0; i < amTxedBuffer->segnum; i++ )
   1231e:	8b 8b 90 00 00 00    	mov    0x90(%ebx),%ecx
   12324:	85 c9                	test   %ecx,%ecx
   12326:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   12329:	0f 84 d1 01 00 00    	je     12500 <so_handler+0x270>
   1232f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12332:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   12336:	0f b6 7a 03          	movzbl 0x3(%edx),%edi
   1233a:	31 d2                	xor    %edx,%edx
   1233c:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
   12340:	89 d6                	mov    %edx,%esi
   12342:	d0 e8                	shr    %al
   12344:	0f b6 c0             	movzbl %al,%eax
   12347:	c1 e7 07             	shl    $0x7,%edi
   1234a:	09 c7                	or     %eax,%edi
   1234c:	31 c0                	xor    %eax,%eax
   1234e:	89 7d dc             	mov    %edi,-0x24(%ebp)
   12351:	eb 0f                	jmp    12362 <so_handler+0xd2>
   12353:	90                   	nop
   12354:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12358:	83 c0 01             	add    $0x1,%eax
   1235b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1235e:	89 c6                	mov    %eax,%esi
   12360:	74 5e                	je     123c0 <so_handler+0x130>
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
   12362:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12365:	39 4c 83 10          	cmp    %ecx,0x10(%ebx,%eax,4)
   12369:	75 ed                	jne    12358 <so_handler+0xc8>
   1236b:	8b 7d ec             	mov    -0x14(%ebp),%edi
   1236e:	0f b6 17             	movzbl (%edi),%edx
   12371:	c0 ea 02             	shr    $0x2,%dl
   12374:	0f b6 fa             	movzbl %dl,%edi
   12377:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1237a:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
   1237e:	0f b6 52 02          	movzbl 0x2(%edx),%edx
   12382:	c1 e1 06             	shl    $0x6,%ecx
   12385:	83 e2 01             	and    $0x1,%edx
   12388:	09 f9                	or     %edi,%ecx
   1238a:	c1 e2 0e             	shl    $0xe,%edx
   1238d:	09 ca                	or     %ecx,%edx
   1238f:	39 54 83 50          	cmp    %edx,0x50(%ebx,%eax,4)
   12393:	75 c3                	jne    12358 <so_handler+0xc8>
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   12395:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12398:	89 f2                	mov    %esi,%edx
   1239a:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1239d:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   123a1:	c7 04 24 14 42 00 00 	movl   $0x4214,(%esp)
   123a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   123ac:	e8 fc ff ff ff       	call   123ad <so_handler+0x11d>
   123b1:	8b bb 90 00 00 00    	mov    0x90(%ebx),%edi
						break;
   123b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
				for( i = 0; i < amTxedBuffer->segnum; i++ )
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   123ba:	89 7d f0             	mov    %edi,-0x10(%ebp)
						break;
   123bd:	eb 07                	jmp    123c6 <so_handler+0x136>
   123bf:	90                   	nop
   123c0:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   123c4:	89 c2                	mov    %eax,%edx
					}
				}
				if( i == amTxedBuffer->segnum )
   123c6:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   123c9:	0f 84 31 01 00 00    	je     12500 <so_handler+0x270>
					amTxedBuffer->segnum++;
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   123cf:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
   123d6:	66 83 f8 ff          	cmp    $0xffff,%ax
   123da:	0f 84 10 01 00 00    	je     124f0 <so_handler+0x260>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   123e0:	83 c0 01             	add    $0x1,%eax
   123e3:	66 89 83 96 00 00 00 	mov    %ax,0x96(%ebx)
   123ea:	98                   	cwtl   
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   123eb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   123ee:	0f b7 91 fa 22 00 00 	movzwl 0x22fa(%ecx),%edx
   123f5:	39 c2                	cmp    %eax,%edx
   123f7:	74 1f                	je     12418 <so_handler+0x188>
						}
					}
				}
				else
				{
					rlc_retx(amIns,amTxedBuffer);
   123f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   123fc:	89 da                	mov    %ebx,%edx
   123fe:	e8 fc ff ff ff       	call   123ff <so_handler+0x16f>
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   12403:	c7 04 24 28 40 00 00 	movl   $0x4028,(%esp)
   1240a:	e8 fc ff ff ff       	call   1240b <so_handler+0x17b>
				break;
			}
		}
	}
	FOUT;
}
   1240f:	83 c4 20             	add    $0x20,%esp
   12412:	5b                   	pop    %ebx
   12413:	5e                   	pop    %esi
   12414:	5f                   	pop    %edi
   12415:	5d                   	pop    %ebp
   12416:	c3                   	ret    
   12417:	90                   	nop
					amTxedBuffer->retxCount++;
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
   12418:	c7 04 24 74 42 00 00 	movl   $0x4274,(%esp)
   1241f:	e8 fc ff ff ff       	call   12420 <so_handler+0x190>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   12424:	b8 04 00 00 00       	mov    $0x4,%eax
   12429:	e8 fc ff ff ff       	call   1242a <so_handler+0x19a>
					mioctrl->eventCode = 0;
					mioctrl->rbIdentity = amIns->rbId;
   1242e:	8b 7d e8             	mov    -0x18(%ebp),%edi
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
					mioctrl->eventCode = 0;
   12431:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12436:	0f b6 57 02          	movzbl 0x2(%edi),%edx
   1243a:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   1243d:	e8 fc ff ff ff       	call   1243e <so_handler+0x1ae>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   12442:	8b 03                	mov    (%ebx),%eax
   12444:	8b 40 50             	mov    0x50(%eax),%eax
   12447:	29 87 f8 00 00 00    	sub    %eax,0xf8(%edi)
					amIns->amTransmittedBufferNum--;
   1244d:	83 af fc 00 00 00 01 	subl   $0x1,0xfc(%edi)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   12454:	8b 03                	mov    (%ebx),%eax
   12456:	e8 fc ff ff ff       	call   12457 <so_handler+0x1c7>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   1245b:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   12461:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
					amTxedBuffer->pkt = NULL;
   12467:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1246d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   12470:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   12472:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12474:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   1247b:	01 10 00 
	entry->prev = LIST_POISON2;
   1247e:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   12485:	02 20 00 
   12488:	e8 fc ff ff ff       	call   12489 <so_handler+0x1f9>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   1248d:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12493:	89 fa                	mov    %edi,%edx
   12495:	81 c2 9c 01 00 00    	add    $0x19c,%edx
   1249b:	39 c2                	cmp    %eax,%edx
   1249d:	0f 84 56 fe ff ff    	je     122f9 <so_handler+0x69>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   124a3:	8b 18                	mov    (%eax),%ebx
   124a5:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   124ab:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
						{
							if( amRetxBf->SN == nackSn)
   124b1:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   124b5:	75 18                	jne    124cf <so_handler+0x23f>
   124b7:	e9 b6 00 00 00       	jmp    12572 <so_handler+0x2e2>
   124bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   124c0:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   124c7:	0f 84 a7 00 00 00    	je     12574 <so_handler+0x2e4>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   124cd:	89 cb                	mov    %ecx,%ebx
   124cf:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   124d5:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   124db:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   124e1:	39 c2                	cmp    %eax,%edx
   124e3:	75 db                	jne    124c0 <so_handler+0x230>
   124e5:	e9 0f fe ff ff       	jmp    122f9 <so_handler+0x69>
   124ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   124f0:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   124f7:	00 00 
   124f9:	31 c0                	xor    %eax,%eax
   124fb:	e9 eb fe ff ff       	jmp    123eb <so_handler+0x15b>
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12500:	8b 45 ec             	mov    -0x14(%ebp),%eax
					if(part3->SOend  == 0x7fff ) //
   12503:	8b 4d ec             	mov    -0x14(%ebp),%ecx
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12506:	0f b6 50 02          	movzbl 0x2(%eax),%edx
   1250a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1250e:	d0 ea                	shr    %dl
   12510:	0f b6 d2             	movzbl %dl,%edx
   12513:	c1 e0 07             	shl    $0x7,%eax
   12516:	09 d0                	or     %edx,%eax
   12518:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1251b:	89 44 93 10          	mov    %eax,0x10(%ebx,%edx,4)
					if(part3->SOend  == 0x7fff ) //
   1251f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12522:	0f b6 02             	movzbl (%edx),%eax
   12525:	0f b6 52 01          	movzbl 0x1(%edx),%edx
   12529:	c0 e8 02             	shr    $0x2,%al
   1252c:	0f b6 c0             	movzbl %al,%eax
   1252f:	c1 e2 06             	shl    $0x6,%edx
   12532:	09 c2                	or     %eax,%edx
   12534:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   12538:	83 e0 01             	and    $0x1,%eax
   1253b:	c1 e0 0e             	shl    $0xe,%eax
   1253e:	09 c2                	or     %eax,%edx
   12540:	66 81 fa ff 7f       	cmp    $0x7fff,%dx
   12545:	0f 84 c1 00 00 00    	je     1260c <so_handler+0x37c>
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
					}
					else
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = part3->SOend;
   1254b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1254e:	0f b7 d2             	movzwl %dx,%edx
   12551:	89 54 83 50          	mov    %edx,0x50(%ebx,%eax,4)
					}
					amTxedBuffer->segnum++;
   12555:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12558:	83 c0 01             	add    $0x1,%eax
   1255b:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
   12561:	c7 04 24 4c 42 00 00 	movl   $0x424c,(%esp)
   12568:	e8 fc ff ff ff       	call   12569 <so_handler+0x2d9>
   1256d:	e9 5d fe ff ff       	jmp    123cf <so_handler+0x13f>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12572:	89 cb                	mov    %ecx,%ebx
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   12574:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
   12578:	0f 84 9f 00 00 00    	je     1261d <so_handler+0x38d>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   1257e:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
   12584:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12587:	85 d2                	test   %edx,%edx
   12589:	8b 88 a4 01 00 00    	mov    0x1a4(%eax),%ecx
   1258f:	74 27                	je     125b8 <so_handler+0x328>
   12591:	8b 75 e8             	mov    -0x18(%ebp),%esi
   12594:	31 c0                	xor    %eax,%eax
   12596:	66 90                	xchg   %ax,%ax
									{
										if( amRetxBf->segStart[i] != -1 )
   12598:	8b 54 83 10          	mov    0x10(%ebx,%eax,4),%edx
   1259c:	83 fa ff             	cmp    $0xffffffff,%edx
   1259f:	74 0c                	je     125ad <so_handler+0x31d>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   125a1:	2b 54 83 50          	sub    0x50(%ebx,%eax,4),%edx
   125a5:	01 d1                	add    %edx,%ecx
   125a7:	89 8e a4 01 00 00    	mov    %ecx,0x1a4(%esi)
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   125ad:	83 c0 01             	add    $0x1,%eax
   125b0:	3b 83 90 00 00 00    	cmp    0x90(%ebx),%eax
   125b6:	72 e0                	jb     12598 <so_handler+0x308>
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   125b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125bb:	2b 4b 0c             	sub    0xc(%ebx),%ecx
   125be:	89 88 a4 01 00 00    	mov    %ecx,0x1a4(%eax)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   125c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125c7:	83 a8 a8 01 00 00 01 	subl   $0x1,0x1a8(%eax)
								fsm_pkt_destroy( amRetxBf->pkt );
   125ce:	8b 03                	mov    (%ebx),%eax
   125d0:	e8 fc ff ff ff       	call   125d1 <so_handler+0x341>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   125d5:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   125db:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
								amRetxBf->pkt = NULL;
   125e1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   125e7:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   125ea:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   125ec:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   125ee:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   125f5:	01 10 00 
	entry->prev = LIST_POISON2;
   125f8:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   125ff:	02 20 00 
   12602:	e8 fc ff ff ff       	call   12603 <so_handler+0x373>
								amRetxBf= NULL;
								break;
   12607:	e9 ed fc ff ff       	jmp    122f9 <so_handler+0x69>
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
					if(part3->SOend  == 0x7fff ) //
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
   1260c:	8b 03                	mov    (%ebx),%eax
   1260e:	8b 7d f0             	mov    -0x10(%ebp),%edi
   12611:	8b 40 50             	mov    0x50(%eax),%eax
   12614:	89 44 bb 50          	mov    %eax,0x50(%ebx,%edi,4)
   12618:	e9 38 ff ff ff       	jmp    12555 <so_handler+0x2c5>
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   1261d:	8b 03                	mov    (%ebx),%eax
   1261f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12622:	8b 40 50             	mov    0x50(%eax),%eax
   12625:	29 82 a4 01 00 00    	sub    %eax,0x1a4(%edx)
   1262b:	eb 97                	jmp    125c4 <so_handler+0x334>
   1262d:	8d 76 00             	lea    0x0(%esi),%esi

00012630 <rlc_poll>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   12630:	55                   	push   %ebp
   12631:	89 e5                	mov    %esp,%ebp
   12633:	56                   	push   %esi
   12634:	53                   	push   %ebx
   12635:	83 ec 04             	sub    $0x4,%esp
   12638:	e8 fc ff ff ff       	call   12639 <rlc_poll+0x9>
   1263d:	89 d6                	mov    %edx,%esi
   1263f:	89 c3                	mov    %eax,%ebx
	//u16 amHdr = 0x0000; //AM PDU
	RLC_AMPDU_fixhead * amHdr;

	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
   12641:	c7 04 24 b0 42 00 00 	movl   $0x42b0,(%esp)
   12648:	e8 fc ff ff ff       	call   12649 <rlc_poll+0x19>
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
   1264d:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	*(u16*)amHdr=htons(*(u16*)amHdr);
   12653:	0f b7 02             	movzwl (%edx),%eax
   12656:	66 c1 c0 08          	rol    $0x8,%ax
	if(amHdr->P!=1)
   1265a:	89 c1                	mov    %eax,%ecx
	{
		amHdr->P = 1;
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   1265c:	0f b7 f0             	movzwl %ax,%esi
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
	if(amHdr->P!=1)
   1265f:	66 c1 e9 08          	shr    $0x8,%cx
   12663:	f6 c1 20             	test   $0x20,%cl
	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
   12666:	66 89 02             	mov    %ax,(%edx)
	if(amHdr->P!=1)
   12669:	75 0c                	jne    12677 <rlc_poll+0x47>
	{
		amHdr->P = 1;
   1266b:	83 c9 20             	or     $0x20,%ecx
   1266e:	88 4a 01             	mov    %cl,0x1(%edx)
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   12671:	0f b7 02             	movzwl (%edx),%eax
   12674:	0f b7 f0             	movzwl %ax,%esi
   12677:	66 c1 e8 08          	shr    $0x8,%ax
   1267b:	c1 e6 08             	shl    $0x8,%esi
   1267e:	09 f0                	or     %esi,%eax
   12680:	66 89 02             	mov    %ax,(%edx)
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
	amIns->byteWithoutPoll = 0;
	amIns->pollSn = amIns->vt_s - 1;
   12683:	0f b7 83 64 12 00 00 	movzwl 0x1264(%ebx),%eax
	/*if( (amHdr&0x2000)>>13 == 0 )
	{
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
   1268a:	66 c7 83 fc 22 00 00 	movw   $0x0,0x22fc(%ebx)
   12691:	00 00 
	amIns->byteWithoutPoll = 0;
   12693:	66 c7 83 fe 22 00 00 	movw   $0x0,0x22fe(%ebx)
   1269a:	00 00 
	amIns->pollSn = amIns->vt_s - 1;
   1269c:	83 e8 01             	sub    $0x1,%eax
   1269f:	66 89 83 00 23 00 00 	mov    %ax,0x2300(%ebx)
	if(amIns->pollRetxTimer)
   126a6:	8b 43 08             	mov    0x8(%ebx),%eax
   126a9:	85 c0                	test   %eax,%eax
   126ab:	74 0c                	je     126b9 <rlc_poll+0x89>
	{
		fsm_schedule_cancel(amIns->pollRetxTimer);
   126ad:	e8 fc ff ff ff       	call   126ae <rlc_poll+0x7e>
		amIns->pollRetxTimer = 0;
   126b2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	}
	amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
   126b9:	8b 53 0c             	mov    0xc(%ebx),%edx
   126bc:	8b 43 10             	mov    0x10(%ebx),%eax
   126bf:	e8 fc ff ff ff       	call   126c0 <rlc_poll+0x90>
   126c4:	89 43 08             	mov    %eax,0x8(%ebx)
	fsm_printf("[RLC][rlc_poll] pollretxTimer start\n");
   126c7:	c7 04 24 d4 42 00 00 	movl   $0x42d4,(%esp)
   126ce:	e8 fc ff ff ff       	call   126cf <rlc_poll+0x9f>
	FOUT;
}
   126d3:	83 c4 04             	add    $0x4,%esp
   126d6:	5b                   	pop    %ebx
   126d7:	5e                   	pop    %esi
   126d8:	5d                   	pop    %ebp
   126d9:	c3                   	ret    
   126da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000126e0 <rlc_poll_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll_retx(struct AM_Instance *amIns)
{
   126e0:	55                   	push   %ebp
   126e1:	89 e5                	mov    %esp,%ebp
   126e3:	57                   	push   %edi
   126e4:	56                   	push   %esi
   126e5:	53                   	push   %ebx
   126e6:	83 ec 24             	sub    $0x24,%esp
   126e9:	e8 fc ff ff ff       	call   126ea <rlc_poll_retx+0xa>
   126ee:	89 c6                	mov    %eax,%esi
	struct AmBuffer *amRetxBf;  //PDU
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	FIN(rlc_poll_retx());
	fsm_printf("[RLC][rlc_poll_retx] entering rlc_poll_retx() function\n");
   126f0:	c7 04 24 fc 42 00 00 	movl   $0x42fc,(%esp)
   126f7:	e8 fc ff ff ff       	call   126f8 <rlc_poll_retx+0x18>
	//
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   126fc:	8d 8e f0 00 00 00    	lea    0xf0(%esi),%ecx
   12702:	3b 8e f0 00 00 00    	cmp    0xf0(%esi),%ecx
   12708:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1270b:	0f 84 a5 02 00 00    	je     129b6 <rlc_poll_retx+0x2d6>
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");
   12711:	c7 04 24 34 43 00 00 	movl   $0x4334,(%esp)
   12718:	e8 fc ff ff ff       	call   12719 <rlc_poll_retx+0x39>

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1271d:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
   12723:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12726:	8b 38                	mov    (%eax),%edi
   12728:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
   1272e:	0f 84 94 02 00 00    	je     129c8 <rlc_poll_retx+0x2e8>
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12734:	8d 8e 9c 01 00 00    	lea    0x19c(%esi),%ecx
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1273a:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12740:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   12743:	eb 21                	jmp    12766 <rlc_poll_retx+0x86>
   12745:	8d 76 00             	lea    0x0(%esi),%esi
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   12748:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
   1274e:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   12754:	2d 9c 00 00 00       	sub    $0x9c,%eax
   12759:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   1275c:	0f 84 66 02 00 00    	je     129c8 <rlc_poll_retx+0x2e8>
   12762:	89 fb                	mov    %edi,%ebx
   12764:	89 c7                	mov    %eax,%edi
		{
			//amTxedBuffer = list_entry(pos,struct AmBuffer,list);
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
   12766:	0f bf 96 64 12 00 00 	movswl 0x1264(%esi),%edx
   1276d:	0f bf 83 94 00 00 00 	movswl 0x94(%ebx),%eax
   12774:	83 ea 01             	sub    $0x1,%edx
   12777:	39 d0                	cmp    %edx,%eax
   12779:	75 cd                	jne    12748 <rlc_poll_retx+0x68>
			{
				if( amTxedBuffer->retxCount == -1 )
   1277b:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
   12782:	66 83 fa ff          	cmp    $0xffff,%dx
   12786:	0f 84 1c 02 00 00    	je     129a8 <rlc_poll_retx+0x2c8>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   1278c:	83 c2 01             	add    $0x1,%edx
   1278f:	66 89 93 96 00 00 00 	mov    %dx,0x96(%ebx)
				}
				fsm_printf("[RLC][rlc_poll_retx] the pdu of rlc_poll_retx's SN is %d\n",amTxedBuffer->SN);
   12796:	89 44 24 04          	mov    %eax,0x4(%esp)
   1279a:	c7 04 24 7c 43 00 00 	movl   $0x437c,(%esp)
   127a1:	e8 fc ff ff ff       	call   127a2 <rlc_poll_retx+0xc2>
				fsm_printf("[RLC][rlc_poll_retx] the retxCount is %d, the maxThreshold is %d\n",amTxedBuffer->retxCount,amIns->maxRetxThreshold);
   127a6:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   127ad:	89 44 24 08          	mov    %eax,0x8(%esp)
   127b1:	0f bf 83 96 00 00 00 	movswl 0x96(%ebx),%eax
   127b8:	c7 04 24 b8 43 00 00 	movl   $0x43b8,(%esp)
   127bf:	89 44 24 04          	mov    %eax,0x4(%esp)
   127c3:	e8 fc ff ff ff       	call   127c4 <rlc_poll_retx+0xe4>
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   127c8:	0f bf 93 96 00 00 00 	movswl 0x96(%ebx),%edx
   127cf:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   127d6:	39 c2                	cmp    %eax,%edx
   127d8:	0f 85 02 02 00 00    	jne    129e0 <rlc_poll_retx+0x300>
				{
					fsm_printf("[RLC][rlc_poll_retx] has reach the maxRetxThreshold\n");
   127de:	c7 04 24 fc 43 00 00 	movl   $0x43fc,(%esp)
   127e5:	e8 fc ff ff ff       	call   127e6 <rlc_poll_retx+0x106>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   127ea:	b8 04 00 00 00       	mov    $0x4,%eax
   127ef:	e8 fc ff ff ff       	call   127f0 <rlc_poll_retx+0x110>
					mioctrl->eventCode = 0;
   127f4:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   127f9:	0f b6 56 02          	movzbl 0x2(%esi),%edx
   127fd:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   12800:	e8 fc ff ff ff       	call   12801 <rlc_poll_retx+0x121>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12805:	8b 96 9c 01 00 00    	mov    0x19c(%esi),%edx
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   1280b:	39 55 e8             	cmp    %edx,-0x18(%ebp)
   1280e:	74 6b                	je     1287b <rlc_poll_retx+0x19b>
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12810:	8d 82 64 ff ff ff    	lea    -0x9c(%edx),%eax
   12816:	8b 0a                	mov    (%edx),%ecx
   12818:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   1281b:	0f b7 83 94 00 00 00 	movzwl 0x94(%ebx),%eax
   12822:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12826:	8d 81 64 ff ff ff    	lea    -0x9c(%ecx),%eax
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   1282c:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
   12830:	66 39 4a f8          	cmp    %cx,-0x8(%edx)
   12834:	0f 84 cc 01 00 00    	je     12a06 <rlc_poll_retx+0x326>
   1283a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
   1283d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   12840:	89 7d e0             	mov    %edi,-0x20(%ebp)
   12843:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
   12847:	eb 16                	jmp    1285f <rlc_poll_retx+0x17f>
   12849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   12850:	66 39 b8 94 00 00 00 	cmp    %di,0x94(%eax)
   12857:	0f 84 93 00 00 00    	je     128f0 <rlc_poll_retx+0x210>
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   1285d:	89 c8                	mov    %ecx,%eax
   1285f:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   12865:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   1286b:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   12871:	39 d3                	cmp    %edx,%ebx
   12873:	75 db                	jne    12850 <rlc_poll_retx+0x170>
   12875:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   12878:	8b 7d e0             	mov    -0x20(%ebp),%edi
					//nposBf = NULL;
					}

					//PDU
					//pos = pos->next;
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   1287b:	8b 03                	mov    (%ebx),%eax
   1287d:	8b 40 50             	mov    0x50(%eax),%eax
   12880:	29 86 f8 00 00 00    	sub    %eax,0xf8(%esi)
					amIns->amTransmittedBufferNum--;
   12886:	83 ae fc 00 00 00 01 	subl   $0x1,0xfc(%esi)
					if(amTxedBuffer->pkt != NULL)
   1288d:	8b 03                	mov    (%ebx),%eax
   1288f:	85 c0                	test   %eax,%eax
   12891:	74 0b                	je     1289e <rlc_poll_retx+0x1be>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   12893:	e8 fc ff ff ff       	call   12894 <rlc_poll_retx+0x1b4>
						amTxedBuffer->pkt = NULL;
   12898:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   1289e:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   128a4:	85 db                	test   %ebx,%ebx
   128a6:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   128ac:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   128af:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   128b1:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   128b8:	01 10 00 
	entry->prev = LIST_POISON2;
   128bb:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   128c2:	02 20 00 
   128c5:	74 07                	je     128ce <rlc_poll_retx+0x1ee>
					{
						fsm_mem_free(amTxedBuffer);
   128c7:	89 d8                	mov    %ebx,%eax
   128c9:	e8 fc ff ff ff       	call   128ca <rlc_poll_retx+0x1ea>
						amTxedBuffer = NULL;
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
   128ce:	8b 86 a4 01 00 00    	mov    0x1a4(%esi),%eax
   128d4:	c7 04 24 34 44 00 00 	movl   $0x4434,(%esp)
   128db:	89 44 24 04          	mov    %eax,0x4(%esp)
   128df:	e8 fc ff ff ff       	call   128e0 <rlc_poll_retx+0x200>
   128e4:	e9 5f fe ff ff       	jmp    12748 <rlc_poll_retx+0x68>
   128e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   128f0:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   128f3:	89 c2                	mov    %eax,%edx
   128f5:	8b 7d e0             	mov    -0x20(%ebp),%edi
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   128f8:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
   128fc:	0f 84 ce 00 00 00    	je     129d0 <rlc_poll_retx+0x2f0>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12902:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
   12908:	85 c9                	test   %ecx,%ecx
   1290a:	8b 8e a4 01 00 00    	mov    0x1a4(%esi),%ecx
   12910:	74 33                	je     12945 <rlc_poll_retx+0x265>
   12912:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12915:	31 c0                	xor    %eax,%eax
   12917:	89 cb                	mov    %ecx,%ebx
   12919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
									{
										if( amRetxBf->segStart[i] != -1 )
   12920:	8b 4c 82 10          	mov    0x10(%edx,%eax,4),%ecx
   12924:	83 f9 ff             	cmp    $0xffffffff,%ecx
   12927:	74 0c                	je     12935 <rlc_poll_retx+0x255>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12929:	2b 4c 82 50          	sub    0x50(%edx,%eax,4),%ecx
   1292d:	01 cb                	add    %ecx,%ebx
   1292f:	89 9e a4 01 00 00    	mov    %ebx,0x1a4(%esi)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12935:	83 c0 01             	add    $0x1,%eax
   12938:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
   1293e:	72 e0                	jb     12920 <rlc_poll_retx+0x240>
   12940:	89 d9                	mov    %ebx,%ecx
   12942:	8b 5d ec             	mov    -0x14(%ebp),%ebx
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12945:	89 c8                	mov    %ecx,%eax
   12947:	2b 42 0c             	sub    0xc(%edx),%eax
   1294a:	89 86 a4 01 00 00    	mov    %eax,0x1a4(%esi)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12950:	83 ae a8 01 00 00 01 	subl   $0x1,0x1a8(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12957:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   1295d:	8b 8a 9c 00 00 00    	mov    0x9c(%edx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12963:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
   12966:	89 08                	mov    %ecx,(%eax)
								list_del(&amRetxBf->list);
								if(amRetxBf->pkt != NULL)
   12968:	8b 02                	mov    (%edx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1296a:	c7 82 9c 00 00 00 00 	movl   $0x100100,0x9c(%edx)
   12971:	01 10 00 
	entry->prev = LIST_POISON2;
   12974:	c7 82 a0 00 00 00 00 	movl   $0x200200,0xa0(%edx)
   1297b:	02 20 00 
   1297e:	85 c0                	test   %eax,%eax
   12980:	74 11                	je     12993 <rlc_poll_retx+0x2b3>
								{
									fsm_pkt_destroy( amRetxBf->pkt );
   12982:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12985:	e8 fc ff ff ff       	call   12986 <rlc_poll_retx+0x2a6>
									amRetxBf->pkt = NULL;
   1298a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1298d:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
								}
								if(amRetxBf != NULL)
   12993:	85 d2                	test   %edx,%edx
   12995:	0f 84 e0 fe ff ff    	je     1287b <rlc_poll_retx+0x19b>
								{
									fsm_mem_free(amRetxBf);
   1299b:	89 d0                	mov    %edx,%eax
   1299d:	e8 fc ff ff ff       	call   1299e <rlc_poll_retx+0x2be>
   129a2:	e9 d4 fe ff ff       	jmp    1287b <rlc_poll_retx+0x19b>
   129a7:	90                   	nop
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
			{
				if( amTxedBuffer->retxCount == -1 )
				{
					amTxedBuffer->retxCount = 0;
   129a8:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   129af:	00 00 
   129b1:	e9 e0 fd ff ff       	jmp    12796 <rlc_poll_retx+0xb6>
			}
		}
	}
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
   129b6:	c7 04 24 b0 44 00 00 	movl   $0x44b0,(%esp)
   129bd:	e8 fc ff ff ff       	call   129be <rlc_poll_retx+0x2de>
   129c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	FOUT;
}
   129c8:	83 c4 24             	add    $0x24,%esp
   129cb:	5b                   	pop    %ebx
   129cc:	5e                   	pop    %esi
   129cd:	5f                   	pop    %edi
   129ce:	5d                   	pop    %ebp
   129cf:	c3                   	ret    
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   129d0:	8b 02                	mov    (%edx),%eax
   129d2:	8b 40 50             	mov    0x50(%eax),%eax
   129d5:	29 86 a4 01 00 00    	sub    %eax,0x1a4(%esi)
   129db:	e9 70 ff ff ff       	jmp    12950 <rlc_poll_retx+0x270>
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
				}
				else
				{
					fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx pdu has not reach maxRetxThreshold\n");
   129e0:	c7 04 24 68 44 00 00 	movl   $0x4468,(%esp)
   129e7:	e8 fc ff ff ff       	call   129e8 <rlc_poll_retx+0x308>
					rlc_poll(amIns,amTxedBuffer->pkt);	//
   129ec:	8b 13                	mov    (%ebx),%edx
   129ee:	89 f0                	mov    %esi,%eax
   129f0:	e8 fc ff ff ff       	call   129f1 <rlc_poll_retx+0x311>
					rlc_retx(amIns,amTxedBuffer);
   129f5:	89 da                	mov    %ebx,%edx
   129f7:	89 f0                	mov    %esi,%eax
   129f9:	e8 fc ff ff ff       	call   129fa <rlc_poll_retx+0x31a>
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
	}
	FOUT;
}
   129fe:	83 c4 24             	add    $0x24,%esp
   12a01:	5b                   	pop    %ebx
   12a02:	5e                   	pop    %esi
   12a03:	5f                   	pop    %edi
   12a04:	5d                   	pop    %ebp
   12a05:	c3                   	ret    
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12a06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12a09:	e9 ea fe ff ff       	jmp    128f8 <rlc_poll_retx+0x218>
