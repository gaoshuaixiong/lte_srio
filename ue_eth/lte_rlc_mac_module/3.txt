
lte_rlc_mac_module.o:     file format elf32-i386


Disassembly of section .text:

00000000 <__fsm_skb_netrx>:
{
	fsm_pkt_destroy(pkptr);
}

static void __fsm_skb_netrx(unsigned long data)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	56                   	push   %esi
       4:	53                   	push   %ebx
       5:	e8 fc ff ff ff       	call   6 <__fsm_skb_netrx+0x6>
       a:	eb 1e                	jmp    2a <__fsm_skb_netrx+0x2a>
       c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.rx_queue);
      10:	e8 fc ff ff ff       	call   11 <__fsm_skb_netrx+0x11>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
      15:	89 f2                	mov    %esi,%edx
      17:	89 c3                	mov    %eax,%ebx
      19:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      1e:	e8 fc ff ff ff       	call   1f <__fsm_skb_netrx+0x1f>
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		NETIF_RX(pkptr);
      23:	89 d8                	mov    %ebx,%eax
      25:	e8 fc ff ff ff       	call   26 <__fsm_skb_netrx+0x26>
	unsigned long flags;


	while(1)
	{
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
      2a:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      2f:	e8 fc ff ff ff       	call   30 <__fsm_skb_netrx+0x30>
      34:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.rx_queue))
      36:	a1 bc 02 00 00       	mov    0x2bc,%eax
      3b:	3b 00                	cmp    (%eax),%eax
      3d:	75 d1                	jne    10 <__fsm_skb_netrx+0x10>
      3f:	89 f2                	mov    %esi,%edx
      41:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      46:	e8 fc ff ff ff       	call   47 <__fsm_skb_netrx+0x47>
		NETIF_RX(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_netrx() packet receive\n");
	return;
}
      4b:	5b                   	pop    %ebx
      4c:	5e                   	pop    %esi
      4d:	5d                   	pop    %ebp
      4e:	c3                   	ret    
      4f:	90                   	nop

00000050 <__fsm_skb_xmit>:

static void __fsm_skb_xmit(unsigned long data)
{
      50:	55                   	push   %ebp
      51:	89 e5                	mov    %esp,%ebp
      53:	56                   	push   %esi
      54:	53                   	push   %ebx
      55:	e8 fc ff ff ff       	call   56 <__fsm_skb_xmit+0x6>
      5a:	eb 1e                	jmp    7a <__fsm_skb_xmit+0x2a>
      5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.tx_queue);
      60:	e8 fc ff ff ff       	call   61 <__fsm_skb_xmit+0x11>
      65:	89 f2                	mov    %esi,%edx
      67:	89 c3                	mov    %eax,%ebx
      69:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      6e:	e8 fc ff ff ff       	call   6f <__fsm_skb_xmit+0x1f>
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
//		fsm_octets_print(pkptr->data, pkptr->len);
		DEV_QUEUE_XMIT(pkptr);
      73:	89 d8                	mov    %ebx,%eax
      75:	e8 fc ff ff ff       	call   76 <__fsm_skb_xmit+0x26>
{
	FSM_PKT* pkptr;
	unsigned long flags;
	while(1)
	{
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
      7a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      7f:	e8 fc ff ff ff       	call   80 <__fsm_skb_xmit+0x30>
      84:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.tx_queue))
      86:	a1 b8 02 00 00       	mov    0x2b8,%eax
      8b:	3b 00                	cmp    (%eax),%eax
      8d:	75 d1                	jne    60 <__fsm_skb_xmit+0x10>
      8f:	89 f2                	mov    %esi,%edx
      91:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      96:	e8 fc ff ff ff       	call   97 <__fsm_skb_xmit+0x47>
		DEV_QUEUE_XMIT(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}
      9b:	5b                   	pop    %ebx
      9c:	5e                   	pop    %esi
      9d:	5d                   	pop    %ebp
      9e:	c3                   	ret    
      9f:	90                   	nop

000000a0 <__fsm_do_ioctl>:
	}
}


static void __fsm_do_ioctl(unsigned long data)
{
      a0:	55                   	push   %ebp
      a1:	89 e5                	mov    %esp,%ebp
      a3:	57                   	push   %edi
      a4:	56                   	push   %esi
      a5:	53                   	push   %ebx
      a6:	e8 fc ff ff ff       	call   a7 <__fsm_do_ioctl+0x7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
      ab:	8b 35 d4 02 00 00    	mov    0x2d4,%esi
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
      b1:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
      b7:	74 60                	je     119 <__fsm_do_ioctl+0x79>
      b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		ev_ptr = list_first_entry(&fsm_core.do_ioctl_list, struct evioctl, list_node);
		ev_ptr->dev->netdev_ops->ndo_do_ioctl(ev_ptr->dev, (struct ifreq*)&ev_ptr->ifr, IOCKERNEL);
      c0:	8b 46 f0             	mov    -0x10(%esi),%eax
      c3:	8d 56 f4             	lea    -0xc(%esi),%edx
      c6:	b9 f0 89 00 00       	mov    $0x89f0,%ecx
      cb:	8d 7e f0             	lea    -0x10(%esi),%edi
      ce:	8b 98 34 01 00 00    	mov    0x134(%eax),%ebx
      d4:	ff 53 28             	call   *0x28(%ebx)
		spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
      d7:	b8 e4 02 00 00       	mov    $0x2e4,%eax
      dc:	e8 fc ff ff ff       	call   dd <__fsm_do_ioctl+0x3d>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
      e1:	8b 4e 04             	mov    0x4(%esi),%ecx
      e4:	8b 1e                	mov    (%esi),%ebx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
      e6:	89 4b 04             	mov    %ecx,0x4(%ebx)
      e9:	89 c2                	mov    %eax,%edx
      eb:	b8 e4 02 00 00       	mov    $0x2e4,%eax
	prev->next = next;
      f0:	89 19                	mov    %ebx,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
      f2:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
      f8:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
      ff:	e8 fc ff ff ff       	call   100 <__fsm_do_ioctl+0x60>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     104:	89 f8                	mov    %edi,%eax
     106:	e8 fc ff ff ff       	call   107 <__fsm_do_ioctl+0x67>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     10b:	8b 35 d4 02 00 00    	mov    0x2d4,%esi

static void __fsm_do_ioctl(unsigned long data)
{
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
     111:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
     117:	75 a7                	jne    c0 <__fsm_do_ioctl+0x20>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
     119:	5b                   	pop    %ebx
     11a:	5e                   	pop    %esi
     11b:	5f                   	pop    %edi
     11c:	5d                   	pop    %ebp
     11d:	c3                   	ret    
     11e:	66 90                	xchg   %ax,%ax

00000120 <__fsm_skb_send_null>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     120:	55                   	push   %ebp
     121:	89 e5                	mov    %esp,%ebp
     123:	e8 fc ff ff ff       	call   124 <__fsm_skb_send_null+0x4>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     128:	e8 fc ff ff ff       	call   129 <__fsm_skb_send_null+0x9>
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
	fsm_pkt_destroy(pkptr);
}
     12d:	5d                   	pop    %ebp
     12e:	c3                   	ret    
     12f:	90                   	nop

00000130 <__fsm_tm_restart>:
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
}

static void __fsm_tm_restart()
{
     130:	55                   	push   %ebp
     131:	89 e5                	mov    %esp,%ebp
     133:	83 ec 04             	sub    $0x4,%esp
     136:	e8 fc ff ff ff       	call   137 <__fsm_tm_restart+0x7>
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
     13b:	8b 15 88 02 00 00    	mov    0x288,%edx
     141:	85 d2                	test   %edx,%edx
     143:	74 7b                	je     1c0 <__fsm_tm_restart+0x90>
	{
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
     145:	a1 44 02 00 00       	mov    0x244,%eax
     14a:	85 c0                	test   %eax,%eax
     14c:	74 42                	je     190 <__fsm_tm_restart+0x60>
	{	
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
     14e:	83 f8 01             	cmp    $0x1,%eax
     151:	74 05                	je     158 <__fsm_tm_restart+0x28>
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     153:	c9                   	leave  
     154:	c3                   	ret    
     155:	8d 76 00             	lea    0x0(%esi),%esi
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
     158:	b8 48 02 00 00       	mov    $0x248,%eax
     15d:	e8 fc ff ff ff       	call   15e <__fsm_tm_restart+0x2e>
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     162:	a1 88 02 00 00       	mov    0x288,%eax
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
     167:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     16e:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     171:	8b 50 08             	mov    0x8(%eax),%edx
     174:	8b 48 0c             	mov    0xc(%eax),%ecx
     177:	b8 48 02 00 00       	mov    $0x248,%eax
     17c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     183:	e8 fc ff ff ff       	call   184 <__fsm_tm_restart+0x54>
	}
}
     188:	c9                   	leave  
     189:	c3                   	ret    
     18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
	{	
		pB->timer.function = __fsm_tm_expire;
     190:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     197:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     19a:	8b 4a 0c             	mov    0xc(%edx),%ecx
     19d:	b8 48 02 00 00       	mov    $0x248,%eax
     1a2:	8b 52 08             	mov    0x8(%edx),%edx
     1a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     1ac:	e8 fc ff ff ff       	call   1ad <__fsm_tm_restart+0x7d>
		pB->tm_state = FSM_TM_RUN;
     1b1:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     1b8:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1bb:	c9                   	leave  
     1bc:	c3                   	ret    
     1bd:	8d 76 00             	lea    0x0(%esi),%esi
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
	{
		pB->tm_state = FSM_TM_STOP;
     1c0:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     1c7:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1ca:	c9                   	leave  
     1cb:	c3                   	ret    
     1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000001d0 <__fsm_skb_pending_xmit>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1d0:	55                   	push   %ebp
     1d1:	89 e5                	mov    %esp,%ebp
     1d3:	83 ec 08             	sub    $0x8,%esp
     1d6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
     1d9:	89 75 fc             	mov    %esi,-0x4(%ebp)
     1dc:	e8 fc ff ff ff       	call   1dd <__fsm_skb_pending_xmit+0xd>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
     1e1:	66 89 48 66          	mov    %cx,0x66(%eax)
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1e5:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
     1e7:	89 50 14             	mov    %edx,0x14(%eax)
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1ea:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     1ef:	e8 fc ff ff ff       	call   1f0 <__fsm_skb_pending_xmit+0x20>
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f4:	89 da                	mov    %ebx,%edx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1f6:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f8:	a1 b8 02 00 00       	mov    0x2b8,%eax
     1fd:	e8 fc ff ff ff       	call   1fe <__fsm_skb_pending_xmit+0x2e>
     202:	89 f2                	mov    %esi,%edx
     204:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     209:	e8 fc ff ff ff       	call   20a <__fsm_skb_pending_xmit+0x3a>
	spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
	tasklet_schedule(fsm_core.tx_tsklt);
     20e:	a1 c0 02 00 00       	mov    0x2c0,%eax
 */
static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
{
	int oldbit;

	asm volatile(LOCK_PREFIX "bts %2,%1\n\t"
     213:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     219:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     21b:	85 d2                	test   %edx,%edx
     21d:	75 05                	jne    224 <__fsm_skb_pending_xmit+0x54>
		__tasklet_schedule(t);
     21f:	e8 fc ff ff ff       	call   220 <__fsm_skb_pending_xmit+0x50>
//	fsm_pkt_destroy(pkptr);
	return;
}
     224:	8b 5d f8             	mov    -0x8(%ebp),%ebx
     227:	8b 75 fc             	mov    -0x4(%ebp),%esi
     22a:	89 ec                	mov    %ebp,%esp
     22c:	5d                   	pop    %ebp
     22d:	c3                   	ret    
     22e:	66 90                	xchg   %ax,%ax

00000230 <__fsm_skb_pending_netrx>:
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     230:	55                   	push   %ebp
     231:	89 e5                	mov    %esp,%ebp
     233:	56                   	push   %esi
     234:	53                   	push   %ebx
     235:	e8 fc ff ff ff       	call   236 <__fsm_skb_pending_netrx+0x6>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
     23a:	66 83 f9 08          	cmp    $0x8,%cx
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     23e:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
     240:	66 89 48 66          	mov    %cx,0x66(%eax)
	skb->dev = dev;
     244:	89 50 14             	mov    %edx,0x14(%eax)
	if(skb->protocol == htons(ETH_P_IP))
     247:	75 0d                	jne    256 <__fsm_skb_pending_netrx+0x26>
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     249:	0f b6 40 64          	movzbl 0x64(%eax),%eax
     24d:	83 e0 f3             	and    $0xfffffff3,%eax
     250:	83 c8 04             	or     $0x4,%eax
     253:	88 43 64             	mov    %al,0x64(%ebx)
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     256:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     25b:	e8 fc ff ff ff       	call   25c <__fsm_skb_pending_netrx+0x2c>
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     260:	89 da                	mov    %ebx,%edx
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     262:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     264:	a1 bc 02 00 00       	mov    0x2bc,%eax
     269:	e8 fc ff ff ff       	call   26a <__fsm_skb_pending_netrx+0x3a>
     26e:	89 f2                	mov    %esi,%edx
     270:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     275:	e8 fc ff ff ff       	call   276 <__fsm_skb_pending_netrx+0x46>
	spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
	tasklet_schedule(fsm_core.rx_tsklt);
     27a:	a1 c4 02 00 00       	mov    0x2c4,%eax
     27f:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     285:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     287:	85 d2                	test   %edx,%edx
     289:	75 05                	jne    290 <__fsm_skb_pending_netrx+0x60>
		__tasklet_schedule(t);
     28b:	e8 fc ff ff ff       	call   28c <__fsm_skb_pending_netrx+0x5c>
//	fsm_pkt_destroy(pkptr);
	return;
}
     290:	5b                   	pop    %ebx
     291:	5e                   	pop    %esi
     292:	5d                   	pop    %ebp
     293:	c3                   	ret    
     294:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     29a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000002a0 <fsm_ev_type>:

/* ---------------------utilities for state machine-----------------------------*/

/* Return information of event.	*/
u32 fsm_ev_type()
{
     2a0:	55                   	push   %ebp
     2a1:	89 e5                	mov    %esp,%ebp
     2a3:	e8 fc ff ff ff       	call   2a4 <fsm_ev_type+0x4>
	return fsm_core.evtype;
}
     2a8:	a1 30 00 00 00       	mov    0x30,%eax
     2ad:	5d                   	pop    %ebp
     2ae:	c3                   	ret    
     2af:	90                   	nop

000002b0 <fsm_ev_code>:

u32 fsm_ev_code()
{
     2b0:	55                   	push   %ebp
     2b1:	89 e5                	mov    %esp,%ebp
     2b3:	e8 fc ff ff ff       	call   2b4 <fsm_ev_code+0x4>
	return fsm_core.code;
}
     2b8:	a1 34 00 00 00       	mov    0x34,%eax
     2bd:	5d                   	pop    %ebp
     2be:	c3                   	ret    
     2bf:	90                   	nop

000002c0 <fsm_ev_src>:

int fsm_ev_src()
{
     2c0:	55                   	push   %ebp
     2c1:	89 e5                	mov    %esp,%ebp
     2c3:	e8 fc ff ff ff       	call   2c4 <fsm_ev_src+0x4>
	return fsm_core.src;
}
     2c8:	a1 38 00 00 00       	mov    0x38,%eax
     2cd:	5d                   	pop    %ebp
     2ce:	c3                   	ret    
     2cf:	90                   	nop

000002d0 <fsm_ev_ioctrl_cmd>:

u32 fsm_ev_ioctrl_cmd()
{
     2d0:	55                   	push   %ebp
     2d1:	89 e5                	mov    %esp,%ebp
     2d3:	e8 fc ff ff ff       	call   2d4 <fsm_ev_ioctrl_cmd+0x4>
	return fsm_core.ioctrl_cmd;
}
     2d8:	a1 b0 02 00 00       	mov    0x2b0,%eax
     2dd:	5d                   	pop    %ebp
     2de:	c3                   	ret    
     2df:	90                   	nop

000002e0 <fsm_sv_ptr_get>:

/* FSM information get */
void* fsm_sv_ptr_get()
{
     2e0:	55                   	push   %ebp
     2e1:	89 e5                	mov    %esp,%ebp
     2e3:	e8 fc ff ff ff       	call   2e4 <fsm_sv_ptr_get+0x4>
	return fsm_core.fsm_sv_ptr;
}
     2e8:	a1 3c 00 00 00       	mov    0x3c,%eax
     2ed:	5d                   	pop    %ebp
     2ee:	c3                   	ret    
     2ef:	90                   	nop

000002f0 <fsm_current_state_ptr_get>:

int* fsm_current_state_ptr_get()
{
     2f0:	55                   	push   %ebp
     2f1:	89 e5                	mov    %esp,%ebp
     2f3:	e8 fc ff ff ff       	call   2f4 <fsm_current_state_ptr_get+0x4>
	return fsm_core.current_state_ptr;
}
     2f8:	a1 24 00 00 00       	mov    0x24,%eax
     2fd:	5d                   	pop    %ebp
     2fe:	c3                   	ret    
     2ff:	90                   	nop

00000300 <fsm_dev_get>:

void* fsm_dev_get()
{
     300:	55                   	push   %ebp
     301:	89 e5                	mov    %esp,%ebp
     303:	e8 fc ff ff ff       	call   304 <fsm_dev_get+0x4>
	return fsm_core.dev;
}
     308:	a1 a8 02 00 00       	mov    0x2a8,%eax
     30d:	5d                   	pop    %ebp
     30e:	c3                   	ret    
     30f:	90                   	nop

00000310 <fsm_get_id_by_name>:

int fsm_get_id_by_name(const char* name)
{
     310:	55                   	push   %ebp
     311:	89 e5                	mov    %esp,%ebp
     313:	56                   	push   %esi
     314:	53                   	push   %ebx
     315:	e8 fc ff ff ff       	call   316 <fsm_get_id_by_name+0x6>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     31a:	31 db                	xor    %ebx,%ebx
{
	return fsm_core.dev;
}

int fsm_get_id_by_name(const char* name)
{
     31c:	89 c6                	mov    %eax,%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
     31e:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
     325:	89 f2                	mov    %esi,%edx
     327:	e8 fc ff ff ff       	call   328 <fsm_get_id_by_name+0x18>
     32c:	85 c0                	test   %eax,%eax
     32e:	74 18                	je     348 <fsm_get_id_by_name+0x38>
}

int fsm_get_id_by_name(const char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     330:	83 c3 01             	add    $0x1,%ebx
     333:	83 fb 06             	cmp    $0x6,%ebx
     336:	75 e6                	jne    31e <fsm_get_id_by_name+0xe>
			{
			return FSM[i]->id;
			}
		}
	return -1;
}
     338:	5b                   	pop    %ebx
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
			}
		}
	return -1;
     339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
     33e:	5e                   	pop    %esi
     33f:	5d                   	pop    %ebp
     340:	c3                   	ret    
     341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     348:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
			}
		}
	return -1;
}
     34f:	5b                   	pop    %ebx
     350:	5e                   	pop    %esi
     351:	5d                   	pop    %ebp
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     352:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
			}
		}
	return -1;
}
     358:	c3                   	ret    
     359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000360 <fsm_get_name_by_id>:

void fsm_get_name_by_id(int id, char* name)
{
     360:	55                   	push   %ebp
     361:	89 e5                	mov    %esp,%ebp
     363:	53                   	push   %ebx
     364:	e8 fc ff ff ff       	call   365 <fsm_get_name_by_id+0x5>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     369:	31 c9                	xor    %ecx,%ecx
		}
	return -1;
}

void fsm_get_name_by_id(int id, char* name)
{
     36b:	89 d3                	mov    %edx,%ebx
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
     36d:	8b 14 8d 90 02 00 00 	mov    0x290(,%ecx,4),%edx
     374:	39 82 80 00 00 00    	cmp    %eax,0x80(%edx)
     37a:	74 14                	je     390 <fsm_get_name_by_id+0x30>
}

void fsm_get_name_by_id(int id, char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     37c:	83 c1 01             	add    $0x1,%ecx
     37f:	83 f9 06             	cmp    $0x6,%ecx
     382:	75 e9                	jne    36d <fsm_get_name_by_id+0xd>
			{
			strcpy(name, FSM[i]->name);
			break;
			}
		}
	*name ='\0';
     384:	c6 03 00             	movb   $0x0,(%ebx)
}
     387:	5b                   	pop    %ebx
     388:	5d                   	pop    %ebp
     389:	c3                   	ret    
     38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
			{
			strcpy(name, FSM[i]->name);
     390:	89 d8                	mov    %ebx,%eax
     392:	e8 fc ff ff ff       	call   393 <fsm_get_name_by_id+0x33>
			break;
			}
		}
	*name ='\0';
     397:	c6 03 00             	movb   $0x0,(%ebx)
}
     39a:	5b                   	pop    %ebx
     39b:	5d                   	pop    %ebp
     39c:	c3                   	ret    
     39d:	8d 76 00             	lea    0x0(%esi),%esi

000003a0 <fsm_intf_addr_get>:

void* fsm_intf_addr_get(int strm_id)
{
     3a0:	55                   	push   %ebp
     3a1:	89 e5                	mov    %esp,%ebp
     3a3:	e8 fc ff ff ff       	call   3a4 <fsm_intf_addr_get+0x4>
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3a8:	c1 e0 04             	shl    $0x4,%eax
     3ab:	8d 90 40 00 00 00    	lea    0x40(%eax),%edx
		return INTF[strm_id].dev->dev_addr;
	else
		return NULL;
     3b1:	31 c0                	xor    %eax,%eax
	*name ='\0';
}

void* fsm_intf_addr_get(int strm_id)
{
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3b3:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
     3b7:	75 09                	jne    3c2 <fsm_intf_addr_get+0x22>
		return INTF[strm_id].dev->dev_addr;
     3b9:	8b 42 0c             	mov    0xc(%edx),%eax
     3bc:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
	else
		return NULL;
}
     3c2:	5d                   	pop    %ebp
     3c3:	c3                   	ret    
     3c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     3ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000003d0 <fsm_self_addr_get>:
	
u8* fsm_self_addr_get()
{
     3d0:	55                   	push   %ebp
     3d1:	89 e5                	mov    %esp,%ebp
     3d3:	e8 fc ff ff ff       	call   3d4 <fsm_self_addr_get+0x4>
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3d8:	a1 a8 02 00 00       	mov    0x2a8,%eax
}
     3dd:	5d                   	pop    %ebp
	
u8* fsm_self_addr_get()
{
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3de:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
}
     3e4:	c3                   	ret    
     3e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     3e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000003f0 <fsm_data_get>:



void* fsm_data_get()
{
     3f0:	55                   	push   %ebp
     3f1:	89 e5                	mov    %esp,%ebp
     3f3:	e8 fc ff ff ff       	call   3f4 <fsm_data_get+0x4>
	void* buffer;
	buffer = fsm_core.buffer;
     3f8:	a1 ac 02 00 00       	mov    0x2ac,%eax
	fsm_core.buffer = NULL;
     3fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     404:	00 00 00 
	return buffer;
}
     407:	5d                   	pop    %ebp
     408:	c3                   	ret    
     409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000410 <fsm_data_destroy>:

void fsm_data_destroy(void* data_ptr)
{
     410:	55                   	push   %ebp
     411:	89 e5                	mov    %esp,%ebp
     413:	e8 fc ff ff ff       	call   414 <fsm_data_destroy+0x4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     418:	e8 fc ff ff ff       	call   419 <fsm_data_destroy+0x9>
}

void fsm_data_destroy(void* data_ptr)
{
	fsm_mem_free(data_ptr);
	freenum++;
     41d:	83 05 00 00 00 00 01 	addl   $0x1,0x0
}
     424:	5d                   	pop    %ebp
     425:	c3                   	ret    
     426:	8d 76 00             	lea    0x0(%esi),%esi
     429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000430 <__fsm_core_self_drive>:
		fsm_mem_free(tmev_ptr);
	}
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
     430:	55                   	push   %ebp
     431:	89 e5                	mov    %esp,%ebp
     433:	56                   	push   %esi
     434:	53                   	push   %ebx
     435:	e8 fc ff ff ff       	call   436 <__fsm_core_self_drive+0x6>
     43a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsm_core.current_fsm = dst_id;
     43d:	89 1d 20 00 00 00    	mov    %ebx,0x20
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     443:	8b 1c 9d 90 02 00 00 	mov    0x290(,%ebx,4),%ebx
	fsm_core.evtype = evtype;
     44a:	a3 30 00 00 00       	mov    %eax,0x30
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     44f:	8b 45 08             	mov    0x8(%ebp),%eax
static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
	fsm_core.evtype = evtype;
	fsm_core.code = code;
     452:	89 15 34 00 00 00    	mov    %edx,0x34
	fsm_core.pkptr = pkptr;
     458:	89 0d 2c 00 00 00    	mov    %ecx,0x2c
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     45e:	8d b3 8c 00 00 00    	lea    0x8c(%ebx),%esi
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     464:	a3 38 00 00 00       	mov    %eax,0x38
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     469:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     46f:	89 35 24 00 00 00    	mov    %esi,0x24
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     475:	a3 3c 00 00 00       	mov    %eax,0x3c
	fsm_core.buffer = buffer;
     47a:	8b 45 10             	mov    0x10(%ebp),%eax
     47d:	a3 ac 02 00 00       	mov    %eax,0x2ac
	fsm_core.ioctrl_cmd = ioctrl_cmd;
     482:	8b 45 14             	mov    0x14(%ebp),%eax
     485:	a3 b0 02 00 00       	mov    %eax,0x2b0
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
     48a:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
     490:	a3 40 00 00 00       	mov    %eax,0x40
	fsm_core.fsm_drive();
     495:	ff d0                	call   *%eax

/* ------------------internal functions-------------------------------*/
static void __fsm_ev_flush()
{
	
	if(fsm_core.pkptr)
     497:	a1 2c 00 00 00       	mov    0x2c,%eax
     49c:	85 c0                	test   %eax,%eax
     49e:	74 05                	je     4a5 <__fsm_core_self_drive+0x75>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     4a0:	e8 fc ff ff ff       	call   4a1 <__fsm_core_self_drive+0x71>
		}
//	if(fsm_core.buffer && !(fsm_ev_type()==FSM_EV_TYPE_CORE && fsm_ev_code()==FSM_EV_IOCTRL && fsm_ev_src()==USER_SPACE))
//		{
//		fsm_mem_free(fsm_core.buffer);
//		}
	if(fsm_core.buffer)
     4a5:	a1 ac 02 00 00       	mov    0x2ac,%eax
     4aa:	85 c0                	test   %eax,%eax
     4ac:	74 05                	je     4b3 <__fsm_core_self_drive+0x83>
		{
		fsm_data_destroy(fsm_core.buffer);
     4ae:	e8 fc ff ff ff       	call   4af <__fsm_core_self_drive+0x7f>
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4b3:	5b                   	pop    %ebx
//		}
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
     4b4:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
     4bb:	ff ff ff 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4be:	5e                   	pop    %esi
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
     4bf:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
     4c6:	00 00 00 
	fsm_core.pkptr = NULL;
     4c9:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     4d0:	00 00 00 
	fsm_core.evtype = INVALIDE;
     4d3:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
     4da:	00 00 00 
	fsm_core.code = INVALIDE;
     4dd:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
     4e4:	00 00 00 
	fsm_core.src = INVALIDE;
     4e7:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
     4ee:	00 00 00 
	FSM_SV_PTR = NULL;
     4f1:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
     4f8:	00 00 00 
	fsm_core.fsm_drive = NULL;
     4fb:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
     502:	00 00 00 
	fsm_core.buffer = NULL;
     505:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     50c:	00 00 00 
	fsm_core.ioctrl_cmd = INVALIDE;
     50f:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
     516:	00 00 00 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     519:	5d                   	pop    %ebp
     51a:	c3                   	ret    
     51b:	90                   	nop
     51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000520 <fsm_pkt_get>:


/* Packet operation */

FSM_PKT* fsm_pkt_get()
{
     520:	55                   	push   %ebp
     521:	89 e5                	mov    %esp,%ebp
     523:	e8 fc ff ff ff       	call   524 <fsm_pkt_get+0x4>
	FSM_PKT* ptr;
	ptr = fsm_core.pkptr;
     528:	a1 2c 00 00 00       	mov    0x2c,%eax
	fsm_core.pkptr = NULL;
     52d:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     534:	00 00 00 
	return ptr;
}
     537:	5d                   	pop    %ebp
     538:	c3                   	ret    
     539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000540 <fsm_pkt_send>:

void fsm_pkt_send(FSM_PKT* pkptr, int oinf)
{
     540:	55                   	push   %ebp
     541:	89 e5                	mov    %esp,%ebp
     543:	53                   	push   %ebx
     544:	e8 fc ff ff ff       	call   545 <fsm_pkt_send+0x5>
	if(oinf < MAX_INTF && INTF[oinf].valid)
     549:	83 fa 1f             	cmp    $0x1f,%edx
     54c:	7f 2a                	jg     578 <fsm_pkt_send+0x38>
     54e:	c1 e2 04             	shl    $0x4,%edx
     551:	8d 9a 40 00 00 00    	lea    0x40(%edx),%ebx
     557:	8b 53 04             	mov    0x4(%ebx),%edx
     55a:	85 d2                	test   %edx,%edx
     55c:	74 1a                	je     578 <fsm_pkt_send+0x38>
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
     55e:	83 fa 01             	cmp    $0x1,%edx
     561:	74 25                	je     588 <fsm_pkt_send+0x48>
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
			}
		else if(INTF[oinf].valid == DEV_INTF_IND)
     563:	83 fa 02             	cmp    $0x2,%edx
     566:	75 15                	jne    57d <fsm_pkt_send+0x3d>
			{
			INTF[oinf].send(pkptr, fsm_core.dev, INTF[oinf].proto);
     568:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     56c:	8b 15 a8 02 00 00    	mov    0x2a8,%edx
     572:	ff 53 10             	call   *0x10(%ebx)
     575:	eb 06                	jmp    57d <fsm_pkt_send+0x3d>
     577:	90                   	nop
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     578:	e8 fc ff ff ff       	call   579 <fsm_pkt_send+0x39>
	}
	else
	{
		fsm_pkt_destroy(pkptr);
	}
}
     57d:	5b                   	pop    %ebx
     57e:	5d                   	pop    %ebp
     57f:	90                   	nop
     580:	c3                   	ret    
     581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	if(oinf < MAX_INTF && INTF[oinf].valid)
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
     588:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     58c:	8b 53 0c             	mov    0xc(%ebx),%edx
     58f:	ff 53 10             	call   *0x10(%ebx)
     592:	eb e9                	jmp    57d <fsm_pkt_send+0x3d>
     594:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     59a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000005a0 <fsm_pkt_create>:
		fsm_pkt_destroy(pkptr);
	}
}

FSM_PKT* fsm_pkt_create(unsigned int size)
{
     5a0:	55                   	push   %ebp
     5a1:	89 e5                	mov    %esp,%ebp
     5a3:	53                   	push   %ebx
     5a4:	e8 fc ff ff ff       	call   5a5 <fsm_pkt_create+0x5>
 *	allocates memory it can be called from an interrupt.
 */
static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
					       unsigned int length)
{
	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
     5a9:	b9 20 00 00 00       	mov    $0x20,%ecx
     5ae:	89 c2                	mov    %eax,%edx
     5b0:	31 c0                	xor    %eax,%eax
     5b2:	e8 fc ff ff ff       	call   5b3 <fsm_pkt_create+0x13>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5b7:	31 d2                	xor    %edx,%edx
     5b9:	89 c3                	mov    %eax,%ebx

FSM_PKT* fsm_pkt_create(unsigned int size)
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
     5bb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
     5c1:	8b 8b a4 00 00 00    	mov    0xa4(%ebx),%ecx
     5c7:	29 c1                	sub    %eax,%ecx
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5c9:	e8 fc ff ff ff       	call   5ca <fsm_pkt_create+0x2a>
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
	return pkptr;
}
     5ce:	89 d8                	mov    %ebx,%eax
     5d0:	5b                   	pop    %ebx
     5d1:	5d                   	pop    %ebp
     5d2:	c3                   	ret    
     5d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005e0 <fsm_skb_realloc_headeroom>:


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
     5e0:	55                   	push   %ebp
     5e1:	89 e5                	mov    %esp,%ebp
     5e3:	83 ec 0c             	sub    $0xc,%esp
     5e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     5e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
     5ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
     5ef:	e8 fc ff ff ff       	call   5f0 <fsm_skb_realloc_headeroom+0x10>
     5f4:	89 c3                	mov    %eax,%ebx
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5f6:	e8 fc ff ff ff       	call   5f7 <fsm_skb_realloc_headeroom+0x17>
	if (unlikely(pkptr_new == NULL))
     5fb:	85 c0                	test   %eax,%eax


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5fd:	89 c6                	mov    %eax,%esi
	if (unlikely(pkptr_new == NULL))
     5ff:	74 27                	je     628 <fsm_skb_realloc_headeroom+0x48>
        {
        KFREE_SKB(pkptr);
        return NULL;
       	}
    if(pkptr->sk)
     601:	8b 7b 10             	mov    0x10(%ebx),%edi
     604:	85 ff                	test   %edi,%edi
     606:	74 20                	je     628 <fsm_skb_realloc_headeroom+0x48>
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */
static inline void skb_orphan(struct sk_buff *skb)
{
	if (skb->destructor)
     608:	8b 50 68             	mov    0x68(%eax),%edx
     60b:	85 d2                	test   %edx,%edx
     60d:	74 02                	je     611 <fsm_skb_realloc_headeroom+0x31>
		skb->destructor(skb);
     60f:	ff d2                	call   *%edx
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	skb_orphan(skb);
	skb->sk = sk;
     611:	89 7e 10             	mov    %edi,0x10(%esi)
 *
 * Atomically adds @i to @v.
 */
static inline void atomic_add(int i, atomic_t *v)
{
	asm volatile(LOCK_PREFIX "addl %1,%0"
     614:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
	skb->destructor = sock_wfree;
     61a:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
     621:	f0 01 87 94 00 00 00 	lock add %eax,0x94(%edi)
        {
        SKB_SET_OWNER_W(pkptr_new, pkptr->sk); 
	}
	KFREE_SKB(pkptr);
     628:	89 d8                	mov    %ebx,%eax
     62a:	e8 fc ff ff ff       	call   62b <fsm_skb_realloc_headeroom+0x4b>
	return pkptr_new;
}
     62f:	89 f0                	mov    %esi,%eax
     631:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     634:	8b 75 f8             	mov    -0x8(%ebp),%esi
     637:	8b 7d fc             	mov    -0x4(%ebp),%edi
     63a:	89 ec                	mov    %ebp,%esp
     63c:	5d                   	pop    %ebp
     63d:	c3                   	ret    
     63e:	66 90                	xchg   %ax,%ax

00000640 <fsm_pkt_destroy>:

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
     640:	55                   	push   %ebp
     641:	89 e5                	mov    %esp,%ebp
     643:	e8 fc ff ff ff       	call   644 <fsm_pkt_destroy+0x4>
	KFREE_SKB(pkptr);
     648:	e8 fc ff ff ff       	call   649 <fsm_pkt_destroy+0x9>
}
     64d:	5d                   	pop    %ebp
     64e:	c3                   	ret    
     64f:	90                   	nop

00000650 <fsm_pkt_duplicate>:

FSM_PKT* fsm_pkt_duplicate(FSM_PKT* pkptr)
{
     650:	55                   	push   %ebp
     651:	89 e5                	mov    %esp,%ebp
     653:	e8 fc ff ff ff       	call   654 <fsm_pkt_duplicate+0x4>
	return SKB_COPY(pkptr, GFP_ATOMIC);
     658:	ba 20 00 00 00       	mov    $0x20,%edx
     65d:	e8 fc ff ff ff       	call   65e <fsm_pkt_duplicate+0xe>
}
     662:	5d                   	pop    %ebp
     663:	c3                   	ret    
     664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     66a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000670 <fsm_skb_put>:

u8* fsm_skb_put(FSM_PKT* pkptr, int len)
{	
     670:	55                   	push   %ebp
     671:	89 e5                	mov    %esp,%ebp
     673:	e8 fc ff ff ff       	call   674 <fsm_skb_put+0x4>
	return (u8*)SKB_PUT(pkptr, len);
     678:	e8 fc ff ff ff       	call   679 <fsm_skb_put+0x9>
}
     67d:	5d                   	pop    %ebp
     67e:	c3                   	ret    
     67f:	90                   	nop

00000680 <fsm_skb_push>:

u8* fsm_skb_push(FSM_PKT* pkptr, int len)
{
     680:	55                   	push   %ebp
     681:	89 e5                	mov    %esp,%ebp
     683:	e8 fc ff ff ff       	call   684 <fsm_skb_push+0x4>
	return SKB_PUSH(pkptr, len);
     688:	e8 fc ff ff ff       	call   689 <fsm_skb_push+0x9>
}
     68d:	5d                   	pop    %ebp
     68e:	c3                   	ret    
     68f:	90                   	nop

00000690 <fsm_skb_pull>:

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	e8 fc ff ff ff       	call   694 <fsm_skb_pull+0x4>
     698:	89 c1                	mov    %eax,%ecx
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     69a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	pkptr->len -= len;
     6a0:	29 51 50             	sub    %edx,0x50(%ecx)
}

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     6a3:	01 d0                	add    %edx,%eax
     6a5:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
	pkptr->len -= len;
	return (u8 *)pkptr->data;
}
     6ab:	5d                   	pop    %ebp
     6ac:	c3                   	ret    
     6ad:	8d 76 00             	lea    0x0(%esi),%esi

000006b0 <fsm_skb_reserve>:

void fsm_skb_reserve(FSM_PKT* pkptr , int len)
{
     6b0:	55                   	push   %ebp
     6b1:	89 e5                	mov    %esp,%ebp
     6b3:	e8 fc ff ff ff       	call   6b4 <fsm_skb_reserve+0x4>
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
     6b8:	01 90 ac 00 00 00    	add    %edx,0xac(%eax)
	skb->tail += len;
     6be:	01 90 a0 00 00 00    	add    %edx,0xa0(%eax)
	SKB_RESERVE(pkptr, len);
}
     6c4:	5d                   	pop    %ebp
     6c5:	c3                   	ret    
     6c6:	8d 76 00             	lea    0x0(%esi),%esi
     6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000006d0 <fsm_skb_tailroom>:

int fsm_skb_tailroom(FSM_PKT* pkptr)
{
     6d0:	55                   	push   %ebp
     6d1:	89 e5                	mov    %esp,%ebp
     6d3:	e8 fc ff ff ff       	call   6d4 <fsm_skb_tailroom+0x4>
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */
static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
     6d8:	31 d2                	xor    %edx,%edx
     6da:	8b 48 54             	mov    0x54(%eax),%ecx
     6dd:	85 c9                	test   %ecx,%ecx
     6df:	75 0c                	jne    6ed <fsm_skb_tailroom+0x1d>
     6e1:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
     6e7:	2b 90 a0 00 00 00    	sub    0xa0(%eax),%edx
	return SKB_TAILROOM(pkptr);
}
     6ed:	89 d0                	mov    %edx,%eax
     6ef:	5d                   	pop    %ebp
     6f0:	c3                   	ret    
     6f1:	eb 0d                	jmp    700 <fsm_skb_headroom>
     6f3:	90                   	nop
     6f4:	90                   	nop
     6f5:	90                   	nop
     6f6:	90                   	nop
     6f7:	90                   	nop
     6f8:	90                   	nop
     6f9:	90                   	nop
     6fa:	90                   	nop
     6fb:	90                   	nop
     6fc:	90                   	nop
     6fd:	90                   	nop
     6fe:	90                   	nop
     6ff:	90                   	nop

00000700 <fsm_skb_headroom>:

int fsm_skb_headroom(FSM_PKT* pkptr)
{
     700:	55                   	push   %ebp
     701:	89 e5                	mov    %esp,%ebp
     703:	e8 fc ff ff ff       	call   704 <fsm_skb_headroom+0x4>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
     708:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
     70e:	2b 90 a8 00 00 00    	sub    0xa8(%eax),%edx
	return SKB_HEADROOM(pkptr);
}
     714:	5d                   	pop    %ebp
     715:	89 d0                	mov    %edx,%eax
     717:	c3                   	ret    
     718:	90                   	nop
     719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000720 <fsm_mem_alloc>:

/* Memory operation */
void* fsm_mem_alloc(size_t size)
{
     720:	55                   	push   %ebp
     721:	89 e5                	mov    %esp,%ebp
     723:	e8 fc ff ff ff       	call   724 <fsm_mem_alloc+0x4>
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(s, flags, size);
		}
	}
	return __kmalloc(size, flags);
     728:	ba 20 00 00 00       	mov    $0x20,%edx
     72d:	e8 fc ff ff ff       	call   72e <fsm_mem_alloc+0xe>
	void* ptr;
	ptr = FSM_MEM_ALLOC(size);
	mallocnum++;
     732:	83 05 00 00 00 00 01 	addl   $0x1,0x0
	return ptr;
}
     739:	5d                   	pop    %ebp
     73a:	c3                   	ret    
     73b:	90                   	nop
     73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000740 <__fsm_tm_ev_add.constprop.7>:
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     740:	55                   	push   %ebp
     741:	89 e5                	mov    %esp,%ebp
     743:	57                   	push   %edi
     744:	56                   	push   %esi
     745:	53                   	push   %ebx
     746:	83 ec 14             	sub    $0x14,%esp
     749:	e8 fc ff ff ff       	call   74a <__fsm_tm_ev_add.constprop.7+0xa>
     74e:	89 c3                	mov    %eax,%ebx
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     750:	b8 2c 00 00 00       	mov    $0x2c,%eax
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     755:	89 d6                	mov    %edx,%esi
     757:	89 cf                	mov    %ecx,%edi
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     759:	e8 fc ff ff ff       	call   75a <__fsm_tm_ev_add.constprop.7+0x1a>
	if(pE)
     75e:	85 c0                	test   %eax,%eax
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     760:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(pE)
     763:	0f 84 bc 00 00 00    	je     825 <__fsm_tm_ev_add.constprop.7+0xe5>
	{
		pE->evmask = EVMASK;
     769:	c7 40 04 d6 96 0f 04 	movl   $0x40f96d6,0x4(%eax)
		pE->pNext = 0;
		pE->type = type;
		pE->code = code;
		pE->delay = delay;
		pE->pkptr = pkptr;
		pE->src_id =src;
     770:	8b 55 f0             	mov    -0x10(%ebp),%edx
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
     773:	85 db                	test   %ebx,%ebx
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
	if(pE)
	{
		pE->evmask = EVMASK;
		pE->pNext = 0;
     775:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		pE->type = type;
     77b:	89 70 18             	mov    %esi,0x18(%eax)
		pE->code = code;
     77e:	89 78 14             	mov    %edi,0x14(%eax)
		pE->delay = delay;
     781:	89 58 10             	mov    %ebx,0x10(%eax)
		pE->pkptr = pkptr;
     784:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
		pE->src_id =src;
     78b:	8b 45 08             	mov    0x8(%ebp),%eax
     78e:	89 42 24             	mov    %eax,0x24(%edx)
		pE->dst_id = dst;
     791:	8b 45 0c             	mov    0xc(%ebp),%eax
     794:	89 42 20             	mov    %eax,0x20(%edx)
		pE->buffer = buffer;
     797:	8b 45 10             	mov    0x10(%ebp),%eax
     79a:	89 42 28             	mov    %eax,0x28(%edx)
		if(delay == 0)
     79d:	0f 84 8d 00 00 00    	je     830 <__fsm_tm_ev_add.constprop.7+0xf0>
			pE->expire = ktime_add_us(ktime_get(), 10);
		else
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
     7a3:	e8 fc ff ff ff       	call   7a4 <__fsm_tm_ev_add.constprop.7+0x64>
     7a8:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
     7ab:	01 db                	add    %ebx,%ebx
     7ad:	89 c6                	mov    %eax,%esi
       return ktime_to_us(ktime_sub(later, earlier));
}

static inline ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
	return ktime_add_ns(kt, usec * 1000);
     7af:	b8 e8 03 00 00       	mov    $0x3e8,%eax
     7b4:	89 d7                	mov    %edx,%edi
     7b6:	f7 e3                	mul    %ebx
     7b8:	01 f0                	add    %esi,%eax
     7ba:	8b 75 f0             	mov    -0x10(%ebp),%esi
     7bd:	11 fa                	adc    %edi,%edx
     7bf:	89 46 08             	mov    %eax,0x8(%esi)
     7c2:	89 56 0c             	mov    %edx,0xc(%esi)
	__tmEvent* p0;
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     7c5:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     7ca:	e8 fc ff ff ff       	call   7cb <__fsm_tm_ev_add.constprop.7+0x8b>
     7cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     7d2:	a1 88 02 00 00       	mov    0x288,%eax
     7d7:	85 c0                	test   %eax,%eax
     7d9:	74 24                	je     7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     7db:	8b 7d f0             	mov    -0x10(%ebp),%edi
     7de:	8b 48 08             	mov    0x8(%eax),%ecx
     7e1:	8b 58 0c             	mov    0xc(%eax),%ebx
     7e4:	8b 77 08             	mov    0x8(%edi),%esi
     7e7:	8b 7f 0c             	mov    0xc(%edi),%edi
     7ea:	89 75 e8             	mov    %esi,-0x18(%ebp)
     7ed:	89 ce                	mov    %ecx,%esi
     7ef:	89 7d ec             	mov    %edi,-0x14(%ebp)
     7f2:	89 df                	mov    %ebx,%edi
     7f4:	2b 75 e8             	sub    -0x18(%ebp),%esi
     7f7:	1b 7d ec             	sbb    -0x14(%ebp),%edi
     7fa:	83 ff 00             	cmp    $0x0,%edi
     7fd:	7e 51                	jle    850 <__fsm_tm_ev_add.constprop.7+0x110>
	{
		pE->pNext = pB->evQ;
     7ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
     802:	89 02                	mov    %eax,(%edx)
		pB->evQ = pE;
		if(pB->tm_state != FSM_TM_EXPIRE)
     804:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
	{
		pE->pNext = pB->evQ;
		pB->evQ = pE;
     80b:	89 15 88 02 00 00    	mov    %edx,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     811:	74 05                	je     818 <__fsm_tm_ev_add.constprop.7+0xd8>
		{
			__fsm_tm_restart();
     813:	e8 18 f9 ff ff       	call   130 <__fsm_tm_restart>
     818:	8b 55 e0             	mov    -0x20(%ebp),%edx
     81b:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     820:	e8 fc ff ff ff       	call   821 <__fsm_tm_ev_add.constprop.7+0xe1>
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
		__fsm_tm_ev_insert(pE);
		return EVHANDLE(pE);
	}
	return 0;
}
     825:	8b 45 f0             	mov    -0x10(%ebp),%eax
     828:	83 c4 14             	add    $0x14,%esp
     82b:	5b                   	pop    %ebx
     82c:	5e                   	pop    %esi
     82d:	5f                   	pop    %edi
     82e:	5d                   	pop    %ebp
     82f:	c3                   	ret    
		pE->pkptr = pkptr;
		pE->src_id =src;
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
			pE->expire = ktime_add_us(ktime_get(), 10);
     830:	e8 fc ff ff ff       	call   831 <__fsm_tm_ev_add.constprop.7+0xf1>
     835:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     838:	05 10 27 00 00       	add    $0x2710,%eax
     83d:	83 d2 00             	adc    $0x0,%edx
     840:	89 41 08             	mov    %eax,0x8(%ecx)
     843:	89 51 0c             	mov    %edx,0xc(%ecx)
     846:	e9 7a ff ff ff       	jmp    7c5 <__fsm_tm_ev_add.constprop.7+0x85>
     84b:	90                   	nop
     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     850:	7c 1f                	jl     871 <__fsm_tm_ev_add.constprop.7+0x131>
     852:	83 fe 00             	cmp    $0x0,%esi
     855:	76 1a                	jbe    871 <__fsm_tm_ev_add.constprop.7+0x131>
     857:	eb a6                	jmp    7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
	{
		p1 = p0;
		p0 = p0->pNext;
     860:	8b 10                	mov    (%eax),%edx
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return;
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
     862:	85 d2                	test   %edx,%edx
     864:	74 32                	je     898 <__fsm_tm_ev_add.constprop.7+0x158>
     866:	8b 4a 08             	mov    0x8(%edx),%ecx
     869:	8b 5a 0c             	mov    0xc(%edx),%ebx
     86c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     86f:	89 d0                	mov    %edx,%eax
     871:	8b 75 e8             	mov    -0x18(%ebp),%esi
     874:	8b 7d ec             	mov    -0x14(%ebp),%edi
     877:	29 ce                	sub    %ecx,%esi
     879:	19 df                	sbb    %ebx,%edi
     87b:	83 ff 00             	cmp    $0x0,%edi
     87e:	7f e0                	jg     860 <__fsm_tm_ev_add.constprop.7+0x120>
     880:	7c 05                	jl     887 <__fsm_tm_ev_add.constprop.7+0x147>
     882:	83 fe 00             	cmp    $0x0,%esi
     885:	77 d9                	ja     860 <__fsm_tm_ev_add.constprop.7+0x120>
     887:	8b 55 ec             	mov    -0x14(%ebp),%edx
     88a:	33 4d e8             	xor    -0x18(%ebp),%ecx
     88d:	31 da                	xor    %ebx,%edx
     88f:	09 ca                	or     %ecx,%edx
     891:	74 cd                	je     860 <__fsm_tm_ev_add.constprop.7+0x120>
     893:	89 c2                	mov    %eax,%edx
     895:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		p1 = p0;
		p0 = p0->pNext;
	}
	pE->pNext = p0;
     898:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     89b:	89 11                	mov    %edx,(%ecx)
	p1->pNext = pE;
     89d:	89 08                	mov    %ecx,(%eax)
     89f:	e9 74 ff ff ff       	jmp    818 <__fsm_tm_ev_add.constprop.7+0xd8>
     8a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     8aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000008b0 <fsm_mem_free>:
	mallocnum++;
	return ptr;
}

void fsm_mem_free(void* ptr)
{
     8b0:	55                   	push   %ebp
     8b1:	89 e5                	mov    %esp,%ebp
     8b3:	e8 fc ff ff ff       	call   8b4 <fsm_mem_free+0x4>
	FSM_MEM_FREE(ptr);
     8b8:	e8 fc ff ff ff       	call   8b9 <fsm_mem_free+0x9>
}
     8bd:	5d                   	pop    %ebp
     8be:	c3                   	ret    
     8bf:	90                   	nop

000008c0 <fsm_mem_cpy>:

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
     8c0:	55                   	push   %ebp
     8c1:	89 e5                	mov    %esp,%ebp
     8c3:	e8 fc ff ff ff       	call   8c4 <fsm_mem_cpy+0x4>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     8c8:	e8 fc ff ff ff       	call   8c9 <fsm_mem_cpy+0x9>
}
     8cd:	5d                   	pop    %ebp
     8ce:	c3                   	ret    
     8cf:	90                   	nop

000008d0 <fsm_mem_set>:

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
     8d0:	55                   	push   %ebp
     8d1:	89 e5                	mov    %esp,%ebp
     8d3:	e8 fc ff ff ff       	call   8d4 <fsm_mem_set+0x4>
	return FSM_MEM_SET(dst_ptr,val,size);
     8d8:	e8 fc ff ff ff       	call   8d9 <fsm_mem_set+0x9>
}
     8dd:	5d                   	pop    %ebp
     8de:	c3                   	ret    
     8df:	90                   	nop

000008e0 <fsm_mem_cmp>:

int fsm_mem_cmp(const void* dst_ptr, const void* src_ptr, size_t size)
{
     8e0:	55                   	push   %ebp
     8e1:	89 e5                	mov    %esp,%ebp
     8e3:	e8 fc ff ff ff       	call   8e4 <fsm_mem_cmp+0x4>
	return FSM_MEM_CMP(dst_ptr,src_ptr,size);
     8e8:	e8 fc ff ff ff       	call   8e9 <fsm_mem_cmp+0x9>
}
     8ed:	5d                   	pop    %ebp
     8ee:	c3                   	ret    
     8ef:	90                   	nop

000008f0 <fsm_printf>:


/* Print */
size_t fsm_printf(const char* fmt,...)
{
     8f0:	55                   	push   %ebp
     8f1:	89 e5                	mov    %esp,%ebp
     8f3:	83 ec 08             	sub    $0x8,%esp
     8f6:	e8 fc ff ff ff       	call   8f7 <fsm_printf+0x7>
	//return 0;
	int print_len;
	va_list args;
	va_start(args,fmt);
     8fb:	8d 45 0c             	lea    0xc(%ebp),%eax
	print_len = VPRINTK(fmt,args);
     8fe:	89 44 24 04          	mov    %eax,0x4(%esp)
     902:	8b 45 08             	mov    0x8(%ebp),%eax
     905:	89 04 24             	mov    %eax,(%esp)
     908:	e8 fc ff ff ff       	call   909 <fsm_printf+0x19>
	va_end(args);
	return print_len;
	
	return 0;
}
     90d:	c9                   	leave  
     90e:	c3                   	ret    
     90f:	90                   	nop

00000910 <__fsm_pending_expev>:
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}

static void __fsm_pending_expev(unsigned long data)
{
     910:	55                   	push   %ebp
     911:	89 e5                	mov    %esp,%ebp
     913:	57                   	push   %edi
     914:	56                   	push   %esi
     915:	53                   	push   %ebx
     916:	83 ec 18             	sub    $0x18,%esp
     919:	e8 fc ff ff ff       	call   91a <__fsm_pending_expev+0xa>
     91e:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     924:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     92a:	0f 85 a5 00 00 00    	jne    9d5 <__fsm_pending_expev+0xc5>
     930:	e9 eb 00 00 00       	jmp    a20 <__fsm_pending_expev+0x110>
     935:	8d 76 00             	lea    0x0(%esi),%esi
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     938:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     93d:	e8 fc ff ff ff       	call   93e <__fsm_pending_expev+0x2e>
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     942:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
     945:	8b 53 14             	mov    0x14(%ebx),%edx
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     948:	89 45 ec             	mov    %eax,-0x14(%ebp)
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     94b:	8b 43 18             	mov    0x18(%ebx),%eax
     94e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     955:	00 
     956:	8b 7b 28             	mov    0x28(%ebx),%edi
     959:	89 7c 24 08          	mov    %edi,0x8(%esp)
     95d:	8b 7b 20             	mov    0x20(%ebx),%edi
     960:	89 7c 24 04          	mov    %edi,0x4(%esp)
     964:	8b 7b 24             	mov    0x24(%ebx),%edi
     967:	89 3c 24             	mov    %edi,(%esp)
     96a:	e8 c1 fa ff ff       	call   430 <__fsm_core_self_drive>
     96f:	8b 55 ec             	mov    -0x14(%ebp),%edx
     972:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     977:	e8 fc ff ff ff       	call   978 <__fsm_pending_expev+0x68>

#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)

static inline int arch_spin_is_locked(struct arch_spinlock *lock)
{
	return PVOP_CALL1(int, pv_lock_ops.spin_is_locked, lock);
     97c:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     981:	ff 15 00 00 00 00    	call   *0x0
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
     987:	85 c0                	test   %eax,%eax
     989:	75 7d                	jne    a08 <__fsm_pending_expev+0xf8>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
//			return;
		} 
		spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
     98b:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     990:	e8 fc ff ff ff       	call   991 <__fsm_pending_expev+0x81>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     995:	8b 4e 04             	mov    0x4(%esi),%ecx
     998:	8b 3e                	mov    (%esi),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     99a:	89 4f 04             	mov    %ecx,0x4(%edi)
     99d:	89 c2                	mov    %eax,%edx
     99f:	b8 e6 02 00 00       	mov    $0x2e6,%eax
	prev->next = next;
     9a4:	89 39                	mov    %edi,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     9a6:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
     9ac:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
     9b3:	e8 fc ff ff ff       	call   9b4 <__fsm_pending_expev+0xa4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     9b8:	89 d8                	mov    %ebx,%eax
     9ba:	e8 fc ff ff ff       	call   9bb <__fsm_pending_expev+0xab>
     9bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9c2:	e8 fc ff ff ff       	call   9c3 <__fsm_pending_expev+0xb3>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     9c7:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
static void __fsm_pending_expev(unsigned long data)
{
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     9cd:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     9d3:	74 4b                	je     a20 <__fsm_pending_expev+0x110>
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9d5:	8d 46 fc             	lea    -0x4(%esi),%eax
		pE = tmev_ptr->pE;
     9d8:	8b 5e fc             	mov    -0x4(%esi),%ebx
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9db:	89 45 f0             	mov    %eax,-0x10(%ebp)
     9de:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     9e3:	ff 15 00 00 00 00    	call   *0x0
		pE = tmev_ptr->pE;
		if(spin_is_locked(&fsm_core.lock))
     9e9:	85 c0                	test   %eax,%eax
     9eb:	0f 84 47 ff ff ff    	je     938 <__fsm_pending_expev+0x28>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
     9f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     9f8:	e8 fc ff ff ff       	call   9f9 <__fsm_pending_expev+0xe9>
     9fd:	e9 36 ff ff ff       	jmp    938 <__fsm_pending_expev+0x28>
     a02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
     a08:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
     a0f:	e8 fc ff ff ff       	call   a10 <__fsm_pending_expev+0x100>
     a14:	e9 72 ff ff ff       	jmp    98b <__fsm_pending_expev+0x7b>
     a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		list_del(&tmev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
		fsm_mem_free(pE);
		fsm_mem_free(tmev_ptr);
	}
}
     a20:	83 c4 18             	add    $0x18,%esp
     a23:	5b                   	pop    %ebx
     a24:	5e                   	pop    %esi
     a25:	5f                   	pop    %edi
     a26:	5d                   	pop    %ebp
     a27:	c3                   	ret    
     a28:	90                   	nop
     a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000a30 <__fsm_tm_expire>:
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
}

static enum hrtimer_restart __fsm_tm_expire(struct hrtimer *timer)
{
     a30:	55                   	push   %ebp
     a31:	89 e5                	mov    %esp,%ebp
     a33:	57                   	push   %edi
     a34:	56                   	push   %esi
     a35:	53                   	push   %ebx
     a36:	83 ec 08             	sub    $0x8,%esp
     a39:	e8 fc ff ff ff       	call   a3a <__fsm_tm_expire+0xa>
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a3e:	e8 fc ff ff ff       	call   a3f <__fsm_tm_expire+0xf>
	pB->tm_state = FSM_TM_EXPIRE;
     a43:	c7 05 44 02 00 00 02 	movl   $0x2,0x244
     a4a:	00 00 00 
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a4d:	89 c6                	mov    %eax,%esi
     a4f:	89 d7                	mov    %edx,%edi
     a51:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a56:	ff 15 00 00 00 00    	call   *0x0
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
     a5c:	85 c0                	test   %eax,%eax
     a5e:	0f 85 9c 00 00 00    	jne    b00 <__fsm_tm_expire+0xd0>
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a64:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a69:	e8 fc ff ff ff       	call   a6a <__fsm_tm_expire+0x3a>
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a6e:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     a74:	85 db                	test   %ebx,%ebx
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a79:	74 15                	je     a90 <__fsm_tm_expire+0x60>
     a7b:	8b 43 08             	mov    0x8(%ebx),%eax
     a7e:	8b 53 0c             	mov    0xc(%ebx),%edx
     a81:	29 f0                	sub    %esi,%eax
     a83:	19 fa                	sbb    %edi,%edx
     a85:	83 fa 00             	cmp    $0x0,%edx
     a88:	0f 8e a2 00 00 00    	jle    b30 <__fsm_tm_expire+0x100>
     a8e:	66 90                	xchg   %ax,%ax
     a90:	8b 55 f0             	mov    -0x10(%ebp),%edx
     a93:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a98:	e8 fc ff ff ff       	call   a99 <__fsm_tm_expire+0x69>
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
			tmev_ptr->pE = pE;
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);		
		tasklet_schedule(fsm_core.exp_ev_tsklt);
     a9d:	a1 cc 02 00 00       	mov    0x2cc,%eax
     aa2:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     aa8:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     aaa:	85 d2                	test   %edx,%edx
     aac:	74 42                	je     af0 <__fsm_tm_expire+0xc0>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     aae:	a1 88 02 00 00       	mov    0x288,%eax
     ab3:	85 c0                	test   %eax,%eax
     ab5:	74 61                	je     b18 <__fsm_tm_expire+0xe8>
     ab7:	8b 50 0c             	mov    0xc(%eax),%edx
     aba:	8b 40 08             	mov    0x8(%eax),%eax
        {	
		hrtimer_set_expires(&pB->timer, pB->evQ->expire);
		pB->tm_state = FSM_TM_RUN;	
     abd:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     ac4:	00 00 00 
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
};

static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
	timer->node.expires = time;
     ac7:	89 15 58 02 00 00    	mov    %edx,0x258
     acd:	a3 54 02 00 00       	mov    %eax,0x254
	timer->_softexpires = time;
     ad2:	a3 5c 02 00 00       	mov    %eax,0x25c
		return HRTIMER_RESTART;
     ad7:	b8 01 00 00 00       	mov    $0x1,%eax
     adc:	89 15 60 02 00 00    	mov    %edx,0x260
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     ae2:	83 c4 08             	add    $0x8,%esp
     ae5:	5b                   	pop    %ebx
     ae6:	5e                   	pop    %esi
     ae7:	5f                   	pop    %edi
     ae8:	5d                   	pop    %ebp
     ae9:	c3                   	ret    
     aea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		__tasklet_schedule(t);
     af0:	e8 fc ff ff ff       	call   af1 <__fsm_tm_expire+0xc1>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     af5:	a1 88 02 00 00       	mov    0x288,%eax
     afa:	85 c0                	test   %eax,%eax
     afc:	75 b9                	jne    ab7 <__fsm_tm_expire+0x87>
     afe:	eb 18                	jmp    b18 <__fsm_tm_expire+0xe8>
	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
	{
		fsm_printf("dead lock\n");
     b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     b07:	e8 fc ff ff ff       	call   b08 <__fsm_tm_expire+0xd8>
		return HRTIMER_NORESTART;
     b0c:	31 c0                	xor    %eax,%eax
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     b0e:	83 c4 08             	add    $0x8,%esp
     b11:	5b                   	pop    %ebx
     b12:	5e                   	pop    %esi
     b13:	5f                   	pop    %edi
     b14:	5d                   	pop    %ebp
     b15:	c3                   	ret    
     b16:	66 90                	xchg   %ax,%ax
		pB->tm_state = FSM_TM_RUN;	
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
     b18:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     b1f:	00 00 00 
		return HRTIMER_NORESTART;	
	}
	
}
     b22:	83 c4 08             	add    $0x8,%esp
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
     b25:	31 c0                	xor    %eax,%eax
	}
	
}
     b27:	5b                   	pop    %ebx
     b28:	5e                   	pop    %esi
     b29:	5f                   	pop    %edi
     b2a:	5d                   	pop    %ebp
     b2b:	c3                   	ret    
     b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b30:	7c 0f                	jl     b41 <__fsm_tm_expire+0x111>
     b32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b38:	83 f8 00             	cmp    $0x0,%eax
     b3b:	0f 87 4f ff ff ff    	ja     a90 <__fsm_tm_expire+0x60>
		{
			pE = pB->evQ;
			pB->evQ = pE->pNext;
     b41:	8b 03                	mov    (%ebx),%eax
     b43:	a3 88 02 00 00       	mov    %eax,0x288
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
     b48:	b8 0c 00 00 00       	mov    $0xc,%eax
     b4d:	e8 fc ff ff ff       	call   b4e <__fsm_tm_expire+0x11e>
			tmev_ptr->pE = pE;
     b52:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     b54:	8b 15 e0 02 00 00    	mov    0x2e0,%edx
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
     b5a:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     b5d:	89 0d e0 02 00 00    	mov    %ecx,0x2e0
	new->next = next;
     b63:	c7 40 04 dc 02 00 00 	movl   $0x2dc,0x4(%eax)
	new->prev = prev;
     b6a:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
     b6d:	89 0a                	mov    %ecx,(%edx)
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b6f:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     b75:	85 db                	test   %ebx,%ebx
     b77:	0f 84 13 ff ff ff    	je     a90 <__fsm_tm_expire+0x60>
     b7d:	8b 43 08             	mov    0x8(%ebx),%eax
     b80:	8b 53 0c             	mov    0xc(%ebx),%edx
     b83:	29 f0                	sub    %esi,%eax
     b85:	19 fa                	sbb    %edi,%edx
     b87:	83 fa 00             	cmp    $0x0,%edx
     b8a:	7c b5                	jl     b41 <__fsm_tm_expire+0x111>
     b8c:	0f 8f fe fe ff ff    	jg     a90 <__fsm_tm_expire+0x60>
     b92:	eb a4                	jmp    b38 <__fsm_tm_expire+0x108>
     b94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000ba0 <fsm_octets_print>:
	
	return 0;
}

size_t fsm_octets_print(void* data_ptr, size_t num)
{
     ba0:	55                   	push   %ebp
     ba1:	89 e5                	mov    %esp,%ebp
     ba3:	e8 fc ff ff ff       	call   ba4 <fsm_octets_print+0x4>
		}
	}
	fsm_printf("\n");
	fsm_printf("=====================================================\n");
	return num;
}
     ba8:	31 c0                	xor    %eax,%eax
     baa:	5d                   	pop    %ebp
     bab:	c3                   	ret    
     bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bb0 <fsm_htons>:

/* Endianness */
u16 fsm_htons(u16 val)
{
     bb0:	55                   	push   %ebp
     bb1:	89 e5                	mov    %esp,%ebp
     bb3:	e8 fc ff ff ff       	call   bb4 <fsm_htons+0x4>
	return HTONS(val);
}
     bb8:	5d                   	pop    %ebp
static inline __attribute_const__ __u16 __fswab16(__u16 val)
{
#ifdef __arch_swab16
	return __arch_swab16(val);
#else
	return ___constant_swab16(val);
     bb9:	66 c1 c0 08          	rol    $0x8,%ax
     bbd:	c3                   	ret    
     bbe:	66 90                	xchg   %ax,%ax

00000bc0 <fsm_htonl>:

u32 fsm_htonl(u32 val)
{
     bc0:	55                   	push   %ebp
     bc1:	89 e5                	mov    %esp,%ebp
     bc3:	e8 fc ff ff ff       	call   bc4 <fsm_htonl+0x4>

static inline __attribute_const__ __u32 __arch_swab32(__u32 val)
{
#ifdef __i386__
# ifdef CONFIG_X86_BSWAP
	asm("bswap %0" : "=r" (val) : "0" (val));
     bc8:	0f c8                	bswap  %eax
	return HTONL(val);
}
     bca:	5d                   	pop    %ebp
     bcb:	c3                   	ret    
     bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bd0 <fsm_ntohs>:

u16 fsm_ntohs(u16 val)
{
     bd0:	55                   	push   %ebp
     bd1:	89 e5                	mov    %esp,%ebp
     bd3:	e8 fc ff ff ff       	call   bd4 <fsm_ntohs+0x4>
	return NTOHS(val);
}
     bd8:	5d                   	pop    %ebp
     bd9:	66 c1 c0 08          	rol    $0x8,%ax
     bdd:	c3                   	ret    
     bde:	66 90                	xchg   %ax,%ax

00000be0 <fsm_ntohl>:

u32 fsm_ntohl(u32 val)
{
     be0:	55                   	push   %ebp
     be1:	89 e5                	mov    %esp,%ebp
     be3:	e8 fc ff ff ff       	call   be4 <fsm_ntohl+0x4>
     be8:	0f c8                	bswap  %eax
	return NTOHL(val);
}
     bea:	5d                   	pop    %ebp
     beb:	c3                   	ret    
     bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bf0 <fsm_schedule_self>:

/*  Event scheduling operation */
evHandle fsm_schedule_self(unsigned int delay, u32 code)
{
     bf0:	55                   	push   %ebp
     bf1:	89 e5                	mov    %esp,%ebp
     bf3:	53                   	push   %ebx
     bf4:	83 ec 0c             	sub    $0xc,%esp
     bf7:	e8 fc ff ff ff       	call   bf8 <fsm_schedule_self+0x8>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_SELF, code, NULL, fsm_core.current_fsm, fsm_core.current_fsm, NULL);
     bfc:	8b 1d 20 00 00 00    	mov    0x20,%ebx
     c02:	89 d1                	mov    %edx,%ecx
     c04:	ba 03 00 00 00       	mov    $0x3,%edx
     c09:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     c0d:	89 1c 24             	mov    %ebx,(%esp)
     c10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c17:	00 
     c18:	e8 23 fb ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c1d:	83 c4 0c             	add    $0xc,%esp
     c20:	5b                   	pop    %ebx
     c21:	5d                   	pop    %ebp
     c22:	c3                   	ret    
     c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000c30 <fsm_schedule_exfsm>:

evHandle fsm_schedule_exfsm(unsigned int delay, u32 code, int dst_id)
{
     c30:	55                   	push   %ebp
     c31:	89 e5                	mov    %esp,%ebp
     c33:	83 ec 0c             	sub    $0xc,%esp
     c36:	e8 fc ff ff ff       	call   c37 <fsm_schedule_exfsm+0x7>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_EXFSM, code, NULL, fsm_core.current_fsm, dst_id, NULL);
     c3b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     c3f:	8b 0d 20 00 00 00    	mov    0x20,%ecx
     c45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c4c:	00 
     c4d:	89 0c 24             	mov    %ecx,(%esp)
     c50:	89 d1                	mov    %edx,%ecx
     c52:	ba 04 00 00 00       	mov    $0x4,%edx
     c57:	e8 e4 fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c5c:	c9                   	leave  
     c5d:	c3                   	ret    
     c5e:	66 90                	xchg   %ax,%ax

00000c60 <fsm_post_msg>:

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
     c60:	55                   	push   %ebp
     c61:	89 e5                	mov    %esp,%ebp
     c63:	83 ec 20             	sub    $0x20,%esp
     c66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     c69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     c6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     c6f:	e8 fc ff ff ff       	call   c70 <fsm_post_msg+0x10>
     c74:	89 cf                	mov    %ecx,%edi
     c76:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c79:	89 d6                	mov    %edx,%esi
     c7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c7e:	89 c8                	mov    %ecx,%eax
     c80:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     c83:	e8 fc ff ff ff       	call   c84 <fsm_post_msg+0x24>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     c8b:	89 f2                	mov    %esi,%edx
}

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c8d:	89 c3                	mov    %eax,%ebx
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c8f:	e8 fc ff ff ff       	call   c90 <fsm_post_msg+0x30>
evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
	fsm_mem_cpy(buffer, msg_ptr, size);
	return	__fsm_tm_ev_add(0, FSM_EV_TYPE_MSG, code, NULL, fsm_core.current_fsm, dst_id, buffer);
     c94:	a1 20 00 00 00       	mov    0x20,%eax
     c99:	ba 06 00 00 00       	mov    $0x6,%edx
     c9e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     ca1:	89 04 24             	mov    %eax,(%esp)
     ca4:	31 c0                	xor    %eax,%eax
     ca6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     caa:	89 7c 24 04          	mov    %edi,0x4(%esp)
     cae:	e8 8d fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     cb3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     cb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
     cb9:	8b 7d fc             	mov    -0x4(%ebp),%edi
     cbc:	89 ec                	mov    %ebp,%esp
     cbe:	5d                   	pop    %ebp
     cbf:	c3                   	ret    

00000cc0 <fsm_schedule_cancel>:

int fsm_schedule_cancel(evHandle eh)
{
     cc0:	55                   	push   %ebp
     cc1:	89 e5                	mov    %esp,%ebp
     cc3:	56                   	push   %esi
     cc4:	53                   	push   %ebx
     cc5:	e8 fc ff ff ff       	call   cc6 <fsm_schedule_cancel+0x6>
     cca:	89 c3                	mov    %eax,%ebx
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
     ccc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
     cd1:	81 7b 04 d6 96 0f 04 	cmpl   $0x40f96d6,0x4(%ebx)
     cd8:	75 43                	jne    d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
     cda:	8b 35 88 02 00 00    	mov    0x288,%esi
     ce0:	85 f6                	test   %esi,%esi
     ce2:	74 39                	je     d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     ce4:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     ce9:	e8 fc ff ff ff       	call   cea <fsm_schedule_cancel+0x2a>
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cee:	8b 15 88 02 00 00    	mov    0x288,%edx
     cf4:	39 d3                	cmp    %edx,%ebx
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     cf6:	89 c6                	mov    %eax,%esi
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cf8:	75 0c                	jne    d06 <fsm_schedule_cancel+0x46>
     cfa:	eb 49                	jmp    d45 <fsm_schedule_cancel+0x85>
     cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
     d00:	39 c3                	cmp    %eax,%ebx
     d02:	74 24                	je     d28 <fsm_schedule_cancel+0x68>
     d04:	89 c2                	mov    %eax,%edx
     d06:	8b 02                	mov    (%edx),%eax
     d08:	85 c0                	test   %eax,%eax
     d0a:	75 f4                	jne    d00 <fsm_schedule_cancel+0x40>
     d0c:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d11:	89 f2                	mov    %esi,%edx
     d13:	e8 fc ff ff ff       	call   d14 <fsm_schedule_cancel+0x54>
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
     d18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d1d:	5b                   	pop    %ebx
     d1e:	5e                   	pop    %esi
     d1f:	5d                   	pop    %ebp
     d20:	c3                   	ret    
     d21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
		p0 = p0->pNext;
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
     d28:	8b 03                	mov    (%ebx),%eax
     d2a:	89 02                	mov    %eax,(%edx)
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d2c:	89 d8                	mov    %ebx,%eax
     d2e:	e8 fc ff ff ff       	call   d2f <fsm_schedule_cancel+0x6f>
     d33:	89 f2                	mov    %esi,%edx
     d35:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d3a:	e8 fc ff ff ff       	call   d3b <fsm_schedule_cancel+0x7b>
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
     d3f:	31 c0                	xor    %eax,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d41:	5b                   	pop    %ebx
     d42:	5e                   	pop    %esi
     d43:	5d                   	pop    %ebp
     d44:	c3                   	ret    
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d45:	8b 03                	mov    (%ebx),%eax
		if(pB->tm_state != FSM_TM_EXPIRE)
     d47:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d4e:	a3 88 02 00 00       	mov    %eax,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     d53:	74 05                	je     d5a <fsm_schedule_cancel+0x9a>
		{
			__fsm_tm_restart();
     d55:	e8 d6 f3 ff ff       	call   130 <__fsm_tm_restart>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d5a:	89 d8                	mov    %ebx,%eax
     d5c:	e8 fc ff ff ff       	call   d5d <fsm_schedule_cancel+0x9d>
		if(pB->tm_state != FSM_TM_EXPIRE)
		{
			__fsm_tm_restart();
		}
		fsm_mem_free(pE);
		if(!pB->evQ)
     d61:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     d67:	85 db                	test   %ebx,%ebx
     d69:	75 c8                	jne    d33 <fsm_schedule_cancel+0x73>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
     d6b:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
     d70:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     d77:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
     d7a:	e8 fc ff ff ff       	call   d7b <fsm_schedule_cancel+0xbb>
     d7f:	eb b2                	jmp    d33 <fsm_schedule_cancel+0x73>
     d81:	eb 0d                	jmp    d90 <fsm_do_ioctrl>
     d83:	90                   	nop
     d84:	90                   	nop
     d85:	90                   	nop
     d86:	90                   	nop
     d87:	90                   	nop
     d88:	90                   	nop
     d89:	90                   	nop
     d8a:	90                   	nop
     d8b:	90                   	nop
     d8c:	90                   	nop
     d8d:	90                   	nop
     d8e:	90                   	nop
     d8f:	90                   	nop

00000d90 <fsm_do_ioctrl>:
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     d90:	55                   	push   %ebp
     d91:	89 e5                	mov    %esp,%ebp
     d93:	83 ec 14             	sub    $0x14,%esp
     d96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     d99:	89 75 f8             	mov    %esi,-0x8(%ebp)
     d9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     d9f:	e8 fc ff ff ff       	call   da0 <fsm_do_ioctrl+0x10>
     da4:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     da7:	c1 e0 04             	shl    $0x4,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     daa:	89 d6                	mov    %edx,%esi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     dac:	8b 90 4c 00 00 00    	mov    0x4c(%eax),%edx
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     db2:	b8 18 00 00 00       	mov    $0x18,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     db7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dba:	89 55 ec             	mov    %edx,-0x14(%ebp)
     dbd:	e8 fc ff ff ff       	call   dbe <fsm_do_ioctrl+0x2e>
	ev_ptr->dev =dev;
     dc2:	8b 55 ec             	mov    -0x14(%ebp),%edx
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     dc5:	85 ff                	test   %edi,%edi
int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dc7:	89 c3                	mov    %eax,%ebx
	ev_ptr->dev =dev;
     dc9:	89 10                	mov    %edx,(%eax)
	ev_ptr->ifr.cmd = cmd;
     dcb:	89 70 04             	mov    %esi,0x4(%eax)
	ev_ptr->ifr.size = size;
     dce:	89 78 08             	mov    %edi,0x8(%eax)
	if(data_ptr != NULL && size > 0)
     dd1:	75 65                	jne    e38 <fsm_do_ioctrl+0xa8>
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
		fsm_mem_cpy(ev_ptr->ifr.buffer, data_ptr, size);
		}
	else
		{
		ev_ptr->ifr.buffer = NULL;
     dd3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     dda:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     ddf:	e8 fc ff ff ff       	call   de0 <fsm_do_ioctrl+0x50>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     de4:	a1 d8 02 00 00       	mov    0x2d8,%eax
		}
	spin_lock(&fsm_core.ioctl_list_lock);
	list_add_tail(&ev_ptr->list_node, &fsm_core.do_ioctl_list);
     de9:	8d 53 10             	lea    0x10(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     dec:	89 15 d8 02 00 00    	mov    %edx,0x2d8
	new->next = next;
     df2:	c7 43 10 d4 02 00 00 	movl   $0x2d4,0x10(%ebx)
	new->prev = prev;
     df9:	89 43 14             	mov    %eax,0x14(%ebx)
	prev->next = new;
     dfc:	89 10                	mov    %edx,(%eax)
	return PVOP_CALL1(int, pv_lock_ops.spin_trylock, lock);
}

static __always_inline void arch_spin_unlock(struct arch_spinlock *lock)
{
	PVOP_VCALL1(pv_lock_ops.spin_unlock, lock);
     dfe:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     e03:	ff 15 14 00 00 00    	call   *0x14
	spin_unlock(&fsm_core.ioctl_list_lock);
	tasklet_schedule(fsm_core.do_ioctl_tsklt);
     e09:	a1 c8 02 00 00       	mov    0x2c8,%eax
     e0e:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     e14:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     e16:	85 d2                	test   %edx,%edx
     e18:	75 05                	jne    e1f <fsm_do_ioctrl+0x8f>
		__tasklet_schedule(t);
     e1a:	e8 fc ff ff ff       	call   e1b <fsm_do_ioctrl+0x8b>
	return 1;
}
     e1f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e22:	b8 01 00 00 00       	mov    $0x1,%eax
     e27:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e2a:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e2d:	89 ec                	mov    %ebp,%esp
     e2f:	5d                   	pop    %ebp
     e30:	c3                   	ret    
     e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e3b:	85 c0                	test   %eax,%eax
     e3d:	74 94                	je     dd3 <fsm_do_ioctrl+0x43>
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e3f:	89 f8                	mov    %edi,%eax
     e41:	e8 fc ff ff ff       	call   e42 <fsm_do_ioctrl+0xb2>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
     e49:	89 f9                	mov    %edi,%ecx
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e4b:	89 43 0c             	mov    %eax,0xc(%ebx)
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e4e:	e8 fc ff ff ff       	call   e4f <fsm_do_ioctrl+0xbf>
     e53:	eb 85                	jmp    dda <fsm_do_ioctrl+0x4a>
     e55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000e60 <fsm_ioctrl_arrival>:
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e60:	55                   	push   %ebp
     e61:	89 e5                	mov    %esp,%ebp
     e63:	83 ec 28             	sub    $0x28,%esp
     e66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     e69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     e6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     e6f:	e8 fc ff ff ff       	call   e70 <fsm_ioctrl_arrival+0x10>
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e74:	81 fa f0 89 00 00    	cmp    $0x89f0,%edx
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e7a:	89 c3                	mov    %eax,%ebx
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e7c:	0f 84 b6 00 00 00    	je     f38 <fsm_ioctrl_arrival+0xd8>
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		}	
	else if(cmd == IOCUSER)	
     e82:	81 fa f1 89 00 00    	cmp    $0x89f1,%edx
     e88:	74 16                	je     ea0 <fsm_ioctrl_arrival+0x40>
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
		}
	
	return 1;
}
     e8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e8d:	b8 01 00 00 00       	mov    $0x1,%eax
     e92:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e95:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e98:	89 ec                	mov    %ebp,%esp
     e9a:	5d                   	pop    %ebp
     e9b:	c3                   	ret    
     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					  unsigned long n)
{
	int sz = __compiletime_object_size(to);

	if (likely(sz == -1 || sz >= n))
		n = _copy_from_user(to, from, n);
     ea0:	8b 50 10             	mov    0x10(%eax),%edx
     ea3:	b9 0c 00 00 00       	mov    $0xc,%ecx
     ea8:	8d 45 e8             	lea    -0x18(%ebp),%eax
     eab:	e8 fc ff ff ff       	call   eac <fsm_ioctrl_arrival+0x4c>
	else if(cmd == IOCUSER)	
		{		
		uifr_ptr = ifr;		
		copy_from_user(&kifr, uifr_ptr->ifr_ifru.ifru_data, sizeof(struct kifreq)); 	
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
     eb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     eb3:	85 c0                	test   %eax,%eax
     eb5:	0f 84 cd 00 00 00    	je     f88 <fsm_ioctrl_arrival+0x128>
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
     ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
     ebe:	e8 fc ff ff ff       	call   ebf <fsm_ioctrl_arrival+0x5f>
     ec3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     ec6:	8b 55 f0             	mov    -0x10(%ebp),%edx
     ec9:	89 c6                	mov    %eax,%esi
     ecb:	e8 fc ff ff ff       	call   ecc <fsm_ioctrl_arrival+0x6c>
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ed0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     ed5:	e8 fc ff ff ff       	call   ed6 <fsm_ioctrl_arrival+0x76>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     eda:	31 c9                	xor    %ecx,%ecx
     edc:	ba 02 00 00 00       	mov    $0x2,%edx
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ee1:	89 c7                	mov    %eax,%edi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     ee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
     ee6:	89 74 24 08          	mov    %esi,0x8(%esp)
     eea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     ef1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ef5:	a1 8c 02 00 00       	mov    0x28c,%eax
     efa:	89 44 24 04          	mov    %eax,0x4(%esp)
     efe:	b8 05 00 00 00       	mov    $0x5,%eax
     f03:	e8 28 f5 ff ff       	call   430 <__fsm_core_self_drive>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     f08:	89 fa                	mov    %edi,%edx
     f0a:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f0f:	e8 fc ff ff ff       	call   f10 <fsm_ioctrl_arrival+0xb0>
			spin_unlock_irqrestore(&fsm_core.lock, flags2);
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
     f14:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     f17:	89 f2                	mov    %esi,%edx
     f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f1c:	e8 fc ff ff ff       	call   f1d <fsm_ioctrl_arrival+0xbd>
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
			spin_unlock_irqrestore(&fsm_core.lock, flags2);		
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
     f21:	8b 43 10             	mov    0x10(%ebx),%eax
     f24:	b9 0c 00 00 00       	mov    $0xc,%ecx
     f29:	8d 55 e8             	lea    -0x18(%ebp),%edx
     f2c:	e8 fc ff ff ff       	call   f2d <fsm_ioctrl_arrival+0xcd>
     f31:	e9 54 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f36:	66 90                	xchg   %ax,%ax
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f38:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f3d:	e8 fc ff ff ff       	call   f3e <fsm_ioctrl_arrival+0xde>
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f42:	31 c9                	xor    %ecx,%ecx
     f44:	ba 02 00 00 00       	mov    $0x2,%edx
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f49:	89 c6                	mov    %eax,%esi
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f4b:	8b 03                	mov    (%ebx),%eax
     f4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     f54:	89 44 24 0c          	mov    %eax,0xc(%esp)
     f58:	8b 43 08             	mov    0x8(%ebx),%eax
     f5b:	89 44 24 08          	mov    %eax,0x8(%esp)
     f5f:	a1 8c 02 00 00       	mov    0x28c,%eax
     f64:	89 44 24 04          	mov    %eax,0x4(%esp)
     f68:	b8 05 00 00 00       	mov    $0x5,%eax
     f6d:	e8 be f4 ff ff       	call   430 <__fsm_core_self_drive>
     f72:	89 f2                	mov    %esi,%edx
     f74:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f79:	e8 fc ff ff ff       	call   f7a <fsm_ioctrl_arrival+0x11a>
     f7e:	e9 07 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f83:	90                   	nop
     f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f88:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f8d:	e8 fc ff ff ff       	call   f8e <fsm_ioctrl_arrival+0x12e>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f92:	31 c9                	xor    %ecx,%ecx
     f94:	ba 02 00 00 00       	mov    $0x2,%edx
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f99:	89 c6                	mov    %eax,%esi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     f9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     fa5:	00 
     fa6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     fad:	89 44 24 0c          	mov    %eax,0xc(%esp)
     fb1:	a1 8c 02 00 00       	mov    0x28c,%eax
     fb6:	89 44 24 04          	mov    %eax,0x4(%esp)
     fba:	b8 05 00 00 00       	mov    $0x5,%eax
     fbf:	e8 6c f4 ff ff       	call   430 <__fsm_core_self_drive>
     fc4:	89 f2                	mov    %esi,%edx
     fc6:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     fcb:	e8 fc ff ff ff       	call   fcc <fsm_ioctrl_arrival+0x16c>
     fd0:	e9 4c ff ff ff       	jmp    f21 <fsm_ioctrl_arrival+0xc1>
     fd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000fe0 <fsm_get_curtime>:



/* Time get */
u32 fsm_get_curtime()
{
     fe0:	55                   	push   %ebp
     fe1:	89 e5                	mov    %esp,%ebp
     fe3:	e8 fc ff ff ff       	call   fe4 <fsm_get_curtime+0x4>
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
     fe8:	e8 fc ff ff ff       	call   fe9 <fsm_get_curtime+0x9>
	cur_time = ktime_to_timeval(ktime);
     fed:	e8 fc ff ff ff       	call   fee <fsm_get_curtime+0xe>
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
	ctm = ctm/10;
     ff2:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
	return ctm;
}
     ff7:	5d                   	pop    %ebp
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
	cur_time = ktime_to_timeval(ktime);
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
     ff8:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
     ffe:	01 c2                	add    %eax,%edx
	ctm = ctm/10;
    1000:	89 d0                	mov    %edx,%eax
    1002:	f7 e1                	mul    %ecx
    1004:	c1 ea 03             	shr    $0x3,%edx
	return ctm;
}
    1007:	89 d0                	mov    %edx,%eax
    1009:	c3                   	ret    
    100a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00001010 <fsm_get_random_bytes>:


/* Random bytes get*/
void fsm_get_random_bytes(void *buf, int nbytes)
{
    1010:	55                   	push   %ebp
    1011:	89 e5                	mov    %esp,%ebp
    1013:	e8 fc ff ff ff       	call   1014 <fsm_get_random_bytes+0x4>
	GET_RANDOM_BYTES(buf, nbytes);
    1018:	e8 fc ff ff ff       	call   1019 <fsm_get_random_bytes+0x9>
}
    101d:	5d                   	pop    %ebp
    101e:	c3                   	ret    
    101f:	90                   	nop

00001020 <fsm_core_create>:


/* FSM core operations */

void fsm_core_create(void* dev)
{
    1020:	55                   	push   %ebp
    1021:	89 e5                	mov    %esp,%ebp
    1023:	e8 fc ff ff ff       	call   1024 <fsm_core_create+0x4>
	int i;
	fsm_core.current_fsm = -1;
    1028:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
    102f:	ff ff ff 
	fsm_core.current_state_ptr = NULL;
    1032:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
    1039:	00 00 00 
	fsm_core.state = CORE_CLOSED;
    103c:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    1043:	00 00 00 
	fsm_core.pkptr = 0;
    1046:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
    104d:	00 00 00 
	fsm_core.evtype = 0;
    1050:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
    1057:	00 00 00 
	fsm_core.code = 0;
	fsm_core.src = 0;
	fsm_core.dev = dev;
    105a:	a3 a8 02 00 00       	mov    %eax,0x2a8
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
    105f:	b8 44 00 00 00       	mov    $0x44,%eax
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
	fsm_core.state = CORE_CLOSED;
	fsm_core.pkptr = 0;
	fsm_core.evtype = 0;
	fsm_core.code = 0;
    1064:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
    106b:	00 00 00 
	fsm_core.src = 0;
    106e:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
    1075:	00 00 00 
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
    1078:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
    107f:	00 00 00 
	fsm_core.fsm_drive = NULL;
    1082:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
    1089:	00 00 00 
	MAIN_PORT = -1;
    108c:	c7 05 8c 02 00 00 ff 	movl   $0xffffffff,0x28c
    1093:	ff ff ff 
    1096:	66 90                	xchg   %ax,%ax
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    1098:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    109e:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    10a4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    10ab:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    10b2:	83 c0 10             	add    $0x10,%eax
	fsm_core.src = 0;
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
	for(i = 0; i < MAX_INTF; i++)
    10b5:	3d 44 02 00 00       	cmp    $0x244,%eax
    10ba:	75 dc                	jne    1098 <fsm_core_create+0x78>
		FSM[i] = NULL;
	}
	fsm_core.buffer = NULL;
	fsm_core.ioctrl_cmd = 0;
	spin_lock_init(&fsm_core.lock);
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    10bc:	b8 10 00 00 00       	mov    $0x10,%eax
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	for(i = 0; i < MAX_FSM; ++i)
	{
		FSM[i] = NULL;
    10c1:	c7 05 90 02 00 00 00 	movl   $0x0,0x290
    10c8:	00 00 00 
    10cb:	c7 05 94 02 00 00 00 	movl   $0x0,0x294
    10d2:	00 00 00 
    10d5:	c7 05 98 02 00 00 00 	movl   $0x0,0x298
    10dc:	00 00 00 
    10df:	c7 05 9c 02 00 00 00 	movl   $0x0,0x29c
    10e6:	00 00 00 
    10e9:	c7 05 a0 02 00 00 00 	movl   $0x0,0x2a0
    10f0:	00 00 00 
    10f3:	c7 05 a4 02 00 00 00 	movl   $0x0,0x2a4
    10fa:	00 00 00 
	}
	fsm_core.buffer = NULL;
    10fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
    1104:	00 00 00 
	fsm_core.ioctrl_cmd = 0;
    1107:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
    110e:	00 00 00 
	spin_lock_init(&fsm_core.lock);
    1111:	66 c7 05 b4 02 00 00 	movw   $0x0,0x2b4
    1118:	00 00 
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    111a:	e8 fc ff ff ff       	call   111b <fsm_core_create+0xfb>
    111f:	a3 b8 02 00 00       	mov    %eax,0x2b8
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    1124:	b8 10 00 00 00       	mov    $0x10,%eax
    1129:	e8 fc ff ff ff       	call   112a <fsm_core_create+0x10a>
    112e:	a3 bc 02 00 00       	mov    %eax,0x2bc
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1133:	b8 14 00 00 00       	mov    $0x14,%eax
    1138:	e8 fc ff ff ff       	call   1139 <fsm_core_create+0x119>
    113d:	a3 c0 02 00 00       	mov    %eax,0x2c0
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1142:	b8 14 00 00 00       	mov    $0x14,%eax
    1147:	e8 fc ff ff ff       	call   1148 <fsm_core_create+0x128>
    114c:	a3 c4 02 00 00       	mov    %eax,0x2c4
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1151:	b8 14 00 00 00       	mov    $0x14,%eax
    1156:	e8 fc ff ff ff       	call   1157 <fsm_core_create+0x137>
    115b:	a3 c8 02 00 00       	mov    %eax,0x2c8
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1160:	b8 14 00 00 00       	mov    $0x14,%eax
    1165:	e8 fc ff ff ff       	call   1166 <fsm_core_create+0x146>
	return; 
}
    116a:	5d                   	pop    %ebp
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    116b:	a3 cc 02 00 00       	mov    %eax,0x2cc
	return; 
}
    1170:	c3                   	ret    
    1171:	eb 0d                	jmp    1180 <fsm_core_intf_set>
    1173:	90                   	nop
    1174:	90                   	nop
    1175:	90                   	nop
    1176:	90                   	nop
    1177:	90                   	nop
    1178:	90                   	nop
    1179:	90                   	nop
    117a:	90                   	nop
    117b:	90                   	nop
    117c:	90                   	nop
    117d:	90                   	nop
    117e:	90                   	nop
    117f:	90                   	nop

00001180 <fsm_core_intf_set>:
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    1180:	55                   	push   %ebp
    1181:	89 e5                	mov    %esp,%ebp
    1183:	83 ec 10             	sub    $0x10,%esp
    1186:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1189:	89 75 f8             	mov    %esi,-0x8(%ebp)
    118c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    118f:	e8 fc ff ff ff       	call   1190 <fsm_core_intf_set+0x10>
    1194:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV *dev = NULL;
	switch(type)
    1197:	83 fa 01             	cmp    $0x1,%edx
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    119a:	89 c3                	mov    %eax,%ebx
    119c:	89 ce                	mov    %ecx,%esi
	NETDEV *dev = NULL;
	switch(type)
    119e:	0f 84 bc 00 00 00    	je     1260 <fsm_core_intf_set+0xe0>
    11a4:	72 3a                	jb     11e0 <fsm_core_intf_set+0x60>
    11a6:	83 fa 02             	cmp    $0x2,%edx
    11a9:	74 55                	je     1200 <fsm_core_intf_set+0x80>
		INTF[index].proto = htons(proto);
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_xmit;
		break;
	}
	if(proto == 0 && dev_name == 0)
    11ab:	85 ff                	test   %edi,%edi
    11ad:	8d 76 00             	lea    0x0(%esi),%esi
    11b0:	75 1c                	jne    11ce <fsm_core_intf_set+0x4e>
    11b2:	66 85 f6             	test   %si,%si
    11b5:	75 17                	jne    11ce <fsm_core_intf_set+0x4e>
		{
		INTF[index].valid = DEV_INTF_NULL;
    11b7:	c1 e3 04             	shl    $0x4,%ebx
    11ba:	c7 83 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
    11c1:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11c4:	c7 83 50 00 00 00 20 	movl   $0x120,0x50(%ebx)
    11cb:	01 00 00 
		}
	return;
}
    11ce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    11d1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    11d4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    11d7:	89 ec                	mov    %ebp,%esp
    11d9:	5d                   	pop    %ebp
    11da:	c3                   	ret    
    11db:	90                   	nop
    11dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	NETDEV *dev = NULL;
	switch(type)
	{
	case DEV_INTF_NULL:
		INTF[index].valid = DEV_INTF_NULL;
    11e0:	c1 e0 04             	shl    $0x4,%eax
    11e3:	c7 80 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    11ea:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11ed:	c7 80 50 00 00 00 20 	movl   $0x120,0x50(%eax)
    11f4:	01 00 00 
		break;
    11f7:	eb b2                	jmp    11ab <fsm_core_intf_set+0x2b>
    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	case DEV_INTF_IND:
		if(dev_name)
    1200:	85 ff                	test   %edi,%edi
    1202:	0f 84 b8 00 00 00    	je     12c0 <fsm_core_intf_set+0x140>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1208:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].valid = DEV_INTF_NULL;
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    120d:	89 fa                	mov    %edi,%edx
    120f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1215:	e8 fc ff ff ff       	call   1216 <fsm_core_intf_set+0x96>
		INTF[index].valid = DEV_INTF_IND;
    121a:	8d 53 02             	lea    0x2(%ebx),%edx
    121d:	89 d1                	mov    %edx,%ecx
    121f:	c1 e1 04             	shl    $0x4,%ecx
    1222:	c7 81 24 00 00 00 02 	movl   $0x2,0x24(%ecx)
    1229:	00 00 00 
		INTF[index].proto = htons(proto);
    122c:	0f b7 ce             	movzwl %si,%ecx
    122f:	c1 e1 08             	shl    $0x8,%ecx
    1232:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1235:	89 f1                	mov    %esi,%ecx
    1237:	66 c1 e9 08          	shr    $0x8,%cx
    123b:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    123f:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    1242:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    1248:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_netrx;
    124f:	c7 82 30 00 00 00 30 	movl   $0x230,0x30(%edx)
    1256:	02 00 00 
		break;
    1259:	e9 4d ff ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    125e:	66 90                	xchg   %ax,%ax
	case DEV_INTF_REQ:
		if(dev_name)
    1260:	85 ff                	test   %edi,%edi
    1262:	74 7c                	je     12e0 <fsm_core_intf_set+0x160>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1264:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    1269:	89 fa                	mov    %edi,%edx
    126b:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1271:	e8 fc ff ff ff       	call   1272 <fsm_core_intf_set+0xf2>
		INTF[index].valid = DEV_INTF_REQ;
    1276:	8d 53 02             	lea    0x2(%ebx),%edx
    1279:	89 d1                	mov    %edx,%ecx
    127b:	c1 e1 04             	shl    $0x4,%ecx
    127e:	c7 81 24 00 00 00 01 	movl   $0x1,0x24(%ecx)
    1285:	00 00 00 
		INTF[index].proto = htons(proto);
    1288:	0f b7 ce             	movzwl %si,%ecx
    128b:	c1 e1 08             	shl    $0x8,%ecx
    128e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1291:	89 f1                	mov    %esi,%ecx
    1293:	66 c1 e9 08          	shr    $0x8,%cx
    1297:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    129b:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    129e:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    12a4:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_xmit;
    12ab:	c7 82 30 00 00 00 d0 	movl   $0x1d0,0x30(%edx)
    12b2:	01 00 00 
		break;
    12b5:	e9 f1 fe ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    12ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12c3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c6:	89 d0                	mov    %edx,%eax
    12c8:	c1 e0 04             	shl    $0x4,%eax
    12cb:	c7 80 24 00 00 00 02 	movl   $0x2,0x24(%eax)
    12d2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12d5:	31 c0                	xor    %eax,%eax
    12d7:	e9 53 ff ff ff       	jmp    122f <fsm_core_intf_set+0xaf>
    12dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12e3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e6:	89 d0                	mov    %edx,%eax
    12e8:	c1 e0 04             	shl    $0x4,%eax
    12eb:	c7 80 24 00 00 00 01 	movl   $0x1,0x24(%eax)
    12f2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12f5:	31 c0                	xor    %eax,%eax
    12f7:	eb 92                	jmp    128b <fsm_core_intf_set+0x10b>
    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001300 <fsm_core_open>:
	return;
}


int fsm_core_open()
{
    1300:	55                   	push   %ebp
    1301:	89 e5                	mov    %esp,%ebp
    1303:	53                   	push   %ebx
    1304:	83 ec 10             	sub    $0x10,%esp
    1307:	e8 fc ff ff ff       	call   1308 <fsm_core_open+0x8>
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
    130c:	a1 28 00 00 00       	mov    0x28,%eax
    1311:	85 c0                	test   %eax,%eax
    1313:	0f 85 54 01 00 00    	jne    146d <fsm_core_open+0x16d>
	{
	fsm_printf("core is opening.\n");
    1319:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    1320:	e8 fc ff ff ff       	call   1321 <fsm_core_open+0x21>
	spin_lock_irqsave(&fsm_core.lock, flags);
    1325:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    132a:	e8 fc ff ff ff       	call   132b <fsm_core_open+0x2b>
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    132f:	31 c9                	xor    %ecx,%ecx
    1331:	ba 50 00 00 00       	mov    $0x50,%edx
{
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
	{
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
    1336:	89 c3                	mov    %eax,%ebx
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
    1338:	a1 b8 02 00 00       	mov    0x2b8,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    133d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    1343:	89 00                	mov    %eax,(%eax)
    1345:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    1348:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	skb_queue_head_init(fsm_core.rx_queue);
    134f:	a1 bc 02 00 00       	mov    0x2bc,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    1354:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    135a:	89 00                	mov    %eax,(%eax)
    135c:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    135f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    1366:	a1 c0 02 00 00       	mov    0x2c0,%eax
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
    136b:	66 c7 05 d0 02 00 00 	movw   $0x0,0x2d0
    1372:	00 00 
	spin_lock_init(&fsm_core.rx_queue_lock);
    1374:	66 c7 05 d2 02 00 00 	movw   $0x0,0x2d2
    137b:	00 00 
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    137d:	e8 fc ff ff ff       	call   137e <fsm_core_open+0x7e>
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
    1382:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1387:	31 c9                	xor    %ecx,%ecx
    1389:	ba 00 00 00 00       	mov    $0x0,%edx
    138e:	e8 fc ff ff ff       	call   138f <fsm_core_open+0x8f>
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    1393:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1398:	31 c9                	xor    %ecx,%ecx
    139a:	ba a0 00 00 00       	mov    $0xa0,%edx
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
    139f:	66 c7 05 e4 02 00 00 	movw   $0x0,0x2e4
    13a6:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13a8:	c7 05 d4 02 00 00 d4 	movl   $0x2d4,0x2d4
    13af:	02 00 00 
	list->prev = list;
    13b2:	c7 05 d8 02 00 00 d4 	movl   $0x2d4,0x2d8
    13b9:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    13bc:	e8 fc ff ff ff       	call   13bd <fsm_core_open+0xbd>
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13c1:	a1 cc 02 00 00       	mov    0x2cc,%eax
    13c6:	31 c9                	xor    %ecx,%ecx
    13c8:	ba 10 09 00 00       	mov    $0x910,%edx
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
    13cd:	66 c7 05 e6 02 00 00 	movw   $0x0,0x2e6
    13d4:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13d6:	c7 05 dc 02 00 00 dc 	movl   $0x2dc,0x2dc
    13dd:	02 00 00 
	list->prev = list;
    13e0:	c7 05 e0 02 00 00 dc 	movl   $0x2dc,0x2e0
    13e7:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13ea:	e8 fc ff ff ff       	call   13eb <fsm_core_open+0xeb>
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	pB->evQ = 0;
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    13ef:	31 c9                	xor    %ecx,%ecx
    13f1:	ba 01 00 00 00       	mov    $0x1,%edx
    13f6:	b8 48 02 00 00       	mov    $0x248,%eax
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
    13fb:	66 c7 05 e8 02 00 00 	movw   $0x0,0x2e8
    1402:	00 00 

static void __fsm_tm_init()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    1404:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    140b:	00 00 00 
	pB->evQ = 0;
    140e:	c7 05 88 02 00 00 00 	movl   $0x0,0x288
    1415:	00 00 00 
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    1418:	e8 fc ff ff ff       	call   1419 <fsm_core_open+0x119>
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    141d:	a1 8c 02 00 00       	mov    0x28c,%eax
    1422:	31 c9                	xor    %ecx,%ecx
    1424:	31 d2                	xor    %edx,%edx
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
    1426:	c7 05 28 00 00 00 01 	movl   $0x1,0x28
    142d:	00 00 00 
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1430:	89 44 24 04          	mov    %eax,0x4(%esp)
    1434:	b8 05 00 00 00       	mov    $0x5,%eax
    1439:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1440:	00 
    1441:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1448:	00 
    1449:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1450:	e8 db ef ff ff       	call   430 <__fsm_core_self_drive>
    1455:	89 da                	mov    %ebx,%edx
    1457:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    145c:	e8 fc ff ff ff       	call   145d <fsm_core_open+0x15d>
	spin_unlock_irqrestore(&fsm_core.lock, flags);
	fsm_printf("core has opened.\n");
    1461:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
    1468:	e8 fc ff ff ff       	call   1469 <fsm_core_open+0x169>
	}
	return FSM_EXEC_SUCC;
}
    146d:	83 c4 10             	add    $0x10,%esp
    1470:	31 c0                	xor    %eax,%eax
    1472:	5b                   	pop    %ebx
    1473:	5d                   	pop    %ebp
    1474:	c3                   	ret    
    1475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001480 <fsm_core_close>:

int fsm_core_close()
{
    1480:	55                   	push   %ebp
    1481:	89 e5                	mov    %esp,%ebp
    1483:	57                   	push   %edi
    1484:	56                   	push   %esi
    1485:	53                   	push   %ebx
    1486:	83 ec 10             	sub    $0x10,%esp
    1489:	e8 fc ff ff ff       	call   148a <fsm_core_close+0xa>
	struct evioctl *ev_ptr, *tmp_ptr;
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
    148e:	a1 28 00 00 00       	mov    0x28,%eax
    1493:	85 c0                	test   %eax,%eax
    1495:	75 11                	jne    14a8 <fsm_core_close+0x28>
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    1497:	83 c4 10             	add    $0x10,%esp
    149a:	31 c0                	xor    %eax,%eax
    149c:	5b                   	pop    %ebx
    149d:	5e                   	pop    %esi
    149e:	5f                   	pop    %edi
    149f:	5d                   	pop    %ebp
    14a0:	c3                   	ret    
    14a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
		return FSM_EXEC_SUCC;
	spin_lock_irqsave(&fsm_core.lock, flags2);
    14a8:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    14ad:	e8 fc ff ff ff       	call   14ae <fsm_core_close+0x2e>
    14b2:	89 c7                	mov    %eax,%edi
	fsm_printf("core is closing.\n");
    14b4:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
    14bb:	e8 fc ff ff ff       	call   14bc <fsm_core_close+0x3c>
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    14c0:	a1 8c 02 00 00       	mov    0x28c,%eax
    14c5:	31 c9                	xor    %ecx,%ecx
    14c7:	ba 01 00 00 00       	mov    $0x1,%edx
    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    14d0:	b8 05 00 00 00       	mov    $0x5,%eax
    14d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    14dc:	00 
    14dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    14e4:	00 
    14e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    14ec:	e8 3f ef ff ff       	call   430 <__fsm_core_self_drive>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
    14f1:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    14f6:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    14fd:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
    1500:	e8 fc ff ff ff       	call   1501 <fsm_core_close+0x81>
{
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
    1505:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    150a:	e8 fc ff ff ff       	call   150b <fsm_core_close+0x8b>
    150f:	89 c3                	mov    %eax,%ebx
	while(pB->evQ)
    1511:	a1 88 02 00 00       	mov    0x288,%eax
    1516:	85 c0                	test   %eax,%eax
    1518:	74 1c                	je     1536 <fsm_core_close+0xb6>
    151a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		pE = pB->evQ;
		pB->evQ = pE->pNext;
    1520:	8b 10                	mov    (%eax),%edx
    1522:	89 15 88 02 00 00    	mov    %edx,0x288
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1528:	e8 fc ff ff ff       	call   1529 <fsm_core_close+0xa9>
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	while(pB->evQ)
    152d:	a1 88 02 00 00       	mov    0x288,%eax
    1532:	85 c0                	test   %eax,%eax
    1534:	75 ea                	jne    1520 <fsm_core_close+0xa0>
    1536:	89 da                	mov    %ebx,%edx
    1538:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    153d:	e8 fc ff ff ff       	call   153e <fsm_core_close+0xbe>
	fsm_printf("core is closing.\n");
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
	__fsm_tm_stop();
	__fsm_tm_flush();
	//Cancel tasklets
	tasklet_kill(fsm_core.tx_tsklt);
    1542:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1547:	e8 fc ff ff ff       	call   1548 <fsm_core_close+0xc8>
	tasklet_kill(fsm_core.rx_tsklt);
    154c:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1551:	e8 fc ff ff ff       	call   1552 <fsm_core_close+0xd2>
	tasklet_kill(fsm_core.do_ioctl_tsklt);
    1556:	a1 c8 02 00 00       	mov    0x2c8,%eax
    155b:	e8 fc ff ff ff       	call   155c <fsm_core_close+0xdc>
	tasklet_kill(fsm_core.exp_ev_tsklt);	
    1560:	a1 cc 02 00 00       	mov    0x2cc,%eax
    1565:	e8 fc ff ff ff       	call   1566 <fsm_core_close+0xe6>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    156a:	a1 b8 02 00 00       	mov    0x2b8,%eax
    156f:	3b 00                	cmp    (%eax),%eax
    1571:	74 2f                	je     15a2 <fsm_core_close+0x122>
    1573:	90                   	nop
    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
    1578:	e8 fc ff ff ff       	call   1579 <fsm_core_close+0xf9>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    157d:	e8 fc ff ff ff       	call   157e <fsm_core_close+0xfe>
	tasklet_kill(fsm_core.tx_tsklt);
	tasklet_kill(fsm_core.rx_tsklt);
	tasklet_kill(fsm_core.do_ioctl_tsklt);
	tasklet_kill(fsm_core.exp_ev_tsklt);	
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    1582:	a1 b8 02 00 00       	mov    0x2b8,%eax
    1587:	3b 00                	cmp    (%eax),%eax
    1589:	75 ed                	jne    1578 <fsm_core_close+0xf8>
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    158b:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1590:	3b 00                	cmp    (%eax),%eax
    1592:	74 17                	je     15ab <fsm_core_close+0x12b>
    1594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
    1598:	e8 fc ff ff ff       	call   1599 <fsm_core_close+0x119>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    159d:	e8 fc ff ff ff       	call   159e <fsm_core_close+0x11e>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    15a2:	a1 bc 02 00 00       	mov    0x2bc,%eax
    15a7:	3b 00                	cmp    (%eax),%eax
    15a9:	75 ed                	jne    1598 <fsm_core_close+0x118>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    15ab:	8b 1d d4 02 00 00    	mov    0x2d4,%ebx
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
	}
	if(!list_empty(&fsm_core.do_ioctl_list))
    15b1:	81 fb d4 02 00 00    	cmp    $0x2d4,%ebx
    15b7:	74 6b                	je     1624 <fsm_core_close+0x1a4>
	{
		list_for_each_entry_safe(ev_ptr, tmp_ptr, &fsm_core.do_ioctl_list, list_node)
    15b9:	8b 33                	mov    (%ebx),%esi
    15bb:	83 eb 10             	sub    $0x10,%ebx
    15be:	83 ee 10             	sub    $0x10,%esi
    15c1:	eb 17                	jmp    15da <fsm_core_close+0x15a>
    15c3:	90                   	nop
    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    15c8:	8b 46 10             	mov    0x10(%esi),%eax
    15cb:	83 e8 10             	sub    $0x10,%eax
    15ce:	81 fe c4 02 00 00    	cmp    $0x2c4,%esi
    15d4:	74 4e                	je     1624 <fsm_core_close+0x1a4>
    15d6:	89 f3                	mov    %esi,%ebx
    15d8:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
    15da:	b8 e4 02 00 00       	mov    $0x2e4,%eax
    15df:	e8 fc ff ff ff       	call   15e0 <fsm_core_close+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    15e4:	8b 4b 14             	mov    0x14(%ebx),%ecx
    15e7:	89 c2                	mov    %eax,%edx
    15e9:	8b 43 10             	mov    0x10(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    15ec:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    15ef:	89 01                	mov    %eax,(%ecx)
    15f1:	b8 e4 02 00 00       	mov    $0x2e4,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    15f6:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    15fd:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    1604:	e8 fc ff ff ff       	call   1605 <fsm_core_close+0x185>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1609:	8b 43 0c             	mov    0xc(%ebx),%eax
    160c:	e8 fc ff ff ff       	call   160d <fsm_core_close+0x18d>
    1611:	89 d8                	mov    %ebx,%eax
    1613:	e8 fc ff ff ff       	call   1614 <fsm_core_close+0x194>
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
			list_del(&ev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
			fsm_mem_free(ev_ptr->ifr.buffer);
			fsm_mem_free(ev_ptr);
			if(list_empty(&fsm_core.do_ioctl_list))
    1618:	81 3d d4 02 00 00 d4 	cmpl   $0x2d4,0x2d4
    161f:	02 00 00 
    1622:	75 a4                	jne    15c8 <fsm_core_close+0x148>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1624:	8b 1d dc 02 00 00    	mov    0x2dc,%ebx
				break;
		}
	}
	if(!list_empty(&fsm_core.exp_ev_list))
    162a:	81 fb dc 02 00 00    	cmp    $0x2dc,%ebx
    1630:	74 69                	je     169b <fsm_core_close+0x21b>
	{
		list_for_each_entry_safe(tmev_ptr, tmev_tmp_ptr, &fsm_core.exp_ev_list, list_node)
    1632:	8b 33                	mov    (%ebx),%esi
    1634:	83 eb 04             	sub    $0x4,%ebx
    1637:	83 ee 04             	sub    $0x4,%esi
    163a:	eb 16                	jmp    1652 <fsm_core_close+0x1d2>
    163c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1640:	8b 46 04             	mov    0x4(%esi),%eax
    1643:	83 e8 04             	sub    $0x4,%eax
    1646:	81 fe d8 02 00 00    	cmp    $0x2d8,%esi
    164c:	74 4d                	je     169b <fsm_core_close+0x21b>
    164e:	89 f3                	mov    %esi,%ebx
    1650:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
    1652:	b8 e6 02 00 00       	mov    $0x2e6,%eax
    1657:	e8 fc ff ff ff       	call   1658 <fsm_core_close+0x1d8>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    165c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    165f:	89 c2                	mov    %eax,%edx
    1661:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1664:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    1667:	89 01                	mov    %eax,(%ecx)
    1669:	b8 e6 02 00 00       	mov    $0x2e6,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    166e:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    1675:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    167c:	e8 fc ff ff ff       	call   167d <fsm_core_close+0x1fd>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1681:	8b 03                	mov    (%ebx),%eax
    1683:	e8 fc ff ff ff       	call   1684 <fsm_core_close+0x204>
    1688:	89 d8                	mov    %ebx,%eax
    168a:	e8 fc ff ff ff       	call   168b <fsm_core_close+0x20b>
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
			list_del(&tmev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
			fsm_mem_free(tmev_ptr->pE);
			fsm_mem_free(tmev_ptr);
			if(list_empty(&fsm_core.exp_ev_list))
    168f:	81 3d dc 02 00 00 dc 	cmpl   $0x2dc,0x2dc
    1696:	02 00 00 
    1699:	75 a5                	jne    1640 <fsm_core_close+0x1c0>
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
    169b:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    16a2:	00 00 00 
    16a5:	b8 4c 00 00 00       	mov    $0x4c,%eax
    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	for(i = 0; i < MAX_INTF; i++)
	{
		if(INTF[i].dev)
    16b0:	8b 10                	mov    (%eax),%edx
    16b2:	85 d2                	test   %edx,%edx
    16b4:	74 09                	je     16bf <fsm_core_close+0x23f>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    16b6:	8b 92 98 02 00 00    	mov    0x298(%edx),%edx
 *
 * Release reference to device to allow it to be freed.
 */
static inline void dev_put(struct net_device *dev)
{
	this_cpu_dec(*dev->pcpu_refcnt);
    16bc:	64 ff 0a             	decl   %fs:(%edx)
    16bf:	83 c0 10             	add    $0x10,%eax
			if(list_empty(&fsm_core.exp_ev_list))
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
	for(i = 0; i < MAX_INTF; i++)
    16c2:	3d 4c 02 00 00       	cmp    $0x24c,%eax
    16c7:	75 e7                	jne    16b0 <fsm_core_close+0x230>
    16c9:	b8 44 00 00 00       	mov    $0x44,%eax
    16ce:	66 90                	xchg   %ax,%ax
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    16d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    16d6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    16dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    16e3:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    16ea:	83 c0 10             	add    $0x10,%eax
		if(INTF[i].dev)
		{
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
    16ed:	3d 44 02 00 00       	cmp    $0x244,%eax
    16f2:	75 dc                	jne    16d0 <fsm_core_close+0x250>
		INTF[i].valid = 0;
		INTF[i].proto = 0;
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
    16f4:	c7 04 24 41 00 00 00 	movl   $0x41,(%esp)
    16fb:	e8 fc ff ff ff       	call   16fc <fsm_core_close+0x27c>
    1700:	89 fa                	mov    %edi,%edx
    1702:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1707:	e8 fc ff ff ff       	call   1708 <fsm_core_close+0x288>
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    170c:	31 c0                	xor    %eax,%eax
    170e:	83 c4 10             	add    $0x10,%esp
    1711:	5b                   	pop    %ebx
    1712:	5e                   	pop    %esi
    1713:	5f                   	pop    %edi
    1714:	5d                   	pop    %ebp
    1715:	c3                   	ret    
    1716:	8d 76 00             	lea    0x0(%esi),%esi
    1719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001720 <fsm_core_pkt_drive>:



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1720:	55                   	push   %ebp
    1721:	89 e5                	mov    %esp,%ebp
    1723:	83 ec 18             	sub    $0x18,%esp
    1726:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    1729:	89 75 fc             	mov    %esi,-0x4(%ebp)
    172c:	e8 fc ff ff ff       	call   172d <fsm_core_pkt_drive+0xd>
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1731:	83 fa 01             	cmp    $0x1,%edx
}



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1734:	89 c6                	mov    %eax,%esi
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1736:	74 68                	je     17a0 <fsm_core_pkt_drive+0x80>
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock ,flags2);
	}
	if(type == RXTX_PKT_REQ)
    1738:	85 d2                	test   %edx,%edx
    173a:	74 0c                	je     1748 <fsm_core_pkt_drive+0x28>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    173c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    173f:	31 c0                	xor    %eax,%eax
    1741:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1744:	89 ec                	mov    %ebp,%esp
    1746:	5d                   	pop    %ebp
    1747:	c3                   	ret    
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1748:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    174d:	e8 fc ff ff ff       	call   174e <fsm_core_pkt_drive+0x2e>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1752:	89 f1                	mov    %esi,%ecx
    1754:	31 d2                	xor    %edx,%edx
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1756:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1758:	a1 8c 02 00 00       	mov    0x28c,%eax
    175d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1764:	00 
    1765:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    176c:	00 
    176d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1774:	89 44 24 04          	mov    %eax,0x4(%esp)
    1778:	b8 01 00 00 00       	mov    $0x1,%eax
    177d:	e8 ae ec ff ff       	call   430 <__fsm_core_self_drive>
    1782:	89 da                	mov    %ebx,%edx
    1784:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1789:	e8 fc ff ff ff       	call   178a <fsm_core_pkt_drive+0x6a>
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    178e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1791:	31 c0                	xor    %eax,%eax
    1793:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1796:	89 ec                	mov    %ebp,%esp
    1798:	5d                   	pop    %ebp
    1799:	c3                   	ret    
    179a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17a0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17a5:	e8 fc ff ff ff       	call   17a6 <fsm_core_pkt_drive+0x86>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17aa:	89 f1                	mov    %esi,%ecx
    17ac:	31 d2                	xor    %edx,%edx
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17ae:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17b0:	a1 8c 02 00 00       	mov    0x28c,%eax
    17b5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    17bc:	00 
    17bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    17c4:	00 
    17c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    17cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    17d0:	b8 02 00 00 00       	mov    $0x2,%eax
    17d5:	e8 56 ec ff ff       	call   430 <__fsm_core_self_drive>
    17da:	89 da                	mov    %ebx,%edx
    17dc:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17e1:	e8 fc ff ff ff       	call   17e2 <fsm_core_pkt_drive+0xc2>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    17e6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    17e9:	31 c0                	xor    %eax,%eax
    17eb:	8b 75 fc             	mov    -0x4(%ebp),%esi
    17ee:	89 ec                	mov    %ebp,%esp
    17f0:	5d                   	pop    %ebp
    17f1:	c3                   	ret    
    17f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    17f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001800 <fsm_create_register>:

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1800:	55                   	push   %ebp
    1801:	89 e5                	mov    %esp,%ebp
    1803:	83 ec 14             	sub    $0x14,%esp
    1806:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1809:	89 75 f8             	mov    %esi,-0x8(%ebp)
    180c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    180f:	e8 fc ff ff ff       	call   1810 <fsm_create_register+0x10>
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1814:	31 db                	xor    %ebx,%ebx
	return FSM_EXEC_SUCC;
}

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1816:	89 c7                	mov    %eax,%edi
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
    1818:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
    181f:	85 c0                	test   %eax,%eax
    1821:	74 1d                	je     1840 <fsm_create_register+0x40>

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1823:	83 c3 01             	add    $0x1,%ebx
    1826:	83 fb 06             	cmp    $0x6,%ebx
    1829:	75 ed                	jne    1818 <fsm_create_register+0x18>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
			FSM[i]->_fsm_current_block = 0;
			return i;
			}
		}
	return -1;
    182b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
    1830:	8b 75 f8             	mov    -0x8(%ebp),%esi
    1833:	89 d8                	mov    %ebx,%eax
    1835:	8b 7d fc             	mov    -0x4(%ebp),%edi
    1838:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    183b:	89 ec                	mov    %ebp,%esp
    183d:	5d                   	pop    %ebp
    183e:	c3                   	ret    
    183f:	90                   	nop
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1840:	b8 90 00 00 00       	mov    $0x90,%eax
    1845:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1848:	8d b3 9c 00 00 00    	lea    0x9c(%ebx),%esi
    184e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    1851:	e8 fc ff ff ff       	call   1852 <fsm_create_register+0x52>
			FSM[i]->fsm_main = fsm_main;
    1856:	8b 55 ec             	mov    -0x14(%ebp),%edx
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1859:	89 04 b5 20 00 00 00 	mov    %eax,0x20(,%esi,4)
			FSM[i]->fsm_main = fsm_main;
    1860:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			FSM[i]->id = i;
    1866:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
			strcpy(FSM[i]->name, name);
    186d:	89 fa                	mov    %edi,%edx
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
			FSM[i]->fsm_main = fsm_main;
			FSM[i]->id = i;
    186f:	89 98 80 00 00 00    	mov    %ebx,0x80(%eax)
			strcpy(FSM[i]->name, name);
    1875:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    187c:	e8 fc ff ff ff       	call   187d <fsm_create_register+0x7d>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
    1881:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1888:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    188b:	89 88 88 00 00 00    	mov    %ecx,0x88(%eax)
			FSM[i]->_fsm_current_block = 0;
    1891:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1898:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
    189f:	00 00 00 
			return i;
			}
		}
	return -1;
}
    18a2:	89 d8                	mov    %ebx,%eax
    18a4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    18a7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    18aa:	8b 7d fc             	mov    -0x4(%ebp),%edi
    18ad:	89 ec                	mov    %ebp,%esp
    18af:	5d                   	pop    %ebp
    18b0:	c3                   	ret    
    18b1:	eb 0d                	jmp    18c0 <fsm_unregister_destroy>
    18b3:	90                   	nop
    18b4:	90                   	nop
    18b5:	90                   	nop
    18b6:	90                   	nop
    18b7:	90                   	nop
    18b8:	90                   	nop
    18b9:	90                   	nop
    18ba:	90                   	nop
    18bb:	90                   	nop
    18bc:	90                   	nop
    18bd:	90                   	nop
    18be:	90                   	nop
    18bf:	90                   	nop

000018c0 <fsm_unregister_destroy>:

void fsm_unregister_destroy(int id)
{
    18c0:	55                   	push   %ebp
    18c1:	89 e5                	mov    %esp,%ebp
    18c3:	53                   	push   %ebx
    18c4:	e8 fc ff ff ff       	call   18c5 <fsm_unregister_destroy+0x5>
	if(FSM[id]!=NULL)
    18c9:	8d 98 9c 00 00 00    	lea    0x9c(%eax),%ebx
    18cf:	8b 04 9d 20 00 00 00 	mov    0x20(,%ebx,4),%eax
    18d6:	85 c0                	test   %eax,%eax
    18d8:	74 10                	je     18ea <fsm_unregister_destroy+0x2a>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    18da:	e8 fc ff ff ff       	call   18db <fsm_unregister_destroy+0x1b>
void fsm_unregister_destroy(int id)
{
	if(FSM[id]!=NULL)
	{
		fsm_mem_free(FSM[id]);
		FSM[id] = NULL;
    18df:	c7 04 9d 20 00 00 00 	movl   $0x0,0x20(,%ebx,4)
    18e6:	00 00 00 00 
	}
}
    18ea:	5b                   	pop    %ebx
    18eb:	5d                   	pop    %ebp
    18ec:	c3                   	ret    
    18ed:	8d 76 00             	lea    0x0(%esi),%esi

000018f0 <fsm_core_destroy>:
	return; 
}

		
void fsm_core_destroy()
{
    18f0:	55                   	push   %ebp
    18f1:	89 e5                	mov    %esp,%ebp
    18f3:	53                   	push   %ebx
    18f4:	e8 fc ff ff ff       	call   18f5 <fsm_core_destroy+0x5>
	int i;
	if(fsm_core.state != CORE_CLOSED)
    18f9:	a1 28 00 00 00       	mov    0x28,%eax
    18fe:	85 c0                	test   %eax,%eax
    1900:	75 56                	jne    1958 <fsm_core_destroy+0x68>
	return; 
}

		
void fsm_core_destroy()
{
    1902:	31 db                	xor    %ebx,%ebx
    1904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
	{
		fsm_unregister_destroy(i);
    1908:	89 d8                	mov    %ebx,%eax
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    190a:	83 c3 01             	add    $0x1,%ebx
	{
		fsm_unregister_destroy(i);
    190d:	e8 fc ff ff ff       	call   190e <fsm_core_destroy+0x1e>
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    1912:	83 fb 06             	cmp    $0x6,%ebx
    1915:	75 f1                	jne    1908 <fsm_core_destroy+0x18>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1917:	a1 b8 02 00 00       	mov    0x2b8,%eax
    191c:	e8 fc ff ff ff       	call   191d <fsm_core_destroy+0x2d>
    1921:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1926:	e8 fc ff ff ff       	call   1927 <fsm_core_destroy+0x37>
    192b:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1930:	e8 fc ff ff ff       	call   1931 <fsm_core_destroy+0x41>
    1935:	a1 c4 02 00 00       	mov    0x2c4,%eax
    193a:	e8 fc ff ff ff       	call   193b <fsm_core_destroy+0x4b>
    193f:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1944:	e8 fc ff ff ff       	call   1945 <fsm_core_destroy+0x55>
    1949:	a1 cc 02 00 00       	mov    0x2cc,%eax
    194e:	e8 fc ff ff ff       	call   194f <fsm_core_destroy+0x5f>
	fsm_mem_free(fsm_core.tx_tsklt);
	fsm_mem_free(fsm_core.rx_tsklt);
	fsm_mem_free(fsm_core.do_ioctl_tsklt);
	fsm_mem_free(fsm_core.exp_ev_tsklt);
	return;
}
    1953:	5b                   	pop    %ebx
    1954:	5d                   	pop    %ebp
    1955:	c3                   	ret    
    1956:	66 90                	xchg   %ax,%ax
		
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
    1958:	e8 fc ff ff ff       	call   1959 <fsm_core_destroy+0x69>
    195d:	8d 76 00             	lea    0x0(%esi),%esi
    1960:	eb a0                	jmp    1902 <fsm_core_destroy+0x12>
    1962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1969:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001970 <fsm_mainport_bind>:
		FSM[id] = NULL;
	}
}

void fsm_mainport_bind(int id)
{
    1970:	55                   	push   %ebp
    1971:	89 e5                	mov    %esp,%ebp
    1973:	e8 fc ff ff ff       	call   1974 <fsm_mainport_bind+0x4>
	fsm_core.main_port = id;
}
    1978:	5d                   	pop    %ebp
	}
}

void fsm_mainport_bind(int id)
{
	fsm_core.main_port = id;
    1979:	a3 8c 02 00 00       	mov    %eax,0x28c
}
    197e:	c3                   	ret    
    197f:	90                   	nop

00001980 <__fsm_dev_set_config>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_set_config(struct net_device *dev, struct ifmap *p_ifmap)
{
    1980:	55                   	push   %ebp
    1981:	89 e5                	mov    %esp,%ebp
    1983:	e8 fc ff ff ff       	call   1984 <__fsm_dev_set_config+0x4>
    	return 0;
}
    1988:	31 c0                	xor    %eax,%eax
    198a:	5d                   	pop    %ebp
    198b:	c3                   	ret    
    198c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001990 <__fsm_dev_get_stats>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    1990:	55                   	push   %ebp
    1991:	89 e5                	mov    %esp,%ebp
    1993:	e8 fc ff ff ff       	call   1994 <__fsm_dev_get_stats+0x4>
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
}
    1998:	5d                   	pop    %ebp
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
    1999:	05 c0 04 00 00       	add    $0x4c0,%eax
}
    199e:	c3                   	ret    
    199f:	90                   	nop

000019a0 <__fsm_dev_tx_timeout>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_tx_timeout(struct net_device *dev)
{  
    19a0:	55                   	push   %ebp
    19a1:	89 e5                	mov    %esp,%ebp
    19a3:	e8 fc ff ff ff       	call   19a4 <__fsm_dev_tx_timeout+0x4>
    return;   
}
    19a8:	5d                   	pop    %ebp
    19a9:	c3                   	ret    
    19aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000019b0 <__fsm_dev_ioctl>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	e8 fc ff ff ff       	call   19b4 <__fsm_dev_ioctl+0x4>
    19b8:	89 d0                	mov    %edx,%eax
    19ba:	89 ca                	mov    %ecx,%edx
	fsm_ioctrl_arrival(ifr,cmd);
    19bc:	e8 fc ff ff ff       	call   19bd <__fsm_dev_ioctl+0xd>
	return 0;
}
    19c1:	31 c0                	xor    %eax,%eax
    19c3:	5d                   	pop    %ebp
    19c4:	c3                   	ret    
    19c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    19c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019d0 <__fsm_dev_tx>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_tx(struct sk_buff *skb, struct net_device *dev)
{ 
    19d0:	55                   	push   %ebp
    19d1:	89 e5                	mov    %esp,%ebp
    19d3:	e8 fc ff ff ff       	call   19d4 <__fsm_dev_tx+0x4>
	fsm_core_pkt_drive(skb, RXTX_PKT_REQ);	
    19d8:	31 d2                	xor    %edx,%edx
    19da:	e8 fc ff ff ff       	call   19db <__fsm_dev_tx+0xb>
   	return 0;    
}	
    19df:	31 c0                	xor    %eax,%eax
    19e1:	5d                   	pop    %ebp
    19e2:	c3                   	ret    
    19e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    19e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019f0 <__fsm_dev_recv>:
 **-------------------------------------- ------system--------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_recv(struct sk_buff *skb ,struct net_device *dev1, struct packet_type *pktype, struct net_device *dev2)
{  
    19f0:	55                   	push   %ebp
    19f1:	89 e5                	mov    %esp,%ebp
    19f3:	e8 fc ff ff ff       	call   19f4 <__fsm_dev_recv+0x4>
    	fsm_core_pkt_drive(skb, RXTX_PKT_IND);
    19f8:	ba 01 00 00 00       	mov    $0x1,%edx
    19fd:	e8 fc ff ff ff       	call   19fe <__fsm_dev_recv+0xe>
    	return 0;            
}
    1a02:	31 c0                	xor    %eax,%eax
    1a04:	5d                   	pop    %ebp
    1a05:	c3                   	ret    
    1a06:	8d 76 00             	lea    0x0(%esi),%esi
    1a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001a10 <__fsm_dev_open>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	53                   	push   %ebx
    1a14:	83 ec 04             	sub    $0x4,%esp
    1a17:	e8 fc ff ff ff       	call   1a18 <__fsm_dev_open+0x8>
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a1c:	b9 f3 f4 00 00       	mov    $0xf4f3,%ecx
    1a21:	ba 02 00 00 00       	mov    $0x2,%edx
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a26:	89 c3                	mov    %eax,%ebx
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a28:	b8 05 00 00 00       	mov    $0x5,%eax
    1a2d:	c7 04 24 53 00 00 00 	movl   $0x53,(%esp)
    1a34:	e8 fc ff ff ff       	call   1a35 <__fsm_dev_open+0x25>
	fsm_core_intf_set(STRM_TO_IPADP, DEV_INTF_IND, DEV_PROTO_IPADP, "LTE_IPADP0");
    1a39:	b9 f0 f4 00 00       	mov    $0xf4f0,%ecx
    1a3e:	ba 02 00 00 00       	mov    $0x2,%edx
    1a43:	b8 07 00 00 00       	mov    $0x7,%eax
    1a48:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp)
    1a4f:	e8 fc ff ff ff       	call   1a50 <__fsm_dev_open+0x40>
	fsm_core_intf_set(STRM_TO_PDCP, DEV_INTF_IND, DEV_PROTO_PDCP, "LTE_PDCP0");
    1a54:	b9 f1 f4 00 00       	mov    $0xf4f1,%ecx
    1a59:	ba 02 00 00 00       	mov    $0x2,%edx
    1a5e:	b8 06 00 00 00       	mov    $0x6,%eax
    1a63:	c7 04 24 67 00 00 00 	movl   $0x67,(%esp)
    1a6a:	e8 fc ff ff ff       	call   1a6b <__fsm_dev_open+0x5b>
	//fsm_core_intf_set(STRM_TO_RLC, DEV_INTF_IND, DEV_PROTO_RLC, "LTE_RLC0");
	fsm_core_intf_set(STRM_TO_SRIO, DEV_INTF_REQ, DEV_PROTO_RLC_MAC, "LTE_SRIO0");
    1a6f:	b9 f8 f4 00 00       	mov    $0xf4f8,%ecx
    1a74:	ba 01 00 00 00       	mov    $0x1,%edx
    1a79:	b8 03 00 00 00       	mov    $0x3,%eax
    1a7e:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
    1a85:	e8 fc ff ff ff       	call   1a86 <__fsm_dev_open+0x76>
    	dev_add_pack(&pk_t); 
    1a8a:	b8 00 00 00 00       	mov    $0x0,%eax
    1a8f:	e8 fc ff ff ff       	call   1a90 <__fsm_dev_open+0x80>
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    1a94:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 */
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    1a9a:	f0 80 60 50 fe       	lock andb $0xfe,0x50(%eax)
	netif_start_queue(dev);   
    	fsm_core_open();	 
    1a9f:	e8 fc ff ff ff       	call   1aa0 <__fsm_dev_open+0x90>
    	return 0;    
}
    1aa4:	31 c0                	xor    %eax,%eax
    1aa6:	83 c4 04             	add    $0x4,%esp
    1aa9:	5b                   	pop    %ebx
    1aaa:	5d                   	pop    %ebp
    1aab:	c3                   	ret    
    1aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001ab0 <dev_init>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1ab0:	55                   	push   %ebp
    1ab1:	89 e5                	mov    %esp,%ebp
    1ab3:	53                   	push   %ebx
    1ab4:	83 ec 08             	sub    $0x8,%esp
    1ab7:	e8 fc ff ff ff       	call   1ab8 <dev_init+0x8>
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1abc:	85 c0                	test   %eax,%eax
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1abe:	89 c3                	mov    %eax,%ebx
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1ac0:	0f 84 af 00 00 00    	je     1b75 <dev_init+0xc5>
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ac6:	83 88 a4 00 00 00 04 	orl    $0x4,0xa4(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1acd:	b9 60 00 00 00       	mov    $0x60,%ecx
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ad2:	83 88 a8 00 00 00 00 	orl    $0x0,0xa8(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1ad9:	31 d2                	xor    %edx,%edx
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    	dev->tx_queue_len = 128;   	/* the queue length */   
    1adb:	c7 80 50 02 00 00 80 	movl   $0x80,0x250(%eax)
    1ae2:	00 00 00 
    	dev->mtu = MTU;		/* now we do not fragmentate the packet */
    1ae5:	c7 80 50 01 00 00 dc 	movl   $0x5dc,0x150(%eax)
    1aec:	05 00 00 
   	dev->header_ops = NULL;   	/* cancle eth_header function for not building ethnet mac header */ 
    1aef:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%eax)
    1af6:	00 00 00 
    	dev->addr_len = 0;
    1af9:	c6 80 7d 01 00 00 00 	movb   $0x0,0x17d(%eax)
    	dev->hard_header_len = 0;
    1b00:	66 c7 80 56 01 00 00 	movw   $0x0,0x156(%eax)
    1b07:	00 00 
	dev->netdev_ops = &fsm_netdev_ops;
    1b09:	c7 80 34 01 00 00 20 	movl   $0x20,0x134(%eax)
    1b10:	00 00 00 
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
    1b13:	c7 80 60 02 00 00 e8 	movl   $0x3e8,0x260(%eax)
    1b1a:	03 00 00 
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    1b1d:	c7 80 40 01 00 00 82 	movl   $0x1082,0x140(%eax)
    1b24:	10 00 00 
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
    1b27:	8d 80 c0 04 00 00    	lea    0x4c0(%eax),%eax
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1b2d:	e8 fc ff ff ff       	call   1b2e <dev_init+0x7e>
	fsm_core_create(dev);
    1b32:	89 d8                	mov    %ebx,%eax
    1b34:	e8 fc ff ff ff       	call   1b35 <dev_init+0x85>
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b39:	b8 ac 5a 00 00       	mov    $0x5aac,%eax
    1b3e:	e8 fc ff ff ff       	call   1b3f <dev_init+0x8f>
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b43:	b9 ac 5a 00 00       	mov    $0x5aac,%ecx
    1b48:	31 d2                	xor    %edx,%edx
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
	fsm_core_create(dev);
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b4a:	89 83 1c 05 00 00    	mov    %eax,0x51c(%ebx)
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b50:	e8 fc ff ff ff       	call   1b51 <dev_init+0xa1>
/*-----------------------------------FSM creation---------------------------*/
	fsm_id = fsm_create_register("lte_rlc_mac_fsm", rlc_mac_main, priv->sv_ptr);
    1b55:	8b 8b 1c 05 00 00    	mov    0x51c(%ebx),%ecx
    1b5b:	ba 00 00 00 00       	mov    $0x0,%edx
    1b60:	b8 7b 00 00 00       	mov    $0x7b,%eax
    1b65:	e8 fc ff ff ff       	call   1b66 <dev_init+0xb6>
	fsm_mainport_bind(fsm_id);
    1b6a:	e8 fc ff ff ff       	call   1b6b <dev_init+0xbb>
/*--------------------------------------------------------------------------*/
    return;
}
    1b6f:	83 c4 08             	add    $0x8,%esp
    1b72:	5b                   	pop    %ebx
    1b73:	5d                   	pop    %ebp
    1b74:	c3                   	ret    
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1b75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1b7c:	00 
    1b7d:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
    1b84:	e8 fc ff ff ff       	call   1b85 <dev_init+0xd5>
    1b89:	e8 fc ff ff ff       	call   1b8a <dev_init+0xda>
    1b8e:	eb df                	jmp    1b6f <dev_init+0xbf>

00001b90 <__fsm_dev_stop>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_stop(struct net_device *dev)
{  
    1b90:	55                   	push   %ebp
    1b91:	89 e5                	mov    %esp,%ebp
    1b93:	53                   	push   %ebx
    1b94:	83 ec 04             	sub    $0x4,%esp
    1b97:	e8 fc ff ff ff       	call   1b98 <__fsm_dev_stop+0x8>
    1b9c:	89 c3                	mov    %eax,%ebx
         
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    1b9e:	e8 fc ff ff ff       	call   1b9f <__fsm_dev_stop+0xf>
    	dev_remove_pack(&pk_t);
    1ba3:	b8 00 00 00 00       	mov    $0x0,%eax
    1ba8:	e8 fc ff ff ff       	call   1ba9 <__fsm_dev_stop+0x19>
{  
    return;   
}

module_init(__fsm_dev_create);
module_exit(__fsm_dev_destroy);
    1bad:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
	}
}

static inline void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
	if (WARN_ON(!dev_queue)) {
    1bb3:	85 c0                	test   %eax,%eax
    1bb5:	74 0d                	je     1bc4 <__fsm_dev_stop+0x34>
 */
static __always_inline void
set_bit(unsigned int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1bb7:	f0 80 48 50 01       	lock orb $0x1,0x50(%eax)
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    	dev_remove_pack(&pk_t);
    	netif_stop_queue(dev);
     	return 0;    
}
    1bbc:	83 c4 04             	add    $0x4,%esp
    1bbf:	31 c0                	xor    %eax,%eax
    1bc1:	5b                   	pop    %ebx
    1bc2:	5d                   	pop    %ebp
    1bc3:	c3                   	ret    
    1bc4:	ba 50 07 00 00       	mov    $0x750,%edx
    1bc9:	b8 8b 00 00 00       	mov    $0x8b,%eax
    1bce:	e8 fc ff ff ff       	call   1bcf <__fsm_dev_stop+0x3f>
		pr_info("netif_stop_queue() cannot be called before register_netdev()\n");
    1bd3:	c7 04 24 8c 00 00 00 	movl   $0x8c,(%esp)
    1bda:	e8 fc ff ff ff       	call   1bdb <__fsm_dev_stop+0x4b>
    1bdf:	eb db                	jmp    1bbc <__fsm_dev_stop+0x2c>
    1be1:	eb 0d                	jmp    1bf0 <__fsm_dev_create>
    1be3:	90                   	nop
    1be4:	90                   	nop
    1be5:	90                   	nop
    1be6:	90                   	nop
    1be7:	90                   	nop
    1be8:	90                   	nop
    1be9:	90                   	nop
    1bea:	90                   	nop
    1beb:	90                   	nop
    1bec:	90                   	nop
    1bed:	90                   	nop
    1bee:	90                   	nop
    1bef:	90                   	nop

00001bf0 <__fsm_dev_create>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_create(void)
{   
    1bf0:	55                   	push   %ebp
    1bf1:	89 e5                	mov    %esp,%ebp
    1bf3:	53                   	push   %ebx
    1bf4:	83 ec 08             	sub    $0x8,%esp
    1bf7:	e8 fc ff ff ff       	call   1bf8 <__fsm_dev_create+0x8>
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1bfc:	b9 00 00 00 00       	mov    $0x0,%ecx
    1c01:	ba a5 00 00 00       	mov    $0xa5,%edx
    1c06:	b8 60 00 00 00       	mov    $0x60,%eax
    1c0b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1c12:	00 
    1c13:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1c1a:	e8 fc ff ff ff       	call   1c1b <__fsm_dev_create+0x2b>
    if (dev == NULL)   /* allocation error */
    1c1f:	85 c0                	test   %eax,%eax
{   
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1c21:	89 c3                	mov    %eax,%ebx
    if (dev == NULL)   /* allocation error */
    1c23:	74 41                	je     1c66 <__fsm_dev_create+0x76>
		{
		return -2;
		}
	memcpy(dev->dev_addr, &dev_addr, 6);       
    1c25:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
    1c2b:	c6 00 00             	movb   $0x0,(%eax)
    1c2e:	c6 40 01 11          	movb   $0x11,0x1(%eax)
    1c32:	c6 40 02 1a          	movb   $0x1a,0x2(%eax)
    1c36:	c6 40 03 1a          	movb   $0x1a,0x3(%eax)
    1c3a:	c6 40 04 8a          	movb   $0x8a,0x4(%eax)
    1c3e:	c6 40 05 42          	movb   $0x42,0x5(%eax)
    if (priv == NULL)
    	{                
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
    1c42:	89 d8                	mov    %ebx,%eax
    1c44:	e8 fc ff ff ff       	call   1c45 <__fsm_dev_create+0x55>
    1c49:	85 c0                	test   %eax,%eax
    1c4b:	75 0b                	jne    1c58 <__fsm_dev_create+0x68>
		{
        free_netdev(dev);   /* release the struct net_device */
        dev = NULL;               
        return -1;
		}
 	return 0;       
    1c4d:	31 c0                	xor    %eax,%eax
}
    1c4f:	83 c4 08             	add    $0x8,%esp
    1c52:	5b                   	pop    %ebx
    1c53:	5d                   	pop    %ebp
    1c54:	c3                   	ret    
    1c55:	8d 76 00             	lea    0x0(%esi),%esi
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
		{
        free_netdev(dev);   /* release the struct net_device */
    1c58:	89 d8                	mov    %ebx,%eax
    1c5a:	e8 fc ff ff ff       	call   1c5b <__fsm_dev_create+0x6b>
        dev = NULL;               
        return -1;
    1c5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1c64:	eb e9                	jmp    1c4f <__fsm_dev_create+0x5f>
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    if (dev == NULL)   /* allocation error */
		{
		return -2;
    1c66:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    1c6b:	eb e2                	jmp    1c4f <__fsm_dev_create+0x5f>
    1c6d:	8d 76 00             	lea    0x0(%esi),%esi

00001c70 <__fsm_dev_destroy>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_destroy(void)
{
    1c70:	55                   	push   %ebp
    1c71:	89 e5                	mov    %esp,%ebp
    1c73:	53                   	push   %ebx
    1c74:	e8 fc ff ff ff       	call   1c75 <__fsm_dev_destroy+0x5>
	NETDEV* dev;
	fsm_priv* priv;
	dev = (NETDEV*)fsm_dev_get();
    1c79:	e8 fc ff ff ff       	call   1c7a <__fsm_dev_destroy+0xa>
    1c7e:	89 c3                	mov    %eax,%ebx
	fsm_core_destroy();
    1c80:	e8 fc ff ff ff       	call   1c81 <__fsm_dev_destroy+0x11>
	priv = netdev_priv(dev);
	fsm_mem_free(priv->sv_ptr);
    1c85:	8b 83 1c 05 00 00    	mov    0x51c(%ebx),%eax
    1c8b:	e8 fc ff ff ff       	call   1c8c <__fsm_dev_destroy+0x1c>
    	unregister_netdev(dev);
    1c90:	89 d8                	mov    %ebx,%eax
    1c92:	e8 fc ff ff ff       	call   1c93 <__fsm_dev_destroy+0x23>
    	free_netdev(dev);
    1c97:	89 d8                	mov    %ebx,%eax
    1c99:	e8 fc ff ff ff       	call   1c9a <__fsm_dev_destroy+0x2a>
}   
    1c9e:	5b                   	pop    %ebx
    1c9f:	5d                   	pop    %ebp
    1ca0:	c3                   	ret    
    1ca1:	90                   	nop
    1ca2:	90                   	nop
    1ca3:	90                   	nop
    1ca4:	90                   	nop
    1ca5:	90                   	nop
    1ca6:	90                   	nop
    1ca7:	90                   	nop
    1ca8:	90                   	nop
    1ca9:	90                   	nop
    1caa:	90                   	nop
    1cab:	90                   	nop
    1cac:	90                   	nop
    1cad:	90                   	nop
    1cae:	90                   	nop
    1caf:	90                   	nop

00001cb0 <findInsByCode>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void * findInsByCode(long code, RlcTimerType * timer)
{
    1cb0:	55                   	push   %ebp
    1cb1:	89 e5                	mov    %esp,%ebp
    1cb3:	57                   	push   %edi
    1cb4:	56                   	push   %esi
    1cb5:	53                   	push   %ebx
    1cb6:	e8 fc ff ff ff       	call   1cb7 <findInsByCode+0x7>
    1cbb:	89 d6                	mov    %edx,%esi
    1cbd:	89 c3                	mov    %eax,%ebx
	struct list_head* pos;
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	
	FIN(findInsByCode());
	SV_PTR_GET(rlc_mac_sv);
    1cbf:	e8 fc ff ff ff       	call   1cc0 <findInsByCode+0x10>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1cc4:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
	/*if( SV(bufferReqTimerCode) == code )
	{
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    1cca:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    1cd0:	39 d1                	cmp    %edx,%ecx
    1cd2:	74 28                	je     1cfc <findInsByCode+0x4c>
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
    1cd4:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cda:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1ce0:	75 14                	jne    1cf6 <findInsByCode+0x46>
    1ce2:	eb 64                	jmp    1d48 <findInsByCode+0x98>
    1ce4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1ce8:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cee:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1cf4:	74 52                	je     1d48 <findInsByCode+0x98>
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    1cf6:	8b 12                	mov    (%edx),%edx
    1cf8:	39 d1                	cmp    %edx,%ecx
    1cfa:	75 ec                	jne    1ce8 <findInsByCode+0x38>
    1cfc:	8b 90 f4 25 00 00    	mov    0x25f4(%eax),%edx
				*timer = UM_REORDER;
				return (void*)umRxIns;
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
    1d02:	8d 88 f4 25 00 00    	lea    0x25f4(%eax),%ecx
    1d08:	39 d1                	cmp    %edx,%ecx
    1d0a:	75 1a                	jne    1d26 <findInsByCode+0x76>
    1d0c:	eb 5a                	jmp    1d68 <findInsByCode+0xb8>
    1d0e:	66 90                	xchg   %ax,%ax
			if(amIns->pollRetxTimerCode == code)
			{
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
    1d10:	39 9a 14 dd ff ff    	cmp    %ebx,-0x22ec(%edx)
    1d16:	74 40                	je     1d58 <findInsByCode+0xa8>
			{
				*timer = AM_REORDER;
				return (void*)amIns;
			}
			if(amIns->statProhTimerCode == code)
    1d18:	39 9a 20 dd ff ff    	cmp    %ebx,-0x22e0(%edx)
    1d1e:	74 40                	je     1d60 <findInsByCode+0xb0>
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    1d20:	8b 12                	mov    (%edx),%edx
    1d22:	39 d1                	cmp    %edx,%ecx
    1d24:	74 2a                	je     1d50 <findInsByCode+0xa0>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->pollRetxTimerCode == code)
    1d26:	39 9a 08 dd ff ff    	cmp    %ebx,-0x22f8(%edx)
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    1d2c:	8d ba fc dc ff ff    	lea    -0x2304(%edx),%edi
			if(amIns->pollRetxTimerCode == code)
    1d32:	75 dc                	jne    1d10 <findInsByCode+0x60>
			{
				*timer = POLL_RETX;
    1d34:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    1d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	else
	{
		return NULL;
	}
}
    1d40:	5b                   	pop    %ebx
    1d41:	89 f8                	mov    %edi,%eax
    1d43:	5e                   	pop    %esi
    1d44:	5f                   	pop    %edi
    1d45:	5d                   	pop    %ebp
    1d46:	c3                   	ret    
    1d47:	90                   	nop
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
			{
				*timer = UM_REORDER;
    1d48:	c7 06 04 00 00 00    	movl   $0x4,(%esi)
				return (void*)umRxIns;
    1d4e:	eb f0                	jmp    1d40 <findInsByCode+0x90>
	}
	else
	{
		return NULL;
	}
}
    1d50:	5b                   	pop    %ebx
    1d51:	5e                   	pop    %esi
    1d52:	5f                   	pop    %edi
    1d53:	5d                   	pop    %ebp
    1d54:	c3                   	ret    
    1d55:	8d 76 00             	lea    0x0(%esi),%esi
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
			{
				*timer = AM_REORDER;
    1d58:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				return (void*)amIns;
    1d5e:	eb e0                	jmp    1d40 <findInsByCode+0x90>
			}
			if(amIns->statProhTimerCode == code)
			{
				*timer = STAT_PRO;
    1d60:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
				return (void*)amIns;
    1d66:	eb d8                	jmp    1d40 <findInsByCode+0x90>
			}
		}
	}
	else
	{
		return NULL;
    1d68:	31 ff                	xor    %edi,%edi
    1d6a:	eb d4                	jmp    1d40 <findInsByCode+0x90>
    1d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001d70 <rlc_close>:
**--------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
***********************************************************************************/
static void rlc_close()
{
    1d70:	55                   	push   %ebp
    1d71:	89 e5                	mov    %esp,%ebp
    1d73:	57                   	push   %edi
    1d74:	56                   	push   %esi
    1d75:	53                   	push   %ebx
    1d76:	83 ec 20             	sub    $0x20,%esp
    1d79:	e8 fc ff ff ff       	call   1d7a <rlc_close+0xa>
	struct AmBuffer *amBuffer, *tempAmBuffer;
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
    1d7e:	e8 fc ff ff ff       	call   1d7f <rlc_close+0xf>
    1d83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
//AM
	if(!list_empty(&SV(vAm_ins).amList))
    1d86:	05 f4 25 00 00       	add    $0x25f4,%eax
    1d8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1d91:	8b b0 f4 25 00 00    	mov    0x25f4(%eax),%esi
    1d97:	39 75 e0             	cmp    %esi,-0x20(%ebp)
    1d9a:	0f 84 6f 04 00 00    	je     220f <rlc_close+0x49f>
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    1da0:	8b 06                	mov    (%esi),%eax
    1da2:	81 ee 04 23 00 00    	sub    $0x2304,%esi
    1da8:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    1dae:	89 55 e8             	mov    %edx,-0x18(%ebp)
    1db1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1db8:	8b 96 08 23 00 00    	mov    0x2308(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1dbe:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1dc1:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1dc3:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
    1dc9:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1dcf:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    1dd6:	01 10 00 
	entry->prev = LIST_POISON2;
    1dd9:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    1de0:	02 20 00 
    1de3:	39 c2                	cmp    %eax,%edx
    1de5:	0f 84 8d 08 00 00    	je     2678 <rlc_close+0x908>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    1deb:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1df1:	8b 00                	mov    (%eax),%eax
    1df3:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1df6:	89 d6                	mov    %edx,%esi
    1df8:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1dfe:	eb 1e                	jmp    1e1e <rlc_close+0xae>
    1e00:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1e06:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1e0c:	39 ce                	cmp    %ecx,%esi
    1e0e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1e14:	0f 84 ae 03 00 00    	je     21c8 <rlc_close+0x458>
    1e1a:	89 fb                	mov    %edi,%ebx
    1e1c:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1e1e:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1e24:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1e27:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1e29:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1e2b:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1e32:	01 10 00 
	entry->prev = LIST_POISON2;
    1e35:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1e3c:	02 20 00 
    1e3f:	85 c0                	test   %eax,%eax
    1e41:	74 0b                	je     1e4e <rlc_close+0xde>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1e43:	e8 fc ff ff ff       	call   1e44 <rlc_close+0xd4>
						amBuffer->pkt = NULL;
    1e48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1e4e:	85 db                	test   %ebx,%ebx
    1e50:	74 07                	je     1e59 <rlc_close+0xe9>
					{
						fsm_mem_free(amBuffer);
    1e52:	89 d8                	mov    %ebx,%eax
    1e54:	e8 fc ff ff ff       	call   1e55 <rlc_close+0xe5>
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
    1e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5c:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    1e62:	75 9c                	jne    1e00 <rlc_close+0x90>
    1e64:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
						break;
    1e66:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
    1e68:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
    1e6f:	e8 fc ff ff ff       	call   1e70 <rlc_close+0x100>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1e74:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    1e7a:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    1e80:	39 c2                	cmp    %eax,%edx
    1e82:	0f 84 59 03 00 00    	je     21e1 <rlc_close+0x471>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    1e88:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1e8e:	8b 00                	mov    (%eax),%eax
    1e90:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1e93:	89 d6                	mov    %edx,%esi
    1e95:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1e9b:	eb 21                	jmp    1ebe <rlc_close+0x14e>
    1e9d:	8d 76 00             	lea    0x0(%esi),%esi
    1ea0:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1ea6:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1eac:	39 ce                	cmp    %ecx,%esi
    1eae:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1eb4:	0f 84 e6 02 00 00    	je     21a0 <rlc_close+0x430>
    1eba:	89 fb                	mov    %edi,%ebx
    1ebc:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ebe:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1ec4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1ec7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1ec9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1ecb:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1ed2:	01 10 00 
	entry->prev = LIST_POISON2;
    1ed5:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1edc:	02 20 00 
    1edf:	85 c0                	test   %eax,%eax
    1ee1:	74 0b                	je     1eee <rlc_close+0x17e>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1ee3:	e8 fc ff ff ff       	call   1ee4 <rlc_close+0x174>
						amBuffer->pkt = NULL;
    1ee8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1eee:	85 db                	test   %ebx,%ebx
    1ef0:	74 07                	je     1ef9 <rlc_close+0x189>
					{
						fsm_mem_free(amBuffer);
    1ef2:	89 d8                	mov    %ebx,%eax
    1ef4:	e8 fc ff ff ff       	call   1ef5 <rlc_close+0x185>
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
    1ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1efc:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    1f02:	75 9c                	jne    1ea0 <rlc_close+0x130>
    1f04:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
						break;
    1f06:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
    1f08:	c7 04 24 2c 01 00 00 	movl   $0x12c,(%esp)
    1f0f:	e8 fc ff ff ff       	call   1f10 <rlc_close+0x1a0>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1f14:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    1f17:	8d 4e 44             	lea    0x44(%esi),%ecx
    1f1a:	39 f9                	cmp    %edi,%ecx
    1f1c:	0f 84 91 02 00 00    	je     21b3 <rlc_close+0x443>
			{
				list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    1f22:	8b 07                	mov    (%edi),%eax
    1f24:	83 ef 0c             	sub    $0xc,%edi
    1f27:	89 75 ec             	mov    %esi,-0x14(%ebp)
    1f2a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    1f2d:	89 cb                	mov    %ecx,%ebx
    1f2f:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f32:	89 d6                	mov    %edx,%esi
    1f34:	eb 17                	jmp    1f4d <rlc_close+0x1dd>
    1f36:	66 90                	xchg   %ax,%ax
    1f38:	8b 46 0c             	mov    0xc(%esi),%eax
    1f3b:	8d 4e 0c             	lea    0xc(%esi),%ecx
    1f3e:	39 cb                	cmp    %ecx,%ebx
    1f40:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f43:	0f 84 07 02 00 00    	je     2150 <rlc_close+0x3e0>
    1f49:	89 f7                	mov    %esi,%edi
    1f4b:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1f4d:	8b 57 10             	mov    0x10(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1f50:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1f53:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amsBuffer->list);
					if(amBuffer->pkt != NULL)
    1f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1f58:	c7 47 0c 00 01 10 00 	movl   $0x100100,0xc(%edi)
	entry->prev = LIST_POISON2;
    1f5f:	c7 47 10 00 02 20 00 	movl   $0x200200,0x10(%edi)
    1f66:	8b 00                	mov    (%eax),%eax
    1f68:	85 c0                	test   %eax,%eax
    1f6a:	74 10                	je     1f7c <rlc_close+0x20c>
					{
						fsm_pkt_destroy(amsBuffer->pkt);
    1f6c:	8b 07                	mov    (%edi),%eax
    1f6e:	e8 fc ff ff ff       	call   1f6f <rlc_close+0x1ff>
						amBuffer->pkt = NULL;
    1f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					}
					if(amsBuffer != NULL)
    1f7c:	85 ff                	test   %edi,%edi
    1f7e:	74 07                	je     1f87 <rlc_close+0x217>
					{
						fsm_mem_free(amsBuffer);
    1f80:	89 f8                	mov    %edi,%eax
    1f82:	e8 fc ff ff ff       	call   1f83 <rlc_close+0x213>
						amsBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amSduBuffer.list))
    1f87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f8a:	3b 58 44             	cmp    0x44(%eax),%ebx
    1f8d:	75 a9                	jne    1f38 <rlc_close+0x1c8>
    1f8f:	89 c6                	mov    %eax,%esi
    1f91:	8b 5d f0             	mov    -0x10(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:sdu buffer is realeasing\n");
    1f94:	c7 04 24 94 01 00 00 	movl   $0x194,(%esp)
    1f9b:	e8 fc ff ff ff       	call   1f9c <rlc_close+0x22c>
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    1fa0:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    1fa6:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    1fac:	0f 84 b6 01 00 00    	je     2168 <rlc_close+0x3f8>
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is not empty\n");
    1fb2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    1fb5:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
    1fbc:	e8 fc ff ff ff       	call   1fbd <rlc_close+0x24d>
				list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    1fc1:	8b 96 b0 01 00 00    	mov    0x1b0(%esi),%edx
    1fc7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    1fca:	8b 02                	mov    (%edx),%eax
    1fcc:	8d 7a fc             	lea    -0x4(%edx),%edi
    1fcf:	39 d1                	cmp    %edx,%ecx
    1fd1:	74 78                	je     204b <rlc_close+0x2db>
    1fd3:	8d 50 fc             	lea    -0x4(%eax),%edx
    1fd6:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1fd9:	89 ce                	mov    %ecx,%esi
    1fdb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    1fde:	89 d3                	mov    %edx,%ebx
    1fe0:	eb 1b                	jmp    1ffd <rlc_close+0x28d>
    1fe2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1fe8:	8b 43 04             	mov    0x4(%ebx),%eax
    1feb:	8d 4b 04             	lea    0x4(%ebx),%ecx
    1fee:	39 ce                	cmp    %ecx,%esi
    1ff0:	8d 50 fc             	lea    -0x4(%eax),%edx
    1ff3:	0f 84 ff 01 00 00    	je     21f8 <rlc_close+0x488>
    1ff9:	89 df                	mov    %ebx,%edi
    1ffb:	89 d3                	mov    %edx,%ebx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ffd:	8b 57 08             	mov    0x8(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2000:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2003:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    2005:	8b 07                	mov    (%edi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2007:	c7 47 04 00 01 10 00 	movl   $0x100100,0x4(%edi)
	entry->prev = LIST_POISON2;
    200e:	c7 47 08 00 02 20 00 	movl   $0x200200,0x8(%edi)
    2015:	85 c0                	test   %eax,%eax
    2017:	74 0b                	je     2024 <rlc_close+0x2b4>
					{
						fsm_pkt_destroy(buffer->pkt);
    2019:	e8 fc ff ff ff       	call   201a <rlc_close+0x2aa>
						buffer->pkt = NULL;
    201e:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
					}
					if(buffer != NULL)
    2024:	85 ff                	test   %edi,%edi
    2026:	74 07                	je     202f <rlc_close+0x2bf>
					{
						fsm_mem_free(buffer);
    2028:	89 f8                	mov    %edi,%eax
    202a:	e8 fc ff ff ff       	call   202b <rlc_close+0x2bb>
						buffer = NULL;
					}					
					if(list_empty(&amIns->ctrlPduBuffer.list))
    202f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2032:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    2038:	75 ae                	jne    1fe8 <rlc_close+0x278>
    203a:	89 c6                	mov    %eax,%esi
    203c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:ctrl buffer is realeasing\n");
    203f:	c7 04 24 20 02 00 00 	movl   $0x220,(%esp)
    2046:	e8 fc ff ff ff       	call   2047 <rlc_close+0x2d7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    204b:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    2051:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2057:	39 c2                	cmp    %eax,%edx
    2059:	0f 84 29 01 00 00    	je     2188 <rlc_close+0x418>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    205f:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    2065:	8b 00                	mov    (%eax),%eax
    2067:	89 75 f0             	mov    %esi,-0x10(%ebp)
    206a:	89 d6                	mov    %edx,%esi
    206c:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    2072:	eb 22                	jmp    2096 <rlc_close+0x326>
    2074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    207e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    2084:	39 ce                	cmp    %ecx,%esi
    2086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    208c:	0f 84 b6 00 00 00    	je     2148 <rlc_close+0x3d8>
    2092:	89 fb                	mov    %edi,%ebx
    2094:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2096:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    209c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    209f:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    20a1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    20a3:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    20aa:	01 10 00 
	entry->prev = LIST_POISON2;
    20ad:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    20b4:	02 20 00 
    20b7:	85 c0                	test   %eax,%eax
    20b9:	74 0b                	je     20c6 <rlc_close+0x356>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    20bb:	e8 fc ff ff ff       	call   20bc <rlc_close+0x34c>
						amBuffer->pkt = NULL;
    20c0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    20c6:	85 db                	test   %ebx,%ebx
    20c8:	74 07                	je     20d1 <rlc_close+0x361>
					{
						fsm_mem_free(amBuffer);
    20ca:	89 d8                	mov    %ebx,%eax
    20cc:	e8 fc ff ff ff       	call   20cd <rlc_close+0x35d>
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
    20d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    20d4:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    20da:	75 9c                	jne    2078 <rlc_close+0x308>
    20dc:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
						break;
    20de:	31 db                	xor    %ebx,%ebx
						fsm_mem_free(amBuffer);
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
    20e0:	c7 04 24 7c 02 00 00 	movl   $0x27c,(%esp)
    20e7:	e8 fc ff ff ff       	call   20e8 <rlc_close+0x378>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] am instance  has released(rbid is%d)\n", amIns->rbId);
    20ec:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    20f0:	c7 04 24 d8 02 00 00 	movl   $0x2d8,(%esp)
    20f7:	89 44 24 04          	mov    %eax,0x4(%esp)
    20fb:	e8 fc ff ff ff       	call   20fc <rlc_close+0x38c>
			if(amIns != NULL)
    2100:	85 f6                	test   %esi,%esi
    2102:	74 07                	je     210b <rlc_close+0x39b>
			{
				fsm_mem_free(amIns);
    2104:	89 f0                	mov    %esi,%eax
    2106:	e8 fc ff ff ff       	call   2107 <rlc_close+0x397>
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
    210b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    210e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2111:	3b 90 f4 25 00 00    	cmp    0x25f4(%eax),%edx
    2117:	0f 84 e6 00 00 00    	je     2203 <rlc_close+0x493>
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
//AM
	if(!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    211d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    2120:	8b 81 04 23 00 00    	mov    0x2304(%ecx),%eax
    2126:	81 c1 04 23 00 00    	add    $0x2304,%ecx
    212c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
    212f:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    2135:	0f 84 d4 00 00 00    	je     220f <rlc_close+0x49f>
    213b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    213e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    2141:	e9 72 fc ff ff       	jmp    1db8 <rlc_close+0x48>
    2146:	66 90                	xchg   %ax,%ax
    2148:	8b 75 f0             	mov    -0x10(%ebp),%esi
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    214b:	89 fb                	mov    %edi,%ebx
    214d:	eb 9d                	jmp    20ec <rlc_close+0x37c>
    214f:	90                   	nop
    2150:	8b 75 ec             	mov    -0x14(%ebp),%esi
    2153:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    2156:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    215c:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    2162:	0f 85 4a fe ff ff    	jne    1fb2 <rlc_close+0x242>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
    2168:	c7 04 24 50 02 00 00 	movl   $0x250,(%esp)
    216f:	e8 fc ff ff ff       	call   2170 <rlc_close+0x400>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2174:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    217a:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2180:	39 c2                	cmp    %eax,%edx
    2182:	0f 85 d7 fe ff ff    	jne    205f <rlc_close+0x2ef>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
    2188:	c7 04 24 ac 02 00 00 	movl   $0x2ac,(%esp)
    218f:	e8 fc ff ff ff       	call   2190 <rlc_close+0x420>
    2194:	e9 53 ff ff ff       	jmp    20ec <rlc_close+0x37c>
    2199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    21a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    21a3:	89 fb                	mov    %edi,%ebx
    21a5:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    21a8:	8d 4e 44             	lea    0x44(%esi),%ecx
    21ab:	39 f9                	cmp    %edi,%ecx
    21ad:	0f 85 6f fd ff ff    	jne    1f22 <rlc_close+0x1b2>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
    21b3:	c7 04 24 c4 01 00 00 	movl   $0x1c4,(%esp)
    21ba:	e8 fc ff ff ff       	call   21bb <rlc_close+0x44b>
    21bf:	e9 dc fd ff ff       	jmp    1fa0 <rlc_close+0x230>
    21c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    21c8:	8b 75 f0             	mov    -0x10(%ebp),%esi
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    21cb:	89 fb                	mov    %edi,%ebx
    21cd:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    21d3:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    21d9:	39 c2                	cmp    %eax,%edx
    21db:	0f 85 a7 fc ff ff    	jne    1e88 <rlc_close+0x118>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
    21e1:	c7 04 24 64 01 00 00 	movl   $0x164,(%esp)
    21e8:	e8 fc ff ff ff       	call   21e9 <rlc_close+0x479>
    21ed:	e9 22 fd ff ff       	jmp    1f14 <rlc_close+0x1a4>
    21f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    21f8:	8b 75 f0             	mov    -0x10(%ebp),%esi
    21fb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    21fe:	e9 48 fe ff ff       	jmp    204b <rlc_close+0x2db>
				fsm_mem_free(amIns);
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
			{
				fsm_printf("[RLC][rlc_close] amInsList is empty\n");
    2203:	c7 04 24 10 03 00 00 	movl   $0x310,(%esp)
    220a:	e8 fc ff ff ff       	call   220b <rlc_close+0x49b>
				break;
			}
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    220f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2212:	05 c0 36 00 00       	add    $0x36c0,%eax
    2217:	89 45 e8             	mov    %eax,-0x18(%ebp)
    221a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    221d:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
    2223:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2226:	0f 84 13 01 00 00    	je     233f <rlc_close+0x5cf>
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    222c:	8b 02                	mov    (%edx),%eax
    222e:	81 ea c4 10 00 00    	sub    $0x10c4,%edx
    2234:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2237:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    223d:	89 55 ec             	mov    %edx,-0x14(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2240:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2243:	8b 91 c8 10 00 00    	mov    0x10c8(%ecx),%edx
		{
			list_del(&umRxIns->umRxList);
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    2249:	89 cf                	mov    %ecx,%edi
    224b:	83 c7 30             	add    $0x30,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    224e:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2251:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2253:	8b 59 30             	mov    0x30(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2256:	c7 81 c4 10 00 00 00 	movl   $0x100100,0x10c4(%ecx)
    225d:	01 10 00 
	entry->prev = LIST_POISON2;
    2260:	c7 81 c8 10 00 00 00 	movl   $0x200200,0x10c8(%ecx)
    2267:	02 20 00 
    226a:	39 df                	cmp    %ebx,%edi
    226c:	0f 84 f5 03 00 00    	je     2667 <rlc_close+0x8f7>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    2272:	8b 03                	mov    (%ebx),%eax
    2274:	83 eb 10             	sub    $0x10,%ebx
    2277:	8d 70 f0             	lea    -0x10(%eax),%esi
    227a:	eb 15                	jmp    2291 <rlc_close+0x521>
    227c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2280:	8b 46 10             	mov    0x10(%esi),%eax
    2283:	8d 4e 10             	lea    0x10(%esi),%ecx
    2286:	39 cf                	cmp    %ecx,%edi
    2288:	8d 50 f0             	lea    -0x10(%eax),%edx
    228b:	74 4a                	je     22d7 <rlc_close+0x567>
    228d:	89 f3                	mov    %esi,%ebx
    228f:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2291:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2294:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2297:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    2299:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    229b:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    22a2:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    22a9:	85 c0                	test   %eax,%eax
    22ab:	74 0b                	je     22b8 <rlc_close+0x548>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    22ad:	e8 fc ff ff ff       	call   22ae <rlc_close+0x53e>
						umBuffer->pkt = NULL;
    22b2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    22b8:	85 db                	test   %ebx,%ebx
    22ba:	74 07                	je     22c3 <rlc_close+0x553>
					{
						fsm_mem_free(umBuffer);
    22bc:	89 d8                	mov    %ebx,%eax
    22be:	e8 fc ff ff ff       	call   22bf <rlc_close+0x54f>
						umBuffer = NULL;
					}				
					
					if(list_empty(&umRxIns->umRecvBuffer.list))
    22c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22c6:	3b 78 30             	cmp    0x30(%eax),%edi
    22c9:	75 b5                	jne    2280 <rlc_close+0x510>
					{
						fsm_printf("[RLC][rlc_close] um recv:recv buffer is realeasing\n");
    22cb:	c7 04 24 38 03 00 00 	movl   $0x338,(%esp)
    22d2:	e8 fc ff ff ff       	call   22d3 <rlc_close+0x563>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umRxIns->rbId);
    22d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22da:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    22de:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    22e5:	89 44 24 04          	mov    %eax,0x4(%esp)
    22e9:	e8 fc ff ff ff       	call   22ea <rlc_close+0x57a>
			if(umRxIns != NULL)
    22ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    22f1:	85 c9                	test   %ecx,%ecx
    22f3:	74 08                	je     22fd <rlc_close+0x58d>
			{
				fsm_mem_free(umRxIns);
    22f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22f8:	e8 fc ff ff ff       	call   22f9 <rlc_close+0x589>
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
    22fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2300:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2303:	3b 90 c0 36 00 00    	cmp    0x36c0(%eax),%edx
    2309:	74 28                	je     2333 <rlc_close+0x5c3>
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    230b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    230e:	8b 81 c4 10 00 00    	mov    0x10c4(%ecx),%eax
    2314:	81 c1 c4 10 00 00    	add    $0x10c4,%ecx
    231a:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    231d:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    2323:	74 1a                	je     233f <rlc_close+0x5cf>
    2325:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2328:	89 55 ec             	mov    %edx,-0x14(%ebp)
    232b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    232e:	e9 0d ff ff ff       	jmp    2240 <rlc_close+0x4d0>
				fsm_mem_free(umRxIns);
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
			{
				fsm_printf("[RLC][rlc_close] umRxInsList is empty\n");
    2333:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
    233a:	e8 fc ff ff ff       	call   233b <rlc_close+0x5cb>
				break;
			}
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
    233f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2342:	05 f8 36 00 00       	add    $0x36f8,%eax
    2347:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    234a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    234d:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
    2353:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2356:	0f 84 02 01 00 00    	je     245e <rlc_close+0x6ee>
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    235c:	8b 02                	mov    (%edx),%eax
    235e:	83 ea 30             	sub    $0x30,%edx
    2361:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2364:	8d 50 d0             	lea    -0x30(%eax),%edx
    2367:	89 55 ec             	mov    %edx,-0x14(%ebp)
    236a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2370:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2373:	8b 51 34             	mov    0x34(%ecx),%edx
		{
			list_del(&umTxIns->umTxList);
			if(!list_empty(&umTxIns->umSduBuffer.list))
    2376:	89 cf                	mov    %ecx,%edi
    2378:	83 c7 18             	add    $0x18,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    237b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    237e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2380:	8b 59 18             	mov    0x18(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2383:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    238a:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    2391:	39 df                	cmp    %ebx,%edi
    2393:	0f 84 bd 02 00 00    	je     2656 <rlc_close+0x8e6>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    2399:	8b 03                	mov    (%ebx),%eax
    239b:	83 eb 10             	sub    $0x10,%ebx
    239e:	8d 70 f0             	lea    -0x10(%eax),%esi
    23a1:	eb 16                	jmp    23b9 <rlc_close+0x649>
    23a3:	90                   	nop
    23a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    23a8:	8b 46 10             	mov    0x10(%esi),%eax
    23ab:	8d 4e 10             	lea    0x10(%esi),%ecx
    23ae:	39 cf                	cmp    %ecx,%edi
    23b0:	8d 50 f0             	lea    -0x10(%eax),%edx
    23b3:	74 4a                	je     23ff <rlc_close+0x68f>
    23b5:	89 f3                	mov    %esi,%ebx
    23b7:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    23b9:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    23bc:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    23bf:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    23c1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    23c3:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    23ca:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    23d1:	85 c0                	test   %eax,%eax
    23d3:	74 0b                	je     23e0 <rlc_close+0x670>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    23d5:	e8 fc ff ff ff       	call   23d6 <rlc_close+0x666>
						umBuffer->pkt = NULL;
    23da:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    23e0:	85 db                	test   %ebx,%ebx
    23e2:	74 07                	je     23eb <rlc_close+0x67b>
					{
						fsm_mem_free(umBuffer);
    23e4:	89 d8                	mov    %ebx,%eax
    23e6:	e8 fc ff ff ff       	call   23e7 <rlc_close+0x677>
						umBuffer = NULL;
					}					
					
					if(list_empty(&umTxIns->umSduBuffer.list))
    23eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23ee:	3b 78 18             	cmp    0x18(%eax),%edi
    23f1:	75 b5                	jne    23a8 <rlc_close+0x638>
					{
						fsm_printf("[RLC][rlc_close] um tran:sdu buffer is realeasing\n");
    23f3:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
    23fa:	e8 fc ff ff ff       	call   23fb <rlc_close+0x68b>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umTxIns->rbid);
    23ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2402:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    2406:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    240d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2411:	e8 fc ff ff ff       	call   2412 <rlc_close+0x6a2>
			if(umTxIns != NULL)
    2416:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2419:	85 d2                	test   %edx,%edx
    241b:	74 08                	je     2425 <rlc_close+0x6b5>
			{
				fsm_mem_free(umTxIns);
    241d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2420:	e8 fc ff ff ff       	call   2421 <rlc_close+0x6b1>
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
    2425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2428:	8b 55 e8             	mov    -0x18(%ebp),%edx
    242b:	3b 90 f8 36 00 00    	cmp    0x36f8(%eax),%edx
    2431:	74 1f                	je     2452 <rlc_close+0x6e2>
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    2433:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2436:	8b 41 30             	mov    0x30(%ecx),%eax
    2439:	83 c1 30             	add    $0x30,%ecx
    243c:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    243f:	8d 50 d0             	lea    -0x30(%eax),%edx
    2442:	74 1a                	je     245e <rlc_close+0x6ee>
    2444:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2447:	89 55 ec             	mov    %edx,-0x14(%ebp)
    244a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    244d:	e9 1e ff ff ff       	jmp    2370 <rlc_close+0x600>
				fsm_mem_free(umTxIns);
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
			{
				fsm_printf("[RLC][rlc_close] umTxInsList is empty\n");
    2452:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2459:	e8 fc ff ff ff       	call   245a <rlc_close+0x6ea>
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
    245e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2461:	05 2c 37 00 00       	add    $0x372c,%eax
    2466:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    246c:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
    2472:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2475:	0f 84 1f 01 00 00    	je     259a <rlc_close+0x82a>
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    247b:	8b 02                	mov    (%edx),%eax
    247d:	83 ea 1c             	sub    $0x1c,%edx
    2480:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2483:	8d 50 e4             	lea    -0x1c(%eax),%edx
    2486:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2490:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2493:	8b 51 20             	mov    0x20(%ecx),%edx
		{
			list_del(&tmTxIns->tmTxList);
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    2496:	89 cf                	mov    %ecx,%edi
    2498:	83 c7 0c             	add    $0xc,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    249b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    249e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    24a0:	8b 59 0c             	mov    0xc(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24a3:	c7 41 1c 00 01 10 00 	movl   $0x100100,0x1c(%ecx)
	entry->prev = LIST_POISON2;
    24aa:	c7 41 20 00 02 20 00 	movl   $0x200200,0x20(%ecx)
    24b1:	39 df                	cmp    %ebx,%edi
    24b3:	74 56                	je     250b <rlc_close+0x79b>
			{
				list_for_each_entry_safe(buffer,tempBuffer, &tmTxIns->tmSduBuffer.list,list)
    24b5:	8b 03                	mov    (%ebx),%eax
    24b7:	83 eb 04             	sub    $0x4,%ebx
    24ba:	8d 70 fc             	lea    -0x4(%eax),%esi
    24bd:	eb 12                	jmp    24d1 <rlc_close+0x761>
    24bf:	90                   	nop
    24c0:	8b 46 04             	mov    0x4(%esi),%eax
    24c3:	8d 4e 04             	lea    0x4(%esi),%ecx
    24c6:	39 cf                	cmp    %ecx,%edi
    24c8:	8d 50 fc             	lea    -0x4(%eax),%edx
    24cb:	74 4a                	je     2517 <rlc_close+0x7a7>
    24cd:	89 f3                	mov    %esi,%ebx
    24cf:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    24d1:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    24d4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    24d7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    24d9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24db:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    24e2:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    24e9:	85 c0                	test   %eax,%eax
    24eb:	74 0b                	je     24f8 <rlc_close+0x788>
					{
						fsm_pkt_destroy(buffer->pkt);
    24ed:	e8 fc ff ff ff       	call   24ee <rlc_close+0x77e>
						buffer->pkt = NULL;
    24f2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(buffer != NULL)
    24f8:	85 db                	test   %ebx,%ebx
    24fa:	74 07                	je     2503 <rlc_close+0x793>
					{
						fsm_mem_free(buffer);
    24fc:	89 d8                	mov    %ebx,%eax
    24fe:	e8 fc ff ff ff       	call   24ff <rlc_close+0x78f>
						buffer = NULL;
					}					
					
					if(list_empty(&tmTxIns->tmSduBuffer.list))
    2503:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2506:	3b 78 0c             	cmp    0xc(%eax),%edi
    2509:	75 b5                	jne    24c0 <rlc_close+0x750>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
    250b:	c7 04 24 88 04 00 00 	movl   $0x488,(%esp)
    2512:	e8 fc ff ff ff       	call   2513 <rlc_close+0x7a3>
			}
			if( tmTxIns->pbCh == 0)
    2517:	8b 55 f0             	mov    -0x10(%ebp),%edx
    251a:	0f b6 42 04          	movzbl 0x4(%edx),%eax
    251e:	84 c0                	test   %al,%al
    2520:	74 4e                	je     2570 <rlc_close+0x800>
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
			}
			else if(tmTxIns->pbCh == 1)
    2522:	3c 01                	cmp    $0x1,%al
    2524:	74 5a                	je     2580 <rlc_close+0x810>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    2526:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    252d:	e8 fc ff ff ff       	call   252e <rlc_close+0x7be>
			}
			if(tmTxIns != NULL)
    2532:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2535:	85 c0                	test   %eax,%eax
    2537:	74 08                	je     2541 <rlc_close+0x7d1>
			{
				fsm_mem_free(tmTxIns);
    2539:	8b 45 f0             	mov    -0x10(%ebp),%eax
    253c:	e8 fc ff ff ff       	call   253d <rlc_close+0x7cd>
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
    2541:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2544:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2547:	3b 90 2c 37 00 00    	cmp    0x372c(%eax),%edx
    254d:	74 3f                	je     258e <rlc_close+0x81e>
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    254f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2552:	8b 41 1c             	mov    0x1c(%ecx),%eax
    2555:	83 c1 1c             	add    $0x1c,%ecx
    2558:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    255b:	8d 50 e4             	lea    -0x1c(%eax),%edx
    255e:	74 3a                	je     259a <rlc_close+0x82a>
    2560:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2563:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2566:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2569:	e9 22 ff ff ff       	jmp    2490 <rlc_close+0x720>
    256e:	66 90                	xchg   %ax,%ax
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
			}
			if( tmTxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
    2570:	c7 04 24 b4 04 00 00 	movl   $0x4b4,(%esp)
    2577:	e8 fc ff ff ff       	call   2578 <rlc_close+0x808>
    257c:	eb b4                	jmp    2532 <rlc_close+0x7c2>
    257e:	66 90                	xchg   %ax,%ax
			}
			else if(tmTxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2580:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    2587:	e8 fc ff ff ff       	call   2588 <rlc_close+0x818>
    258c:	eb a4                	jmp    2532 <rlc_close+0x7c2>
				fsm_mem_free(tmTxIns);
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
			{
				fsm_printf("[RLC][rlc_close] tmTxInsList is empty\n");
    258e:	c7 04 24 28 05 00 00 	movl   $0x528,(%esp)
    2595:	e8 fc ff ff ff       	call   2596 <rlc_close+0x826>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    259a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
    259d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    25a0:	8b 98 08 37 00 00    	mov    0x3708(%eax),%ebx
    25a6:	81 c7 08 37 00 00    	add    $0x3708,%edi
    25ac:	39 df                	cmp    %ebx,%edi
    25ae:	0f 84 8e 00 00 00    	je     2642 <rlc_close+0x8d2>
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25b4:	8b 03                	mov    (%ebx),%eax
    25b6:	83 eb 08             	sub    $0x8,%ebx
    25b9:	8d 70 f8             	lea    -0x8(%eax),%esi
    25bc:	eb 39                	jmp    25f7 <rlc_close+0x887>
    25be:	66 90                	xchg   %ax,%ax
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
			}
			else if(tmRxIns->pbCh == 1)
    25c0:	3c 01                	cmp    $0x1,%al
    25c2:	74 64                	je     2628 <rlc_close+0x8b8>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    25c4:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    25cb:	e8 fc ff ff ff       	call   25cc <rlc_close+0x85c>
			}
			if(tmRxIns != NULL)
    25d0:	85 db                	test   %ebx,%ebx
    25d2:	74 07                	je     25db <rlc_close+0x86b>
			{
				fsm_mem_free(tmRxIns);
    25d4:	89 d8                	mov    %ebx,%eax
    25d6:	e8 fc ff ff ff       	call   25d7 <rlc_close+0x867>
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
    25db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25de:	3b b8 08 37 00 00    	cmp    0x3708(%eax),%edi
    25e4:	74 50                	je     2636 <rlc_close+0x8c6>
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25e6:	8b 46 08             	mov    0x8(%esi),%eax
    25e9:	8d 4e 08             	lea    0x8(%esi),%ecx
    25ec:	39 cf                	cmp    %ecx,%edi
    25ee:	8d 50 f8             	lea    -0x8(%eax),%edx
    25f1:	74 4f                	je     2642 <rlc_close+0x8d2>
    25f3:	89 f3                	mov    %esi,%ebx
    25f5:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    25f7:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    25fa:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    25fd:	89 02                	mov    %eax,(%edx)
		{
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
    25ff:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2603:	c7 43 08 00 01 10 00 	movl   $0x100100,0x8(%ebx)
	entry->prev = LIST_POISON2;
    260a:	c7 43 0c 00 02 20 00 	movl   $0x200200,0xc(%ebx)
    2611:	84 c0                	test   %al,%al
    2613:	75 ab                	jne    25c0 <rlc_close+0x850>
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
    2615:	c7 04 24 50 05 00 00 	movl   $0x550,(%esp)
    261c:	e8 fc ff ff ff       	call   261d <rlc_close+0x8ad>
    2621:	eb ad                	jmp    25d0 <rlc_close+0x860>
    2623:	90                   	nop
    2624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			else if(tmRxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2628:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    262f:	e8 fc ff ff ff       	call   2630 <rlc_close+0x8c0>
    2634:	eb 9a                	jmp    25d0 <rlc_close+0x860>
				fsm_mem_free(tmRxIns);
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
			{
				fsm_printf("[RLC][rlc_close] tmRxInsList is empty\n");
    2636:	c7 04 24 7c 05 00 00 	movl   $0x57c,(%esp)
    263d:	e8 fc ff ff ff       	call   263e <rlc_close+0x8ce>
				break;
			}
		}
	}
	fsm_printf("[RLC][rlc_close] rlc has closed \n");
    2642:	c7 04 24 a4 05 00 00 	movl   $0x5a4,(%esp)
    2649:	e8 fc ff ff ff       	call   264a <rlc_close+0x8da>
	FOUT;
}
    264e:	83 c4 20             	add    $0x20,%esp
    2651:	5b                   	pop    %ebx
    2652:	5e                   	pop    %esi
    2653:	5f                   	pop    %edi
    2654:	5d                   	pop    %ebp
    2655:	c3                   	ret    
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
    2656:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
    265d:	e8 fc ff ff ff       	call   265e <rlc_close+0x8ee>
    2662:	e9 98 fd ff ff       	jmp    23ff <rlc_close+0x68f>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
    2667:	c7 04 24 6c 03 00 00 	movl   $0x36c,(%esp)
    266e:	e8 fc ff ff ff       	call   266f <rlc_close+0x8ff>
    2673:	e9 5f fc ff ff       	jmp    22d7 <rlc_close+0x567>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
    2678:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
    267f:	e8 fc ff ff ff       	call   2680 <rlc_close+0x910>
    2684:	e9 eb f7 ff ff       	jmp    1e74 <rlc_close+0x104>
    2689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00002690 <StartWaitingForRaResponse>:
->output:
->Special:
*******************************
*/
static void StartWaitingForRaResponse()
{
    2690:	55                   	push   %ebp
    2691:	89 e5                	mov    %esp,%ebp
    2693:	53                   	push   %ebx
    2694:	83 ec 04             	sub    $0x4,%esp
    2697:	e8 fc ff ff ff       	call   2698 <StartWaitingForRaResponse+0x8>
	FIN(StartWaitingForRaResponse());
	SV_PTR_GET(rlc_mac_sv);
    269c:	e8 fc ff ff ff       	call   269d <StartWaitingForRaResponse+0xd>
    26a1:	89 c3                	mov    %eax,%ebx
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
    26a3:	8b 80 cc 00 00 00    	mov    0xcc(%eax),%eax
    26a9:	89 83 90 01 00 00    	mov    %eax,0x190(%ebx)
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
    26af:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)
    26b6:	e8 fc ff ff ff       	call   26b7 <StartWaitingForRaResponse+0x27>
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26bb:	ba 18 00 00 00       	mov    $0x18,%edx
    26c0:	6b 83 90 01 00 00 64 	imul   $0x64,0x190(%ebx),%eax
    26c7:	e8 fc ff ff ff       	call   26c8 <StartWaitingForRaResponse+0x38>
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
    26cc:	c6 83 98 01 00 00 01 	movb   $0x1,0x198(%ebx)
	SV_PTR_GET(rlc_mac_sv);
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26d3:	89 83 94 01 00 00    	mov    %eax,0x194(%ebx)
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
	FOUT;
}
    26d9:	83 c4 04             	add    $0x4,%esp
    26dc:	5b                   	pop    %ebx
    26dd:	5d                   	pop    %ebp
    26de:	c3                   	ret    
    26df:	90                   	nop

000026e0 <send_SR>:
->output:
->Special:
*******************************
*/
static void send_SR()
{
    26e0:	55                   	push   %ebp
    26e1:	89 e5                	mov    %esp,%ebp
    26e3:	53                   	push   %ebx
    26e4:	83 ec 04             	sub    $0x4,%esp
    26e7:	e8 fc ff ff ff       	call   26e8 <send_SR+0x8>
	FIN(send_SR());
	SV_PTR_GET(rlc_mac_sv);
    26ec:	e8 fc ff ff ff       	call   26ed <send_SR+0xd>
    26f1:	89 c3                	mov    %eax,%ebx
	fsm_printf("[UE MAC]send_SR\n");
    26f3:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    26fa:	e8 fc ff ff ff       	call   26fb <send_SR+0x1b>
	fsm_schedule_self(0,SR_Fail);//SR
    26ff:	ba 07 00 00 00       	mov    $0x7,%edx
    2704:	31 c0                	xor    %eax,%eax
    2706:	e8 fc ff ff ff       	call   2707 <send_SR+0x27>
	SV(ratype.ra_type)=2;
    270b:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    2712:	00 00 00 
	FOUT;
}
    2715:	83 c4 04             	add    $0x4,%esp
    2718:	5b                   	pop    %ebx
    2719:	5d                   	pop    %ebp
    271a:	c3                   	ret    
    271b:	90                   	nop
    271c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00002720 <rlc_init_enter>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void rlc_init_enter(void)
{
    2720:	55                   	push   %ebp
    2721:	89 e5                	mov    %esp,%ebp
    2723:	57                   	push   %edi
    2724:	56                   	push   %esi
    2725:	53                   	push   %ebx
    2726:	83 ec 04             	sub    $0x4,%esp
    2729:	e8 fc ff ff ff       	call   272a <rlc_init_enter+0xa>
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
    272e:	e8 fc ff ff ff       	call   272f <rlc_init_enter+0xf>
    2733:	89 c3                	mov    %eax,%ebx
	if(RLC_OPEN)
    2735:	e8 fc ff ff ff       	call   2736 <rlc_init_enter+0x16>
    273a:	83 f8 05             	cmp    $0x5,%eax
    273d:	74 09                	je     2748 <rlc_init_enter+0x28>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    273f:	83 c4 04             	add    $0x4,%esp
    2742:	5b                   	pop    %ebx
    2743:	5e                   	pop    %esi
    2744:	5f                   	pop    %edi
    2745:	5d                   	pop    %ebp
    2746:	c3                   	ret    
    2747:	90                   	nop
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
    2748:	e8 fc ff ff ff       	call   2749 <rlc_init_enter+0x29>
    274d:	85 c0                	test   %eax,%eax
    274f:	75 ee                	jne    273f <rlc_init_enter+0x1f>
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
    2751:	8d 83 f4 25 00 00    	lea    0x25f4(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2757:	89 83 f4 25 00 00    	mov    %eax,0x25f4(%ebx)
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
    275d:	8d b3 08 37 00 00    	lea    0x3708(%ebx),%esi
	list->prev = list;
    2763:	89 83 f8 25 00 00    	mov    %eax,0x25f8(%ebx)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
    2769:	8d 83 c0 36 00 00    	lea    0x36c0(%ebx),%eax
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
		INIT_LIST_HEAD(&SV(vTm_tx_ins).tmTxList);
    276f:	8d bb 2c 37 00 00    	lea    0x372c(%ebx),%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2775:	89 83 c0 36 00 00    	mov    %eax,0x36c0(%ebx)
	list->prev = list;
    277b:	89 83 c4 36 00 00    	mov    %eax,0x36c4(%ebx)
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
    2781:	8d 83 f8 36 00 00    	lea    0x36f8(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2787:	89 83 f8 36 00 00    	mov    %eax,0x36f8(%ebx)
	list->prev = list;
    278d:	89 83 fc 36 00 00    	mov    %eax,0x36fc(%ebx)
		SV(countDropPacket)=0;
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2793:	31 c0                	xor    %eax,%eax
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
    2795:	c6 83 24 02 00 00 00 	movb   $0x0,0x224(%ebx)
		SV(packetType) = -1;
    279c:	c7 83 20 02 00 00 ff 	movl   $0xffffffff,0x220(%ebx)
    27a3:	ff ff ff 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27a6:	89 b3 08 37 00 00    	mov    %esi,0x3708(%ebx)
	list->prev = list;
    27ac:	89 b3 0c 37 00 00    	mov    %esi,0x370c(%ebx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27b2:	89 bb 2c 37 00 00    	mov    %edi,0x372c(%ebx)
	list->prev = list;
    27b8:	89 bb 30 37 00 00    	mov    %edi,0x3730(%ebx)
		//mallocnum=0;
		//freenum=0;
	//	SV(pduLft).SN_Left = -1;
	//	SV(pduLft).sduLeft = NULL;
		//for test
		SV(countRecvFromUpper)=0;
    27be:	c7 83 8c 5a 00 00 00 	movl   $0x0,0x5a8c(%ebx)
    27c5:	00 00 00 
		SV(countSendToUpper)=0;
    27c8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    27cf:	00 00 00 
		SV(countRecvFromLower)=0;
    27d2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    27d9:	00 00 00 
		SV(countSentToLower)=0;
    27dc:	c7 83 98 5a 00 00 00 	movl   $0x0,0x5a98(%ebx)
    27e3:	00 00 00 
		SV(countDropPacket)=0;
    27e6:	c7 83 9c 5a 00 00 00 	movl   $0x0,0x5a9c(%ebx)
    27ed:	00 00 00 
		SV(countSendCtrlPdu)=0;
    27f0:	c7 83 a0 5a 00 00 00 	movl   $0x0,0x5aa0(%ebx)
    27f7:	00 00 00 
		SV(countRecvCtrlPdu)=0;
    27fa:	c7 83 a4 5a 00 00 00 	movl   $0x0,0x5aa4(%ebx)
    2801:	00 00 00 
		SV(max_queue_num)=0;
    2804:	c7 83 a8 5a 00 00 00 	movl   $0x0,0x5aa8(%ebx)
    280b:	00 00 00 
    280e:	66 90                	xchg   %ax,%ax
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2810:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
    2817:	83 c0 01             	add    $0x1,%eax
    281a:	83 f8 32             	cmp    $0x32,%eax
    281d:	75 f1                	jne    2810 <rlc_init_enter+0xf0>
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    281f:	c7 83 e8 02 00 00 ff 	movl   $0xffffffff,0x2e8(%ebx)
    2826:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2829:	b0 10                	mov    $0x10,%al
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    282b:	c7 83 cc 02 00 00 ff 	movl   $0xffffffff,0x2cc(%ebx)
    2832:	ff ff ff 
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
    2835:	c7 83 c8 02 00 00 ff 	movl   $0xffffffff,0x2c8(%ebx)
    283c:	ff ff ff 
    283f:	c7 83 c4 02 00 00 ff 	movl   $0xffffffff,0x2c4(%ebx)
    2846:	ff ff ff 
    2849:	c7 83 c0 02 00 00 ff 	movl   $0xffffffff,0x2c0(%ebx)
    2850:	ff ff ff 
    2853:	c7 83 bc 02 00 00 ff 	movl   $0xffffffff,0x2bc(%ebx)
    285a:	ff ff ff 
    285d:	c7 83 b8 02 00 00 ff 	movl   $0xffffffff,0x2b8(%ebx)
    2864:	ff ff ff 
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
    2867:	c7 83 b4 02 00 00 ff 	movl   $0xffffffff,0x2b4(%ebx)
    286e:	ff ff ff 
    2871:	c7 83 b0 02 00 00 ff 	movl   $0xffffffff,0x2b0(%ebx)
    2878:	ff ff ff 
    287b:	c7 83 ac 02 00 00 ff 	movl   $0xffffffff,0x2ac(%ebx)
    2882:	ff ff ff 
    2885:	c7 83 54 02 00 00 ff 	movl   $0xffffffff,0x254(%ebx)
    288c:	ff ff ff 
    288f:	c7 83 28 02 00 00 ff 	movl   $0xffffffff,0x228(%ebx)
    2896:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2899:	e8 fc ff ff ff       	call   289a <rlc_init_enter+0x17a>
		tmRxIns->pbCh = 1;            //PCCH
    289e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28a2:	8d 48 08             	lea    0x8(%eax),%ecx
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 1;            //PCCH
		tmRxIns->rnti = 0;
    28a5:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28aa:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;
    28ae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28b2:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28b8:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28be:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28c1:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    28c4:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");
    28c6:	c7 04 24 fc 05 00 00 	movl   $0x5fc,(%esp)
    28cd:	e8 fc ff ff ff       	call   28ce <rlc_init_enter+0x1ae>

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    28d2:	b8 10 00 00 00       	mov    $0x10,%eax
    28d7:	e8 fc ff ff ff       	call   28d8 <rlc_init_enter+0x1b8>
		tmRxIns->pbCh = 2;            //BCCH
    28dc:	c6 40 04 02          	movb   $0x2,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //BCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28e0:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 2;            //BCCH
		tmRxIns->rnti = 0;
    28e3:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28e8:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //BCCH
    28ec:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28f0:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28f6:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28fc:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28ff:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2902:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");
    2904:	c7 04 24 30 06 00 00 	movl   $0x630,(%esp)
    290b:	e8 fc ff ff ff       	call   290c <rlc_init_enter+0x1ec>

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2910:	b8 10 00 00 00       	mov    $0x10,%eax
    2915:	e8 fc ff ff ff       	call   2916 <rlc_init_enter+0x1f6>
		tmRxIns->pbCh = 0;            //CCCH
    291a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //CCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    291e:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 0;            //CCCH
		tmRxIns->rnti = 0;
    2921:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    2926:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //CCCH
    292a:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    292e:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2934:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    293a:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    293d:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2940:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");
    2942:	c7 04 24 64 06 00 00 	movl   $0x664,(%esp)
    2949:	e8 fc ff ff ff       	call   294a <rlc_init_enter+0x22a>

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
    294e:	b8 24 00 00 00       	mov    $0x24,%eax
    2953:	e8 fc ff ff ff       	call   2954 <rlc_init_enter+0x234>
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
    2958:	8d 50 0c             	lea    0xc(%eax),%edx
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
    295b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
		tmTxIns->tmSduBufferSize = 0;
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
    295f:	8d 48 1c             	lea    0x1c(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
    2962:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmTxIns->rbId = 0;
    2967:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmTxIns->lcId = 0;       //CCCH
    296b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    296f:	89 50 0c             	mov    %edx,0xc(%eax)
	list->prev = list;
    2972:	89 50 10             	mov    %edx,0x10(%eax)
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
    2975:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		tmTxIns->tmSduBufferSize = 0;
    297c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    2983:	8b 93 30 37 00 00    	mov    0x3730(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2989:	89 8b 30 37 00 00    	mov    %ecx,0x3730(%ebx)
	new->next = next;
    298f:	89 78 1c             	mov    %edi,0x1c(%eax)
	new->prev = prev;
    2992:	89 50 20             	mov    %edx,0x20(%eax)
	prev->next = new;
    2995:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH tran instance has bulided\n");
    2997:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    299e:	e8 fc ff ff ff       	call   299f <rlc_init_enter+0x27f>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    29a3:	83 c4 04             	add    $0x4,%esp
    29a6:	5b                   	pop    %ebx
    29a7:	5e                   	pop    %esi
    29a8:	5f                   	pop    %edi
    29a9:	5d                   	pop    %ebp
    29aa:	c3                   	ret    
    29ab:	90                   	nop
    29ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000029b0 <ue_mac_sv_close>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_close()
{
    29b0:	55                   	push   %ebp
    29b1:	89 e5                	mov    %esp,%ebp
    29b3:	53                   	push   %ebx
    29b4:	e8 fc ff ff ff       	call   29b5 <ue_mac_sv_close+0x5>
	FIN(ue_mac_sv_close());
	SV_PTR_GET(rlc_mac_sv);
    29b9:	e8 fc ff ff ff       	call   29ba <ue_mac_sv_close+0xa>
    29be:	89 c3                	mov    %eax,%ebx
	if(SV(m_temp_cr) != NULL)
    29c0:	8b 80 a0 01 00 00    	mov    0x1a0(%eax),%eax
    29c6:	85 c0                	test   %eax,%eax
    29c8:	74 0f                	je     29d9 <ue_mac_sv_close+0x29>
	{
		fsm_mem_free(SV(m_temp_cr));
    29ca:	e8 fc ff ff ff       	call   29cb <ue_mac_sv_close+0x1b>
		SV(m_temp_cr) = NULL;
    29cf:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    29d6:	00 00 00 
	}
	Free_Uemac_Scheduler_Resource();
    29d9:	e8 fc ff ff ff       	call   29da <ue_mac_sv_close+0x2a>
	if(SV(msg3_buf_ptr)!=NULL)
    29de:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    29e4:	85 c0                	test   %eax,%eax
    29e6:	74 0f                	je     29f7 <ue_mac_sv_close+0x47>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));
    29e8:	e8 fc ff ff ff       	call   29e9 <ue_mac_sv_close+0x39>
		SV(msg3_buf_ptr)=NULL;
    29ed:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    29f4:	00 00 00 
	}
	FOUT;
}
    29f7:	5b                   	pop    %ebx
    29f8:	5d                   	pop    %ebp
    29f9:	c3                   	ret    
    29fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00002a00 <SendRaPreamble>:
->output:
->Special:
*******************************
*/
static void SendRaPreamble(RACH_ConfigDedicated *randomaccess_info)
{
    2a00:	55                   	push   %ebp
    2a01:	89 e5                	mov    %esp,%ebp
    2a03:	53                   	push   %ebx
    2a04:	83 ec 04             	sub    $0x4,%esp
    2a07:	e8 fc ff ff ff       	call   2a08 <SendRaPreamble+0x8>
    2a0c:	89 c3                	mov    %eax,%ebx
	FIN(SendRaPreamble());
	//modified by HQ
	fsm_printf("[UEMAC][sendrapreamble]run here,start send RAP \n");//testing code
    2a0e:	c7 04 24 d4 06 00 00 	movl   $0x6d4,(%esp)
    2a15:	e8 fc ff ff ff       	call   2a16 <SendRaPreamble+0x16>
	//fsm_octets_print(randomaccess_info,sizeof(RACH_ConfigDedicated));// for test
	fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_Preamble_Indicate, (void*)randomaccess_info , sizeof(randomaccess_info));
    2a1a:	89 d9                	mov    %ebx,%ecx
    2a1c:	ba 25 00 00 00       	mov    $0x25,%edx
    2a21:	b8 03 00 00 00       	mov    $0x3,%eax
    2a26:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    2a2d:	e8 fc ff ff ff       	call   2a2e <SendRaPreamble+0x2e>
	//send the information of random access to PHYadapter
	fsm_mem_free(randomaccess_info);//20140722 modified by lhl IOCTL
    2a32:	89 d8                	mov    %ebx,%eax
    2a34:	e8 fc ff ff ff       	call   2a35 <SendRaPreamble+0x35>
	FOUT;
 }
    2a39:	83 c4 04             	add    $0x4,%esp
    2a3c:	5b                   	pop    %ebx
    2a3d:	5d                   	pop    %ebp
    2a3e:	c3                   	ret    
    2a3f:	90                   	nop

00002a40 <ioctrl_handler>:
->output:
->Special:
*******************************
*/
static void ioctrl_handler()
{
    2a40:	55                   	push   %ebp
    2a41:	89 e5                	mov    %esp,%ebp
    2a43:	83 ec 18             	sub    $0x18,%esp
    2a46:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    2a49:	89 75 f8             	mov    %esi,-0x8(%ebp)
    2a4c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    2a4f:	e8 fc ff ff ff       	call   2a50 <ioctrl_handler+0x10>
	UEPHY_TO_MAC_ULgrant *tempulgrant;
	u32 rar_failed_times;//201501
	u32 contention_failed_times;//201501
	FIN(ioctrl_handler());

	SV_PTR_GET(rlc_mac_sv);
    2a54:	e8 fc ff ff ff       	call   2a55 <ioctrl_handler+0x15>
    2a59:	89 c6                	mov    %eax,%esi

	int cmd_value=fsm_ev_ioctrl_cmd();
    2a5b:	e8 fc ff ff ff       	call   2a5c <ioctrl_handler+0x1c>

	switch(cmd_value)
    2a60:	3d 87 00 00 00       	cmp    $0x87,%eax
    2a65:	76 21                	jbe    2a88 <ioctrl_handler+0x48>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
			
			
			break;
		default:
			fsm_printf("[RLC_MAC] unidentified ioctrl command!\n");
    2a67:	c7 04 24 c8 0a 00 00 	movl   $0xac8,(%esp)
    2a6e:	e8 fc ff ff ff       	call   2a6f <ioctrl_handler+0x2f>
    2a73:	90                   	nop
    2a74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		
/**/
	}	
	FOUT;
}
    2a78:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2a7b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2a7e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2a81:	89 ec                	mov    %ebp,%esp
    2a83:	5d                   	pop    %ebp
    2a84:	c3                   	ret    
    2a85:	8d 76 00             	lea    0x0(%esi),%esi

	SV_PTR_GET(rlc_mac_sv);

	int cmd_value=fsm_ev_ioctrl_cmd();

	switch(cmd_value)
    2a88:	ff 24 85 e0 00 00 00 	jmp    *0xe0(,%eax,4)
    2a8f:	90                   	nop
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
		break;
		case TEST_RECV_SYS :  
			fsm_printf("[MAC][RECVSYS]\n");
    2a90:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
    2a97:	e8 fc ff ff ff       	call   2a98 <ioctrl_handler+0x58>
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
    2a9c:	31 c9                	xor    %ecx,%ecx
    2a9e:	ba 26 00 00 00       	mov    $0x26,%edx
    2aa3:	b8 03 00 00 00       	mov    $0x3,%eax
    2aa8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2aaf:	e8 fc ff ff ff       	call   2ab0 <ioctrl_handler+0x70>
		//ioctrlRNTI
		break;
    2ab4:	eb c2                	jmp    2a78 <ioctrl_handler+0x38>
    2ab6:	66 90                	xchg   %ax,%ax
			test_print_pkt_num();
		break;

		/***************** RLC ioctl_handler ******************/
		case CRLC_CONFIG_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
    2ab8:	c7 04 24 a0 09 00 00 	movl   $0x9a0,(%esp)
    2abf:	e8 fc ff ff ff       	call   2ac0 <ioctrl_handler+0x80>
			PCRLC_CONFIG_REQ();
    2ac4:	e8 fc ff ff ff       	call   2ac5 <ioctrl_handler+0x85>
			FOUT;
    2ac9:	eb ad                	jmp    2a78 <ioctrl_handler+0x38>
    2acb:	90                   	nop
    2acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
		//ioctrlRNTI
		break;
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
    2ad0:	c7 04 24 d4 00 00 00 	movl   $0xd4,(%esp)
    2ad7:	e8 fc ff ff ff       	call   2ad8 <ioctrl_handler+0x98>
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
    2adc:	31 c9                	xor    %ecx,%ecx
    2ade:	ba 46 00 00 00       	mov    $0x46,%edx
    2ae3:	b8 03 00 00 00       	mov    $0x3,%eax
    2ae8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2aef:	e8 fc ff ff ff       	call   2af0 <ioctrl_handler+0xb0>
		break;
    2af4:	eb 82                	jmp    2a78 <ioctrl_handler+0x38>
    2af6:	66 90                	xchg   %ax,%ax
			SV(RetxBSRTimer.time_value)	= SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer);
			SV(RetxBSRTimer.timer_sign) = fsm_schedule_self(SV(RetxBSRTimer.time_value), RexBSRTimer_Expire);
			SV(RetxBSRTimer.flag)= true;*/ 	//noted in 20151228
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
    2af8:	ba 0b 00 00 00       	mov    $0xb,%edx
    2afd:	b8 64 00 00 00       	mov    $0x64,%eax
    2b02:	e8 fc ff ff ff       	call   2b03 <ioctrl_handler+0xc3>
		break;
    2b07:	e9 6c ff ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
*/
static void handle_HARQ_feedback()
{
	void *tmpdata_ptr;	
	FIN(handle_HARQ_feedback());
	SV_PTR_GET(rlc_mac_sv);
    2b10:	e8 fc ff ff ff       	call   2b11 <ioctrl_handler+0xd1>
    2b15:	89 c6                	mov    %eax,%esi
	HARQ_statu_parameters ACK_statu={0,true,0};
	tmpdata_ptr = fsm_data_get();
    2b17:	e8 fc ff ff ff       	call   2b18 <ioctrl_handler+0xd8>
	if( ((struct HARQ_feedback*)tmpdata_ptr)->HARQ_FEEDBACK == true )
    2b1c:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
    2b20:	74 31                	je     2b53 <ioctrl_handler+0x113>
	{
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].avaiable_flag = true;
    2b22:	8b 10                	mov    (%eax),%edx
    2b24:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b27:	c6 44 96 38 01       	movb   $0x1,0x38(%esi,%edx,4)
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].HARQ_buffer_pointer = NULL;
    2b2c:	8b 10                	mov    (%eax),%edx
    2b2e:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b31:	c7 44 96 44 00 00 00 	movl   $0x0,0x44(%esi,%edx,4)
    2b38:	00 
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].statu=ACK_statu;
    2b39:	8b 10                	mov    (%eax),%edx
    2b3b:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b3e:	8d 4c 96 30          	lea    0x30(%esi,%edx,4),%ecx
    2b42:	66 c7 41 0c 00 00    	movw   $0x0,0xc(%ecx)
    2b48:	c6 41 0e 01          	movb   $0x1,0xe(%ecx)
    2b4c:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
    2b53:	e8 fc ff ff ff       	call   2b54 <ioctrl_handler+0x114>
		break;
    2b58:	e9 1b ff ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b5d:	8d 76 00             	lea    0x0(%esi),%esi
*/
static void ue_mac_lc_release()
{
	void *tmpdata_ptr;
	FIN(ue_mac_lc_release());
	tmpdata_ptr = fsm_data_get();
    2b60:	e8 fc ff ff ff       	call   2b61 <ioctrl_handler+0x121>
    2b65:	89 c6                	mov    %eax,%esi
	Delete_LogicalChannel_ConfigInfo(*((unsigned char *)tmpdata_ptr));
    2b67:	0f b6 00             	movzbl (%eax),%eax
    2b6a:	e8 fc ff ff ff       	call   2b6b <ioctrl_handler+0x12b>
	fsm_data_destroy(tmpdata_ptr);
    2b6f:	89 f0                	mov    %esi,%eax
    2b71:	e8 fc ff ff ff       	call   2b72 <ioctrl_handler+0x132>
    2b76:	e9 fd fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b7b:	90                   	nop
    2b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
			ue_mac_rach_config();
		break;
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
    2b80:	c7 04 24 c0 07 00 00 	movl   $0x7c0,(%esp)
    2b87:	e8 fc ff ff ff       	call   2b88 <ioctrl_handler+0x148>
*/
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    2b8c:	b8 15 00 00 00       	mov    $0x15,%eax
    2b91:	e8 fc ff ff ff       	call   2b92 <ioctrl_handler+0x152>
    2b96:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2b98:	e8 fc ff ff ff       	call   2b99 <ioctrl_handler+0x159>
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2b9d:	b9 15 00 00 00       	mov    $0x15,%ecx
    2ba2:	89 c2                	mov    %eax,%edx
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	tmpdata_ptr = fsm_data_get();	
    2ba4:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2ba6:	89 f0                	mov    %esi,%eax
    2ba8:	e8 fc ff ff ff       	call   2ba9 <ioctrl_handler+0x169>
	fsm_data_destroy(tmpdata_ptr);//
    2bad:	89 f8                	mov    %edi,%eax
    2baf:	e8 fc ff ff ff       	call   2bb0 <ioctrl_handler+0x170>
	Init_LogicalChannel_ConfigInfo(lc_configinfo);//lc_configinfo 20140506
    2bb4:	89 f0                	mov    %esi,%eax
    2bb6:	e8 fc ff ff ff       	call   2bb7 <ioctrl_handler+0x177>
	//fsm_printf("[UEMAC][logch_config]LCID:%d, ",lc_configinfo->logicalChannelIdentity);
	//fsm_printf("[UEMAC][logch_config]RRC TO MAC:LCGROUP:%d\n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup);
	//fsm_printf("[UEMAC][logch_config]prioritisedBitRate: %d \n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate);
	fsm_mem_free(lc_configinfo);	
    2bbb:	89 f0                	mov    %esi,%eax
    2bbd:	e8 fc ff ff ff       	call   2bbe <ioctrl_handler+0x17e>
    2bc2:	e9 b1 fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2bc7:	90                   	nop
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
			ue_mac_PCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_SPS  : 
			fsm_printf("[UEMAC][RRCTOMAC_spsconfig]rrctomac_spsconfig\n");
    2bc8:	c7 04 24 58 08 00 00 	movl   $0x858,(%esp)
    2bcf:	e8 fc ff ff ff       	call   2bd0 <ioctrl_handler+0x190>
*/
static void ue_mac_SPS_Config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_SPS_Config());
	SV_PTR_GET(rlc_mac_sv);
    2bd4:	e8 fc ff ff ff       	call   2bd5 <ioctrl_handler+0x195>
    2bd9:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();
    2bdb:	e8 fc ff ff ff       	call   2bdc <ioctrl_handler+0x19c>
	SV(systemconfigInfo.SPSConfigInfo)= *((struct SPS_Config*)tmpdata_ptr); //ioctrl //
    2be0:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    2be6:	b9 11 00 00 00       	mov    $0x11,%ecx
    2beb:	89 c6                	mov    %eax,%esi
    2bed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2bef:	e8 fc ff ff ff       	call   2bf0 <ioctrl_handler+0x1b0>
    2bf4:	e9 7f fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		break;
		case IOCCMD_PDCCHtoMAC_ULGRANT : //PHYPDCCHUL_grantDCI,MAC
		//MACul_grant 
		//MSG4
			
			tempdata_ptr = fsm_data_get();
    2c00:	e8 fc ff ff ff       	call   2c01 <ioctrl_handler+0x1c1>
    2c05:	89 c7                	mov    %eax,%edi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
    2c07:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    2c0b:	66 89 46 0a          	mov    %ax,0xa(%esi)
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
    2c0f:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    2c13:	66 89 46 0c          	mov    %ax,0xc(%esi)
			if(tempulgrant->m_rnti == SV(C_RNTI))
    2c17:	0f b7 06             	movzwl (%esi),%eax
    2c1a:	66 39 07             	cmp    %ax,(%edi)
    2c1d:	0f 84 ed 03 00 00    	je     3010 <ioctrl_handler+0x5d0>
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
    2c23:	66 85 c0             	test   %ax,%ax
    2c26:	74 28                	je     2c50 <ioctrl_handler+0x210>
    2c28:	8b 86 ec 01 00 00    	mov    0x1ec(%esi),%eax
    2c2e:	85 c0                	test   %eax,%eax
    2c30:	74 1e                	je     2c50 <ioctrl_handler+0x210>
    2c32:	8b 86 f0 01 00 00    	mov    0x1f0(%esi),%eax
    2c38:	85 c0                	test   %eax,%eax
    2c3a:	0f 84 df 03 00 00    	je     301f <ioctrl_handler+0x5df>
    2c40:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    2c47:	0f 84 fc 03 00 00    	je     3049 <ioctrl_handler+0x609>
    2c4d:	8d 76 00             	lea    0x0(%esi),%esi
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2c50:	8b 47 06             	mov    0x6(%edi),%eax
    2c53:	e8 fc ff ff ff       	call   2c54 <ioctrl_handler+0x214>
			//fsm_printf("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d\n",SV(UL_resource_info.m_tbsize));
			//printk("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d, ul_sched_count:%d\n",SV(UL_resource_info.m_tbsize),++ul_sched_count);
			//SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(*((int *)tempdata_ptr)); //UL_grant 
			// ul_grant retxBSR-Timer 36321-80c 5.4.5
			SV(UL_resource_info.resource_flag) = true;
    2c58:	c6 46 28 01          	movb   $0x1,0x28(%esi)

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    2c5c:	89 c2                	mov    %eax,%edx
    2c5e:	c1 ea 03             	shr    $0x3,%edx
    2c61:	89 96 f4 01 00 00    	mov    %edx,0x1f4(%esi)
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2c67:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2c6d:	89 46 2c             	mov    %eax,0x2c(%esi)
			SV(UL_resource_info.resource_flag) = true;

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2c70:	8d 4a 05             	lea    0x5(%edx),%ecx
    2c73:	39 4a 05             	cmp    %ecx,0x5(%edx)
    2c76:	74 0a                	je     2c82 <ioctrl_handler+0x242>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    2c78:	e8 fc ff ff ff       	call   2c79 <ioctrl_handler+0x239>
    2c7d:	e8 fc ff ff ff       	call   2c7e <ioctrl_handler+0x23e>
				SV(UL_resource_info.resource_flag)=false;
    2c82:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    2c86:	e9 ed fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2c8b:	90                   	nop
    2c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
			TATimer_config();//RRCTA 
		break;
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
    2c90:	c7 04 24 58 07 00 00 	movl   $0x758,(%esp)
    2c97:	e8 fc ff ff ff       	call   2c98 <ioctrl_handler+0x258>
*/
static void ue_mac_main_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_main_config());
	SV_PTR_GET(rlc_mac_sv);
    2c9c:	e8 fc ff ff ff       	call   2c9d <ioctrl_handler+0x25d>
    2ca1:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();	
    2ca3:	e8 fc ff ff ff       	call   2ca4 <ioctrl_handler+0x264>
	SV(systemconfigInfo.MACMainConfigInfo) = *((struct MAC_MainConfig*)tmpdata_ptr); //ioctrl
    2ca8:	83 c7 5c             	add    $0x5c,%edi
    2cab:	b9 14 00 00 00       	mov    $0x14,%ecx
    2cb0:	89 c6                	mov    %eax,%esi
    2cb2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2cb4:	e8 fc ff ff ff       	call   2cb5 <ioctrl_handler+0x275>
    2cb9:	e9 ba fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2cbe:	66 90                	xchg   %ax,%ax
}

static void test_print_pkt_num()
{
	FIN(test_print_pkt_num());
	SV_PTR_GET(rlc_mac_sv);
    2cc0:	e8 fc ff ff ff       	call   2cc1 <ioctrl_handler+0x281>
    2cc5:	89 c6                	mov    %eax,%esi
	printk("[UEMAC]uplink lost pkt num:%d\n",SV(lost_pkt_num_uplink));
    2cc7:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
    2ccd:	c7 04 24 18 09 00 00 	movl   $0x918,(%esp)
    2cd4:	89 44 24 04          	mov    %eax,0x4(%esp)
    2cd8:	e8 fc ff ff ff       	call   2cd9 <ioctrl_handler+0x299>
	printk("[UEMAC]uplink total pkt num:%d\n",SV(pkt_num_uplink));
    2cdd:	8b 86 08 02 00 00    	mov    0x208(%esi),%eax
    2ce3:	c7 04 24 38 09 00 00 	movl   $0x938,(%esp)
    2cea:	89 44 24 04          	mov    %eax,0x4(%esp)
    2cee:	e8 fc ff ff ff       	call   2cef <ioctrl_handler+0x2af>
	printk("[UEMAC]downlink lost pkt num:%d\n",SV(lost_pkt_num_downlink));
    2cf3:	8b 86 0c 02 00 00    	mov    0x20c(%esi),%eax
    2cf9:	c7 04 24 58 09 00 00 	movl   $0x958,(%esp)
    2d00:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d04:	e8 fc ff ff ff       	call   2d05 <ioctrl_handler+0x2c5>
	printk("[UEMAC]downlink total pkt num:%d\n",SV(pkt_num_downlink));
    2d09:	8b 86 10 02 00 00    	mov    0x210(%esi),%eax
    2d0f:	c7 04 24 7c 09 00 00 	movl   $0x97c,(%esp)
    2d16:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d1a:	e8 fc ff ff ff       	call   2d1b <ioctrl_handler+0x2db>
    2d1f:	e9 54 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
		break;
		case _IOCTLtoUEMAC_Contention_Failed:
			tempdata_ptr = fsm_data_get();
    2d28:	e8 fc ff ff ff       	call   2d29 <ioctrl_handler+0x2e9>
			contention_failed_times=*((u32 *)tempdata_ptr);
    2d2d:	8b 10                	mov    (%eax),%edx
			SV(contention_failed_num)=contention_failed_times;
    2d2f:	89 96 00 02 00 00    	mov    %edx,0x200(%esi)
			fsm_data_destroy(tempdata_ptr);
    2d35:	e8 fc ff ff ff       	call   2d36 <ioctrl_handler+0x2f6>
		break;
    2d3a:	e9 39 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d3f:	90                   	nop
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
    2d40:	e8 fc ff ff ff       	call   2d41 <ioctrl_handler+0x301>
			rar_failed_times=*((u32 *)tempdata_ptr);
    2d45:	8b 10                	mov    (%eax),%edx
			SV(rar_failed_num)=rar_failed_times;
    2d47:	89 96 fc 01 00 00    	mov    %edx,0x1fc(%esi)
    2d4d:	e9 01 fe ff ff       	jmp    2b53 <ioctrl_handler+0x113>
    2d52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
			PCRLC_RESUME_REQ();
			FOUT;
			break;
		case  PRLC_DISC_REQ:
			PPRLC_DISC_REQ();
    2d58:	e8 fc ff ff ff       	call   2d59 <ioctrl_handler+0x319>
			FOUT;
    2d5d:	e9 16 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
			PCRLC_CONFIG_REQ();
			FOUT;
			break;
		case CRLC_BULID_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
    2d68:	c7 04 24 dc 09 00 00 	movl   $0x9dc,(%esp)
    2d6f:	e8 fc ff ff ff       	call   2d70 <ioctrl_handler+0x330>
			PCRLC_BULID_REQ();
    2d74:	e8 fc ff ff ff       	call   2d75 <ioctrl_handler+0x335>
			FOUT;
    2d79:	e9 fa fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d7e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
			PCRLC_SUSPEND_REQ();
			FOUT;
			break;
		case CRLC_RESUME_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
    2d80:	c7 04 24 8c 0a 00 00 	movl   $0xa8c,(%esp)
    2d87:	e8 fc ff ff ff       	call   2d88 <ioctrl_handler+0x348>
			PCRLC_RESUME_REQ();
    2d8c:	e8 fc ff ff ff       	call   2d8d <ioctrl_handler+0x34d>
			FOUT;
    2d91:	e9 e2 fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d96:	66 90                	xchg   %ax,%ax
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
			PCRLC_DEACT_REQ();
			FOUT;
			break;
		case CRLC_SUSPEND_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
    2d98:	c7 04 24 50 0a 00 00 	movl   $0xa50,(%esp)
    2d9f:	e8 fc ff ff ff       	call   2da0 <ioctrl_handler+0x360>
			PCRLC_SUSPEND_REQ();
    2da4:	e8 fc ff ff ff       	call   2da5 <ioctrl_handler+0x365>
			FOUT;
    2da9:	e9 ca fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2dae:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
			PCRLC_BULID_REQ();
			FOUT;
			break;
		case CRLC_DEACT_REQ:
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
    2db0:	c7 04 24 14 0a 00 00 	movl   $0xa14,(%esp)
    2db7:	e8 fc ff ff ff       	call   2db8 <ioctrl_handler+0x378>
			PCRLC_DEACT_REQ();
    2dbc:	e8 fc ff ff ff       	call   2dbd <ioctrl_handler+0x37d>
			FOUT;
    2dc1:	e9 b2 fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2dc6:	66 90                	xchg   %ax,%ax
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
			ue_mac_main_config(); 
		break;
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
    2dc8:	c7 04 24 8c 07 00 00 	movl   $0x78c,(%esp)
    2dcf:	e8 fc ff ff ff       	call   2dd0 <ioctrl_handler+0x390>
*/
static void ue_mac_rach_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_rach_config());
	SV_PTR_GET(rlc_mac_sv);
    2dd4:	e8 fc ff ff ff       	call   2dd5 <ioctrl_handler+0x395>
    2dd9:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();
    2ddb:	e8 fc ff ff ff       	call   2ddc <ioctrl_handler+0x39c>
	//ioctrl
	SV(systemconfigInfo.RACHCommonConfigInfo) = *((struct RachConfigCommon*)tmpdata_ptr); 
    2de0:	8b 10                	mov    (%eax),%edx
    2de2:	89 96 ac 00 00 00    	mov    %edx,0xac(%esi)
    2de8:	8b 50 04             	mov    0x4(%eax),%edx
    2deb:	89 96 b0 00 00 00    	mov    %edx,0xb0(%esi)
    2df1:	8b 50 08             	mov    0x8(%eax),%edx
    2df4:	89 96 b4 00 00 00    	mov    %edx,0xb4(%esi)
    2dfa:	8b 50 0c             	mov    0xc(%eax),%edx
    2dfd:	89 96 b8 00 00 00    	mov    %edx,0xb8(%esi)
    2e03:	8b 50 10             	mov    0x10(%eax),%edx
    2e06:	89 96 bc 00 00 00    	mov    %edx,0xbc(%esi)
    2e0c:	8b 50 14             	mov    0x14(%eax),%edx
    2e0f:	89 96 c0 00 00 00    	mov    %edx,0xc0(%esi)
    2e15:	8b 50 18             	mov    0x18(%eax),%edx
    2e18:	89 96 c4 00 00 00    	mov    %edx,0xc4(%esi)
    2e1e:	8b 50 1c             	mov    0x1c(%eax),%edx
    2e21:	89 96 c8 00 00 00    	mov    %edx,0xc8(%esi)
    2e27:	8b 50 20             	mov    0x20(%eax),%edx
    2e2a:	89 96 cc 00 00 00    	mov    %edx,0xcc(%esi)
    2e30:	8b 50 24             	mov    0x24(%eax),%edx
    2e33:	89 96 d0 00 00 00    	mov    %edx,0xd0(%esi)
    2e39:	8b 50 28             	mov    0x28(%eax),%edx
    2e3c:	89 96 d4 00 00 00    	mov    %edx,0xd4(%esi)
	//fsm_mem_cpy(&(SV(systemconfigInfo.RACHCommonConfigInfo)), tmpdata_ptr, sizeof(struct RachConfigCommon));
	//fsm_printf("[UEMAC][rach_config]maxHARQ_Msg3Tx :%d ",	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx) );//testing code
	//fsm_printf("[UEMAC][rach_config]mac_ContentionResolutionTimer : %d \n",SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer));
	fsm_data_destroy(tmpdata_ptr);//
    2e42:	e8 fc ff ff ff       	call   2e43 <ioctrl_handler+0x403>
    2e47:	e9 2c fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2e4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
			//ioctrl
		break ;
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
    2e50:	c7 04 24 08 07 00 00 	movl   $0x708,(%esp)
    2e57:	e8 fc ff ff ff       	call   2e58 <ioctrl_handler+0x418>
*/
static void TATimer_config() 
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
    2e5c:	e8 fc ff ff ff       	call   2e5d <ioctrl_handler+0x41d>
    2e61:	89 c6                	mov    %eax,%esi
	int time;
	tmpdata_ptr = fsm_data_get();
    2e63:	e8 fc ff ff ff       	call   2e64 <ioctrl_handler+0x424>
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2e68:	b9 04 00 00 00       	mov    $0x4,%ecx
    2e6d:	89 c2                	mov    %eax,%edx
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
    2e6f:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2e71:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2e74:	e8 fc ff ff ff       	call   2e75 <ioctrl_handler+0x435>
	SV(TA_Periodic_time)=time;//LHL 20141021
    2e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2e7c:	80 be 68 01 00 00 00 	cmpb   $0x0,0x168(%esi)
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
	SV(TA_Periodic_time)=time;//LHL 20141021
    2e83:	89 46 24             	mov    %eax,0x24(%esi)
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2e86:	74 3a                	je     2ec2 <ioctrl_handler+0x482>
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
    2e88:	c7 04 24 30 07 00 00 	movl   $0x730,(%esp)
    2e8f:	e8 fc ff ff ff       	call   2e90 <ioctrl_handler+0x450>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    2e94:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
    2e9a:	e8 fc ff ff ff       	call   2e9b <ioctrl_handler+0x45b>
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2e9f:	8b 46 24             	mov    0x24(%esi),%eax
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2ea2:	ba 0b 00 00 00       	mov    $0xb,%edx
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
		SV(TATimer.flag)=true;
    2ea7:	c6 86 68 01 00 00 01 	movb   $0x1,0x168(%esi)
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2eae:	89 86 60 01 00 00    	mov    %eax,0x160(%esi)
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2eb4:	6b c0 64             	imul   $0x64,%eax,%eax
    2eb7:	e8 fc ff ff ff       	call   2eb8 <ioctrl_handler+0x478>
    2ebc:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
		//SV(TA_timer_flag)=0;
	}//  
	fsm_data_destroy(tmpdata_ptr);
    2ec2:	89 f8                	mov    %edi,%eax
    2ec4:	e8 fc ff ff ff       	call   2ec5 <ioctrl_handler+0x485>
    2ec9:	e9 aa fb ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2ece:	66 90                	xchg   %ax,%ax
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
			//ioctrlRNTI
		break;
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
    2ed0:	31 c9                	xor    %ecx,%ecx
    2ed2:	ba 27 00 00 00       	mov    $0x27,%edx
    2ed7:	b8 03 00 00 00       	mov    $0x3,%eax
    2edc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2ee3:	e8 fc ff ff ff       	call   2ee4 <ioctrl_handler+0x4a4>
			//ioctrl
		break ;
    2ee8:	e9 8b fb ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2eed:	8d 76 00             	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] MRLC_TRANSOP_IND  has received\n");
			PMRLC_TRANSOP_IND();
			FOUT;
			break;*/ //noted in 20150804
		case PRINTRLC:
			printk("\ncountRecvFromUpper =%d\n",SV(countRecvFromUpper));
    2ef0:	8b 86 8c 5a 00 00    	mov    0x5a8c(%esi),%eax
    2ef6:	c7 04 24 e4 00 00 00 	movl   $0xe4,(%esp)
    2efd:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f01:	e8 fc ff ff ff       	call   2f02 <ioctrl_handler+0x4c2>
			printk("countSentToLower =%d\n",SV(countSentToLower));
    2f06:	8b 86 98 5a 00 00    	mov    0x5a98(%esi),%eax
    2f0c:	c7 04 24 fd 00 00 00 	movl   $0xfd,(%esp)
    2f13:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f17:	e8 fc ff ff ff       	call   2f18 <ioctrl_handler+0x4d8>
			printk("countSendToUpper =%d\n",SV(countSendToUpper));
    2f1c:	8b 86 90 5a 00 00    	mov    0x5a90(%esi),%eax
    2f22:	c7 04 24 13 01 00 00 	movl   $0x113,(%esp)
    2f29:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f2d:	e8 fc ff ff ff       	call   2f2e <ioctrl_handler+0x4ee>
			printk("countRecvFromLower =%d\n",SV(countRecvFromLower));
    2f32:	8b 86 94 5a 00 00    	mov    0x5a94(%esi),%eax
    2f38:	c7 04 24 29 01 00 00 	movl   $0x129,(%esp)
    2f3f:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f43:	e8 fc ff ff ff       	call   2f44 <ioctrl_handler+0x504>
			printk("countSendCtrlPdu =%d\n",SV(countSendCtrlPdu));
    2f48:	8b 86 a0 5a 00 00    	mov    0x5aa0(%esi),%eax
    2f4e:	c7 04 24 41 01 00 00 	movl   $0x141,(%esp)
    2f55:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f59:	e8 fc ff ff ff       	call   2f5a <ioctrl_handler+0x51a>
			printk("countRecvCtrlPdu =%d\n",SV(countRecvCtrlPdu));
    2f5e:	8b 86 a4 5a 00 00    	mov    0x5aa4(%esi),%eax
    2f64:	c7 04 24 57 01 00 00 	movl   $0x157,(%esp)
    2f6b:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f6f:	e8 fc ff ff ff       	call   2f70 <ioctrl_handler+0x530>
			printk("countDropPacket =%d\n\n",SV(countDropPacket));
    2f74:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    2f7a:	c7 04 24 6d 01 00 00 	movl   $0x16d,(%esp)
    2f81:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f85:	e8 fc ff ff ff       	call   2f86 <ioctrl_handler+0x546>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
    2f8a:	8b 86 a8 5a 00 00    	mov    0x5aa8(%esi),%eax
    2f90:	c7 04 24 83 01 00 00 	movl   $0x183,(%esp)
    2f97:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f9b:	e8 fc ff ff ff       	call   2f9c <ioctrl_handler+0x55c>
			
			
			break;
    2fa0:	e9 d3 fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2fa5:	8d 76 00             	lea    0x0(%esi),%esi
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
			ue_mac_BCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
    2fa8:	c7 04 24 24 08 00 00 	movl   $0x824,(%esp)
    2faf:	e8 fc ff ff ff       	call   2fb0 <ioctrl_handler+0x570>
*/
static void ue_mac_PCCH_config()
{
	void *tmpdata_ptr;	
	FIN( ue_mac_PCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    2fb4:	e8 fc ff ff ff       	call   2fb5 <ioctrl_handler+0x575>
    2fb9:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();		
    2fbb:	e8 fc ff ff ff       	call   2fbc <ioctrl_handler+0x57c>
	SV(systemconfigInfo.PCCHConfigInfo) = *((struct PCCH_Config*)tmpdata_ptr);  //ioctrl
    2fc0:	8b 08                	mov    (%eax),%ecx
    2fc2:	8b 58 04             	mov    0x4(%eax),%ebx
    2fc5:	89 8e d8 00 00 00    	mov    %ecx,0xd8(%esi)
    2fcb:	89 9e dc 00 00 00    	mov    %ebx,0xdc(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    2fd1:	e8 fc ff ff ff       	call   2fd2 <ioctrl_handler+0x592>
    2fd6:	e9 9d fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2fdb:	90                   	nop
    2fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
			ue_mac_logCh_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
    2fe0:	c7 04 24 f0 07 00 00 	movl   $0x7f0,(%esp)
    2fe7:	e8 fc ff ff ff       	call   2fe8 <ioctrl_handler+0x5a8>
*/
static void ue_mac_BCCH_config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_BCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    2fec:	e8 fc ff ff ff       	call   2fed <ioctrl_handler+0x5ad>
    2ff1:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2ff3:	e8 fc ff ff ff       	call   2ff4 <ioctrl_handler+0x5b4>
	SV(systemconfigInfo.BCCHConfigInfo)= *((struct BCCH_Config*)tmpdata_ptr);  //ioctrl 
    2ff8:	8b 10                	mov    (%eax),%edx
    2ffa:	89 96 e0 00 00 00    	mov    %edx,0xe0(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    3000:	e8 fc ff ff ff       	call   3001 <ioctrl_handler+0x5c1>
    3005:	e9 6e fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    300a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
    3010:	c7 86 f0 01 00 00 01 	movl   $0x1,0x1f0(%esi)
    3017:	00 00 00 
    301a:	e9 04 fc ff ff       	jmp    2c23 <ioctrl_handler+0x1e3>
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
				fsm_schedule_self(0, Contention_Success );
			}
			else if(SV(C_RNTI) && SV(sendmsg3) && !SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )
    301f:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    3026:	0f 85 24 fc ff ff    	jne    2c50 <ioctrl_handler+0x210>
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
    302c:	c7 04 24 d4 08 00 00 	movl   $0x8d4,(%esp)
    3033:	e8 fc ff ff ff       	call   3034 <ioctrl_handler+0x5f4>
				fsm_schedule_self(0, ContentionResolution_Fail );
    3038:	ba 05 00 00 00       	mov    $0x5,%edx
    303d:	31 c0                	xor    %eax,%eax
    303f:	e8 fc ff ff ff       	call   3040 <ioctrl_handler+0x600>
    3044:	e9 07 fc ff ff       	jmp    2c50 <ioctrl_handler+0x210>
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
    3049:	c7 04 24 88 08 00 00 	movl   $0x888,(%esp)
    3050:	e8 fc ff ff ff       	call   3051 <ioctrl_handler+0x611>
				fsm_schedule_self(0, Contention_Success );
    3055:	ba 06 00 00 00       	mov    $0x6,%edx
    305a:	31 c0                	xor    %eax,%eax
    305c:	e8 fc ff ff ff       	call   305d <ioctrl_handler+0x61d>
    3061:	e9 ea fb ff ff       	jmp    2c50 <ioctrl_handler+0x210>
    3066:	8d 76 00             	lea    0x0(%esi),%esi
    3069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003070 <doStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
static void doStartContentionBasedRandomAccessProcedure() //modified by HQ  20140419
{
    3070:	55                   	push   %ebp
    3071:	89 e5                	mov    %esp,%ebp
    3073:	83 ec 18             	sub    $0x18,%esp
    3076:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3079:	89 75 f8             	mov    %esi,-0x8(%ebp)
    307c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    307f:	e8 fc ff ff ff       	call   3080 <doStartContentionBasedRandomAccessProcedure+0x10>
	FIN(doStartContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    3084:	e8 fc ff ff ff       	call   3085 <doStartContentionBasedRandomAccessProcedure+0x15>
    3089:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated));
    308b:	b8 02 00 00 00       	mov    $0x2,%eax
    3090:	e8 fc ff ff ff       	call   3091 <doStartContentionBasedRandomAccessProcedure+0x21>
    3095:	89 c6                	mov    %eax,%esi
	int mg3_buffer;
	//print_tran_info("[UEMAC][contention_ra]startCRA IDLE -> CRA");//testing code
	if(SV(PREAMBLE_TRANSMISSION_COUNTER )== 0)   //
    3097:	8b 43 14             	mov    0x14(%ebx),%eax
    309a:	85 c0                	test   %eax,%eax
    309c:	75 10                	jne    30ae <doStartContentionBasedRandomAccessProcedure+0x3e>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
    309e:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    30a5:	b0 01                	mov    $0x1,%al
    30a7:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    30ae:	89 44 24 04          	mov    %eax,0x4(%esp)
    30b2:	c7 04 24 f0 0a 00 00 	movl   $0xaf0,(%esp)
    30b9:	e8 fc ff ff ff       	call   30ba <doStartContentionBasedRandomAccessProcedure+0x4a>
*******************************
*/
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
    30be:	e8 fc ff ff ff       	call   30bf <doStartContentionBasedRandomAccessProcedure+0x4f>
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    30c3:	ba 01 00 00 00       	mov    $0x1,%edx
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
    30c8:	0f b6 b8 ac 00 00 00 	movzbl 0xac(%eax),%edi
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    30cf:	8d 45 f3             	lea    -0xd(%ebp),%eax
    30d2:	e8 fc ff ff ff       	call   30d3 <doStartContentionBasedRandomAccessProcedure+0x63>
	raPreambleID = raPreambleID%NumberOfRA_Preambles;
    30d7:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    30db:	89 fa                	mov    %edi,%edx
    30dd:	f6 f2                	div    %dl
    30df:	0f b6 c4             	movzbl %ah,%eax
    30e2:	88 45 f3             	mov    %al,-0xd(%ebp)
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
		SV(backoff_index) = 0;  //UEbackoff0ms    
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
	randomaccess_info->ra_PreambleIndex=RandomlySelectRaPreamble();//rapreamble
    30e5:	88 06                	mov    %al,(%esi)
	SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//rapid,RAR //HQ 20140506 
    30e7:	88 43 04             	mov    %al,0x4(%ebx)
	
	/*for test*/
	//randomaccess_info->ra_PreambleIndex=2;//for test 20141103
	//SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//for test20141103
	/*for test*/
	fsm_printf("[UEMAC][contention_ra]MAC ra_PreambleIndex:%d\n",SV(RA_info.ra_PreambleIndex));//test code
    30ea:	0f b6 c0             	movzbl %al,%eax
    30ed:	89 44 24 04          	mov    %eax,0x4(%esp)
    30f1:	c7 04 24 18 0b 00 00 	movl   $0xb18,(%esp)
    30f8:	e8 fc ff ff ff       	call   30f9 <doStartContentionBasedRandomAccessProcedure+0x89>
	/*randomaccess_info->ra_PRACHMaskIndex=0;
	SV(RA_info.ra_PRACHMaskIndex)=randomaccess_info->ra_PRACHMaskIndex;*/
	SendRaPreamble(randomaccess_info);//
    30fd:	89 f0                	mov    %esi,%eax
    30ff:	e8 fc f8 ff ff       	call   2a00 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    3104:	e8 87 f5 ff ff       	call   2690 <StartWaitingForRaResponse>
	FOUT;
}
    3109:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    310c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    310f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    3112:	89 ec                	mov    %ebp,%esp
    3114:	5d                   	pop    %ebp
    3115:	c3                   	ret    
    3116:	8d 76 00             	lea    0x0(%esi),%esi
    3119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003120 <reports_handler>:
->output:
->Special:
*******************************
*/
static void reports_handler()
{
    3120:	55                   	push   %ebp
    3121:	89 e5                	mov    %esp,%ebp
    3123:	53                   	push   %ebx
    3124:	83 ec 04             	sub    $0x4,%esp
    3127:	e8 fc ff ff ff       	call   3128 <reports_handler+0x8>
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    312c:	e8 fc ff ff ff       	call   312d <reports_handler+0xd>
    3131:	83 f8 03             	cmp    $0x3,%eax
    3134:	74 4a                	je     3180 <reports_handler+0x60>
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    3136:	e8 fc ff ff ff       	call   3137 <reports_handler+0x17>
    313b:	83 f8 03             	cmp    $0x3,%eax
    313e:	66 90                	xchg   %ax,%ax
    3140:	74 06                	je     3148 <reports_handler+0x28>
		handle_RetxBSRTimerExpire();
	//PHR 
FOUT;
}
    3142:	83 c4 04             	add    $0x4,%esp
    3145:	5b                   	pop    %ebx
    3146:	5d                   	pop    %ebp
    3147:	c3                   	ret    
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    3148:	e8 fc ff ff ff       	call   3149 <reports_handler+0x29>
    314d:	83 f8 0d             	cmp    $0xd,%eax
    3150:	75 f0                	jne    3142 <reports_handler+0x22>
->Special:
*******************************
*/
static void handle_RetxBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    3152:	e8 fc ff ff ff       	call   3153 <reports_handler+0x33>
    3157:	89 c3                	mov    %eax,%ebx
	FIN(handle_RetxBSRTimerExpire());
	DoProduceBsr_RetxBSRTimer();
    3159:	e8 fc ff ff ff       	call   315a <reports_handler+0x3a>
	SV(RetxBSRTimer.timer_sign) = NULL;
    315e:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3165:	00 00 00 
	SV(RetxBSRTimer.flag) = false;	
    3168:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	fsm_printf("[UEMAC][handle_retxbsrtimer]handle RetxBSRTimer expire\n");//testing code 
    316f:	c7 04 24 88 0b 00 00 	movl   $0xb88,(%esp)
    3176:	e8 fc ff ff ff       	call   3177 <reports_handler+0x57>
    317b:	eb c5                	jmp    3142 <reports_handler+0x22>
    317d:	8d 76 00             	lea    0x0(%esi),%esi
*******************************
*/
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    3180:	e8 fc ff ff ff       	call   3181 <reports_handler+0x61>
    3185:	83 f8 0c             	cmp    $0xc,%eax
    3188:	75 ac                	jne    3136 <reports_handler+0x16>
->Special:
*******************************
*/
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    318a:	e8 fc ff ff ff       	call   318b <reports_handler+0x6b>
    318f:	89 c3                	mov    %eax,%ebx
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
    3191:	e8 fc ff ff ff       	call   3192 <reports_handler+0x72>
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3196:	ba 0c 00 00 00       	mov    $0xc,%edx
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
    319b:	6b 43 64 64          	imul   $0x64,0x64(%ebx),%eax
    319f:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    31a5:	e8 fc ff ff ff       	call   31a6 <reports_handler+0x86>
	SV(PeriodicBSRTimer).flag = true;
    31aa:	c6 83 8c 01 00 00 01 	movb   $0x1,0x18c(%ebx)
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    31b1:	89 83 88 01 00 00    	mov    %eax,0x188(%ebx)
	SV(PeriodicBSRTimer).flag = true;
	fsm_printf("[UEMAC][handle_periodicbsrtimer]handle PeriodicBSRTimer expire\n");//testing code 
    31b7:	c7 04 24 48 0b 00 00 	movl   $0xb48,(%esp)
    31be:	e8 fc ff ff ff       	call   31bf <reports_handler+0x9f>
    31c3:	e9 6e ff ff ff       	jmp    3136 <reports_handler+0x16>
    31c8:	90                   	nop
    31c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000031d0 <send_msg3>:
->output:
->Special:
*******************************
*/
void send_msg3(FSM_PKT *skb) //defined by HQ 20140430  
{
    31d0:	55                   	push   %ebp
    31d1:	89 e5                	mov    %esp,%ebp
    31d3:	56                   	push   %esi
    31d4:	53                   	push   %ebx
    31d5:	83 ec 08             	sub    $0x8,%esp
    31d8:	e8 fc ff ff ff       	call   31d9 <send_msg3+0x9>
    31dd:	89 c6                	mov    %eax,%esi
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	//FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    31df:	e8 fc ff ff ff       	call   31e0 <send_msg3+0x10>
    31e4:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    31e6:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    31ec:	c7 04 24 c0 0b 00 00 	movl   $0xbc0,(%esp)
    31f3:	89 44 24 04          	mov    %eax,0x4(%esp)
    31f7:	e8 fc ff ff ff       	call   31f8 <send_msg3+0x28>
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    31fc:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    3202:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    3208:	83 fa 01             	cmp    $0x1,%edx
    320b:	74 3b                	je     3248 <send_msg3+0x78>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    320d:	85 c0                	test   %eax,%eax
    320f:	74 09                	je     321a <send_msg3+0x4a>
    3211:	83 fa 02             	cmp    $0x2,%edx
    3214:	0f 84 a6 00 00 00    	je     32c0 <send_msg3+0xf0>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    321a:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    3220:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    3225:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    322b:	6b c0 64             	imul   $0x64,%eax,%eax
    322e:	e8 fc ff ff ff       	call   322f <send_msg3+0x5f>
	SV(CRTimer.flag)=true;
    3233:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    323a:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	SV(CRTimer.flag)=true;
	FOUT;
}
    3240:	83 c4 08             	add    $0x8,%esp
    3243:	5b                   	pop    %ebx
    3244:	5e                   	pop    %esi
    3245:	5d                   	pop    %ebp
    3246:	c3                   	ret    
    3247:	90                   	nop
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    3248:	85 c0                	test   %eax,%eax
    324a:	74 05                	je     3251 <send_msg3+0x81>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    324c:	e8 fc ff ff ff       	call   324d <send_msg3+0x7d>
		SV(msg3_buf_ptr)=skb;//3
    3251:	89 b3 e4 01 00 00    	mov    %esi,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3257:	89 f0                	mov    %esi,%eax
    3259:	e8 fc ff ff ff       	call   325a <send_msg3+0x8a>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    325e:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3263:	89 c6                	mov    %eax,%esi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3265:	e8 fc ff ff ff       	call   3266 <send_msg3+0x96>
    326a:	85 c0                	test   %eax,%eax
    326c:	74 1a                	je     3288 <send_msg3+0xb8>
    326e:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3272:	74 14                	je     3288 <send_msg3+0xb8>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3274:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    327b:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3282:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
		complexUeMacPdu(skb);
    3288:	89 f0                	mov    %esi,%eax
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    328a:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3291:	00 00 00 
		complexUeMacPdu(skb);
    3294:	e8 fc ff ff ff       	call   3295 <send_msg3+0xc5>
		
	
		if(SV(Tbsize_Complex)!=0)
    3299:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    329f:	85 c0                	test   %eax,%eax
    32a1:	74 0a                	je     32ad <send_msg3+0xdd>
			SV(Tbsize_Complex)=0;//TBSIZE
    32a3:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    32aa:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    32ad:	c7 04 24 ec 0b 00 00 	movl   $0xbec,(%esp)
    32b4:	e8 fc ff ff ff       	call   32b5 <send_msg3+0xe5>
    32b9:	e9 5c ff ff ff       	jmp    321a <send_msg3+0x4a>
    32be:	66 90                	xchg   %ax,%ax
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32c0:	e8 fc ff ff ff       	call   32c1 <send_msg3+0xf1>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32c5:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32ca:	89 c6                	mov    %eax,%esi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32cc:	e8 fc ff ff ff       	call   32cd <send_msg3+0xfd>
    32d1:	85 c0                	test   %eax,%eax
    32d3:	74 06                	je     32db <send_msg3+0x10b>
    32d5:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    32d9:	75 3d                	jne    3318 <send_msg3+0x148>
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
		complexUeMacPdu(skb); 	
    32db:	89 f0                	mov    %esi,%eax
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
    32dd:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    32e4:	00 00 00 
		complexUeMacPdu(skb); 	
    32e7:	e8 fc ff ff ff       	call   32e8 <send_msg3+0x118>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    32ec:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    32f2:	85 c0                	test   %eax,%eax
    32f4:	74 0a                	je     3300 <send_msg3+0x130>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    32f6:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    32fd:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    3300:	c7 04 24 24 0c 00 00 	movl   $0xc24,(%esp)
    3307:	e8 fc ff ff ff       	call   3308 <send_msg3+0x138>
    330c:	e9 09 ff ff ff       	jmp    321a <send_msg3+0x4a>
    3311:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3318:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    331f:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3326:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
    332c:	eb ad                	jmp    32db <send_msg3+0x10b>
    332e:	66 90                	xchg   %ax,%ax

00003330 <print_tran_info>:
->output:
->Special:
*******************************
*/
void print_tran_info( const char *str)
{
    3330:	55                   	push   %ebp
    3331:	89 e5                	mov    %esp,%ebp
    3333:	53                   	push   %ebx
    3334:	83 ec 04             	sub    $0x4,%esp
    3337:	e8 fc ff ff ff       	call   3338 <print_tran_info+0x8>
    333c:	89 c3                	mov    %eax,%ebx
	FIN( print_tran_info());
	int curtime=0;
	curtime=fsm_get_curtime();
    333e:	e8 fc ff ff ff       	call   333f <print_tran_info+0xf>
	//fsm_printf("[UEMAC][print_info]%d ",curtime);
	fsm_printf(str);
    3343:	89 1c 24             	mov    %ebx,(%esp)
    3346:	e8 fc ff ff ff       	call   3347 <print_tran_info+0x17>
	fsm_printf("\n");
    334b:	c7 04 24 95 01 00 00 	movl   $0x195,(%esp)
    3352:	e8 fc ff ff ff       	call   3353 <print_tran_info+0x23>
	FOUT;
}
    3357:	83 c4 04             	add    $0x4,%esp
    335a:	5b                   	pop    %ebx
    335b:	5d                   	pop    %ebp
    335c:	c3                   	ret    
    335d:	8d 76 00             	lea    0x0(%esi),%esi

00003360 <handle_timeAlignmentTimerExpire>:
->output:
->Special:
*******************************
*/
static void handle_timeAlignmentTimerExpire()
{
    3360:	55                   	push   %ebp
    3361:	89 e5                	mov    %esp,%ebp
    3363:	e8 fc ff ff ff       	call   3364 <handle_timeAlignmentTimerExpire+0x4>
	FIN(handle_timeAlignmentTimerExpire());  
	SV_PTR_GET(rlc_mac_sv);
    3368:	e8 fc ff ff ff       	call   3369 <handle_timeAlignmentTimerExpire+0x9>
	SV(TATimer.time_value)=0;
    336d:	c7 80 60 01 00 00 00 	movl   $0x0,0x160(%eax)
    3374:	00 00 00 
	SV(TATimer.flag)=false;//
    3377:	c6 80 68 01 00 00 00 	movb   $0x0,0x168(%eax)
	SV(TATimer.timer_sign)=NULL;
    337e:	c7 80 64 01 00 00 00 	movl   $0x0,0x164(%eax)
    3385:	00 00 00 
	cleanharqBuff(); //HARQ
	//fsm_do_ioctrl(STRM_TO_IP, IOCCMD_MACtoRRC_PUCCHSRS_release  , NULL , 0);  //RRCPUCCH/SRS
	//
	SV(UL_resource_info.resource_flag)=false;//
    3388:	c6 40 28 00          	movb   $0x0,0x28(%eax)
	SV(UL_resource_info.m_tbsize)=0;
    338c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
											//??? 
	print_tran_info("[UEMAC][handle_tatimer]LostUL"); //testing code 
    3393:	b8 97 01 00 00       	mov    $0x197,%eax
    3398:	e8 fc ff ff ff       	call   3399 <handle_timeAlignmentTimerExpire+0x39>
	FOUT;
}
    339d:	5d                   	pop    %ebp
    339e:	c3                   	ret    
    339f:	90                   	nop

000033a0 <random_test>:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
{
    33a0:	55                   	push   %ebp
    33a1:	89 e5                	mov    %esp,%ebp
    33a3:	56                   	push   %esi
    33a4:	53                   	push   %ebx
    33a5:	83 ec 18             	sub    $0x18,%esp
    33a8:	e8 fc ff ff ff       	call   33a9 <random_test+0x9>
    33ad:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    33b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    33b6:	31 c0                	xor    %eax,%eax
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    33b8:	8d 5d ea             	lea    -0x16(%ebp),%ebx
void random_test()   //HQ 20140410 0-63
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    33bb:	c7 04 24 5c 0c 00 00 	movl   $0xc5c,(%esp)
->input:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
    33c2:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    33c5:	e8 fc ff ff ff       	call   33c6 <random_test+0x26>
    33ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    33d0:	89 d8                	mov    %ebx,%eax
    33d2:	ba 01 00 00 00       	mov    $0x1,%edx
    33d7:	e8 fc ff ff ff       	call   33d8 <random_test+0x38>
		randNum[i]=randNum[i]%64;
    33dc:	0f b6 03             	movzbl (%ebx),%eax
    33df:	83 e0 3f             	and    $0x3f,%eax
    33e2:	88 03                	mov    %al,(%ebx)
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
    33e4:	0f b6 c0             	movzbl %al,%eax
    33e7:	83 c3 01             	add    $0x1,%ebx
    33ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    33ee:	c7 04 24 8c 0c 00 00 	movl   $0xc8c,(%esp)
    33f5:	e8 fc ff ff ff       	call   33f6 <random_test+0x56>
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
    33fa:	39 f3                	cmp    %esi,%ebx
    33fc:	75 d2                	jne    33d0 <random_test+0x30>
		fsm_get_random_bytes(&randNum[i], sizeof(char));
		randNum[i]=randNum[i]%64;
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
	} 
	FOUT;
}
    33fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3401:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    3408:	75 07                	jne    3411 <random_test+0x71>
    340a:	83 c4 18             	add    $0x18,%esp
    340d:	5b                   	pop    %ebx
    340e:	5e                   	pop    %esi
    340f:	5d                   	pop    %ebp
    3410:	c3                   	ret    
    3411:	e8 fc ff ff ff       	call   3412 <random_test+0x72>
    3416:	8d 76 00             	lea    0x0(%esi),%esi
    3419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003420 <RA_RRCconfig_testingfun>:
->output:
->Special:
*******************************
*/
void RA_RRCconfig_testingfun() // RRC HQ 20140428 
{
    3420:	55                   	push   %ebp
    3421:	89 e5                	mov    %esp,%ebp
    3423:	83 ec 04             	sub    $0x4,%esp
    3426:	e8 fc ff ff ff       	call   3427 <RA_RRCconfig_testingfun+0x7>
	FIN(RA_RRCconfig_testingfun());
	SV_PTR_GET(rlc_mac_sv);
    342b:	e8 fc ff ff ff       	call   342c <RA_RRCconfig_testingfun+0xc>
	SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles)= 64;
    3430:	c7 80 ac 00 00 00 40 	movl   $0x40,0xac(%eax)
    3437:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax)=8;
    343a:	c7 80 c8 00 00 00 08 	movl   $0x8,0xc8(%eax)
    3441:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize)=800000;//8; 800s
    3444:	c7 80 cc 00 00 00 00 	movl   $0xc3500,0xcc(%eax)
    344b:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer)=800000;// 800s;
    344e:	c7 80 d0 00 00 00 00 	movl   $0xc3500,0xd0(%eax)
    3455:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx)=5;
    3458:	c7 80 d4 00 00 00 05 	movl   $0x5,0xd4(%eax)
    345f:	00 00 00 
	SV(backoff_index)= 2 ; 
    3462:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
	fsm_printf("[UEMAC][ra_rrcconfig]:RACH config have done \n");//testing code
    3469:	c7 04 24 b8 0c 00 00 	movl   $0xcb8,(%esp)
    3470:	e8 fc ff ff ff       	call   3471 <RA_RRCconfig_testingfun+0x51>
	FOUT;
}
    3475:	c9                   	leave  
    3476:	c3                   	ret    
    3477:	89 f6                	mov    %esi,%esi
    3479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003480 <ue_mac_sv_init>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_init()
{
    3480:	55                   	push   %ebp
    3481:	89 e5                	mov    %esp,%ebp
    3483:	57                   	push   %edi
    3484:	56                   	push   %esi
    3485:	53                   	push   %ebx
    3486:	83 ec 08             	sub    $0x8,%esp
    3489:	e8 fc ff ff ff       	call   348a <ue_mac_sv_init+0xa>
	FIN(ue_mac_sv_init());
	int len;
	
	SV_PTR_GET(rlc_mac_sv);
    348e:	e8 fc ff ff ff       	call   348f <ue_mac_sv_init+0xf>
    3493:	89 c3                	mov    %eax,%ebx
	print_tran_info("FSM INIT-init SV");//testing code
    3495:	b8 b5 01 00 00       	mov    $0x1b5,%eax
    349a:	e8 fc ff ff ff       	call   349b <ue_mac_sv_init+0x1b>
	SV(TA_Periodic_time)=800000000;//testing code ,
    349f:	c7 43 24 00 08 af 2f 	movl   $0x2faf0800,0x24(%ebx)
	Init_Uemac_Scheduler();
    34a6:	e8 fc ff ff ff       	call   34a7 <ue_mac_sv_init+0x27>
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    34ab:	b8 06 00 00 00       	mov    $0x6,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("FSM INIT-init SV");//testing code
	SV(TA_Periodic_time)=800000000;//testing code ,
	Init_Uemac_Scheduler();
	SV(sys_frame.frameNo)=0;//modified LHL 20141105
    34b0:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
	SV(sys_frame.subframeNo)=0;
    34b6:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
	SV(recv_frame).subframeNo=0;//
    34bc:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	SV(recv_frame).frameNo=0;
    34c2:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	SV(ue_schedule_frame.frameNo)=0;
    34c8:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
	SV(ue_schedule_frame.subframeNo)=0;
    34ce:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
    34d4:	66 c7 43 22 00 00    	movw   $0x0,0x22(%ebx)
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    34da:	e8 fc ff ff ff       	call   34db <ue_mac_sv_init+0x5b>
	//
	
	SV(TATimer.time_value) = 0;
    34df:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    34e6:	00 00 00 
	SV(TATimer.timer_sign) = NULL;
    34e9:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    34f0:	00 00 00 
	SV(TATimer.flag) = false;
    34f3:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
	SV(CRTimer.time_value) = 0;
    34fa:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    3501:	00 00 00 
	SV(CRTimer.timer_sign) = NULL;
    3504:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    350b:	00 00 00 
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    350e:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	SV(TATimer.time_value) = 0;
	SV(TATimer.timer_sign) = NULL;
	SV(TATimer.flag) = false;
	SV(CRTimer.time_value) = 0;
	SV(CRTimer.timer_sign) = NULL;
	SV(CRTimer.flag) = false;
    3514:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
	SV(RetxBSRTimer.time_value) = 0;
    351b:	c7 83 78 01 00 00 00 	movl   $0x0,0x178(%ebx)
    3522:	00 00 00 
	SV(RetxBSRTimer.timer_sign) = NULL;
    3525:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    352c:	00 00 00 
	SV(RetxBSRTimer.flag) = false;
    352f:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	SV(PeriodicBSRTimer.time_value) = 0;
    3536:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
    353d:	00 00 00 
	SV(PeriodicBSRTimer.timer_sign) = NULL;
    3540:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    3547:	00 00 00 
	SV(PeriodicBSRTimer.flag) = false;	
    354a:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
	SV(WaitforRAresponseTimer.time_value) = 0;
    3551:	c7 83 90 01 00 00 00 	movl   $0x0,0x190(%ebx)
    3558:	00 00 00 
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
    355b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3562:	00 00 00 
	SV(WaitforRAresponseTimer.flag) = false;
    3565:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
	SV(msg3_buf_ptr) = NULL;	
    356c:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    3573:	00 00 00 
	SV(ra_allocation_res)=0;
    3576:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    357d:	00 00 00 
*******************************
*/
static void macmain_defaultconfig()
{
	FIN(macmain_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3580:	e8 fc ff ff ff       	call   3581 <ue_mac_sv_init+0x101>
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx) = maxHARQ_Tx_n5;
    3585:	c7 40 60 05 00 00 00 	movl   $0x5,0x60(%eax)
	//fsm_printf("test maxHARQTX:%d \n ",SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx));//testing code
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)= periodicBSR_Timer_infinity;//
    358c:	c7 40 64 ff ff ff ff 	movl   $0xffffffff,0x64(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)= retxBSR_Timer_sf2560 ;
    3593:	c7 40 68 00 0a 00 00 	movl   $0xa00,0x68(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.ttiBundling)= false ;
    359a:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.drx_Config.choice.setup.haveShortDRX)= false ;//means release
    359e:	c6 80 8c 00 00 00 00 	movb   $0x0,0x8c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.type)= 1 ; //means phr-Config release ??  
    35a5:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
    35ac:	00 00 00 
*******************************
*/
static void sps_defaultconfig()
{
	FIN(sps_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    35af:	e8 fc ff ff ff       	call   35b0 <ue_mac_sv_init+0x130>
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigDL)=false;
    35b4:	c6 80 e8 00 00 00 00 	movb   $0x0,0xe8(%eax)
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigUL)=false; 
    35bb:	c6 80 08 01 00 00 00 	movb   $0x0,0x108(%eax)
*******************************
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    35c2:	e8 fc ff ff ff       	call   35c3 <ue_mac_sv_init+0x143>
    35c7:	89 c7                	mov    %eax,%edi
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    35c9:	b8 15 00 00 00       	mov    $0x15,%eax
    35ce:	e8 fc ff ff ff       	call   35cf <ue_mac_sv_init+0x14f>
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    35d3:	8d 97 28 01 00 00    	lea    0x128(%edi),%edx
    35d9:	b9 15 00 00 00       	mov    $0x15,%ecx
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
    35de:	c7 87 28 01 00 00 00 	movl   $0x0,0x128(%edi)
    35e5:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
    35e8:	c6 87 2c 01 00 00 01 	movb   $0x1,0x12c(%edi)
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
    35ef:	c7 87 2d 01 00 00 01 	movl   $0x1,0x12d(%edi)
    35f6:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
    35f9:	c7 87 31 01 00 00 ff 	movl   $0xffffffff,0x131(%edi)
    3600:	ff ff ff 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
    3603:	c7 87 39 01 00 00 00 	movl   $0x0,0x139(%edi)
    360a:	00 00 00 
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    360d:	89 c6                	mov    %eax,%esi
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    360f:	e8 fc ff ff ff       	call   3610 <ue_mac_sv_init+0x190>
	Init_LogicalChannel_ConfigInfo(ccch_info); 
    3614:	89 f0                	mov    %esi,%eax
    3616:	e8 fc ff ff ff       	call   3617 <ue_mac_sv_init+0x197>
	fsm_mem_free(ccch_info);//
    361b:	89 f0                	mov    %esi,%eax
    361d:	e8 fc ff ff ff       	call   361e <ue_mac_sv_init+0x19e>
	fsm_printf("[UEMAC][init]CCCH_defaultconfig completed\n");
    3622:	c7 04 24 e8 0c 00 00 	movl   $0xce8,(%esp)
    3629:	e8 fc ff ff ff       	call   362a <ue_mac_sv_init+0x1aa>
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
    362e:	e8 fc ff ff ff       	call   362f <ue_mac_sv_init+0x1af>
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    3633:	b9 04 00 00 00       	mov    $0x4,%ecx
    3638:	31 d2                	xor    %edx,%edx
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
	SV(UL_resource_info.resource_flag)= false; //testing code
    363a:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    363e:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
    3644:	e8 fc ff ff ff       	call   3645 <ue_mac_sv_init+0x1c5>
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    3649:	b8 0c 00 00 00       	mov    $0xc,%eax
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
	SV(sendmsg3)=0;//0:MSG31:MSG3
    364e:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    3655:	00 00 00 
	SV(pdcch_rnti)=0;//0:PDCCHC_RNTI1:C_RNTI
    3658:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    365f:	00 00 00 
	SV(Tbsize_Complex)=0;//modified by lhl ,20140718,to 
    3662:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    3669:	00 00 00 
	//test_init_logicalchannel(1);//TEST 20141103
	//test_init_logicalchannel(3);//TEST 20141103
	SV(contention_failed_num)=0;
    366c:	c7 83 00 02 00 00 00 	movl   $0x0,0x200(%ebx)
    3673:	00 00 00 
	SV(rar_failed_num)=0;
    3676:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
    367d:	00 00 00 
	
	SV(lost_pkt_num_uplink)=0;
    3680:	c7 83 04 02 00 00 00 	movl   $0x0,0x204(%ebx)
    3687:	00 00 00 
	SV(pkt_num_uplink)=0;
    368a:	c7 83 08 02 00 00 00 	movl   $0x0,0x208(%ebx)
    3691:	00 00 00 
	SV(lost_pkt_num_downlink)=0;
    3694:	c7 83 0c 02 00 00 00 	movl   $0x0,0x20c(%ebx)
    369b:	00 00 00 
	SV(pkt_num_downlink)=0;
    369e:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%ebx)
    36a5:	00 00 00 
	
	SV(countSendToUpper)=0;
    36a8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    36af:	00 00 00 
	SV(countRecvFromLower)=0;
    36b2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    36b9:	00 00 00 
	SV(countreceive_from_mac)=0;
    36bc:	c7 83 88 5a 00 00 00 	movl   $0x0,0x5a88(%ebx)
    36c3:	00 00 00 
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    36c6:	e8 fc ff ff ff       	call   36c7 <ue_mac_sv_init+0x247>
    36cb:	89 c6                	mov    %eax,%esi
    36cd:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)
	(*Q)->front = (*Q)->rear = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    36d3:	b8 08 00 00 00       	mov    $0x8,%eax
    36d8:	e8 fc ff ff ff       	call   36d9 <ue_mac_sv_init+0x259>
    36dd:	89 46 04             	mov    %eax,0x4(%esi)
    36e0:	89 06                	mov    %eax,(%esi)
	// Q->front = NULL;
	// Q->rear = NULL;
	(*Q)->pkt_count = 0;
    36e2:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    36e8:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	fsm_printf("[InitQueue]Q point: %p\n", *Q);
    36ee:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    36f4:	c7 04 24 c6 01 00 00 	movl   $0x1c6,(%esp)
    36fb:	89 44 24 04          	mov    %eax,0x4(%esp)
    36ff:	e8 fc ff ff ff       	call   3700 <ue_mac_sv_init+0x280>
	SV(countSendToUpper)=0;
	SV(countRecvFromLower)=0;
	SV(countreceive_from_mac)=0;

	InitQueue(&SV(CraQueue));	//add cra queue initialization by LXR in 20151020
	fsm_printf("[ue_mac_sv_init]SV(CraQueue): %p\n", SV(CraQueue));
    3704:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    370a:	c7 04 24 14 0d 00 00 	movl   $0xd14,(%esp)
    3711:	89 44 24 04          	mov    %eax,0x4(%esp)
    3715:	e8 fc ff ff ff       	call   3716 <ue_mac_sv_init+0x296>
	
	FOUT;
}
    371a:	83 c4 08             	add    $0x8,%esp
    371d:	5b                   	pop    %ebx
    371e:	5e                   	pop    %esi
    371f:	5f                   	pop    %edi
    3720:	5d                   	pop    %ebp
    3721:	c3                   	ret    
    3722:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    3729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003730 <testdoStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartContentionBasedRandomAccessProcedure()
{
    3730:	55                   	push   %ebp
    3731:	89 e5                	mov    %esp,%ebp
    3733:	e8 fc ff ff ff       	call   3734 <testdoStartContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> CRA");
    3738:	b8 de 01 00 00       	mov    $0x1de,%eax
    373d:	e8 fc ff ff ff       	call   373e <testdoStartContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	//fsm_schedule_self(100000, RandomAcc_Fail );//testing code
	FOUT;
}
    3742:	5d                   	pop    %ebp
    3743:	c3                   	ret    
    3744:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    374a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003750 <testdoStartNonContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartNonContentionBasedRandomAccessProcedure() // 
{
    3750:	55                   	push   %ebp
    3751:	89 e5                	mov    %esp,%ebp
    3753:	e8 fc ff ff ff       	call   3754 <testdoStartNonContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartNonContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> NCRA");
    3758:	b8 ea 01 00 00       	mov    $0x1ea,%eax
    375d:	e8 fc ff ff ff       	call   375e <testdoStartNonContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	FOUT;
}
    3762:	5d                   	pop    %ebp
    3763:	c3                   	ret    
    3764:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    376a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003770 <stop_WRAP_timer>:
->output:
->Special:
*******************************
*/
void stop_WRAP_timer()
{
    3770:	55                   	push   %ebp
    3771:	89 e5                	mov    %esp,%ebp
    3773:	53                   	push   %ebx
    3774:	e8 fc ff ff ff       	call   3775 <stop_WRAP_timer+0x5>
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3779:	e8 fc ff ff ff       	call   377a <stop_WRAP_timer+0xa>
	if(SV(WaitforRAresponseTimer.flag)==true)
    377e:	80 b8 98 01 00 00 00 	cmpb   $0x0,0x198(%eax)
*******************************
*/
void stop_WRAP_timer()
{
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3785:	89 c3                	mov    %eax,%ebx
	if(SV(WaitforRAresponseTimer.flag)==true)
    3787:	74 1c                	je     37a5 <stop_WRAP_timer+0x35>
	{
		fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    3789:	8b 80 94 01 00 00    	mov    0x194(%eax),%eax
    378f:	e8 fc ff ff ff       	call   3790 <stop_WRAP_timer+0x20>
		SV(WaitforRAresponseTimer.flag)=false;
    3794:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)=NULL;
    379b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    37a2:	00 00 00 
	}
	FOUT;
}
    37a5:	5b                   	pop    %ebx
    37a6:	5d                   	pop    %ebp
    37a7:	c3                   	ret    
    37a8:	90                   	nop
    37a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000037b0 <NCRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void NCRAtoCON_testingfun() 
{
    37b0:	55                   	push   %ebp
    37b1:	89 e5                	mov    %esp,%ebp
    37b3:	e8 fc ff ff ff       	call   37b4 <NCRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("NCRA -> CON");
    37b8:	b8 f7 01 00 00       	mov    $0x1f7,%eax
    37bd:	e8 fc ff ff ff       	call   37be <NCRAtoCON_testingfun+0xe>
	stop_WRAP_timer(); //RAR
    37c2:	e8 fc ff ff ff       	call   37c3 <NCRAtoCON_testingfun+0x13>
	FOUT;
}
    37c7:	5d                   	pop    %ebp
    37c8:	c3                   	ret    
    37c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000037d0 <stop_CR_timer>:
->output:
->Special:
*******************************
*/
void stop_CR_timer()
{
    37d0:	55                   	push   %ebp
    37d1:	89 e5                	mov    %esp,%ebp
    37d3:	53                   	push   %ebx
    37d4:	e8 fc ff ff ff       	call   37d5 <stop_CR_timer+0x5>
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    37d9:	e8 fc ff ff ff       	call   37da <stop_CR_timer+0xa>
	if(SV(CRTimer.flag)==true)
    37de:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
*******************************
*/
void stop_CR_timer()
{
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    37e5:	89 c3                	mov    %eax,%ebx
	if(SV(CRTimer.flag)==true)
    37e7:	74 1c                	je     3805 <stop_CR_timer+0x35>
	{
		fsm_schedule_cancel(SV(CRTimer.timer_sign));
    37e9:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    37ef:	e8 fc ff ff ff       	call   37f0 <stop_CR_timer+0x20>
		SV(CRTimer.flag)=false;
    37f4:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
		SV(CRTimer.timer_sign)=NULL;
    37fb:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    3802:	00 00 00 
	}
	FOUT;
}
    3805:	5b                   	pop    %ebx
    3806:	5d                   	pop    %ebp
    3807:	c3                   	ret    
    3808:	90                   	nop
    3809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003810 <stop_TA_timer>:
->output:
->Special:
*******************************
*/
void stop_TA_timer()
{
    3810:	55                   	push   %ebp
    3811:	89 e5                	mov    %esp,%ebp
    3813:	53                   	push   %ebx
    3814:	e8 fc ff ff ff       	call   3815 <stop_TA_timer+0x5>
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    3819:	e8 fc ff ff ff       	call   381a <stop_TA_timer+0xa>
	if(SV(TATimer.flag)==true)
    381e:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
void stop_TA_timer()
{
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    3825:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true)
    3827:	74 1c                	je     3845 <stop_TA_timer+0x35>
	{
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    3829:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    382f:	e8 fc ff ff ff       	call   3830 <stop_TA_timer+0x20>
		SV(TATimer.flag)=false;
    3834:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.timer_sign)=NULL;
    383b:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    3842:	00 00 00 
	}
	FOUT;
}
    3845:	5b                   	pop    %ebx
    3846:	5d                   	pop    %ebp
    3847:	c3                   	ret    
    3848:	90                   	nop
    3849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003850 <stop_RetxBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_RetxBSR_timer()
{
    3850:	55                   	push   %ebp
    3851:	89 e5                	mov    %esp,%ebp
    3853:	53                   	push   %ebx
    3854:	e8 fc ff ff ff       	call   3855 <stop_RetxBSR_timer+0x5>
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3859:	e8 fc ff ff ff       	call   385a <stop_RetxBSR_timer+0xa>
	if(SV(RetxBSRTimer.flag)==true)
    385e:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
*******************************
*/
void stop_RetxBSR_timer()
{
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3865:	89 c3                	mov    %eax,%ebx
	if(SV(RetxBSRTimer.flag)==true)
    3867:	74 1c                	je     3885 <stop_RetxBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(RetxBSRTimer.timer_sign));
    3869:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    386f:	e8 fc ff ff ff       	call   3870 <stop_RetxBSR_timer+0x20>
		SV(RetxBSRTimer.flag)=false;
    3874:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
		SV(RetxBSRTimer.timer_sign)=NULL;
    387b:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3882:	00 00 00 
	}
	FOUT;
}
    3885:	5b                   	pop    %ebx
    3886:	5d                   	pop    %ebp
    3887:	c3                   	ret    
    3888:	90                   	nop
    3889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003890 <stop_PeriodicBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_PeriodicBSR_timer()
{
    3890:	55                   	push   %ebp
    3891:	89 e5                	mov    %esp,%ebp
    3893:	53                   	push   %ebx
    3894:	e8 fc ff ff ff       	call   3895 <stop_PeriodicBSR_timer+0x5>
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3899:	e8 fc ff ff ff       	call   389a <stop_PeriodicBSR_timer+0xa>
	if(SV(PeriodicBSRTimer.flag)==true)
    389e:	80 b8 8c 01 00 00 00 	cmpb   $0x0,0x18c(%eax)
*******************************
*/
void stop_PeriodicBSR_timer()
{
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    38a5:	89 c3                	mov    %eax,%ebx
	if(SV(PeriodicBSRTimer.flag)==true)
    38a7:	74 1c                	je     38c5 <stop_PeriodicBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(PeriodicBSRTimer.timer_sign));
    38a9:	8b 80 88 01 00 00    	mov    0x188(%eax),%eax
    38af:	e8 fc ff ff ff       	call   38b0 <stop_PeriodicBSR_timer+0x20>
		SV(PeriodicBSRTimer.flag)=false;
    38b4:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
		SV(PeriodicBSRTimer.timer_sign)=NULL;
    38bb:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    38c2:	00 00 00 
	}
	FOUT;
}
    38c5:	5b                   	pop    %ebx
    38c6:	5d                   	pop    %ebp
    38c7:	c3                   	ret    
    38c8:	90                   	nop
    38c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038d0 <ue_mac_reset>:
->output:
->Special:
*******************************
*/
static void ue_mac_reset()//modified by LHL 20140717
{
    38d0:	55                   	push   %ebp
    38d1:	89 e5                	mov    %esp,%ebp
    38d3:	53                   	push   %ebx
    38d4:	e8 fc ff ff ff       	call   38d5 <ue_mac_reset+0x5>
	FIN( ue_mac_reset());
	SV_PTR_GET(rlc_mac_sv);
    38d9:	e8 fc ff ff ff       	call   38da <ue_mac_reset+0xa>
    38de:	89 c3                	mov    %eax,%ebx
	//initialize Bj for each logical channel to zero;BJ0 
	Zero_LogicalChannel_Bj_Reset();
    38e0:	e8 fc ff ff ff       	call   38e1 <ue_mac_reset+0x11>
	//stop (if running) all timers; 
	stop_WRAP_timer();//WaitforRAresponseTimer
    38e5:	e8 fc ff ff ff       	call   38e6 <ue_mac_reset+0x16>
	stop_CR_timer();//CR
    38ea:	e8 fc ff ff ff       	call   38eb <ue_mac_reset+0x1b>
    38ef:	90                   	nop
	stop_RetxBSR_timer();
    38f0:	e8 fc ff ff ff       	call   38f1 <ue_mac_reset+0x21>
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
    38f5:	e8 fc ff ff ff       	call   38f6 <ue_mac_reset+0x26>
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    38fa:	8b 83 e8 01 00 00    	mov    0x1e8(%ebx),%eax
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
	//	consider timeAlignmentTimer as expired and perform the corresponding actions in subclause 5.2;
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
    3900:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	SV(SR_COUNTER)= 0; 
    3907:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    390e:	83 f8 03             	cmp    $0x3,%eax
    3911:	74 4d                	je     3960 <ue_mac_reset+0x90>
    3913:	83 f8 01             	cmp    $0x1,%eax
    3916:	74 48                	je     3960 <ue_mac_reset+0x90>
	{
		SV(RA_info.ra_PreambleIndex)=0;//
		SV(RA_info.ra_PRACHMaskIndex)=0;
	}
	//	flush Msg3 buffer;
	if(SV(msg3_buf_ptr)!=NULL)
    3918:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    391e:	85 c0                	test   %eax,%eax
    3920:	74 0f                	je     3931 <ue_mac_reset+0x61>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));	
    3922:	e8 fc ff ff ff       	call   3923 <ue_mac_reset+0x53>
		SV(msg3_buf_ptr) = NULL; 
    3927:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    392e:	00 00 00 
	}
	//	cancel, if any, triggered Scheduling Request procedure;
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
    3931:	e8 fc ff ff ff       	call   3932 <ue_mac_reset+0x62>
	Empty_MACBuffer_Rlc();//RLC 
    3936:	e8 fc ff ff ff       	call   3937 <ue_mac_reset+0x67>
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
	if(SV(m_temp_cr) != NULL)
    393b:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
	Empty_MACBuffer_Rlc();//RLC 
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
    3941:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if(SV(m_temp_cr) != NULL)
    3947:	85 c0                	test   %eax,%eax
    3949:	74 0f                	je     395a <ue_mac_reset+0x8a>
	{
		fsm_mem_free(SV(m_temp_cr));
    394b:	e8 fc ff ff ff       	call   394c <ue_mac_reset+0x7c>
		SV(m_temp_cr) = NULL;
    3950:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    3957:	00 00 00 
	}
	FOUT;
}
    395a:	5b                   	pop    %ebx
    395b:	5d                   	pop    %ebp
    395c:	c3                   	ret    
    395d:	8d 76 00             	lea    0x0(%esi),%esi
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
	{
		SV(RA_info.ra_PreambleIndex)=0;//
    3960:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0;
    3964:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    3968:	eb ae                	jmp    3918 <ue_mac_reset+0x48>
    396a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00003970 <CRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void CRAtoCON_testingfun()
{
    3970:	55                   	push   %ebp
    3971:	89 e5                	mov    %esp,%ebp
    3973:	e8 fc ff ff ff       	call   3974 <CRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("CRA -> CON");
    3978:	b8 03 02 00 00       	mov    $0x203,%eax
    397d:	e8 fc ff ff ff       	call   397e <CRAtoCON_testingfun+0xe>
	stop_CR_timer(); //
    3982:	e8 fc ff ff ff       	call   3983 <CRAtoCON_testingfun+0x13>
	FOUT;
}
    3987:	5d                   	pop    %ebp
    3988:	c3                   	ret    
    3989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003990 <test1_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test1_idle_default_handler()
{
    3990:	55                   	push   %ebp
    3991:	89 e5                	mov    %esp,%ebp
    3993:	83 ec 10             	sub    $0x10,%esp
    3996:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    3999:	89 75 fc             	mov    %esi,-0x4(%ebp)
    399c:	e8 fc ff ff ff       	call   399d <test1_idle_default_handler+0xd>
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    39a1:	e8 fc ff ff ff       	call   39a2 <test1_idle_default_handler+0x12>
    39a6:	89 c3                	mov    %eax,%ebx
	print_tran_info("MAC:idle_default_handler");
    39a8:	b8 0e 02 00 00       	mov    $0x20e,%eax
    39ad:	e8 fc ff ff ff       	call   39ae <test1_idle_default_handler+0x1e>
	if(MAC_CLOSE)
    39b2:	e8 fc ff ff ff       	call   39b3 <test1_idle_default_handler+0x23>
    39b7:	83 f8 05             	cmp    $0x5,%eax
    39ba:	74 5c                	je     3a18 <test1_idle_default_handler+0x88>
    39bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    39c0:	e8 fc ff ff ff       	call   39c1 <test1_idle_default_handler+0x31>
    39c5:	83 f8 02             	cmp    $0x2,%eax
    39c8:	74 76                	je     3a40 <test1_idle_default_handler+0xb0>
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    39ca:	e8 fc ff ff ff       	call   39cb <test1_idle_default_handler+0x3b>
    39cf:	83 f8 05             	cmp    $0x5,%eax
    39d2:	74 0c                	je     39e0 <test1_idle_default_handler+0x50>
			ioctrl_handler();  	
		break;
		}
	}
FOUT;
}
    39d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    39d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
    39da:	89 ec                	mov    %ebp,%esp
    39dc:	5d                   	pop    %ebp
    39dd:	c3                   	ret    
    39de:	66 90                	xchg   %ax,%ax
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    39e0:	e8 fc ff ff ff       	call   39e1 <test1_idle_default_handler+0x51>
    39e5:	83 f8 02             	cmp    $0x2,%eax
    39e8:	75 ea                	jne    39d4 <test1_idle_default_handler+0x44>
	{//IOCTL
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
    39ea:	b8 3a 02 00 00       	mov    $0x23a,%eax
    39ef:	e8 fc ff ff ff       	call   39f0 <test1_idle_default_handler+0x60>
		switch(fsm_ev_ioctrl_cmd())
    39f4:	e8 fc ff ff ff       	call   39f5 <test1_idle_default_handler+0x65>
    39f9:	83 f8 0b             	cmp    $0xb,%eax
    39fc:	0f 84 be 00 00 00    	je     3ac0 <test1_idle_default_handler+0x130>
    3a02:	83 f8 0c             	cmp    $0xc,%eax
    3a05:	74 6d                	je     3a74 <test1_idle_default_handler+0xe4>
    3a07:	83 f8 04             	cmp    $0x4,%eax
    3a0a:	74 4d                	je     3a59 <test1_idle_default_handler+0xc9>
    3a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		*/

		//
		default:
			ioctrl_handler();  	
    3a10:	e8 2b f0 ff ff       	call   2a40 <ioctrl_handler>
		break;
    3a15:	eb bd                	jmp    39d4 <test1_idle_default_handler+0x44>
    3a17:	90                   	nop
    3a18:	90                   	nop
    3a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("MAC:idle_default_handler");
	if(MAC_CLOSE)
    3a20:	e8 fc ff ff ff       	call   3a21 <test1_idle_default_handler+0x91>
    3a25:	83 f8 01             	cmp    $0x1,%eax
    3a28:	75 92                	jne    39bc <test1_idle_default_handler+0x2c>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3a2a:	b8 27 02 00 00       	mov    $0x227,%eax
    3a2f:	e8 fc ff ff ff       	call   3a30 <test1_idle_default_handler+0xa0>
		ue_mac_sv_close();
    3a34:	e8 77 ef ff ff       	call   29b0 <ue_mac_sv_close>
    3a39:	eb 81                	jmp    39bc <test1_idle_default_handler+0x2c>
    3a3b:	90                   	nop
    3a3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("MAC:IDLE receive a data packet from PHYadapter"); //testing code
    3a40:	b8 38 0d 00 00       	mov    $0xd38,%eax
    3a45:	e8 fc ff ff ff       	call   3a46 <test1_idle_default_handler+0xb6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3a4a:	e8 fc ff ff ff       	call   3a4b <test1_idle_default_handler+0xbb>
    3a4f:	e8 fc ff ff ff       	call   3a50 <test1_idle_default_handler+0xc0>
    3a54:	e9 71 ff ff ff       	jmp    39ca <test1_idle_default_handler+0x3a>
				fsm_data_destroy(tmpdata_ptr);//
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("MAC:IDLE receive a cra order ");
    3a59:	b8 9d 02 00 00       	mov    $0x29d,%eax
    3a5e:	e8 fc ff ff ff       	call   3a5f <test1_idle_default_handler+0xcf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//		
    3a63:	ba 02 00 00 00       	mov    $0x2,%edx
    3a68:	31 c0                	xor    %eax,%eax
    3a6a:	e8 fc ff ff ff       	call   3a6b <test1_idle_default_handler+0xdb>
		break;
    3a6f:	e9 60 ff ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;

		//PHYRA
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				tmpdata_ptr = fsm_data_get();
    3a74:	e8 fc ff ff ff       	call   3a75 <test1_idle_default_handler+0xe5>
    3a79:	89 c6                	mov    %eax,%esi
				print_tran_info("IDLE receive a ncra order ");
    3a7b:	b8 76 02 00 00       	mov    $0x276,%eax
    3a80:	e8 fc ff ff ff       	call   3a81 <test1_idle_default_handler+0xf1>
				fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    3a85:	b9 02 00 00 00       	mov    $0x2,%ecx
    3a8a:	89 f2                	mov    %esi,%edx
    3a8c:	8d 43 04             	lea    0x4(%ebx),%eax
    3a8f:	e8 fc ff ff ff       	call   3a90 <test1_idle_default_handler+0x100>
				fsm_printf("RAPID: %d \n",SV(RA_info.ra_PreambleIndex));		
    3a94:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    3a98:	c7 04 24 91 02 00 00 	movl   $0x291,(%esp)
    3a9f:	89 44 24 04          	mov    %eax,0x4(%esp)
    3aa3:	e8 fc ff ff ff       	call   3aa4 <test1_idle_default_handler+0x114>
				if(tmpdata_ptr != NULL)
    3aa8:	85 f6                	test   %esi,%esi
    3aaa:	0f 84 24 ff ff ff    	je     39d4 <test1_idle_default_handler+0x44>
				fsm_data_destroy(tmpdata_ptr);//
    3ab0:	89 f0                	mov    %esi,%eax
    3ab2:	e8 fc ff ff ff       	call   3ab3 <test1_idle_default_handler+0x123>
    3ab7:	e9 18 ff ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
    3abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3ac0:	e8 fc ff ff ff       	call   3ac1 <test1_idle_default_handler+0x131>
    3ac5:	89 c3                	mov    %eax,%ebx
			print_tran_info("MAC:IDLE receive a RLCdatareq");
    3ac7:	b8 58 02 00 00       	mov    $0x258,%eax
    3acc:	e8 fc ff ff ff       	call   3acd <test1_idle_default_handler+0x13d>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3ad1:	89 d8                	mov    %ebx,%eax
    3ad3:	e8 fc ff ff ff       	call   3ad4 <test1_idle_default_handler+0x144>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3ad8:	ba 02 00 00 00       	mov    $0x2,%edx
    3add:	31 c0                	xor    %eax,%eax
    3adf:	e8 fc ff ff ff       	call   3ae0 <test1_idle_default_handler+0x150>
		break;
    3ae4:	e9 eb fe ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
    3ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003af0 <test2_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test2_idle_default_handler()
{
    3af0:	55                   	push   %ebp
    3af1:	89 e5                	mov    %esp,%ebp
    3af3:	53                   	push   %ebx
    3af4:	e8 fc ff ff ff       	call   3af5 <test2_idle_default_handler+0x5>
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
    3af9:	e8 fc ff ff ff       	call   3afa <test2_idle_default_handler+0xa>
	print_tran_info("idle_default_handler");
    3afe:	b8 bb 02 00 00       	mov    $0x2bb,%eax
    3b03:	e8 fc ff ff ff       	call   3b04 <test2_idle_default_handler+0x14>
	if(MAC_CLOSE)
    3b08:	e8 fc ff ff ff       	call   3b09 <test2_idle_default_handler+0x19>
    3b0d:	83 f8 05             	cmp    $0x5,%eax
    3b10:	74 56                	je     3b68 <test2_idle_default_handler+0x78>
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3b12:	e8 fc ff ff ff       	call   3b13 <test2_idle_default_handler+0x23>
    3b17:	83 f8 02             	cmp    $0x2,%eax
    3b1a:	74 74                	je     3b90 <test2_idle_default_handler+0xa0>
    3b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3b20:	e8 fc ff ff ff       	call   3b21 <test2_idle_default_handler+0x31>
    3b25:	83 f8 05             	cmp    $0x5,%eax
    3b28:	74 06                	je     3b30 <test2_idle_default_handler+0x40>
			ioctrl_handler();
		break;
		}
	}
	FOUT;
}
    3b2a:	5b                   	pop    %ebx
    3b2b:	5d                   	pop    %ebp
    3b2c:	c3                   	ret    
    3b2d:	8d 76 00             	lea    0x0(%esi),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3b30:	e8 fc ff ff ff       	call   3b31 <test2_idle_default_handler+0x41>
    3b35:	83 f8 02             	cmp    $0x2,%eax
    3b38:	75 f0                	jne    3b2a <test2_idle_default_handler+0x3a>
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
    3b3a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
    3b3f:	e8 fc ff ff ff       	call   3b40 <test2_idle_default_handler+0x50>
		switch(fsm_ev_ioctrl_cmd())
    3b44:	e8 fc ff ff ff       	call   3b45 <test2_idle_default_handler+0x55>
    3b49:	83 f8 0b             	cmp    $0xb,%eax
    3b4c:	0f 84 96 00 00 00    	je     3be8 <test2_idle_default_handler+0xf8>
    3b52:	77 5c                	ja     3bb0 <test2_idle_default_handler+0xc0>
    3b54:	83 f8 04             	cmp    $0x4,%eax
    3b57:	74 70                	je     3bc9 <test2_idle_default_handler+0xd9>
    3b59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
		break;
		//do_ioctl
		//
		default:
			ioctrl_handler();
    3b60:	e8 db ee ff ff       	call   2a40 <ioctrl_handler>
		break;
    3b65:	eb c3                	jmp    3b2a <test2_idle_default_handler+0x3a>
    3b67:	90                   	nop
    3b68:	90                   	nop
    3b69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("idle_default_handler");
	if(MAC_CLOSE)
    3b70:	e8 fc ff ff ff       	call   3b71 <test2_idle_default_handler+0x81>
    3b75:	83 f8 01             	cmp    $0x1,%eax
    3b78:	75 98                	jne    3b12 <test2_idle_default_handler+0x22>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3b7a:	b8 27 02 00 00       	mov    $0x227,%eax
    3b7f:	e8 fc ff ff ff       	call   3b80 <test2_idle_default_handler+0x90>
		ue_mac_sv_close();
    3b84:	e8 27 ee ff ff       	call   29b0 <ue_mac_sv_close>
    3b89:	eb 87                	jmp    3b12 <test2_idle_default_handler+0x22>
    3b8b:	90                   	nop
    3b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("IDLE receive a data packet from PHYadapter"); //testing code
    3b90:	b8 68 0d 00 00       	mov    $0xd68,%eax
    3b95:	e8 fc ff ff ff       	call   3b96 <test2_idle_default_handler+0xa6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3b9a:	e8 fc ff ff ff       	call   3b9b <test2_idle_default_handler+0xab>
    3b9f:	e8 fc ff ff ff       	call   3ba0 <test2_idle_default_handler+0xb0>
    3ba4:	e9 73 ff ff ff       	jmp    3b1c <test2_idle_default_handler+0x2c>
    3ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
    3bb0:	83 f8 0c             	cmp    $0xc,%eax
    3bb3:	74 5c                	je     3c11 <test2_idle_default_handler+0x121>
    3bb5:	83 f8 31             	cmp    $0x31,%eax
    3bb8:	75 9f                	jne    3b59 <test2_idle_default_handler+0x69>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;
		//
		//PHYRA
		case NCRATEST:
				print_tran_info("IDLE receive a ncra test ");
    3bba:	b8 04 03 00 00       	mov    $0x304,%eax
    3bbf:	e8 fc ff ff ff       	call   3bc0 <test2_idle_default_handler+0xd0>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
    3bc4:	e9 61 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>
				print_tran_info("IDLE receive a ncra order ");
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("IDLE receive a cra order ");
    3bc9:	b8 1e 03 00 00       	mov    $0x31e,%eax
    3bce:	e8 fc ff ff ff       	call   3bcf <test2_idle_default_handler+0xdf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    3bd3:	ba 02 00 00 00       	mov    $0x2,%edx
    3bd8:	31 c0                	xor    %eax,%eax
    3bda:	e8 fc ff ff ff       	call   3bdb <test2_idle_default_handler+0xeb>
		break;
    3bdf:	e9 46 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>
    3be4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3be8:	e8 fc ff ff ff       	call   3be9 <test2_idle_default_handler+0xf9>
    3bed:	89 c3                	mov    %eax,%ebx
			print_tran_info("IDLE receive a RLCdatareq");
    3bef:	b8 ea 02 00 00       	mov    $0x2ea,%eax
    3bf4:	e8 fc ff ff ff       	call   3bf5 <test2_idle_default_handler+0x105>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3bf9:	89 d8                	mov    %ebx,%eax
    3bfb:	e8 fc ff ff ff       	call   3bfc <test2_idle_default_handler+0x10c>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3c00:	ba 02 00 00 00       	mov    $0x2,%edx
    3c05:	31 c0                	xor    %eax,%eax
    3c07:	e8 fc ff ff ff       	call   3c08 <test2_idle_default_handler+0x118>
		break;
    3c0c:	e9 19 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				print_tran_info("IDLE receive a ncra order ");
    3c11:	b8 76 02 00 00       	mov    $0x276,%eax
    3c16:	e8 fc ff ff ff       	call   3c17 <test2_idle_default_handler+0x127>
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
    3c1b:	e9 0a ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>

00003c20 <findInsByRbid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsByRbid(u8 rbid,void **up, void **down , RlcMode *mode)
{
    3c20:	55                   	push   %ebp
    3c21:	89 e5                	mov    %esp,%ebp
    3c23:	57                   	push   %edi
    3c24:	56                   	push   %esi
    3c25:	53                   	push   %ebx
    3c26:	83 ec 10             	sub    $0x10,%esp
    3c29:	e8 fc ff ff ff       	call   3c2a <findInsByRbid+0xa>
    3c2e:	8b 75 08             	mov    0x8(%ebp),%esi
    3c31:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3c34:	89 c3                	mov    %eax,%ebx
    3c36:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsByRbid());
	SV_PTR_GET(rlc_mac_sv);
    3c39:	e8 fc ff ff ff       	call   3c3a <findInsByRbid+0x1a>
	*up = *down = NULL;
    3c3e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3c44:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    3c4a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    3c50:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    3c56:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    3c5c:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    3c62:	39 d1                	cmp    %edx,%ecx
    3c64:	74 29                	je     3c8f <findInsByRbid+0x6f>
    3c66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3c69:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3c6c:	eb 08                	jmp    3c76 <findInsByRbid+0x56>
    3c6e:	66 90                	xchg   %ax,%ax
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3c70:	8b 12                	mov    (%edx),%edx
    3c72:	39 d1                	cmp    %edx,%ecx
    3c74:	74 16                	je     3c8c <findInsByRbid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->rbId == rbid)
    3c76:	38 5a e6             	cmp    %bl,-0x1a(%edx)
    3c79:	75 f5                	jne    3c70 <findInsByRbid+0x50>
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    3c7b:	8d 42 e4             	lea    -0x1c(%edx),%eax
    3c7e:	89 07                	mov    %eax,(%edi)
			if(tmTxIns->rbId == rbid)
			{
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
    3c80:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3c86:	8b 12                	mov    (%edx),%edx
    3c88:	39 d1                	cmp    %edx,%ecx
    3c8a:	75 ea                	jne    3c76 <findInsByRbid+0x56>
    3c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3c8f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    3c95:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    3c9b:	39 d1                	cmp    %edx,%ecx
    3c9d:	74 28                	je     3cc7 <findInsByRbid+0xa7>
    3c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3ca2:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3ca5:	eb 07                	jmp    3cae <findInsByRbid+0x8e>
    3ca7:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3ca8:	8b 12                	mov    (%edx),%edx
    3caa:	39 d1                	cmp    %edx,%ecx
    3cac:	74 16                	je     3cc4 <findInsByRbid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->rbId == rbid)
    3cae:	38 5a fa             	cmp    %bl,-0x6(%edx)
    3cb1:	75 f5                	jne    3ca8 <findInsByRbid+0x88>
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    3cb3:	8d 42 f8             	lea    -0x8(%edx),%eax
    3cb6:	89 07                	mov    %eax,(%edi)
			if(tmRxIns->rbId == rbid)
			{
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
    3cb8:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3cbe:	8b 12                	mov    (%edx),%edx
    3cc0:	39 d1                	cmp    %edx,%ecx
    3cc2:	75 ea                	jne    3cae <findInsByRbid+0x8e>
    3cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
			}
		}
	}
	if(*mode == TM_MODE)
    3cc7:	83 3e 01             	cmpl   $0x1,(%esi)
    3cca:	0f 84 c8 00 00 00    	je     3d98 <findInsByRbid+0x178>
    3cd0:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    3cd6:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    3cdc:	39 d1                	cmp    %edx,%ecx
    3cde:	74 27                	je     3d07 <findInsByRbid+0xe7>
    3ce0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3ce3:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3ce6:	eb 06                	jmp    3cee <findInsByRbid+0xce>
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3ce8:	8b 12                	mov    (%edx),%edx
    3cea:	39 d1                	cmp    %edx,%ecx
    3cec:	74 16                	je     3d04 <findInsByRbid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->rbid == rbid)
    3cee:	38 5a d2             	cmp    %bl,-0x2e(%edx)
    3cf1:	75 f5                	jne    3ce8 <findInsByRbid+0xc8>
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    3cf3:	8d 42 d0             	lea    -0x30(%edx),%eax
    3cf6:	89 07                	mov    %eax,(%edi)
			if(umTxIns->rbid == rbid)
			{
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
    3cf8:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3cfe:	8b 12                	mov    (%edx),%edx
    3d00:	39 d1                	cmp    %edx,%ecx
    3d02:	75 ea                	jne    3cee <findInsByRbid+0xce>
    3d04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3d07:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    3d0d:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    3d13:	39 d1                	cmp    %edx,%ecx
    3d15:	74 2e                	je     3d45 <findInsByRbid+0x125>
    3d17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d1a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d1d:	eb 07                	jmp    3d26 <findInsByRbid+0x106>
    3d1f:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3d20:	8b 12                	mov    (%edx),%edx
    3d22:	39 d1                	cmp    %edx,%ecx
    3d24:	74 1c                	je     3d42 <findInsByRbid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->rbId == rbid)
    3d26:	38 9a 3e ef ff ff    	cmp    %bl,-0x10c2(%edx)
    3d2c:	75 f2                	jne    3d20 <findInsByRbid+0x100>
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    3d2e:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
    3d34:	89 07                	mov    %eax,(%edi)
			if(umRxIns->rbId == rbid)
			{
				*down = (void*)umRxIns;
				*mode = UM_MODE;
    3d36:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3d3c:	8b 12                	mov    (%edx),%edx
    3d3e:	39 d1                	cmp    %edx,%ecx
    3d40:	75 e4                	jne    3d26 <findInsByRbid+0x106>
    3d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)umRxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(*mode == UM_MODE)
    3d45:	83 3e 02             	cmpl   $0x2,(%esi)
    3d48:	74 4e                	je     3d98 <findInsByRbid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    3d4a:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    3d50:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    3d56:	39 c2                	cmp    %eax,%edx
    3d58:	74 3e                	je     3d98 <findInsByRbid+0x178>
    3d5a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d5d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    3d60:	eb 0c                	jmp    3d6e <findInsByRbid+0x14e>
    3d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3d68:	8b 00                	mov    (%eax),%eax
    3d6a:	39 c2                	cmp    %eax,%edx
    3d6c:	74 2a                	je     3d98 <findInsByRbid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->rbId == rbid)
    3d6e:	38 98 fe dc ff ff    	cmp    %bl,-0x2302(%eax)
    3d74:	75 f2                	jne    3d68 <findInsByRbid+0x148>
			{
				*mode = AM_MODE;
    3d76:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    3d79:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->rbId == rbid)
			{
				*mode = AM_MODE;
    3d7f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    3d85:	8b 75 ec             	mov    -0x14(%ebp),%esi
    3d88:	89 0f                	mov    %ecx,(%edi)
    3d8a:	89 0e                	mov    %ecx,(%esi)
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3d8c:	8b 00                	mov    (%eax),%eax
    3d8e:	39 c2                	cmp    %eax,%edx
    3d90:	75 dc                	jne    3d6e <findInsByRbid+0x14e>
    3d92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				*up = *down =  (void*)amIns;
			}
		}
	}
	FOUT;
}
    3d98:	83 c4 10             	add    $0x10,%esp
    3d9b:	5b                   	pop    %ebx
    3d9c:	5e                   	pop    %esi
    3d9d:	5f                   	pop    %edi
    3d9e:	5d                   	pop    %ebp
    3d9f:	c3                   	ret    

00003da0 <rlc_pkt_receive_from_upper>:
**--------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
static void rlc_pkt_receive_from_upper(void)
{
    3da0:	55                   	push   %ebp
    3da1:	89 e5                	mov    %esp,%ebp
    3da3:	57                   	push   %edi
    3da4:	56                   	push   %esi
    3da5:	53                   	push   %ebx
    3da6:	83 ec 24             	sub    $0x24,%esp
    3da9:	e8 fc ff ff ff       	call   3daa <rlc_pkt_receive_from_upper+0xa>
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	
    3dae:	e8 fc ff ff ff       	call   3daf <rlc_pkt_receive_from_upper+0xf>
    3db3:	89 c3                	mov    %eax,%ebx

	skb = (FSM_PKT *)fsm_pkt_get();
    3db5:	e8 fc ff ff ff       	call   3db6 <rlc_pkt_receive_from_upper+0x16>
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
    3dba:	8b b8 a8 00 00 00    	mov    0xa8(%eax),%edi
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	

	skb = (FSM_PKT *)fsm_pkt_get();
    3dc0:	89 c6                	mov    %eax,%esi
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
	fsm_printf("[RLC][rlc_pkt_receive_from_upper][-->] receive from upper, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
    3dc2:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    3dc6:	89 44 24 08          	mov    %eax,0x8(%esp)
    3dca:	0f b6 07             	movzbl (%edi),%eax
    3dcd:	c7 04 24 94 0d 00 00 	movl   $0xd94,(%esp)
    3dd4:	89 44 24 04          	mov    %eax,0x4(%esp)
    3dd8:	e8 fc ff ff ff       	call   3dd9 <rlc_pkt_receive_from_upper+0x39>
	fsm_octets_print(skb->data,64);
    3ddd:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    3de3:	ba 40 00 00 00       	mov    $0x40,%edx
    3de8:	e8 fc ff ff ff       	call   3de9 <rlc_pkt_receive_from_upper+0x49>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    3ded:	80 3f 00             	cmpb   $0x0,(%edi)
    3df0:	0f 85 13 02 00 00    	jne    4009 <rlc_pkt_receive_from_upper+0x269>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    3df6:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    3dfa:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    3e00:	89 14 24             	mov    %edx,(%esp)
    3e03:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    3e06:	8d 55 ec             	lea    -0x14(%ebp),%edx
    3e09:	e8 fc ff ff ff       	call   3e0a <rlc_pkt_receive_from_upper+0x6a>
		fsm_printf("[RLC_MAC][rlc_pkt_receive_from_upper]ins_mode is: %d\n", SV(ins_mode));
    3e0e:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    3e14:	c7 04 24 e4 0d 00 00 	movl   $0xde4,(%esp)
    3e1b:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e1f:	e8 fc ff ff ff       	call   3e20 <rlc_pkt_receive_from_upper+0x80>
		switch(SV(ins_mode))
    3e24:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    3e2a:	83 f8 02             	cmp    $0x2,%eax
    3e2d:	0f 84 35 01 00 00    	je     3f68 <rlc_pkt_receive_from_upper+0x1c8>
    3e33:	83 f8 03             	cmp    $0x3,%eax
    3e36:	0f 84 8c 00 00 00    	je     3ec8 <rlc_pkt_receive_from_upper+0x128>
    3e3c:	83 f8 01             	cmp    $0x1,%eax
    3e3f:	74 47                	je     3e88 <rlc_pkt_receive_from_upper+0xe8>
				//fsm_printf("[RLC][rlc_pkt_receive_from_upper][TM] bufferReqTimer is runing\n");
			}*/
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    3e41:	83 83 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%ebx)
			printk("[RLC][rlc_pkt_receive_from_upper] cannot distinfuish this %d\n", SV(ins_mode));
    3e48:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e4c:	c7 04 24 10 10 00 00 	movl   $0x1010,(%esp)
    3e53:	e8 fc ff ff ff       	call   3e54 <rlc_pkt_receive_from_upper+0xb4>
			printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    3e58:	8b 83 9c 5a 00 00    	mov    0x5a9c(%ebx),%eax
    3e5e:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    3e65:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e69:	e8 fc ff ff ff       	call   3e6a <rlc_pkt_receive_from_upper+0xca>
			
			break;
		}
		
		if(skb != NULL)
    3e6e:	85 f6                	test   %esi,%esi
    3e70:	74 07                	je     3e79 <rlc_pkt_receive_from_upper+0xd9>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    3e72:	89 f0                	mov    %esi,%eax
    3e74:	e8 fc ff ff ff       	call   3e75 <rlc_pkt_receive_from_upper+0xd5>
		skb = NULL;
		FOUT;
	}
}
    3e79:	83 c4 24             	add    $0x24,%esp
    3e7c:	5b                   	pop    %ebx
    3e7d:	5e                   	pop    %esi
    3e7e:	5f                   	pop    %edi
    3e7f:	5d                   	pop    %ebp
    3e80:	c3                   	ret    
    3e81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}*/
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    3e88:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    3e8b:	85 db                	test   %ebx,%ebx
    3e8d:	0f 84 a4 01 00 00    	je     4037 <rlc_pkt_receive_from_upper+0x297>
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    3e93:	b8 0c 00 00 00       	mov    $0xc,%eax
    3e98:	e8 fc ff ff ff       	call   3e99 <rlc_pkt_receive_from_upper+0xf9>
			tmElm->pkt = skb;
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    3e9d:	8d 7b 0c             	lea    0xc(%ebx),%edi
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
			tmElm->pkt = skb;
    3ea0:	89 30                	mov    %esi,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3ea2:	8b 53 10             	mov    0x10(%ebx),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    3ea5:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3ea8:	89 4b 10             	mov    %ecx,0x10(%ebx)
    3eab:	89 78 04             	mov    %edi,0x4(%eax)
	new->next = next;
	new->prev = prev;
    3eae:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    3eb1:	89 0a                	mov    %ecx,(%edx)
			tmTxIns->tmSduBufferNum++;
    3eb3:	83 43 18 01          	addl   $0x1,0x18(%ebx)
			tmTxIns->tmSduBufferSize += skb->len;
    3eb7:	8b 46 50             	mov    0x50(%esi),%eax
    3eba:	01 43 14             	add    %eax,0x14(%ebx)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    3ebd:	83 c4 24             	add    $0x24,%esp
    3ec0:	5b                   	pop    %ebx
    3ec1:	5e                   	pop    %esi
    3ec2:	5f                   	pop    %edi
    3ec3:	5d                   	pop    %ebp
    3ec4:	c3                   	ret    
    3ec5:	8d 76 00             	lea    0x0(%esi),%esi
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][rlc_pkt_receive_from_upper]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    3ec8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3ecb:	85 c0                	test   %eax,%eax
    3ecd:	0f 84 7d 01 00 00    	je     4050 <rlc_pkt_receive_from_upper+0x2b0>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    3ed3:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    3ed7:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    3eda:	66 83 fa 0b          	cmp    $0xb,%dx
    3ede:	0f 84 85 01 00 00    	je     4069 <rlc_pkt_receive_from_upper+0x2c9>
    3ee4:	66 83 fa 09          	cmp    $0x9,%dx
    3ee8:	0f 84 7b 01 00 00    	je     4069 <rlc_pkt_receive_from_upper+0x2c9>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    3eee:	b8 14 00 00 00       	mov    $0x14,%eax
    3ef3:	e8 fc ff ff ff       	call   3ef4 <rlc_pkt_receive_from_upper+0x154>
			/*mallocnum++;
			if(mallocnum%25==0)
			{
				printk("RLC ALLOC: %d\n", mallocnum);
			}*/
			amElm->pkt = skb;
    3ef8:	89 30                	mov    %esi,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    3efa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3efd:	8d 58 0c             	lea    0xc(%eax),%ebx
			if(mallocnum%25==0)
			{
				printk("RLC ALLOC: %d\n", mallocnum);
			}*/
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    3f00:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    3f07:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3f0e:	8b 4a 48             	mov    0x48(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3f11:	89 5a 48             	mov    %ebx,0x48(%edx)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    3f14:	83 c2 44             	add    $0x44,%edx
    3f17:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    3f1a:	89 48 10             	mov    %ecx,0x10(%eax)
	prev->next = new;
    3f1d:	89 19                	mov    %ebx,(%ecx)
			fsm_printf("[RLC][rlc_pkt_receive_from_upper]AM_MODE list_add done!\n");
    3f1f:	c7 04 24 ac 0e 00 00 	movl   $0xeac,(%esp)
    3f26:	e8 fc ff ff ff       	call   3f27 <rlc_pkt_receive_from_upper+0x187>
			fsm_printf("[RLC][rlc_pkt_receive_from_upper] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    3f2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3f2e:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    3f32:	89 54 24 0c          	mov    %edx,0xc(%esp)
    3f36:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3f3a:	c7 04 24 e8 0e 00 00 	movl   $0xee8,(%esp)
    3f41:	89 44 24 08          	mov    %eax,0x8(%esp)
    3f45:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3f48:	89 44 24 04          	mov    %eax,0x4(%esp)
    3f4c:	e8 fc ff ff ff       	call   3f4d <rlc_pkt_receive_from_upper+0x1ad>
			amIns->amSduBufferSize += skb->len;
    3f51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3f54:	8b 56 50             	mov    0x50(%esi),%edx
    3f57:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    3f5a:	83 40 50 01          	addl   $0x1,0x50(%eax)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    3f5e:	83 c4 24             	add    $0x24,%esp
    3f61:	5b                   	pop    %ebx
    3f62:	5e                   	pop    %esi
    3f63:	5f                   	pop    %edi
    3f64:	5d                   	pop    %ebp
    3f65:	c3                   	ret    
    3f66:	66 90                	xchg   %ax,%ax
			}*/
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    3f68:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3f6b:	85 d2                	test   %edx,%edx
    3f6d:	0f 84 c4 00 00 00    	je     4037 <rlc_pkt_receive_from_upper+0x297>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    3f73:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    3f77:	3c 0b                	cmp    $0xb,%al
    3f79:	74 04                	je     3f7f <rlc_pkt_receive_from_upper+0x1df>
    3f7b:	3c 09                	cmp    $0x9,%al
    3f7d:	75 19                	jne    3f98 <rlc_pkt_receive_from_upper+0x1f8>
			{
				fsm_printf("[RLC][rlc_pkt_receive_from_upper][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    3f7f:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    3f83:	c7 04 24 88 0f 00 00 	movl   $0xf88,(%esp)
    3f8a:	89 44 24 04          	mov    %eax,0x4(%esp)
    3f8e:	e8 fc ff ff ff       	call   3f8f <rlc_pkt_receive_from_upper+0x1ef>
				break;
    3f93:	e9 d6 fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    3f98:	b8 18 00 00 00       	mov    $0x18,%eax
    3f9d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    3fa0:	e8 fc ff ff ff       	call   3fa1 <rlc_pkt_receive_from_upper+0x201>
			umElm->pkt = skb;
    3fa5:	89 30                	mov    %esi,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    3fa7:	8d 78 10             	lea    0x10(%eax),%edi
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    3faa:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    3fb1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3fb8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3fbb:	8b 4a 1c             	mov    0x1c(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3fbe:	89 7a 1c             	mov    %edi,0x1c(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3fc1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    3fc4:	8d 4a 18             	lea    0x18(%edx),%ecx
    3fc7:	89 48 10             	mov    %ecx,0x10(%eax)
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    3fca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    3fcd:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    3fd0:	89 39                	mov    %edi,(%ecx)
			fsm_printf("[RLC][rlc_pkt_receive_from_upper]UM_MODE list_add done!\n");
    3fd2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    3fd5:	c7 04 24 d4 0f 00 00 	movl   $0xfd4,(%esp)
    3fdc:	e8 fc ff ff ff       	call   3fdd <rlc_pkt_receive_from_upper+0x23d>
			
			umTxIns->umSduBufferNum++;
    3fe1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3fe4:	8b 42 24             	mov    0x24(%edx),%eax
    3fe7:	83 c0 01             	add    $0x1,%eax
    3fea:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    3fed:	3b 83 a8 5a 00 00    	cmp    0x5aa8(%ebx),%eax
    3ff3:	76 06                	jbe    3ffb <rlc_pkt_receive_from_upper+0x25b>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    3ff5:	89 83 a8 5a 00 00    	mov    %eax,0x5aa8(%ebx)
			}
			umTxIns->umSduBufferSize += skb->len;
    3ffb:	8b 46 50             	mov    0x50(%esi),%eax
    3ffe:	01 42 20             	add    %eax,0x20(%edx)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    4001:	83 c4 24             	add    $0x24,%esp
    4004:	5b                   	pop    %ebx
    4005:	5e                   	pop    %esi
    4006:	5f                   	pop    %edi
    4007:	5d                   	pop    %ebp
    4008:	c3                   	ret    
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    4009:	83 83 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%ebx)
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
    4010:	c7 04 24 9c 10 00 00 	movl   $0x109c,(%esp)
    4017:	e8 fc ff ff ff       	call   4018 <rlc_pkt_receive_from_upper+0x278>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    401c:	8b 83 9c 5a 00 00    	mov    0x5a9c(%ebx),%eax
    4022:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    4029:	89 44 24 04          	mov    %eax,0x4(%esp)
    402d:	e8 fc ff ff ff       	call   402e <rlc_pkt_receive_from_upper+0x28e>
    4032:	e9 3b fe ff ff       	jmp    3e72 <rlc_pkt_receive_from_upper+0xd2>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    4037:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    403b:	c7 04 24 3c 0f 00 00 	movl   $0xf3c,(%esp)
    4042:	89 44 24 04          	mov    %eax,0x4(%esp)
    4046:	e8 fc ff ff ff       	call   4047 <rlc_pkt_receive_from_upper+0x2a7>
				break;
    404b:	e9 1e fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    4050:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    4054:	c7 04 24 1c 0e 00 00 	movl   $0xe1c,(%esp)
    405b:	89 44 24 04          	mov    %eax,0x4(%esp)
    405f:	e8 fc ff ff ff       	call   4060 <rlc_pkt_receive_from_upper+0x2c0>
				break;
    4064:	e9 05 fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    4069:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    406d:	c7 04 24 60 0e 00 00 	movl   $0xe60,(%esp)
    4074:	89 44 24 04          	mov    %eax,0x4(%esp)
    4078:	e8 fc ff ff ff       	call   4079 <rlc_pkt_receive_from_upper+0x2d9>
				break;
    407d:	e9 ec fd ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
    4082:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    4089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00004090 <rlc_mac_main>:
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
    4090:	55                   	push   %ebp
    4091:	89 e5                	mov    %esp,%ebp
    4093:	83 ec 3c             	sub    $0x3c,%esp
    4096:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    4099:	89 75 f8             	mov    %esi,-0x8(%ebp)
    409c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    409f:	e8 fc ff ff ff       	call   40a0 <rlc_mac_main+0x10>
	FSM_ENTER(rlc_mac_main);
    40a4:	e8 fc ff ff ff       	call   40a5 <rlc_mac_main+0x15>
	FSM_BLOCK_SWITCH
    40a9:	83 38 19             	cmpl   $0x19,(%eax)
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
    40ac:	89 c6                	mov    %eax,%esi
	FSM_BLOCK_SWITCH
    40ae:	76 18                	jbe    40c8 <rlc_mac_main+0x38>
		FSM_STATE_FORCED(ST_NULL_IDLE, "NULL_IDLE", , )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
    40b0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
    40b6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    40b9:	8b 75 f8             	mov    -0x8(%ebp),%esi
    40bc:	8b 7d fc             	mov    -0x4(%ebp),%edi
    40bf:	89 ec                	mov    %ebp,%esp
    40c1:	5d                   	pop    %ebp
    40c2:	c3                   	ret    
    40c3:	90                   	nop
    40c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
    40c8:	8b 00                	mov    (%eax),%eax
    40ca:	ff 24 85 00 03 00 00 	jmp    *0x300(,%eax,4)
    40d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    40d8:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    40df:	03 00 00 
		{
			FSM_COND_TEST_IN("IDLE")				
    40e2:	31 db                	xor    %ebx,%ebx
    40e4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    40e9:	e8 fc ff ff ff       	call   40ea <rlc_mac_main+0x5a>
    40ee:	83 f8 03             	cmp    $0x3,%eax
    40f1:	0f 84 c4 0f 00 00    	je     50bb <rlc_mac_main+0x102b>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    40f7:	e8 fc ff ff ff       	call   40f8 <rlc_mac_main+0x68>
    40fc:	83 f8 03             	cmp    $0x3,%eax
    40ff:	90                   	nop
    4100:	0f 84 9a 0f 00 00    	je     50a0 <rlc_mac_main+0x1010>
				FSM_TEST_COND(MAC_RESET)
    4106:	e8 fc ff ff ff       	call   4107 <rlc_mac_main+0x77>
    410b:	83 f8 05             	cmp    $0x5,%eax
    410e:	66 90                	xchg   %ax,%ax
    4110:	0f 84 5d 0f 00 00    	je     5073 <rlc_mac_main+0xfe3>
				
				FSM_TEST_COND(RLC_SUSPEND)
    4116:	e8 fc ff ff ff       	call   4117 <rlc_mac_main+0x87>
    411b:	83 f8 03             	cmp    $0x3,%eax
    411e:	66 90                	xchg   %ax,%ax
    4120:	0f 84 32 0f 00 00    	je     5058 <rlc_mac_main+0xfc8>
				FSM_TEST_COND(RLC_DEACT)
    4126:	e8 fc ff ff ff       	call   4127 <rlc_mac_main+0x97>
    412b:	83 f8 03             	cmp    $0x3,%eax
    412e:	66 90                	xchg   %ax,%ax
    4130:	0f 84 a9 0e 00 00    	je     4fdf <rlc_mac_main+0xf4f>
				FSM_TEST_COND(RLC_RESUME)
    4136:	e8 fc ff ff ff       	call   4137 <rlc_mac_main+0xa7>
    413b:	83 f8 03             	cmp    $0x3,%eax
    413e:	66 90                	xchg   %ax,%ax
    4140:	0f 84 7e 0e 00 00    	je     4fc4 <rlc_mac_main+0xf34>
			FSM_COND_TEST_OUT("IDLE")
    4146:	83 fb 01             	cmp    $0x1,%ebx
    4149:	0f 8e 21 08 00 00    	jle    4970 <rlc_mac_main+0x8e0>
    414f:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    4156:	00 
    4157:	c7 44 24 04 4f 03 00 	movl   $0x34f,0x4(%esp)
    415e:	00 
    415f:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    4166:	e8 fc ff ff ff       	call   4167 <rlc_mac_main+0xd7>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    416b:	c7 05 30 00 00 00 86 	movl   $0x386,0x30
    4172:	03 00 00 
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4175:	e8 fc ff ff ff       	call   4176 <rlc_mac_main+0xe6>
    417a:	89 c7                	mov    %eax,%edi
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code
    417c:	b8 48 11 00 00       	mov    $0x1148,%eax
    4181:	e8 fc ff ff ff       	call   4182 <rlc_mac_main+0xf2>

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    4186:	e8 fc ff ff ff       	call   4187 <rlc_mac_main+0xf7>
    418b:	83 f8 05             	cmp    $0x5,%eax
    418e:	0f 84 b6 13 00 00    	je     554a <rlc_mac_main+0x14ba>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    4194:	e8 fc ff ff ff       	call   4195 <rlc_mac_main+0x105>
    4199:	83 f8 05             	cmp    $0x5,%eax
    419c:	0f 84 69 14 00 00    	je     560b <rlc_mac_main+0x157b>
	{
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    41a2:	e8 fc ff ff ff       	call   41a3 <rlc_mac_main+0x113>
    41a7:	83 f8 02             	cmp    $0x2,%eax
    41aa:	0f 84 22 14 00 00    	je     55d2 <rlc_mac_main+0x1542>
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    41b0:	e8 fc ff ff ff       	call   41b1 <rlc_mac_main+0x121>
    41b5:	83 f8 01             	cmp    $0x1,%eax
    41b8:	0f 84 df 15 00 00    	je     579d <rlc_mac_main+0x170d>
    41be:	66 90                	xchg   %ax,%ax
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    41c0:	e8 fc ff ff ff       	call   41c1 <rlc_mac_main+0x131>
    41c5:	83 f8 03             	cmp    $0x3,%eax
    41c8:	0f 84 50 17 00 00    	je     591e <rlc_mac_main+0x188e>
    41ce:	66 90                	xchg   %ax,%ax
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    41d0:	e8 fc ff ff ff       	call   41d1 <rlc_mac_main+0x141>
    41d5:	83 f8 03             	cmp    $0x3,%eax
    41d8:	0f 84 d6 17 00 00    	je     59b4 <rlc_mac_main+0x1924>
    41de:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
    41e0:	e8 fc ff ff ff       	call   41e1 <rlc_mac_main+0x151>
    41e5:	83 f8 03             	cmp    $0x3,%eax
    41e8:	0f 84 85 17 00 00    	je     5973 <rlc_mac_main+0x18e3>
    41ee:	66 90                	xchg   %ax,%ax
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    41f0:	e8 fc ff ff ff       	call   41f1 <rlc_mac_main+0x161>
    41f5:	83 f8 05             	cmp    $0x5,%eax
    41f8:	0f 85 8b 1f 00 00    	jne    6189 <rlc_mac_main+0x20f9>
    41fe:	66 90                	xchg   %ax,%ax
    4200:	e8 fc ff ff ff       	call   4201 <rlc_mac_main+0x171>
    4205:	83 f8 02             	cmp    $0x2,%eax
    4208:	0f 85 7b 1f 00 00    	jne    6189 <rlc_mac_main+0x20f9>
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
    420e:	b8 50 13 00 00       	mov    $0x1350,%eax
    4213:	e8 fc ff ff ff       	call   4214 <rlc_mac_main+0x184>
		u32 cmd1=fsm_ev_ioctrl_cmd();
    4218:	e8 fc ff ff ff       	call   4219 <rlc_mac_main+0x189>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
    421d:	89 44 24 04          	mov    %eax,0x4(%esp)
    4221:	c7 04 24 91 03 00 00 	movl   $0x391,(%esp)
    4228:	e8 fc ff ff ff       	call   4229 <rlc_mac_main+0x199>
		switch(fsm_ev_ioctrl_cmd())
    422d:	e8 fc ff ff ff       	call   422e <rlc_mac_main+0x19e>
    4232:	83 f8 0b             	cmp    $0xb,%eax
    4235:	0f 84 52 1a 00 00    	je     5c8d <rlc_mac_main+0x1bfd>
    423b:	90                   	nop
    423c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4240:	0f 87 99 17 00 00    	ja     59df <rlc_mac_main+0x194f>
    4246:	83 f8 04             	cmp    $0x4,%eax
    4249:	0f 84 be 1a 00 00    	je     5d0d <rlc_mac_main+0x1c7d>
    424f:	90                   	nop
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
				fsm_data_destroy(tmpdata_ptr);
			break;
			default:
				ioctrl_handler();
    4250:	e8 eb e7 ff ff       	call   2a40 <ioctrl_handler>
			break;
		}
		reports_handler();//BSR PHR 
    4255:	e8 c6 ee ff ff       	call   3120 <reports_handler>
    425a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    4260:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4266:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4269:	8b 75 f8             	mov    -0x8(%ebp),%esi
    426c:	8b 7d fc             	mov    -0x4(%ebp),%edi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    426f:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    4276:	03 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4279:	89 ec                	mov    %ebp,%esp
    427b:	5d                   	pop    %ebp
    427c:	c3                   	ret    
    427d:	8b 75 dc             	mov    -0x24(%ebp),%esi
			do_bsr_and_resource_alloc();	//this function should in while loop or not? this a question
		}
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
    4280:	e8 fc ff ff ff       	call   4281 <rlc_mac_main+0x1f1>
    4285:	83 f8 02             	cmp    $0x2,%eax
    4288:	0f 84 5d 1f 00 00    	je     61eb <rlc_mac_main+0x215b>
		}
		decomplexUeDataPdu(skb);
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    428e:	e8 fc ff ff ff       	call   428f <rlc_mac_main+0x1ff>
    4293:	83 f8 01             	cmp    $0x1,%eax
    4296:	0f 84 89 13 00 00    	je     5625 <rlc_mac_main+0x1595>
    429c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    42a0:	e8 fc ff ff ff       	call   42a1 <rlc_mac_main+0x211>
    42a5:	83 f8 03             	cmp    $0x3,%eax
    42a8:	0f 84 c7 15 00 00    	je     5875 <rlc_mac_main+0x17e5>
    42ae:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
    42b0:	e8 fc ff ff ff       	call   42b1 <rlc_mac_main+0x221>
    42b5:	83 f8 03             	cmp    $0x3,%eax
    42b8:	0f 84 6e 15 00 00    	je     582c <rlc_mac_main+0x179c>
    42be:	66 90                	xchg   %ax,%ax
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
	}
	else if(IOCTRL_ARRIVAL)
    42c0:	e8 fc ff ff ff       	call   42c1 <rlc_mac_main+0x231>
    42c5:	83 f8 05             	cmp    $0x5,%eax
    42c8:	0f 85 f1 1f 00 00    	jne    62bf <rlc_mac_main+0x222f>
    42ce:	66 90                	xchg   %ax,%ax
    42d0:	e8 fc ff ff ff       	call   42d1 <rlc_mac_main+0x241>
    42d5:	83 f8 02             	cmp    $0x2,%eax
    42d8:	0f 85 e1 1f 00 00    	jne    62bf <rlc_mac_main+0x222f>
    42de:	66 90                	xchg   %ax,%ax
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
    42e0:	e8 fc ff ff ff       	call   42e1 <rlc_mac_main+0x251>
    42e5:	83 f8 0b             	cmp    $0xb,%eax
    42e8:	0f 84 26 17 00 00    	je     5a14 <rlc_mac_main+0x1984>
    42ee:	66 90                	xchg   %ax,%ax
			//RLCdatareqMAC reqregularBSR 
			//SR RLCreq
			//MACSR  
		}
		else 
			ioctrl_handler();  //ioctrl		
    42f0:	e8 4b e7 ff ff       	call   2a40 <ioctrl_handler>
		print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
    42f5:	b8 d8 1f 00 00       	mov    $0x1fd8,%eax
    42fa:	e8 fc ff ff ff       	call   42fb <rlc_mac_main+0x26b>
		reports_handler();//BSR PHR cut to this domian 20150910
    42ff:	e8 1c ee ff ff       	call   3120 <reports_handler>
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
	}
	//fsm_printf("[RLC_MAC][con_default_handler][end]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	fsm_mem_free(pdu_type);
    4304:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4307:	e8 fc ff ff ff       	call   4308 <rlc_mac_main+0x278>
    430c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    4310:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4316:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4319:	8b 75 f8             	mov    -0x8(%ebp),%esi
    431c:	8b 7d fc             	mov    -0x4(%ebp),%edi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    431f:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    4326:	04 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4329:	89 ec                	mov    %ebp,%esp
    432b:	5d                   	pop    %ebp
    432c:	c3                   	ret    
    432d:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    4330:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    4337:	03 00 00 
		{
			FSM_COND_TEST_IN("CRA")
    433a:	31 db                	xor    %ebx,%ebx
    433c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4341:	e8 fc ff ff ff       	call   4342 <rlc_mac_main+0x2b2>
    4346:	83 f8 03             	cmp    $0x3,%eax
    4349:	0f 84 e2 0b 00 00    	je     4f31 <rlc_mac_main+0xea1>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    434f:	e8 fc ff ff ff       	call   4350 <rlc_mac_main+0x2c0>
    4354:	83 f8 03             	cmp    $0x3,%eax
    4357:	0f 84 63 0a 00 00    	je     4dc0 <rlc_mac_main+0xd30>
    435d:	8d 76 00             	lea    0x0(%esi),%esi
    4360:	e8 fc ff ff ff       	call   4361 <rlc_mac_main+0x2d1>
    4365:	83 f8 03             	cmp    $0x3,%eax
    4368:	0f 84 92 0a 00 00    	je     4e00 <rlc_mac_main+0xd70>
    436e:	66 90                	xchg   %ax,%ax
    4370:	e8 fc ff ff ff       	call   4371 <rlc_mac_main+0x2e1>
    4375:	83 f8 05             	cmp    $0x5,%eax
    4378:	0f 84 2a 0f 00 00    	je     52a8 <rlc_mac_main+0x1218>
    437e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RARREV_SUCCESS)
    4380:	e8 fc ff ff ff       	call   4381 <rlc_mac_main+0x2f1>
    4385:	83 f8 03             	cmp    $0x3,%eax
    4388:	0f 84 12 0a 00 00    	je     4da0 <rlc_mac_main+0xd10>
    438e:	66 90                	xchg   %ax,%ax
    4390:	e8 fc ff ff ff       	call   4391 <rlc_mac_main+0x301>
    4395:	83 f8 05             	cmp    $0x5,%eax
    4398:	0f 84 aa 0d 00 00    	je     5148 <rlc_mac_main+0x10b8>
    439e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(CONTENTION_FAIL)
    43a0:	e8 fc ff ff ff       	call   43a1 <rlc_mac_main+0x311>
    43a5:	83 f8 03             	cmp    $0x3,%eax
    43a8:	0f 84 d2 09 00 00    	je     4d80 <rlc_mac_main+0xcf0>
    43ae:	66 90                	xchg   %ax,%ax
    43b0:	e8 fc ff ff ff       	call   43b1 <rlc_mac_main+0x321>
    43b5:	83 f8 03             	cmp    $0x3,%eax
    43b8:	0f 84 7a 0a 00 00    	je     4e38 <rlc_mac_main+0xda8>
    43be:	66 90                	xchg   %ax,%ax
    43c0:	e8 fc ff ff ff       	call   43c1 <rlc_mac_main+0x331>
    43c5:	83 f8 05             	cmp    $0x5,%eax
    43c8:	0f 84 b8 0e 00 00    	je     5286 <rlc_mac_main+0x11f6>
    43ce:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(CONTENTION_SUCCESS)
    43d0:	e8 fc ff ff ff       	call   43d1 <rlc_mac_main+0x341>
    43d5:	83 f8 03             	cmp    $0x3,%eax
    43d8:	0f 84 82 09 00 00    	je     4d60 <rlc_mac_main+0xcd0>
    43de:	66 90                	xchg   %ax,%ax
    43e0:	e8 fc ff ff ff       	call   43e1 <rlc_mac_main+0x351>
    43e5:	83 f8 05             	cmp    $0x5,%eax
    43e8:	0f 84 35 0d 00 00    	je     5123 <rlc_mac_main+0x1093>
    43ee:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(MAC_RESET)
    43f0:	e8 fc ff ff ff       	call   43f1 <rlc_mac_main+0x361>
    43f5:	83 f8 05             	cmp    $0x5,%eax
    43f8:	0f 84 2a 0c 00 00    	je     5028 <rlc_mac_main+0xf98>
			FSM_COND_TEST_OUT("CRA")
    43fe:	83 fb 01             	cmp    $0x1,%ebx
    4401:	0f 8e 21 06 00 00    	jle    4a28 <rlc_mac_main+0x998>
    4407:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    440e:	00 
    440f:	c7 44 24 04 a7 03 00 	movl   $0x3a7,0x4(%esp)
    4416:	00 
    4417:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    441e:	e8 fc ff ff ff       	call   441f <rlc_mac_main+0x38f>
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
				FSM_CASE_DEFAULT(ST_CRA,cra_default_handler() , "CRA->CRA")	//transit to CRA state	by default.
    4423:	c7 05 30 00 00 00 cd 	movl   $0x3cd,0x30
    442a:	03 00 00 
{
	void *tmpdata_ptr;
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    442d:	e8 fc ff ff ff       	call   442e <rlc_mac_main+0x39e>
    4432:	89 c3                	mov    %eax,%ebx

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    4434:	b8 01 00 00 00       	mov    $0x1,%eax
    4439:	e8 fc ff ff ff       	call   443a <rlc_mac_main+0x3aa>
	fsm_mem_set(pdu_type,0,sizeof(char));
    443e:	31 d2                	xor    %edx,%edx
    4440:	b9 01 00 00 00       	mov    $0x1,%ecx
	u32 tmpdata;
	FSM_PKT* skb;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
    4445:	89 c7                	mov    %eax,%edi
	fsm_mem_set(pdu_type,0,sizeof(char));
    4447:	e8 fc ff ff ff       	call   4448 <rlc_mac_main+0x3b8>

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    444c:	83 bb ec 01 00 00 01 	cmpl   $0x1,0x1ec(%ebx)
    4453:	0f 84 13 11 00 00    	je     556c <rlc_mac_main+0x14dc>
		fsm_schedule_self(0, Contention_Success );//TEST  
	if(MAC_CLOSE)
    4459:	e8 fc ff ff ff       	call   445a <rlc_mac_main+0x3ca>
    445e:	83 f8 05             	cmp    $0x5,%eax
    4461:	0f 84 20 11 00 00    	je     5587 <rlc_mac_main+0x14f7>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    4467:	e8 fc ff ff ff       	call   4468 <rlc_mac_main+0x3d8>
    446c:	83 f8 02             	cmp    $0x2,%eax
    446f:	90                   	nop
    4470:	0f 84 09 1f 00 00    	je     637f <rlc_mac_main+0x22ef>
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_pkt_destroy(fsm_pkt_get());
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
    4476:	e8 fc ff ff ff       	call   4477 <rlc_mac_main+0x3e7>
    447b:	83 f8 01             	cmp    $0x1,%eax
    447e:	66 90                	xchg   %ax,%ax
    4480:	0f 84 82 12 00 00    	je     5708 <rlc_mac_main+0x1678>
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4486:	e8 fc ff ff ff       	call   4487 <rlc_mac_main+0x3f7>
    448b:	83 f8 03             	cmp    $0x3,%eax
    448e:	66 90                	xchg   %ax,%ax
    4490:	0f 84 46 12 00 00    	je     56dc <rlc_mac_main+0x164c>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    4496:	e8 fc ff ff ff       	call   4497 <rlc_mac_main+0x407>
    449b:	83 f8 05             	cmp    $0x5,%eax
    449e:	66 90                	xchg   %ax,%ax
    44a0:	75 26                	jne    44c8 <rlc_mac_main+0x438>
    44a2:	e8 fc ff ff ff       	call   44a3 <rlc_mac_main+0x413>
    44a7:	83 f8 02             	cmp    $0x2,%eax
    44aa:	75 1c                	jne    44c8 <rlc_mac_main+0x438>
    44ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		switch(fsm_ev_ioctrl_cmd())
    44b0:	e8 fc ff ff ff       	call   44b1 <rlc_mac_main+0x421>
    44b5:	83 f8 0b             	cmp    $0xb,%eax
    44b8:	0f 84 83 1c 00 00    	je     6141 <rlc_mac_main+0x20b1>
    44be:	66 90                	xchg   %ax,%ax
					tmpdata_ptr = (char *)fsm_data_get();
					fsm_data_destroy((void *)tmpdata_ptr);//
				}				
			break;
			default:
				ioctrl_handler();//ioctrl
    44c0:	e8 7b e5 ff ff       	call   2a40 <ioctrl_handler>
    44c5:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    44c8:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    44cf:	03 00 00 
    44d2:	c7 06 05 00 00 00    	movl   $0x5,(%esi)
    44d8:	e9 d9 fb ff ff       	jmp    40b6 <rlc_mac_main+0x26>
    44dd:	8d 76 00             	lea    0x0(%esi),%esi
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    44e0:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    44e7:	03 00 00 
		{
			FSM_COND_TEST_IN("NCRA")
    44ea:	31 db                	xor    %ebx,%ebx
    44ec:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    44f1:	e8 fc ff ff ff       	call   44f2 <rlc_mac_main+0x462>
    44f6:	83 f8 03             	cmp    $0x3,%eax
    44f9:	0f 84 d5 0b 00 00    	je     50d4 <rlc_mac_main+0x1044>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    44ff:	e8 fc ff ff ff       	call   4500 <rlc_mac_main+0x470>
    4504:	83 f8 03             	cmp    $0x3,%eax
    4507:	0f 84 d3 08 00 00    	je     4de0 <rlc_mac_main+0xd50>
    450d:	8d 76 00             	lea    0x0(%esi),%esi
    4510:	e8 fc ff ff ff       	call   4511 <rlc_mac_main+0x481>
    4515:	83 f8 03             	cmp    $0x3,%eax
    4518:	0f 84 fa 08 00 00    	je     4e18 <rlc_mac_main+0xd88>
    451e:	66 90                	xchg   %ax,%ax
    4520:	e8 fc ff ff ff       	call   4521 <rlc_mac_main+0x491>
    4525:	83 f8 05             	cmp    $0x5,%eax
    4528:	0f 84 aa 0d 00 00    	je     52d8 <rlc_mac_main+0x1248>
    452e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RARREV_SUCCESS)
    4530:	e8 fc ff ff ff       	call   4531 <rlc_mac_main+0x4a1>
    4535:	83 f8 03             	cmp    $0x3,%eax
    4538:	0f 84 02 08 00 00    	je     4d40 <rlc_mac_main+0xcb0>
    453e:	66 90                	xchg   %ax,%ax
    4540:	e8 fc ff ff ff       	call   4541 <rlc_mac_main+0x4b1>
    4545:	83 f8 05             	cmp    $0x5,%eax
    4548:	0f 84 2a 0c 00 00    	je     5178 <rlc_mac_main+0x10e8>
    454e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(MAC_RESET)
    4550:	e8 fc ff ff ff       	call   4551 <rlc_mac_main+0x4c1>
    4555:	83 f8 05             	cmp    $0x5,%eax
    4558:	0f 84 9c 0a 00 00    	je     4ffa <rlc_mac_main+0xf6a>
			FSM_COND_TEST_OUT("NCRA")
    455e:	83 fb 01             	cmp    $0x1,%ebx
    4561:	0f 8e 91 07 00 00    	jle    4cf8 <rlc_mac_main+0xc68>
    4567:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    456e:	00 
    456f:	c7 44 24 04 d6 03 00 	movl   $0x3d6,0x4(%esp)
    4576:	00 
    4577:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    457e:	e8 fc ff ff ff       	call   457f <rlc_mac_main+0x4ef>
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4583:	b8 64 1a 00 00       	mov    $0x1a64,%eax
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
    4588:	c7 05 30 00 00 00 f4 	movl   $0x3f4,0x30
    458f:	03 00 00 
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4592:	e8 fc ff ff ff       	call   4593 <rlc_mac_main+0x503>
	if(MAC_CLOSE)
    4597:	e8 fc ff ff ff       	call   4598 <rlc_mac_main+0x508>
    459c:	83 f8 05             	cmp    $0x5,%eax
    459f:	0f 84 35 13 00 00    	je     58da <rlc_mac_main+0x184a>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    45a5:	e8 fc ff ff ff       	call   45a6 <rlc_mac_main+0x516>
    45aa:	83 f8 02             	cmp    $0x2,%eax
    45ad:	0f 84 16 13 00 00    	je     58c9 <rlc_mac_main+0x1839>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    45b3:	e8 fc ff ff ff       	call   45b4 <rlc_mac_main+0x524>
    45b8:	83 f8 03             	cmp    $0x3,%eax
    45bb:	0f 84 de 12 00 00    	je     589f <rlc_mac_main+0x180f>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
	}
	if(IOCTRL_ARRIVAL)
    45c1:	e8 fc ff ff ff       	call   45c2 <rlc_mac_main+0x532>
    45c6:	83 f8 05             	cmp    $0x5,%eax
    45c9:	75 15                	jne    45e0 <rlc_mac_main+0x550>
    45cb:	90                   	nop
    45cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    45d0:	e8 fc ff ff ff       	call   45d1 <rlc_mac_main+0x541>
    45d5:	83 f8 02             	cmp    $0x2,%eax
    45d8:	75 06                	jne    45e0 <rlc_mac_main+0x550>
		ioctrl_handler();//ioctrl
    45da:	e8 61 e4 ff ff       	call   2a40 <ioctrl_handler>
    45df:	90                   	nop
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    45e0:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    45e7:	03 00 00 
    45ea:	c7 06 07 00 00 00    	movl   $0x7,(%esi)
    45f0:	e9 c1 fa ff ff       	jmp    40b6 <rlc_mac_main+0x26>
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
    45f5:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
		}
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
    45fb:	c7 05 30 00 00 00 3d 	movl   $0x33d,0x30
    4602:	03 00 00 
    4605:	e8 16 e1 ff ff       	call   2720 <rlc_init_enter>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
    460a:	e9 51 fc ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    460f:	90                   	nop
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    4610:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    4617:	04 00 00 
		{
			FSM_COND_TEST_IN("CON")
    461a:	31 db                	xor    %ebx,%ebx
    461c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4621:	e8 fc ff ff ff       	call   4622 <rlc_mac_main+0x592>
    4626:	83 f8 03             	cmp    $0x3,%eax
    4629:	0f 84 7c 09 00 00    	je     4fab <rlc_mac_main+0xf1b>
				FSM_TEST_COND(SR_FAIL)
    462f:	e8 fc ff ff ff       	call   4630 <rlc_mac_main+0x5a0>
    4634:	83 f8 03             	cmp    $0x3,%eax
    4637:	0f 84 53 09 00 00    	je     4f90 <rlc_mac_main+0xf00>
    463d:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_TEST_COND(MAC_RESET)
    4640:	e8 fc ff ff ff       	call   4641 <rlc_mac_main+0x5b1>
    4645:	83 f8 05             	cmp    $0x5,%eax
    4648:	0f 84 17 09 00 00    	je     4f65 <rlc_mac_main+0xed5>
    464e:	66 90                	xchg   %ax,%ax

				FSM_TEST_COND(RLC_SUSPEND)
    4650:	e8 fc ff ff ff       	call   4651 <rlc_mac_main+0x5c1>
    4655:	83 f8 03             	cmp    $0x3,%eax
    4658:	0f 84 aa 0a 00 00    	je     5108 <rlc_mac_main+0x1078>
    465e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_DEACT)
    4660:	e8 fc ff ff ff       	call   4661 <rlc_mac_main+0x5d1>
    4665:	83 f8 03             	cmp    $0x3,%eax
    4668:	0f 84 7f 0a 00 00    	je     50ed <rlc_mac_main+0x105d>
    466e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_RESUME)
    4670:	e8 fc ff ff ff       	call   4671 <rlc_mac_main+0x5e1>
    4675:	83 f8 03             	cmp    $0x3,%eax
    4678:	0f 84 cc 08 00 00    	je     4f4a <rlc_mac_main+0xeba>
			FSM_COND_TEST_OUT("CON")
    467e:	83 fb 01             	cmp    $0x1,%ebx
    4681:	0f 8e 91 02 00 00    	jle    4918 <rlc_mac_main+0x888>
    4687:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    468e:	00 
    468f:	c7 44 24 04 01 04 00 	movl   $0x401,0x4(%esp)
    4696:	00 
    4697:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    469e:	e8 fc ff ff ff       	call   469f <rlc_mac_main+0x60f>
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    46a3:	b8 01 00 00 00       	mov    $0x1,%eax
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_CON,con_default_handler() , "CON -> CON")	//transit to CON state	by default.
    46a8:	c7 05 30 00 00 00 1c 	movl   $0x41c,0x30
    46af:	04 00 00 
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    46b2:	e8 fc ff ff ff       	call   46b3 <rlc_mac_main+0x623>
	fsm_mem_set(pdu_type,0,sizeof(char));
    46b7:	31 d2                	xor    %edx,%edx
    46b9:	b9 01 00 00 00       	mov    $0x1,%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));
    46be:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_mem_set(pdu_type,0,sizeof(char));
    46c1:	e8 fc ff ff ff       	call   46c2 <rlc_mac_main+0x632>

	FIN(con_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    46c6:	e8 fc ff ff ff       	call   46c7 <rlc_mac_main+0x637>
    46cb:	89 c3                	mov    %eax,%ebx

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    46cd:	e8 fc ff ff ff       	call   46ce <rlc_mac_main+0x63e>
    46d2:	83 f8 05             	cmp    $0x5,%eax
    46d5:	0f 84 cf 0e 00 00    	je     55aa <rlc_mac_main+0x151a>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    46db:	e8 fc ff ff ff       	call   46dc <rlc_mac_main+0x64c>
    46e0:	83 f8 05             	cmp    $0x5,%eax
    46e3:	0f 84 90 13 00 00    	je     5a79 <rlc_mac_main+0x19e9>
		rlc_close();
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
		FOUT;
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
    46e9:	80 bb 5a 01 00 00 00 	cmpb   $0x0,0x15a(%ebx)
    46f0:	74 0a                	je     46fc <rlc_mac_main+0x66c>
    46f2:	80 7b 28 00          	cmpb   $0x0,0x28(%ebx)
    46f6:	0f 85 39 12 00 00    	jne    5935 <rlc_mac_main+0x18a5>
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
    46fc:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    4702:	66 83 7a 08 00       	cmpw   $0x0,0x8(%edx)
    4707:	0f 84 73 fb ff ff    	je     4280 <rlc_mac_main+0x1f0>
	fsm_octets_print(skb->data,64);
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    470d:	89 75 dc             	mov    %esi,-0x24(%ebp)
    4710:	e9 c7 00 00 00       	jmp    47dc <rlc_mac_main+0x74c>
    4715:	8d 76 00             	lea    0x0(%esi),%esi
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
    4718:	83 f8 03             	cmp    $0x3,%eax
    471b:	0f 84 ca 0a 00 00    	je     51eb <rlc_mac_main+0x115b>
    4721:	83 f8 01             	cmp    $0x1,%eax
    4724:	0f 84 7e 0a 00 00    	je     51a8 <rlc_mac_main+0x1118>
			tmTxIns->tmSduBufferSize += skb->len;
			
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    472a:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
			printk("[RLC][skb_from_cra_to_con] cannot distinfuish this %d\n", SV(ins_mode));
    4731:	89 44 24 04          	mov    %eax,0x4(%esp)
    4735:	c7 04 24 60 1d 00 00 	movl   $0x1d60,(%esp)
    473c:	e8 fc ff ff ff       	call   473d <rlc_mac_main+0x6ad>
			printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    4741:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    4747:	c7 04 24 98 1d 00 00 	movl   $0x1d98,(%esp)
    474e:	89 44 24 04          	mov    %eax,0x4(%esp)
    4752:	e8 fc ff ff ff       	call   4753 <rlc_mac_main+0x6c3>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    4757:	89 f0                	mov    %esi,%eax
    4759:	e8 fc ff ff ff       	call   475a <rlc_mac_main+0x6ca>
{
	char *tmpdata_ptr;
	int tmpdata;

	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);
    475e:	e8 fc ff ff ff       	call   475f <rlc_mac_main+0x6cf>
    4763:	89 c6                	mov    %eax,%esi

	if( PMRLC_BUFFERREP_REQ() == NULL )
    4765:	e8 fc ff ff ff       	call   4766 <rlc_mac_main+0x6d6>
    476a:	85 c0                	test   %eax,%eax
    476c:	0f 84 98 0c 00 00    	je     540a <rlc_mac_main+0x137a>
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4772:	e8 fc ff ff ff       	call   4773 <rlc_mac_main+0x6e3>
		tmpdata = *((u32*)tmpdata_ptr);//	
    4777:	8b 10                	mov    (%eax),%edx
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4779:	89 c7                	mov    %eax,%edi
		tmpdata = *((u32*)tmpdata_ptr);//	
		if( tmpdata > 0 )
    477b:	85 d2                	test   %edx,%edx
    477d:	7e 21                	jle    47a0 <rlc_mac_main+0x710>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    477f:	8d 40 04             	lea    0x4(%eax),%eax
    4782:	e8 fc ff ff ff       	call   4783 <rlc_mac_main+0x6f3>
    4787:	e8 fc ff ff ff       	call   4788 <rlc_mac_main+0x6f8>
			fsm_data_destroy((void *)tmpdata_ptr);//
    478c:	89 f8                	mov    %edi,%eax
    478e:	e8 fc ff ff ff       	call   478f <rlc_mac_main+0x6ff>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    4793:	80 be 58 01 00 00 00 	cmpb   $0x0,0x158(%esi)
    479a:	0f 85 c1 0b 00 00    	jne    5361 <rlc_mac_main+0x12d1>
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    47a0:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
		}
	}

	SV(UL_resource_info.resource_flag) = true;
    47a6:	c6 46 28 01          	movb   $0x1,0x28(%esi)
		/********for test 20150916 *********/
	if(SV(UL_resource_info.resource_flag) == true)
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
    47aa:	c7 46 2c f0 2d 00 00 	movl   $0x2df0,0x2c(%esi)
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    47b1:	c7 86 f4 01 00 00 be 	movl   $0x5be,0x1f4(%esi)
    47b8:	05 00 00 
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    47bb:	8d 50 05             	lea    0x5(%eax),%edx
    47be:	39 50 05             	cmp    %edx,0x5(%eax)
    47c1:	74 0f                	je     47d2 <rlc_mac_main+0x742>
			DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    47c3:	b8 f0 2d 00 00       	mov    $0x2df0,%eax
    47c8:	e8 fc ff ff ff       	call   47c9 <rlc_mac_main+0x739>
    47cd:	e8 fc ff ff ff       	call   47ce <rlc_mac_main+0x73e>
		SV(UL_resource_info.resource_flag)=false;
    47d2:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    47d6:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    47dc:	8b 0a                	mov    (%edx),%ecx
    47de:	8b 7a 04             	mov    0x4(%edx),%edi
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
    47e1:	39 f9                	cmp    %edi,%ecx
    47e3:	0f 84 94 fa ff ff    	je     427d <rlc_mac_main+0x1ed>
//the first node is head node, so always take the second node out.
static FSM_PKT * DeQueue(CraQueuePtr *Q)
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
    47e9:	3b 93 18 02 00 00    	cmp    0x218(%ebx),%edx
    47ef:	0f 84 26 0c 00 00    	je     541b <rlc_mac_main+0x138b>
	// p = (*Q)->front;
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
    47f5:	8b 41 04             	mov    0x4(%ecx),%eax
	pktptr = p->pkt;
	if((*Q)->rear == p)
    47f8:	39 f8                	cmp    %edi,%eax
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
    47fa:	8b 30                	mov    (%eax),%esi
	if((*Q)->rear == p)
    47fc:	0f 84 06 0b 00 00    	je     5308 <rlc_mac_main+0x1278>
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
		(*Q)->front->next = NULL;
	}
	else
		(*Q)->front->next = p->next;	//more than 2 pkt in the queue.
    4802:	8b 50 04             	mov    0x4(%eax),%edx
    4805:	89 51 04             	mov    %edx,0x4(%ecx)

	fsm_mem_free(p);
    4808:	e8 fc ff ff ff       	call   4809 <rlc_mac_main+0x779>
	(*Q)->pkt_count--;
    480d:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    4813:	66 83 68 08 01       	subw   $0x1,0x8(%eax)
	fsm_printf("[DeQueue]DeQueue successfully!\n");
    4818:	c7 04 24 10 1b 00 00 	movl   $0x1b10,(%esp)
    481f:	e8 fc ff ff ff       	call   4820 <rlc_mac_main+0x790>
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
		{
			pkptr = DeQueue(&SV(CraQueue));
			if(pkptr == NULL)
    4824:	85 f6                	test   %esi,%esi
    4826:	74 ae                	je     47d6 <rlc_mac_main+0x746>
				continue;

			fsm_printf("[con_default_handler]SV(CraQueue): %p, pkptr: %p\n", SV(CraQueue), pkptr);
    4828:	89 74 24 08          	mov    %esi,0x8(%esp)
    482c:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    4832:	c7 04 24 30 1b 00 00 	movl   $0x1b30,(%esp)
    4839:	89 44 24 04          	mov    %eax,0x4(%esp)
    483d:	e8 fc ff ff ff       	call   483e <rlc_mac_main+0x7ae>
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    4842:	e8 fc ff ff ff       	call   4843 <rlc_mac_main+0x7b3>

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    4847:	8b 8e a8 00 00 00    	mov    0xa8(%esi),%ecx
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    484d:	ba 40 00 00 00       	mov    $0x40,%edx
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    4852:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    4855:	89 c7                	mov    %eax,%edi

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    4857:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    485d:	e8 fc ff ff ff       	call   485e <rlc_mac_main+0x7ce>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    4862:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4865:	80 38 00             	cmpb   $0x0,(%eax)
    4868:	0f 85 d6 1b 00 00    	jne    6444 <rlc_mac_main+0x23b4>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    486e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    4872:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    4878:	89 14 24             	mov    %edx,(%esp)
    487b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    487e:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4881:	e8 fc ff ff ff       	call   4882 <rlc_mac_main+0x7f2>
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
    4886:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    488c:	c7 04 24 64 1b 00 00 	movl   $0x1b64,(%esp)
    4893:	89 44 24 04          	mov    %eax,0x4(%esp)
    4897:	e8 fc ff ff ff       	call   4898 <rlc_mac_main+0x808>
		switch(SV(ins_mode))
    489c:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    48a2:	83 f8 02             	cmp    $0x2,%eax
    48a5:	0f 85 6d fe ff ff    	jne    4718 <rlc_mac_main+0x688>
			
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    48ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48ae:	85 d2                	test   %edx,%edx
    48b0:	0f 84 e4 18 00 00    	je     619a <rlc_mac_main+0x210a>
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    48b6:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    48ba:	3c 0b                	cmp    $0xb,%al
    48bc:	74 08                	je     48c6 <rlc_mac_main+0x836>
    48be:	3c 09                	cmp    $0x9,%al
    48c0:	0f 85 a5 0a 00 00    	jne    536b <rlc_mac_main+0x12db>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    48c6:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    48ca:	c7 04 24 e4 1c 00 00 	movl   $0x1ce4,(%esp)
    48d1:	89 44 24 04          	mov    %eax,0x4(%esp)
    48d5:	e8 fc ff ff ff       	call   48d6 <rlc_mac_main+0x846>
    48da:	e9 78 fe ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
    48df:	90                   	nop
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
    48e0:	c7 05 30 00 00 00 38 	movl   $0x338,0x30
    48e7:	03 00 00 
}

static void init_enter()
{
	FIN(init_enter());
	ue_mac_sv_init();
    48ea:	e8 91 eb ff ff       	call   3480 <ue_mac_sv_init>
	rlc_init_enter();
    48ef:	e8 2c de ff ff       	call   2720 <rlc_init_enter>
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
    48f4:	e9 67 f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    48f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
			//add RLC_INTI state, transmit to IDLE, 20150803
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
    4900:	c7 05 30 00 00 00 46 	movl   $0x346,0x30
    4907:	03 00 00 
    490a:	e8 71 eb ff ff       	call   3480 <ue_mac_sv_init>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
    490f:	e9 4c f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4914:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
    4918:	85 db                	test   %ebx,%ebx
    491a:	0f 84 83 fd ff ff    	je     46a3 <rlc_mac_main+0x613>
			FSM_TRANSIT_SWITCH
    4920:	83 ff 05             	cmp    $0x5,%edi
    4923:	0f 87 7a fd ff ff    	ja     46a3 <rlc_mac_main+0x613>
    4929:	ff 24 bd 68 03 00 00 	jmp    *0x368(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")
    4930:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    4937:	04 00 00 
    493a:	e8 91 ef ff ff       	call   38d0 <ue_mac_reset>
    493f:	e9 1c f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
    4944:	c7 05 30 00 00 00 11 	movl   $0x411,0x30
    494b:	04 00 00 
    494e:	e8 1d e7 ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
    4953:	e9 70 fb ff ff       	jmp    44c8 <rlc_mac_main+0x438>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
    4958:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    495f:	04 00 00 
    4962:	e8 f9 e9 ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    4967:	e9 f4 f8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    496c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
    4970:	85 db                	test   %ebx,%ebx
    4972:	0f 84 f3 f7 ff ff    	je     416b <rlc_mac_main+0xdb>
			FSM_TRANSIT_SWITCH
    4978:	83 ff 05             	cmp    $0x5,%edi
    497b:	90                   	nop
    497c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4980:	0f 87 e5 f7 ff ff    	ja     416b <rlc_mac_main+0xdb>
    4986:	ff 24 bd 80 03 00 00 	jmp    *0x380(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
    498d:	c7 05 30 00 00 00 79 	movl   $0x379,0x30
    4994:	03 00 00 
    4997:	e8 34 ef ff ff       	call   38d0 <ue_mac_reset>
    499c:	e9 bf f8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    49a1:	c7 05 30 00 00 00 ea 	movl   $0x1ea,0x30
    49a8:	01 00 00 
*******************************
*/
static void doStartNonContentionBasedRandomAccessProcedure() //modified by HQ  20140413
{
	FIN(doStartNonContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    49ab:	e8 fc ff ff ff       	call   49ac <rlc_mac_main+0x91c>
    49b0:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated ));
    49b2:	b8 02 00 00 00       	mov    $0x2,%eax
    49b7:	e8 fc ff ff ff       	call   49b8 <rlc_mac_main+0x928>
    49bc:	89 c7                	mov    %eax,%edi
	int mg3_buffer;
	print_tran_info("[UEMAC][noncontention_ra]startNCRA IDLE -> NCRA");//testing code
    49be:	b8 ec 10 00 00       	mov    $0x10ec,%eax
    49c3:	e8 fc ff ff ff       	call   49c4 <rlc_mac_main+0x934>
	if(SV(PREAMBLE_TRANSMISSION_COUNTER ) == 0)   //
    49c8:	8b 43 14             	mov    0x14(%ebx),%eax
    49cb:	85 c0                	test   %eax,%eax
    49cd:	75 10                	jne    49df <rlc_mac_main+0x94f>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER ) = 1; //PREAMBLE_TRANSMISSION_COUNTER1 
    49cf:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    49d6:	b0 01                	mov    $0x1,%al
    49d8:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer = 0;   //MSG3//
	}
	fsm_printf("[UEMAC][noncontention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    49df:	89 44 24 04          	mov    %eax,0x4(%esp)
    49e3:	c7 04 24 1c 11 00 00 	movl   $0x111c,(%esp)
    49ea:	e8 fc ff ff ff       	call   49eb <rlc_mac_main+0x95b>
	//
	randomaccess_info->ra_PreambleIndex=SV(RA_info.ra_PreambleIndex);
    49ef:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    49f3:	88 07                	mov    %al,(%edi)
	//fsm_printf("[HEXI]PREAMBLE INDEX IN MACFSM:%d\n",SV(RA_info.ra_PreambleIndex));
	
	randomaccess_info->ra_PRACHMaskIndex= SV(RA_info.ra_PRACHMaskIndex);
    49f5:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
    49f9:	88 47 01             	mov    %al,0x1(%edi)
	SendRaPreamble(randomaccess_info);//
    49fc:	89 f8                	mov    %edi,%eax
    49fe:	e8 fd df ff ff       	call   2a00 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    4a03:	e8 88 dc ff ff       	call   2690 <StartWaitingForRaResponse>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4a08:	e9 d3 fb ff ff       	jmp    45e0 <rlc_mac_main+0x550>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
    4a0d:	c7 05 30 00 00 00 de 	movl   $0x1de,0x30
    4a14:	01 00 00 
    4a17:	e8 54 e6 ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
    4a1c:	e9 a7 fa ff ff       	jmp    44c8 <rlc_mac_main+0x438>
    4a21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
    4a28:	85 db                	test   %ebx,%ebx
    4a2a:	0f 84 f3 f9 ff ff    	je     4423 <rlc_mac_main+0x393>
			FSM_TRANSIT_SWITCH
    4a30:	83 ff 05             	cmp    $0x5,%edi
    4a33:	0f 87 ea f9 ff ff    	ja     4423 <rlc_mac_main+0x393>
    4a39:	ff 24 bd 98 03 00 00 	jmp    *0x398(,%edi,4)
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4a40:	c7 05 30 00 00 00 03 	movl   $0x203,0x30
    4a47:	02 00 00 
*/
static void cra_success()
{
	RNTI_indication *data_ptr;
	FIN(cra_success());
	SV_PTR_GET(rlc_mac_sv);
    4a4a:	e8 fc ff ff ff       	call   4a4b <rlc_mac_main+0x9bb>
    4a4f:	89 c7                	mov    %eax,%edi
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4a51:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4a55:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4a59:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	cleanharqBuff();//HARQmsg3
	SV(ra_allocation_res)=0;
    4a60:	c7 80 f8 01 00 00 00 	movl   $0x0,0x1f8(%eax)
    4a67:	00 00 00 
	if(SV(msg3_buf_ptr) != NULL)
    4a6a:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
    4a70:	85 c0                	test   %eax,%eax
    4a72:	74 0f                	je     4a83 <rlc_mac_main+0x9f3>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    4a74:	e8 fc ff ff ff       	call   4a75 <rlc_mac_main+0x9e5>
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    4a79:	c7 87 e4 01 00 00 00 	movl   $0x0,0x1e4(%edi)
    4a80:	00 00 00 
	}
	if(SV(C_RNTI) == 0)
    4a83:	66 83 3f 00          	cmpw   $0x0,(%edi)
    4a87:	0f 85 92 08 00 00    	jne    531f <rlc_mac_main+0x128f>
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    4a8d:	0f b7 47 02          	movzwl 0x2(%edi),%eax
	SV(T_C_RNTI) = 0;//T_C_RNTI
    4a91:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
    4a97:	66 85 c0             	test   %ax,%ax
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    4a9a:	66 89 07             	mov    %ax,(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
    4a9d:	0f 85 82 08 00 00    	jne    5325 <rlc_mac_main+0x1295>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
		fsm_mem_free(data_ptr);//LHL20141018
	}
	if(SV(CRTimer.flag)==true) //CR
    4aa3:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    4aaa:	74 1b                	je     4ac7 <rlc_mac_main+0xa37>
	{
		SV(CRTimer.timer_sign)= NULL;
    4aac:	c7 87 70 01 00 00 00 	movl   $0x0,0x170(%edi)
    4ab3:	00 00 00 
		SV(CRTimer.flag)= false;
    4ab6:	c6 87 74 01 00 00 00 	movb   $0x0,0x174(%edi)
		SV(CRTimer.time_value)=0;
    4abd:	c7 87 6c 01 00 00 00 	movl   $0x0,0x16c(%edi)
    4ac4:	00 00 00 
	}
	SV(sendmsg3)=0;//MSG30
    4ac7:	c7 87 ec 01 00 00 00 	movl   $0x0,0x1ec(%edi)
    4ace:	00 00 00 
	SV(ratype.ra_type)=0;//0 
    4ad1:	c7 87 e8 01 00 00 00 	movl   $0x0,0x1e8(%edi)
    4ad8:	00 00 00 
	SV(pdcch_rnti)=0;
    4adb:	c7 87 f0 01 00 00 00 	movl   $0x0,0x1f0(%edi)
    4ae2:	00 00 00 
	fsm_printf("[UEMAC][cra_success]:contention based random access success \n");//testing code 
    4ae5:	c7 04 24 00 17 00 00 	movl   $0x1700,(%esp)
    4aec:	e8 fc ff ff ff       	call   4aed <rlc_mac_main+0xa5d>
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4af1:	e9 1a f8 ff ff       	jmp    4310 <rlc_mac_main+0x280>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4af6:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4afd:	03 00 00 
*******************************
*/
static void ContentionFailed() 
{
	FIN(ContentionFailed());
	SV_PTR_GET(rlc_mac_sv);
    4b00:	e8 fc ff ff ff       	call   4b01 <rlc_mac_main+0xa71>
    4b05:	89 c3                	mov    %eax,%ebx
	int result=1;//TEST
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4b07:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	u32 backoff_time=0,backoff_param=0;//ms backoff_index
    4b0d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
    4b14:	c7 04 24 a4 16 00 00 	movl   $0x16a4,(%esp)
    4b1b:	e8 fc ff ff ff       	call   4b1c <rlc_mac_main+0xa8c>
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
    4b20:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
    4b27:	0f 85 fb 09 00 00    	jne    5528 <rlc_mac_main+0x1498>
		SV(CRTimer.timer_sign)= NULL;
		SV(CRTimer.flag)= false;
	}
	//if(SV(TATimer.time_value)== SV(TA_fromRAR) && SV(TATimer.flag)==true) //TATimer MAC5.1.6
	
	if(SV(TATimer.flag)==true) 
    4b2d:	80 bb 68 01 00 00 00 	cmpb   $0x0,0x168(%ebx)
    4b34:	74 2a                	je     4b60 <rlc_mac_main+0xad0>
	{//HQ 20140428 
		//fsm_printf("[UEMAC][con_failed]CR fail,stop TAtimer\n");//testing code 
		if(SV(TATimer.timer_sign) != NULL)
    4b36:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
    4b3c:	85 c0                	test   %eax,%eax
    4b3e:	74 05                	je     4b45 <rlc_mac_main+0xab5>
		{
			result=fsm_schedule_cancel (SV(TATimer.timer_sign));
    4b40:	e8 fc ff ff ff       	call   4b41 <rlc_mac_main+0xab1>
		}
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
    4b45:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    4b4c:	00 00 00 
		SV(TATimer.flag)=false;
    4b4f:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.time_value)=0;
    4b56:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    4b5d:	00 00 00 
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b60:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b63:	83 c7 01             	add    $0x1,%edi
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
    4b66:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b6c:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b6f:	39 f8                	cmp    %edi,%eax
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b71:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b74:	0f 84 23 0f 00 00    	je     5a9d <rlc_mac_main+0x1a0d>
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    4b7a:	8b 43 1c             	mov    0x1c(%ebx),%eax
	}
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
    4b7d:	c7 83 f8 01 00 00 01 	movl   $0x1,0x1f8(%ebx)
    4b84:	00 00 00 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4b87:	8b 55 e8             	mov    -0x18(%ebp),%edx
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    4b8a:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4b91:	00 
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4b92:	85 db                	test   %ebx,%ebx
    4b94:	0f 85 26 0b 00 00    	jne    56c0 <rlc_mac_main+0x1630>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			//fsm_printf("[UEMAC][con_failed]:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4b9a:	6b c2 64             	imul   $0x64,%edx,%eax
    4b9d:	ba 02 00 00 00       	mov    $0x2,%edx
    4ba2:	e8 fc ff ff ff       	call   4ba3 <rlc_mac_main+0xb13>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4ba7:	e9 b4 f6 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    4bac:	c7 05 30 00 00 00 c2 	movl   $0x3c2,0x30
    4bb3:	03 00 00 
*/
static void waitsending_msg3() //defined by HQ 20140430 
{
	RNTI_indication *data_ptr;
	FIN(waitsending_msg3());   
	SV_PTR_GET(rlc_mac_sv);
    4bb6:	e8 fc ff ff ff       	call   4bb7 <rlc_mac_main+0xb27>
    4bbb:	89 c7                	mov    %eax,%edi
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4bbd:	e8 fc ff ff ff       	call   4bbe <rlc_mac_main+0xb2e>
	if(SV(TATimer.flag)==false)
    4bc2:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4bc9:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==false)
    4bcb:	0f 84 98 08 00 00    	je     5469 <rlc_mac_main+0x13d9>
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		//T_C_RNTI
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
    4bd1:	66 83 7f 02 00       	cmpw   $0x0,0x2(%edi)
    4bd6:	0f 85 50 08 00 00    	jne    542c <rlc_mac_main+0x139c>
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		fsm_mem_free(data_ptr);
	}
	//HQ HQ modified end 20140717
	fsm_printf("[UEMAC][waitsend_msg3]MAC SV(PREAMBLE_TRANSMISSION_COUNTER):%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER));
    4bdc:	8b 47 14             	mov    0x14(%edi),%eax
    4bdf:	c7 04 24 98 15 00 00 	movl   $0x1598,(%esp)
    4be6:	89 44 24 04          	mov    %eax,0x4(%esp)
    4bea:	e8 fc ff ff ff       	call   4beb <rlc_mac_main+0xb5b>
	{  	
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte,    	
  		fsm_printf("MAC SEND MSG3:this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
	}*/ //modified by lhl 20140725

	if(SV(ra_allocation_res)==0)
    4bef:	8b 87 f8 01 00 00    	mov    0x1f8(%edi),%eax
    4bf5:	85 c0                	test   %eax,%eax
    4bf7:	0f 85 9f 08 00 00    	jne    549c <rlc_mac_main+0x140c>
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
    4bfd:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4c04:	0f 84 f1 07 00 00    	je     53fb <rlc_mac_main+0x136b>
    4c0a:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    4c0e:	0f 84 e7 07 00 00    	je     53fb <rlc_mac_main+0x136b>
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4c14:	8b 47 2c             	mov    0x2c(%edi),%eax
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    4c17:	66 83 3f 00          	cmpw   $0x0,(%edi)
	if(SV(ra_allocation_res)==0)
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
    4c1b:	c7 87 f8 01 00 00 01 	movl   $0x1,0x1f8(%edi)
    4c22:	00 00 00 
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4c25:	89 c2                	mov    %eax,%edx
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    4c27:	0f 84 d5 0c 00 00    	je     5902 <rlc_mac_main+0x1872>
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4c2d:	c1 ea 03             	shr    $0x3,%edx
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    4c30:	83 e8 18             	sub    $0x18,%eax
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4c33:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    4c39:	e8 fc ff ff ff       	call   4c3a <rlc_mac_main+0xbaa>
    4c3e:	e8 fc ff ff ff       	call   4c3f <rlc_mac_main+0xbaf>
				SV(UL_resource_info.resource_flag)=false;
    4c43:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    4c47:	e9 7c f8 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4c4c:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4c53:	03 00 00 
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c56:	e8 fc ff ff ff       	call   4c57 <rlc_mac_main+0xbc7>
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4c5b:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c61:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    4c63:	b8 e0 14 00 00       	mov    $0x14e0,%eax
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
    4c68:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    4c6e:	e8 fc ff ff ff       	call   4c6f <rlc_mac_main+0xbdf>
	if(SV(WaitforRAresponseTimer.flag)==true)//
    4c73:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4c7a:	74 11                	je     4c8d <rlc_mac_main+0xbfd>
	{
		SV(WaitforRAresponseTimer.flag)= false;
    4c7c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4c83:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4c8a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c8d:	8b 43 14             	mov    0x14(%ebx),%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c90:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c93:	83 c0 01             	add    $0x1,%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c96:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c98:	89 43 14             	mov    %eax,0x14(%ebx)
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c9b:	0f 84 41 0e 00 00    	je     5ae2 <rlc_mac_main+0x1a52>
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
		//fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
	//modified by HQ
	else
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
    4ca1:	8b 43 1c             	mov    0x1c(%ebx),%eax
    4ca4:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4cab:	00 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4cac:	66 85 db             	test   %bx,%bx
    4caf:	0f 85 b5 09 00 00    	jne    566a <rlc_mac_main+0x15da>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4cb5:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    4cb9:	ba 02 00 00 00       	mov    $0x2,%edx
    4cbe:	6b c0 64             	imul   $0x64,%eax,%eax
    4cc1:	e8 fc ff ff ff       	call   4cc2 <rlc_mac_main+0xc32>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4cc6:	e9 95 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
    4ccb:	c7 05 30 00 00 00 ab 	movl   $0x3ab,0x30
    4cd2:	03 00 00 
    4cd5:	e8 86 e6 ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    4cda:	e9 81 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
    4cdf:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4ce6:	03 00 00 
    4ce9:	e8 e2 eb ff ff       	call   38d0 <ue_mac_reset>
    4cee:	e9 6d f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4cf3:	90                   	nop
    4cf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
    4cf8:	85 db                	test   %ebx,%ebx
    4cfa:	0f 84 83 f8 ff ff    	je     4583 <rlc_mac_main+0x4f3>
			FSM_TRANSIT_SWITCH
    4d00:	83 ff 01             	cmp    $0x1,%edi
    4d03:	0f 84 b9 01 00 00    	je     4ec2 <rlc_mac_main+0xe32>
    4d09:	0f 8e 95 09 00 00    	jle    56a4 <rlc_mac_main+0x1614>
    4d0f:	83 ff 02             	cmp    $0x2,%edi
    4d12:	0f 84 3d 01 00 00    	je     4e55 <rlc_mac_main+0xdc5>
    4d18:	83 ff 03             	cmp    $0x3,%edi
    4d1b:	90                   	nop
    4d1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4d20:	0f 85 5d f8 ff ff    	jne    4583 <rlc_mac_main+0x4f3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
    4d26:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4d2d:	03 00 00 
    4d30:	e8 9b eb ff ff       	call   38d0 <ue_mac_reset>
    4d35:	e9 26 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4d40:	e8 fc ff ff ff       	call   4d41 <rlc_mac_main+0xcb1>
    4d45:	83 f8 04             	cmp    $0x4,%eax
    4d48:	0f 85 f0 f7 ff ff    	jne    453e <rlc_mac_main+0x4ae>
    4d4e:	83 c3 01             	add    $0x1,%ebx
    4d51:	bf 02 00 00 00       	mov    $0x2,%edi
    4d56:	e9 f3 f7 ff ff       	jmp    454e <rlc_mac_main+0x4be>
    4d5b:	90                   	nop
    4d5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4d60:	e8 fc ff ff ff       	call   4d61 <rlc_mac_main+0xcd1>
    4d65:	83 f8 06             	cmp    $0x6,%eax
    4d68:	0f 85 70 f6 ff ff    	jne    43de <rlc_mac_main+0x34e>
    4d6e:	83 c3 01             	add    $0x1,%ebx
    4d71:	bf 04 00 00 00       	mov    $0x4,%edi
    4d76:	e9 73 f6 ff ff       	jmp    43ee <rlc_mac_main+0x35e>
    4d7b:	90                   	nop
    4d7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4d80:	e8 fc ff ff ff       	call   4d81 <rlc_mac_main+0xcf1>
    4d85:	83 f8 05             	cmp    $0x5,%eax
    4d88:	0f 85 20 f6 ff ff    	jne    43ae <rlc_mac_main+0x31e>
    4d8e:	83 c3 01             	add    $0x1,%ebx
    4d91:	bf 03 00 00 00       	mov    $0x3,%edi
    4d96:	e9 33 f6 ff ff       	jmp    43ce <rlc_mac_main+0x33e>
    4d9b:	90                   	nop
    4d9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4da0:	e8 fc ff ff ff       	call   4da1 <rlc_mac_main+0xd11>
    4da5:	83 f8 04             	cmp    $0x4,%eax
    4da8:	0f 85 e0 f5 ff ff    	jne    438e <rlc_mac_main+0x2fe>
    4dae:	83 c3 01             	add    $0x1,%ebx
    4db1:	bf 02 00 00 00       	mov    $0x2,%edi
    4db6:	e9 e3 f5 ff ff       	jmp    439e <rlc_mac_main+0x30e>
    4dbb:	90                   	nop
    4dbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4dc0:	e8 fc ff ff ff       	call   4dc1 <rlc_mac_main+0xd31>
    4dc5:	83 f8 03             	cmp    $0x3,%eax
    4dc8:	0f 85 8f f5 ff ff    	jne    435d <rlc_mac_main+0x2cd>
    4dce:	83 c3 01             	add    $0x1,%ebx
    4dd1:	bf 01 00 00 00       	mov    $0x1,%edi
    4dd6:	e9 a3 f5 ff ff       	jmp    437e <rlc_mac_main+0x2ee>
    4ddb:	90                   	nop
    4ddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4de0:	e8 fc ff ff ff       	call   4de1 <rlc_mac_main+0xd51>
    4de5:	83 f8 03             	cmp    $0x3,%eax
    4de8:	0f 85 1f f7 ff ff    	jne    450d <rlc_mac_main+0x47d>
    4dee:	83 c3 01             	add    $0x1,%ebx
    4df1:	bf 01 00 00 00       	mov    $0x1,%edi
    4df6:	e9 33 f7 ff ff       	jmp    452e <rlc_mac_main+0x49e>
    4dfb:	90                   	nop
    4dfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4e00:	e8 fc ff ff ff       	call   4e01 <rlc_mac_main+0xd71>
    4e05:	83 f8 18             	cmp    $0x18,%eax
    4e08:	0f 85 60 f5 ff ff    	jne    436e <rlc_mac_main+0x2de>
    4e0e:	66 90                	xchg   %ax,%ax
    4e10:	eb bc                	jmp    4dce <rlc_mac_main+0xd3e>
    4e12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4e18:	90                   	nop
    4e19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4e20:	e8 fc ff ff ff       	call   4e21 <rlc_mac_main+0xd91>
    4e25:	83 f8 18             	cmp    $0x18,%eax
    4e28:	0f 85 f0 f6 ff ff    	jne    451e <rlc_mac_main+0x48e>
    4e2e:	66 90                	xchg   %ax,%ax
    4e30:	eb bc                	jmp    4dee <rlc_mac_main+0xd5e>
    4e32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4e38:	90                   	nop
    4e39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    4e40:	e8 fc ff ff ff       	call   4e41 <rlc_mac_main+0xdb1>
    4e45:	83 f8 0f             	cmp    $0xf,%eax
    4e48:	0f 85 70 f5 ff ff    	jne    43be <rlc_mac_main+0x32e>
    4e4e:	66 90                	xchg   %ax,%ax
    4e50:	e9 39 ff ff ff       	jmp    4d8e <rlc_mac_main+0xcfe>
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4e55:	c7 05 30 00 00 00 f7 	movl   $0x1f7,0x30
    4e5c:	01 00 00 
*******************************
*/
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
    4e5f:	e8 fc ff ff ff       	call   4e60 <rlc_mac_main+0xdd0>
    4e64:	89 c7                	mov    %eax,%edi
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4e66:	e8 fc ff ff ff       	call   4e67 <rlc_mac_main+0xdd7>
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4e6b:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4e72:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4e74:	74 0f                	je     4e85 <rlc_mac_main+0xdf5>
    4e76:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    4e7c:	85 c0                	test   %eax,%eax
    4e7e:	74 05                	je     4e85 <rlc_mac_main+0xdf5>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    4e80:	e8 fc ff ff ff       	call   4e81 <rlc_mac_main+0xdf1>
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4e85:	8b 43 24             	mov    0x24(%ebx),%eax
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4e88:	ba 0b 00 00 00       	mov    $0xb,%edx
	SV_PTR_GET(rlc_mac_sv);	
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4e8d:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4e93:	6b c0 64             	imul   $0x64,%eax,%eax
    4e96:	e8 fc ff ff ff       	call   4e97 <rlc_mac_main+0xe07>
	SV(TATimer.flag)=true;
    4e9b:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4ea2:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
	RARTA_handleA();//RAR  TA 
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4ea8:	c6 47 04 00          	movb   $0x0,0x4(%edi)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4eac:	c6 47 05 00          	movb   $0x0,0x5(%edi)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4eb0:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI 
    4eb7:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4ebd:	e9 4e f4 ff ff       	jmp    4310 <rlc_mac_main+0x280>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4ec2:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4ec9:	03 00 00 
*******************************
*/
static void NC_RaResponseFailed() 
{
	FIN(NC_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4ecc:	e8 fc ff ff ff       	call   4ecd <rlc_mac_main+0xe3d>
    4ed1:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4ed3:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	print_tran_info("[UEMAC][nc_ra_failed]NCRA -> IDLE");//testing code
    4ed9:	b8 d4 19 00 00       	mov    $0x19d4,%eax
    4ede:	e8 fc ff ff ff       	call   4edf <rlc_mac_main+0xe4f>
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
    4ee3:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4eea:	74 11                	je     4efd <rlc_mac_main+0xe6d>
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
    4eec:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4ef3:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4efa:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4efd:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4f00:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4f03:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4f06:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4f08:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4f0b:	0f 84 d1 04 00 00    	je     53e2 <rlc_mac_main+0x1352>
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
	}
	else
	{
		fsm_printf("[UEMAC][nc_ra_failed]MAC:start a new NCRA \n");//testing code 
    4f11:	c7 04 24 38 1a 00 00 	movl   $0x1a38,(%esp)
    4f18:	e8 fc ff ff ff       	call   4f19 <rlc_mac_main+0xe89>
		fsm_schedule_self(100,Start_NonContentionBase_RandomAcc);//trigger a new random access procedure
    4f1d:	ba 01 00 00 00       	mov    $0x1,%edx
    4f22:	b8 64 00 00 00       	mov    $0x64,%eax
    4f27:	e8 fc ff ff ff       	call   4f28 <rlc_mac_main+0xe98>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4f2c:	e9 2f f3 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4f31:	e8 fc ff ff ff       	call   4f32 <rlc_mac_main+0xea2>
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
    4f36:	83 f8 0b             	cmp    $0xb,%eax
    4f39:	0f 94 c3             	sete   %bl
    4f3c:	0f b6 fb             	movzbl %bl,%edi
    4f3f:	0f b6 db             	movzbl %bl,%ebx
    4f42:	83 ef 01             	sub    $0x1,%edi
    4f45:	e9 05 f4 ff ff       	jmp    434f <rlc_mac_main+0x2bf>
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4f4a:	e8 fc ff ff ff       	call   4f4b <rlc_mac_main+0xebb>
    4f4f:	83 f8 54             	cmp    $0x54,%eax
    4f52:	0f 85 26 f7 ff ff    	jne    467e <rlc_mac_main+0x5ee>
    4f58:	83 c3 01             	add    $0x1,%ebx
    4f5b:	bf 05 00 00 00       	mov    $0x5,%edi
    4f60:	e9 19 f7 ff ff       	jmp    467e <rlc_mac_main+0x5ee>
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)
    4f65:	e8 fc ff ff ff       	call   4f66 <rlc_mac_main+0xed6>
    4f6a:	83 f8 02             	cmp    $0x2,%eax
    4f6d:	0f 85 db f6 ff ff    	jne    464e <rlc_mac_main+0x5be>
    4f73:	e8 fc ff ff ff       	call   4f74 <rlc_mac_main+0xee4>
    4f78:	83 f8 03             	cmp    $0x3,%eax
    4f7b:	0f 85 cd f6 ff ff    	jne    464e <rlc_mac_main+0x5be>
    4f81:	83 c3 01             	add    $0x1,%ebx
    4f84:	bf 02 00 00 00       	mov    $0x2,%edi
    4f89:	e9 c0 f6 ff ff       	jmp    464e <rlc_mac_main+0x5be>
    4f8e:	66 90                	xchg   %ax,%ax
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
    4f90:	e8 fc ff ff ff       	call   4f91 <rlc_mac_main+0xf01>
    4f95:	83 f8 07             	cmp    $0x7,%eax
    4f98:	0f 85 9f f6 ff ff    	jne    463d <rlc_mac_main+0x5ad>
    4f9e:	83 c3 01             	add    $0x1,%ebx
    4fa1:	bf 01 00 00 00       	mov    $0x1,%edi
    4fa6:	e9 92 f6 ff ff       	jmp    463d <rlc_mac_main+0x5ad>
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4fab:	e8 fc ff ff ff       	call   4fac <rlc_mac_main+0xf1c>
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
    4fb0:	83 f8 0b             	cmp    $0xb,%eax
    4fb3:	0f 94 c3             	sete   %bl
    4fb6:	0f b6 fb             	movzbl %bl,%edi
    4fb9:	0f b6 db             	movzbl %bl,%ebx
    4fbc:	83 ef 01             	sub    $0x1,%edi
    4fbf:	e9 6b f6 ff ff       	jmp    462f <rlc_mac_main+0x59f>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4fc4:	e8 fc ff ff ff       	call   4fc5 <rlc_mac_main+0xf35>
    4fc9:	83 f8 54             	cmp    $0x54,%eax
    4fcc:	0f 85 74 f1 ff ff    	jne    4146 <rlc_mac_main+0xb6>
    4fd2:	83 c3 01             	add    $0x1,%ebx
    4fd5:	bf 05 00 00 00       	mov    $0x5,%edi
    4fda:	e9 67 f1 ff ff       	jmp    4146 <rlc_mac_main+0xb6>
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4fdf:	e8 fc ff ff ff       	call   4fe0 <rlc_mac_main+0xf50>
    4fe4:	83 f8 52             	cmp    $0x52,%eax
    4fe7:	0f 85 49 f1 ff ff    	jne    4136 <rlc_mac_main+0xa6>
    4fed:	83 c3 01             	add    $0x1,%ebx
    4ff0:	bf 04 00 00 00       	mov    $0x4,%edi
    4ff5:	e9 3c f1 ff ff       	jmp    4136 <rlc_mac_main+0xa6>
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4ffa:	e8 fc ff ff ff       	call   4ffb <rlc_mac_main+0xf6b>
    4fff:	83 f8 02             	cmp    $0x2,%eax
    5002:	0f 85 56 f5 ff ff    	jne    455e <rlc_mac_main+0x4ce>
    5008:	e8 fc ff ff ff       	call   5009 <rlc_mac_main+0xf79>
    500d:	83 f8 03             	cmp    $0x3,%eax
    5010:	0f 85 48 f5 ff ff    	jne    455e <rlc_mac_main+0x4ce>
    5016:	83 c3 01             	add    $0x1,%ebx
    5019:	bf 03 00 00 00       	mov    $0x3,%edi
    501e:	e9 3b f5 ff ff       	jmp    455e <rlc_mac_main+0x4ce>
    5023:	90                   	nop
    5024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    5028:	e8 fc ff ff ff       	call   5029 <rlc_mac_main+0xf99>
    502d:	83 f8 02             	cmp    $0x2,%eax
    5030:	0f 85 c8 f3 ff ff    	jne    43fe <rlc_mac_main+0x36e>
    5036:	e8 fc ff ff ff       	call   5037 <rlc_mac_main+0xfa7>
    503b:	83 f8 03             	cmp    $0x3,%eax
    503e:	66 90                	xchg   %ax,%ax
    5040:	0f 85 b8 f3 ff ff    	jne    43fe <rlc_mac_main+0x36e>
    5046:	83 c3 01             	add    $0x1,%ebx
    5049:	bf 05 00 00 00       	mov    $0x5,%edi
    504e:	e9 ab f3 ff ff       	jmp    43fe <rlc_mac_main+0x36e>
    5053:	90                   	nop
    5054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
    5058:	e8 fc ff ff ff       	call   5059 <rlc_mac_main+0xfc9>
    505d:	83 f8 53             	cmp    $0x53,%eax
    5060:	0f 85 c0 f0 ff ff    	jne    4126 <rlc_mac_main+0x96>
    5066:	83 c3 01             	add    $0x1,%ebx
    5069:	bf 03 00 00 00       	mov    $0x3,%edi
    506e:	e9 b3 f0 ff ff       	jmp    4126 <rlc_mac_main+0x96>
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
    5073:	e8 fc ff ff ff       	call   5074 <rlc_mac_main+0xfe4>
    5078:	83 f8 02             	cmp    $0x2,%eax
    507b:	0f 85 95 f0 ff ff    	jne    4116 <rlc_mac_main+0x86>
    5081:	e8 fc ff ff ff       	call   5082 <rlc_mac_main+0xff2>
    5086:	83 f8 03             	cmp    $0x3,%eax
    5089:	0f 85 87 f0 ff ff    	jne    4116 <rlc_mac_main+0x86>
    508f:	83 c3 01             	add    $0x1,%ebx
    5092:	bf 02 00 00 00       	mov    $0x2,%edi
    5097:	e9 7a f0 ff ff       	jmp    4116 <rlc_mac_main+0x86>
    509c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    50a0:	e8 fc ff ff ff       	call   50a1 <rlc_mac_main+0x1011>
    50a5:	83 f8 01             	cmp    $0x1,%eax
    50a8:	0f 85 58 f0 ff ff    	jne    4106 <rlc_mac_main+0x76>
    50ae:	83 c3 01             	add    $0x1,%ebx
    50b1:	bf 01 00 00 00       	mov    $0x1,%edi
    50b6:	e9 4b f0 ff ff       	jmp    4106 <rlc_mac_main+0x76>
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    50bb:	e8 fc ff ff ff       	call   50bc <rlc_mac_main+0x102c>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
    50c0:	83 f8 02             	cmp    $0x2,%eax
    50c3:	0f 94 c3             	sete   %bl
    50c6:	0f b6 fb             	movzbl %bl,%edi
    50c9:	0f b6 db             	movzbl %bl,%ebx
    50cc:	83 ef 01             	sub    $0x1,%edi
    50cf:	e9 23 f0 ff ff       	jmp    40f7 <rlc_mac_main+0x67>
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    50d4:	e8 fc ff ff ff       	call   50d5 <rlc_mac_main+0x1045>
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
    50d9:	83 f8 0b             	cmp    $0xb,%eax
    50dc:	0f 94 c3             	sete   %bl
    50df:	0f b6 fb             	movzbl %bl,%edi
    50e2:	0f b6 db             	movzbl %bl,%ebx
    50e5:	83 ef 01             	sub    $0x1,%edi
    50e8:	e9 12 f4 ff ff       	jmp    44ff <rlc_mac_main+0x46f>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    50ed:	e8 fc ff ff ff       	call   50ee <rlc_mac_main+0x105e>
    50f2:	83 f8 52             	cmp    $0x52,%eax
    50f5:	0f 85 73 f5 ff ff    	jne    466e <rlc_mac_main+0x5de>
    50fb:	83 c3 01             	add    $0x1,%ebx
    50fe:	bf 04 00 00 00       	mov    $0x4,%edi
    5103:	e9 66 f5 ff ff       	jmp    466e <rlc_mac_main+0x5de>
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
    5108:	e8 fc ff ff ff       	call   5109 <rlc_mac_main+0x1079>
    510d:	83 f8 53             	cmp    $0x53,%eax
    5110:	0f 85 48 f5 ff ff    	jne    465e <rlc_mac_main+0x5ce>
    5116:	83 c3 01             	add    $0x1,%ebx
    5119:	bf 03 00 00 00       	mov    $0x3,%edi
    511e:	e9 3b f5 ff ff       	jmp    465e <rlc_mac_main+0x5ce>
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
				FSM_TEST_COND(CONTENTION_SUCCESS)
    5123:	e8 fc ff ff ff       	call   5124 <rlc_mac_main+0x1094>
    5128:	83 f8 02             	cmp    $0x2,%eax
    512b:	0f 85 bd f2 ff ff    	jne    43ee <rlc_mac_main+0x35e>
    5131:	e8 fc ff ff ff       	call   5132 <rlc_mac_main+0x10a2>
    5136:	83 f8 43             	cmp    $0x43,%eax
    5139:	0f 85 af f2 ff ff    	jne    43ee <rlc_mac_main+0x35e>
    513f:	90                   	nop
    5140:	e9 29 fc ff ff       	jmp    4d6e <rlc_mac_main+0xcde>
    5145:	8d 76 00             	lea    0x0(%esi),%esi
    5148:	90                   	nop
    5149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    5150:	e8 fc ff ff ff       	call   5151 <rlc_mac_main+0x10c1>
    5155:	83 f8 02             	cmp    $0x2,%eax
    5158:	0f 85 40 f2 ff ff    	jne    439e <rlc_mac_main+0x30e>
    515e:	66 90                	xchg   %ax,%ax
    5160:	e8 fc ff ff ff       	call   5161 <rlc_mac_main+0x10d1>
    5165:	83 f8 41             	cmp    $0x41,%eax
    5168:	0f 85 30 f2 ff ff    	jne    439e <rlc_mac_main+0x30e>
    516e:	66 90                	xchg   %ax,%ax
    5170:	e9 39 fc ff ff       	jmp    4dae <rlc_mac_main+0xd1e>
    5175:	8d 76 00             	lea    0x0(%esi),%esi
    5178:	90                   	nop
    5179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    5180:	e8 fc ff ff ff       	call   5181 <rlc_mac_main+0x10f1>
    5185:	83 f8 02             	cmp    $0x2,%eax
    5188:	0f 85 c0 f3 ff ff    	jne    454e <rlc_mac_main+0x4be>
    518e:	66 90                	xchg   %ax,%ax
    5190:	e8 fc ff ff ff       	call   5191 <rlc_mac_main+0x1101>
    5195:	83 f8 41             	cmp    $0x41,%eax
    5198:	0f 85 b0 f3 ff ff    	jne    454e <rlc_mac_main+0x4be>
    519e:	66 90                	xchg   %ax,%ax
    51a0:	e9 a9 fb ff ff       	jmp    4d4e <rlc_mac_main+0xcbe>
    51a5:	8d 76 00             	lea    0x0(%esi),%esi
			
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    51a8:	8b 7d ec             	mov    -0x14(%ebp),%edi
    51ab:	85 ff                	test   %edi,%edi
    51ad:	8d 76 00             	lea    0x0(%esi),%esi
    51b0:	0f 84 bc 12 00 00    	je     6472 <rlc_mac_main+0x23e2>
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    51b6:	b8 0c 00 00 00       	mov    $0xc,%eax
    51bb:	e8 fc ff ff ff       	call   51bc <rlc_mac_main+0x112c>
			tmElm->pkt = skb;
    51c0:	89 30                	mov    %esi,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    51c2:	8b 57 10             	mov    0x10(%edi),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    51c5:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    51c8:	89 4f 10             	mov    %ecx,0x10(%edi)
    51cb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    51ce:	8d 4f 0c             	lea    0xc(%edi),%ecx
    51d1:	89 48 04             	mov    %ecx,0x4(%eax)
	new->next = next;
	new->prev = prev;
    51d4:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    51d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51da:	89 02                	mov    %eax,(%edx)
			tmTxIns->tmSduBufferNum++;
    51dc:	83 47 18 01          	addl   $0x1,0x18(%edi)
			tmTxIns->tmSduBufferSize += skb->len;
    51e0:	8b 46 50             	mov    0x50(%esi),%eax
    51e3:	01 47 14             	add    %eax,0x14(%edi)
    51e6:	e9 73 f5 ff ff       	jmp    475e <rlc_mac_main+0x6ce>
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    51eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    51ee:	85 c0                	test   %eax,%eax
    51f0:	0f 84 d9 0f 00 00    	je     61cf <rlc_mac_main+0x213f>
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    51f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    51f9:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
    51fd:	66 83 fa 0b          	cmp    $0xb,%dx
    5201:	0f 84 af 0f 00 00    	je     61b6 <rlc_mac_main+0x2126>
    5207:	66 83 fa 09          	cmp    $0x9,%dx
    520b:	0f 84 a5 0f 00 00    	je     61b6 <rlc_mac_main+0x2126>
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    5211:	b8 14 00 00 00       	mov    $0x14,%eax
    5216:	e8 fc ff ff ff       	call   5217 <rlc_mac_main+0x1187>
			
			amElm->pkt = skb;
    521b:	89 30                	mov    %esi,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    521d:	8d 48 0c             	lea    0xc(%eax),%ecx
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
			
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    5220:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    5227:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    522e:	8b 55 e8             	mov    -0x18(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5231:	8b 7a 48             	mov    0x48(%edx),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5234:	89 4a 48             	mov    %ecx,0x48(%edx)
    5237:	83 c2 44             	add    $0x44,%edx
    523a:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    523d:	89 78 10             	mov    %edi,0x10(%eax)
	prev->next = new;
    5240:	89 0f                	mov    %ecx,(%edi)
			fsm_printf("[RLC][skb_from_cra_to_con]AM_MODE list_add done!\n");
    5242:	c7 04 24 1c 1c 00 00 	movl   $0x1c1c,(%esp)
    5249:	e8 fc ff ff ff       	call   524a <rlc_mac_main+0x11ba>
			fsm_printf("[RLC][skb_from_cra_to_con] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    524e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5251:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    5255:	89 54 24 0c          	mov    %edx,0xc(%esp)
    5259:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    525d:	c7 04 24 50 1c 00 00 	movl   $0x1c50,(%esp)
    5264:	89 44 24 08          	mov    %eax,0x8(%esp)
    5268:	8d 45 e8             	lea    -0x18(%ebp),%eax
    526b:	89 44 24 04          	mov    %eax,0x4(%esp)
    526f:	e8 fc ff ff ff       	call   5270 <rlc_mac_main+0x11e0>
			amIns->amSduBufferSize += skb->len;
    5274:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5277:	8b 56 50             	mov    0x50(%esi),%edx
    527a:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    527d:	83 40 50 01          	addl   $0x1,0x50(%eax)
    5281:	e9 d8 f4 ff ff       	jmp    475e <rlc_mac_main+0x6ce>
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL)
    5286:	e8 fc ff ff ff       	call   5287 <rlc_mac_main+0x11f7>
    528b:	83 f8 02             	cmp    $0x2,%eax
    528e:	0f 85 3a f1 ff ff    	jne    43ce <rlc_mac_main+0x33e>
    5294:	e8 fc ff ff ff       	call   5295 <rlc_mac_main+0x1205>
    5299:	83 f8 42             	cmp    $0x42,%eax
    529c:	0f 85 2c f1 ff ff    	jne    43ce <rlc_mac_main+0x33e>
    52a2:	e9 e7 fa ff ff       	jmp    4d8e <rlc_mac_main+0xcfe>
    52a7:	90                   	nop
    52a8:	90                   	nop
    52a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    52b0:	e8 fc ff ff ff       	call   52b1 <rlc_mac_main+0x1221>
    52b5:	83 f8 02             	cmp    $0x2,%eax
    52b8:	0f 85 c0 f0 ff ff    	jne    437e <rlc_mac_main+0x2ee>
    52be:	66 90                	xchg   %ax,%ax
    52c0:	e8 fc ff ff ff       	call   52c1 <rlc_mac_main+0x1231>
    52c5:	83 f8 40             	cmp    $0x40,%eax
    52c8:	0f 85 b0 f0 ff ff    	jne    437e <rlc_mac_main+0x2ee>
    52ce:	66 90                	xchg   %ax,%ax
    52d0:	e9 f9 fa ff ff       	jmp    4dce <rlc_mac_main+0xd3e>
    52d5:	8d 76 00             	lea    0x0(%esi),%esi
    52d8:	90                   	nop
    52d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    52e0:	e8 fc ff ff ff       	call   52e1 <rlc_mac_main+0x1251>
    52e5:	83 f8 02             	cmp    $0x2,%eax
    52e8:	0f 85 40 f2 ff ff    	jne    452e <rlc_mac_main+0x49e>
    52ee:	66 90                	xchg   %ax,%ax
    52f0:	e8 fc ff ff ff       	call   52f1 <rlc_mac_main+0x1261>
    52f5:	83 f8 40             	cmp    $0x40,%eax
    52f8:	0f 85 30 f2 ff ff    	jne    452e <rlc_mac_main+0x49e>
    52fe:	66 90                	xchg   %ax,%ax
    5300:	e9 e9 fa ff ff       	jmp    4dee <rlc_mac_main+0xd5e>
    5305:	8d 76 00             	lea    0x0(%esi),%esi
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
	if((*Q)->rear == p)
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
    5308:	89 4a 04             	mov    %ecx,0x4(%edx)
		(*Q)->front->next = NULL;
    530b:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    5311:	8b 12                	mov    (%edx),%edx
    5313:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    531a:	e9 e9 f4 ff ff       	jmp    4808 <rlc_mac_main+0x778>
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
    531f:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    5325:	b8 08 00 00 00       	mov    $0x8,%eax
    532a:	e8 fc ff ff ff       	call   532b <rlc_mac_main+0x129b>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    532f:	ba 24 00 00 00       	mov    $0x24,%edx
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    5334:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 1; 
    5336:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		data_ptr->rnti_value = SV(C_RNTI);
    533c:	0f b7 07             	movzwl (%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    533f:	89 d9                	mov    %ebx,%ecx
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
    5341:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    5344:	b8 03 00 00 00       	mov    $0x3,%eax
    5349:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    5350:	e8 fc ff ff ff       	call   5351 <rlc_mac_main+0x12c1>
		fsm_mem_free(data_ptr);//LHL20141018
    5355:	89 d8                	mov    %ebx,%eax
    5357:	e8 fc ff ff ff       	call   5358 <rlc_mac_main+0x12c8>
    535c:	e9 42 f7 ff ff       	jmp    4aa3 <rlc_mac_main+0xa13>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    5361:	e8 fc ff ff ff       	call   5362 <rlc_mac_main+0x12d2>
    5366:	e9 35 f4 ff ff       	jmp    47a0 <rlc_mac_main+0x710>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    536b:	b8 18 00 00 00       	mov    $0x18,%eax
    5370:	89 55 d8             	mov    %edx,-0x28(%ebp)
    5373:	e8 fc ff ff ff       	call   5374 <rlc_mac_main+0x12e4>
			umElm->pkt = skb;
    5378:	89 30                	mov    %esi,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    537a:	8d 48 10             	lea    0x10(%eax),%ecx
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    537d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    5384:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    538b:	8b 55 d8             	mov    -0x28(%ebp),%edx
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    538e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5391:	8b 4a 1c             	mov    0x1c(%edx),%ecx
    5394:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5397:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    539a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    539d:	8d 4a 18             	lea    0x18(%edx),%ecx
    53a0:	89 48 10             	mov    %ecx,0x10(%eax)
	new->next = next;
	new->prev = prev;
    53a3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    53a6:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    53a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53ac:	89 01                	mov    %eax,(%ecx)
			fsm_printf("[RLC][skb_from_cra_to_con]UM_MODE list_add done!\n");
    53ae:	89 55 d8             	mov    %edx,-0x28(%ebp)
    53b1:	c7 04 24 2c 1d 00 00 	movl   $0x1d2c,(%esp)
    53b8:	e8 fc ff ff ff       	call   53b9 <rlc_mac_main+0x1329>
			
			umTxIns->umSduBufferNum++;
    53bd:	8b 55 d8             	mov    -0x28(%ebp),%edx
    53c0:	8b 42 24             	mov    0x24(%edx),%eax
    53c3:	83 c0 01             	add    $0x1,%eax
    53c6:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    53c9:	3b 87 a8 5a 00 00    	cmp    0x5aa8(%edi),%eax
    53cf:	76 06                	jbe    53d7 <rlc_mac_main+0x1347>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    53d1:	89 87 a8 5a 00 00    	mov    %eax,0x5aa8(%edi)
			}
			umTxIns->umSduBufferSize += skb->len;
    53d7:	8b 46 50             	mov    0x50(%esi),%eax
    53da:	01 42 20             	add    %eax,0x20(%edx)
    53dd:	e9 7c f3 ff ff       	jmp    475e <rlc_mac_main+0x6ce>
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
	{
		//modified by HQ    	
		fsm_printf("[UEMAC][nc_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    53e2:	c7 04 24 f8 19 00 00 	movl   $0x19f8,(%esp)
    53e9:	e8 fc ff ff ff       	call   53ea <rlc_mac_main+0x135a>
		// fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
		//modified by HQ
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
    53ee:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
    53f2:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    53f6:	e9 65 ee ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				SV(UL_resource_info.resource_flag)=false;
			}
			//fsm_printf("[UEMAC][waitsend_msg3]DoResourceAllocation \n");
		}
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
    53fb:	b8 d8 15 00 00       	mov    $0x15d8,%eax
    5400:	e8 fc ff ff ff       	call   5401 <rlc_mac_main+0x1371>
    5405:	e9 be f0 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);

	if( PMRLC_BUFFERREP_REQ() == NULL )
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    540a:	c7 04 24 28 1e 00 00 	movl   $0x1e28,(%esp)
    5411:	e8 fc ff ff ff       	call   5412 <rlc_mac_main+0x1382>
    5416:	e9 bb f3 ff ff       	jmp    47d6 <rlc_mac_main+0x746>
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
	{
		fsm_printf("[DeQueue]Queue is empty!\n");
    541b:	c7 04 24 44 04 00 00 	movl   $0x444,(%esp)
    5422:	e8 fc ff ff ff       	call   5423 <rlc_mac_main+0x1393>
    5427:	e9 aa f3 ff ff       	jmp    47d6 <rlc_mac_main+0x746>
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    542c:	b8 08 00 00 00       	mov    $0x8,%eax
    5431:	e8 fc ff ff ff       	call   5432 <rlc_mac_main+0x13a2>
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    5436:	ba 24 00 00 00       	mov    $0x24,%edx
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    543b:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 2; 
    543d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
		data_ptr->rnti_value = SV(T_C_RNTI);
    5443:	0f b7 47 02          	movzwl 0x2(%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    5447:	89 d9                	mov    %ebx,%ecx
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
    5449:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    544c:	b8 03 00 00 00       	mov    $0x3,%eax
    5451:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    5458:	e8 fc ff ff ff       	call   5459 <rlc_mac_main+0x13c9>
		fsm_mem_free(data_ptr);
    545d:	89 d8                	mov    %ebx,%eax
    545f:	e8 fc ff ff ff       	call   5460 <rlc_mac_main+0x13d0>
    5464:	e9 73 f7 ff ff       	jmp    4bdc <rlc_mac_main+0xb4c>
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5469:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    546d:	ba 0b 00 00 00       	mov    $0xb,%edx
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5472:	c1 e0 04             	shl    $0x4,%eax
    5475:	66 89 43 22          	mov    %ax,0x22(%ebx)
		SV(TATimer.time_value)=SV(TA_Periodic_time);
    5479:	8b 43 24             	mov    0x24(%ebx),%eax
    547c:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5482:	6b c0 64             	imul   $0x64,%eax,%eax
    5485:	e8 fc ff ff ff       	call   5486 <rlc_mac_main+0x13f6>
		SV(TATimer.flag)=true;
    548a:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5491:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
    5497:	e9 35 f7 ff ff       	jmp    4bd1 <rlc_mac_main+0xb41>
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    549c:	8b 47 2c             	mov    0x2c(%edi),%eax
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
    549f:	c7 87 f8 01 00 00 02 	movl   $0x2,0x1f8(%edi)
    54a6:	00 00 00 
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    54a9:	c1 e8 03             	shr    $0x3,%eax
    54ac:	89 87 f4 01 00 00    	mov    %eax,0x1f4(%edi)
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    54b2:	e8 fc ff ff ff       	call   54b3 <rlc_mac_main+0x1423>
    54b7:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    54b9:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    54bf:	c7 04 24 04 16 00 00 	movl   $0x1604,(%esp)
    54c6:	89 44 24 04          	mov    %eax,0x4(%esp)
    54ca:	e8 fc ff ff ff       	call   54cb <rlc_mac_main+0x143b>
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    54cf:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    54d5:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    54db:	83 fa 01             	cmp    $0x1,%edx
    54de:	0f 84 c8 06 00 00    	je     5bac <rlc_mac_main+0x1b1c>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    54e4:	85 c0                	test   %eax,%eax
    54e6:	74 09                	je     54f1 <rlc_mac_main+0x1461>
    54e8:	83 fa 02             	cmp    $0x2,%edx
    54eb:	0f 84 3c 0a 00 00    	je     5f2d <rlc_mac_main+0x1e9d>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    54f1:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    54f7:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    54fc:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5502:	6b c0 64             	imul   $0x64,%eax,%eax
    5505:	e8 fc ff ff ff       	call   5506 <rlc_mac_main+0x1476>
	SV(CRTimer.flag)=true;
    550a:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    5511:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
		//fsm_schedule_self(0, RA_Send_Msg3);//LHL 20140726 ,MSG3MAC
		retransmit_msg3(); 	//call static retransmit_msg3(void) function 20150901 
		fsm_printf("[UEMAC][waitsend_msg3]this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
    5517:	c7 04 24 28 16 00 00 	movl   $0x1628,(%esp)
    551e:	e8 fc ff ff ff       	call   551f <rlc_mac_main+0x148f>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    5523:	e9 a0 ef ff ff       	jmp    44c8 <rlc_mac_main+0x438>
	u32 backoff_time=0,backoff_param=0;//ms backoff_index

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
	{
		fsm_printf("[UEMAC][con_failed]because CRtimer expire \n");
    5528:	c7 04 24 d4 16 00 00 	movl   $0x16d4,(%esp)
    552f:	e8 fc ff ff ff       	call   5530 <rlc_mac_main+0x14a0>
		SV(CRTimer.timer_sign)= NULL;
    5534:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    553b:	00 00 00 
		SV(CRTimer.flag)= false;
    553e:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
    5545:	e9 e3 f5 ff ff       	jmp    4b2d <rlc_mac_main+0xa9d>
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    554a:	e8 fc ff ff ff       	call   554b <rlc_mac_main+0x14bb>
    554f:	83 f8 01             	cmp    $0x1,%eax
    5552:	0f 85 3c ec ff ff    	jne    4194 <rlc_mac_main+0x104>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
    5558:	b8 78 11 00 00       	mov    $0x1178,%eax
    555d:	e8 fc ff ff ff       	call   555e <rlc_mac_main+0x14ce>
		ue_mac_sv_close();
    5562:	e8 49 d4 ff ff       	call   29b0 <ue_mac_sv_close>
    5567:	e9 f4 ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>

	char *pdu_type = (char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
	fsm_mem_set(pdu_type,0,sizeof(char));

	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    556c:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5570:	0f 84 e3 ee ff ff    	je     4459 <rlc_mac_main+0x3c9>
		fsm_schedule_self(0, Contention_Success );//TEST  
    5576:	ba 06 00 00 00       	mov    $0x6,%edx
    557b:	31 c0                	xor    %eax,%eax
    557d:	e8 fc ff ff ff       	call   557e <rlc_mac_main+0x14ee>
    5582:	e9 d2 ee ff ff       	jmp    4459 <rlc_mac_main+0x3c9>
	if(MAC_CLOSE)
    5587:	e8 fc ff ff ff       	call   5588 <rlc_mac_main+0x14f8>
    558c:	83 f8 01             	cmp    $0x1,%eax
    558f:	90                   	nop
    5590:	0f 85 d1 ee ff ff    	jne    4467 <rlc_mac_main+0x3d7>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
    5596:	b8 40 17 00 00       	mov    $0x1740,%eax
    559b:	e8 fc ff ff ff       	call   559c <rlc_mac_main+0x150c>
		ue_mac_sv_close();
    55a0:	e8 0b d4 ff ff       	call   29b0 <ue_mac_sv_close>
    55a5:	e9 1e ef ff ff       	jmp    44c8 <rlc_mac_main+0x438>
    55aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    55b0:	e8 fc ff ff ff       	call   55b1 <rlc_mac_main+0x1521>
    55b5:	83 f8 01             	cmp    $0x1,%eax
    55b8:	0f 85 1d f1 ff ff    	jne    46db <rlc_mac_main+0x64b>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
    55be:	b8 b0 1a 00 00       	mov    $0x1ab0,%eax
    55c3:	e8 fc ff ff ff       	call   55c4 <rlc_mac_main+0x1534>
		ue_mac_sv_close();
    55c8:	e8 e3 d3 ff ff       	call   29b0 <ue_mac_sv_close>
    55cd:	e9 3e ed ff ff       	jmp    4310 <rlc_mac_main+0x280>
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
	{//ICIRLC
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
    55d2:	b8 a0 11 00 00       	mov    $0x11a0,%eax
    55d7:	e8 fc ff ff ff       	call   55d8 <rlc_mac_main+0x1548>
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
    55dc:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    55e3:	0f 84 79 03 00 00    	je     5962 <rlc_mac_main+0x18d2>
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
    55e9:	c7 04 24 ec 11 00 00 	movl   $0x11ec,(%esp)
    55f0:	e8 fc ff ff ff       	call   55f1 <rlc_mac_main+0x1561>
		{
			//IDLE
			fsm_pkt_destroy(fsm_pkt_get());
		}
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
    55f5:	e8 fc ff ff ff       	call   55f6 <rlc_mac_main+0x1566>
    55fa:	e8 fc ff ff ff       	call   55fb <rlc_mac_main+0x156b>
		SV(countRecvFromLower)++;
    55ff:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
    5606:	e9 55 ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    560b:	e8 fc ff ff ff       	call   560c <rlc_mac_main+0x157c>
    5610:	83 f8 01             	cmp    $0x1,%eax
    5613:	0f 85 89 eb ff ff    	jne    41a2 <rlc_mac_main+0x112>
	{
		rlc_close();
    5619:	e8 52 c7 ff ff       	call   1d70 <rlc_close>
    561e:	66 90                	xchg   %ax,%ax
    5620:	e9 3b ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    5625:	83 83 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%ebx)
		rlc_pkt_receive_from_upper();
    562c:	e8 6f e7 ff ff       	call   3da0 <rlc_pkt_receive_from_upper>

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
    5631:	e8 fc ff ff ff       	call   5632 <rlc_mac_main+0x15a2>
    5636:	85 c0                	test   %eax,%eax
    5638:	0f 84 0d 07 00 00    	je     5d4b <rlc_mac_main+0x1cbb>
    563e:	66 90                	xchg   %ax,%ax
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    5640:	e8 fc ff ff ff       	call   5641 <rlc_mac_main+0x15b1>
			tmpdata = *((u32*)tmpdata_ptr);//	
    5645:	8b 10                	mov    (%eax),%edx
		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    5647:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    5649:	85 d2                	test   %edx,%edx
    564b:	0f 8e b3 ec ff ff    	jle    4304 <rlc_mac_main+0x274>
			{
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5651:	8d 40 04             	lea    0x4(%eax),%eax
    5654:	e8 fc ff ff ff       	call   5655 <rlc_mac_main+0x15c5>
    5659:	e8 fc ff ff ff       	call   565a <rlc_mac_main+0x15ca>
				fsm_data_destroy((void *)tmpdata_ptr);//
    565e:	89 d8                	mov    %ebx,%eax
    5660:	e8 fc ff ff ff       	call   5661 <rlc_mac_main+0x15d1>
    5665:	e9 9a ec ff ff       	jmp    4304 <rlc_mac_main+0x274>
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    566a:	8d 45 f0             	lea    -0x10(%ebp),%eax
    566d:	ba 02 00 00 00       	mov    $0x2,%edx
    5672:	e8 fc ff ff ff       	call   5673 <rlc_mac_main+0x15e3>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    5677:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    567b:	31 d2                	xor    %edx,%edx
    567d:	66 f7 f3             	div    %bx
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5680:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    5687:	00 
    5688:	c7 04 24 58 15 00 00 	movl   $0x1558,(%esp)
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    568f:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    5693:	0f b7 d2             	movzwl %dx,%edx
    5696:	89 54 24 08          	mov    %edx,0x8(%esp)
    569a:	e8 fc ff ff ff       	call   569b <rlc_mac_main+0x160b>
    569f:	e9 11 f6 ff ff       	jmp    4cb5 <rlc_mac_main+0xc25>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
    56a4:	85 ff                	test   %edi,%edi
    56a6:	0f 85 d7 ee ff ff    	jne    4583 <rlc_mac_main+0x4f3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
    56ac:	c7 05 30 00 00 00 db 	movl   $0x3db,0x30
    56b3:	03 00 00 
    56b6:	e8 a5 dc ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    56bb:	e9 a0 eb ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    56c0:	ba 04 00 00 00       	mov    $0x4,%edx
    56c5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    56c8:	e8 fc ff ff ff       	call   56c9 <rlc_mac_main+0x1639>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    56cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    56d0:	31 d2                	xor    %edx,%edx
    56d2:	f7 f3                	div    %ebx
    56d4:	89 55 e8             	mov    %edx,-0x18(%ebp)
    56d7:	e9 be f4 ff ff       	jmp    4b9a <rlc_mac_main+0xb0a>
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
		FOUT;
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    56dc:	e8 fc ff ff ff       	call   56dd <rlc_mac_main+0x164d>
    56e1:	83 f8 09             	cmp    $0x9,%eax
    56e4:	0f 85 ac ed ff ff    	jne    4496 <rlc_mac_main+0x406>
	{
		FlushBj();
    56ea:	e8 fc ff ff ff       	call   56eb <rlc_mac_main+0x165b>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    56ef:	ba 09 00 00 00       	mov    $0x9,%edx
    56f4:	b8 64 00 00 00       	mov    $0x64,%eax
    56f9:	e8 fc ff ff ff       	call   56fa <rlc_mac_main+0x166a>
    56fe:	e9 c5 ed ff ff       	jmp    44c8 <rlc_mac_main+0x438>
    5703:	90                   	nop
    5704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void cra_pkt_recv_from_upper(void)
{
	FSM_PKT *skb;

	FIN(cra_pkt_recv_from_upper());
	SV_PTR_GET(rlc_mac_sv);
    5708:	e8 fc ff ff ff       	call   5709 <rlc_mac_main+0x1679>
    570d:	89 c3                	mov    %eax,%ebx
    570f:	90                   	nop
	
	skb = (FSM_PKT *)fsm_pkt_get();
    5710:	e8 fc ff ff ff       	call   5711 <rlc_mac_main+0x1681>
    5715:	89 c7                	mov    %eax,%edi
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]recv from upper\n");
    5717:	c7 04 24 d0 18 00 00 	movl   $0x18d0,(%esp)
    571e:	e8 fc ff ff ff       	call   571f <rlc_mac_main+0x168f>
	fsm_octets_print(skb->data, 64);
    5723:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    5729:	ba 40 00 00 00       	mov    $0x40,%edx
    572e:	e8 fc ff ff ff       	call   572f <rlc_mac_main+0x169f>
	return Q->front == Q->rear;		//because of the head node existence, once front==rear represent the queue empty.
}

static void EnQueue(CraQueuePtr *Q, FSM_PKT *pktptr)
{
	QueueNode *p = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    5733:	b8 08 00 00 00       	mov    $0x8,%eax
    5738:	e8 fc ff ff ff       	call   5739 <rlc_mac_main+0x16a9>
	p->pkt = pktptr;
    573d:	89 38                	mov    %edi,(%eax)
	p->next = NULL;
    573f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	// 	(*Q)->front = (*Q)->rear = p;		//insert node p into a empty queue
	// else{
	// 	(*Q)->rear->next = p;
	// 	(*Q)->rear = p;
	// }
	(*Q)->rear->next = p;
    5746:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    574c:	8b 52 04             	mov    0x4(%edx),%edx
    574f:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->rear = p;
    5752:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    5758:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->pkt_count++;
    575b:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    5761:	66 83 40 08 01       	addw   $0x1,0x8(%eax)
	fsm_printf("[EnQueue]EnQueue successfully!\n");
    5766:	c7 04 24 04 19 00 00 	movl   $0x1904,(%esp)
    576d:	e8 fc ff ff ff       	call   576e <rlc_mac_main+0x16de>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    5772:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5778:	0f b7 40 08          	movzwl 0x8(%eax),%eax
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    577c:	c7 04 24 24 19 00 00 	movl   $0x1924,(%esp)
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    5783:	89 44 24 04          	mov    %eax,0x4(%esp)
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    5787:	e8 fc ff ff ff       	call   5788 <rlc_mac_main+0x16f8>
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	else if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
    578c:	c7 04 24 60 19 00 00 	movl   $0x1960,(%esp)
    5793:	e8 fc ff ff ff       	call   5794 <rlc_mac_main+0x1704>
    5798:	e9 2b ed ff ff       	jmp    44c8 <rlc_mac_main+0x438>
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    579d:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    57a4:	e8 f7 e5 ff ff       	call   3da0 <rlc_pkt_receive_from_upper>

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
    57a9:	e8 fc ff ff ff       	call   57aa <rlc_mac_main+0x171a>
    57ae:	85 c0                	test   %eax,%eax
    57b0:	0f 84 c2 09 00 00    	je     6178 <rlc_mac_main+0x20e8>
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    57b6:	e8 fc ff ff ff       	call   57b7 <rlc_mac_main+0x1727>
			tmpdata = *((u32*)tmpdata_ptr);//	
    57bb:	8b 10                	mov    (%eax),%edx

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    57bd:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    57bf:	85 d2                	test   %edx,%edx
    57c1:	0f 8e 99 ea ff ff    	jle    4260 <rlc_mac_main+0x1d0>
			{
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    57c7:	89 55 d8             	mov    %edx,-0x28(%ebp)
    57ca:	c7 04 24 88 12 00 00 	movl   $0x1288,(%esp)
    57d1:	e8 fc ff ff ff       	call   57d2 <rlc_mac_main+0x1742>
				//fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    57d6:	8b 43 07             	mov    0x7(%ebx),%eax
    57d9:	c7 04 24 bc 12 00 00 	movl   $0x12bc,(%esp)
    57e0:	89 44 24 04          	mov    %eax,0x4(%esp)
    57e4:	e8 fc ff ff ff       	call   57e5 <rlc_mac_main+0x1755>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    57e9:	8b 55 d8             	mov    -0x28(%ebp),%edx
    57ec:	8d 43 04             	lea    0x4(%ebx),%eax
    57ef:	e8 fc ff ff ff       	call   57f0 <rlc_mac_main+0x1760>
    57f4:	e8 fc ff ff ff       	call   57f5 <rlc_mac_main+0x1765>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    57f9:	89 d8                	mov    %ebx,%eax
    57fb:	e8 fc ff ff ff       	call   57fc <rlc_mac_main+0x176c>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5800:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5807:	74 05                	je     580e <rlc_mac_main+0x177e>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    5809:	e8 fc ff ff ff       	call   580a <rlc_mac_main+0x177a>
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    580e:	ba 02 00 00 00       	mov    $0x2,%edx
    5813:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5818:	e8 fc ff ff ff       	call   5819 <rlc_mac_main+0x1789>
				SV(ratype.ra_type)=2;
    581d:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5824:	00 00 00 
    5827:	e9 34 ea ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    582c:	e8 fc ff ff ff       	call   582d <rlc_mac_main+0x179d>
    5831:	8d 93 1c 02 00 00    	lea    0x21c(%ebx),%edx
    5837:	e8 74 c4 ff ff       	call   1cb0 <findInsByCode>
    583c:	85 c0                	test   %eax,%eax
    583e:	89 c7                	mov    %eax,%edi
    5840:	0f 84 a2 0b 00 00    	je     63e8 <rlc_mac_main+0x2358>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    5846:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
    584c:	83 f8 02             	cmp    $0x2,%eax
    584f:	0f 84 3c 07 00 00    	je     5f91 <rlc_mac_main+0x1f01>
    5855:	0f 87 98 02 00 00    	ja     5af3 <rlc_mac_main+0x1a63>
    585b:	83 e8 01             	sub    $0x1,%eax
    585e:	0f 84 99 05 00 00    	je     5dfd <rlc_mac_main+0x1d6d>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    5864:	c7 04 24 1c 13 00 00 	movl   $0x131c,(%esp)
    586b:	e8 fc ff ff ff       	call   586c <rlc_mac_main+0x17dc>
    5870:	e9 8f ea ff ff       	jmp    4304 <rlc_mac_main+0x274>
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5875:	e8 fc ff ff ff       	call   5876 <rlc_mac_main+0x17e6>
    587a:	83 f8 09             	cmp    $0x9,%eax
    587d:	8d 76 00             	lea    0x0(%esi),%esi
    5880:	0f 85 28 ea ff ff    	jne    42ae <rlc_mac_main+0x21e>
	{
		FlushBj();
    5886:	e8 fc ff ff ff       	call   5887 <rlc_mac_main+0x17f7>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    588b:	ba 09 00 00 00       	mov    $0x9,%edx
    5890:	b8 64 00 00 00       	mov    $0x64,%eax
    5895:	e8 fc ff ff ff       	call   5896 <rlc_mac_main+0x1806>
    589a:	e9 65 ea ff ff       	jmp    4304 <rlc_mac_main+0x274>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    589f:	e8 fc ff ff ff       	call   58a0 <rlc_mac_main+0x1810>
    58a4:	83 f8 09             	cmp    $0x9,%eax
    58a7:	0f 85 14 ed ff ff    	jne    45c1 <rlc_mac_main+0x531>
    58ad:	8d 76 00             	lea    0x0(%esi),%esi
	{
		FlushBj();
    58b0:	e8 fc ff ff ff       	call   58b1 <rlc_mac_main+0x1821>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    58b5:	ba 09 00 00 00       	mov    $0x9,%edx
    58ba:	b8 64 00 00 00       	mov    $0x64,%eax
    58bf:	e8 fc ff ff ff       	call   58c0 <rlc_mac_main+0x1830>
    58c4:	e9 f8 ec ff ff       	jmp    45c1 <rlc_mac_main+0x531>
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
	{
		//decomplexUeDataPdu(fsm_pkt_get());
		decomplexUeRARPdu(fsm_pkt_get());	//modify by lxr 20160122
    58c9:	e8 fc ff ff ff       	call   58ca <rlc_mac_main+0x183a>
    58ce:	66 90                	xchg   %ax,%ax
    58d0:	e8 fc ff ff ff       	call   58d1 <rlc_mac_main+0x1841>
    58d5:	e9 d9 ec ff ff       	jmp    45b3 <rlc_mac_main+0x523>
    58da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
	if(MAC_CLOSE)
    58e0:	e8 fc ff ff ff       	call   58e1 <rlc_mac_main+0x1851>
    58e5:	83 f8 01             	cmp    $0x1,%eax
    58e8:	0f 85 b7 ec ff ff    	jne    45a5 <rlc_mac_main+0x515>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
    58ee:	b8 88 1a 00 00       	mov    $0x1a88,%eax
    58f3:	e8 fc ff ff ff       	call   58f4 <rlc_mac_main+0x1864>
		ue_mac_sv_close();
    58f8:	e8 b3 d0 ff ff       	call   29b0 <ue_mac_sv_close>
    58fd:	e9 a3 ec ff ff       	jmp    45a5 <rlc_mac_main+0x515>
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
				SV(UL_resource_info.resource_flag)=false;
			}
			else//RRCC_RNTI2010721 LHL
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5902:	c1 ea 03             	shr    $0x3,%edx
    5905:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//20140531 ,20140718LHL:32MAC
    590b:	e8 fc ff ff ff       	call   590c <rlc_mac_main+0x187c>
    5910:	e8 fc ff ff ff       	call   5911 <rlc_mac_main+0x1881>
				SV(UL_resource_info.resource_flag)=false;
    5915:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    5919:	e9 aa eb ff ff       	jmp    44c8 <rlc_mac_main+0x438>
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    591e:	e8 fc ff ff ff       	call   591f <rlc_mac_main+0x188f>
    5923:	83 f8 0b             	cmp    $0xb,%eax
    5926:	0f 85 a2 e8 ff ff    	jne    41ce <rlc_mac_main+0x13e>
    592c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5930:	e9 a0 f3 ff ff       	jmp    4cd5 <rlc_mac_main+0xc45>
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
	{// 
		//DoResourceAllocation(SV(UL_resource_info.m_tbsize)); 
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
    5935:	c7 04 24 d8 1a 00 00 	movl   $0x1ad8,(%esp)
    593c:	e8 fc ff ff ff       	call   593d <rlc_mac_main+0x18ad>
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5941:	8b 43 2c             	mov    0x2c(%ebx),%eax
    5944:	89 c2                	mov    %eax,%edx
    5946:	c1 ea 03             	shr    $0x3,%edx
    5949:	89 93 f4 01 00 00    	mov    %edx,0x1f4(%ebx)
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
    594f:	e8 fc ff ff ff       	call   5950 <rlc_mac_main+0x18c0>
    5954:	e8 fc ff ff ff       	call   5955 <rlc_mac_main+0x18c5>
		SV(UL_resource_info.resource_flag)=false;
    5959:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    595d:	e9 9a ed ff ff       	jmp    46fc <rlc_mac_main+0x66c>
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
		else
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=false\n");//testing code 	 
    5962:	c7 04 24 18 12 00 00 	movl   $0x1218,(%esp)
    5969:	e8 fc ff ff ff       	call   596a <rlc_mac_main+0x18da>
    596e:	e9 82 fc ff ff       	jmp    55f5 <rlc_mac_main+0x1565>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    5973:	e8 fc ff ff ff       	call   5974 <rlc_mac_main+0x18e4>
    5978:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    597e:	e8 2d c3 ff ff       	call   1cb0 <findInsByCode>
    5983:	89 c3                	mov    %eax,%ebx
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5985:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    598b:	83 f8 02             	cmp    $0x2,%eax
    598e:	0f 84 8f 04 00 00    	je     5e23 <rlc_mac_main+0x1d93>
    5994:	0f 87 c2 03 00 00    	ja     5d5c <rlc_mac_main+0x1ccc>
    599a:	83 e8 01             	sub    $0x1,%eax
    599d:	0f 84 6d 04 00 00    	je     5e10 <rlc_mac_main+0x1d80>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    59a3:	c7 04 24 1c 13 00 00 	movl   $0x131c,(%esp)
    59aa:	e8 fc ff ff ff       	call   59ab <rlc_mac_main+0x191b>
    59af:	e9 ac e8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	else if(TimeAlignmentTimerExpire)
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    59b4:	e8 fc ff ff ff       	call   59b5 <rlc_mac_main+0x1925>
    59b9:	83 f8 09             	cmp    $0x9,%eax
    59bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    59c0:	0f 85 18 e8 ff ff    	jne    41de <rlc_mac_main+0x14e>
	{
		FlushBj();
    59c6:	e8 fc ff ff ff       	call   59c7 <rlc_mac_main+0x1937>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    59cb:	ba 09 00 00 00       	mov    $0x9,%edx
    59d0:	b8 64 00 00 00       	mov    $0x64,%eax
    59d5:	e8 fc ff ff ff       	call   59d6 <rlc_mac_main+0x1946>
    59da:	e9 81 e8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	else if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
		u32 cmd1=fsm_ev_ioctrl_cmd();
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
    59df:	83 f8 0c             	cmp    $0xc,%eax
    59e2:	0f 84 39 02 00 00    	je     5c21 <rlc_mac_main+0x1b91>
    59e8:	83 f8 0e             	cmp    $0xe,%eax
    59eb:	90                   	nop
    59ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    59f0:	0f 85 59 e8 ff ff    	jne    424f <rlc_mac_main+0x1bf>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//
			case IOCCMD_PHYtoMAC_SYSFRAME:
				tmpdata_ptr = fsm_data_get();
    59f6:	e8 fc ff ff ff       	call   59f7 <rlc_mac_main+0x1967>
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
    59fb:	0f b7 10             	movzwl (%eax),%edx
    59fe:	66 89 57 06          	mov    %dx,0x6(%edi)
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
    5a02:	0f b7 50 02          	movzwl 0x2(%eax),%edx
    5a06:	66 89 57 08          	mov    %dx,0x8(%edi)
				fsm_data_destroy(tmpdata_ptr);
    5a0a:	e8 fc ff ff ff       	call   5a0b <rlc_mac_main+0x197b>
    5a0f:	e9 41 e8 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
	else if(IOCTRL_ARRIVAL)
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
		{
			tmpdata_ptr = (char *)fsm_data_get();
    5a14:	e8 fc ff ff ff       	call   5a15 <rlc_mac_main+0x1985>
    5a19:	89 c7                	mov    %eax,%edi
			tmpdata = *((u32*)tmpdata_ptr);//
			//print_tran_info("CON receive a RLCdatareq");//testing code
			//fsm_printf("tmpdata:%d \n",tmpdata);//testing code
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5a1b:	8b 17                	mov    (%edi),%edx
    5a1d:	8d 40 04             	lea    0x4(%eax),%eax
    5a20:	e8 fc ff ff ff       	call   5a21 <rlc_mac_main+0x1991>
    5a25:	e8 fc ff ff ff       	call   5a26 <rlc_mac_main+0x1996>
			fsm_data_destroy((void *)tmpdata_ptr);//
    5a2a:	89 f8                	mov    %edi,%eax
    5a2c:	e8 fc ff ff ff       	call   5a2d <rlc_mac_main+0x199d>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5a31:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    5a38:	0f 85 67 06 00 00    	jne    60a5 <rlc_mac_main+0x2015>
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    5a3e:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
			
			/*******for test *********/
			SV(UL_resource_info.resource_flag) = true;
    5a44:	c6 43 28 01          	movb   $0x1,0x28(%ebx)
			/********for test *********/
			if(SV(UL_resource_info.resource_flag) == true)
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
    5a48:	c7 43 2c c0 2b 00 00 	movl   $0x2bc0,0x2c(%ebx)
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5a4f:	c7 83 f4 01 00 00 78 	movl   $0x578,0x1f4(%ebx)
    5a56:	05 00 00 
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    5a59:	8d 50 05             	lea    0x5(%eax),%edx
    5a5c:	39 50 05             	cmp    %edx,0x5(%eax)
    5a5f:	74 0f                	je     5a70 <rlc_mac_main+0x19e0>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    5a61:	b8 c0 2b 00 00       	mov    $0x2bc0,%eax
    5a66:	e8 fc ff ff ff       	call   5a67 <rlc_mac_main+0x19d7>
    5a6b:	e8 fc ff ff ff       	call   5a6c <rlc_mac_main+0x19dc>
				SV(UL_resource_info.resource_flag)=false;
    5a70:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    5a74:	e9 7c e8 ff ff       	jmp    42f5 <rlc_mac_main+0x265>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    5a79:	e8 fc ff ff ff       	call   5a7a <rlc_mac_main+0x19ea>
    5a7e:	83 e8 01             	sub    $0x1,%eax
    5a81:	0f 85 62 ec ff ff    	jne    46e9 <rlc_mac_main+0x659>
	{
		rlc_close();
    5a87:	e8 e4 c2 ff ff       	call   1d70 <rlc_close>
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
    5a8c:	c7 04 24 27 04 00 00 	movl   $0x427,(%esp)
    5a93:	e8 fc ff ff ff       	call   5a94 <rlc_mac_main+0x1a04>
    5a98:	e9 73 e8 ff ff       	jmp    4310 <rlc_mac_main+0x280>
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
    5a9d:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    5aa4:	00 00 00 
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5aa7:	31 c9                	xor    %ecx,%ecx
    5aa9:	ba 22 00 00 00       	mov    $0x22,%edx
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
    5aae:	c7 83 e8 01 00 00 00 	movl   $0x0,0x1e8(%ebx)
    5ab5:	00 00 00 
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5ab8:	b8 05 00 00 00       	mov    $0x5,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
    5abd:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    5ac4:	00 00 00 
		SV(ra_allocation_res)=0;
    5ac7:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    5ace:	00 00 00 
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5ad1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5ad8:	e8 fc ff ff ff       	call   5ad9 <rlc_mac_main+0x1a49>
    5add:	e9 7e e7 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
		//modified by HQ
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    5ae2:	c7 04 24 18 15 00 00 	movl   $0x1518,(%esp)
    5ae9:	e8 fc ff ff ff       	call   5aea <rlc_mac_main+0x1a5a>
    5aee:	e9 6d e7 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    5af3:	83 f8 03             	cmp    $0x3,%eax
    5af6:	0f 84 b2 04 00 00    	je     5fae <rlc_mac_main+0x1f1e>
    5afc:	83 f8 04             	cmp    $0x4,%eax
    5aff:	90                   	nop
    5b00:	0f 85 5e fd ff ff    	jne    5864 <rlc_mac_main+0x17d4>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5b06:	0f b6 47 02          	movzbl 0x2(%edi),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5b0a:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5b11:	c7 04 24 e4 12 00 00 	movl   $0x12e4,(%esp)
    5b18:	89 44 24 04          	mov    %eax,0x4(%esp)
    5b1c:	e8 fc ff ff ff       	call   5b1d <rlc_mac_main+0x1a8d>
			if(umRxIns->snFiledLength == 5)
    5b21:	66 83 7f 06 05       	cmpw   $0x5,0x6(%edi)
    5b26:	0f 84 b3 05 00 00    	je     60df <rlc_mac_main+0x204f>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5b2c:	66 83 7f 06 0a       	cmpw   $0xa,0x6(%edi)
    5b31:	0f 85 d9 e7 ff ff    	jne    4310 <rlc_mac_main+0x280>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5b37:	0f b7 8f be 10 00 00 	movzwl 0x10be(%edi),%ecx
    5b3e:	bb 00 04 00 00       	mov    $0x400,%ebx
    5b43:	89 ca                	mov    %ecx,%edx
    5b45:	89 c8                	mov    %ecx,%eax
    5b47:	66 c1 fa 0f          	sar    $0xf,%dx
    5b4b:	66 f7 fb             	idiv   %bx
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5b4e:	0f bf da             	movswl %dx,%ebx
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5b51:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5b58:	83 bc 9f b8 00 00 00 	cmpl   $0x0,0xb8(%edi,%ebx,4)
    5b5f:	00 
    5b60:	74 3b                	je     5b9d <rlc_mac_main+0x1b0d>
    5b62:	66 39 d1             	cmp    %dx,%cx
    5b65:	7e 0e                	jle    5b75 <rlc_mac_main+0x1ae5>
    5b67:	eb 34                	jmp    5b9d <rlc_mac_main+0x1b0d>
    5b69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    5b70:	66 39 c1             	cmp    %ax,%cx
    5b73:	7f 21                	jg     5b96 <rlc_mac_main+0x1b06>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5b75:	8d 43 01             	lea    0x1(%ebx),%eax
    5b78:	89 c2                	mov    %eax,%edx
    5b7a:	c1 fa 1f             	sar    $0x1f,%edx
    5b7d:	c1 ea 16             	shr    $0x16,%edx
    5b80:	01 d0                	add    %edx,%eax
    5b82:	25 ff 03 00 00       	and    $0x3ff,%eax
    5b87:	29 d0                	sub    %edx,%eax
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5b89:	0f bf d8             	movswl %ax,%ebx
    5b8c:	83 bc 9f b8 00 00 00 	cmpl   $0x0,0xb8(%edi,%ebx,4)
    5b93:	00 
    5b94:	75 da                	jne    5b70 <rlc_mac_main+0x1ae0>
    5b96:	66 89 87 bc 10 00 00 	mov    %ax,0x10bc(%edi)
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5b9d:	8d 57 18             	lea    0x18(%edi),%edx
    5ba0:	89 f8                	mov    %edi,%eax
    5ba2:	e8 fc ff ff ff       	call   5ba3 <rlc_mac_main+0x1b13>
    5ba7:	e9 64 e7 ff ff       	jmp    4310 <rlc_mac_main+0x280>
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    5bac:	85 c0                	test   %eax,%eax
    5bae:	74 05                	je     5bb5 <rlc_mac_main+0x1b25>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    5bb0:	e8 fc ff ff ff       	call   5bb1 <rlc_mac_main+0x1b21>
		SV(msg3_buf_ptr)=skb;//3
    5bb5:	31 c0                	xor    %eax,%eax
    5bb7:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5bbd:	e8 fc ff ff ff       	call   5bbe <rlc_mac_main+0x1b2e>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5bc2:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5bc7:	89 c7                	mov    %eax,%edi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5bc9:	e8 fc ff ff ff       	call   5bca <rlc_mac_main+0x1b3a>
    5bce:	85 c0                	test   %eax,%eax
    5bd0:	74 1a                	je     5bec <rlc_mac_main+0x1b5c>
    5bd2:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5bd6:	74 14                	je     5bec <rlc_mac_main+0x1b5c>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5bd8:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5bdf:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5be6:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    5bec:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5bf3:	00 00 00 
		complexUeMacPdu(skb);
    5bf6:	89 f8                	mov    %edi,%eax
    5bf8:	e8 fc ff ff ff       	call   5bf9 <rlc_mac_main+0x1b69>
		
	
		if(SV(Tbsize_Complex)!=0)
    5bfd:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5c04:	74 0a                	je     5c10 <rlc_mac_main+0x1b80>
			SV(Tbsize_Complex)=0;//TBSIZE
    5c06:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5c0d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    5c10:	c7 04 24 ec 0b 00 00 	movl   $0xbec,(%esp)
    5c17:	e8 fc ff ff ff       	call   5c18 <rlc_mac_main+0x1b88>
    5c1c:	e9 d0 f8 ff ff       	jmp    54f1 <rlc_mac_main+0x1461>
				SV(ratype.ra_type)=2;
			break;
			//PHYRA
			case IOCCMD_PDCCHtoMAC_RandomAcc_Req: 	
			// break	  
				tmpdata_ptr = fsm_data_get();
    5c21:	e8 fc ff ff ff       	call   5c22 <rlc_mac_main+0x1b92>
    5c26:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5c28:	b8 a8 13 00 00       	mov    $0x13a8,%eax
    5c2d:	e8 fc ff ff ff       	call   5c2e <rlc_mac_main+0x1b9e>
				if(tmpdata_ptr > 0)//
    5c32:	85 db                	test   %ebx,%ebx
    5c34:	0f 84 80 04 00 00    	je     60ba <rlc_mac_main+0x202a>
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
				if(tmpdata_ptr > 0)//
				{
					fsm_printf("[UEMAC][idle_default]IDLE receive a ncra order ");
    5c3a:	c7 04 24 e8 13 00 00 	movl   $0x13e8,(%esp)
    5c41:	e8 fc ff ff ff       	call   5c42 <rlc_mac_main+0x1bb2>
					fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    5c46:	89 da                	mov    %ebx,%edx
    5c48:	b9 02 00 00 00       	mov    $0x2,%ecx
    5c4d:	8d 47 04             	lea    0x4(%edi),%eax
    5c50:	e8 fc ff ff ff       	call   5c51 <rlc_mac_main+0x1bc1>
					fsm_printf("[UEMAC][idle_default]the RAPID is %d\n",SV(RA_info.ra_PreambleIndex));
    5c55:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    5c59:	c7 04 24 18 14 00 00 	movl   $0x1418,(%esp)
    5c60:	89 44 24 04          	mov    %eax,0x4(%esp)
    5c64:	e8 fc ff ff ff       	call   5c65 <rlc_mac_main+0x1bd5>
					if(tmpdata_ptr != NULL)
					{
						fsm_data_destroy(tmpdata_ptr);//
    5c69:	89 d8                	mov    %ebx,%eax
    5c6b:	e8 fc ff ff ff       	call   5c6c <rlc_mac_main+0x1bdc>
						fsm_printf("[UEMAC][idle_default]fsm_ev_data,then free the memory\n");
    5c70:	c7 04 24 40 14 00 00 	movl   $0x1440,(%esp)
    5c77:	e8 fc ff ff ff       	call   5c78 <rlc_mac_main+0x1be8>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
    5c7c:	ba 01 00 00 00       	mov    $0x1,%edx
    5c81:	31 c0                	xor    %eax,%eax
    5c83:	e8 fc ff ff ff       	call   5c84 <rlc_mac_main+0x1bf4>
    5c88:	e9 c8 e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5c8d:	e8 fc ff ff ff       	call   5c8e <rlc_mac_main+0x1bfe>
				tmpdata = *((u32*)tmpdata_ptr);//				
    5c92:	8b 10                	mov    (%eax),%edx
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5c94:	89 c3                	mov    %eax,%ebx
				tmpdata = *((u32*)tmpdata_ptr);//				
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5c96:	c7 04 24 88 12 00 00 	movl   $0x1288,(%esp)
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
				tmpdata = *((u32*)tmpdata_ptr);//				
    5c9d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5ca0:	e8 fc ff ff ff       	call   5ca1 <rlc_mac_main+0x1c11>
				fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
    5ca5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5ca8:	c7 04 24 84 13 00 00 	movl   $0x1384,(%esp)
    5caf:	89 54 24 04          	mov    %edx,0x4(%esp)
    5cb3:	e8 fc ff ff ff       	call   5cb4 <rlc_mac_main+0x1c24>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    5cb8:	8b 43 07             	mov    0x7(%ebx),%eax
    5cbb:	c7 04 24 bc 12 00 00 	movl   $0x12bc,(%esp)
    5cc2:	89 44 24 04          	mov    %eax,0x4(%esp)
    5cc6:	e8 fc ff ff ff       	call   5cc7 <rlc_mac_main+0x1c37>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5ccb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5cce:	8d 43 04             	lea    0x4(%ebx),%eax
    5cd1:	e8 fc ff ff ff       	call   5cd2 <rlc_mac_main+0x1c42>
    5cd6:	e8 fc ff ff ff       	call   5cd7 <rlc_mac_main+0x1c47>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    5cdb:	89 d8                	mov    %ebx,%eax
    5cdd:	e8 fc ff ff ff       	call   5cde <rlc_mac_main+0x1c4e>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5ce2:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5ce9:	0f 85 c0 03 00 00    	jne    60af <rlc_mac_main+0x201f>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    5cef:	ba 02 00 00 00       	mov    $0x2,%edx
    5cf4:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5cf9:	e8 fc ff ff ff       	call   5cfa <rlc_mac_main+0x1c6a>
				SV(ratype.ra_type)=2;
    5cfe:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5d05:	00 00 00 
    5d08:	e9 48 e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//RRCRA
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
    5d0d:	e8 fc ff ff ff       	call   5d0e <rlc_mac_main+0x1c7e>
    5d12:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5d14:	b8 a8 13 00 00       	mov    $0x13a8,%eax
    5d19:	e8 fc ff ff ff       	call   5d1a <rlc_mac_main+0x1c8a>
				if(tmpdata_ptr > 0)//
    5d1e:	85 db                	test   %ebx,%ebx
    5d20:	0f 85 14 ff ff ff    	jne    5c3a <rlc_mac_main+0x1baa>
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5d26:	b8 78 14 00 00       	mov    $0x1478,%eax
    5d2b:	e8 fc ff ff ff       	call   5d2c <rlc_mac_main+0x1c9c>
					SV(ratype.ra_type)=3;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5d30:	ba 02 00 00 00       	mov    $0x2,%edx
    5d35:	31 c0                	xor    %eax,%eax
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=3;
    5d37:	c7 87 e8 01 00 00 03 	movl   $0x3,0x1e8(%edi)
    5d3e:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5d41:	e8 fc ff ff ff       	call   5d42 <rlc_mac_main+0x1cb2>
    5d46:	e9 0a e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
		rlc_pkt_receive_from_upper();

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    5d4b:	c7 04 24 4c 1f 00 00 	movl   $0x1f4c,(%esp)
    5d52:	e8 fc ff ff ff       	call   5d53 <rlc_mac_main+0x1cc3>
    5d57:	e9 a8 e5 ff ff       	jmp    4304 <rlc_mac_main+0x274>
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5d5c:	83 f8 03             	cmp    $0x3,%eax
    5d5f:	0f 84 db 00 00 00    	je     5e40 <rlc_mac_main+0x1db0>
    5d65:	83 f8 04             	cmp    $0x4,%eax
    5d68:	0f 85 35 fc ff ff    	jne    59a3 <rlc_mac_main+0x1913>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5d6e:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5d72:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5d79:	c7 04 24 e4 12 00 00 	movl   $0x12e4,(%esp)
    5d80:	89 44 24 04          	mov    %eax,0x4(%esp)
    5d84:	e8 fc ff ff ff       	call   5d85 <rlc_mac_main+0x1cf5>
			if(umRxIns->snFiledLength == 5)
    5d89:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    5d8e:	0f 84 b4 04 00 00    	je     6248 <rlc_mac_main+0x21b8>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5d94:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    5d99:	0f 85 c1 e4 ff ff    	jne    4260 <rlc_mac_main+0x1d0>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5d9f:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    5da6:	bf 00 04 00 00       	mov    $0x400,%edi
    5dab:	89 ca                	mov    %ecx,%edx
    5dad:	89 c8                	mov    %ecx,%eax
    5daf:	66 c1 fa 0f          	sar    $0xf,%dx
    5db3:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5db6:	bf 00 04 00 00       	mov    $0x400,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5dbb:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5dc2:	eb 16                	jmp    5dda <rlc_mac_main+0x1d4a>
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5dc4:	66 39 c1             	cmp    %ax,%cx
    5dc7:	7f 25                	jg     5dee <rlc_mac_main+0x1d5e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5dc9:	8d 42 01             	lea    0x1(%edx),%eax
    5dcc:	89 c2                	mov    %eax,%edx
    5dce:	c1 fa 1f             	sar    $0x1f,%edx
    5dd1:	f7 ff                	idiv   %edi
    5dd3:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5dda:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5de1:	0f bf d0             	movswl %ax,%edx
    5de4:	83 bc 93 b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edx,4)
    5deb:	00 
    5dec:	75 d6                	jne    5dc4 <rlc_mac_main+0x1d34>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5dee:	8d 53 18             	lea    0x18(%ebx),%edx
    5df1:	89 d8                	mov    %ebx,%eax
    5df3:	e8 fc ff ff ff       	call   5df4 <rlc_mac_main+0x1d64>
    5df8:	e9 63 e4 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5dfd:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			rlc_poll_retx(amIns);
    5e04:	89 f8                	mov    %edi,%eax
    5e06:	e8 fc ff ff ff       	call   5e07 <rlc_mac_main+0x1d77>
    5e0b:	e9 00 e5 ff ff       	jmp    4310 <rlc_mac_main+0x280>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5e10:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5e17:	89 d8                	mov    %ebx,%eax
    5e19:	e8 fc ff ff ff       	call   5e1a <rlc_mac_main+0x1d8a>
    5e1e:	e9 3d e4 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5e23:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5e27:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5e2e:	0f 84 2c e4 ff ff    	je     4260 <rlc_mac_main+0x1d0>
			{
				rlc_ctrl_pkt_trans(amIns);
    5e34:	89 d8                	mov    %ebx,%eax
    5e36:	e8 fc ff ff ff       	call   5e37 <rlc_mac_main+0x1da7>
    5e3b:	e9 20 e4 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5e40:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5e47:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5e4e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5e55:	39 d0                	cmp    %edx,%eax
    5e57:	7d 29                	jge    5e82 <rlc_mac_main+0x1df2>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5e59:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5e60:	00 
    5e61:	0f 84 08 03 00 00    	je     616f <rlc_mac_main+0x20df>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5e67:	83 c0 01             	add    $0x1,%eax
    5e6a:	eb 12                	jmp    5e7e <rlc_mac_main+0x1dee>
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5e6c:	83 c0 01             	add    $0x1,%eax
    5e6f:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5e76:	85 c9                	test   %ecx,%ecx
    5e78:	0f 84 f1 02 00 00    	je     616f <rlc_mac_main+0x20df>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5e7e:	39 d0                	cmp    %edx,%eax
    5e80:	75 ea                	jne    5e6c <rlc_mac_main+0x1ddc>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5e82:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5e89:	bf 00 04 00 00       	mov    $0x400,%edi
    5e8e:	89 ca                	mov    %ecx,%edx
    5e90:	89 c8                	mov    %ecx,%eax
    5e92:	66 c1 fa 0f          	sar    $0xf,%dx
    5e96:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5e99:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5e9c:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5ea3:	7e 2b                	jle    5ed0 <rlc_mac_main+0x1e40>
    5ea5:	eb 37                	jmp    5ede <rlc_mac_main+0x1e4e>
    5ea7:	90                   	nop
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5ea8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5eac:	74 30                	je     5ede <rlc_mac_main+0x1e4e>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5eae:	8d 42 01             	lea    0x1(%edx),%eax
    5eb1:	89 c2                	mov    %eax,%edx
    5eb3:	c1 fa 1f             	sar    $0x1f,%edx
    5eb6:	c1 ea 16             	shr    $0x16,%edx
    5eb9:	01 d0                	add    %edx,%eax
    5ebb:	25 ff 03 00 00       	and    $0x3ff,%eax
    5ec0:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5ec2:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5ec5:	89 c2                	mov    %eax,%edx
    5ec7:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5ece:	7f 0e                	jg     5ede <rlc_mac_main+0x1e4e>
    5ed0:	0f bf d2             	movswl %dx,%edx
    5ed3:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5eda:	85 c0                	test   %eax,%eax
    5edc:	75 ca                	jne    5ea8 <rlc_mac_main+0x1e18>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5ede:	8d 53 30             	lea    0x30(%ebx),%edx
    5ee1:	89 d8                	mov    %ebx,%eax
    5ee3:	e8 fc ff ff ff       	call   5ee4 <rlc_mac_main+0x1e54>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5ee8:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5eef:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5ef6:	66 39 c2             	cmp    %ax,%dx
    5ef9:	7f 11                	jg     5f0c <rlc_mac_main+0x1e7c>
    5efb:	98                   	cwtl   
    5efc:	0f bf d2             	movswl %dx,%edx
    5eff:	2d 00 02 00 00       	sub    $0x200,%eax
    5f04:	39 c2                	cmp    %eax,%edx
    5f06:	0f 8d 54 e3 ff ff    	jge    4260 <rlc_mac_main+0x1d0>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5f0c:	8b 53 18             	mov    0x18(%ebx),%edx
    5f0f:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5f12:	e8 fc ff ff ff       	call   5f13 <rlc_mac_main+0x1e83>
    5f17:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5f1a:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5f21:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5f28:	e9 33 e3 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5f2d:	e8 fc ff ff ff       	call   5f2e <rlc_mac_main+0x1e9e>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5f32:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5f37:	89 c7                	mov    %eax,%edi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5f39:	e8 fc ff ff ff       	call   5f3a <rlc_mac_main+0x1eaa>
    5f3e:	85 c0                	test   %eax,%eax
    5f40:	74 1a                	je     5f5c <rlc_mac_main+0x1ecc>
    5f42:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5f46:	74 14                	je     5f5c <rlc_mac_main+0x1ecc>
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5f48:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5f4f:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5f56:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
		}
		SV(sendmsg3)=1;	
    5f5c:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5f63:	00 00 00 
		complexUeMacPdu(skb); 	
    5f66:	89 f8                	mov    %edi,%eax
    5f68:	e8 fc ff ff ff       	call   5f69 <rlc_mac_main+0x1ed9>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    5f6d:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5f74:	74 0a                	je     5f80 <rlc_mac_main+0x1ef0>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    5f76:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5f7d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    5f80:	c7 04 24 24 0c 00 00 	movl   $0xc24,(%esp)
    5f87:	e8 fc ff ff ff       	call   5f88 <rlc_mac_main+0x1ef8>
    5f8c:	e9 60 f5 ff ff       	jmp    54f1 <rlc_mac_main+0x1461>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5f91:	80 7f 06 00          	cmpb   $0x0,0x6(%edi)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5f95:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%edi)
			if(amIns->statFlag)
    5f9c:	0f 84 6e e3 ff ff    	je     4310 <rlc_mac_main+0x280>
			{
				rlc_ctrl_pkt_trans(amIns);
    5fa2:	89 f8                	mov    %edi,%eax
    5fa4:	e8 fc ff ff ff       	call   5fa5 <rlc_mac_main+0x1f15>
    5fa9:	e9 62 e3 ff ff       	jmp    4310 <rlc_mac_main+0x280>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5fae:	0f bf 87 f4 22 00 00 	movswl 0x22f4(%edi),%eax
    5fb5:	0f bf 97 f2 22 00 00 	movswl 0x22f2(%edi),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5fbc:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5fc3:	39 d0                	cmp    %edx,%eax
    5fc5:	7d 2f                	jge    5ff6 <rlc_mac_main+0x1f66>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5fc7:	83 bc 87 6c 12 00 00 	cmpl   $0x0,0x126c(%edi,%eax,4)
    5fce:	00 
    5fcf:	0f 84 63 01 00 00    	je     6138 <rlc_mac_main+0x20a8>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5fd5:	83 c0 01             	add    $0x1,%eax
    5fd8:	eb 18                	jmp    5ff2 <rlc_mac_main+0x1f62>
    5fda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5fe0:	83 c0 01             	add    $0x1,%eax
    5fe3:	8b 8c 87 68 12 00 00 	mov    0x1268(%edi,%eax,4),%ecx
    5fea:	85 c9                	test   %ecx,%ecx
    5fec:	0f 84 46 01 00 00    	je     6138 <rlc_mac_main+0x20a8>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5ff2:	39 d0                	cmp    %edx,%eax
    5ff4:	75 ea                	jne    5fe0 <rlc_mac_main+0x1f50>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5ff6:	0f b7 8f f0 22 00 00 	movzwl 0x22f0(%edi),%ecx
    5ffd:	bb 00 04 00 00       	mov    $0x400,%ebx
    6002:	89 ca                	mov    %ecx,%edx
    6004:	89 c8                	mov    %ecx,%eax
    6006:	66 c1 fa 0f          	sar    $0xf,%dx
    600a:	66 f7 fb             	idiv   %bx
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    600d:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    6010:	66 89 97 f2 22 00 00 	mov    %dx,0x22f2(%edi)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    6017:	7e 2f                	jle    6048 <rlc_mac_main+0x1fb8>
    6019:	eb 3b                	jmp    6056 <rlc_mac_main+0x1fc6>
    601b:	90                   	nop
    601c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    6020:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    6024:	74 30                	je     6056 <rlc_mac_main+0x1fc6>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    6026:	8d 42 01             	lea    0x1(%edx),%eax
    6029:	89 c2                	mov    %eax,%edx
    602b:	c1 fa 1f             	sar    $0x1f,%edx
    602e:	c1 ea 16             	shr    $0x16,%edx
    6031:	01 d0                	add    %edx,%eax
    6033:	25 ff 03 00 00       	and    $0x3ff,%eax
    6038:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    603a:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    603d:	89 c2                	mov    %eax,%edx
    603f:	66 89 87 f2 22 00 00 	mov    %ax,0x22f2(%edi)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    6046:	7f 0e                	jg     6056 <rlc_mac_main+0x1fc6>
    6048:	0f bf d2             	movswl %dx,%edx
    604b:	8b 84 97 6c 12 00 00 	mov    0x126c(%edi,%edx,4),%eax
    6052:	85 c0                	test   %eax,%eax
    6054:	75 ca                	jne    6020 <rlc_mac_main+0x1f90>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    6056:	8d 57 30             	lea    0x30(%edi),%edx
    6059:	89 f8                	mov    %edi,%eax
    605b:	e8 fc ff ff ff       	call   605c <rlc_mac_main+0x1fcc>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    6060:	0f b7 97 ee 22 00 00 	movzwl 0x22ee(%edi),%edx
    6067:	0f b7 87 f2 22 00 00 	movzwl 0x22f2(%edi),%eax
    606e:	66 39 c2             	cmp    %ax,%dx
    6071:	7f 11                	jg     6084 <rlc_mac_main+0x1ff4>
    6073:	98                   	cwtl   
    6074:	0f bf d2             	movswl %dx,%edx
    6077:	2d 00 02 00 00       	sub    $0x200,%eax
    607c:	39 c2                	cmp    %eax,%edx
    607e:	0f 8d 8c e2 ff ff    	jge    4310 <rlc_mac_main+0x280>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    6084:	8b 57 18             	mov    0x18(%edi),%edx
    6087:	8b 47 1c             	mov    0x1c(%edi),%eax
    608a:	e8 fc ff ff ff       	call   608b <rlc_mac_main+0x1ffb>
    608f:	89 47 14             	mov    %eax,0x14(%edi)
				amIns->vr_x = amIns->vr_h;
    6092:	0f b7 87 ee 22 00 00 	movzwl 0x22ee(%edi),%eax
    6099:	66 89 87 f0 22 00 00 	mov    %ax,0x22f0(%edi)
    60a0:	e9 6b e2 ff ff       	jmp    4310 <rlc_mac_main+0x280>
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    60a5:	e8 fc ff ff ff       	call   60a6 <rlc_mac_main+0x2016>
    60aa:	e9 8f f9 ff ff       	jmp    5a3e <rlc_mac_main+0x19ae>
    60af:	90                   	nop
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    60b0:	e8 fc ff ff ff       	call   60b1 <rlc_mac_main+0x2021>
    60b5:	e9 35 fc ff ff       	jmp    5cef <rlc_mac_main+0x1c5f>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    60ba:	b8 78 14 00 00       	mov    $0x1478,%eax
    60bf:	e8 fc ff ff ff       	call   60c0 <rlc_mac_main+0x2030>
					SV(ratype.ra_type)=1;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    60c4:	ba 02 00 00 00       	mov    $0x2,%edx
    60c9:	31 c0                	xor    %eax,%eax
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=1;
    60cb:	c7 87 e8 01 00 00 01 	movl   $0x1,0x1e8(%edi)
    60d2:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    60d5:	e8 fc ff ff ff       	call   60d6 <rlc_mac_main+0x2046>
    60da:	e9 76 e1 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    60df:	0f bf 87 bc 10 00 00 	movswl 0x10bc(%edi),%eax
    60e6:	b9 20 00 00 00       	mov    $0x20,%ecx
    60eb:	83 c0 01             	add    $0x1,%eax
    60ee:	89 c2                	mov    %eax,%edx
    60f0:	c1 fa 1f             	sar    $0x1f,%edx
    60f3:	f7 f9                	idiv   %ecx
    60f5:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
    60fc:	eb 1a                	jmp    6118 <rlc_mac_main+0x2088>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    60fe:	66 3b 87 be 10 00 00 	cmp    0x10be(%edi),%ax
    6105:	7f 22                	jg     6129 <rlc_mac_main+0x2099>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    6107:	8d 42 01             	lea    0x1(%edx),%eax
    610a:	89 c2                	mov    %eax,%edx
    610c:	c1 fa 1f             	sar    $0x1f,%edx
    610f:	f7 f9                	idiv   %ecx
    6111:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    6118:	0f b7 87 bc 10 00 00 	movzwl 0x10bc(%edi),%eax
    611f:	0f bf d0             	movswl %ax,%edx
    6122:	83 7c 97 38 00       	cmpl   $0x0,0x38(%edi,%edx,4)
    6127:	75 d5                	jne    60fe <rlc_mac_main+0x206e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6129:	8d 57 18             	lea    0x18(%edi),%edx
    612c:	89 f8                	mov    %edi,%eax
    612e:	e8 fc ff ff ff       	call   612f <rlc_mac_main+0x209f>
    6133:	e9 f4 f9 ff ff       	jmp    5b2c <rlc_mac_main+0x1a9c>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    6138:	c6 47 06 01          	movb   $0x1,0x6(%edi)
    613c:	e9 b5 fe ff ff       	jmp    5ff6 <rlc_mac_main+0x1f66>
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
    6141:	c7 04 24 98 19 00 00 	movl   $0x1998,(%esp)
    6148:	e8 fc ff ff ff       	call   6149 <rlc_mac_main+0x20b9>
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
    614d:	83 bb ec 01 00 00 00 	cmpl   $0x0,0x1ec(%ebx)
    6154:	74 0a                	je     6160 <rlc_mac_main+0x20d0>
    6156:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    615a:	0f 85 70 01 00 00    	jne    62d0 <rlc_mac_main+0x2240>
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
					SV(ratype.ra_type)=2;
				}
				else//
				{
					tmpdata_ptr = (char *)fsm_data_get();
    6160:	e8 fc ff ff ff       	call   6161 <rlc_mac_main+0x20d1>
					fsm_data_destroy((void *)tmpdata_ptr);//
    6165:	e8 fc ff ff ff       	call   6166 <rlc_mac_main+0x20d6>
    616a:	e9 59 e3 ff ff       	jmp    44c8 <rlc_mac_main+0x438>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    616f:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    6173:	e9 0a fd ff ff       	jmp    5e82 <rlc_mac_main+0x1df2>
		SV(countRecvFromUpper)++;
		rlc_pkt_receive_from_upper();

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    6178:	c7 04 24 48 12 00 00 	movl   $0x1248,(%esp)
    617f:	e8 fc ff ff ff       	call   6180 <rlc_mac_main+0x20f0>
    6184:	e9 d7 e0 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		}
		reports_handler();//BSR PHR 
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    6189:	c7 04 24 a8 14 00 00 	movl   $0x14a8,(%esp)
    6190:	e8 fc ff ff ff       	call   6191 <rlc_mac_main+0x2101>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    6195:	e9 c6 e0 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			break;

		case UM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    619a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    619d:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
    61a1:	c7 04 24 a0 1c 00 00 	movl   $0x1ca0,(%esp)
    61a8:	89 44 24 04          	mov    %eax,0x4(%esp)
    61ac:	e8 fc ff ff ff       	call   61ad <rlc_mac_main+0x211d>
    61b1:	e9 a1 e5 ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    61b6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    61ba:	c7 04 24 d4 1b 00 00 	movl   $0x1bd4,(%esp)
    61c1:	89 44 24 04          	mov    %eax,0x4(%esp)
    61c5:	e8 fc ff ff ff       	call   61c6 <rlc_mac_main+0x2136>
    61ca:	e9 88 e5 ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    61cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    61d2:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    61d6:	c7 04 24 94 1b 00 00 	movl   $0x1b94,(%esp)
    61dd:	89 44 24 04          	mov    %eax,0x4(%esp)
    61e1:	e8 fc ff ff ff       	call   61e2 <rlc_mac_main+0x2152>
    61e6:	e9 6c e5 ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
    61eb:	b8 84 1e 00 00       	mov    $0x1e84,%eax
    61f0:	e8 fc ff ff ff       	call   61f1 <rlc_mac_main+0x2161>
		SV(countRecvFromLower)++;
    61f5:	83 83 94 5a 00 00 01 	addl   $0x1,0x5a94(%ebx)
		skb=fsm_pkt_get();
    61fc:	e8 fc ff ff ff       	call   61fd <rlc_mac_main+0x216d>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    6201:	b9 01 00 00 00       	mov    $0x1,%ecx
    6206:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
		SV(countRecvFromLower)++;
		skb=fsm_pkt_get();
    620c:	89 c3                	mov    %eax,%ebx
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    620e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6211:	e8 fc ff ff ff       	call   6212 <rlc_mac_main+0x2182>
		*pdu_type=(*pdu_type)>>6;
    6216:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6219:	0f b6 02             	movzbl (%edx),%eax
    621c:	c0 f8 06             	sar    $0x6,%al
    621f:	88 02                	mov    %al,(%edx)
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    6221:	0f be c0             	movsbl %al,%eax
    6224:	89 44 24 04          	mov    %eax,0x4(%esp)
    6228:	c7 04 24 c4 1e 00 00 	movl   $0x1ec4,(%esp)
    622f:	e8 fc ff ff ff       	call   6230 <rlc_mac_main+0x21a0>
		if( (*pdu_type) > 0){
    6234:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6237:	80 38 00             	cmpb   $0x0,(%eax)
			fsm_pkt_destroy(skb);
    623a:	89 d8                	mov    %ebx,%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
    623c:	7f 63                	jg     62a1 <rlc_mac_main+0x2211>
			fsm_pkt_destroy(skb);
			fsm_mem_free(pdu_type);
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			FOUT;
		}
		decomplexUeDataPdu(skb);
    623e:	e8 fc ff ff ff       	call   623f <rlc_mac_main+0x21af>
    6243:	e9 bc e0 ff ff       	jmp    4304 <rlc_mac_main+0x274>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    6248:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    624f:	b9 20 00 00 00       	mov    $0x20,%ecx
    6254:	83 c0 01             	add    $0x1,%eax
    6257:	89 c2                	mov    %eax,%edx
    6259:	c1 fa 1f             	sar    $0x1f,%edx
    625c:	f7 f9                	idiv   %ecx
    625e:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    6265:	eb 1a                	jmp    6281 <rlc_mac_main+0x21f1>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    6267:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    626e:	7f 22                	jg     6292 <rlc_mac_main+0x2202>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    6270:	8d 42 01             	lea    0x1(%edx),%eax
    6273:	89 c2                	mov    %eax,%edx
    6275:	c1 fa 1f             	sar    $0x1f,%edx
    6278:	f7 f9                	idiv   %ecx
    627a:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    6281:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    6288:	0f bf d0             	movswl %ax,%edx
    628b:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    6290:	75 d5                	jne    6267 <rlc_mac_main+0x21d7>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6292:	8d 53 18             	lea    0x18(%ebx),%edx
    6295:	89 d8                	mov    %ebx,%eax
    6297:	e8 fc ff ff ff       	call   6298 <rlc_mac_main+0x2208>
    629c:	e9 f3 fa ff ff       	jmp    5d94 <rlc_mac_main+0x1d04>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		//fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last)); //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU
		printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if( (*pdu_type) > 0){
			fsm_pkt_destroy(skb);
    62a1:	e8 fc ff ff ff       	call   62a2 <rlc_mac_main+0x2212>
			fsm_mem_free(pdu_type);
    62a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    62a9:	e8 fc ff ff ff       	call   62aa <rlc_mac_main+0x221a>
			printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
    62ae:	c7 04 24 00 1f 00 00 	movl   $0x1f00,(%esp)
    62b5:	e8 fc ff ff ff       	call   62b6 <rlc_mac_main+0x2226>
    62ba:	e9 51 e0 ff ff       	jmp    4310 <rlc_mac_main+0x280>
		print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    62bf:	c7 04 24 a8 14 00 00 	movl   $0x14a8,(%esp)
    62c6:	e8 fc ff ff ff       	call   62c7 <rlc_mac_main+0x2237>
    62cb:	e9 34 e0 ff ff       	jmp    4304 <rlc_mac_main+0x274>
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
				{
					tmpdata_ptr = (char *)fsm_data_get();
    62d0:	e8 fc ff ff ff       	call   62d1 <rlc_mac_main+0x2241>
    62d5:	89 c7                	mov    %eax,%edi
					tmpdata = *((u32*)tmpdata_ptr);//	
					DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    62d7:	8b 17                	mov    (%edi),%edx
    62d9:	8d 40 04             	lea    0x4(%eax),%eax
    62dc:	e8 fc ff ff ff       	call   62dd <rlc_mac_main+0x224d>
    62e1:	e8 fc ff ff ff       	call   62e2 <rlc_mac_main+0x2252>
					//tmpdata_ptr+sizeof(int)//4 
					fsm_data_destroy((void *)tmpdata_ptr);//
    62e6:	89 f8                	mov    %edi,%eax
    62e8:	e8 fc ff ff ff       	call   62e9 <rlc_mac_main+0x2259>
					if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    62ed:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    62f4:	74 05                	je     62fb <rlc_mac_main+0x226b>
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    62f6:	e8 fc ff ff ff       	call   62f7 <rlc_mac_main+0x2267>
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    62fb:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
					//cra_success();//
					//IOCTL

					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    6301:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
    6305:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    6309:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    6310:	85 c0                	test   %eax,%eax
					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
    6312:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    6319:	00 00 00 
					if(SV(msg3_buf_ptr) != NULL)
    631c:	74 0f                	je     632d <rlc_mac_main+0x229d>
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    631e:	e8 fc ff ff ff       	call   631f <rlc_mac_main+0x228f>
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    6323:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    632a:	00 00 00 
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
					if(SV(CRTimer.flag)==true) //CR
    632d:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
					if(SV(msg3_buf_ptr) != NULL)
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
    6334:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
					if(SV(CRTimer.flag)==true) //CR
    633a:	74 1b                	je     6357 <rlc_mac_main+0x22c7>
					{
						SV(CRTimer.timer_sign)= NULL;
    633c:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    6343:	00 00 00 
						SV(CRTimer.flag)= false;
    6346:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
						SV(CRTimer.time_value)=0;
    634d:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    6354:	00 00 00 
					}
					SV(sendmsg3)=0;//MSG30
    6357:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    635e:	00 00 00 
					//SV(ratype.ra_type)=0;//0 
					SV(pdcch_rnti)=0;
    6361:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    6368:	00 00 00 
					/*************/
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
    636b:	e8 00 cd ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
					SV(ratype.ra_type)=2;
    6370:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    6377:	00 00 00 
    637a:	e9 49 e1 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    637f:	e8 fc ff ff ff       	call   6380 <rlc_mac_main+0x22f0>
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    6384:	b9 01 00 00 00       	mov    $0x1,%ecx
    6389:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		/*******************************************/
		skb=fsm_pkt_get();
    638f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
    6392:	89 f8                	mov    %edi,%eax
    6394:	e8 fc ff ff ff       	call   6395 <rlc_mac_main+0x2305>
		*pdu_type=(*pdu_type)>>6;
    6399:	0f b6 07             	movzbl (%edi),%eax
    639c:	c0 f8 06             	sar    $0x6,%al
    639f:	88 07                	mov    %al,(%edi)
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
    63a1:	0f be c0             	movsbl %al,%eax
    63a4:	89 44 24 04          	mov    %eax,0x4(%esp)
    63a8:	c7 04 24 68 17 00 00 	movl   $0x1768,(%esp)
    63af:	e8 fc ff ff ff       	call   63b0 <rlc_mac_main+0x2320>
		if(SV(sendmsg3)==0){
    63b4:	8b 83 ec 01 00 00    	mov    0x1ec(%ebx),%eax
    63ba:	85 c0                	test   %eax,%eax
    63bc:	75 58                	jne    6416 <rlc_mac_main+0x2386>
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    63be:	0f b6 07             	movzbl (%edi),%eax
    63c1:	83 e8 01             	sub    $0x1,%eax
    63c4:	3c 02                	cmp    $0x2,%al
				decomplexUeRARPdu(skb);
    63c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
		skb=fsm_pkt_get();
		fsm_mem_cpy(pdu_type, skb->data,sizeof(char));
		*pdu_type=(*pdu_type)>>6;
		printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: pdu_type=%d\n",(*pdu_type));
		if(SV(sendmsg3)==0){
			if( (*pdu_type) > 0 && (*pdu_type) <= 3){  
    63c9:	77 2e                	ja     63f9 <rlc_mac_main+0x2369>
				decomplexUeRARPdu(skb);
    63cb:	e8 fc ff ff ff       	call   63cc <rlc_mac_main+0x233c>
				fsm_mem_free(pdu_type);
    63d0:	89 f8                	mov    %edi,%eax
    63d2:	e8 fc ff ff ff       	call   63d3 <rlc_mac_main+0x2343>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
    63d7:	c7 04 24 a4 17 00 00 	movl   $0x17a4,(%esp)
    63de:	e8 fc ff ff ff       	call   63df <rlc_mac_main+0x234f>
    63e3:	e9 e0 e0 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
    63e8:	c7 04 24 a0 1f 00 00 	movl   $0x1fa0,(%esp)
    63ef:	e8 fc ff ff ff       	call   63f0 <rlc_mac_main+0x2360>
    63f4:	e9 17 df ff ff       	jmp    4310 <rlc_mac_main+0x280>
				decomplexUeRARPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a RAR PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    63f9:	e8 fc ff ff ff       	call   63fa <rlc_mac_main+0x236a>
				fsm_mem_free(pdu_type);
    63fe:	89 f8                	mov    %edi,%eax
    6400:	e8 fc ff ff ff       	call   6401 <rlc_mac_main+0x2371>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
    6405:	c7 04 24 e8 17 00 00 	movl   $0x17e8,(%esp)
    640c:	e8 fc ff ff ff       	call   640d <rlc_mac_main+0x237d>
    6411:	e9 b2 e0 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
    6416:	83 e8 01             	sub    $0x1,%eax
    6419:	0f 85 a9 e0 ff ff    	jne    44c8 <rlc_mac_main+0x438>
			if( (*pdu_type) == 0){  
    641f:	80 3f 00             	cmpb   $0x0,(%edi)
				decomplexUeDataPdu(skb);
    6422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a Common DATA PDU ,Error!!!\n");
				FOUT;
			}
		}	
		if(SV(sendmsg3)==1){
			if( (*pdu_type) == 0){  
    6425:	75 67                	jne    648e <rlc_mac_main+0x23fe>
				decomplexUeDataPdu(skb);
    6427:	e8 fc ff ff ff       	call   6428 <rlc_mac_main+0x2398>
				fsm_mem_free(pdu_type);
    642c:	89 f8                	mov    %edi,%eax
    642e:	e8 fc ff ff ff       	call   642f <rlc_mac_main+0x239f>
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
    6433:	c7 04 24 3c 18 00 00 	movl   $0x183c,(%esp)
    643a:	e8 fc ff ff ff       	call   643b <rlc_mac_main+0x23ab>
    643f:	e9 84 e0 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    6444:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
    644b:	c7 04 24 e0 1d 00 00 	movl   $0x1de0,(%esp)
    6452:	e8 fc ff ff ff       	call   6453 <rlc_mac_main+0x23c3>
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    6457:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    645d:	c7 04 24 98 1d 00 00 	movl   $0x1d98,(%esp)
    6464:	89 44 24 04          	mov    %eax,0x4(%esp)
    6468:	e8 fc ff ff ff       	call   6469 <rlc_mac_main+0x23d9>
    646d:	e9 e5 e2 ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    6472:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6475:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    6479:	c7 04 24 a0 1c 00 00 	movl   $0x1ca0,(%esp)
    6480:	89 44 24 04          	mov    %eax,0x4(%esp)
    6484:	e8 fc ff ff ff       	call   6485 <rlc_mac_main+0x23f5>
    6489:	e9 c9 e2 ff ff       	jmp    4757 <rlc_mac_main+0x6c7>
				decomplexUeDataPdu(skb);
				fsm_mem_free(pdu_type);
				printk("[UE MAC CRA]mac_pkthandler decomplexRARdu: This is a Common DATA PDU !!!\n");
				FOUT;
			}else{
				fsm_pkt_destroy(skb);
    648e:	e8 fc ff ff ff       	call   648f <rlc_mac_main+0x23ff>
				fsm_mem_free(pdu_type);
    6493:	89 f8                	mov    %edi,%eax
    6495:	e8 fc ff ff ff       	call   6496 <rlc_mac_main+0x2406>
				printk("[UE MAC CRA]mac_pkthandler decomplexUeDataPdu: This is a other PDU !!!\n");
    649a:	c7 04 24 88 18 00 00 	movl   $0x1888,(%esp)
    64a1:	e8 fc ff ff ff       	call   64a2 <rlc_mac_main+0x2412>
    64a6:	e9 1d e0 ff ff       	jmp    44c8 <rlc_mac_main+0x438>
    64ab:	90                   	nop
    64ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000064b0 <findInsBylcid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsBylcid(u8 lcid, void **up, void**down, RlcMode *mode)
{
    64b0:	55                   	push   %ebp
    64b1:	89 e5                	mov    %esp,%ebp
    64b3:	57                   	push   %edi
    64b4:	56                   	push   %esi
    64b5:	53                   	push   %ebx
    64b6:	83 ec 10             	sub    $0x10,%esp
    64b9:	e8 fc ff ff ff       	call   64ba <findInsBylcid+0xa>
    64be:	8b 75 08             	mov    0x8(%ebp),%esi
    64c1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    64c4:	89 c3                	mov    %eax,%ebx
    64c6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsBylcid());
	SV_PTR_GET(rlc_mac_sv);
    64c9:	e8 fc ff ff ff       	call   64ca <findInsBylcid+0x1a>
	*up = *down = NULL;
    64ce:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    64d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64d4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    64da:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    64e0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    64e6:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    64ec:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    64f2:	39 d1                	cmp    %edx,%ecx
    64f4:	74 29                	je     651f <findInsBylcid+0x6f>
    64f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    64f9:	8b 7d ec             	mov    -0x14(%ebp),%edi
    64fc:	eb 08                	jmp    6506 <findInsBylcid+0x56>
    64fe:	66 90                	xchg   %ax,%ax
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6500:	8b 12                	mov    (%edx),%edx
    6502:	39 d1                	cmp    %edx,%ecx
    6504:	74 16                	je     651c <findInsBylcid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->lcId == lcid)
    6506:	38 5a e7             	cmp    %bl,-0x19(%edx)
    6509:	75 f5                	jne    6500 <findInsBylcid+0x50>
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    650b:	8d 42 e4             	lea    -0x1c(%edx),%eax
			if(tmTxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    650e:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    6514:	89 07                	mov    %eax,(%edi)
	SV_PTR_GET(rlc_mac_sv);
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6516:	8b 12                	mov    (%edx),%edx
    6518:	39 d1                	cmp    %edx,%ecx
    651a:	75 ea                	jne    6506 <findInsBylcid+0x56>
    651c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    651f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up =  (void*)tmTxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    6525:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    652b:	39 d1                	cmp    %edx,%ecx
    652d:	74 28                	je     6557 <findInsBylcid+0xa7>
    652f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6532:	8b 7d e8             	mov    -0x18(%ebp),%edi
    6535:	eb 07                	jmp    653e <findInsBylcid+0x8e>
    6537:	90                   	nop
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    6538:	8b 12                	mov    (%edx),%edx
    653a:	39 d1                	cmp    %edx,%ecx
    653c:	74 16                	je     6554 <findInsBylcid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->lcId == lcid)
    653e:	38 5a fb             	cmp    %bl,-0x5(%edx)
    6541:	75 f5                	jne    6538 <findInsBylcid+0x88>
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    6543:	8d 42 f8             	lea    -0x8(%edx),%eax
			if(tmRxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    6546:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    654c:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    654e:	8b 12                	mov    (%edx),%edx
    6550:	39 d1                	cmp    %edx,%ecx
    6552:	75 ea                	jne    653e <findInsBylcid+0x8e>
    6554:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down =  (void*)tmRxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if(*mode == TM_MODE)
    6557:	83 3e 01             	cmpl   $0x1,(%esi)
    655a:	0f 84 c8 00 00 00    	je     6628 <findInsBylcid+0x178>
    6560:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    6566:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    656c:	39 d1                	cmp    %edx,%ecx
    656e:	74 27                	je     6597 <findInsBylcid+0xe7>
    6570:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6573:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6576:	eb 06                	jmp    657e <findInsBylcid+0xce>
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    6578:	8b 12                	mov    (%edx),%edx
    657a:	39 d1                	cmp    %edx,%ecx
    657c:	74 16                	je     6594 <findInsBylcid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->lcid == lcid)
    657e:	38 5a d3             	cmp    %bl,-0x2d(%edx)
    6581:	75 f5                	jne    6578 <findInsBylcid+0xc8>
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    6583:	8d 42 d0             	lea    -0x30(%edx),%eax
			if(umTxIns->lcid == lcid)
			{
				*mode = UM_MODE;
    6586:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    658c:	89 07                	mov    %eax,(%edi)
	}
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    658e:	8b 12                	mov    (%edx),%edx
    6590:	39 d1                	cmp    %edx,%ecx
    6592:	75 ea                	jne    657e <findInsBylcid+0xce>
    6594:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6597:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*mode = UM_MODE;
				*up =  (void*)umTxIns;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    659d:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    65a3:	39 d1                	cmp    %edx,%ecx
    65a5:	74 2e                	je     65d5 <findInsBylcid+0x125>
    65a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    65aa:	8b 7d e8             	mov    -0x18(%ebp),%edi
    65ad:	eb 07                	jmp    65b6 <findInsBylcid+0x106>
    65af:	90                   	nop
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    65b0:	8b 12                	mov    (%edx),%edx
    65b2:	39 d1                	cmp    %edx,%ecx
    65b4:	74 1c                	je     65d2 <findInsBylcid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->lcId == lcid)
    65b6:	38 9a 3f ef ff ff    	cmp    %bl,-0x10c1(%edx)
    65bc:	75 f2                	jne    65b0 <findInsBylcid+0x100>
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    65be:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
			if(umRxIns->lcId == lcid)
			{
				*mode = UM_MODE;
    65c4:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    65ca:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    65cc:	8b 12                	mov    (%edx),%edx
    65ce:	39 d1                	cmp    %edx,%ecx
    65d0:	75 e4                	jne    65b6 <findInsBylcid+0x106>
    65d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*mode = UM_MODE;
				*down =  (void*)umRxIns;
			}
		}
	}
	if(*mode == UM_MODE)
    65d5:	83 3e 02             	cmpl   $0x2,(%esi)
    65d8:	74 4e                	je     6628 <findInsBylcid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    65da:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    65e0:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    65e6:	39 c2                	cmp    %eax,%edx
    65e8:	74 3e                	je     6628 <findInsBylcid+0x178>
    65ea:	8b 7d e8             	mov    -0x18(%ebp),%edi
    65ed:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    65f0:	eb 0c                	jmp    65fe <findInsBylcid+0x14e>
    65f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    65f8:	8b 00                	mov    (%eax),%eax
    65fa:	39 c2                	cmp    %eax,%edx
    65fc:	74 2a                	je     6628 <findInsBylcid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->lcId == lcid)
    65fe:	38 98 ff dc ff ff    	cmp    %bl,-0x2301(%eax)
    6604:	75 f2                	jne    65f8 <findInsBylcid+0x148>
			{
				*mode = AM_MODE;
    6606:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    6609:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->lcId == lcid)
			{
				*mode = AM_MODE;
    660f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    6615:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6618:	89 0f                	mov    %ecx,(%edi)
    661a:	89 0e                	mov    %ecx,(%esi)
	}
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    661c:	8b 00                	mov    (%eax),%eax
    661e:	39 c2                	cmp    %eax,%edx
    6620:	75 dc                	jne    65fe <findInsBylcid+0x14e>
    6622:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				//      fsm_printf("am instance(lcid is %d)\n",lcid);
			}
		}
	}
	FOUT;
}
    6628:	83 c4 10             	add    $0x10,%esp
    662b:	5b                   	pop    %ebx
    662c:	5e                   	pop    %esi
    662d:	5f                   	pop    %edi
    662e:	5d                   	pop    %ebp
    662f:	c3                   	ret    

00006630 <isInsideTranWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideTranWin(struct AM_Instance *amIns, SequenceNumber SN)
{
    6630:	55                   	push   %ebp
    6631:	89 e5                	mov    %esp,%ebp
    6633:	53                   	push   %ebx
    6634:	e8 fc ff ff ff       	call   6635 <isInsideTranWin+0x5>
	//printk("[RLC][isInsideTranWin] vt_a=%d, vt_ms=%d, SN=%d\n",amIns->vt_a, amIns->vt_ms, SN);
	//return((amIns->vt_a <= SN)&&(SN < amIns->vt_ms));
	return (SN-amIns->vt_a+1024)%1024 < (amIns->vt_ms-amIns->vt_a+1024)%1024;
    6639:	0f bf 98 66 12 00 00 	movswl 0x1266(%eax),%ebx
    6640:	0f bf 80 68 12 00 00 	movswl 0x1268(%eax),%eax
    6647:	0f bf d2             	movswl %dx,%edx
    664a:	29 da                	sub    %ebx,%edx
    664c:	81 c2 00 04 00 00    	add    $0x400,%edx
    6652:	29 d8                	sub    %ebx,%eax
    6654:	89 d1                	mov    %edx,%ecx
    6656:	05 00 04 00 00       	add    $0x400,%eax
    665b:	c1 f9 1f             	sar    $0x1f,%ecx
    665e:	c1 e9 16             	shr    $0x16,%ecx
    6661:	01 ca                	add    %ecx,%edx
    6663:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6669:	29 ca                	sub    %ecx,%edx
    666b:	89 c1                	mov    %eax,%ecx
    666d:	c1 f9 1f             	sar    $0x1f,%ecx
    6670:	c1 e9 16             	shr    $0x16,%ecx
    6673:	01 c8                	add    %ecx,%eax
    6675:	25 ff 03 00 00       	and    $0x3ff,%eax
    667a:	29 c8                	sub    %ecx,%eax
    667c:	39 c2                	cmp    %eax,%edx
    667e:	0f 9c c0             	setl   %al
}
    6681:	5b                   	pop    %ebx
    6682:	5d                   	pop    %ebp
    6683:	c3                   	ret    
    6684:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    668a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00006690 <isInsideAmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    6690:	55                   	push   %ebp
    6691:	89 e5                	mov    %esp,%ebp
    6693:	56                   	push   %esi
    6694:	53                   	push   %ebx
    6695:	83 ec 14             	sub    $0x14,%esp
    6698:	e8 fc ff ff ff       	call   6699 <isInsideAmRecvWin+0x9>
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    669d:	0f bf 88 ec 22 00 00 	movswl 0x22ec(%eax),%ecx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    66a4:	89 c3                	mov    %eax,%ebx
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    66a6:	0f bf 80 f4 22 00 00 	movswl 0x22f4(%eax),%eax
    66ad:	0f bf f2             	movswl %dx,%esi
    66b0:	89 ca                	mov    %ecx,%edx
    66b2:	89 74 24 0c          	mov    %esi,0xc(%esp)
    66b6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    66ba:	29 c2                	sub    %eax,%edx
    66bc:	89 54 24 10          	mov    %edx,0x10(%esp)
    66c0:	89 44 24 04          	mov    %eax,0x4(%esp)
    66c4:	c7 04 24 08 20 00 00 	movl   $0x2008,(%esp)
    66cb:	e8 fc ff ff ff       	call   66cc <isInsideAmRecvWin+0x3c>
	return (SN-amIns->vr_r+1024)%1024 < (amIns->vr_mr-amIns->vr_r+1024)%1024;
    66d0:	0f bf 93 f4 22 00 00 	movswl 0x22f4(%ebx),%edx
    66d7:	29 d6                	sub    %edx,%esi
    66d9:	81 c6 00 04 00 00    	add    $0x400,%esi
    66df:	89 f0                	mov    %esi,%eax
    66e1:	c1 f8 1f             	sar    $0x1f,%eax
    66e4:	c1 e8 16             	shr    $0x16,%eax
    66e7:	01 c6                	add    %eax,%esi
    66e9:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    66ef:	29 c6                	sub    %eax,%esi
    66f1:	0f bf 83 ec 22 00 00 	movswl 0x22ec(%ebx),%eax
    66f8:	29 d0                	sub    %edx,%eax
    66fa:	05 00 04 00 00       	add    $0x400,%eax
    66ff:	89 c2                	mov    %eax,%edx
    6701:	c1 fa 1f             	sar    $0x1f,%edx
    6704:	c1 ea 16             	shr    $0x16,%edx
    6707:	01 d0                	add    %edx,%eax
    6709:	25 ff 03 00 00       	and    $0x3ff,%eax
    670e:	29 d0                	sub    %edx,%eax
    6710:	39 c6                	cmp    %eax,%esi
    6712:	0f 9c c0             	setl   %al
}
    6715:	83 c4 14             	add    $0x14,%esp
    6718:	5b                   	pop    %ebx
    6719:	5e                   	pop    %esi
    671a:	5d                   	pop    %ebp
    671b:	c3                   	ret    
    671c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006720 <isInsideUmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6720:	55                   	push   %ebp
    6721:	89 e5                	mov    %esp,%ebp
    6723:	e8 fc ff ff ff       	call   6724 <isInsideUmRecvWin+0x4>
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6728:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    672d:	0f bf 80 c0 10 00 00 	movswl 0x10c0(%eax),%eax
    6734:	0f bf d2             	movswl %dx,%edx
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6737:	74 27                	je     6760 <isInsideUmRecvWin+0x40>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    6739:	29 c2                	sub    %eax,%edx
    673b:	81 c2 00 06 00 00    	add    $0x600,%edx
    6741:	89 d0                	mov    %edx,%eax
    6743:	c1 f8 1f             	sar    $0x1f,%eax
    6746:	c1 e8 16             	shr    $0x16,%eax
    6749:	01 c2                	add    %eax,%edx
    674b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6751:	29 c2                	sub    %eax,%edx
    6753:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    6759:	0f 9e c0             	setle  %al
	}
}
    675c:	5d                   	pop    %ebp
    675d:	c3                   	ret    
    675e:	66 90                	xchg   %ax,%ax
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    6760:	29 c2                	sub    %eax,%edx
    6762:	83 c2 30             	add    $0x30,%edx
    6765:	89 d0                	mov    %edx,%eax
    6767:	c1 f8 1f             	sar    $0x1f,%eax
    676a:	c1 e8 1b             	shr    $0x1b,%eax
    676d:	01 c2                	add    %eax,%edx
    676f:	83 e2 1f             	and    $0x1f,%edx
    6772:	29 c2                	sub    %eax,%edx
    6774:	83 fa 0f             	cmp    $0xf,%edx
    6777:	0f 9e c0             	setle  %al
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
	}
}
    677a:	5d                   	pop    %ebp
    677b:	c3                   	ret    
    677c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006780 <isOrderedUm>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isOrderedUm(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6780:	55                   	push   %ebp
    6781:	89 e5                	mov    %esp,%ebp
    6783:	53                   	push   %ebx
    6784:	e8 fc ff ff ff       	call   6785 <isOrderedUm+0x5>
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6789:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    678e:	0f bf 98 c0 10 00 00 	movswl 0x10c0(%eax),%ebx
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6795:	74 51                	je     67e8 <isOrderedUm+0x68>
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
	}
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
    6797:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    679e:	b9 00 02 00 00       	mov    $0x200,%ecx
    67a3:	0f bf d2             	movswl %dx,%edx
    67a6:	29 d9                	sub    %ebx,%ecx
    67a8:	8d 94 11 00 04 00 00 	lea    0x400(%ecx,%edx,1),%edx
    67af:	89 d3                	mov    %edx,%ebx
    67b1:	8d 84 01 00 04 00 00 	lea    0x400(%ecx,%eax,1),%eax
    67b8:	89 c1                	mov    %eax,%ecx
    67ba:	c1 fb 1f             	sar    $0x1f,%ebx
    67bd:	c1 f9 1f             	sar    $0x1f,%ecx
    67c0:	c1 eb 16             	shr    $0x16,%ebx
    67c3:	c1 e9 16             	shr    $0x16,%ecx
    67c6:	01 da                	add    %ebx,%edx
    67c8:	01 c8                	add    %ecx,%eax
    67ca:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    67d0:	25 ff 03 00 00       	and    $0x3ff,%eax
    67d5:	29 da                	sub    %ebx,%edx
    67d7:	29 c8                	sub    %ecx,%eax
    67d9:	39 c2                	cmp    %eax,%edx
    67db:	0f 9c c0             	setl   %al
	}
}
    67de:	5b                   	pop    %ebx
    67df:	5d                   	pop    %ebp
    67e0:	c3                   	ret    
    67e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    67e8:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    67ef:	b9 10 00 00 00       	mov    $0x10,%ecx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    67f4:	0f bf d2             	movswl %dx,%edx
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    67f7:	29 d9                	sub    %ebx,%ecx
    67f9:	8d 54 11 20          	lea    0x20(%ecx,%edx,1),%edx
    67fd:	89 d3                	mov    %edx,%ebx
    67ff:	8d 44 01 20          	lea    0x20(%ecx,%eax,1),%eax
    6803:	89 c1                	mov    %eax,%ecx
    6805:	c1 fb 1f             	sar    $0x1f,%ebx
    6808:	c1 f9 1f             	sar    $0x1f,%ecx
    680b:	c1 eb 1b             	shr    $0x1b,%ebx
    680e:	c1 e9 1b             	shr    $0x1b,%ecx
    6811:	01 da                	add    %ebx,%edx
    6813:	01 c8                	add    %ecx,%eax
    6815:	83 e2 1f             	and    $0x1f,%edx
    6818:	83 e0 1f             	and    $0x1f,%eax
    681b:	29 da                	sub    %ebx,%edx
    681d:	29 c8                	sub    %ecx,%eax
    681f:	39 c2                	cmp    %eax,%edx
    6821:	0f 9c c0             	setl   %al
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
	}
}
    6824:	5b                   	pop    %ebx
    6825:	5d                   	pop    %ebp
    6826:	c3                   	ret    
    6827:	89 f6                	mov    %esi,%esi
    6829:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00006830 <countSegInd>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
    6830:	55                   	push   %ebp
    6831:	89 e5                	mov    %esp,%ebp
    6833:	e8 fc ff ff ff       	call   6834 <countSegInd+0x4>
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6838:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    683e:	31 c0                	xor    %eax,%eax
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    6840:	f6 42 01 04          	testb  $0x4,0x1(%edx)
    6844:	74 20                	je     6866 <countSegInd+0x36>
	{
		count++;
		while(1 == (ind++)->E)
    6846:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    684a:	b0 01                	mov    $0x1,%al
    684c:	79 18                	jns    6866 <countSegInd+0x36>
    684e:	83 c2 06             	add    $0x6,%edx
    6851:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    6858:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
		{
			count++;
    685c:	83 c0 01             	add    $0x1,%eax
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    685f:	83 c2 02             	add    $0x2,%edx
    6862:	84 c9                	test   %cl,%cl
    6864:	78 f2                	js     6858 <countSegInd+0x28>
		{
			count++;
		}
	}
	return count;
}
    6866:	5d                   	pop    %ebp
    6867:	c3                   	ret    
    6868:	90                   	nop
    6869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006870 <assamble_segment>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6870:	55                   	push   %ebp
    6871:	89 e5                	mov    %esp,%ebp
    6873:	57                   	push   %edi
    6874:	56                   	push   %esi
    6875:	53                   	push   %ebx
    6876:	83 ec 20             	sub    $0x20,%esp
    6879:	e8 fc ff ff ff       	call   687a <assamble_segment+0xa>
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    687e:	8b 9a ac 00 00 00    	mov    0xac(%edx),%ebx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6884:	89 c6                	mov    %eax,%esi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6886:	8b 00                	mov    (%eax),%eax
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6888:	89 55 ec             	mov    %edx,-0x14(%ebp)
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    688b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    688e:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6895:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    689b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    689e:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    68a2:	74 34                	je     68d8 <assamble_segment+0x68>
	{
		count++;
		while(1 == (ind++)->E)
    68a4:	c7 45 e8 06 00 00 00 	movl   $0x6,-0x18(%ebp)
    68ab:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    68af:	79 27                	jns    68d8 <assamble_segment+0x68>
    68b1:	83 c0 06             	add    $0x6,%eax
    68b4:	ba 01 00 00 00       	mov    $0x1,%edx
    68b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    68c0:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    68c4:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    68c7:	83 c0 02             	add    $0x2,%eax
    68ca:	84 c9                	test   %cl,%cl
    68cc:	78 f2                	js     68c0 <assamble_segment+0x50>
    68ce:	8d 54 12 04          	lea    0x4(%edx,%edx,1),%edx
    68d2:	0f b7 d2             	movzwl %dx,%edx
    68d5:	89 55 e8             	mov    %edx,-0x18(%ebp)
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    68d8:	8b 7d f0             	mov    -0x10(%ebp),%edi
	u32 posEnd = posStart + pkt->len - headLen;
    68db:	8b 55 ec             	mov    -0x14(%ebp),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    68de:	0f b6 5f 03          	movzbl 0x3(%edi),%ebx
    68e2:	0f b6 47 02          	movzbl 0x2(%edi),%eax
	u32 posEnd = posStart + pkt->len - headLen;
    68e6:	8b 4a 50             	mov    0x50(%edx),%ecx
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    68e9:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    68ef:	83 e3 7f             	and    $0x7f,%ebx
    68f2:	c1 e3 08             	shl    $0x8,%ebx
    68f5:	09 c3                	or     %eax,%ebx
	u32 posEnd = posStart + pkt->len - headLen;
    68f7:	8d 3c 0b             	lea    (%ebx,%ecx,1),%edi
    68fa:	89 7d e0             	mov    %edi,-0x20(%ebp)
    68fd:	2b 7d e8             	sub    -0x18(%ebp),%edi
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6900:	85 d2                	test   %edx,%edx
    6902:	74 1b                	je     691f <assamble_segment+0xaf>
    6904:	31 c0                	xor    %eax,%eax
    6906:	66 90                	xchg   %ax,%ax
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
    6908:	3b 5c 86 10          	cmp    0x10(%esi,%eax,4),%ebx
    690c:	72 0a                	jb     6918 <assamble_segment+0xa8>
    690e:	3b 7c 86 50          	cmp    0x50(%esi,%eax,4),%edi
    6912:	0f 86 50 01 00 00    	jbe    6a68 <assamble_segment+0x1f8>
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6918:	83 c0 01             	add    $0x1,%eax
    691b:	39 d0                	cmp    %edx,%eax
    691d:	75 e9                	jne    6908 <assamble_segment+0x98>
	char *posbuf = (char*)ambuf->pkt->data;
	int i, j,datalen = 0;
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
    691f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6922:	03 45 e8             	add    -0x18(%ebp),%eax
    6925:	89 45 d8             	mov    %eax,-0x28(%ebp)
	}
	//fsm_printf("[RLC][assamble_segment] ambuf->datalen is %d\n",ambuf->datalen);
	//fsm_printf("[RLC][assamble_segment] ambuf->segEnd[ambuf->segnum - 1] is %d\n",ambuf->segEnd[ambuf->segnum - 1]);
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
    6928:	8d 42 ff             	lea    -0x1(%edx),%eax
    692b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    692e:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6932:	39 c7                	cmp    %eax,%edi
    6934:	0f 82 3e 01 00 00    	jb     6a78 <assamble_segment+0x208>
	//
	else
	{
		//fsm_printf("[RLC][assamble_segment] have not received the last segment\n");
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
    693a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    693d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6941:	78 6d                	js     69b0 <assamble_segment+0x140>
    6943:	39 c7                	cmp    %eax,%edi
    6945:	77 69                	ja     69b0 <assamble_segment+0x140>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
		ambuf->datalen = datalen;
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6947:	39 c3                	cmp    %eax,%ebx
    6949:	0f 87 f9 00 00 00    	ja     6a48 <assamble_segment+0x1d8>
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    694f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6952:	85 d2                	test   %edx,%edx
    6954:	7e 3b                	jle    6991 <assamble_segment+0x121>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6956:	8d 44 96 10          	lea    0x10(%esi,%edx,4),%eax
    695a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
			{
				//10:
				if((ambuf->segStart[i] <= posStart)&&(posStart <= ambuf->segEnd[i]))
    6960:	8b 08                	mov    (%eax),%ecx
    6962:	39 cb                	cmp    %ecx,%ebx
    6964:	72 09                	jb     696f <assamble_segment+0xff>
    6966:	3b 58 40             	cmp    0x40(%eax),%ebx
    6969:	0f 86 5f 02 00 00    	jbe    6bce <assamble_segment+0x35e>
					ambuf->segEnd[i] = posEnd;
					ambuf->segnum = i + 1;
					FOUT;
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
    696f:	3b 58 3c             	cmp    0x3c(%eax),%ebx
    6972:	76 08                	jbe    697c <assamble_segment+0x10c>
    6974:	39 cb                	cmp    %ecx,%ebx
    6976:	0f 86 4e 02 00 00    	jbe    6bca <assamble_segment+0x35a>
					ambuf->segnum = i + 1;
					FOUT;
				}
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
    697c:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    6983:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    6989:	83 e8 04             	sub    $0x4,%eax
    698c:	83 ea 01             	sub    $0x1,%edx
    698f:	75 cf                	jne    6960 <assamble_segment+0xf0>
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
				}
			}
			if(posStart > ambuf->segStart[0])
    6991:	3b 5e 10             	cmp    0x10(%esi),%ebx
    6994:	77 03                	ja     6999 <assamble_segment+0x129>
				ambuf->segnum = 1;
				FOUT;
			}
            else
            {
	            ambuf->segStart[0]  = posStart;
    6996:	89 5e 10             	mov    %ebx,0x10(%esi)
	            ambuf->segEnd[0] = posEnd;
    6999:	89 7e 50             	mov    %edi,0x50(%esi)
	            ambuf->segnum = 1;
    699c:	c7 86 90 00 00 00 01 	movl   $0x1,0x90(%esi)
    69a3:	00 00 00 
	            FOUT;
			}
		}
	}
}
    69a6:	83 c4 20             	add    $0x20,%esp
    69a9:	5b                   	pop    %ebx
    69aa:	5e                   	pop    %esi
    69ab:	5f                   	pop    %edi
    69ac:	5d                   	pop    %ebp
    69ad:	c3                   	ret    
    69ae:	66 90                	xchg   %ax,%ax
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
		{
			//pdu
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    69b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    69b3:	e8 fc ff ff ff       	call   69b4 <assamble_segment+0x144>
    69b8:	03 45 e0             	add    -0x20(%ebp),%eax
    69bb:	e8 fc ff ff ff       	call   69bc <assamble_segment+0x14c>
    69c0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
    69c3:	8b 06                	mov    (%esi),%eax
    69c5:	8b 48 50             	mov    0x50(%eax),%ecx
    69c8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    69ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    69d1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    69d7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    69da:	e8 fc ff ff ff       	call   69db <assamble_segment+0x16b>
			fsm_skb_put(pkptr, datalen);
    69df:	8b 55 e0             	mov    -0x20(%ebp),%edx
    69e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    69e5:	e8 fc ff ff ff       	call   69e6 <assamble_segment+0x176>
			fsm_pkt_destroy(ambuf->pkt);
    69ea:	8b 06                	mov    (%esi),%eax
    69ec:	e8 fc ff ff ff       	call   69ed <assamble_segment+0x17d>
			ambuf->pkt = pkptr;
    69f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    69f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
    69f7:	89 06                	mov    %eax,(%esi)
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    69f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    69fc:	8b 4a 50             	mov    0x50(%edx),%ecx
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    69ff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6a02:	01 d8                	add    %ebx,%eax
    6a04:	03 82 ac 00 00 00    	add    0xac(%edx),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6a0a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    6a0d:	e8 fc ff ff ff       	call   6a0e <assamble_segment+0x19e>
			fsm_pkt_destroy(pkt);
    6a12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a15:	e8 fc ff ff ff       	call   6a16 <assamble_segment+0x1a6>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    6a1a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    6a1d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6a21:	0f 89 bc 01 00 00    	jns    6be3 <assamble_segment+0x373>
		ambuf->datalen = datalen;
    6a27:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6a2a:	89 96 98 00 00 00    	mov    %edx,0x98(%esi)
    6a30:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6a36:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6a3a:	8d 4a ff             	lea    -0x1(%edx),%ecx
    6a3d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6a40:	39 c3                	cmp    %eax,%ebx
    6a42:	0f 86 07 ff ff ff    	jbe    694f <assamble_segment+0xdf>
		{
			ambuf->segEnd[ambuf->segnum] = posEnd;
    6a48:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
			ambuf->segStart[ambuf->segnum]  = posStart;
    6a4c:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
			ambuf->segnum++;
    6a50:	83 c2 01             	add    $0x1,%edx
    6a53:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6a59:	83 c4 20             	add    $0x20,%esp
    6a5c:	5b                   	pop    %ebx
    6a5d:	5e                   	pop    %esi
    6a5e:	5f                   	pop    %edi
    6a5f:	5d                   	pop    %ebp
    6a60:	c3                   	ret    
    6a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
		{
			//fsm_printf("[RLC][assamble_segment] this segment has been received\n");
			fsm_pkt_destroy(pkt);
    6a68:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a6b:	e8 fc ff ff ff       	call   6a6c <assamble_segment+0x1fc>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6a70:	83 c4 20             	add    $0x20,%esp
    6a73:	5b                   	pop    %ebx
    6a74:	5e                   	pop    %esi
    6a75:	5f                   	pop    %edi
    6a76:	5d                   	pop    %ebp
    6a77:	c3                   	ret    
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
    6a78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6a7b:	03 45 e8             	add    -0x18(%ebp),%eax
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6a7e:	8b 55 d8             	mov    -0x28(%ebp),%edx
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
    6a81:	01 d8                	add    %ebx,%eax
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6a83:	e8 fc ff ff ff       	call   6a84 <assamble_segment+0x214>
		fsm_pkt_destroy(pkt);
    6a88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a8b:	e8 fc ff ff ff       	call   6a8c <assamble_segment+0x21c>
		pkt = NULL;
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
    6a90:	8b 46 10             	mov    0x10(%esi),%eax
    6a93:	85 c0                	test   %eax,%eax
    6a95:	7e 29                	jle    6ac0 <assamble_segment+0x250>
    6a97:	3b 7e 14             	cmp    0x14(%esi),%edi
    6a9a:	73 24                	jae    6ac0 <assamble_segment+0x250>
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    6a9c:	39 c3                	cmp    %eax,%ebx
    6a9e:	0f 82 54 01 00 00    	jb     6bf8 <assamble_segment+0x388>
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    6aa4:	77 1a                	ja     6ac0 <assamble_segment+0x250>
    6aa6:	39 c7                	cmp    %eax,%edi
    6aa8:	76 16                	jbe    6ac0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    6aaa:	8b 46 50             	mov    0x50(%esi),%eax
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    6aad:	39 c3                	cmp    %eax,%ebx
    6aaf:	90                   	nop
    6ab0:	73 0e                	jae    6ac0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    6ab2:	39 c7                	cmp    %eax,%edi
    6ab4:	76 0a                	jbe    6ac0 <assamble_segment+0x250>
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
    6ab6:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    6ab9:	89 7e 50             	mov    %edi,0x50(%esi)
				FOUT;
    6abc:	eb b2                	jmp    6a70 <assamble_segment+0x200>
    6abe:	66 90                	xchg   %ax,%ax
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6ac0:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6ac6:	89 ca                	mov    %ecx,%edx
    6ac8:	83 ea 01             	sub    $0x1,%edx
    6acb:	89 55 dc             	mov    %edx,-0x24(%ebp)
    6ace:	74 a0                	je     6a70 <assamble_segment+0x200>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				FOUT;
    6ad0:	89 75 ec             	mov    %esi,-0x14(%ebp)
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6ad3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    6ada:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    6add:	89 75 e0             	mov    %esi,-0x20(%ebp)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6ae0:	8b 75 ec             	mov    -0x14(%ebp),%esi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6ae3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6ae6:	8b 46 50             	mov    0x50(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6ae9:	83 eb 01             	sub    $0x1,%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6aec:	39 45 e8             	cmp    %eax,-0x18(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6aef:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    6af2:	76 14                	jbe    6b08 <assamble_segment+0x298>
    6af4:	8b 56 14             	mov    0x14(%esi),%edx
    6af7:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    6afa:	73 0c                	jae    6b08 <assamble_segment+0x298>
    6afc:	39 c7                	cmp    %eax,%edi
    6afe:	76 08                	jbe    6b08 <assamble_segment+0x298>
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
    6b00:	39 d7                	cmp    %edx,%edi
    6b02:	0f 82 5d 03 00 00    	jb     6e65 <assamble_segment+0x5f5>
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
    6b08:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    6b0b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    6b0e:	3b 73 10             	cmp    0x10(%ebx),%esi
    6b11:	72 5d                	jb     6b70 <assamble_segment+0x300>
    6b13:	39 c6                	cmp    %eax,%esi
    6b15:	77 5e                	ja     6b75 <assamble_segment+0x305>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6b17:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    6b1a:	76 34                	jbe    6b50 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6b1f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    6b22:	8d 44 93 10          	lea    0x10(%ebx,%edx,4),%eax
    6b26:	66 90                	xchg   %ax,%ax
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6b28:	8b 18                	mov    (%eax),%ebx
    6b2a:	39 df                	cmp    %ebx,%edi
    6b2c:	72 0b                	jb     6b39 <assamble_segment+0x2c9>
    6b2e:	8b 70 40             	mov    0x40(%eax),%esi
    6b31:	39 f7                	cmp    %esi,%edi
    6b33:	0f 86 09 01 00 00    	jbe    6c42 <assamble_segment+0x3d2>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6b39:	3b 78 3c             	cmp    0x3c(%eax),%edi
    6b3c:	72 08                	jb     6b46 <assamble_segment+0x2d6>
    6b3e:	39 df                	cmp    %ebx,%edi
    6b40:	0f 82 76 01 00 00    	jb     6cbc <assamble_segment+0x44c>
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6b46:	83 c2 01             	add    $0x1,%edx
    6b49:	83 c0 04             	add    $0x4,%eax
    6b4c:	39 d1                	cmp    %edx,%ecx
    6b4e:	77 d8                	ja     6b28 <assamble_segment+0x2b8>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6b53:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6b56:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
    6b5a:	83 c0 01             	add    $0x1,%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6b5d:	39 55 dc             	cmp    %edx,-0x24(%ebp)
    6b60:	0f 86 0a ff ff ff    	jbe    6a70 <assamble_segment+0x200>
    6b66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b69:	e9 72 ff ff ff       	jmp    6ae0 <assamble_segment+0x270>
    6b6e:	66 90                	xchg   %ax,%ax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6b70:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6b73:	72 db                	jb     6b50 <assamble_segment+0x2e0>
    6b75:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b78:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6b7b:	83 c0 04             	add    $0x4,%eax
    6b7e:	8b 1c 82             	mov    (%edx,%eax,4),%ebx
    6b81:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
    6b84:	89 45 d8             	mov    %eax,-0x28(%ebp)
    6b87:	77 c7                	ja     6b50 <assamble_segment+0x2e0>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6b89:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    6b8c:	76 c2                	jbe    6b50 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b8e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6b91:	8d 44 b2 14          	lea    0x14(%edx,%esi,4),%eax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6b95:	89 f2                	mov    %esi,%edx
    6b97:	eb 0c                	jmp    6ba5 <assamble_segment+0x335>
    6b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6ba0:	8b 18                	mov    (%eax),%ebx
    6ba2:	83 c0 04             	add    $0x4,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6ba5:	39 df                	cmp    %ebx,%edi
    6ba7:	72 0b                	jb     6bb4 <assamble_segment+0x344>
    6ba9:	8b 70 3c             	mov    0x3c(%eax),%esi
    6bac:	39 f7                	cmp    %esi,%edi
    6bae:	0f 86 08 02 00 00    	jbe    6dbc <assamble_segment+0x54c>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6bb4:	3b 78 38             	cmp    0x38(%eax),%edi
    6bb7:	72 08                	jb     6bc1 <assamble_segment+0x351>
    6bb9:	39 df                	cmp    %ebx,%edi
    6bbb:	0f 82 73 01 00 00    	jb     6d34 <assamble_segment+0x4c4>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6bc1:	83 c2 01             	add    $0x1,%edx
    6bc4:	39 d1                	cmp    %edx,%ecx
    6bc6:	77 d8                	ja     6ba0 <assamble_segment+0x330>
    6bc8:	eb 86                	jmp    6b50 <assamble_segment+0x2e0>
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
				{
					//fsm_printf("[RLC][assamble_segment] condition 11\n");
					ambuf->segStart[i] = posStart;
    6bca:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
					ambuf->segEnd[i] = posEnd;
    6bce:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
					ambuf->segnum = i + 1;
    6bd2:	83 c2 01             	add    $0x1,%edx
    6bd5:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6bdb:	83 c4 20             	add    $0x20,%esp
    6bde:	5b                   	pop    %ebx
    6bdf:	5e                   	pop    %esi
    6be0:	5f                   	pop    %edi
    6be1:	5d                   	pop    %ebp
    6be2:	c3                   	ret    
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
			fsm_pkt_destroy(pkt);
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    6be3:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6be9:	8d 42 ff             	lea    -0x1(%edx),%eax
    6bec:	89 45 dc             	mov    %eax,-0x24(%ebp)
    6bef:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6bf3:	e9 4f fd ff ff       	jmp    6947 <assamble_segment+0xd7>
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    6bf8:	39 c7                	cmp    %eax,%edi
    6bfa:	0f 83 4c 02 00 00    	jae    6e4c <assamble_segment+0x5dc>
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6c00:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6c06:	89 ca                	mov    %ecx,%edx
    6c08:	83 ea 01             	sub    $0x1,%edx
    6c0b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    6c0e:	78 1b                	js     6c2b <assamble_segment+0x3bb>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c10:	8d 44 8e 4c          	lea    0x4c(%esi,%ecx,4),%eax
    6c14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
    6c18:	8b 08                	mov    (%eax),%ecx
    6c1a:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[i+1] = ambuf->segStart[i];
    6c1d:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6c20:	89 48 c4             	mov    %ecx,-0x3c(%eax)
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6c23:	83 e8 04             	sub    $0x4,%eax
    6c26:	83 ea 01             	sub    $0x1,%edx
    6c29:	79 ed                	jns    6c18 <assamble_segment+0x3a8>
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
    6c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
    6c2e:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    6c31:	89 7e 50             	mov    %edi,0x50(%esi)
				ambuf->segnum++;
    6c34:	83 c0 01             	add    $0x1,%eax
    6c37:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
				FOUT;
    6c3d:	e9 2e fe ff ff       	jmp    6a70 <assamble_segment+0x200>
    6c42:	89 f0                	mov    %esi,%eax
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6c44:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6c47:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;j++;
    6c4a:	8d 5a 01             	lea    0x1(%edx),%ebx
						for(; i < ambuf->segnum; j++, i++)
    6c4d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6c50:	89 44 be 50          	mov    %eax,0x50(%esi,%edi,4)
						i++;j++;
    6c54:	8b 7d f0             	mov    -0x10(%ebp),%edi
						for(; i < ambuf->segnum; j++, i++)
    6c57:	39 f9                	cmp    %edi,%ecx
    6c59:	76 4f                	jbe    6caa <assamble_segment+0x43a>
    6c5b:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c61:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
    6c65:	89 75 f0             	mov    %esi,-0x10(%ebp)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6c68:	89 45 ec             	mov    %eax,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c6b:	8d 44 be 50          	lea    0x50(%esi,%edi,4),%eax
    6c6f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6c72:	eb 20                	jmp    6c94 <assamble_segment+0x424>
    6c74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6c78:	8b 0a                	mov    (%edx),%ecx
    6c7a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6c7c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6c7f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6c82:	83 c7 01             	add    $0x1,%edi
    6c85:	83 c3 01             	add    $0x1,%ebx
    6c88:	83 c2 04             	add    $0x4,%edx
    6c8b:	83 c0 04             	add    $0x4,%eax
    6c8e:	39 f7                	cmp    %esi,%edi
    6c90:	73 15                	jae    6ca7 <assamble_segment+0x437>
    6c92:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6c94:	39 cb                	cmp    %ecx,%ebx
    6c96:	72 e0                	jb     6c78 <assamble_segment+0x408>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6c98:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6c9e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6ca5:	eb db                	jmp    6c82 <assamble_segment+0x412>
    6ca7:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6caa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6cad:	29 df                	sub    %ebx,%edi
    6caf:	01 f8                	add    %edi,%eax
    6cb1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6cb7:	e9 b4 fd ff ff       	jmp    6a70 <assamble_segment+0x200>
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6cbc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6cbf:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6cc2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6cc5:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6cc9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						for(; i < ambuf->segnum; j++, i++)
    6ccc:	39 d9                	cmp    %ebx,%ecx
    6cce:	76 52                	jbe    6d22 <assamble_segment+0x4b2>
    6cd0:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6cd6:	8d 44 9e 50          	lea    0x50(%esi,%ebx,4),%eax
    6cda:	89 75 f0             	mov    %esi,-0x10(%ebp)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6cdd:	89 7d ec             	mov    %edi,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6ce0:	8d 7c 96 50          	lea    0x50(%esi,%edx,4),%edi
    6ce4:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6ce7:	eb 23                	jmp    6d0c <assamble_segment+0x49c>
    6ce9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6cf0:	8b 0f                	mov    (%edi),%ecx
    6cf2:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6cf4:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6cf7:	89 48 c0             	mov    %ecx,-0x40(%eax)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6cfa:	83 c3 01             	add    $0x1,%ebx
    6cfd:	83 c2 01             	add    $0x1,%edx
    6d00:	83 c7 04             	add    $0x4,%edi
    6d03:	83 c0 04             	add    $0x4,%eax
    6d06:	39 de                	cmp    %ebx,%esi
    6d08:	76 15                	jbe    6d1f <assamble_segment+0x4af>
    6d0a:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6d0c:	39 d1                	cmp    %edx,%ecx
    6d0e:	77 e0                	ja     6cf0 <assamble_segment+0x480>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6d10:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6d16:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6d1d:	eb db                	jmp    6cfa <assamble_segment+0x48a>
    6d1f:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6d22:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d25:	29 d3                	sub    %edx,%ebx
    6d27:	01 d8                	add    %ebx,%eax
    6d29:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6d2f:	e9 3c fd ff ff       	jmp    6a70 <assamble_segment+0x200>
    6d34:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6d37:	8b 75 e0             	mov    -0x20(%ebp),%esi
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
    6d3a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6d3d:	89 1c 86             	mov    %ebx,(%esi,%eax,4)
						ambuf->segEnd[i] = posEnd;
    6d40:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6d43:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
    6d46:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6d4a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6d4d:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6d50:	39 d9                	cmp    %ebx,%ecx
    6d52:	76 56                	jbe    6daa <assamble_segment+0x53a>
    6d54:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6d5a:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6d5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6d61:	89 7d f0             	mov    %edi,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6d64:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6d67:	8d 44 be 58          	lea    0x58(%esi,%edi,4),%eax
    6d6b:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6d6e:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6d71:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6d74:	eb 1e                	jmp    6d94 <assamble_segment+0x524>
    6d76:	66 90                	xchg   %ax,%ax
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6d78:	8b 0f                	mov    (%edi),%ecx
    6d7a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6d7c:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6d7f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6d82:	83 c3 01             	add    $0x1,%ebx
    6d85:	83 c2 01             	add    $0x1,%edx
    6d88:	83 c7 04             	add    $0x4,%edi
    6d8b:	83 c0 04             	add    $0x4,%eax
    6d8e:	39 de                	cmp    %ebx,%esi
    6d90:	76 15                	jbe    6da7 <assamble_segment+0x537>
    6d92:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6d94:	39 ca                	cmp    %ecx,%edx
    6d96:	72 e0                	jb     6d78 <assamble_segment+0x508>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6d98:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6d9e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6da5:	eb db                	jmp    6d82 <assamble_segment+0x512>
    6da7:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6daa:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dad:	29 d3                	sub    %edx,%ebx
    6daf:	01 d8                	add    %ebx,%eax
    6db1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6db7:	e9 b4 fc ff ff       	jmp    6a70 <assamble_segment+0x200>
    6dbc:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6dbf:	89 f0                	mov    %esi,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
    6dc1:	8b 7d d8             	mov    -0x28(%ebp),%edi
    6dc4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6dc7:	89 1c be             	mov    %ebx,(%esi,%edi,4)
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6dca:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;j++;
    6dcd:	8d 7a 01             	lea    0x1(%edx),%edi
						for(; i < ambuf->segnum; j++, i++)
    6dd0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6dd3:	89 44 9e 50          	mov    %eax,0x50(%esi,%ebx,4)
						i++;j++;
    6dd7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6dda:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6ddd:	39 d9                	cmp    %ebx,%ecx
    6ddf:	76 59                	jbe    6e3a <assamble_segment+0x5ca>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6de1:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6de5:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6deb:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6dee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6df1:	89 45 f0             	mov    %eax,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6df4:	8d 44 96 58          	lea    0x58(%esi,%edx,4),%eax
    6df8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6dfb:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6dfe:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6e01:	eb 21                	jmp    6e24 <assamble_segment+0x5b4>
    6e03:	90                   	nop
    6e04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6e08:	8b 0a                	mov    (%edx),%ecx
    6e0a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6e0c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6e0f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6e12:	83 c3 01             	add    $0x1,%ebx
    6e15:	83 c7 01             	add    $0x1,%edi
    6e18:	83 c2 04             	add    $0x4,%edx
    6e1b:	83 c0 04             	add    $0x4,%eax
    6e1e:	39 de                	cmp    %ebx,%esi
    6e20:	76 15                	jbe    6e37 <assamble_segment+0x5c7>
    6e22:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6e24:	39 cf                	cmp    %ecx,%edi
    6e26:	72 e0                	jb     6e08 <assamble_segment+0x598>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6e28:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6e2e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6e35:	eb db                	jmp    6e12 <assamble_segment+0x5a2>
    6e37:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6e3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e3d:	29 fb                	sub    %edi,%ebx
    6e3f:	01 d8                	add    %ebx,%eax
    6e41:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6e47:	e9 24 fc ff ff       	jmp    6a70 <assamble_segment+0x200>
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//2:
			if((posStart < ambuf->segStart[0] )&&(ambuf->segStart[0] < posEnd)&&(posEnd <= ambuf->segEnd[0]))
    6e4c:	0f 86 6e fc ff ff    	jbe    6ac0 <assamble_segment+0x250>
    6e52:	3b 7e 50             	cmp    0x50(%esi),%edi
    6e55:	0f 87 4f fc ff ff    	ja     6aaa <assamble_segment+0x23a>
			{
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
    6e5b:	89 5e 10             	mov    %ebx,0x10(%esi)
    6e5e:	66 90                	xchg   %ax,%ax
				FOUT;
    6e60:	e9 0b fc ff ff       	jmp    6a70 <assamble_segment+0x200>
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6e65:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6e68:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6e6b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6e6e:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6e71:	7e 20                	jle    6e93 <assamble_segment+0x623>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6e73:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6e77:	89 4d f0             	mov    %ecx,-0x10(%ebp)
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6e7a:	8b 08                	mov    (%eax),%ecx
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6e7c:	83 ea 01             	sub    $0x1,%edx
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6e7f:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[j+1] = ambuf->segStart[j];
    6e82:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6e85:	89 48 c4             	mov    %ecx,-0x3c(%eax)
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6e88:	83 e8 04             	sub    $0x4,%eax
    6e8b:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6e8e:	7f ea                	jg     6e7a <assamble_segment+0x60a>
    6e90:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
    6e93:	83 c1 01             	add    $0x1,%ecx
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
    6e96:	89 5c 96 14          	mov    %ebx,0x14(%esi,%edx,4)
				ambuf->segEnd[j+1] = posEnd;
    6e9a:	89 7c 96 54          	mov    %edi,0x54(%esi,%edx,4)
				ambuf->segnum++;
    6e9e:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
				FOUT;
    6ea4:	e9 c7 fb ff ff       	jmp    6a70 <assamble_segment+0x200>
    6ea9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006eb0 <rlc_pkt_receive_from_mac>:
**-------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
******************************************************************************/
void rlc_pkt_receive_from_mac(FSM_PKT * skb)
{
    6eb0:	55                   	push   %ebp
    6eb1:	89 e5                	mov    %esp,%ebp
    6eb3:	57                   	push   %edi
    6eb4:	56                   	push   %esi
    6eb5:	53                   	push   %ebx
    6eb6:	83 ec 4c             	sub    $0x4c,%esp
    6eb9:	e8 fc ff ff ff       	call   6eba <rlc_pkt_receive_from_mac+0xa>
    6ebe:	89 c3                	mov    %eax,%ebx
	struct  UM_RX_Instance *umRxIns;
//   struct  TM_RX_Instance *tmRxIns;
	void *insptru, *insptrd;
	
	FIN(rlc_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6ec0:	e8 fc ff ff ff       	call   6ec1 <rlc_pkt_receive_from_mac+0x11>
    6ec5:	89 c7                	mov    %eax,%edi
	SV(countreceive_from_mac)++;
    6ec7:	8b 80 88 5a 00 00    	mov    0x5a88(%eax),%eax
    6ecd:	83 c0 01             	add    $0x1,%eax
    6ed0:	89 87 88 5a 00 00    	mov    %eax,0x5a88(%edi)
	printk("[rlc_pkt_receive_from_mac]UE RLC_MAC SEND TO UPPER=%d\n",SV(countreceive_from_mac));
    6ed6:	89 44 24 04          	mov    %eax,0x4(%esp)
    6eda:	c7 04 24 48 20 00 00 	movl   $0x2048,(%esp)
    6ee1:	e8 fc ff ff ff       	call   6ee2 <rlc_pkt_receive_from_mac+0x32>

	//skb = fsm_pkt_get();

	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from lower\n");
	//fsm_octets_print(skb->data,50);
	micimsg = (MRLC_fromMac_IciMsg*)skb->head;
    6ee6:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
    6eec:	8b 46 02             	mov    0x2(%esi),%eax
    6eef:	89 44 24 08          	mov    %eax,0x8(%esp)
    6ef3:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6ef7:	c7 04 24 80 20 00 00 	movl   $0x2080,(%esp)
    6efe:	89 44 24 04          	mov    %eax,0x4(%esp)
    6f02:	e8 fc ff ff ff       	call   6f03 <rlc_pkt_receive_from_mac+0x53>
	fsm_octets_print(skb->data,64);
    6f07:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    6f0d:	ba 40 00 00 00       	mov    $0x40,%edx
    6f12:	e8 fc ff ff ff       	call   6f13 <rlc_pkt_receive_from_mac+0x63>
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
    6f17:	8b 46 02             	mov    0x2(%esi),%eax
    6f1a:	85 c0                	test   %eax,%eax
    6f1c:	75 08                	jne    6f26 <rlc_pkt_receive_from_mac+0x76>
    6f1e:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6f22:	84 c0                	test   %al,%al
    6f24:	75 5a                	jne    6f80 <rlc_pkt_receive_from_mac+0xd0>
		}
		
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    6f26:	89 d8                	mov    %ebx,%eax
    6f28:	e8 fc ff ff ff       	call   6f29 <rlc_pkt_receive_from_mac+0x79>
    6f2d:	83 f8 01             	cmp    $0x1,%eax
    6f30:	0f 86 92 03 00 00    	jbe    72c8 <rlc_pkt_receive_from_mac+0x418>
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6f36:	8b 46 02             	mov    0x2(%esi),%eax
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6f39:	8d 55 f2             	lea    -0xe(%ebp),%edx
    6f3c:	b9 02 00 00 00       	mov    $0x2,%ecx
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
    6f41:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6f45:	88 45 f2             	mov    %al,-0xe(%ebp)
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6f48:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    6f4e:	e8 fc ff ff ff       	call   6f4f <rlc_pkt_receive_from_mac+0x9f>
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
    6f53:	c7 04 24 94 29 00 00 	movl   $0x2994,(%esp)
    6f5a:	e8 fc ff ff ff       	call   6f5b <rlc_pkt_receive_from_mac+0xab>
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6f5f:	ba 05 00 00 00       	mov    $0x5,%edx
    6f64:	89 d8                	mov    %ebx,%eax
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
    6f66:	83 87 90 5a 00 00 01 	addl   $0x1,0x5a90(%edi)
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6f6d:	e8 fc ff ff ff       	call   6f6e <rlc_pkt_receive_from_mac+0xbe>
	}
	//printk("[RLC_MAC]SV(countDropPacket):%d\n", SV(countDropPacket));
	FOUT;
}
    6f72:	83 c4 4c             	add    $0x4c,%esp
    6f75:	5b                   	pop    %ebx
    6f76:	5e                   	pop    %esi
    6f77:	5f                   	pop    %edi
    6f78:	5d                   	pop    %ebp
    6f79:	c3                   	ret    
    6f7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
	fsm_octets_print(skb->data,64);
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
    6f80:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    6f86:	0f b6 c0             	movzbl %al,%eax
    6f89:	89 14 24             	mov    %edx,(%esp)
    6f8c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    6f8f:	8d 55 e8             	lea    -0x18(%ebp),%edx
    6f92:	e8 fc ff ff ff       	call   6f93 <rlc_pkt_receive_from_mac+0xe3>
		switch(SV(ins_mode))
    6f97:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    6f9d:	83 f8 02             	cmp    $0x2,%eax
    6fa0:	74 3e                	je     6fe0 <rlc_pkt_receive_from_mac+0x130>
    6fa2:	83 f8 03             	cmp    $0x3,%eax
    6fa5:	0f 84 35 03 00 00    	je     72e0 <rlc_pkt_receive_from_mac+0x430>
			//printk("[RLC_MAC UM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		default:
			printk("[RLC][rlc_pkt_receive_from_mac] cannot distinfuish this  %d", SV(ins_mode));
    6fab:	89 44 24 04          	mov    %eax,0x4(%esp)
    6faf:	c7 04 24 20 29 00 00 	movl   $0x2920,(%esp)
    6fb6:	e8 fc ff ff ff       	call   6fb7 <rlc_pkt_receive_from_mac+0x107>
			break;
		}
		//fsm_printf("[RLC][rlc_pkt_receive_from_mac] cannot find the instance or the instance is suspended(rbid is %d)\n", micimsg->lcid);
		printk("[RLC][rlc_pkt_receive_from_mac] A packet has dropped\n");
    6fbb:	c7 04 24 5c 29 00 00 	movl   $0x295c,(%esp)
    6fc2:	e8 fc ff ff ff       	call   6fc3 <rlc_pkt_receive_from_mac+0x113>
		SV(countDropPacket)++;
    6fc7:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		if(skb != NULL)
    6fce:	85 db                	test   %ebx,%ebx
    6fd0:	74 a0                	je     6f72 <rlc_pkt_receive_from_mac+0xc2>
		{
			fsm_pkt_destroy(skb);
    6fd2:	89 d8                	mov    %ebx,%eax
    6fd4:	e8 fc ff ff ff       	call   6fd5 <rlc_pkt_receive_from_mac+0x125>
    6fd9:	eb 97                	jmp    6f72 <rlc_pkt_receive_from_mac+0xc2>
    6fdb:	90                   	nop
    6fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		case UM_MODE:
			if(insptrd == NULL)
    6fe0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    6fe3:	85 c9                	test   %ecx,%ecx
    6fe5:	0f 84 ab 0d 00 00    	je     7d96 <rlc_pkt_receive_from_mac+0xee6>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
    6feb:	0f b6 81 c2 10 00 00 	movzbl 0x10c2(%ecx),%eax
    6ff2:	3c 0b                	cmp    $0xb,%al
    6ff4:	0f 84 83 0d 00 00    	je     7d7d <rlc_pkt_receive_from_mac+0xecd>
    6ffa:	3c 09                	cmp    $0x9,%al
    6ffc:	0f 84 7b 0d 00 00    	je     7d7d <rlc_pkt_receive_from_mac+0xecd>
	u16 windows;
	//MRLC_fromMac_IciMsg *mac_ici;
	//URLC_IciMsg *icimsg;
	
	FIN(rlc_UM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7002:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7005:	e8 fc ff ff ff       	call   7006 <rlc_pkt_receive_from_mac+0x156>
    700a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	fsm_printf("\n[RLC][rlc_UM_pkt_receive_from_mac] entering rlc_UM_pkt_receive_from_mac\n");
    700d:	c7 04 24 50 25 00 00 	movl   $0x2550,(%esp)
    7014:	e8 fc ff ff ff       	call   7015 <rlc_pkt_receive_from_mac+0x165>
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
    7019:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    701c:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    7020:	c7 04 24 9c 25 00 00 	movl   $0x259c,(%esp)
    7027:	89 44 24 04          	mov    %eax,0x4(%esp)
    702b:	e8 fc ff ff ff       	call   702c <rlc_pkt_receive_from_mac+0x17c>
	switch(umRxIns->snFiledLength)
    7030:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7033:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    7037:	66 83 f8 05          	cmp    $0x5,%ax
    703b:	0f 84 3f 06 00 00    	je     7680 <rlc_pkt_receive_from_mac+0x7d0>
    7041:	66 83 f8 0a          	cmp    $0xa,%ax
    7045:	0f 84 7d 06 00 00    	je     76c8 <rlc_pkt_receive_from_mac+0x818>
			FOUT;
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size10 + 1));
		break;
	default:
		printk("[RLC][rlc_UM_pkt_receive_from_mac] cannot distinguish the %d",umRxIns->snFiledLength);
    704b:	0f b7 c0             	movzwl %ax,%eax
    704e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7051:	89 44 24 04          	mov    %eax,0x4(%esp)
    7055:	c7 04 24 34 26 00 00 	movl   $0x2634,(%esp)
    705c:	e8 fc ff ff ff       	call   705d <rlc_pkt_receive_from_mac+0x1ad>
    7061:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7064:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    706a:	0f bf 75 e4          	movswl -0x1c(%ebp),%esi
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    706e:	b8 18 00 00 00       	mov    $0x18,%eax
    7073:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7076:	e8 fc ff ff ff       	call   7077 <rlc_pkt_receive_from_mac+0x1c7>
	umbuf->pkt = pkt;
    707b:	89 18                	mov    %ebx,(%eax)
	umbuf->SN = SN;
    707d:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    7081:	8d 50 10             	lea    0x10(%eax),%edx
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    7084:	89 c7                	mov    %eax,%edi
	umbuf->pkt = pkt;
	umbuf->SN = SN;
    7086:	66 89 58 0c          	mov    %bx,0xc(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    708a:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    708d:	8b 41 34             	mov    0x34(%ecx),%eax
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    7090:	8d 59 30             	lea    0x30(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7093:	89 51 34             	mov    %edx,0x34(%ecx)
    7096:	89 5f 10             	mov    %ebx,0x10(%edi)
	new->next = next;
	new->prev = prev;
    7099:	89 47 14             	mov    %eax,0x14(%edi)
	prev->next = new;
    709c:	89 10                	mov    %edx,(%eax)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    709e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    70a1:	89 74 24 04          	mov    %esi,0x4(%esp)
    70a5:	c7 04 24 74 26 00 00 	movl   $0x2674,(%esp)
    70ac:	e8 fc ff ff ff       	call   70ad <rlc_pkt_receive_from_mac+0x1fd>
	if(umRxIns->snFiledLength == 5)
    70b1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    70b4:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    70b8:	66 83 f8 05          	cmp    $0x5,%ax
    70bc:	0f 84 1e 07 00 00    	je     77e0 <rlc_pkt_receive_from_mac+0x930>
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
	}
	if(umRxIns->snFiledLength == 10)
    70c2:	66 83 f8 0a          	cmp    $0xa,%ax
    70c6:	75 07                	jne    70cf <rlc_pkt_receive_from_mac+0x21f>
	{
		umRxIns->umRecvWindow10[SN] = umbuf;
    70c8:	89 bc b1 b8 00 00 00 	mov    %edi,0xb8(%ecx,%esi,4)
	}
	umRxIns->vr_uh %= windows;
    70cf:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    70d6:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    70da:	89 c2                	mov    %eax,%edx
    70dc:	c1 fa 1f             	sar    $0x1f,%edx
    70df:	f7 fb                	idiv   %ebx
    70e1:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_uh is %d\n", umRxIns->vr_uh);
    70e8:	0f bf d2             	movswl %dx,%edx
    70eb:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    70ee:	89 54 24 04          	mov    %edx,0x4(%esp)
    70f2:	c7 04 24 c0 26 00 00 	movl   $0x26c0,(%esp)
    70f9:	e8 fc ff ff ff       	call   70fa <rlc_pkt_receive_from_mac+0x24a>
	//
	if((SN>=umRxIns->vr_uh)||(SN <= umRxIns->vr_uh - windows/2))
    70fe:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7101:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
    7105:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    710c:	66 d1 ef             	shr    %di
    710f:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
    7113:	0f b7 ff             	movzwl %di,%edi
    7116:	7d 07                	jge    711f <rlc_pkt_receive_from_mac+0x26f>
    7118:	98                   	cwtl   
    7119:	29 f8                	sub    %edi,%eax
    711b:	39 c6                	cmp    %eax,%esi
    711d:	7f 66                	jg     7185 <rlc_pkt_receive_from_mac+0x2d5>
	{
		//	fsm_printf("umbuf->SN  >=  umRxIns->vr_uh is %d\n",umRxIns->vr_uh);
		umRxIns->vr_uh = (SN + 1)%windows;
    711f:	8d 46 01             	lea    0x1(%esi),%eax
    7122:	89 c2                	mov    %eax,%edx
    7124:	c1 fa 1f             	sar    $0x1f,%edx
    7127:	f7 fb                	idiv   %ebx
    7129:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] outside the windows: umRxIns->vr_uh is updated to %d\n", umRxIns->vr_uh);
    7130:	89 54 24 04          	mov    %edx,0x4(%esp)
    7134:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7137:	c7 04 24 fc 26 00 00 	movl   $0x26fc,(%esp)
    713e:	e8 fc ff ff ff       	call   713f <rlc_pkt_receive_from_mac+0x28f>
		//temp = umRxIns->vr_ur;
		if(umRxIns->vr_ur < umRxIns->vr_uh - windows/2 )
    7143:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7146:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    714d:	0f bf 91 bc 10 00 00 	movswl 0x10bc(%ecx),%edx
    7154:	89 c6                	mov    %eax,%esi
    7156:	29 fe                	sub    %edi,%esi
    7158:	39 f2                	cmp    %esi,%edx
    715a:	7d 13                	jge    716f <rlc_pkt_receive_from_mac+0x2bf>
		{
			umRxIns->vr_ur = (umRxIns->vr_uh + windows/2)%windows;
    715c:	01 f8                	add    %edi,%eax
    715e:	89 c2                	mov    %eax,%edx
    7160:	c1 fa 1f             	sar    $0x1f,%edx
    7163:	f7 fb                	idiv   %ebx
    7165:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
    716c:	0f bf d2             	movswl %dx,%edx
			}
			umRxIns->vr_ur =  temp;*/
			//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
		}		
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    716f:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7172:	89 54 24 04          	mov    %edx,0x4(%esp)
    7176:	c7 04 24 58 27 00 00 	movl   $0x2758,(%esp)
    717d:	e8 fc ff ff ff       	call   717e <rlc_pkt_receive_from_mac+0x2ce>
    7182:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		//	fsm_printf("umRxIns->vr_ur is %d\n",umRxIns->vr_ur);
		//	   fsm_pkt_send(rlc_UM_reassemble_deliver( umRxIns),STRM_TO_PDCP);
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
    7185:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    7189:	66 83 f8 05          	cmp    $0x5,%ax
    718d:	0f 84 f6 06 00 00    	je     7889 <rlc_pkt_receive_from_mac+0x9d9>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
		}
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
    7193:	66 83 f8 0a          	cmp    $0xa,%ax
    7197:	0f 84 92 07 00 00    	je     792f <rlc_pkt_receive_from_mac+0xa7f>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    719d:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    71a4:	8b 71 08             	mov    0x8(%ecx),%esi
    71a7:	85 f6                	test   %esi,%esi
    71a9:	0f 84 a4 00 00 00    	je     7253 <rlc_pkt_receive_from_mac+0x3a3>
    71af:	0f b7 81 be 10 00 00 	movzwl 0x10be(%ecx),%eax
    71b6:	66 39 c7             	cmp    %ax,%di
    71b9:	7d 6d                	jge    7228 <rlc_pkt_receive_from_mac+0x378>
    71bb:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    71bf:	0f bf d0             	movswl %ax,%edx
    71c2:	0f bf ff             	movswl %di,%edi
    71c5:	66 d1 ee             	shr    %si
    71c8:	0f b7 f6             	movzwl %si,%esi
    71cb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    71ce:	89 d6                	mov    %edx,%esi
    71d0:	2b 75 e4             	sub    -0x1c(%ebp),%esi
    71d3:	39 f7                	cmp    %esi,%edi
    71d5:	7e 51                	jle    7228 <rlc_pkt_receive_from_mac+0x378>
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    71d7:	66 83 79 06 05       	cmpw   $0x5,0x6(%ecx)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    71dc:	0f bf b1 c0 10 00 00 	movswl 0x10c0(%ecx),%esi
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    71e3:	0f 84 f4 08 00 00    	je     7add <rlc_pkt_receive_from_mac+0xc2d>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    71e9:	29 f2                	sub    %esi,%edx
    71eb:	81 c2 00 06 00 00    	add    $0x600,%edx
    71f1:	89 d6                	mov    %edx,%esi
    71f3:	c1 fe 1f             	sar    $0x1f,%esi
    71f6:	c1 ee 16             	shr    $0x16,%esi
    71f9:	01 f2                	add    %esi,%edx
    71fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    7201:	29 f2                	sub    %esi,%edx
    7203:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    7209:	0f 9e c2             	setle  %dl
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    720c:	84 d2                	test   %dl,%dl
    720e:	0f 85 5e fd ff ff    	jne    6f72 <rlc_pkt_receive_from_mac+0xc2>
								((!isInsideUmRecvWin(umRxIns,umRxIns->vr_ux ))&&(umRxIns->vr_ux != umRxIns->vr_uh))))
    7214:	66 3b 81 c0 10 00 00 	cmp    0x10c0(%ecx),%ax
    721b:	0f 84 51 fd ff ff    	je     6f72 <rlc_pkt_receive_from_mac+0xc2>
    7221:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is canceling\n\n");
    7228:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    722b:	c7 04 24 68 28 00 00 	movl   $0x2868,(%esp)
    7232:	e8 fc ff ff ff       	call   7233 <rlc_pkt_receive_from_mac+0x383>
		fsm_schedule_cancel(umRxIns->reorderTimer);
    7237:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    723a:	8b 41 08             	mov    0x8(%ecx),%eax
    723d:	e8 fc ff ff ff       	call   723e <rlc_pkt_receive_from_mac+0x38e>
		umRxIns->reorderTimer = 0;
    7242:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7245:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    724c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
	}
	//h>r(!=)
	//if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh != umRxIns->vr_ur))//??
	if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh>umRxIns->vr_ur||umRxIns->vr_uh<umRxIns->vr_ur-windows/2))
    7253:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    725a:	66 39 c7             	cmp    %ax,%di
    725d:	7c 18                	jl     7277 <rlc_pkt_receive_from_mac+0x3c7>
    725f:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    7263:	0f bf ff             	movswl %di,%edi
    7266:	98                   	cwtl   
    7267:	66 d1 ea             	shr    %dx
    726a:	0f b7 d2             	movzwl %dx,%edx
    726d:	29 d7                	sub    %edx,%edi
    726f:	39 f8                	cmp    %edi,%eax
    7271:	0f 8d fb fc ff ff    	jge    6f72 <rlc_pkt_receive_from_mac+0xc2>
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is scheduling\n");
    7277:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    727a:	c7 04 24 a0 28 00 00 	movl   $0x28a0,(%esp)
    7281:	e8 fc ff ff ff       	call   7282 <rlc_pkt_receive_from_mac+0x3d2>
		umRxIns->reorderTimer = fsm_schedule_self(umRxIns->reorderTimerValue, umRxIns->reorderTimerCode);
    7286:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7289:	8b 51 0c             	mov    0xc(%ecx),%edx
    728c:	8b 41 10             	mov    0x10(%ecx),%eax
    728f:	e8 fc ff ff ff       	call   7290 <rlc_pkt_receive_from_mac+0x3e0>
    7294:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7297:	89 41 08             	mov    %eax,0x8(%ecx)
		umRxIns->vr_ux = umRxIns->vr_uh;
		umRxIns->vr_ux %= windows;
    729a:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    72a1:	89 c2                	mov    %eax,%edx
    72a3:	c1 fa 1f             	sar    $0x1f,%edx
    72a6:	f7 fb                	idiv   %ebx
    72a8:	66 89 91 be 10 00 00 	mov    %dx,0x10be(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ux is updated to %d\n\n", umRxIns->vr_ux);
    72af:	0f bf d2             	movswl %dx,%edx
    72b2:	89 54 24 04          	mov    %edx,0x4(%esp)
    72b6:	c7 04 24 d8 28 00 00 	movl   $0x28d8,(%esp)
    72bd:	e8 fc ff ff ff       	call   72be <rlc_pkt_receive_from_mac+0x40e>
    72c2:	e9 ab fc ff ff       	jmp    6f72 <rlc_pkt_receive_from_mac+0xc2>
    72c7:	90                   	nop
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    72c8:	89 d8                	mov    %ebx,%eax
    72ca:	ba 02 00 00 00       	mov    $0x2,%edx
    72cf:	e8 fc ff ff ff       	call   72d0 <rlc_pkt_receive_from_mac+0x420>
    72d4:	89 c3                	mov    %eax,%ebx
    72d6:	e9 5b fc ff ff       	jmp    6f36 <rlc_pkt_receive_from_mac+0x86>
    72db:	90                   	nop
    72dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    72e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72e3:	85 c0                	test   %eax,%eax
    72e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    72e8:	0f 84 76 0a 00 00    	je     7d64 <rlc_pkt_receive_from_mac+0xeb4>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    72ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    72f1:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
    72f5:	66 83 f8 0b          	cmp    $0xb,%ax
    72f9:	0f 84 4c 0a 00 00    	je     7d4b <rlc_pkt_receive_from_mac+0xe9b>
    72ff:	66 83 f8 09          	cmp    $0x9,%ax
    7303:	0f 84 42 0a 00 00    	je     7d4b <rlc_pkt_receive_from_mac+0xe9b>
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7309:	e8 fc ff ff ff       	call   730a <rlc_pkt_receive_from_mac+0x45a>
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
    730e:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
    7314:	66 c1 06 08          	rolw   $0x8,(%esi)
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7318:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
	*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
	fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the header is:\n");
    731b:	c7 04 24 6c 21 00 00 	movl   $0x216c,(%esp)
    7322:	e8 fc ff ff ff       	call   7323 <rlc_pkt_receive_from_mac+0x473>
	fsm_octets_print(fixhead,2);
    7327:	ba 02 00 00 00       	mov    $0x2,%edx
    732c:	89 f0                	mov    %esi,%eax
    732e:	e8 fc ff ff ff       	call   732f <rlc_pkt_receive_from_mac+0x47f>
	//fsm_printf("\n[RLC][rlc_AM_pkt_receive_from_mac] entering rlc_AM_pkt_receive_from_mac\n");
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
    7333:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7337:	84 c0                	test   %al,%al
    7339:	0f 89 b1 04 00 00    	jns    77f0 <rlc_pkt_receive_from_mac+0x940>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    733f:	a8 40                	test   $0x40,%al
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7341:	0f b6 16             	movzbl (%esi),%edx
    7344:	0f b6 46 01          	movzbl 0x1(%esi),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    7348:	0f 84 3a 02 00 00    	je     7588 <rlc_pkt_receive_from_mac+0x6d8>
	}

//AMD PDU 
	else
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
    734e:	83 e0 03             	and    $0x3,%eax
    7351:	c1 e0 08             	shl    $0x8,%eax
    7354:	09 d0                	or     %edx,%eax
    7356:	89 44 24 04          	mov    %eax,0x4(%esp)
    735a:	c7 04 24 28 22 00 00 	movl   $0x2228,(%esp)
    7361:	e8 fc ff ff ff       	call   7362 <rlc_pkt_receive_from_mac+0x4b2>
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
    7366:	8b 8b ac 00 00 00    	mov    0xac(%ebx),%ecx
    736c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    736f:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7373:	0f b6 16             	movzbl (%esi),%edx
    7376:	83 e0 03             	and    $0x3,%eax
    7379:	c1 e0 08             	shl    $0x8,%eax
    737c:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    737e:	0f bf d0             	movswl %ax,%edx
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    7381:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    7385:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7388:	89 55 e0             	mov    %edx,-0x20(%ebp)
    738b:	e8 fc ff ff ff       	call   738c <rlc_pkt_receive_from_mac+0x4dc>
    7390:	84 c0                	test   %al,%al
    7392:	0f 84 4b 09 00 00    	je     7ce3 <rlc_pkt_receive_from_mac+0xe33>
    7398:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    739b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    739e:	81 c1 98 04 00 00    	add    $0x498,%ecx
    73a4:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
    73a8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    73ab:	85 c0                	test   %eax,%eax
    73ad:	0f 84 49 07 00 00    	je     7afc <rlc_pkt_receive_from_mac+0xc4c>
    73b3:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    73b7:	0f 84 26 09 00 00    	je     7ce3 <rlc_pkt_receive_from_mac+0xe33>
		//PDU
		else
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not received this PDU segment before(pos is %d)\n", extseghead->SO);
			//
			if(extseghead->LSF == 1)
    73bd:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    73c0:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    73c4:	79 3a                	jns    7400 <rlc_pkt_receive_from_mac+0x550>
			{
				amIns->amRecvWindow[SN]->pktstatus = LAST_SEGMENT;
    73c6:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
    73cd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    73d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    73d3:	8b 44 82 0c          	mov    0xc(%edx,%eax,4),%eax
    73d7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    73da:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    73de:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    73e2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    73e5:	83 e0 7f             	and    $0x7f,%eax
    73e8:	c1 e0 08             	shl    $0x8,%eax
    73eb:	09 d0                	or     %edx,%eax
    73ed:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    73f0:	03 43 50             	add    0x50(%ebx),%eax
    73f3:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    73f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    73fc:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
    7400:	89 da                	mov    %ebx,%edx
    7402:	e8 fc ff ff ff       	call   7403 <rlc_pkt_receive_from_mac+0x553>
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    7407:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    740a:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    740d:	8b 44 9a 0c          	mov    0xc(%edx,%ebx,4),%eax
    7411:	8b 10                	mov    (%eax),%edx
    7413:	8b 4a 50             	mov    0x50(%edx),%ecx
    7416:	39 88 98 00 00 00    	cmp    %ecx,0x98(%eax)
    741c:	0f 84 d9 05 00 00    	je     79fb <rlc_pkt_receive_from_mac+0xb4b>
	}

//PDUSN

//vr_h
	if(SN >= amIns->vr_h || SN <= amIns->vr_h-AM_WINDOW_SIZE)
    7422:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7425:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    742c:	66 3b 45 da          	cmp    -0x26(%ebp),%ax
    7430:	7e 0b                	jle    743d <rlc_pkt_receive_from_mac+0x58d>
    7432:	98                   	cwtl   
    7433:	2d 00 02 00 00       	sub    $0x200,%eax
    7438:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    743b:	7f 31                	jg     746e <rlc_pkt_receive_from_mac+0x5be>
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN > amIns->vr_h\n");
    743d:	c7 04 24 e8 22 00 00 	movl   $0x22e8,(%esp)
    7444:	e8 fc ff ff ff       	call   7445 <rlc_pkt_receive_from_mac+0x595>
		amIns->vr_h = (SN + 1)%(AM_WINDOW_SIZE*2);
    7449:	8b 45 e0             	mov    -0x20(%ebp),%eax
    744c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    744f:	83 c0 01             	add    $0x1,%eax
    7452:	25 ff 03 00 00       	and    $0x3ff,%eax
    7457:	66 89 82 ee 22 00 00 	mov    %ax,0x22ee(%edx)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_h is updated to %d\n",amIns->vr_h);
    745e:	89 44 24 04          	mov    %eax,0x4(%esp)
    7462:	c7 04 24 20 23 00 00 	movl   $0x2320,(%esp)
    7469:	e8 fc ff ff ff       	call   746a <rlc_pkt_receive_from_mac+0x5ba>
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    746e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7471:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
    7478:	8b 84 90 6c 12 00 00 	mov    0x126c(%eax,%edx,4),%eax
    747f:	85 c0                	test   %eax,%eax
    7481:	74 0a                	je     748d <rlc_pkt_receive_from_mac+0x5dd>
    7483:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7487:	0f 84 83 03 00 00    	je     7810 <rlc_pkt_receive_from_mac+0x960>
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    748d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7490:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7493:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    749a:	0f bf c2             	movswl %dx,%eax
    749d:	8b 84 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%eax
    74a4:	85 c0                	test   %eax,%eax
    74a6:	74 0a                	je     74b2 <rlc_pkt_receive_from_mac+0x602>
    74a8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    74ac:	0f 84 6d 05 00 00    	je     7a1f <rlc_pkt_receive_from_mac+0xb6f>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
	}
	
//x>r,xmr
	if(amIns->reorderTimer &&((amIns->vr_x == amIns->vr_r)||(!isInsideAmRecvWin(amIns, SN)&&(amIns->vr_x != amIns->vr_mr))))
    74b2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    74b5:	8b 41 14             	mov    0x14(%ecx),%eax
    74b8:	85 c0                	test   %eax,%eax
    74ba:	74 4b                	je     7507 <rlc_pkt_receive_from_mac+0x657>
    74bc:	66 3b 91 f0 22 00 00 	cmp    0x22f0(%ecx),%dx
    74c3:	74 2c                	je     74f1 <rlc_pkt_receive_from_mac+0x641>
    74c5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    74c8:	89 c8                	mov    %ecx,%eax
    74ca:	e8 fc ff ff ff       	call   74cb <rlc_pkt_receive_from_mac+0x61b>
    74cf:	84 c0                	test   %al,%al
    74d1:	0f 85 a1 02 00 00    	jne    7778 <rlc_pkt_receive_from_mac+0x8c8>
    74d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74da:	0f b7 90 ec 22 00 00 	movzwl 0x22ec(%eax),%edx
    74e1:	66 39 90 f0 22 00 00 	cmp    %dx,0x22f0(%eax)
    74e8:	0f 84 8a 02 00 00    	je     7778 <rlc_pkt_receive_from_mac+0x8c8>
    74ee:	8b 40 14             	mov    0x14(%eax),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
    74f1:	e8 fc ff ff ff       	call   74f2 <rlc_pkt_receive_from_mac+0x642>
		amIns->reorderTimer = 0;
    74f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74f9:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    7500:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7507:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    750a:	0f b7 81 ee 22 00 00 	movzwl 0x22ee(%ecx),%eax
    7511:	66 39 c2             	cmp    %ax,%dx
    7514:	7c 0e                	jl     7524 <rlc_pkt_receive_from_mac+0x674>
    7516:	0f bf d2             	movswl %dx,%edx
    7519:	98                   	cwtl   
    751a:	81 ea 00 02 00 00    	sub    $0x200,%edx
    7520:	39 d0                	cmp    %edx,%eax
    7522:	7d 24                	jge    7548 <rlc_pkt_receive_from_mac+0x698>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is scheduling\n");
		amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue ,amIns->reorderTimerCode);
    7524:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7527:	8b 50 18             	mov    0x18(%eax),%edx
    752a:	8b 40 1c             	mov    0x1c(%eax),%eax
    752d:	e8 fc ff ff ff       	call   752e <rlc_pkt_receive_from_mac+0x67e>
    7532:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7535:	89 43 14             	mov    %eax,0x14(%ebx)
		amIns->vr_x = amIns->vr_h;
    7538:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    753f:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    7546:	66 90                	xchg   %ax,%ax
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_x is updated to %d\n",amIns->vr_x);
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
    7548:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    754c:	c7 04 24 5e 04 00 00 	movl   $0x45e,(%esp)
    7553:	c0 e8 05             	shr    $0x5,%al
    7556:	83 e0 01             	and    $0x1,%eax
    7559:	89 44 24 04          	mov    %eax,0x4(%esp)
    755d:	e8 fc ff ff ff       	call   755e <rlc_pkt_receive_from_mac+0x6ae>
	if(fixhead->P == 1)
    7562:	f6 46 01 20          	testb  $0x20,0x1(%esi)
    7566:	0f 85 2c 02 00 00    	jne    7798 <rlc_pkt_receive_from_mac+0x8e8>
			//amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
			//fsm_printf("After am receive_from_mac pollRetxRimer is running\n");
			//addpkt_recvData(amIns);				
			rlc_AM_pkt_receive_from_mac(amIns,skb);
			//    fsm_printf("time for rlc_AM_pkt_receive_from_mac(amIns,skb)\n");
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
    756c:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    7572:	c7 04 24 9c 24 00 00 	movl   $0x249c,(%esp)
    7579:	89 44 24 04          	mov    %eax,0x4(%esp)
    757d:	e8 fc ff ff ff       	call   757e <rlc_pkt_receive_from_mac+0x6ce>
			FOUT;
    7582:	e9 eb f9 ff ff       	jmp    6f72 <rlc_pkt_receive_from_mac+0xc2>
    7587:	90                   	nop
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7588:	83 e0 03             	and    $0x3,%eax
    758b:	c1 e0 08             	shl    $0x8,%eax
    758e:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7590:	0f bf d0             	movswl %ax,%edx
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7593:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7597:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    759a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    759d:	e8 fc ff ff ff       	call   759e <rlc_pkt_receive_from_mac+0x6ee>
    75a2:	84 c0                	test   %al,%al
    75a4:	0f 84 45 07 00 00    	je     7cef <rlc_pkt_receive_from_mac+0xe3f>
				pkt= NULL;
			}			
			FOUT;
		}
//,
		if(amIns->amRecvWindow[SN] != NULL)
    75aa:	8b 55 e0             	mov    -0x20(%ebp),%edx
    75ad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    75b0:	81 c2 98 04 00 00    	add    $0x498,%edx
    75b6:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    75ba:	89 55 dc             	mov    %edx,-0x24(%ebp)
    75bd:	85 c0                	test   %eax,%eax
    75bf:	74 42                	je     7603 <rlc_pkt_receive_from_mac+0x753>
		{
			if(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)
    75c1:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    75c5:	0f 84 24 07 00 00    	je     7cef <rlc_pkt_receive_from_mac+0xe3f>
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received completly\n");
				FOUT;
			}
			else
			{
				if(amIns->amRecvWindow[SN]->pkt != NULL)
    75cb:	8b 10                	mov    (%eax),%edx
    75cd:	85 d2                	test   %edx,%edx
    75cf:	74 1f                	je     75f0 <rlc_pkt_receive_from_mac+0x740>
				{
					fsm_pkt_destroy(amIns->amRecvWindow[SN]->pkt);
    75d1:	89 d0                	mov    %edx,%eax
    75d3:	e8 fc ff ff ff       	call   75d4 <rlc_pkt_receive_from_mac+0x724>
					amIns->amRecvWindow[SN]->pkt = NULL;
    75d8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    75db:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    75de:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    75e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				}
				if(amIns->amRecvWindow[SN] != NULL)
    75e8:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    75ec:	85 c0                	test   %eax,%eax
    75ee:	74 13                	je     7603 <rlc_pkt_receive_from_mac+0x753>
				{
					fsm_mem_free(amIns->amRecvWindow[SN]);
    75f0:	e8 fc ff ff ff       	call   75f1 <rlc_pkt_receive_from_mac+0x741>
					amIns->amRecvWindow[SN] = NULL;
    75f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    75f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    75fb:	c7 44 82 0c 00 00 00 	movl   $0x0,0xc(%edx,%eax,4)
    7602:	00 
					//printk("RLC FREE: %d\n", freenum);
				}				
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received but not completly\n");
			}
		}
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    7603:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7608:	e8 fc ff ff ff       	call   7609 <rlc_pkt_receive_from_mac+0x759>
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
    760d:	89 18                	mov    %ebx,(%eax)
		ambuf->pktstatus = FULL_SDU;
		ambuf->pos = 0;
		ambuf->segnum = 0;
		ambuf->SN = SN;
    760f:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7613:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
		ambuf->pktstatus = FULL_SDU;
    7619:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		ambuf->pos = 0;
    7620:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		ambuf->segnum = 0;
    7627:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    762e:	00 00 00 
		ambuf->SN = SN;
    7631:	66 89 98 94 00 00 00 	mov    %bx,0x94(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    7638:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    763b:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7641:	89 8b 60 02 00 00    	mov    %ecx,0x260(%ebx)
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7647:	81 c3 5c 02 00 00    	add    $0x25c,%ebx
    764d:	89 98 9c 00 00 00    	mov    %ebx,0x9c(%eax)
		amIns->amRecvWindow[SN] = ambuf;
    7653:	8b 5d dc             	mov    -0x24(%ebp),%ebx
	new->next = next;
	new->prev = prev;
    7656:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
    765c:	89 0a                	mov    %ecx,(%edx)
    765e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7661:	89 44 9a 0c          	mov    %eax,0xc(%edx,%ebx,4)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    7665:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7668:	c7 04 24 dc 21 00 00 	movl   $0x21dc,(%esp)
    766f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7673:	e8 fc ff ff ff       	call   7674 <rlc_pkt_receive_from_mac+0x7c4>
    7678:	e9 a5 fd ff ff       	jmp    7422 <rlc_pkt_receive_from_mac+0x572>
    767d:	8d 76 00             	lea    0x0(%esi),%esi
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
	switch(umRxIns->snFiledLength)
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
    7680:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    7686:	0f b6 00             	movzbl (%eax),%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
    7689:	89 c6                	mov    %eax,%esi
    768b:	83 e6 1f             	and    $0x1f,%esi
    768e:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
    7692:	0f bf f6             	movswl %si,%esi
    7695:	8b 44 b1 38          	mov    0x38(%ecx,%esi,4),%eax
    7699:	85 c0                	test   %eax,%eax
    769b:	0f 85 78 06 00 00    	jne    7d19 <rlc_pkt_receive_from_mac+0xe69>
    76a1:	89 c8                	mov    %ecx,%eax
    76a3:	89 f2                	mov    %esi,%edx
    76a5:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    76a8:	e8 fc ff ff ff       	call   76a9 <rlc_pkt_receive_from_mac+0x7f9>
    76ad:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    76b0:	84 c0                	test   %al,%al
    76b2:	0f 85 61 06 00 00    	jne    7d19 <rlc_pkt_receive_from_mac+0xe69>
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
    76b8:	66 c7 45 e0 20 00    	movw   $0x20,-0x20(%ebp)
    76be:	e9 ab f9 ff ff       	jmp    706e <rlc_pkt_receive_from_mac+0x1be>
    76c3:	90                   	nop
    76c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
    76c8:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    76ce:	ba 02 00 00 00       	mov    $0x2,%edx
    76d3:	66 c1 00 08          	rolw   $0x8,(%eax)
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
    76d7:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    76dd:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    76e0:	89 f0                	mov    %esi,%eax
    76e2:	e8 fc ff ff ff       	call   76e3 <rlc_pkt_receive_from_mac+0x833>
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    76e7:	0f b6 46 01          	movzbl 0x1(%esi),%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    76eb:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    76ee:	0f b6 16             	movzbl (%esi),%edx
    76f1:	83 e0 03             	and    $0x3,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    76f4:	0f bf b9 bc 10 00 00 	movswl 0x10bc(%ecx),%edi
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    76fb:	c1 e0 08             	shl    $0x8,%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    76fe:	09 d0                	or     %edx,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7700:	0f bf f0             	movswl %ax,%esi
    7703:	89 f2                	mov    %esi,%edx
    7705:	29 fa                	sub    %edi,%edx
    7707:	81 c2 00 04 00 00    	add    $0x400,%edx
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    770d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7711:	89 d0                	mov    %edx,%eax
    7713:	c1 f8 1f             	sar    $0x1f,%eax
    7716:	c1 e8 16             	shr    $0x16,%eax
    7719:	01 c2                	add    %eax,%edx
    771b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    7721:	29 c2                	sub    %eax,%edx
    7723:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    772a:	29 f8                	sub    %edi,%eax
    772c:	05 00 04 00 00       	add    $0x400,%eax
    7731:	89 c7                	mov    %eax,%edi
    7733:	c1 ff 1f             	sar    $0x1f,%edi
    7736:	c1 ef 16             	shr    $0x16,%edi
    7739:	01 f8                	add    %edi,%eax
    773b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7740:	29 f8                	sub    %edi,%eax
    7742:	39 c2                	cmp    %eax,%edx
    7744:	7d 0f                	jge    7755 <rlc_pkt_receive_from_mac+0x8a5>
    7746:	8b bc b1 b8 00 00 00 	mov    0xb8(%ecx,%esi,4),%edi
    774d:	85 ff                	test   %edi,%edi
    774f:	0f 85 6c 05 00 00    	jne    7cc1 <rlc_pkt_receive_from_mac+0xe11>
    7755:	89 c8                	mov    %ecx,%eax
    7757:	89 f2                	mov    %esi,%edx
    7759:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    775c:	e8 fc ff ff ff       	call   775d <rlc_pkt_receive_from_mac+0x8ad>
    7761:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7764:	84 c0                	test   %al,%al
    7766:	0f 85 55 05 00 00    	jne    7cc1 <rlc_pkt_receive_from_mac+0xe11>
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
    776c:	66 c7 45 e0 00 04    	movw   $0x400,-0x20(%ebp)
    7772:	e9 f7 f8 ff ff       	jmp    706e <rlc_pkt_receive_from_mac+0x1be>
    7777:	90                   	nop
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
		amIns->reorderTimer = 0;
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7778:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    777b:	8b 50 14             	mov    0x14(%eax),%edx
    777e:	85 d2                	test   %edx,%edx
    7780:	0f 85 c2 fd ff ff    	jne    7548 <rlc_pkt_receive_from_mac+0x698>
    7786:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    778d:	e9 75 fd ff ff       	jmp    7507 <rlc_pkt_receive_from_mac+0x657>
    7792:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
	if(fixhead->P == 1)
	{
		fsm_printf("[RLC] amIns->statProhTimer = %d\n",amIns->statProhTimer);
    7798:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    779b:	8b 46 20             	mov    0x20(%esi),%eax
    779e:	c7 04 24 3c 24 00 00 	movl   $0x243c,(%esp)
    77a5:	89 44 24 04          	mov    %eax,0x4(%esp)
    77a9:	e8 fc ff ff ff       	call   77aa <rlc_pkt_receive_from_mac+0x8fa>
		//
		if( !amIns->statProhTimer )
    77ae:	8b 46 20             	mov    0x20(%esi),%eax
    77b1:	85 c0                	test   %eax,%eax
    77b3:	0f 85 b3 fd ff ff    	jne    756c <rlc_pkt_receive_from_mac+0x6bc>
		{
			amIns->statFlag = true;
    77b9:	c6 46 06 01          	movb   $0x1,0x6(%esi)
			fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the statProhTimer start\n");
    77bd:	c7 04 24 60 24 00 00 	movl   $0x2460,(%esp)
    77c4:	e8 fc ff ff ff       	call   77c5 <rlc_pkt_receive_from_mac+0x915>
			amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    77c9:	8b 56 24             	mov    0x24(%esi),%edx
    77cc:	8b 46 28             	mov    0x28(%esi),%eax
    77cf:	e8 fc ff ff ff       	call   77d0 <rlc_pkt_receive_from_mac+0x920>
    77d4:	89 46 20             	mov    %eax,0x20(%esi)
    77d7:	e9 90 fd ff ff       	jmp    756c <rlc_pkt_receive_from_mac+0x6bc>
    77dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	umbuf->SN = SN;
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
	if(umRxIns->snFiledLength == 5)
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
    77e0:	89 7c b1 38          	mov    %edi,0x38(%ecx,%esi,4)
    77e4:	e9 e6 f8 ff ff       	jmp    70cf <rlc_pkt_receive_from_mac+0x21f>
    77e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    77f0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		rlc_ctrl_pkt_recv(amIns, pkt);
    77f3:	89 da                	mov    %ebx,%edx
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    77f5:	83 80 a4 5a 00 00 01 	addl   $0x1,0x5aa4(%eax)
		rlc_ctrl_pkt_recv(amIns, pkt);
    77fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    77ff:	e8 fc ff ff ff       	call   7800 <rlc_pkt_receive_from_mac+0x950>
    7804:	e9 63 fd ff ff       	jmp    756c <rlc_pkt_receive_from_mac+0x6bc>
    7809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    7810:	8d 42 01             	lea    0x1(%edx),%eax
    7813:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7816:	89 c1                	mov    %eax,%ecx
    7818:	c1 f9 1f             	sar    $0x1f,%ecx
    781b:	c1 e9 16             	shr    $0x16,%ecx
    781e:	01 c8                	add    %ecx,%eax
    7820:	25 ff 03 00 00       	and    $0x3ff,%eax
    7825:	29 c8                	sub    %ecx,%eax
    7827:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    782e:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7835:	85 d2                	test   %edx,%edx
    7837:	74 3b                	je     7874 <rlc_pkt_receive_from_mac+0x9c4>
    7839:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    783d:	75 35                	jne    7874 <rlc_pkt_receive_from_mac+0x9c4>
    783f:	89 d9                	mov    %ebx,%ecx
    7841:	eb 0b                	jmp    784e <rlc_pkt_receive_from_mac+0x99e>
    7843:	90                   	nop
    7844:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    7848:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    784c:	75 26                	jne    7874 <rlc_pkt_receive_from_mac+0x9c4>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    784e:	83 c0 01             	add    $0x1,%eax
    7851:	89 c2                	mov    %eax,%edx
    7853:	c1 fa 1f             	sar    $0x1f,%edx
    7856:	c1 ea 16             	shr    $0x16,%edx
    7859:	01 d0                	add    %edx,%eax
    785b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7860:	29 d0                	sub    %edx,%eax
    7862:	66 89 81 f2 22 00 00 	mov    %ax,0x22f2(%ecx)

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    7869:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7870:	85 d2                	test   %edx,%edx
    7872:	75 d4                	jne    7848 <rlc_pkt_receive_from_mac+0x998>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
    7874:	89 44 24 04          	mov    %eax,0x4(%esp)
    7878:	c7 04 24 64 23 00 00 	movl   $0x2364,(%esp)
    787f:	e8 fc ff ff ff       	call   7880 <rlc_pkt_receive_from_mac+0x9d0>
    7884:	e9 04 fc ff ff       	jmp    748d <rlc_pkt_receive_from_mac+0x5dd>
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
    7889:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    788c:	c7 04 24 9c 27 00 00 	movl   $0x279c,(%esp)
    7893:	e8 fc ff ff ff       	call   7894 <rlc_pkt_receive_from_mac+0x9e4>
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
    7898:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    789b:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    78a2:	0f bf c7             	movswl %di,%eax
    78a5:	8b 74 81 38          	mov    0x38(%ecx,%eax,4),%esi
    78a9:	85 f6                	test   %esi,%esi
    78ab:	0f 84 f3 f8 ff ff    	je     71a4 <rlc_pkt_receive_from_mac+0x2f4>
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    78b1:	83 c0 01             	add    $0x1,%eax
    78b4:	89 c2                	mov    %eax,%edx
    78b6:	c1 fa 1f             	sar    $0x1f,%edx
    78b9:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    78bb:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    78be:	89 d7                	mov    %edx,%edi
    78c0:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    78c7:	8b 54 81 38          	mov    0x38(%ecx,%eax,4),%edx
    78cb:	85 d2                	test   %edx,%edx
    78cd:	74 31                	je     7900 <rlc_pkt_receive_from_mac+0xa50>
    78cf:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    78d6:	66 39 fe             	cmp    %di,%si
    78d9:	7d 0a                	jge    78e5 <rlc_pkt_receive_from_mac+0xa35>
    78db:	eb 23                	jmp    7900 <rlc_pkt_receive_from_mac+0xa50>
    78dd:	8d 76 00             	lea    0x0(%esi),%esi
    78e0:	66 39 d6             	cmp    %dx,%si
    78e3:	7c 14                	jl     78f9 <rlc_pkt_receive_from_mac+0xa49>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    78e5:	83 c0 01             	add    $0x1,%eax
    78e8:	89 c2                	mov    %eax,%edx
    78ea:	c1 fa 1f             	sar    $0x1f,%edx
    78ed:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    78ef:	0f bf c2             	movswl %dx,%eax
    78f2:	83 7c 81 38 00       	cmpl   $0x0,0x38(%ecx,%eax,4)
    78f7:	75 e7                	jne    78e0 <rlc_pkt_receive_from_mac+0xa30>
    78f9:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    7900:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7903:	89 44 24 04          	mov    %eax,0x4(%esp)
    7907:	c7 04 24 58 27 00 00 	movl   $0x2758,(%esp)
    790e:	e8 fc ff ff ff       	call   790f <rlc_pkt_receive_from_mac+0xa5f>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    7913:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7916:	8d 51 18             	lea    0x18(%ecx),%edx
    7919:	89 c8                	mov    %ecx,%eax
    791b:	e8 fc ff ff ff       	call   791c <rlc_pkt_receive_from_mac+0xa6c>
    7920:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7923:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    792a:	e9 75 f8 ff ff       	jmp    71a4 <rlc_pkt_receive_from_mac+0x2f4>
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
    792f:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    7936:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7939:	c7 04 24 cc 27 00 00 	movl   $0x27cc,(%esp)
    7940:	89 44 24 04          	mov    %eax,0x4(%esp)
    7944:	e8 fc ff ff ff       	call   7945 <rlc_pkt_receive_from_mac+0xa95>
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
    7949:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    794c:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    7953:	0f bf c7             	movswl %di,%eax
    7956:	8b b4 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%esi
    795d:	85 f6                	test   %esi,%esi
    795f:	0f 84 3f f8 ff ff    	je     71a4 <rlc_pkt_receive_from_mac+0x2f4>
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
    7965:	c7 04 24 14 28 00 00 	movl   $0x2814,(%esp)
    796c:	e8 fc ff ff ff       	call   796d <rlc_pkt_receive_from_mac+0xabd>
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7971:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7974:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    797b:	83 c0 01             	add    $0x1,%eax
    797e:	89 c2                	mov    %eax,%edx
    7980:	c1 fa 1f             	sar    $0x1f,%edx
    7983:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7985:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7988:	89 d7                	mov    %edx,%edi
    798a:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7991:	8b 94 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%edx
    7998:	85 d2                	test   %edx,%edx
    799a:	74 37                	je     79d3 <rlc_pkt_receive_from_mac+0xb23>
    799c:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    79a3:	66 39 f7             	cmp    %si,%di
    79a6:	7e 0d                	jle    79b5 <rlc_pkt_receive_from_mac+0xb05>
    79a8:	eb 29                	jmp    79d3 <rlc_pkt_receive_from_mac+0xb23>
    79aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    79b0:	66 39 f2             	cmp    %si,%dx
    79b3:	7f 17                	jg     79cc <rlc_pkt_receive_from_mac+0xb1c>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    79b5:	83 c0 01             	add    $0x1,%eax
    79b8:	89 c2                	mov    %eax,%edx
    79ba:	c1 fa 1f             	sar    $0x1f,%edx
    79bd:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    79bf:	0f bf c2             	movswl %dx,%eax
    79c2:	83 bc 81 b8 00 00 00 	cmpl   $0x0,0xb8(%ecx,%eax,4)
    79c9:	00 
    79ca:	75 e4                	jne    79b0 <rlc_pkt_receive_from_mac+0xb00>
    79cc:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    79d3:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    79d6:	89 44 24 04          	mov    %eax,0x4(%esp)
    79da:	c7 04 24 58 27 00 00 	movl   $0x2758,(%esp)
    79e1:	e8 fc ff ff ff       	call   79e2 <rlc_pkt_receive_from_mac+0xb32>
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    79e6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    79e9:	8d 51 18             	lea    0x18(%ecx),%edx
    79ec:	89 c8                	mov    %ecx,%eax
    79ee:	e8 fc ff ff ff       	call   79ef <rlc_pkt_receive_from_mac+0xb3f>
    79f3:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    79f6:	e9 a2 f7 ff ff       	jmp    719d <rlc_pkt_receive_from_mac+0x2ed>
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    79fb:	83 b8 90 00 00 00 01 	cmpl   $0x1,0x90(%eax)
    7a02:	0f 85 1a fa ff ff    	jne    7422 <rlc_pkt_receive_from_mac+0x572>
				(amIns->amRecvWindow[SN]->segnum == 1)&&(amIns->amRecvWindow[SN]->segStart[0] == 0))
    7a08:	8b 48 10             	mov    0x10(%eax),%ecx
    7a0b:	85 c9                	test   %ecx,%ecx
    7a0d:	0f 85 0f fa ff ff    	jne    7422 <rlc_pkt_receive_from_mac+0x572>
			{
				amIns->amRecvWindow[SN]->pktstatus = FULL_SDU;
    7a13:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    7a1a:	e9 03 fa ff ff       	jmp    7422 <rlc_pkt_receive_from_mac+0x572>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
    7a1f:	c7 04 24 c0 23 00 00 	movl   $0x23c0,(%esp)
    7a26:	e8 fc ff ff ff       	call   7a27 <rlc_pkt_receive_from_mac+0xb77>
		amIns->vr_r = (amIns->vr_r+1)%1024;
    7a2b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7a2e:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    7a35:	83 c0 01             	add    $0x1,%eax
    7a38:	89 c2                	mov    %eax,%edx
    7a3a:	c1 fa 1f             	sar    $0x1f,%edx
    7a3d:	c1 ea 16             	shr    $0x16,%edx
    7a40:	01 d0                	add    %edx,%eax
    7a42:	25 ff 03 00 00       	and    $0x3ff,%eax
    7a47:	29 d0                	sub    %edx,%eax
    7a49:	66 89 83 f4 22 00 00 	mov    %ax,0x22f4(%ebx)
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7a50:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7a57:	85 d2                	test   %edx,%edx
    7a59:	74 39                	je     7a94 <rlc_pkt_receive_from_mac+0xbe4>
    7a5b:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    7a5f:	75 33                	jne    7a94 <rlc_pkt_receive_from_mac+0xbe4>
    7a61:	89 d9                	mov    %ebx,%ecx
    7a63:	eb 09                	jmp    7a6e <rlc_pkt_receive_from_mac+0xbbe>
    7a65:	8d 76 00             	lea    0x0(%esi),%esi
    7a68:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    7a6c:	75 26                	jne    7a94 <rlc_pkt_receive_from_mac+0xbe4>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
    7a6e:	83 c0 01             	add    $0x1,%eax
    7a71:	89 c2                	mov    %eax,%edx
    7a73:	c1 fa 1f             	sar    $0x1f,%edx
    7a76:	c1 ea 16             	shr    $0x16,%edx
    7a79:	01 d0                	add    %edx,%eax
    7a7b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7a80:	29 d0                	sub    %edx,%eax
    7a82:	66 89 81 f4 22 00 00 	mov    %ax,0x22f4(%ecx)
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
		amIns->vr_r = (amIns->vr_r+1)%1024;
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7a89:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7a90:	85 d2                	test   %edx,%edx
    7a92:	75 d4                	jne    7a68 <rlc_pkt_receive_from_mac+0xbb8>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
		}
		amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 1024;
    7a94:	05 00 02 00 00       	add    $0x200,%eax
    7a99:	89 c2                	mov    %eax,%edx
    7a9b:	c1 fa 1f             	sar    $0x1f,%edx
    7a9e:	c1 ea 16             	shr    $0x16,%edx
    7aa1:	01 d0                	add    %edx,%eax
    7aa3:	25 ff 03 00 00       	and    $0x3ff,%eax
    7aa8:	29 d0                	sub    %edx,%eax
    7aaa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7aad:	66 89 82 ec 22 00 00 	mov    %ax,0x22ec(%edx)
		//amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_r is updated to %d, amIns->vr_mr is updated to %d\n",amIns->vr_r, amIns->vr_mr);
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
    7ab4:	c7 04 24 f8 23 00 00 	movl   $0x23f8,(%esp)
    7abb:	e8 fc ff ff ff       	call   7abc <rlc_pkt_receive_from_mac+0xc0c>
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    7ac0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7ac3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ac6:	83 c2 30             	add    $0x30,%edx
    7ac9:	e8 fc ff ff ff       	call   7aca <rlc_pkt_receive_from_mac+0xc1a>
    7ace:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ad1:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    7ad8:	e9 d5 f9 ff ff       	jmp    74b2 <rlc_pkt_receive_from_mac+0x602>
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    7add:	29 f2                	sub    %esi,%edx
    7adf:	83 c2 30             	add    $0x30,%edx
    7ae2:	89 d6                	mov    %edx,%esi
    7ae4:	c1 fe 1f             	sar    $0x1f,%esi
    7ae7:	c1 ee 1b             	shr    $0x1b,%esi
    7aea:	01 f2                	add    %esi,%edx
    7aec:	83 e2 1f             	and    $0x1f,%edx
    7aef:	29 f2                	sub    %esi,%edx
    7af1:	83 fa 0f             	cmp    $0xf,%edx
    7af4:	0f 9e c2             	setle  %dl
    7af7:	e9 10 f7 ff ff       	jmp    720c <rlc_pkt_receive_from_mac+0x35c>

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    7afc:	b8 a4 00 00 00       	mov    $0xa4,%eax
    7b01:	e8 fc ff ff ff       	call   7b02 <rlc_pkt_receive_from_mac+0xc52>
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7b06:	8b 4d d0             	mov    -0x30(%ebp),%ecx

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    7b09:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7b0c:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    7b10:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    7b14:	83 e0 7f             	and    $0x7f,%eax
    7b17:	c1 e0 08             	shl    $0x8,%eax
    7b1a:	09 d0                	or     %edx,%eax
    7b1c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
			if(0 == ambuf->pos)
    7b1f:	85 c0                	test   %eax,%eax
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7b21:	89 42 08             	mov    %eax,0x8(%edx)
			if(0 == ambuf->pos)
    7b24:	0f 85 e6 00 00 00    	jne    7c10 <rlc_pkt_receive_from_mac+0xd60>
			{
				ambuf->pkt = pkt;
    7b2a:	89 1a                	mov    %ebx,(%edx)
    7b2c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7b33:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b36:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
			ambuf->segnum = 1;
			ambuf->datalen = 0;
			if(extseghead->LSF == 1)
    7b3a:	8b 4d d0             	mov    -0x30(%ebp),%ecx
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
			ambuf->segnum = 1;
    7b3d:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    7b44:	00 00 00 
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7b47:	66 89 90 94 00 00 00 	mov    %dx,0x94(%eax)
			ambuf->segnum = 1;
			ambuf->datalen = 0;
    7b4e:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    7b55:	00 00 00 
			if(extseghead->LSF == 1)
    7b58:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    7b5c:	0f 89 9f 00 00 00    	jns    7c01 <rlc_pkt_receive_from_mac+0xd51>
			{
				ambuf->pktstatus = LAST_SEGMENT;
    7b62:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				ambuf->datalen = ambuf->pos + pkt->len;
    7b69:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7b6c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7b6f:	03 43 50             	add    0x50(%ebx),%eax
    7b72:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
    7b78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b7b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7b7e:	89 50 10             	mov    %edx,0x10(%eax)
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7b81:	8b 4b 50             	mov    0x50(%ebx),%ecx
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7b84:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7b8a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    7b8d:	31 c9                	xor    %ecx,%ecx
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7b8f:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    7b93:	74 19                	je     7bae <rlc_pkt_receive_from_mac+0xcfe>
	{
		count++;
		while(1 == (ind++)->E)
    7b95:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    7b99:	b1 01                	mov    $0x1,%cl
    7b9b:	79 11                	jns    7bae <rlc_pkt_receive_from_mac+0xcfe>
    7b9d:	83 c0 06             	add    $0x6,%eax
    7ba0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
		{
			count++;
    7ba4:	83 c1 01             	add    $0x1,%ecx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    7ba7:	83 c0 02             	add    $0x2,%eax
    7baa:	84 d2                	test   %dl,%dl
    7bac:	78 f2                	js     7ba0 <rlc_pkt_receive_from_mac+0xcf0>
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7bae:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7bb1:	8b 5d cc             	mov    -0x34(%ebp),%ebx
    7bb4:	8d 54 18 fc          	lea    -0x4(%eax,%ebx,1),%edx
    7bb8:	0f b7 c1             	movzwl %cx,%eax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    7bbb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7bbe:	f7 d8                	neg    %eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7bc0:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7bc3:	8d 04 42             	lea    (%edx,%eax,2),%eax
    7bc6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7bc9:	89 42 50             	mov    %eax,0x50(%edx)
    7bcc:	8b 81 60 02 00 00    	mov    0x260(%ecx),%eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7bd2:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7bd8:	89 91 60 02 00 00    	mov    %edx,0x260(%ecx)
    7bde:	81 c1 5c 02 00 00    	add    $0x25c,%ecx
    7be4:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    7bea:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    7bf0:	89 10                	mov    %edx,(%eax)
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been put into buffer(SN is %d)\n", SN);
			amIns->amRecvWindow[SN] = ambuf;
    7bf2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7bf5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7bf8:	89 5c 82 0c          	mov    %ebx,0xc(%edx,%eax,4)
    7bfc:	e9 21 f8 ff ff       	jmp    7422 <rlc_pkt_receive_from_mac+0x572>
				ambuf->datalen = ambuf->pos + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", ambuf->datalen );
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
    7c01:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7c04:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    7c0b:	e9 68 ff ff ff       	jmp    7b78 <rlc_pkt_receive_from_mac+0xcc8>
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7c10:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    7c13:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
    7c17:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    7c1b:	8b 4b 50             	mov    0x50(%ebx),%ecx
    7c1e:	83 e2 7f             	and    $0x7f,%edx
    7c21:	c1 e2 08             	shl    $0x8,%edx
    7c24:	09 c2                	or     %eax,%edx
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7c26:	89 d8                	mov    %ebx,%eax
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7c28:	01 ca                	add    %ecx,%edx
    7c2a:	89 55 cc             	mov    %edx,-0x34(%ebp)
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7c2d:	e8 fc ff ff ff       	call   7c2e <rlc_pkt_receive_from_mac+0xd7e>
    7c32:	03 45 cc             	add    -0x34(%ebp),%eax
    7c35:	e8 fc ff ff ff       	call   7c36 <rlc_pkt_receive_from_mac+0xd86>
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7c3a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    7c40:	89 55 c8             	mov    %edx,-0x38(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7c43:	8b 4d c8             	mov    -0x38(%ebp),%ecx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    7c46:	31 d2                	xor    %edx,%edx
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7c48:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7c4b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    7c51:	89 45 c0             	mov    %eax,-0x40(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7c54:	f6 41 01 04          	testb  $0x4,0x1(%ecx)
    7c58:	74 1b                	je     7c75 <rlc_pkt_receive_from_mac+0xdc5>
	{
		count++;
		while(1 == (ind++)->E)
    7c5a:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
    7c5e:	b2 01                	mov    $0x1,%dl
    7c60:	79 13                	jns    7c75 <rlc_pkt_receive_from_mac+0xdc5>
    7c62:	89 c8                	mov    %ecx,%eax
    7c64:	83 c0 06             	add    $0x6,%eax
    7c67:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    7c6b:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    7c6e:	83 c0 02             	add    $0x2,%eax
    7c71:	84 c9                	test   %cl,%cl
    7c73:	78 f2                	js     7c67 <rlc_pkt_receive_from_mac+0xdb7>
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7c75:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7c78:	8b 4b 50             	mov    0x50(%ebx),%ecx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7c7b:	8b 40 08             	mov    0x8(%eax),%eax
    7c7e:	89 45 bc             	mov    %eax,-0x44(%ebp)
    7c81:	0f b7 c2             	movzwl %dx,%eax
    7c84:	8b 55 bc             	mov    -0x44(%ebp),%edx
    7c87:	8d 44 42 04          	lea    0x4(%edx,%eax,2),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7c8b:	8b 55 c8             	mov    -0x38(%ebp),%edx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7c8e:	03 45 c0             	add    -0x40(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7c91:	e8 fc ff ff ff       	call   7c92 <rlc_pkt_receive_from_mac+0xde2>
				fsm_skb_put(pkptr, datalen);
    7c96:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7c99:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7c9c:	e8 fc ff ff ff       	call   7c9d <rlc_pkt_receive_from_mac+0xded>
				if(pkt != NULL)
    7ca1:	85 db                	test   %ebx,%ebx
    7ca3:	74 07                	je     7cac <rlc_pkt_receive_from_mac+0xdfc>
				{
					fsm_pkt_destroy(pkt);
    7ca5:	89 d8                	mov    %ebx,%eax
    7ca7:	e8 fc ff ff ff       	call   7ca8 <rlc_pkt_receive_from_mac+0xdf8>
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
    7cac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7caf:	31 db                	xor    %ebx,%ebx
    7cb1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7cb4:	8b 48 08             	mov    0x8(%eax),%ecx
    7cb7:	89 10                	mov    %edx,(%eax)
    7cb9:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    7cbc:	e9 72 fe ff ff       	jmp    7b33 <rlc_pkt_receive_from_mac+0xc83>
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
		{
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7cc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7cc4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7ccb:	89 d8                	mov    %ebx,%eax
    7ccd:	e8 fc ff ff ff       	call   7cce <rlc_pkt_receive_from_mac+0xe1e>
			printk("rlc_macfsm 4361\n");
    7cd2:	c7 04 24 86 04 00 00 	movl   $0x486,(%esp)
    7cd9:	e8 fc ff ff ff       	call   7cda <rlc_pkt_receive_from_mac+0xe2a>
    7cde:	e9 8f f2 ff ff       	jmp    6f72 <rlc_pkt_receive_from_mac+0xc2>
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
		{
			printk("[RLC][rlc_AM_pkt_receive_from_mac] PDU segment is outside the receiving window or the segment has been received\n");
    7ce3:	c7 04 24 74 22 00 00 	movl   $0x2274,(%esp)
    7cea:	e8 fc ff ff ff       	call   7ceb <rlc_pkt_receive_from_mac+0xe3b>
			printk("[RLC][rlc_AM_pkt_receive_from_mac] A packet has dropped\n");
    7cef:	c7 04 24 a0 21 00 00 	movl   $0x21a0,(%esp)
    7cf6:	e8 fc ff ff ff       	call   7cf7 <rlc_pkt_receive_from_mac+0xe47>
			SV(countDropPacket)++;
    7cfb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7cfe:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			if(pkt != NULL)
    7d05:	85 db                	test   %ebx,%ebx
    7d07:	0f 84 5f f8 ff ff    	je     756c <rlc_pkt_receive_from_mac+0x6bc>
			{
				fsm_pkt_destroy(pkt);
    7d0d:	89 d8                	mov    %ebx,%eax
    7d0f:	e8 fc ff ff ff       	call   7d10 <rlc_pkt_receive_from_mac+0xe60>
    7d14:	e9 53 f8 ff ff       	jmp    756c <rlc_pkt_receive_from_mac+0x6bc>
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
    7d19:	89 74 24 04          	mov    %esi,0x4(%esp)
    7d1d:	c7 04 24 e4 25 00 00 	movl   $0x25e4,(%esp)
    7d24:	e8 fc ff ff ff       	call   7d25 <rlc_pkt_receive_from_mac+0xe75>
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7d29:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7d2c:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7d33:	89 d8                	mov    %ebx,%eax
    7d35:	e8 fc ff ff ff       	call   7d36 <rlc_pkt_receive_from_mac+0xe86>
			printk("rlc_macfsm 4328\n");
    7d3a:	c7 04 24 75 04 00 00 	movl   $0x475,(%esp)
    7d41:	e8 fc ff ff ff       	call   7d42 <rlc_pkt_receive_from_mac+0xe92>
    7d46:	e9 27 f2 ff ff       	jmp    6f72 <rlc_pkt_receive_from_mac+0xc2>
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7d4b:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7d4f:	c7 04 24 20 21 00 00 	movl   $0x2120,(%esp)
    7d56:	89 44 24 04          	mov    %eax,0x4(%esp)
    7d5a:	e8 fc ff ff ff       	call   7d5b <rlc_pkt_receive_from_mac+0xeab>
				break;
    7d5f:	e9 57 f2 ff ff       	jmp    6fbb <rlc_pkt_receive_from_mac+0x10b>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
    7d64:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7d68:	c7 04 24 dc 20 00 00 	movl   $0x20dc,(%esp)
    7d6f:	89 44 24 04          	mov    %eax,0x4(%esp)
    7d73:	e8 fc ff ff ff       	call   7d74 <rlc_pkt_receive_from_mac+0xec4>
				break;
    7d78:	e9 3e f2 ff ff       	jmp    6fbb <rlc_pkt_receive_from_mac+0x10b>
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7d7d:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7d81:	c7 04 24 04 25 00 00 	movl   $0x2504,(%esp)
    7d88:	89 44 24 04          	mov    %eax,0x4(%esp)
    7d8c:	e8 fc ff ff ff       	call   7d8d <rlc_pkt_receive_from_mac+0xedd>
				break;
    7d91:	e9 25 f2 ff ff       	jmp    6fbb <rlc_pkt_receive_from_mac+0x10b>
			break;

		case UM_MODE:
			if(insptrd == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
    7d96:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7d9a:	c7 04 24 c0 24 00 00 	movl   $0x24c0,(%esp)
    7da1:	89 44 24 04          	mov    %eax,0x4(%esp)
    7da5:	e8 fc ff ff ff       	call   7da6 <rlc_pkt_receive_from_mac+0xef6>
				break;
    7daa:	e9 0c f2 ff ff       	jmp    6fbb <rlc_pkt_receive_from_mac+0x10b>
    7daf:	90                   	nop

00007db0 <MACCETA_handle>:
//HQ
/**
 * @function: deal with Timing Advance control element
 * @param ta_index: Timing Advance Command
 */
void MACCETA_handle(unsigned char ta_index) {   
    7db0:	55                   	push   %ebp
    7db1:	89 e5                	mov    %esp,%ebp
    7db3:	56                   	push   %esi
    7db4:	53                   	push   %ebx
    7db5:	e8 fc ff ff ff       	call   7db6 <MACCETA_handle+0x6>
    7dba:	89 c6                	mov    %eax,%esi
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7dbc:	e8 fc ff ff ff       	call   7dbd <MACCETA_handle+0xd>
    if(SV(TATimer.flag)==true)
    7dc1:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
 */
void MACCETA_handle(unsigned char ta_index) {   
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7dc8:	89 c3                	mov    %eax,%ebx
    if(SV(TATimer.flag)==true)
    7dca:	74 0b                	je     7dd7 <MACCETA_handle+0x27>
        fsm_schedule_cancel(SV(TATimer.timer_sign));
    7dcc:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    7dd2:	e8 fc ff ff ff       	call   7dd3 <MACCETA_handle+0x23>
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7dd7:	8b 43 24             	mov    0x24(%ebx),%eax
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7dda:	81 e6 ff 00 00 00    	and    $0xff,%esi
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7de0:	ba 0b 00 00 00       	mov    $0xb,%edx
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7de5:	83 ee 1f             	sub    $0x1f,%esi
    7de8:	c1 e6 04             	shl    $0x4,%esi
    7deb:	66 01 73 22          	add    %si,0x22(%ebx)
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7def:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7df5:	6b c0 64             	imul   $0x64,%eax,%eax
    7df8:	e8 fc ff ff ff       	call   7df9 <MACCETA_handle+0x49>
	SV(TATimer.flag)=true;
    7dfd:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7e04:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
	SV(TATimer.flag)=true;
		
FOUT;
}
    7e0a:	5b                   	pop    %ebx
    7e0b:	5e                   	pop    %esi
    7e0c:	5d                   	pop    %ebp
    7e0d:	c3                   	ret    
    7e0e:	66 90                	xchg   %ax,%ax

00007e10 <decomplexRarPdu>:
/**
 * @function: decomplex the RAR PDU to get the MAC RAR that belongs to the user
 * @param skb: the sk_buff that contains the RAR PDU
 * @return: is there MAC RAR in the RAR PDU that belongs to the user
 */
bool decomplexRarPdu(FSM_PKT *skb){		//RAR SDU	//RAR
    7e10:	55                   	push   %ebp
    7e11:	89 e5                	mov    %esp,%ebp
    7e13:	57                   	push   %edi
    7e14:	56                   	push   %esi
    7e15:	53                   	push   %ebx
    7e16:	83 ec 3c             	sub    $0x3c,%esp
    7e19:	e8 fc ff ff ff       	call   7e1a <decomplexRarPdu+0xa>
    7e1e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
	MAC_RAR_subhead_withbi *bi_subhead=(MAC_RAR_subhead_withbi*)fsm_mem_alloc(sizeof(MAC_RAR_subhead_withbi));	//20140430
    7e21:	b8 01 00 00 00       	mov    $0x1,%eax
    7e26:	e8 fc ff ff ff       	call   7e27 <decomplexRarPdu+0x17>
    7e2b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
    7e2e:	b8 01 00 00 00       	mov    $0x1,%eax
    7e33:	e8 fc ff ff ff       	call   7e34 <decomplexRarPdu+0x24>
    7e38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
    7e3b:	b8 06 00 00 00       	mov    $0x6,%eax
    7e40:	e8 fc ff ff ff       	call   7e41 <decomplexRarPdu+0x31>
    7e45:	89 45 d8             	mov    %eax,-0x28(%ebp)
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
    7e48:	b8 04 00 00 00       	mov    $0x4,%eax
    7e4d:	e8 fc ff ff ff       	call   7e4e <decomplexRarPdu+0x3e>
    7e52:	89 45 cc             	mov    %eax,-0x34(%ebp)
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));
    7e55:	b8 07 00 00 00       	mov    $0x7,%eax
    7e5a:	e8 fc ff ff ff       	call   7e5b <decomplexRarPdu+0x4b>
    7e5f:	89 45 c8             	mov    %eax,-0x38(%ebp)

	SV_PTR_GET(rlc_mac_sv);
    7e62:	e8 fc ff ff ff       	call   7e63 <decomplexRarPdu+0x53>
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7e67:	31 d2                	xor    %edx,%edx
    7e69:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));

	SV_PTR_GET(rlc_mac_sv);
    7e6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7e71:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7e74:	e8 fc ff ff ff       	call   7e75 <decomplexRarPdu+0x65>
	fsm_mem_set(rar_subhead,0,sizeof(MAC_RAR_subhead));	//20140430
    7e79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7e7c:	31 d2                	xor    %edx,%edx
    7e7e:	b9 01 00 00 00       	mov    $0x1,%ecx
    7e83:	e8 fc ff ff ff       	call   7e84 <decomplexRarPdu+0x74>
	fsm_mem_set(rar_sdu,0,sizeof(MAC_RAR_sdu));	//20140430
    7e88:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7e8b:	31 d2                	xor    %edx,%edx
    7e8d:	b9 06 00 00 00       	mov    $0x6,%ecx
    7e92:	e8 fc ff ff ff       	call   7e93 <decomplexRarPdu+0x83>
	fsm_mem_set(rar_ulgrant,0,sizeof(RAR_ULgrant));	//20141111modified
    7e97:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7e9a:	31 d2                	xor    %edx,%edx
    7e9c:	b9 04 00 00 00       	mov    $0x4,%ecx
    7ea1:	e8 fc ff ff ff       	call   7ea2 <decomplexRarPdu+0x92>
	fsm_mem_set(phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    7ea6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7ea9:	31 d2                	xor    %edx,%edx
    7eab:	b9 07 00 00 00       	mov    $0x7,%ecx
    7eb0:	e8 fc ff ff ff       	call   7eb1 <decomplexRarPdu+0xa1>
		fsm_printf("%c,",*((char *)skb->data+offset));
	}
	fsm_printf("\n");*/
	//fsm_octets_print(newskb->data,4);
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
    7eb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7eb8:	b9 01 00 00 00       	mov    $0x1,%ecx
    7ebd:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    7ec3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ec6:	e8 fc ff ff ff       	call   7ec7 <decomplexRarPdu+0xb7>
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
    7ecb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ece:	0f b6 10             	movzbl (%eax),%edx
    7ed1:	89 d0                	mov    %edx,%eax
    7ed3:	c0 e8 06             	shr    $0x6,%al
    7ed6:	0f b6 c0             	movzbl %al,%eax
	if(typ_flag==0||typ_flag==2){		//BI
    7ed9:	83 f8 02             	cmp    $0x2,%eax
    7edc:	0f 84 5e 01 00 00    	je     8040 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7ee2:	31 ff                	xor    %edi,%edi
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
    7ee4:	85 c0                	test   %eax,%eax
    7ee6:	0f 84 54 01 00 00    	je     8040 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7eec:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7eef:	8b 75 e0             	mov    -0x20(%ebp),%esi
    7ef2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7ef9:	89 7d ec             	mov    %edi,-0x14(%ebp)
    7efc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7f00:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    7f06:	b9 01 00 00 00       	mov    $0x1,%ecx
    7f0b:	89 d8                	mov    %ebx,%eax
	else{
		continue_flag=true;
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
    7f0d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7f11:	01 fa                	add    %edi,%edx
		from_len=from_len+sizeof(MAC_RAR_subhead);
    7f13:	83 c7 01             	add    $0x1,%edi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7f16:	e8 fc ff ff ff       	call   7f17 <decomplexRarPdu+0x107>
		from_len=from_len+sizeof(MAC_RAR_subhead);
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
    7f1b:	80 3b 00             	cmpb   $0x0,(%ebx)
    7f1e:	78 e0                	js     7f00 <decomplexRarPdu+0xf0>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7f20:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f23:	89 fe                	mov    %edi,%esi
    7f25:	89 74 24 08          	mov    %esi,0x8(%esp)
    7f29:	8b 7d ec             	mov    -0x14(%ebp),%edi
    7f2c:	c7 04 24 c8 29 00 00 	movl   $0x29c8,(%esp)
    7f33:	89 44 24 04          	mov    %eax,0x4(%esp)
    7f37:	e8 fc ff ff ff       	call   7f38 <decomplexRarPdu+0x128>

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7f3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f3f:	85 c0                	test   %eax,%eax
    7f41:	0f 84 f3 00 00 00    	je     803a <decomplexRarPdu+0x22a>
    7f47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    7f4e:	eb 4a                	jmp    7f9a <decomplexRarPdu+0x18a>
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7f50:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7f54:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7f58:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7f5f:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7f63:	e8 fc ff ff ff       	call   7f64 <decomplexRarPdu+0x154>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7f68:	0f bf 55 d6          	movswl -0x2a(%ebp),%edx
    7f6c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    7f6f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7f73:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    7f7a:	e8 fc ff ff ff       	call   7f7b <decomplexRarPdu+0x16b>
		if(rapid_in_subhead==my_id){	//RAR
    7f7f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7f82:	39 da                	cmp    %ebx,%edx
    7f84:	0f 84 1f 01 00 00    	je     80a9 <decomplexRarPdu+0x299>
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7f8a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7f8e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f91:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7f94:	0f 84 a0 00 00 00    	je     803a <decomplexRarPdu+0x22a>
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7f9a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f9d:	89 fa                	mov    %edi,%edx
    7f9f:	b9 01 00 00 00       	mov    $0x1,%ecx
		head_len=head_len+len;
    7fa4:	83 c7 01             	add    $0x1,%edi

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7fa7:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7fad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7fb0:	e8 fc ff ff ff       	call   7fb1 <decomplexRarPdu+0x1a1>
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7fb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7fb8:	0f b6 18             	movzbl (%eax),%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7fbb:	c7 04 24 a4 04 00 00 	movl   $0x4a4,(%esp)

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7fc2:	83 e3 3f             	and    $0x3f,%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7fc5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7fc9:	e8 fc ff ff ff       	call   7fca <decomplexRarPdu+0x1ba>

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7fce:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7fd1:	89 f2                	mov    %esi,%edx
    7fd3:	b9 06 00 00 00       	mov    $0x6,%ecx

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
    7fd8:	83 c6 06             	add    $0x6,%esi
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7fdb:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7fe1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fe4:	e8 fc ff ff ff       	call   7fe5 <decomplexRarPdu+0x1d5>

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
    7fe9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fec:	8b 82 fc 01 00 00    	mov    0x1fc(%edx),%eax
    7ff2:	85 c0                	test   %eax,%eax
    7ff4:	0f 84 56 ff ff ff    	je     7f50 <decomplexRarPdu+0x140>
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
			
		}
		else
		{
			SV(rar_failed_num)=SV(rar_failed_num)-1;
    7ffa:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7ffd:	83 e8 01             	sub    $0x1,%eax
    8000:	89 82 fc 01 00 00    	mov    %eax,0x1fc(%edx)
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    8006:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    800a:	c7 04 24 b7 04 00 00 	movl   $0x4b7,(%esp)
    8011:	e8 fc ff ff ff       	call   8012 <decomplexRarPdu+0x202>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    8016:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
    801d:	00 
    801e:	c7 04 24 d2 04 00 00 	movl   $0x4d2,(%esp)
    8025:	e8 fc ff ff ff       	call   8026 <decomplexRarPdu+0x216>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    802a:	8b 55 e8             	mov    -0x18(%ebp),%edx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    802d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    8031:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    8034:	0f 85 60 ff ff ff    	jne    7f9a <decomplexRarPdu+0x18a>
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    803a:	31 db                	xor    %ebx,%ebx
    803c:	eb 2f                	jmp    806d <decomplexRarPdu+0x25d>
    803e:	66 90                	xchg   %ax,%ax
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    8040:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    8043:	89 d0                	mov    %edx,%eax
    8045:	83 e0 0f             	and    $0xf,%eax
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    8048:	84 d2                	test   %dl,%dl
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    804a:	89 41 1c             	mov    %eax,0x1c(%ecx)
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    804d:	78 50                	js     809f <decomplexRarPdu+0x28f>
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    804f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    8056:	00 
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    8057:	31 db                	xor    %ebx,%ebx
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    8059:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    8060:	00 
    8061:	c7 04 24 c8 29 00 00 	movl   $0x29c8,(%esp)
    8068:	e8 fc ff ff ff       	call   8069 <decomplexRarPdu+0x259>
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
	}
	fsm_mem_free(bi_subhead);
    806d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8070:	e8 fc ff ff ff       	call   8071 <decomplexRarPdu+0x261>
	fsm_mem_free(rar_subhead);
    8075:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8078:	e8 fc ff ff ff       	call   8079 <decomplexRarPdu+0x269>
	fsm_mem_free(rar_sdu);
    807d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8080:	e8 fc ff ff ff       	call   8081 <decomplexRarPdu+0x271>
	fsm_mem_free(rar_ulgrant);	//20141111modified
    8085:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8088:	e8 fc ff ff ff       	call   8089 <decomplexRarPdu+0x279>
	fsm_mem_free(phy_ici);
    808d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    8090:	e8 fc ff ff ff       	call   8091 <decomplexRarPdu+0x281>
	FRET(return_value);
}
    8095:	89 d8                	mov    %ebx,%eax
    8097:	83 c4 3c             	add    $0x3c,%esp
    809a:	5b                   	pop    %ebx
    809b:	5e                   	pop    %esi
    809c:	5f                   	pop    %edi
    809d:	5d                   	pop    %ebp
    809e:	c3                   	ret    
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
		SV(backoff_index)=bi;
		from_len=from_len+len;
    809f:	bf 01 00 00 00       	mov    $0x1,%edi
    80a4:	e9 43 fe ff ff       	jmp    7eec <decomplexRarPdu+0xdc>
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
    80a9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    80ac:	8b 55 dc             	mov    -0x24(%ebp),%edx
    80af:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    80b3:	66 89 42 02          	mov    %ax,0x2(%edx)
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
    80b7:	89 44 24 04          	mov    %eax,0x4(%esp)
    80bb:	c7 04 24 e2 04 00 00 	movl   $0x4e2,(%esp)
    80c2:	e8 fc ff ff ff       	call   80c3 <decomplexRarPdu+0x2b3>
			
			tadvance=(rar_sdu->m_r_ta)&127;
    80c7:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    80ca:	0f b6 01             	movzbl (%ecx),%eax
			tadvance=tadvance<<4;
    80cd:	89 c2                	mov    %eax,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    80cf:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
			
			tadvance=(rar_sdu->m_r_ta)&127;
			tadvance=tadvance<<4;
    80d3:	83 e2 7f             	and    $0x7f,%edx
    80d6:	c1 e2 04             	shl    $0x4,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    80d9:	c0 e8 04             	shr    $0x4,%al
    80dc:	0f b6 c0             	movzbl %al,%eax
    80df:	01 d0                	add    %edx,%eax
    80e1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    80e4:	66 89 42 20          	mov    %ax,0x20(%edx)
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
    80e8:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			ul_grant=ul_grant<<12;
    80ec:	c1 e0 10             	shl    $0x10,%eax
    80ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    80f2:	0f b7 51 02          	movzwl 0x2(%ecx),%edx
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    80f6:	b9 04 00 00 00       	mov    $0x4,%ecx
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
			ul_grant=ul_grant<<12;
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    80fb:	01 d0                	add    %edx,%eax
    80fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    8100:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8103:	8d 55 f0             	lea    -0x10(%ebp),%edx
    8106:	e8 fc ff ff ff       	call   8107 <decomplexRarPdu+0x2f7>
			//m_tb_size=DoReceiveRARULgrant_Tbsize(ul_grant);	//make		//20140428 

			SV(recv_frame).frameNo=phy_ici->frameNo;	//add on 11,17.2014
    810b:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    810e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8111:	0f b7 41 03          	movzwl 0x3(%ecx),%eax
    8115:	66 89 42 0a          	mov    %ax,0xa(%edx)
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014
    8119:	0f b7 41 05          	movzwl 0x5(%ecx),%eax
    811d:	66 89 42 0c          	mov    %ax,0xc(%edx)

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
    8121:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8124:	e8 fc ff ff ff       	call   8125 <decomplexRarPdu+0x315>
    8129:	89 c3                	mov    %eax,%ebx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
    812b:	89 44 24 04          	mov    %eax,0x4(%esp)
    812f:	c7 04 24 fc 04 00 00 	movl   $0x4fc,(%esp)
    8136:	e8 fc ff ff ff       	call   8137 <decomplexRarPdu+0x327>
			SV(UL_resource_info).m_tbsize=m_tb_size;		
    813b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    813e:	89 58 2c             	mov    %ebx,0x2c(%eax)
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
    8141:	bb 01 00 00 00       	mov    $0x1,%ebx
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
    8146:	c6 40 28 01          	movb   $0x1,0x28(%eax)
			break;
    814a:	e9 1e ff ff ff       	jmp    806d <decomplexRarPdu+0x25d>
    814f:	90                   	nop

00008150 <lteMacCEC_rntiSend>:
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    8150:	55                   	push   %ebp
    8151:	89 e5                	mov    %esp,%ebp
    8153:	83 ec 10             	sub    $0x10,%esp
    8156:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8159:	89 75 f8             	mov    %esi,-0x8(%ebp)
    815c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    815f:	e8 fc ff ff ff       	call   8160 <lteMacCEC_rntiSend+0x10>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    8164:	31 db                	xor    %ebx,%ebx
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    8166:	89 c7                	mov    %eax,%edi
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
    8168:	e8 fc ff ff ff       	call   8169 <lteMacCEC_rntiSend+0x19>
    816d:	89 c6                	mov    %eax,%esi
    816f:	90                   	nop
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
    8170:	80 bc de a5 01 00 00 	cmpb   $0x1b,0x1a5(%esi,%ebx,8)
    8177:	1b 
    8178:	74 1e                	je     8198 <lteMacCEC_rntiSend+0x48>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    817a:	83 c3 01             	add    $0x1,%ebx
    817d:	83 fb 08             	cmp    $0x8,%ebx
    8180:	75 ee                	jne    8170 <lteMacCEC_rntiSend+0x20>
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    8182:	8b 5d f4             	mov    -0xc(%ebp),%ebx
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
    8185:	31 c0                	xor    %eax,%eax
}
    8187:	8b 75 f8             	mov    -0x8(%ebp),%esi
    818a:	8b 7d fc             	mov    -0x4(%ebp),%edi
    818d:	89 ec                	mov    %ebp,%esp
    818f:	5d                   	pop    %ebp
    8190:	c3                   	ret    
    8191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    8198:	83 c3 34             	add    $0x34,%ebx
	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");
    819b:	c7 04 24 f4 29 00 00 	movl   $0x29f4,(%esp)
    81a2:	e8 fc ff ff ff       	call   81a3 <lteMacCEC_rntiSend+0x53>

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    81a7:	8b 44 de 08          	mov    0x8(%esi,%ebx,8),%eax
    81ab:	0f b7 00             	movzwl (%eax),%eax
    81ae:	66 89 07             	mov    %ax,(%edi)
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    81b1:	8b 7d fc             	mov    -0x4(%ebp),%edi

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
			
			//fsm_printf("[MAC CRNTI]RNTI IN SV:%d\n",SV(C_RNTI));
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    81b4:	0f b6 44 de 04       	movzbl 0x4(%esi,%ebx,8),%eax
		}
	}
	
	FRET(false);
}
    81b9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    81bc:	8b 75 f8             	mov    -0x8(%ebp),%esi
    81bf:	89 ec                	mov    %ebp,%esp
    81c1:	5d                   	pop    %ebp
    81c2:	c3                   	ret    
    81c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    81c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000081d0 <lteMacCEPhSend>:
/**
 * @function: fill in the Power Headroom control element
 * @param m_power_headroom: the structure of Power Headroom control element
 * @return: is there Power Headroom control element tfsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);o send
 */
bool lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom){		//
    81d0:	55                   	push   %ebp
    81d1:	89 e5                	mov    %esp,%ebp
    81d3:	e8 fc ff ff ff       	call   81d4 <lteMacCEPhSend+0x4>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
    81d8:	e8 fc ff ff ff       	call   81d9 <lteMacCEPhSend+0x9>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    81dd:	31 d2                	xor    %edx,%edx
    81df:	90                   	nop
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
    81e0:	80 bc d0 a5 01 00 00 	cmpb   $0x1a,0x1a5(%eax,%edx,8)
    81e7:	1a 
    81e8:	74 0e                	je     81f8 <lteMacCEPhSend+0x28>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    81ea:	83 c2 01             	add    $0x1,%edx
    81ed:	83 fa 08             	cmp    $0x8,%edx
    81f0:	75 ee                	jne    81e0 <lteMacCEPhSend+0x10>
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	FRET(false);
    81f2:	31 c0                	xor    %eax,%eax
}
    81f4:	5d                   	pop    %ebp
    81f5:	c3                   	ret    
    81f6:	66 90                	xchg   %ax,%ax

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    81f8:	0f b6 84 d0 a4 01 00 	movzbl 0x1a4(%eax,%edx,8),%eax
    81ff:	00 
		}
	}
	FRET(false);
}
    8200:	5d                   	pop    %ebp
    8201:	c3                   	ret    
    8202:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    8209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008210 <lteMacCcchSend>:
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    8210:	55                   	push   %ebp
    8211:	89 e5                	mov    %esp,%ebp
    8213:	57                   	push   %edi
    8214:	56                   	push   %esi
    8215:	53                   	push   %ebx
    8216:	83 ec 2c             	sub    $0x2c,%esp
    8219:	e8 fc ff ff ff       	call   821a <lteMacCcchSend+0xa>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    821e:	bf 1f 00 00 00       	mov    $0x1f,%edi
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    8223:	89 45 f0             	mov    %eax,-0x10(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    8226:	b8 0a 00 00 00       	mov    $0xa,%eax
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    822b:	89 55 ec             	mov    %edx,-0x14(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    822e:	e8 fc ff ff ff       	call   822f <lteMacCcchSend+0x1f>
    8233:	89 45 e0             	mov    %eax,-0x20(%ebp)
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
    8236:	b8 01 00 00 00       	mov    $0x1,%eax
    823b:	e8 fc ff ff ff       	call   823c <lteMacCcchSend+0x2c>
    8240:	89 c3                	mov    %eax,%ebx
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    8242:	b8 03 00 00 00       	mov    $0x3,%eax
    8247:	e8 fc ff ff ff       	call   8248 <lteMacCcchSend+0x38>
    824c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    824f:	e8 fc ff ff ff       	call   8250 <lteMacCcchSend+0x40>
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    8254:	31 d2                	xor    %edx,%edx
    8256:	b9 0a 00 00 00       	mov    $0xa,%ecx
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    825b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    825e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8261:	e8 fc ff ff ff       	call   8262 <lteMacCcchSend+0x52>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8266:	31 d2                	xor    %edx,%edx
    8268:	b9 02 00 00 00       	mov    $0x2,%ecx
    826d:	89 d8                	mov    %ebx,%eax
    826f:	e8 fc ff ff ff       	call   8270 <lteMacCcchSend+0x60>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
    8274:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8277:	31 d2                	xor    %edx,%edx
    8279:	b9 03 00 00 00       	mov    $0x3,%ecx
    827e:	e8 fc ff ff ff       	call   827f <lteMacCcchSend+0x6f>
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    8283:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8286:	b9 02 00 00 00       	mov    $0x2,%ecx
    828b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    828e:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    8294:	89 d8                	mov    %ebx,%eax
    8296:	e8 fc ff ff ff       	call   8297 <lteMacCcchSend+0x87>
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    829b:	0f b6 13             	movzbl (%ebx),%edx
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    829e:	21 d7                	and    %edx,%edi
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    82a0:	89 d0                	mov    %edx,%eax
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    82a2:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    82a6:	c0 e8 05             	shr    $0x5,%al
    82a9:	0f b6 f0             	movzbl %al,%esi
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    82ac:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    82b0:	c0 ea 07             	shr    $0x7,%dl
    82b3:	0f b6 d2             	movzbl %dl,%edx
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    82b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
    82ba:	89 55 d8             	mov    %edx,-0x28(%ebp)
    82bd:	89 74 24 04          	mov    %esi,0x4(%esp)
    82c1:	c7 04 24 1c 2a 00 00 	movl   $0x2a1c,(%esp)
    82c8:	e8 fc ff ff ff       	call   82c9 <lteMacCcchSend+0xb9>
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    82cd:	83 fe 01             	cmp    $0x1,%esi
    82d0:	8b 55 d8             	mov    -0x28(%ebp),%edx
	/*for(i=0;i<4;i++){
		fsm_printf("%c,",*(skb->data+i));
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
    82d3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	
	while(continue_flag==1){
    82da:	0f 85 7d 00 00 00    	jne    835d <lteMacCcchSend+0x14d>
		if(lcid==0){								//ccch
    82e0:	85 ff                	test   %edi,%edi
    82e2:	0f 84 ab 00 00 00    	je     8393 <lteMacCcchSend+0x183>
    82e8:	66 31 f6             	xor    %si,%si
    82eb:	31 ff                	xor    %edi,%edi
    82ed:	eb 44                	jmp    8333 <lteMacCcchSend+0x123>
    82ef:	90                   	nop
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    82f0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
    82f4:	83 c6 02             	add    $0x2,%esi
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    82f7:	83 e0 7f             	and    $0x7f,%eax
				offset=offset+sdu_len;
    82fa:	01 c7                	add    %eax,%edi
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    82fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    82ff:	b9 02 00 00 00       	mov    $0x2,%ecx
    8304:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8307:	01 f2                	add    %esi,%edx
    8309:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    830f:	89 d8                	mov    %ebx,%eax
    8311:	e8 fc ff ff ff       	call   8312 <lteMacCcchSend+0x102>
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8316:	0f b6 03             	movzbl (%ebx),%eax
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    8319:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    831d:	89 c1                	mov    %eax,%ecx
				sdu_len=(m_7bit_subhead->m_f_l)&127;
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    831f:	c0 e8 05             	shr    $0x5,%al
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    8322:	83 e1 1f             	and    $0x1f,%ecx
		f_domain=m_7bit_subhead->m_f_l>>7;
    8325:	c0 ea 07             	shr    $0x7,%dl
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    8328:	3c 01                	cmp    $0x1,%al
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    832a:	0f b6 d2             	movzbl %dl,%edx
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    832d:	75 29                	jne    8358 <lteMacCcchSend+0x148>
		if(lcid==0){								//ccch
    832f:	85 c9                	test   %ecx,%ecx
    8331:	74 5d                	je     8390 <lteMacCcchSend+0x180>
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
    8333:	83 fa 01             	cmp    $0x1,%edx
    8336:	75 b8                	jne    82f0 <lteMacCcchSend+0xe0>
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8338:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
    833b:	83 c6 03             	add    $0x3,%esi
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    833e:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			sdu_len=sdu_len<<8;
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    8342:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8346:	83 e0 7f             	and    $0x7f,%eax
			sdu_len=sdu_len<<8;
    8349:	c1 e0 08             	shl    $0x8,%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    834c:	01 d0                	add    %edx,%eax
			offset=offset+sdu_len;
    834e:	01 c7                	add    %eax,%edi
    8350:	eb aa                	jmp    82fc <lteMacCcchSend+0xec>
    8352:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8358:	89 7d dc             	mov    %edi,-0x24(%ebp)
    835b:	89 cf                	mov    %ecx,%edi
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
    835d:	85 ff                	test   %edi,%edi
    835f:	0f 84 c3 01 00 00    	je     8528 <lteMacCcchSend+0x318>
	FIN(lteMacCcchSend());

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
    8365:	be 01 00 00 00       	mov    $0x1,%esi
			skb_len = skb->tail - skb->data;
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
		}
	fsm_mem_free(m_rrc_request);
    836a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    836d:	e8 fc ff ff ff       	call   836e <lteMacCcchSend+0x15e>
	fsm_mem_free(m_7bit_subhead);
    8372:	89 d8                	mov    %ebx,%eax
    8374:	e8 fc ff ff ff       	call   8375 <lteMacCcchSend+0x165>
	fsm_mem_free(m_15bit_subhead);
    8379:	8b 45 e8             	mov    -0x18(%ebp),%eax
    837c:	e8 fc ff ff ff       	call   837d <lteMacCcchSend+0x16d>
	FRET(ccch_or_not);
		//FRET(0);
}
    8381:	89 f0                	mov    %esi,%eax
    8383:	83 c4 2c             	add    $0x2c,%esp
    8386:	5b                   	pop    %ebx
    8387:	5e                   	pop    %esi
    8388:	5f                   	pop    %edi
    8389:	5d                   	pop    %ebp
    838a:	c3                   	ret    
    838b:	90                   	nop
    838c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8390:	89 7d dc             	mov    %edi,-0x24(%ebp)
	while(continue_flag==1){
		if(lcid==0){								//ccch
		    //fsm_printf("There are two SDU from CCCH ,error \n");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8393:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8396:	b9 0a 00 00 00       	mov    $0xa,%ecx
    839b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    839e:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    83a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    83a7:	e8 fc ff ff ff       	call   83a8 <lteMacCcchSend+0x198>
			/*
			SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity)&0x0000ffff;
			SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity&0x000f0000)>>32;
			*/
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    83ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    83af:	b9 05 00 00 00       	mov    $0x5,%ecx
    83b4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    83b7:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    83bd:	83 c6 01             	add    $0x1,%esi
    83c0:	89 f2                	mov    %esi,%edx
    83c2:	e8 fc ff ff ff       	call   83c3 <lteMacCcchSend+0x1b3>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    83c7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    83ca:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    83d0:	8b 00                	mov    (%eax),%eax
    83d2:	c7 04 24 5c 2a 00 00 	movl   $0x2a5c,(%esp)
    83d9:	89 44 24 04          	mov    %eax,0x4(%esp)
    83dd:	e8 fc ff ff ff       	call   83de <lteMacCcchSend+0x1ce>
			
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    83e2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    83e5:	b9 01 00 00 00       	mov    $0x1,%ecx
    83ea:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    83f0:	89 f2                	mov    %esi,%edx
    83f2:	83 c0 04             	add    $0x4,%eax
    83f5:	e8 fc ff ff ff       	call   83f6 <lteMacCcchSend+0x1e6>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    83fa:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    83fd:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8403:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8407:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp)
    840e:	89 44 24 04          	mov    %eax,0x4(%esp)
    8412:	e8 fc ff ff ff       	call   8413 <lteMacCcchSend+0x203>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    8417:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    841a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    841d:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    8423:	8b 41 06             	mov    0x6(%ecx),%eax
    8426:	83 e0 0f             	and    $0xf,%eax
    8429:	66 03 42 04          	add    0x4(%edx),%ax
    842d:	c1 e0 08             	shl    $0x8,%eax
    8430:	66 89 42 04          	mov    %ax,0x4(%edx)
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8434:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8437:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    843d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8441:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp)
    8448:	89 44 24 04          	mov    %eax,0x4(%esp)
    844c:	e8 fc ff ff ff       	call   844d <lteMacCcchSend+0x23d>
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8451:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8454:	b9 0a 00 00 00       	mov    $0xa,%ecx
    8459:	8b 55 dc             	mov    -0x24(%ebp),%edx
    845c:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    8462:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8465:	e8 fc ff ff ff       	call   8466 <lteMacCcchSend+0x256>
			//fsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);

			//SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity.randomValue)&0x0000ffff;	//randomValue32
			//SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity.randomValue&0x000f0000)>>32;	//randomValue33~40
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    846a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    846d:	b9 05 00 00 00       	mov    $0x5,%ecx
    8472:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8478:	89 f2                	mov    %esi,%edx
    847a:	e8 fc ff ff ff       	call   847b <lteMacCcchSend+0x26b>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    847f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    8482:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8488:	8b 00                	mov    (%eax),%eax
    848a:	c7 04 24 5c 2a 00 00 	movl   $0x2a5c,(%esp)
    8491:	89 44 24 04          	mov    %eax,0x4(%esp)
    8495:	e8 fc ff ff ff       	call   8496 <lteMacCcchSend+0x286>
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
    849a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    849d:	b9 02 00 00 00       	mov    $0x2,%ecx
    84a2:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    84a8:	31 d2                	xor    %edx,%edx
    84aa:	83 c0 04             	add    $0x4,%eax
    84ad:	e8 fc ff ff ff       	call   84ae <lteMacCcchSend+0x29e>
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    84b2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    84b5:	89 f2                	mov    %esi,%edx
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
    84b7:	31 f6                	xor    %esi,%esi
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    84b9:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    84bf:	b9 01 00 00 00       	mov    $0x1,%ecx
    84c4:	83 c0 04             	add    $0x4,%eax
    84c7:	e8 fc ff ff ff       	call   84c8 <lteMacCcchSend+0x2b8>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    84cc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    84cf:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    84d5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    84d9:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp)
    84e0:	89 44 24 04          	mov    %eax,0x4(%esp)
    84e4:	e8 fc ff ff ff       	call   84e5 <lteMacCcchSend+0x2d5>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    84e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    84ec:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    84ef:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    84f5:	8b 41 06             	mov    0x6(%ecx),%eax
    84f8:	83 e0 0f             	and    $0xf,%eax
    84fb:	66 03 42 04          	add    0x4(%edx),%ax
    84ff:	c1 e0 08             	shl    $0x8,%eax
    8502:	66 89 42 04          	mov    %ax,0x4(%edx)
			//fsm_printf("[MAC CCCHSEND]%d\n",m_rrc_request->establishmentCause);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8506:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8509:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    850f:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8513:	c7 04 24 80 2a 00 00 	movl   $0x2a80,(%esp)
    851a:	89 44 24 04          	mov    %eax,0x4(%esp)
    851e:	e8 fc ff ff ff       	call   851f <lteMacCcchSend+0x30f>
    8523:	e9 42 fe ff ff       	jmp    836a <lteMacCcchSend+0x15a>
    8528:	8b 45 e0             	mov    -0x20(%ebp),%eax
    852b:	8d 70 01             	lea    0x1(%eax),%esi
    852e:	e9 1e ff ff ff       	jmp    8451 <lteMacCcchSend+0x241>
    8533:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008540 <setMACtoRLC_IciMsg>:
 * @function: fill in the ICI from MAC to RLC
 * @param ici_msg: the structure of the ICI
 * @param pbch: the channel that carries the PDU
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
    8540:	55                   	push   %ebp
    8541:	89 e5                	mov    %esp,%ebp
    8543:	83 ec 0c             	sub    $0xc,%esp
    8546:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8549:	89 75 f8             	mov    %esi,-0x8(%ebp)
    854c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    854f:	e8 fc ff ff ff       	call   8550 <setMACtoRLC_IciMsg+0x10>
    8554:	89 c3                	mov    %eax,%ebx
    8556:	89 d6                	mov    %edx,%esi
    8558:	89 cf                	mov    %ecx,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    855a:	e8 fc ff ff ff       	call   855b <setMACtoRLC_IciMsg+0x1b>
	ici_msg->lcid=lcid;
    855f:	89 fa                	mov    %edi,%edx
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8561:	8b 7d fc             	mov    -0x4(%ebp),%edi
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
    8564:	89 73 02             	mov    %esi,0x2(%ebx)
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8567:	8b 75 f8             	mov    -0x8(%ebp),%esi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    856a:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    856d:	0f b7 00             	movzwl (%eax),%eax
    8570:	66 89 03             	mov    %ax,(%ebx)
	FOUT;
}
    8573:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    8576:	89 ec                	mov    %ebp,%esp
    8578:	5d                   	pop    %ebp
    8579:	c3                   	ret    
    857a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008580 <setMACtoPHY_IciMsg>:
	SV(sys_frame).subframeNo=0;
		
	//
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
    8580:	55                   	push   %ebp
    8581:	89 e5                	mov    %esp,%ebp
    8583:	83 ec 0c             	sub    $0xc,%esp
    8586:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8589:	89 75 f8             	mov    %esi,-0x8(%ebp)
    858c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    858f:	e8 fc ff ff ff       	call   8590 <setMACtoPHY_IciMsg+0x10>
    8594:	89 d6                	mov    %edx,%esi
    8596:	89 cf                	mov    %ecx,%edi
    8598:	89 c3                	mov    %eax,%ebx
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
    859a:	e8 fc ff ff ff       	call   859b <setMACtoPHY_IciMsg+0x1b>
	ici_msg->tcid=tcid;
    859f:	89 f2                	mov    %esi,%edx
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    85a1:	66 85 ff             	test   %di,%di
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
	ici_msg->tcid=tcid;
    85a4:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    85a7:	75 0c                	jne    85b5 <setMACtoPHY_IciMsg+0x35>
    85a9:	0f b7 38             	movzwl (%eax),%edi
    85ac:	66 85 ff             	test   %di,%di
    85af:	75 04                	jne    85b5 <setMACtoPHY_IciMsg+0x35>
    85b1:	0f b7 78 02          	movzwl 0x2(%eax),%edi
    85b5:	66 89 7b 04          	mov    %di,0x4(%ebx)

	ici_msg->frameNo=SV(sys_frame).frameNo;
    85b9:	0f b7 50 06          	movzwl 0x6(%eax),%edx
    85bd:	66 89 13             	mov    %dx,(%ebx)
	ici_msg->subframeNo=SV(sys_frame).subframeNo;
    85c0:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    85c4:	66 89 53 02          	mov    %dx,0x2(%ebx)
	SV(sys_frame).frameNo=0;
    85c8:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
	SV(sys_frame).subframeNo=0;
    85ce:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		
	//
	FOUT;
}
    85d4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    85d7:	8b 75 f8             	mov    -0x8(%ebp),%esi
    85da:	8b 7d fc             	mov    -0x4(%ebp),%edi
    85dd:	89 ec                	mov    %ebp,%esp
    85df:	5d                   	pop    %ebp
    85e0:	c3                   	ret    
    85e1:	eb 0d                	jmp    85f0 <lteMacCEBSRSend>
    85e3:	90                   	nop
    85e4:	90                   	nop
    85e5:	90                   	nop
    85e6:	90                   	nop
    85e7:	90                   	nop
    85e8:	90                   	nop
    85e9:	90                   	nop
    85ea:	90                   	nop
    85eb:	90                   	nop
    85ec:	90                   	nop
    85ed:	90                   	nop
    85ee:	90                   	nop
    85ef:	90                   	nop

000085f0 <lteMacCEBSRSend>:
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    85f0:	55                   	push   %ebp
    85f1:	89 e5                	mov    %esp,%ebp
    85f3:	57                   	push   %edi
    85f4:	56                   	push   %esi
    85f5:	53                   	push   %ebx
    85f6:	83 ec 08             	sub    $0x8,%esp
    85f9:	e8 fc ff ff ff       	call   85fa <lteMacCEBSRSend+0xa>
    85fe:	89 c7                	mov    %eax,%edi
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    8600:	b8 1a 00 00 00       	mov    $0x1a,%eax
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    8605:	89 55 f0             	mov    %edx,-0x10(%ebp)
    8608:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    860b:	e8 fc ff ff ff       	call   860c <lteMacCEBSRSend+0x1c>
    8610:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
    8612:	e8 fc ff ff ff       	call   8613 <lteMacCEBSRSend+0x23>

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8617:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    861c:	31 d2                	xor    %edx,%edx
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);
    861e:	89 c3                	mov    %eax,%ebx

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8620:	89 f0                	mov    %esi,%eax
    8622:	e8 fc ff ff ff       	call   8623 <lteMacCEBSRSend+0x33>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8627:	31 c0                	xor    %eax,%eax
    8629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
    8630:	0f b6 94 c3 a5 01 00 	movzbl 0x1a5(%ebx,%eax,8),%edx
    8637:	00 
    8638:	80 fa 1d             	cmp    $0x1d,%dl
    863b:	74 2b                	je     8668 <lteMacCEBSRSend+0x78>
					*lcg_id=0;
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
    863d:	80 fa 1e             	cmp    $0x1e,%dl
    8640:	0f 84 92 00 00 00    	je     86d8 <lteMacCEBSRSend+0xe8>
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8646:	83 c0 01             	add    $0x1,%eax
    8649:	83 f8 08             	cmp    $0x8,%eax
    864c:	75 e2                	jne    8630 <lteMacCEBSRSend+0x40>
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    864e:	89 f0                	mov    %esi,%eax
	FRET(0);
    8650:	31 db                	xor    %ebx,%ebx
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    8652:	e8 fc ff ff ff       	call   8653 <lteMacCEBSRSend+0x63>
	FRET(0);
}
    8657:	89 d8                	mov    %ebx,%eax
    8659:	83 c4 08             	add    $0x8,%esp
    865c:	5b                   	pop    %ebx
    865d:	5e                   	pop    %esi
    865e:	5f                   	pop    %edi
    865f:	5d                   	pop    %ebp
    8660:	c3                   	ret    
    8661:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8668:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    866f:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    8674:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    8676:	31 db                	xor    %ebx,%ebx
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8678:	e8 fc ff ff ff       	call   8679 <lteMacCEBSRSend+0x89>
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    867d:	8b 46 06             	mov    0x6(%esi),%eax
    8680:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8683:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8685:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8688:	31 c0                	xor    %eax,%eax
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
    868a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    868e:	85 c9                	test   %ecx,%ecx
    8690:	74 36                	je     86c8 <lteMacCEBSRSend+0xd8>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8692:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8694:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
					lcg_numb++;
    8698:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    869b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    869e:	83 fb 01             	cmp    $0x1,%ebx
    86a1:	76 06                	jbe    86a9 <lteMacCEBSRSend+0xb9>
					*lcg_id=0;
    86a3:	c7 07 00 00 00 00    	movl   $0x0,(%edi)

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    86a9:	83 c0 01             	add    $0x1,%eax
    86ac:	83 f8 04             	cmp    $0x4,%eax
    86af:	75 d9                	jne    868a <lteMacCEBSRSend+0x9a>
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
    86b1:	89 f0                	mov    %esi,%eax
    86b3:	e8 fc ff ff ff       	call   86b4 <lteMacCEBSRSend+0xc4>
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
	FRET(0);
}
    86b8:	83 c4 08             	add    $0x8,%esp
    86bb:	89 d8                	mov    %ebx,%eax
    86bd:	5b                   	pop    %ebx
    86be:	5e                   	pop    %esi
    86bf:	5f                   	pop    %edi
    86c0:	5d                   	pop    %ebp
    86c1:	c3                   	ret    
    86c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    86c8:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    86cf:	eb cd                	jmp    869e <lteMacCEBSRSend+0xae>
    86d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    86d8:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    86df:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    86e4:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    86e6:	31 db                	xor    %ebx,%ebx
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    86e8:	e8 fc ff ff ff       	call   86e9 <lteMacCEBSRSend+0xf9>
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    86ed:	8b 46 06             	mov    0x6(%esi),%eax
    86f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    86f3:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    86f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    86f8:	31 c0                	xor    %eax,%eax
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
    86fa:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    86fe:	85 c9                	test   %ecx,%ecx
    8700:	74 36                	je     8738 <lteMacCEBSRSend+0x148>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8702:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8704:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
					lcg_numb++;
    8708:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    870b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    870e:	83 fb 01             	cmp    $0x1,%ebx
    8711:	76 06                	jbe    8719 <lteMacCEBSRSend+0x129>
					*lcg_id=0;
    8713:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8719:	83 c0 01             	add    $0x1,%eax
    871c:	83 f8 04             	cmp    $0x4,%eax
    871f:	75 d9                	jne    86fa <lteMacCEBSRSend+0x10a>
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8721:	8b 55 f0             	mov    -0x10(%ebp),%edx
			fsm_mem_free(m_bsr_infor);
    8724:	89 f0                	mov    %esi,%eax
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8726:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			fsm_mem_free(m_bsr_infor);
    872c:	e8 fc ff ff ff       	call   872d <lteMacCEBSRSend+0x13d>
    8731:	eb 85                	jmp    86b8 <lteMacCEBSRSend+0xc8>
    8733:	90                   	nop
    8734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    8738:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    873f:	eb cd                	jmp    870e <lteMacCEBSRSend+0x11e>
    8741:	eb 0d                	jmp    8750 <lteMacGetDlHeadLength>
    8743:	90                   	nop
    8744:	90                   	nop
    8745:	90                   	nop
    8746:	90                   	nop
    8747:	90                   	nop
    8748:	90                   	nop
    8749:	90                   	nop
    874a:	90                   	nop
    874b:	90                   	nop
    874c:	90                   	nop
    874d:	90                   	nop
    874e:	90                   	nop
    874f:	90                   	nop

00008750 <lteMacGetDlHeadLength>:
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8750:	55                   	push   %ebp
    8751:	89 e5                	mov    %esp,%ebp
    8753:	57                   	push   %edi
    8754:	56                   	push   %esi
    8755:	53                   	push   %ebx
    8756:	83 ec 1c             	sub    $0x1c,%esp
    8759:	e8 fc ff ff ff       	call   875a <lteMacGetDlHeadLength+0xa>
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
    875e:	31 db                	xor    %ebx,%ebx
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8760:	89 c7                	mov    %eax,%edi
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    8762:	b8 03 00 00 00       	mov    $0x3,%eax
    8767:	e8 fc ff ff ff       	call   8768 <lteMacGetDlHeadLength+0x18>
    876c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
    876f:	b8 01 00 00 00       	mov    $0x1,%eax
    8774:	e8 fc ff ff ff       	call   8775 <lteMacGetDlHeadLength+0x25>
    8779:	89 c6                	mov    %eax,%esi
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    877b:	b8 02 00 00 00       	mov    $0x2,%eax
    8780:	e8 fc ff ff ff       	call   8781 <lteMacGetDlHeadLength+0x31>

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8785:	31 d2                	xor    %edx,%edx
    8787:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    878c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    878f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8792:	e8 fc ff ff ff       	call   8793 <lteMacGetDlHeadLength+0x43>
	fsm_mem_set(fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8797:	31 d2                	xor    %edx,%edx
    8799:	b9 01 00 00 00       	mov    $0x1,%ecx
    879e:	89 f0                	mov    %esi,%eax
    87a0:	e8 fc ff ff ff       	call   87a1 <lteMacGetDlHeadLength+0x51>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    87a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87a8:	31 d2                	xor    %edx,%edx
    87aa:	b9 02 00 00 00       	mov    $0x2,%ecx
    87af:	e8 fc ff ff ff       	call   87b0 <lteMacGetDlHeadLength+0x60>
	
	last_len=sizeof(MAC_SDU_subhead_last);
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
    87b4:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    87ba:	b9 01 00 00 00       	mov    $0x1,%ecx
    87bf:	89 f0                	mov    %esi,%eax
    87c1:	e8 fc ff ff ff       	call   87c2 <lteMacGetDlHeadLength+0x72>
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
    87c6:	0f b6 16             	movzbl (%esi),%edx
    87c9:	89 d0                	mov    %edx,%eax
    87cb:	c0 e8 05             	shr    $0x5,%al
	//20140626
	while(m_e==1){		//
    87ce:	3c 01                	cmp    $0x1,%al
    87d0:	74 50                	je     8822 <lteMacGetDlHeadLength+0xd2>
    87d2:	e9 89 00 00 00       	jmp    8860 <lteMacGetDlHeadLength+0x110>
    87d7:	90                   	nop
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
		switch(m_lcid){
    87d8:	83 fa 1c             	cmp    $0x1c,%edx
    87db:	74 7b                	je     8858 <lteMacGetDlHeadLength+0x108>
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
			break;
		default:
			fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    87dd:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    87e3:	b9 02 00 00 00       	mov    $0x2,%ecx
    87e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87eb:	01 da                	add    %ebx,%edx
    87ed:	e8 fc ff ff ff       	call   87ee <lteMacGetDlHeadLength+0x9e>
			m_f=m_7bit_subhead->m_f_l>>7;
			if(m_f==1){
				from_len=from_len+subhead_15bit_len;
    87f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    87f5:	8d 43 03             	lea    0x3(%ebx),%eax
    87f8:	83 c3 02             	add    $0x2,%ebx
    87fb:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    87ff:	0f 48 d8             	cmovs  %eax,%ebx
			else{
				from_len=from_len+subhead_7bit_len;
			}
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
    8802:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    8808:	b9 01 00 00 00       	mov    $0x1,%ecx
    880d:	89 f0                	mov    %esi,%eax
    880f:	01 da                	add    %ebx,%edx
    8811:	e8 fc ff ff ff       	call   8812 <lteMacGetDlHeadLength+0xc2>
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
    8816:	0f b6 16             	movzbl (%esi),%edx
    8819:	89 d0                	mov    %edx,%eax
    881b:	c0 e8 05             	shr    $0x5,%al
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
	//20140626
	while(m_e==1){		//
    881e:	3c 01                	cmp    $0x1,%al
    8820:	75 3e                	jne    8860 <lteMacGetDlHeadLength+0x110>
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8822:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8825:	89 54 24 04          	mov    %edx,0x4(%esp)
    8829:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    882c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    8830:	c7 04 24 a4 2a 00 00 	movl   $0x2aa4,(%esp)
    8837:	e8 fc ff ff ff       	call   8838 <lteMacGetDlHeadLength+0xe8>
		
		switch(m_lcid){
    883c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    883f:	83 fa 1d             	cmp    $0x1d,%edx
    8842:	74 14                	je     8858 <lteMacGetDlHeadLength+0x108>
    8844:	76 92                	jbe    87d8 <lteMacGetDlHeadLength+0x88>
    8846:	83 fa 1e             	cmp    $0x1e,%edx
    8849:	74 0d                	je     8858 <lteMacGetDlHeadLength+0x108>
    884b:	83 fa 1f             	cmp    $0x1f,%edx
    884e:	66 90                	xchg   %ax,%ax
    8850:	75 8b                	jne    87dd <lteMacGetDlHeadLength+0x8d>
    8852:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			break;
		case TIMING_ADVANCE_LCID :
			from_len=from_len+last_len;
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
    8858:	83 c3 01             	add    $0x1,%ebx
			break;
    885b:	eb a5                	jmp    8802 <lteMacGetDlHeadLength+0xb2>
    885d:	8d 76 00             	lea    0x0(%esi),%esi
			break;
		}
		fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8860:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8863:	89 54 24 04          	mov    %edx,0x4(%esp)
    8867:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    886a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    886e:	c7 04 24 a4 2a 00 00 	movl   $0x2aa4,(%esp)
    8875:	e8 fc ff ff ff       	call   8876 <lteMacGetDlHeadLength+0x126>
		
	switch(m_lcid){		//while
    887a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		break;
	case DRX_LCID :
		from_len=from_len+last_len;
		break;
	case TIMING_ADVANCE_LCID :
		from_len=from_len+last_len;
    887d:	8d 43 01             	lea    0x1(%ebx),%eax
    8880:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    8883:	83 fa 1d             	cmp    $0x1d,%edx
    8886:	74 10                	je     8898 <lteMacGetDlHeadLength+0x148>
    8888:	76 36                	jbe    88c0 <lteMacGetDlHeadLength+0x170>
    888a:	83 fa 1e             	cmp    $0x1e,%edx
    888d:	74 09                	je     8898 <lteMacGetDlHeadLength+0x148>
    888f:	83 fa 1f             	cmp    $0x1f,%edx
    8892:	75 31                	jne    88c5 <lteMacGetDlHeadLength+0x175>
    8894:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
			from_len=from_len+subhead_7bit_len;
		}
		break;
	}
	fsm_mem_free(m_15bit_subhead);
    8898:	8b 45 ec             	mov    -0x14(%ebp),%eax
    889b:	e8 fc ff ff ff       	call   889c <lteMacGetDlHeadLength+0x14c>
	fsm_mem_free(fixed_subhead);
    88a0:	89 f0                	mov    %esi,%eax
    88a2:	e8 fc ff ff ff       	call   88a3 <lteMacGetDlHeadLength+0x153>
	fsm_mem_free(m_7bit_subhead);
    88a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88aa:	e8 fc ff ff ff       	call   88ab <lteMacGetDlHeadLength+0x15b>
	FRET(from_len);
}
    88af:	8b 45 e8             	mov    -0x18(%ebp),%eax
    88b2:	83 c4 1c             	add    $0x1c,%esp
    88b5:	5b                   	pop    %ebx
    88b6:	5e                   	pop    %esi
    88b7:	5f                   	pop    %edi
    88b8:	5d                   	pop    %ebp
    88b9:	c3                   	ret    
    88ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    88c0:	83 fa 1c             	cmp    $0x1c,%edx
    88c3:	74 d3                	je     8898 <lteMacGetDlHeadLength+0x148>
		break;
	case CONTENTION_RESOLUTION_LCID :
		from_len=from_len+last_len;
		break;
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    88c5:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    88cb:	b9 02 00 00 00       	mov    $0x2,%ecx
    88d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88d3:	01 da                	add    %ebx,%edx
    88d5:	e8 fc ff ff ff       	call   88d6 <lteMacGetDlHeadLength+0x186>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
    88da:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88dd:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    88e1:	78 14                	js     88f7 <lteMacGetDlHeadLength+0x1a7>
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_7bit_len;
    88e3:	83 c3 02             	add    $0x2,%ebx
		
			from_len=from_len+subhead_15bit_len;
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
    88e6:	c7 04 24 1a 05 00 00 	movl   $0x51a,(%esp)
    88ed:	e8 fc ff ff ff       	call   88ee <lteMacGetDlHeadLength+0x19e>
		
			from_len=from_len+subhead_7bit_len;
    88f2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    88f5:	eb a1                	jmp    8898 <lteMacGetDlHeadLength+0x148>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_15bit_len;
    88f7:	83 c3 03             	add    $0x3,%ebx
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
    88fa:	c7 04 24 e0 2a 00 00 	movl   $0x2ae0,(%esp)
    8901:	e8 fc ff ff ff       	call   8902 <lteMacGetDlHeadLength+0x1b2>
		
			from_len=from_len+subhead_15bit_len;
    8906:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    8909:	eb 8d                	jmp    8898 <lteMacGetDlHeadLength+0x148>
    890b:	90                   	nop
    890c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00008910 <Pdcch_c_rnti>:
/**
 * @function: exclude the information in PCH, BCCH in the decomplexing to offer the result whether the MSG4 is successful
 * @param c_rnti: rnti in the PHY-T-MAC-ICI
 */

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
    8910:	55                   	push   %ebp
    8911:	89 e5                	mov    %esp,%ebp
    8913:	53                   	push   %ebx
    8914:	e8 fc ff ff ff       	call   8915 <Pdcch_c_rnti+0x5>
    8919:	89 c3                	mov    %eax,%ebx
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
    891b:	e8 fc ff ff ff       	call   891c <Pdcch_c_rnti+0xc>
	if(SV(sendmsg3)==1){//msg3
    8920:	83 b8 ec 01 00 00 01 	cmpl   $0x1,0x1ec(%eax)
    8927:	74 0f                	je     8938 <Pdcch_c_rnti+0x28>
			fsm_schedule_self(0, ContentionResolution_Fail );//3
			//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution fail\n");
		}
	}
	else
		SV(pdcch_rnti)=0;
    8929:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    8930:	00 00 00 
	FOUT;
}
    8933:	5b                   	pop    %ebx
    8934:	5d                   	pop    %ebp
    8935:	c3                   	ret    
    8936:	66 90                	xchg   %ax,%ax

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8938:	0f b7 10             	movzwl (%eax),%edx
    893b:	66 39 da             	cmp    %bx,%dx
    893e:	74 20                	je     8960 <Pdcch_c_rnti+0x50>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
				//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution successfully\n");
			}				
		}
		else if ((c_rnti !=SV(C_RNTI)) && SV(C_RNTI)!=0){//PDCCHCRNTI
    8940:	66 85 d2             	test   %dx,%dx
    8943:	74 ee                	je     8933 <Pdcch_c_rnti+0x23>
			SV(pdcch_rnti)=0;//0
    8945:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    894c:	00 00 00 
			fsm_schedule_self(0, ContentionResolution_Fail );//3
    894f:	ba 05 00 00 00       	mov    $0x5,%edx
    8954:	31 c0                	xor    %eax,%eax
    8956:	e8 fc ff ff ff       	call   8957 <Pdcch_c_rnti+0x47>
    895b:	eb d6                	jmp    8933 <Pdcch_c_rnti+0x23>
    895d:	8d 76 00             	lea    0x0(%esi),%esi

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8960:	66 85 d2             	test   %dx,%dx
    8963:	74 ce                	je     8933 <Pdcch_c_rnti+0x23>
		{
			SV(pdcch_rnti)=1;//1
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8965:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
		{
			SV(pdcch_rnti)=1;//1
    896c:	c7 80 f0 01 00 00 01 	movl   $0x1,0x1f0(%eax)
    8973:	00 00 00 
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8976:	74 bb                	je     8933 <Pdcch_c_rnti+0x23>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
    8978:	ba 06 00 00 00       	mov    $0x6,%edx
    897d:	31 c0                	xor    %eax,%eax
    897f:	e8 fc ff ff ff       	call   8980 <Pdcch_c_rnti+0x70>
    8984:	eb ad                	jmp    8933 <Pdcch_c_rnti+0x23>
    8986:	8d 76 00             	lea    0x0(%esi),%esi
    8989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008990 <compare>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
    8990:	55                   	push   %ebp
    8991:	89 e5                	mov    %esp,%ebp
    8993:	e8 fc ff ff ff       	call   8994 <compare+0x4>
	u32 ret=first<second?0:1;
	return ret;
}
    8998:	5d                   	pop    %ebp
/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
	u32 ret=first<second?0:1;
    8999:	39 d0                	cmp    %edx,%eax
    899b:	0f 93 c0             	setae  %al
    899e:	0f b6 c0             	movzbl %al,%eax
	return ret;
}
    89a1:	c3                   	ret    
    89a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    89a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000089b0 <decomplexUeRARPdu>:
/**
 * @function: decomplex RAR PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
 void decomplexUeRARPdu(FSM_PKT *skb)
{
    89b0:	55                   	push   %ebp
    89b1:	89 e5                	mov    %esp,%ebp
    89b3:	56                   	push   %esi
    89b4:	53                   	push   %ebx
    89b5:	83 ec 18             	sub    $0x18,%esp
    89b8:	e8 fc ff ff ff       	call   89b9 <decomplexUeRARPdu+0x9>
    89bd:	89 c3                	mov    %eax,%ebx
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    89bf:	e8 fc ff ff ff       	call   89c0 <decomplexUeRARPdu+0x10>

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    89c4:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
{
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    89ca:	89 c6                	mov    %eax,%esi

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    89cc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    89d2:	29 d0                	sub    %edx,%eax
    89d4:	83 f8 06             	cmp    $0x6,%eax
    89d7:	0f 86 98 01 00 00    	jbe    8b75 <decomplexUeRARPdu+0x1c5>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    89dd:	b9 07 00 00 00       	mov    $0x7,%ecx
    89e2:	8d 45 f1             	lea    -0xf(%ebp),%eax
    89e5:	e8 fc ff ff ff       	call   89e6 <decomplexUeRARPdu+0x36>
	if(m_phy_ici.tcid==BCH){
    89ea:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    89ee:	3c 01                	cmp    $0x1,%al
    89f0:	0f 84 ca 00 00 00    	je     8ac0 <decomplexUeRARPdu+0x110>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    89f6:	84 c0                	test   %al,%al
    89f8:	74 0e                	je     8a08 <decomplexUeRARPdu+0x58>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    89fa:	3c 02                	cmp    $0x2,%al
    89fc:	74 72                	je     8a70 <decomplexUeRARPdu+0xc0>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    89fe:	83 c4 18             	add    $0x18,%esp
    8a01:	5b                   	pop    %ebx
    8a02:	5e                   	pop    %esi
    8a03:	5d                   	pop    %ebp
    8a04:	c3                   	ret    
    8a05:	8d 76 00             	lea    0x0(%esi),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8a08:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    8a0f:	e8 fc ff ff ff       	call   8a10 <decomplexUeRARPdu+0x60>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8a14:	e8 fc ff ff ff       	call   8a15 <decomplexUeRARPdu+0x65>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a19:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8a1f:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    8a23:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8a2a:	0f b7 00             	movzwl (%eax),%eax
    8a2d:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8a31:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8a37:	29 c2                	sub    %eax,%edx
    8a39:	83 fa 06             	cmp    $0x6,%edx
    8a3c:	0f 86 52 01 00 00    	jbe    8b94 <decomplexUeRARPdu+0x1e4>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8a42:	8d 55 ea             	lea    -0x16(%ebp),%edx
    8a45:	b9 07 00 00 00       	mov    $0x7,%ecx
    8a4a:	e8 fc ff ff ff       	call   8a4b <decomplexUeRARPdu+0x9b>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8a4f:	31 c0                	xor    %eax,%eax
    8a51:	e8 fc ff ff ff       	call   8a52 <decomplexUeRARPdu+0xa2>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8a56:	8b 43 50             	mov    0x50(%ebx),%eax
    8a59:	c7 04 24 00 2b 00 00 	movl   $0x2b00,(%esp)
    8a60:	89 44 24 04          	mov    %eax,0x4(%esp)
    8a64:	e8 fc ff ff ff       	call   8a65 <decomplexUeRARPdu+0xb5>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    8a69:	83 c4 18             	add    $0x18,%esp
    8a6c:	5b                   	pop    %ebx
    8a6d:	5e                   	pop    %esi
    8a6e:	5d                   	pop    %ebp
    8a6f:	c3                   	ret    
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code
    8a70:	c7 04 24 24 2b 00 00 	movl   $0x2b24,(%esp)
    8a77:	e8 fc ff ff ff       	call   8a78 <decomplexUeRARPdu+0xc8>

		if(!compare(skb->tail-skb->data,len)){
    8a7c:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8a82:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8a88:	83 f8 06             	cmp    $0x6,%eax
    8a8b:	0f 86 22 01 00 00    	jbe    8bb3 <decomplexUeRARPdu+0x203>
			fsm_pkt_destroy(skb);
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
    8a91:	80 be 98 01 00 00 00 	cmpb   $0x0,0x198(%esi)
    8a98:	0f 85 82 00 00 00    	jne    8b20 <decomplexUeRARPdu+0x170>
					fsm_schedule_self(0,RandomAcc_Fail);
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
				} 
		}
		else { //RAR
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test	
    8a9e:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		}
		fsm_pkt_destroy(skb);//
    8aa5:	89 d8                	mov    %ebx,%eax
    8aa7:	e8 fc ff ff ff       	call   8aa8 <decomplexUeRARPdu+0xf8>
		//printk("ue mac_pkthandler 796\n");
		fsm_printf("decomplex for RAR function done\n");//testing code
    8aac:	c7 04 24 88 2b 00 00 	movl   $0x2b88,(%esp)
    8ab3:	e8 fc ff ff ff       	call   8ab4 <decomplexUeRARPdu+0x104>
			
		FOUT;
	}
		
}
    8ab8:	83 c4 18             	add    $0x18,%esp
    8abb:	5b                   	pop    %ebx
    8abc:	5e                   	pop    %esi
    8abd:	5d                   	pop    %ebp
    8abe:	c3                   	ret    
    8abf:	90                   	nop
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8ac0:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    8ac7:	e8 fc ff ff ff       	call   8ac8 <decomplexUeRARPdu+0x118>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8acc:	e8 fc ff ff ff       	call   8acd <decomplexUeRARPdu+0x11d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8ad1:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8ad7:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    8adb:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8ae2:	0f b7 00             	movzwl (%eax),%eax
    8ae5:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8ae9:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8aef:	29 c2                	sub    %eax,%edx
    8af1:	83 fa 06             	cmp    $0x6,%edx
    8af4:	0f 87 48 ff ff ff    	ja     8a42 <decomplexUeRARPdu+0x92>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8afa:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8b01:	89 d8                	mov    %ebx,%eax
    8b03:	e8 fc ff ff ff       	call   8b04 <decomplexUeRARPdu+0x154>
			printk("ue mac_pkthandler 715\n");
    8b08:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    8b0f:	e8 fc ff ff ff       	call   8b10 <decomplexUeRARPdu+0x160>
			FOUT;
    8b14:	e9 e5 fe ff ff       	jmp    89fe <decomplexUeRARPdu+0x4e>
    8b19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    8b20:	8b 86 94 01 00 00    	mov    0x194(%esi),%eax
    8b26:	e8 fc ff ff ff       	call   8b27 <decomplexUeRARPdu+0x177>
				SV(WaitforRAresponseTimer.flag)=false;
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    8b2b:	89 d8                	mov    %ebx,%eax
			FOUT;
		}
		
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
				SV(WaitforRAresponseTimer.flag)=false;
    8b2d:	c6 86 98 01 00 00 00 	movb   $0x0,0x198(%esi)
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
    8b34:	c7 86 94 01 00 00 00 	movl   $0x0,0x194(%esi)
    8b3b:	00 00 00 
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    8b3e:	e8 fc ff ff ff       	call   8b3f <decomplexUeRARPdu+0x18f>
    8b43:	84 c0                	test   %al,%al
    8b45:	74 11                	je     8b58 <decomplexUeRARPdu+0x1a8>
					fsm_schedule_self(0,RARrev_Success);
    8b47:	ba 04 00 00 00       	mov    $0x4,%edx
    8b4c:	31 c0                	xor    %eax,%eax
    8b4e:	e8 fc ff ff ff       	call   8b4f <decomplexUeRARPdu+0x19f>
    8b53:	e9 4d ff ff ff       	jmp    8aa5 <decomplexUeRARPdu+0xf5>
				else{
					fsm_schedule_self(0,RandomAcc_Fail);
    8b58:	ba 03 00 00 00       	mov    $0x3,%edx
    8b5d:	31 c0                	xor    %eax,%eax
    8b5f:	e8 fc ff ff ff       	call   8b60 <decomplexUeRARPdu+0x1b0>
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
    8b64:	c7 04 24 54 2b 00 00 	movl   $0x2b54,(%esp)
    8b6b:	e8 fc ff ff ff       	call   8b6c <decomplexUeRARPdu+0x1bc>
    8b70:	e9 30 ff ff ff       	jmp    8aa5 <decomplexUeRARPdu+0xf5>
	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8b75:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		fsm_pkt_destroy(skb);
    8b7c:	89 d8                	mov    %ebx,%eax
    8b7e:	e8 fc ff ff ff       	call   8b7f <decomplexUeRARPdu+0x1cf>
		printk("ue mac_pkthandler 701\n");
    8b83:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    8b8a:	e8 fc ff ff ff       	call   8b8b <decomplexUeRARPdu+0x1db>
		FOUT;
    8b8f:	e9 6a fe ff ff       	jmp    89fe <decomplexUeRARPdu+0x4e>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8b94:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8b9b:	89 d8                	mov    %ebx,%eax
    8b9d:	e8 fc ff ff ff       	call   8b9e <decomplexUeRARPdu+0x1ee>
			printk("ue mac_pkthandler 740\n");
    8ba2:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    8ba9:	e8 fc ff ff ff       	call   8baa <decomplexUeRARPdu+0x1fa>
			FOUT;
    8bae:	e9 4b fe ff ff       	jmp    89fe <decomplexUeRARPdu+0x4e>
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("[decomplexUeRARPdu]recieve DLSCH data packet, \n");//testing code

		if(!compare(skb->tail-skb->data,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8bb3:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8bba:	89 d8                	mov    %ebx,%eax
    8bbc:	e8 fc ff ff ff       	call   8bbd <decomplexUeRARPdu+0x20d>
			printk("ue mac_pkthandler 767\n");
    8bc1:	c7 04 24 b1 05 00 00 	movl   $0x5b1,(%esp)
    8bc8:	e8 fc ff ff ff       	call   8bc9 <decomplexUeRARPdu+0x219>
			FOUT;
    8bcd:	e9 2c fe ff ff       	jmp    89fe <decomplexUeRARPdu+0x4e>
    8bd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    8bd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008be0 <decomplexUeDataPdu>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
void decomplexUeDataPdu(FSM_PKT *skb){		//  
    8be0:	55                   	push   %ebp
    8be1:	89 e5                	mov    %esp,%ebp
    8be3:	57                   	push   %edi
    8be4:	56                   	push   %esi
    8be5:	53                   	push   %ebx
    8be6:	83 ec 54             	sub    $0x54,%esp
    8be9:	e8 fc ff ff ff       	call   8bea <decomplexUeDataPdu+0xa>
    8bee:	89 c3                	mov    %eax,%ebx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    8bf0:	e8 fc ff ff ff       	call   8bf1 <decomplexUeDataPdu+0x11>

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8bf5:	31 d2                	xor    %edx,%edx
    8bf7:	b9 03 00 00 00       	mov    $0x3,%ecx
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	//char *pdu_type=(char*)fsm_mem_alloc(sizeof(char));  //pdu_type : 0 -> Common Data PDU ; 1~3 -> RAR PDU

	SV_PTR_GET(rlc_mac_sv);
    8bfc:	89 45 b8             	mov    %eax,-0x48(%ebp)

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8bff:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8c02:	e8 fc ff ff ff       	call   8c03 <decomplexUeDataPdu+0x23>
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8c07:	31 d2                	xor    %edx,%edx
    8c09:	b9 01 00 00 00       	mov    $0x1,%ecx
    8c0e:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8c11:	e8 fc ff ff ff       	call   8c12 <decomplexUeDataPdu+0x32>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8c16:	31 d2                	xor    %edx,%edx
    8c18:	b9 02 00 00 00       	mov    $0x2,%ecx
    8c1d:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8c20:	e8 fc ff ff ff       	call   8c21 <decomplexUeDataPdu+0x41>
	fsm_mem_set(&m_content_resolution,0,sizeof(MAC_CE_content_resolution_identity));	//20140430
    8c25:	31 d2                	xor    %edx,%edx
    8c27:	b9 06 00 00 00       	mov    $0x6,%ecx
    8c2c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    8c2f:	e8 fc ff ff ff       	call   8c30 <decomplexUeDataPdu+0x50>
	fsm_mem_set(&m_time_advance,0,sizeof(MAC_CE_time_advance));	//20140430
    8c34:	31 d2                	xor    %edx,%edx
    8c36:	b9 01 00 00 00       	mov    $0x1,%ecx
    8c3b:	8d 45 f3             	lea    -0xd(%ebp),%eax
    8c3e:	e8 fc ff ff ff       	call   8c3f <decomplexUeDataPdu+0x5f>
	fsm_mem_set(&m_rlc_type2_icimsg,0,sizeof(MACtoRLC_IciMsg));	//20140430
    8c43:	31 d2                	xor    %edx,%edx
    8c45:	b9 07 00 00 00       	mov    $0x7,%ecx
    8c4a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    8c4d:	e8 fc ff ff ff       	call   8c4e <decomplexUeDataPdu+0x6e>
	fsm_mem_set(&m_padding_subhead,0,sizeof(MAC_SH_padding));	//20140430
    8c52:	31 d2                	xor    %edx,%edx
    8c54:	b9 01 00 00 00       	mov    $0x1,%ecx
    8c59:	8d 45 f2             	lea    -0xe(%ebp),%eax
    8c5c:	e8 fc ff ff ff       	call   8c5d <decomplexUeDataPdu+0x7d>
	fsm_mem_set(&m_phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    8c61:	31 d2                	xor    %edx,%edx
    8c63:	b9 07 00 00 00       	mov    $0x7,%ecx
    8c68:	8d 45 df             	lea    -0x21(%ebp),%eax
    8c6b:	e8 fc ff ff ff       	call   8c6c <decomplexUeDataPdu+0x8c>
    //PHYICI  HQ 20140502

	/*
	 * for test
	 */
	SV(pkt_num_downlink)=SV(pkt_num_downlink)+1;
    8c70:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8c73:	83 80 10 02 00 00 01 	addl   $0x1,0x210(%eax)


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    8c7a:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    8c80:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8c86:	29 d0                	sub    %edx,%eax
    8c88:	83 f8 06             	cmp    $0x6,%eax
    8c8b:	0f 86 6c 06 00 00    	jbe    92fd <decomplexUeDataPdu+0x71d>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    8c91:	b9 07 00 00 00       	mov    $0x7,%ecx
    8c96:	8d 45 df             	lea    -0x21(%ebp),%eax
    8c99:	e8 fc ff ff ff       	call   8c9a <decomplexUeDataPdu+0xba>
	if(m_phy_ici.tcid==BCH){
    8c9e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
    8ca2:	3c 01                	cmp    $0x1,%al
    8ca4:	0f 84 a6 00 00 00    	je     8d50 <decomplexUeDataPdu+0x170>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    8caa:	84 c0                	test   %al,%al
    8cac:	74 32                	je     8ce0 <decomplexUeDataPdu+0x100>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    8cae:	3c 02                	cmp    $0x2,%al
    8cb0:	0f 84 f2 00 00 00    	je     8da8 <decomplexUeDataPdu+0x1c8>
	
	/*
	 * for test
	 */
	 else{
	 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    8cb6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8cb9:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
    8cc0:	89 d8                	mov    %ebx,%eax
    8cc2:	e8 fc ff ff ff       	call   8cc3 <decomplexUeDataPdu+0xe3>
   	fsm_printf("decomplex function done\n");//testing code
    8cc7:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    8cce:	e8 fc ff ff ff       	call   8ccf <decomplexUeDataPdu+0xef>
	FOUT;
}
    8cd3:	83 c4 54             	add    $0x54,%esp
    8cd6:	5b                   	pop    %ebx
    8cd7:	5e                   	pop    %esi
    8cd8:	5f                   	pop    %edi
    8cd9:	5d                   	pop    %ebp
    8cda:	c3                   	ret    
    8cdb:	90                   	nop
    8cdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8ce0:	c7 04 24 80 05 00 00 	movl   $0x580,(%esp)
    8ce7:	e8 fc ff ff ff       	call   8ce8 <decomplexUeDataPdu+0x108>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8cec:	e8 fc ff ff ff       	call   8ced <decomplexUeDataPdu+0x10d>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8cf1:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8cf7:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8cfb:	c7 45 da 01 00 00 00 	movl   $0x1,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8d02:	0f b7 00             	movzwl (%eax),%eax
    8d05:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8d09:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8d0f:	29 c2                	sub    %eax,%edx
    8d11:	83 fa 06             	cmp    $0x6,%edx
    8d14:	0f 86 99 06 00 00    	jbe    93b3 <decomplexUeDataPdu+0x7d3>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8d1a:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8d1d:	b9 07 00 00 00       	mov    $0x7,%ecx
    8d22:	e8 fc ff ff ff       	call   8d23 <decomplexUeDataPdu+0x143>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(skb);  //add in 20150804
    8d27:	89 d8                	mov    %ebx,%eax
    8d29:	e8 fc ff ff ff       	call   8d2a <decomplexUeDataPdu+0x14a>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8d2e:	8b 43 50             	mov    0x50(%ebx),%eax
    8d31:	c7 04 24 00 2b 00 00 	movl   $0x2b00,(%esp)
    8d38:	89 44 24 04          	mov    %eax,0x4(%esp)
    8d3c:	e8 fc ff ff ff       	call   8d3d <decomplexUeDataPdu+0x15d>
	 }
	//fsm_mem_free(pdu_type);
   	fsm_pkt_destroy(skb);
   	fsm_printf("decomplex function done\n");//testing code
	FOUT;
}
    8d41:	83 c4 54             	add    $0x54,%esp
    8d44:	5b                   	pop    %ebx
    8d45:	5e                   	pop    %esi
    8d46:	5f                   	pop    %edi
    8d47:	5d                   	pop    %ebp
    8d48:	c3                   	ret    
    8d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8d50:	c7 04 24 4f 05 00 00 	movl   $0x54f,(%esp)
    8d57:	e8 fc ff ff ff       	call   8d58 <decomplexUeDataPdu+0x178>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8d5c:	e8 fc ff ff ff       	call   8d5d <decomplexUeDataPdu+0x17d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8d61:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8d67:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8d6b:	c7 45 da 02 00 00 00 	movl   $0x2,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8d72:	0f b7 00             	movzwl (%eax),%eax
    8d75:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8d79:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8d7f:	29 c2                	sub    %eax,%edx
    8d81:	83 fa 06             	cmp    $0x6,%edx
    8d84:	77 94                	ja     8d1a <decomplexUeDataPdu+0x13a>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8d86:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8d89:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    8d90:	89 d8                	mov    %ebx,%eax
    8d92:	e8 fc ff ff ff       	call   8d93 <decomplexUeDataPdu+0x1b3>
			printk("ue mac_pkthandler 715\n");
    8d97:	c7 04 24 69 05 00 00 	movl   $0x569,(%esp)
    8d9e:	e8 fc ff ff ff       	call   8d9f <decomplexUeDataPdu+0x1bf>
			FOUT;
    8da3:	e9 2b ff ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8da8:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)


		//fsm_mem_cpy(&m_type,skb->data,len);//  HQ 20140502;delete m_type in 20160222
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
    8daf:	31 f6                	xor    %esi,%esi
			//fsm_mem_free(pdu_type);
			//printk("[UE MAC ]mac_pkthandler decomplexUeDataPdu: This is a RAR PDU ,Error!!!\n");
			//FOUT;
		//}
		/**************************/
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8db1:	e8 fc ff ff ff       	call   8db2 <decomplexUeDataPdu+0x1d2>
		//len=sizeof(char);
		len=0;	//modify by lxr in 20160225
		head_len=lteMacGetDlHeadLength(skb);	//SDU
    8db6:	89 d8                	mov    %ebx,%eax
    8db8:	e8 fc ff ff ff       	call   8db9 <decomplexUeDataPdu+0x1d9>
    8dbd:	89 45 d0             	mov    %eax,-0x30(%ebp)
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
    8dc0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
    8dc4:	e8 fc ff ff ff       	call   8dc5 <decomplexUeDataPdu+0x1e5>
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
    8dc9:	c7 04 24 e5 05 00 00 	movl   $0x5e5,(%esp)
    8dd0:	e8 fc ff ff ff       	call   8dd1 <decomplexUeDataPdu+0x1f1>
    8dd5:	8d 76 00             	lea    0x0(%esi),%esi
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
    8dd8:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8dde:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8de4:	29 d0                	sub    %edx,%eax
    8de6:	39 c6                	cmp    %eax,%esi
    8de8:	0f 84 65 04 00 00    	je     9253 <decomplexUeDataPdu+0x673>
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8dee:	01 f2                	add    %esi,%edx
    8df0:	b9 01 00 00 00       	mov    $0x1,%ecx
    8df5:	8d 45 f2             	lea    -0xe(%ebp),%eax
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8df8:	bf 1f 00 00 00       	mov    $0x1f,%edi
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8dfd:	e8 fc ff ff ff       	call   8dfe <decomplexUeDataPdu+0x21e>
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8e02:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
    8e06:	89 c2                	mov    %eax,%edx
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8e08:	21 c7                	and    %eax,%edi
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8e0a:	c0 ea 05             	shr    $0x5,%dl
    8e0d:	88 55 d4             	mov    %dl,-0x2c(%ebp)
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
    8e10:	89 7c 24 04          	mov    %edi,0x4(%esp)
    8e14:	c7 04 24 18 06 00 00 	movl   $0x618,(%esp)
    8e1b:	e8 fc ff ff ff       	call   8e1c <decomplexUeDataPdu+0x23c>
				switch(lcid){
    8e20:	83 ff 1d             	cmp    $0x1d,%edi
    8e23:	0f 84 67 03 00 00    	je     9190 <decomplexUeDataPdu+0x5b0>
    8e29:	0f 87 11 02 00 00    	ja     9040 <decomplexUeDataPdu+0x460>
    8e2f:	83 ff 1c             	cmp    $0x1c,%edi
    8e32:	0f 84 28 02 00 00    	je     9060 <decomplexUeDataPdu+0x480>
						break;
					
				}		
			}			
		
			if(lcid>=0&&lcid<11){
    8e38:	83 ff 0a             	cmp    $0xa,%edi
    8e3b:	90                   	nop
    8e3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8e40:	0f 87 fb 04 00 00    	ja     9341 <decomplexUeDataPdu+0x761>
    8e46:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    8e49:	e9 ff 00 00 00       	jmp    8f4d <decomplexUeDataPdu+0x36d>
    8e4e:	66 90                	xchg   %ax,%ax
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8e50:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8e56:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8e5c:	29 d0                	sub    %edx,%eax
    8e5e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8e61:	83 f8 02             	cmp    $0x2,%eax
    8e64:	0f 86 2d 04 00 00    	jbe    9297 <decomplexUeDataPdu+0x6b7>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 954\n");
							FOUT;
						}

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
    8e6a:	03 55 d4             	add    -0x2c(%ebp),%edx
    8e6d:	b9 03 00 00 00       	mov    $0x3,%ecx
    8e72:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8e75:	e8 fc ff ff ff       	call   8e76 <decomplexUeDataPdu+0x296>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8e7a:	e8 fc ff ff ff       	call   8e7b <decomplexUeDataPdu+0x29b>
	ici_msg->lcid=lcid;
    8e7f:	89 f2                	mov    %esi,%edx

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8e81:	0f b6 7d ee          	movzbl -0x12(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8e85:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8e88:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8e8f:	0f b7 00             	movzwl (%eax),%eax
    8e92:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
    8e96:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    8e9a:	83 e0 7f             	and    $0x7f,%eax
						sdu_len=sdu_len<<8;
    8e9d:	c1 e0 08             	shl    $0x8,%eax
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8ea0:	01 c7                	add    %eax,%edi
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8ea2:	8d 47 11             	lea    0x11(%edi),%eax
    8ea5:	e8 fc ff ff ff       	call   8ea6 <decomplexUeDataPdu+0x2c6>
						fsm_skb_reserve(newskb,sdu_len);
    8eaa:	89 fa                	mov    %edi,%edx
						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8eac:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8eae:	e8 fc ff ff ff       	call   8eaf <decomplexUeDataPdu+0x2cf>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
    8eb3:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8eb9:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    8ebf:	29 c2                	sub    %eax,%edx
    8ec1:	83 fa 06             	cmp    $0x6,%edx
    8ec4:	0f 86 ab 03 00 00    	jbe    9275 <decomplexUeDataPdu+0x695>
							printk("ue mac_pkthandler 976\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
    8eca:	b9 07 00 00 00       	mov    $0x7,%ecx
    8ecf:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8ed2:	e8 fc ff ff ff       	call   8ed3 <decomplexUeDataPdu+0x2f3>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8ed7:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8edd:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8ee3:	39 c7                	cmp    %eax,%edi
    8ee5:	0f 87 24 03 00 00    	ja     920f <decomplexUeDataPdu+0x62f>
    8eeb:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8ef1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8ef7:	29 d0                	sub    %edx,%eax
    8ef9:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8efc:	39 c7                	cmp    %eax,%edi
    8efe:	0f 87 0b 03 00 00    	ja     920f <decomplexUeDataPdu+0x62f>

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;
    8f04:	83 45 d4 03          	addl   $0x3,-0x2c(%ebp)
							printk("ue mac_pkthandler 1026\n");
							FOUT;
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
    8f08:	03 55 d0             	add    -0x30(%ebp),%edx
    8f0b:	89 f0                	mov    %esi,%eax
    8f0d:	89 55 bc             	mov    %edx,-0x44(%ebp)
    8f10:	89 fa                	mov    %edi,%edx
    8f12:	e8 fc ff ff ff       	call   8f13 <decomplexUeDataPdu+0x333>
    8f17:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8f1a:	89 f9                	mov    %edi,%ecx
    8f1c:	e8 fc ff ff ff       	call   8f1d <decomplexUeDataPdu+0x33d>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8f21:	89 f0                	mov    %esi,%eax
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
    8f23:	01 7d d0             	add    %edi,-0x30(%ebp)
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8f26:	e8 fc ff ff ff       	call   8f27 <decomplexUeDataPdu+0x347>
						//fsm_pkt_send(newskb,STRM_TO_IPADP);

						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
    8f2b:	8b 46 50             	mov    0x50(%esi),%eax
    8f2e:	c7 04 24 00 2b 00 00 	movl   $0x2b00,(%esp)
    8f35:	89 44 24 04          	mov    %eax,0x4(%esp)
    8f39:	e8 fc ff ff ff       	call   8f3a <decomplexUeDataPdu+0x35a>
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8f3e:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
    8f42:	c0 e8 05             	shr    $0x5,%al
				}		
			}			
		
			if(lcid>=0&&lcid<11){
				continue_flag=1;
				while(continue_flag==1){
    8f45:	3c 01                	cmp    $0x1,%al
    8f47:	0f 85 73 fd ff ff    	jne    8cc0 <decomplexUeDataPdu+0xe0>
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
    8f4d:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8f53:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8f59:	29 d0                	sub    %edx,%eax
    8f5b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8f5e:	83 f8 01             	cmp    $0x1,%eax
    8f61:	0f 86 ca 02 00 00    	jbe    9231 <decomplexUeDataPdu+0x651>
						fsm_pkt_destroy(skb);
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
    8f67:	03 55 d4             	add    -0x2c(%ebp),%edx
    8f6a:	b9 02 00 00 00       	mov    $0x2,%ecx
    8f6f:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8f72:	e8 fc ff ff ff       	call   8f73 <decomplexUeDataPdu+0x393>
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8f77:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8f7b:	89 d0                	mov    %edx,%eax
    8f7d:	83 e0 1f             	and    $0x1f,%eax
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8f80:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8f84:	89 c6                	mov    %eax,%esi
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8f86:	88 55 c0             	mov    %dl,-0x40(%ebp)
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8f89:	0f 88 c1 fe ff ff    	js     8e50 <decomplexUeDataPdu+0x270>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8f8f:	e8 fc ff ff ff       	call   8f90 <decomplexUeDataPdu+0x3b0>
	ici_msg->lcid=lcid;
    8f94:	89 f2                	mov    %esi,%edx
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8f96:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8f9a:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8f9d:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
    8fa4:	83 45 d4 02          	addl   $0x2,-0x2c(%ebp)
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8fa8:	83 e7 7f             	and    $0x7f,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    8fab:	0f b7 00             	movzwl (%eax),%eax
    8fae:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8fb2:	8d 47 11             	lea    0x11(%edi),%eax
    8fb5:	e8 fc ff ff ff       	call   8fb6 <decomplexUeDataPdu+0x3d6>
						fsm_skb_reserve(newskb,sdu_len);
    8fba:	89 fa                	mov    %edi,%edx
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8fbc:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8fbe:	e8 fc ff ff ff       	call   8fbf <decomplexUeDataPdu+0x3df>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8fc3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8fc9:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8fcf:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8fd2:	83 f8 06             	cmp    $0x6,%eax
    8fd5:	0f 86 de 02 00 00    	jbe    92b9 <decomplexUeDataPdu+0x6d9>
							printk("ue mac_pkthandler 1015\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);
    8fdb:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8fe1:	b9 07 00 00 00       	mov    $0x7,%ecx
    8fe6:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8fe9:	e8 fc ff ff ff       	call   8fea <decomplexUeDataPdu+0x40a>


						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8fee:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8ff4:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8ffa:	39 c7                	cmp    %eax,%edi
    8ffc:	77 19                	ja     9017 <decomplexUeDataPdu+0x437>
    8ffe:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9004:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    900a:	29 d0                	sub    %edx,%eax
    900c:	2b 45 d0             	sub    -0x30(%ebp),%eax
    900f:	39 c7                	cmp    %eax,%edi
    9011:	0f 86 f1 fe ff ff    	jbe    8f08 <decomplexUeDataPdu+0x328>
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9017:	8b 45 b8             	mov    -0x48(%ebp),%eax
    901a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9021:	89 d8                	mov    %ebx,%eax
    9023:	e8 fc ff ff ff       	call   9024 <decomplexUeDataPdu+0x444>
							printk("ue mac_pkthandler 1026\n");
    9028:	c7 04 24 f9 06 00 00 	movl   $0x6f9,(%esp)
    902f:	e8 fc ff ff ff       	call   9030 <decomplexUeDataPdu+0x450>
							FOUT;
    9034:	e9 9a fc ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
    9039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
    9040:	83 ff 1e             	cmp    $0x1e,%edi
    9043:	74 09                	je     904e <decomplexUeDataPdu+0x46e>
    9045:	83 ff 1f             	cmp    $0x1f,%edi
    9048:	0f 85 ea fd ff ff    	jne    8e38 <decomplexUeDataPdu+0x258>
					case DRX_LCID:
						from_len=from_len+len;
						break;
					case PADDING_LCID:
						padding_flag=1;
						from_len=from_len+len;
    904e:	83 c6 01             	add    $0x1,%esi
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122

			Pdcch_c_rnti(m_phy_ici.rnti);
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
			while(continue_flag==1)
    9051:	80 7d d4 01          	cmpb   $0x1,-0x2c(%ebp)
    9055:	0f 84 7d fd ff ff    	je     8dd8 <decomplexUeDataPdu+0x1f8>
    905b:	e9 d8 fd ff ff       	jmp    8e38 <decomplexUeDataPdu+0x258>
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
					case CONTENTION_RESOLUTION_LCID:	//20140428 
						if(SV(CRTimer.flag)==true){  // 	
    9060:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9063:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
    906a:	74 e5                	je     9051 <decomplexUeDataPdu+0x471>
							fsm_schedule_cancel(SV(CRTimer.timer_sign));  //CR  HQ 20140424
    906c:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    9072:	e8 fc ff ff ff       	call   9073 <decomplexUeDataPdu+0x493>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
    9077:	8b 45 b8             	mov    -0x48(%ebp),%eax
    907a:	c6 80 74 01 00 00 00 	movb   $0x0,0x174(%eax)
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
    9081:	c7 80 70 01 00 00 00 	movl   $0x0,0x170(%eax)
    9088:	00 00 00 
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
    908b:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9091:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9097:	29 d0                	sub    %edx,%eax
    9099:	39 c6                	cmp    %eax,%esi
    909b:	0f 84 f0 02 00 00    	je     9391 <decomplexUeDataPdu+0x7b1>
								printk("ue mac_pkthandler 834\n");
								FOUT;
							}


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
    90a1:	01 f2                	add    %esi,%edx
    90a3:	b9 01 00 00 00       	mov    $0x1,%ecx
    90a8:	8d 45 f1             	lea    -0xf(%ebp),%eax
    90ab:	e8 fc ff ff ff       	call   90ac <decomplexUeDataPdu+0x4cc>
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);
    90b0:	89 74 24 04          	mov    %esi,0x4(%esp)
    90b4:	c7 04 24 ac 2b 00 00 	movl   $0x2bac,(%esp)
    90bb:	e8 fc ff ff ff       	call   90bc <decomplexUeDataPdu+0x4dc>

							from_len=from_len+len;
							len=sizeof(MAC_CE_content_resolution_identity);
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
    90c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    90c3:	c7 04 24 e0 2b 00 00 	movl   $0x2be0,(%esp)
    90ca:	89 44 24 04          	mov    %eax,0x4(%esp)
    90ce:	e8 fc ff ff ff       	call   90cf <decomplexUeDataPdu+0x4ef>
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
    90d3:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    90d9:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    90df:	29 d0                	sub    %edx,%eax
    90e1:	2b 45 d0             	sub    -0x30(%ebp),%eax
    90e4:	83 f8 05             	cmp    $0x5,%eax
    90e7:	0f 86 82 02 00 00    	jbe    936f <decomplexUeDataPdu+0x78f>
								fsm_pkt_destroy(skb);
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
    90ed:	03 55 d0             	add    -0x30(%ebp),%edx
    90f0:	b9 06 00 00 00       	mov    $0x6,%ecx
    90f5:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    90f8:	e8 fc ff ff ff       	call   90f9 <decomplexUeDataPdu+0x519>
							part1=m_content_resolution.m_resolusion_identity_1;
							part2=m_content_resolution.m_resolusion_identity_2;
    90fd:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
							part1=m_content_resolution.m_resolusion_identity_1;
    9101:	8b 4d e6             	mov    -0x1a(%ebp),%ecx
							part2=m_content_resolution.m_resolusion_identity_2;
    9104:	66 89 55 c0          	mov    %dx,-0x40(%ebp)

							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);
    9108:	8b 55 b8             	mov    -0x48(%ebp),%edx
    910b:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    9111:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    9115:	89 54 24 10          	mov    %edx,0x10(%esp)
    9119:	8b 00                	mov    (%eax),%eax
    911b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    911f:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
    9122:	c7 04 24 10 2c 00 00 	movl   $0x2c10,(%esp)
    9129:	89 44 24 0c          	mov    %eax,0xc(%esp)
    912d:	0f bf 45 c0          	movswl -0x40(%ebp),%eax
    9131:	89 44 24 08          	mov    %eax,0x8(%esp)
    9135:	e8 fc ff ff ff       	call   9136 <decomplexUeDataPdu+0x556>

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
    913a:	8b 55 b8             	mov    -0x48(%ebp),%edx
    913d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    9140:	8b 82 00 02 00 00    	mov    0x200(%edx),%eax
    9146:	85 c0                	test   %eax,%eax
    9148:	74 11                	je     915b <decomplexUeDataPdu+0x57b>
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    914a:	83 e8 01             	sub    $0x1,%eax
								part1=0;//
    914d:	31 c9                	xor    %ecx,%ecx
							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    914f:	89 82 00 02 00 00    	mov    %eax,0x200(%edx)
								part1=0;//
								part2=0;
    9155:	66 c7 45 c0 00 00    	movw   $0x0,-0x40(%ebp)
							}
							/*********************************/

							if(part1==SV(m_temp_cr)->m_part_1&&part2==SV(m_temp_cr)->m_part_2){
    915b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    915e:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    9164:	39 08                	cmp    %ecx,(%eax)
    9166:	0f 85 88 00 00 00    	jne    91f4 <decomplexUeDataPdu+0x614>
    916c:	0f bf 55 c0          	movswl -0x40(%ebp),%edx
    9170:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    9174:	39 c2                	cmp    %eax,%edx
    9176:	75 7c                	jne    91f4 <decomplexUeDataPdu+0x614>
							//	SV(contention_resolution_flag)=true;	//flag
								fsm_schedule_self(0, Contention_Success);
    9178:	ba 06 00 00 00       	mov    $0x6,%edx
    917d:	31 c0                	xor    %eax,%eax
    917f:	e8 fc ff ff ff       	call   9180 <decomplexUeDataPdu+0x5a0>


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);

							from_len=from_len+len;
    9184:	83 c6 01             	add    $0x1,%esi
								
								fsm_schedule_self(0, ContentionResolution_Fail);
								
								FOUT; 
							}
							head_len=head_len+len;
    9187:	83 45 d0 06          	addl   $0x6,-0x30(%ebp)
    918b:	e9 c1 fe ff ff       	jmp    9051 <decomplexUeDataPdu+0x471>
						}
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
    9190:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9196:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    919c:	29 d0                	sub    %edx,%eax
    919e:	39 c6                	cmp    %eax,%esi
    91a0:	0f 84 35 01 00 00    	je     92db <decomplexUeDataPdu+0x6fb>
							printk("ue mac_pkthandler 896\n");
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
    91a6:	01 f2                	add    %esi,%edx
    91a8:	b9 01 00 00 00       	mov    $0x1,%ecx
    91ad:	8d 45 f1             	lea    -0xf(%ebp),%eax
    91b0:	e8 fc ff ff ff       	call   91b1 <decomplexUeDataPdu+0x5d1>
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
    91b5:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    91bb:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    91c1:	29 d0                	sub    %edx,%eax
    91c3:	39 45 d0             	cmp    %eax,-0x30(%ebp)
    91c6:	0f 84 53 01 00 00    	je     931f <decomplexUeDataPdu+0x73f>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    91cc:	03 55 d0             	add    -0x30(%ebp),%edx
    91cf:	b9 01 00 00 00       	mov    $0x1,%ecx
    91d4:	8d 45 f3             	lea    -0xd(%ebp),%eax
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
    91d7:	83 c6 01             	add    $0x1,%esi
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    91da:	e8 fc ff ff ff       	call   91db <decomplexUeDataPdu+0x5fb>
						head_len=head_len+len;
						timing=(m_time_advance.m_r_r_command)&63;
    91df:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
						head_len=head_len+len;
    91e3:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
						timing=(m_time_advance.m_r_r_command)&63;

						MACCETA_handle(timing);
    91e7:	83 e0 3f             	and    $0x3f,%eax
    91ea:	e8 fc ff ff ff       	call   91eb <decomplexUeDataPdu+0x60b>
						break;
    91ef:	e9 5d fe ff ff       	jmp    9051 <decomplexUeDataPdu+0x471>
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    91f4:	8b 45 b8             	mov    -0x48(%ebp),%eax
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    91f7:	ba 05 00 00 00       	mov    $0x5,%edx
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    91fc:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    9203:	31 c0                	xor    %eax,%eax
    9205:	e8 fc ff ff ff       	call   9206 <decomplexUeDataPdu+0x626>
								
								FOUT; 
    920a:	e9 c4 fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>

						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    920f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9212:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9219:	89 d8                	mov    %ebx,%eax
    921b:	e8 fc ff ff ff       	call   921c <decomplexUeDataPdu+0x63c>
							printk("ue mac_pkthandler 987\n");
    9220:	c7 04 24 ca 06 00 00 	movl   $0x6ca,(%esp)
    9227:	e8 fc ff ff ff       	call   9228 <decomplexUeDataPdu+0x648>
							FOUT;
    922c:	e9 a2 fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
				continue_flag=1;
				while(continue_flag==1){
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
						SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9231:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9234:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
						fsm_pkt_destroy(skb);
    923b:	89 d8                	mov    %ebx,%eax
    923d:	e8 fc ff ff ff       	call   923e <decomplexUeDataPdu+0x65e>
						printk("ue mac_pkthandler 940\n");
    9242:	c7 04 24 85 06 00 00 	movl   $0x685,(%esp)
    9249:	e8 fc ff ff ff       	call   924a <decomplexUeDataPdu+0x66a>
						FOUT;
    924e:	e9 80 fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
					SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9253:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9256:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
					fsm_pkt_destroy(skb);
    925d:	89 d8                	mov    %ebx,%eax
    925f:	e8 fc ff ff ff       	call   9260 <decomplexUeDataPdu+0x680>
					printk("ue mac_pkthandler 814\n");
    9264:	c7 04 24 01 06 00 00 	movl   $0x601,(%esp)
    926b:	e8 fc ff ff ff       	call   926c <decomplexUeDataPdu+0x68c>
					FOUT;
    9270:	e9 5e fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9275:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9278:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    927f:	89 d8                	mov    %ebx,%eax
    9281:	e8 fc ff ff ff       	call   9282 <decomplexUeDataPdu+0x6a2>
							printk("ue mac_pkthandler 976\n");
    9286:	c7 04 24 b3 06 00 00 	movl   $0x6b3,(%esp)
    928d:	e8 fc ff ff ff       	call   928e <decomplexUeDataPdu+0x6ae>
							FOUT;
    9292:	e9 3c fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9297:	8b 45 b8             	mov    -0x48(%ebp),%eax
    929a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    92a1:	89 d8                	mov    %ebx,%eax
    92a3:	e8 fc ff ff ff       	call   92a4 <decomplexUeDataPdu+0x6c4>
							printk("ue mac_pkthandler 954\n");
    92a8:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    92af:	e8 fc ff ff ff       	call   92b0 <decomplexUeDataPdu+0x6d0>
							FOUT;
    92b4:	e9 1a fa ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    92b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    92bc:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    92c3:	89 d8                	mov    %ebx,%eax
    92c5:	e8 fc ff ff ff       	call   92c6 <decomplexUeDataPdu+0x6e6>
							printk("ue mac_pkthandler 1015\n");
    92ca:	c7 04 24 e1 06 00 00 	movl   $0x6e1,(%esp)
    92d1:	e8 fc ff ff ff       	call   92d2 <decomplexUeDataPdu+0x6f2>
							FOUT;
    92d6:	e9 f8 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    92db:	8b 45 b8             	mov    -0x48(%ebp),%eax
    92de:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    92e5:	89 d8                	mov    %ebx,%eax
    92e7:	e8 fc ff ff ff       	call   92e8 <decomplexUeDataPdu+0x708>
							printk("ue mac_pkthandler 896\n");
    92ec:	c7 04 24 57 06 00 00 	movl   $0x657,(%esp)
    92f3:	e8 fc ff ff ff       	call   92f4 <decomplexUeDataPdu+0x714>
							FOUT;
    92f8:	e9 d6 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    92fd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9300:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
		fsm_pkt_destroy(skb);
    9307:	89 d8                	mov    %ebx,%eax
    9309:	e8 fc ff ff ff       	call   930a <decomplexUeDataPdu+0x72a>
		printk("ue mac_pkthandler 701\n");
    930e:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    9315:	e8 fc ff ff ff       	call   9316 <decomplexUeDataPdu+0x736>
		FOUT;
    931a:	e9 b4 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    931f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9322:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9329:	89 d8                	mov    %ebx,%eax
    932b:	e8 fc ff ff ff       	call   932c <decomplexUeDataPdu+0x74c>
							printk("ue mac_pkthandler 908\n");
    9330:	c7 04 24 6e 06 00 00 	movl   $0x66e,(%esp)
    9337:	e8 fc ff ff ff       	call   9338 <decomplexUeDataPdu+0x758>
							FOUT;
    933c:	e9 92 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
			
			/*
			 * for test
			 */
			 else{
			 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    9341:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9344:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			 	
			 	fsm_pkt_destroy(skb);
    934b:	89 d8                	mov    %ebx,%eax
    934d:	e8 fc ff ff ff       	call   934e <decomplexUeDataPdu+0x76e>
			 	printk("ue mac_pkthandler 1052\n");
    9352:	c7 04 24 11 07 00 00 	movl   $0x711,(%esp)
    9359:	e8 fc ff ff ff       	call   935a <decomplexUeDataPdu+0x77a>
   				fsm_printf("decomplex function done\n");//testing code
    935e:	c7 04 24 29 07 00 00 	movl   $0x729,(%esp)
    9365:	e8 fc ff ff ff       	call   9366 <decomplexUeDataPdu+0x786>
				FOUT;
    936a:	e9 64 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    936f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9372:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    9379:	89 d8                	mov    %ebx,%eax
    937b:	e8 fc ff ff ff       	call   937c <decomplexUeDataPdu+0x79c>
								printk("ue mac_pkthandler 851\n");
    9380:	c7 04 24 40 06 00 00 	movl   $0x640,(%esp)
    9387:	e8 fc ff ff ff       	call   9388 <decomplexUeDataPdu+0x7a8>
								FOUT;
    938c:	e9 42 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9391:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9394:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    939b:	89 d8                	mov    %ebx,%eax
    939d:	e8 fc ff ff ff       	call   939e <decomplexUeDataPdu+0x7be>
								printk("ue mac_pkthandler 834\n");
    93a2:	c7 04 24 29 06 00 00 	movl   $0x629,(%esp)
    93a9:	e8 fc ff ff ff       	call   93aa <decomplexUeDataPdu+0x7ca>
								FOUT;
    93ae:	e9 20 f9 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    93b3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    93b6:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    93bd:	89 d8                	mov    %ebx,%eax
    93bf:	e8 fc ff ff ff       	call   93c0 <decomplexUeDataPdu+0x7e0>
			printk("ue mac_pkthandler 740\n");
    93c4:	c7 04 24 9a 05 00 00 	movl   $0x59a,(%esp)
    93cb:	e8 fc ff ff ff       	call   93cc <decomplexUeDataPdu+0x7ec>
			FOUT;
    93d0:	e9 fe f8 ff ff       	jmp    8cd3 <decomplexUeDataPdu+0xf3>
    93d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    93d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000093e0 <clean_CE_tags>:
}	//ICI()
	
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
    93e0:	55                   	push   %ebp
    93e1:	89 e5                	mov    %esp,%ebp
    93e3:	56                   	push   %esi
    93e4:	53                   	push   %ebx
    93e5:	e8 fc ff ff ff       	call   93e6 <clean_CE_tags+0x6>
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    93ea:	31 db                	xor    %ebx,%ebx
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
    93ec:	e8 fc ff ff ff       	call   93ed <clean_CE_tags+0xd>
    93f1:	89 c6                	mov    %eax,%esi
    93f3:	90                   	nop
    93f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    93f8:	8d 84 de a4 01 00 00 	lea    0x1a4(%esi,%ebx,8),%eax
    93ff:	31 d2                	xor    %edx,%edx
    9401:	b9 08 00 00 00       	mov    $0x8,%ecx
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    9406:	83 c3 01             	add    $0x1,%ebx
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    9409:	e8 fc ff ff ff       	call   940a <clean_CE_tags+0x2a>
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    940e:	83 fb 08             	cmp    $0x8,%ebx
    9411:	75 e5                	jne    93f8 <clean_CE_tags+0x18>
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
	FOUT;
}
    9413:	5b                   	pop    %ebx
    9414:	5e                   	pop    %esi
    9415:	5d                   	pop    %ebp
    9416:	c3                   	ret    
    9417:	89 f6                	mov    %esi,%esi
    9419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009420 <complexUeMacPdu>:

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9420:	55                   	push   %ebp
    9421:	89 e5                	mov    %esp,%ebp
    9423:	57                   	push   %edi
    9424:	56                   	push   %esi
    9425:	53                   	push   %ebx
    9426:	83 ec 70             	sub    $0x70,%esp
    9429:	e8 fc ff ff ff       	call   942a <complexUeMacPdu+0xa>
    942e:	89 c3                	mov    %eax,%ebx
	u32 bsr_flag;	//bsr
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
    9430:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    9437:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    943e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    9445:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    944c:	e8 fc ff ff ff       	call   944d <complexUeMacPdu+0x2d>

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    9451:	31 d2                	xor    %edx,%edx
    9453:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    9458:	89 c6                	mov    %eax,%esi

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    945a:	8d 45 f1             	lea    -0xf(%ebp),%eax
    945d:	e8 fc ff ff ff       	call   945e <complexUeMacPdu+0x3e>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));		//20140430
    9462:	31 d2                	xor    %edx,%edx
    9464:	b9 02 00 00 00       	mov    $0x2,%ecx
    9469:	8d 45 ed             	lea    -0x13(%ebp),%eax
    946c:	e8 fc ff ff ff       	call   946d <complexUeMacPdu+0x4d>
	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));		//20140430
    9471:	31 d2                	xor    %edx,%edx
    9473:	b9 03 00 00 00       	mov    $0x3,%ecx
    9478:	8d 45 e7             	lea    -0x19(%ebp),%eax
    947b:	e8 fc ff ff ff       	call   947c <complexUeMacPdu+0x5c>
	fsm_mem_set(&m_crnti,0,sizeof(MAC_CE_Crnti));		//20140430
    9480:	31 d2                	xor    %edx,%edx
    9482:	b9 02 00 00 00       	mov    $0x2,%ecx
    9487:	8d 45 ef             	lea    -0x11(%ebp),%eax
    948a:	e8 fc ff ff ff       	call   948b <complexUeMacPdu+0x6b>
	fsm_mem_set(&m_power_headroom,0,sizeof(MAC_CE_power_headroom));//20140430
    948f:	31 d2                	xor    %edx,%edx
    9491:	b9 01 00 00 00       	mov    $0x1,%ecx
    9496:	8d 45 f2             	lea    -0xe(%ebp),%eax
    9499:	e8 fc ff ff ff       	call   949a <complexUeMacPdu+0x7a>
	fsm_mem_set(&m_short_bsr,0,sizeof(MAC_CE_shortBSR));		//20140430
    949e:	31 d2                	xor    %edx,%edx
    94a0:	b9 01 00 00 00       	mov    $0x1,%ecx
    94a5:	8d 45 f3             	lea    -0xd(%ebp),%eax
    94a8:	e8 fc ff ff ff       	call   94a9 <complexUeMacPdu+0x89>
	fsm_mem_set(&m_long_bsr,0,sizeof(MAC_CE_longBSR));		//20140430
    94ad:	31 d2                	xor    %edx,%edx
    94af:	b9 03 00 00 00       	mov    $0x3,%ecx
    94b4:	8d 45 ea             	lea    -0x16(%ebp),%eax
    94b7:	e8 fc ff ff ff       	call   94b8 <complexUeMacPdu+0x98>
	//fsm_mem_set(m_rlc_type2_ici,0,sizeof(RLC_MAC_IciMsgPB));		//20140430
	fsm_mem_set(&m_rlc_type1_ici,0,sizeof(RLCtoMAC_IciMsg));		//20140430
    94bc:	31 d2                	xor    %edx,%edx
    94be:	b9 04 00 00 00       	mov    $0x4,%ecx
    94c3:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    94c6:	e8 fc ff ff ff       	call   94c7 <complexUeMacPdu+0xa7>
	fsm_mem_set(&m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    94cb:	31 d2                	xor    %edx,%edx
    94cd:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    94d2:	8d 45 a6             	lea    -0x5a(%ebp),%eax
    94d5:	e8 fc ff ff ff       	call   94d6 <complexUeMacPdu+0xb6>
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506
    94da:	31 d2                	xor    %edx,%edx
    94dc:	b9 07 00 00 00       	mov    $0x7,%ecx
    94e1:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    94e4:	e8 fc ff ff ff       	call   94e5 <complexUeMacPdu+0xc5>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
    94e9:	8b bb ac 00 00 00    	mov    0xac(%ebx),%edi
    94ef:	2b bb a8 00 00 00    	sub    0xa8(%ebx),%edi



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    94f5:	8d 47 0a             	lea    0xa(%edi),%eax
    94f8:	e8 fc ff ff ff       	call   94f9 <complexUeMacPdu+0xd9>

	if(!compare(skb->data-skb->head,re_len)){
    94fd:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    9503:	89 45 a0             	mov    %eax,-0x60(%ebp)

	if(!compare(skb->data-skb->head,re_len)){
    9506:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    950c:	29 d0                	sub    %edx,%eax
    950e:	39 f8                	cmp    %edi,%eax
    9510:	0f 82 ca 03 00 00    	jb     98e0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(head_backup,skb->head,re_len);
    9516:	8b 45 a0             	mov    -0x60(%ebp),%eax
    9519:	89 f9                	mov    %edi,%ecx
    951b:	e8 fc ff ff ff       	call   951c <complexUeMacPdu+0xfc>
	
	
	/*
	 * for test
	 */
	SV(pkt_num_uplink)=SV(pkt_num_uplink)+1;
    9520:	83 86 08 02 00 00 01 	addl   $0x1,0x208(%esi)

	len=sizeof(RLCtoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    9527:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    952d:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9533:	29 d0                	sub    %edx,%eax
    9535:	83 f8 03             	cmp    $0x3,%eax
    9538:	0f 86 a2 03 00 00    	jbe    98e0 <complexUeMacPdu+0x4c0>
		fsm_pkt_destroy(skb);
		FOUT;
	}


	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
    953e:	b9 04 00 00 00       	mov    $0x4,%ecx
    9543:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    9546:	e8 fc ff ff ff       	call   9547 <complexUeMacPdu+0x127>
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
    954b:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    954f:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
    9553:	0f b7 c0             	movzwl %ax,%eax
    9556:	89 44 24 04          	mov    %eax,0x4(%esp)
    955a:	c7 04 24 54 2c 00 00 	movl   $0x2c54,(%esp)
    9561:	e8 fc ff ff ff       	call   9562 <complexUeMacPdu+0x142>
	if(skb->data==skb->tail){	//SDU,
    9566:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    956c:	89 45 98             	mov    %eax,-0x68(%ebp)
    956f:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9575:	89 45 94             	mov    %eax,-0x6c(%ebp)
	}
	else
		e=1;	//20131110modified

	total_len=SV(Tbsize_Complex);
	fsm_printf("[COMPLEX]TBSIZE:%d\n",SV(Tbsize_Complex));	
    9578:	8b 86 f4 01 00 00    	mov    0x1f4(%esi),%eax
    957e:	c7 04 24 42 07 00 00 	movl   $0x742,(%esp)
    9585:	89 44 24 04          	mov    %eax,0x4(%esp)
    9589:	e8 fc ff ff ff       	call   958a <complexUeMacPdu+0x16a>
		len=sizeof(RLCtoMAC_IciMsg);
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
    958e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9594:	0f b7 55 e5          	movzwl -0x1b(%ebp),%edx
    9598:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    959e:	01 d0                	add    %edx,%eax
    95a0:	3d fa 05 00 00       	cmp    $0x5fa,%eax
    95a5:	0f 87 5d 03 00 00    	ja     9908 <complexUeMacPdu+0x4e8>
		fsm_pkt_destroy(skb);
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
    95ab:	8d 45 ef             	lea    -0x11(%ebp),%eax
    95ae:	e8 fc ff ff ff       	call   95af <complexUeMacPdu+0x18f>
    95b3:	88 45 9c             	mov    %al,-0x64(%ebp)
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    95b6:	8d 45 f2             	lea    -0xe(%ebp),%eax
    95b9:	e8 fc ff ff ff       	call   95ba <complexUeMacPdu+0x19a>
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    95be:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    95c1:	8d 55 dc             	lea    -0x24(%ebp),%edx
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    95c4:	88 45 9d             	mov    %al,-0x63(%ebp)
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    95c7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    95ca:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    95d1:	e8 fc ff ff ff       	call   95d2 <complexUeMacPdu+0x1b2>
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    95d6:	83 f8 01             	cmp    $0x1,%eax
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    95d9:	89 c7                	mov    %eax,%edi
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    95db:	76 0c                	jbe    95e9 <complexUeMacPdu+0x1c9>
	
		test_len++;
	
		if(con_flag)
			fsm_printf("[COMPLEX]LONG BSR CONTROL ELEMENT FOUND!\n");
    95dd:	c7 04 24 9c 2c 00 00 	movl   $0x2c9c,(%esp)
    95e4:	e8 fc ff ff ff       	call   95e5 <complexUeMacPdu+0x1c5>
	test_rnti=test_ici.rnti;
	fsm_printf("[HEXI]LCID AND RNTI OF CCCH AFTER REALLOC:%d %d\n",test_lcid,test_rnti);*/

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
    95e9:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    95ed:	74 2f                	je     961e <complexUeMacPdu+0x1fe>
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST

		if(!compare(skb->data-skb->head,len)){
    95ef:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    95f5:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST
    95fb:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)

		if(!compare(skb->data-skb->head,len)){
    95ff:	0f 84 db 02 00 00    	je     98e0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_power_headroom,len);	//NEWSDU
    9605:	ba 01 00 00 00       	mov    $0x1,%edx
    960a:	89 d8                	mov    %ebx,%eax
    960c:	e8 fc ff ff ff       	call   960d <complexUeMacPdu+0x1ed>
    9611:	b9 01 00 00 00       	mov    $0x1,%ecx
    9616:	8d 55 f2             	lea    -0xe(%ebp),%edx
    9619:	e8 fc ff ff ff       	call   961a <complexUeMacPdu+0x1fa>
		
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti->m_crnti);
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR
    961e:	85 ff                	test   %edi,%edi
    9620:	0f 85 6a 02 00 00    	jne    9890 <complexUeMacPdu+0x470>
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL SUBHEAD:%d\n",(skb->tail-skb->data));
	
	if(crnti_flag){
    9626:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    962a:	74 4a                	je     9676 <complexUeMacPdu+0x256>
		len=sizeof(MAC_CE_Crnti);

		if(!compare(skb->data-skb->head,len)){
    962c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9632:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    9638:	83 f8 01             	cmp    $0x1,%eax
    963b:	0f 86 9f 02 00 00    	jbe    98e0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_crnti,len);	//NEWSDU
    9641:	ba 02 00 00 00       	mov    $0x2,%edx
    9646:	89 d8                	mov    %ebx,%eax
    9648:	e8 fc ff ff ff       	call   9649 <complexUeMacPdu+0x229>
    964d:	b9 02 00 00 00       	mov    $0x2,%ecx
    9652:	8d 55 ef             	lea    -0x11(%ebp),%edx
    9655:	e8 fc ff ff ff       	call   9656 <complexUeMacPdu+0x236>
		rnti_to_ici=SV(T_C_RNTI);
    965a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
    965e:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti.m_crnti);
    9662:	0f b7 45 ef          	movzwl -0x11(%ebp),%eax
    9666:	c7 04 24 c8 2c 00 00 	movl   $0x2cc8,(%esp)
    966d:	89 44 24 04          	mov    %eax,0x4(%esp)
    9671:	e8 fc ff ff ff       	call   9672 <complexUeMacPdu+0x252>
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9676:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    967c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9682:	0f b7 4d e5          	movzwl -0x1b(%ebp),%ecx
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9686:	29 d0                	sub    %edx,%eax
    9688:	83 e8 04             	sub    $0x4,%eax
    968b:	83 f8 01             	cmp    $0x1,%eax
    968e:	0f 86 4c 02 00 00    	jbe    98e0 <complexUeMacPdu+0x4c0>
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9694:	0f b7 c9             	movzwl %cx,%ecx
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    9697:	83 c2 04             	add    $0x4,%edx
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    969a:	89 4d 90             	mov    %ecx,-0x70(%ebp)
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    969d:	8d 45 ed             	lea    -0x13(%ebp),%eax
    96a0:	b9 02 00 00 00       	mov    $0x2,%ecx
    96a5:	e8 fc ff ff ff       	call   96a6 <complexUeMacPdu+0x286>
	m_7bit_subhead.m_f_l=m_7bit_subhead.m_f_l>>7;
    96aa:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    96ae:	c0 e8 07             	shr    $0x7,%al
    96b1:	88 45 ee             	mov    %al,-0x12(%ebp)
	fsm_printf("THE TYPE OF SDU:%d\n",m_7bit_subhead.m_f_l);
    96b4:	0f b6 c0             	movzbl %al,%eax
    96b7:	89 44 24 04          	mov    %eax,0x4(%esp)
    96bb:	c7 04 24 56 07 00 00 	movl   $0x756,(%esp)
    96c2:	e8 fc ff ff ff       	call   96c3 <complexUeMacPdu+0x2a3>
	
	
	test_len+=head_len;
	//fsm_printf("[COMPLEX]THE ORIGINAL LENGTH AND LENGTH OF THE HEADS:%d,%d\n",m_rlc_type1_ici->len,head_len);
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING SDU SUBHEAD:%d\n",(skb->tail-skb->data));
	if(!compare(skb->data-skb->head-len,head_len)){
    96c7:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    96cd:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    96d3:	83 e8 04             	sub    $0x4,%eax
    96d6:	39 45 90             	cmp    %eax,-0x70(%ebp)
    96d9:	0f 87 01 02 00 00    	ja     98e0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_skb_push(skb,head_len);		
    96df:	8b 55 90             	mov    -0x70(%ebp),%edx
    96e2:	89 d8                	mov    %ebx,%eax
    96e4:	e8 fc ff ff ff       	call   96e5 <complexUeMacPdu+0x2c5>
	fsm_mem_cpy(skb->data,(u8*)head_backup+len,head_len);	//SDUdata 	//for test
    96e9:	8b 55 a0             	mov    -0x60(%ebp),%edx
    96ec:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    96f2:	8b 4d 90             	mov    -0x70(%ebp),%ecx
    96f5:	83 c2 04             	add    $0x4,%edx
    96f8:	e8 fc ff ff ff       	call   96f9 <complexUeMacPdu+0x2d9>

	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
    96fd:	85 ff                	test   %edi,%edi
    96ff:	0f 84 bb 02 00 00    	je     99c0 <complexUeMacPdu+0x5a0>

	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
	if(skb->data==skb->tail){	//SDU,
		e=0;
    9705:	8b 45 94             	mov    -0x6c(%ebp),%eax
    9708:	39 45 98             	cmp    %eax,-0x68(%ebp)
    970b:	0f 95 c0             	setne  %al
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
    970e:	c1 e0 05             	shl    $0x5,%eax
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
    9711:	83 ff 01             	cmp    $0x1,%edi
    9714:	0f 84 46 02 00 00    	je     9960 <complexUeMacPdu+0x540>
			//fsm_printf("PUT IN THE LONG BSR HEAD!\n");


			lcid=LONG_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    971a:	83 c0 1e             	add    $0x1e,%eax
    971d:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9720:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9726:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    972c:	0f 84 ae 01 00 00    	je     98e0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9732:	ba 01 00 00 00       	mov    $0x1,%edx
    9737:	89 d8                	mov    %ebx,%eax
    9739:	e8 fc ff ff ff       	call   973a <complexUeMacPdu+0x31a>
    973e:	b9 01 00 00 00       	mov    $0x1,%ecx
	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
    9743:	31 ff                	xor    %edi,%edi
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9745:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9748:	e8 fc ff ff ff       	call   9749 <complexUeMacPdu+0x329>
			head_len=head_len+len;
		}
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    974d:	31 d2                	xor    %edx,%edx
    974f:	b9 01 00 00 00       	mov    $0x1,%ecx
    9754:	8d 45 f1             	lea    -0xf(%ebp),%eax
    9757:	e8 fc ff ff ff       	call   9758 <complexUeMacPdu+0x338>
	if(crnti_flag){
    975c:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    9760:	74 39                	je     979b <complexUeMacPdu+0x37b>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9762:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=e<<5;
    9765:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9768:	8d 47 1b             	lea    0x1b(%edi),%eax
    976b:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    976e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9774:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    977a:	0f 84 60 01 00 00    	je     98e0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9780:	ba 01 00 00 00       	mov    $0x1,%edx
    9785:	89 d8                	mov    %ebx,%eax
    9787:	e8 fc ff ff ff       	call   9788 <complexUeMacPdu+0x368>
    978c:	b9 01 00 00 00       	mov    $0x1,%ecx
    9791:	31 ff                	xor    %edi,%edi
    9793:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9796:	e8 fc ff ff ff       	call   9797 <complexUeMacPdu+0x377>
		head_len=head_len+len;
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    979b:	31 d2                	xor    %edx,%edx
    979d:	b9 01 00 00 00       	mov    $0x1,%ecx
    97a2:	8d 45 f1             	lea    -0xf(%ebp),%eax
    97a5:	e8 fc ff ff ff       	call   97a6 <complexUeMacPdu+0x386>
	if(ph_flag){
    97aa:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    97ae:	74 37                	je     97e7 <complexUeMacPdu+0x3c7>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    97b0:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=(e<<5);
    97b3:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    97b6:	8d 47 1a             	lea    0x1a(%edi),%eax
    97b9:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    97bc:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    97c2:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    97c8:	0f 84 12 01 00 00    	je     98e0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    97ce:	ba 01 00 00 00       	mov    $0x1,%edx
    97d3:	89 d8                	mov    %ebx,%eax
    97d5:	e8 fc ff ff ff       	call   97d6 <complexUeMacPdu+0x3b6>
    97da:	b9 01 00 00 00       	mov    $0x1,%ecx
    97df:	8d 55 f1             	lea    -0xf(%ebp),%edx
    97e2:	e8 fc ff ff ff       	call   97e3 <complexUeMacPdu+0x3c3>
		
		//fsm_printf("[COMPLEX]PH SUBHED:%c\n",m_fixed_subhead->m_lcid_e_r_r+10);
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL ELEMENTS:%d\n",(skb->tail-skb->data));
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    97e7:	0f b7 4d 9e          	movzwl -0x62(%ebp),%ecx
    97eb:	ba 02 00 00 00       	mov    $0x2,%edx
    97f0:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    97f3:	e8 fc ff ff ff       	call   97f4 <complexUeMacPdu+0x3d4>
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 
    97f8:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    97fc:	89 44 24 08          	mov    %eax,0x8(%esp)
    9800:	0f b7 45 d5          	movzwl -0x2b(%ebp),%eax
    9804:	c7 04 24 ec 2c 00 00 	movl   $0x2cec,(%esp)
    980b:	89 44 24 04          	mov    %eax,0x4(%esp)
    980f:	e8 fc ff ff ff       	call   9810 <complexUeMacPdu+0x3f0>

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
    9814:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    981a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9820:	29 c2                	sub    %eax,%edx
    9822:	83 fa 06             	cmp    $0x6,%edx
    9825:	0f 86 b5 00 00 00    	jbe    98e0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

    	fsm_mem_cpy(skb->head,&m_phy_ici,sizeof(MACtoPHYadapter_IciMsg));//ICIsk_buf//20140506 HQ
    982b:	b9 07 00 00 00       	mov    $0x7,%ecx
    9830:	8d 55 d1             	lea    -0x2f(%ebp),%edx
    9833:	e8 fc ff ff ff       	call   9834 <complexUeMacPdu+0x414>
    		fsm_printf("%c ",*(skb->data+i)+65);
    	}*/
    	
    	//fsm_octets_print(skb->data,7);
    	
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
    9838:	ba 03 00 00 00       	mov    $0x3,%edx
    983d:	89 d8                	mov    %ebx,%eax
    983f:	e8 fc ff ff ff       	call   9840 <complexUeMacPdu+0x420>
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
    9844:	8b 43 50             	mov    0x50(%ebx),%eax
    9847:	c7 04 24 18 2d 00 00 	movl   $0x2d18,(%esp)
    984e:	89 44 24 04          	mov    %eax,0x4(%esp)
    9852:	e8 fc ff ff ff       	call   9853 <complexUeMacPdu+0x433>
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping
    9857:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    985d:	ba 50 00 00 00       	mov    $0x50,%edx
    9862:	e8 fc ff ff ff       	call   9863 <complexUeMacPdu+0x443>
	SV(Tbsize_Complex)=0;

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9867:	8b 45 a0             	mov    -0x60(%ebp),%eax
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping

	SV(Tbsize_Complex)=0;
    986a:	c7 86 f4 01 00 00 00 	movl   $0x0,0x1f4(%esi)
    9871:	00 00 00 

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9874:	e8 fc ff ff ff       	call   9875 <complexUeMacPdu+0x455>
	clean_CE_tags();// modified by HQ 20140512 
    9879:	e8 fc ff ff ff       	call   987a <complexUeMacPdu+0x45a>
	fsm_printf("complex function done\n");//testing code 
    987e:	c7 04 24 6a 07 00 00 	movl   $0x76a,(%esp)
    9885:	e8 fc ff ff ff       	call   9886 <complexUeMacPdu+0x466>
	fsm_printf("%c,\n",*(skb->data+from_len));
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
    988a:	eb 6f                	jmp    98fb <complexUeMacPdu+0x4db>
    988c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
    9890:	83 ff 01             	cmp    $0x1,%edi
    9893:	0f 84 e7 00 00 00    	je     9980 <complexUeMacPdu+0x560>

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    9899:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		else{
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
    989c:	8b 45 c0             	mov    -0x40(%ebp),%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    989f:	89 ca                	mov    %ecx,%edx
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
    98a1:	c1 e0 02             	shl    $0x2,%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    98a4:	83 e2 30             	and    $0x30,%edx
    98a7:	0f b6 c0             	movzbl %al,%eax
    98aa:	01 d0                	add    %edx,%eax
    98ac:	c1 e8 04             	shr    $0x4,%eax
    98af:	88 45 ea             	mov    %al,-0x16(%ebp)
			m_long_bsr.m_buffersize2=(longbsr_buf_sizes[1]&15);
    98b2:	89 c8                	mov    %ecx,%eax
    98b4:	83 e0 0f             	and    $0xf,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    98b7:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[2];
    98ba:	66 03 45 c8          	add    -0x38(%ebp),%ax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    98be:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[3];
    98c1:	66 03 45 cc          	add    -0x34(%ebp),%ax
    98c5:	66 89 45 eb          	mov    %ax,-0x15(%ebp)
			//
			//fsm_printf("[COMPLEX]BSR VALUE:%c,%d\n",m_long_bsr->m_buffersize1+65,m_long_bsr->m_buffersize2);

			len=sizeof(MAC_CE_longBSR);

			if(!compare(skb->data-skb->head,len)){
    98c9:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    98cf:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    98d5:	83 f8 02             	cmp    $0x2,%eax
    98d8:	77 5e                	ja     9938 <complexUeMacPdu+0x518>
    98da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
			fsm_mem_free(head_backup);
    98e0:	8b 45 a0             	mov    -0x60(%ebp),%eax
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    98e3:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
			fsm_mem_free(head_backup);
    98ea:	e8 fc ff ff ff       	call   98eb <complexUeMacPdu+0x4cb>
			clean_CE_tags();
    98ef:	e8 fc ff ff ff       	call   98f0 <complexUeMacPdu+0x4d0>
			fsm_pkt_destroy(skb);
    98f4:	89 d8                	mov    %ebx,%eax
    98f6:	e8 fc ff ff ff       	call   98f7 <complexUeMacPdu+0x4d7>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    98fb:	83 c4 70             	add    $0x70,%esp
    98fe:	5b                   	pop    %ebx
    98ff:	5e                   	pop    %esi
    9900:	5f                   	pop    %edi
    9901:	5d                   	pop    %ebp
    9902:	c3                   	ret    
    9903:	90                   	nop
    9904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9908:	8b 45 a0             	mov    -0x60(%ebp),%eax
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    990b:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9912:	e8 fc ff ff ff       	call   9913 <complexUeMacPdu+0x4f3>
		clean_CE_tags();// modified by HQ 20140512 
    9917:	e8 fc ff ff ff       	call   9918 <complexUeMacPdu+0x4f8>
		fsm_printf("complex function done by error!\n");//testing code 
    991c:	c7 04 24 78 2c 00 00 	movl   $0x2c78,(%esp)
    9923:	e8 fc ff ff ff       	call   9924 <complexUeMacPdu+0x504>
		fsm_pkt_destroy(skb);
    9928:	89 d8                	mov    %ebx,%eax
    992a:	e8 fc ff ff ff       	call   992b <complexUeMacPdu+0x50b>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    992f:	83 c4 70             	add    $0x70,%esp
    9932:	5b                   	pop    %ebx
    9933:	5e                   	pop    %esi
    9934:	5f                   	pop    %edi
    9935:	5d                   	pop    %ebp
    9936:	c3                   	ret    
    9937:	90                   	nop
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_long_bsr,len);	//BSR
    9938:	ba 03 00 00 00       	mov    $0x3,%edx
    993d:	89 d8                	mov    %ebx,%eax
    993f:	e8 fc ff ff ff       	call   9940 <complexUeMacPdu+0x520>
    9944:	b9 03 00 00 00       	mov    $0x3,%ecx
    9949:	8d 55 ea             	lea    -0x16(%ebp),%edx
    994c:	e8 fc ff ff ff       	call   994d <complexUeMacPdu+0x52d>
			}
			SV(RetxBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)*100;
			SV(RetxBSRTimer).timer_sign = fsm_schedule_self(SV(RetxBSRTimer).time_value,RexBSRTimer_Expire );
			SV(RetxBSRTimer).flag = true; */			
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
    9951:	e8 fc ff ff ff       	call   9952 <complexUeMacPdu+0x532>
    9956:	e9 cb fc ff ff       	jmp    9626 <complexUeMacPdu+0x206>
    995b:	90                   	nop
    995c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9960:	83 c0 1d             	add    $0x1d,%eax
    9963:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9966:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    996c:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9972:	0f 85 ba fd ff ff    	jne    9732 <complexUeMacPdu+0x312>
    9978:	e9 63 ff ff ff       	jmp    98e0 <complexUeMacPdu+0x4c0>
    997d:	8d 76 00             	lea    0x0(%esi),%esi
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
			m_short_bsr.m_lcgid_buffersize=lcg_id;
    9980:	8b 45 d8             	mov    -0x28(%ebp),%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize<<6;
    9983:	c1 e0 06             	shl    $0x6,%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize+(shortbsr_buf_size);
    9986:	02 45 dc             	add    -0x24(%ebp),%al
    9989:	88 45 f3             	mov    %al,-0xd(%ebp)
			len=sizeof(MAC_CE_shortBSR);

			if(!compare(skb->data-skb->head,len)){
    998c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9992:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9998:	0f 84 42 ff ff ff    	je     98e0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_short_bsr,len);	//BSR
    999e:	ba 01 00 00 00       	mov    $0x1,%edx
    99a3:	89 d8                	mov    %ebx,%eax
    99a5:	e8 fc ff ff ff       	call   99a6 <complexUeMacPdu+0x586>
    99aa:	b9 01 00 00 00       	mov    $0x1,%ecx
    99af:	8d 55 f3             	lea    -0xd(%ebp),%edx
    99b2:	e8 fc ff ff ff       	call   99b3 <complexUeMacPdu+0x593>
    99b7:	eb 98                	jmp    9951 <complexUeMacPdu+0x531>
    99b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
	bool crnti_flag=false, ph_flag=false,first_flag=true,con_flag=true;	//crnti; 
    99c0:	bf 01 00 00 00       	mov    $0x1,%edi
    99c5:	e9 83 fd ff ff       	jmp    974d <complexUeMacPdu+0x32d>
    99ca:	90                   	nop
    99cb:	90                   	nop
    99cc:	90                   	nop
    99cd:	90                   	nop
    99ce:	90                   	nop
    99cf:	90                   	nop

000099d0 <Init_Uemac_Scheduler>:
->output:
->Special:
*******************************
*/
void Init_Uemac_Scheduler(void)
{
    99d0:	55                   	push   %ebp
    99d1:	89 e5                	mov    %esp,%ebp
    99d3:	53                   	push   %ebx
    99d4:	e8 fc ff ff ff       	call   99d5 <Init_Uemac_Scheduler+0x5>
	FIN(Init_Uemac_Scheduler(void));
	SV_PTR_GET(rlc_mac_sv);
    99d9:	e8 fc ff ff ff       	call   99da <Init_Uemac_Scheduler+0xa>
    99de:	89 c3                	mov    %eax,%ebx
	SV(LCGZeroToData)=false;
    99e0:	c6 80 58 01 00 00 00 	movb   $0x0,0x158(%eax)
	SV(m_freshUlBsr)=false;
    99e7:	c6 80 59 01 00 00 00 	movb   $0x0,0x159(%eax)
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;
    99ee:	c6 80 5a 01 00 00 00 	movb   $0x0,0x15a(%eax)

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    99f5:	b8 1a 00 00 00       	mov    $0x1a,%eax
    99fa:	e8 fc ff ff ff       	call   99fb <Init_Uemac_Scheduler+0x2b>
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    99ff:	31 d2                	xor    %edx,%edx
    9a01:	b9 1a 00 00 00       	mov    $0x1a,%ecx
	SV(LCGZeroToData)=false;
	SV(m_freshUlBsr)=false;
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9a06:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    9a0c:	e8 fc ff ff ff       	call   9a0d <Init_Uemac_Scheduler+0x3d>
	SV(Periodicbsr)=NULL;
	SV(Regularbsr)=NULL;
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9a11:	b8 0d 00 00 00       	mov    $0xd,%eax
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
	SV(Periodicbsr)=NULL;
    9a16:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    9a1d:	00 00 00 
	SV(Regularbsr)=NULL;
    9a20:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    9a27:	00 00 00 
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9a2a:	e8 fc ff ff ff       	call   9a2b <Init_Uemac_Scheduler+0x5b>
    9a2f:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
	SV(LogicalChannel_Bj)=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    9a35:	b8 0d 00 00 00       	mov    $0xd,%eax
    9a3a:	e8 fc ff ff ff       	call   9a3b <Init_Uemac_Scheduler+0x6b>
    9a3f:	89 83 44 01 00 00    	mov    %eax,0x144(%ebx)
	SV(LogicalChannel_Config)=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9a45:	b8 19 00 00 00       	mov    $0x19,%eax
    9a4a:	e8 fc ff ff ff       	call   9a4b <Init_Uemac_Scheduler+0x7b>
    9a4f:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
	INIT_LIST_HEAD(&(SV(MacBuffer_RLC)->list));
    9a55:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    9a5b:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a5e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9a61:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Bj)->list));
    9a64:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
    9a6a:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a6d:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9a70:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Config)->list));
    9a73:	8b 83 40 01 00 00    	mov    0x140(%ebx),%eax
    9a79:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a7c:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9a7f:	89 50 15             	mov    %edx,0x15(%eax)
	FOUT;
}
    9a82:	5b                   	pop    %ebx
    9a83:	5d                   	pop    %ebp
    9a84:	c3                   	ret    
    9a85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9a89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009a90 <RlcRequest_arraytolist>:
->Output:RlcBufferRequest 
->Special:
*******************************
*/
RlcBufferRequest * RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num)//num
{
    9a90:	55                   	push   %ebp
    9a91:	89 e5                	mov    %esp,%ebp
    9a93:	57                   	push   %edi
    9a94:	56                   	push   %esi
    9a95:	53                   	push   %ebx
    9a96:	83 ec 18             	sub    $0x18,%esp
    9a99:	e8 fc ff ff ff       	call   9a9a <RlcRequest_arraytolist+0xa>
    9a9e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9aa1:	89 c6                	mov    %eax,%esi
	LogicalChannelConfigInfo *temp_lcc_info;
	u8 lcid;
	u32 flag;

	FIN(RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num));
	SV_PTR_GET(rlc_mac_sv);
    9aa3:	e8 fc ff ff ff       	call   9aa4 <RlcRequest_arraytolist+0x14>
    9aa8:	89 c7                	mov    %eax,%edi
	rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9aaa:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9aaf:	e8 fc ff ff ff       	call   9ab0 <RlcRequest_arraytolist+0x20>
    9ab4:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9ab7:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
    9aba:	83 c0 13             	add    $0x13,%eax
    9abd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9ac0:	89 42 13             	mov    %eax,0x13(%edx)
	list->prev = list;
    9ac3:	89 42 17             	mov    %eax,0x17(%edx)
	for(i=0;i<num;i++)
    9ac6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9ac9:	85 c0                	test   %eax,%eax
    9acb:	74 52                	je     9b1f <RlcRequest_arraytolist+0x8f>
    9acd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9ad4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9ad8:	8b 87 40 01 00 00    	mov    0x140(%edi),%eax
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
    9ade:	0f b6 56 02          	movzbl 0x2(%esi),%edx
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9ae2:	8b 58 11             	mov    0x11(%eax),%ebx
    9ae5:	83 eb 11             	sub    $0x11,%ebx
    9ae8:	39 d8                	cmp    %ebx,%eax
    9aea:	74 12                	je     9afe <RlcRequest_arraytolist+0x6e>
		{
			if(lcid==temp_lcc_info->lcid)
    9aec:	38 13                	cmp    %dl,(%ebx)
    9aee:	74 48                	je     9b38 <RlcRequest_arraytolist+0xa8>
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    9af0:	8b 5b 11             	mov    0x11(%ebx),%ebx
    9af3:	83 eb 11             	sub    $0x11,%ebx
    9af6:	39 9f 40 01 00 00    	cmp    %ebx,0x140(%edi)
    9afc:	75 ee                	jne    9aec <RlcRequest_arraytolist+0x5c>
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
    9afe:	c7 04 24 80 2d 00 00 	movl   $0x2d80,(%esp)
    9b05:	e8 fc ff ff ff       	call   9b06 <RlcRequest_arraytolist+0x76>
    9b0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
    9b10:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9b14:	83 c6 13             	add    $0x13,%esi
    9b17:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9b1a:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    9b1d:	75 b9                	jne    9ad8 <RlcRequest_arraytolist+0x48>
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    9b1f:	8b 55 e8             	mov    -0x18(%ebp),%edx
	FRET(rlcrequest);
}
    9b22:	8b 45 ec             	mov    -0x14(%ebp),%eax
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    9b25:	89 97 5c 01 00 00    	mov    %edx,0x15c(%edi)
	FRET(rlcrequest);
}
    9b2b:	83 c4 18             	add    $0x18,%esp
    9b2e:	5b                   	pop    %ebx
    9b2f:	5e                   	pop    %esi
    9b30:	5f                   	pop    %edi
    9b31:	5d                   	pop    %ebp
    9b32:	c3                   	ret    
    9b33:	90                   	nop
    9b34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			if(lcid==temp_lcc_info->lcid)
			{
				if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9b38:	83 7b 0d 03          	cmpl   $0x3,0xd(%ebx)
    9b3c:	77 6a                	ja     9ba8 <RlcRequest_arraytolist+0x118>
				}
			}
		}
		if(flag==1)//requestMAC 
		{		
			rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9b3e:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9b43:	e8 fc ff ff ff       	call   9b44 <RlcRequest_arraytolist+0xb4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9b48:	8b 5d ec             	mov    -0x14(%ebp),%ebx
			/*while(rlcrequest_temp==0)//
			{
				rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
			}*/
			INIT_LIST_HEAD(&(rlcrequest_temp->list));
    9b4b:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9b4e:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9b51:	89 50 17             	mov    %edx,0x17(%eax)
			rlcrequest_temp->rnti=rlc_request_array[i].rnti;
    9b54:	0f b7 0e             	movzwl (%esi),%ecx
    9b57:	66 89 08             	mov    %cx,(%eax)
			rlcrequest_temp->lcid=rlc_request_array[i].lcid;
    9b5a:	0f b6 4e 02          	movzbl 0x2(%esi),%ecx
    9b5e:	88 48 02             	mov    %cl,0x2(%eax)
			rlcrequest_temp->txQueueSize=rlc_request_array[i].txQueueSize;
    9b61:	8b 4e 03             	mov    0x3(%esi),%ecx
    9b64:	89 48 03             	mov    %ecx,0x3(%eax)
			rlcrequest_temp->txQueueHeader=rlc_request_array[i].txQueueHeader;
    9b67:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    9b6b:	66 89 48 07          	mov    %cx,0x7(%eax)
			rlcrequest_temp->retxQueueSize=rlc_request_array[i].retxQueueSize;
    9b6f:	8b 4e 09             	mov    0x9(%esi),%ecx
    9b72:	89 48 09             	mov    %ecx,0x9(%eax)
			rlcrequest_temp->retxQueueHeader=rlc_request_array[i].retxQueueHeader;
    9b75:	0f b7 4e 0d          	movzwl 0xd(%esi),%ecx
    9b79:	66 89 48 0d          	mov    %cx,0xd(%eax)
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
    9b7d:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    9b81:	66 89 48 0f          	mov    %cx,0xf(%eax)
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
    9b85:	0f b7 4e 11          	movzwl 0x11(%esi),%ecx
    9b89:	66 89 48 11          	mov    %cx,0x11(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9b8d:	8b 4b 17             	mov    0x17(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9b90:	89 53 17             	mov    %edx,0x17(%ebx)
	new->next = next;
    9b93:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	new->prev = prev;
    9b96:	89 48 17             	mov    %ecx,0x17(%eax)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    9b99:	89 58 13             	mov    %ebx,0x13(%eax)
	new->prev = prev;
	prev->next = new;
    9b9c:	89 11                	mov    %edx,(%ecx)
    9b9e:	e9 6d ff ff ff       	jmp    9b10 <RlcRequest_arraytolist+0x80>
    9ba3:	90                   	nop
    9ba4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					flag=1;
					break;
				}
				else
				{
					fsm_printf("[UEMAC][RLCreq_tolist]:lc_group error ,maybe it's rrc's mistake\n");
    9ba8:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9bab:	c7 04 24 3c 2d 00 00 	movl   $0x2d3c,(%esp)
    9bb2:	e8 fc ff ff ff       	call   9bb3 <RlcRequest_arraytolist+0x123>
    9bb7:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
					continue;
    9bbb:	e9 30 ff ff ff       	jmp    9af0 <RlcRequest_arraytolist+0x60>

00009bc0 <RlcRequest_listtoarray>:
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9bc0:	55                   	push   %ebp
    9bc1:	89 e5                	mov    %esp,%ebp
    9bc3:	57                   	push   %edi
    9bc4:	56                   	push   %esi
    9bc5:	53                   	push   %ebx
    9bc6:	83 ec 10             	sub    $0x10,%esp
    9bc9:	e8 fc ff ff ff       	call   9bca <RlcRequest_listtoarray+0xa>
	/*while(rlc_report==0)//
	{
		rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(int));
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;
    9bce:	31 db                	xor    %ebx,%ebx
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9bd0:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9bd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void *rlc_report;
	u32 *temp_num;
	RLC_Request *rlc_report_temp;

	FIN(RlcRequest_listtoarray( RlcBufferRequest *rlc_request,int *num));
	SV_PTR_GET(rlc_mac_sv);
    9bd6:	e8 fc ff ff ff       	call   9bd7 <RlcRequest_listtoarray+0x17>
	rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(u32));//report
    9bdb:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
    9be1:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    9be4:	8d 44 50 04          	lea    0x4(%eax,%edx,2),%eax
    9be8:	e8 fc ff ff ff       	call   9be9 <RlcRequest_listtoarray+0x29>
    9bed:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9bf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9bf3:	8b 50 13             	mov    0x13(%eax),%edx
    9bf6:	89 c7                	mov    %eax,%edi
    9bf8:	b8 04 00 00 00       	mov    $0x4,%eax
    9bfd:	83 c7 13             	add    $0x13,%edi
    9c00:	39 fa                	cmp    %edi,%edx
    9c02:	8b 0a                	mov    (%edx),%ecx
    9c04:	74 62                	je     9c68 <RlcRequest_listtoarray+0xa8>
    9c06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9c09:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    9c0c:	eb 06                	jmp    9c14 <RlcRequest_listtoarray+0x54>
    9c0e:	66 90                	xchg   %ax,%ax
    9c10:	89 ca                	mov    %ecx,%edx
    9c12:	89 f1                	mov    %esi,%ecx
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    9c14:	0f b7 72 ed          	movzwl -0x13(%edx),%esi
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
    9c18:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    9c1c:	66 89 70 04          	mov    %si,0x4(%eax)
		rlc_report_temp[i].lcid=temp->lcid;
    9c20:	0f b6 72 ef          	movzbl -0x11(%edx),%esi
    9c24:	89 f3                	mov    %esi,%ebx
    9c26:	88 58 06             	mov    %bl,0x6(%eax)
		rlc_report_temp[i].txQueueSize=temp->txQueueSize;
    9c29:	8b 72 f0             	mov    -0x10(%edx),%esi
    9c2c:	89 70 07             	mov    %esi,0x7(%eax)
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
    9c2f:	0f b7 72 f4          	movzwl -0xc(%edx),%esi
    9c33:	66 89 70 0b          	mov    %si,0xb(%eax)
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
    9c37:	8b 72 f6             	mov    -0xa(%edx),%esi
    9c3a:	89 70 0d             	mov    %esi,0xd(%eax)
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
    9c3d:	0f b7 72 fa          	movzwl -0x6(%edx),%esi
    9c41:	66 89 70 11          	mov    %si,0x11(%eax)
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
    9c45:	0f b7 72 fc          	movzwl -0x4(%edx),%esi
    9c49:	66 89 70 13          	mov    %si,0x13(%eax)
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
    9c4d:	0f b7 52 fe          	movzwl -0x2(%edx),%edx
    9c51:	66 89 50 15          	mov    %dx,0x15(%eax)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9c55:	83 c0 13             	add    $0x13,%eax
    9c58:	39 cf                	cmp    %ecx,%edi
    9c5a:	8b 31                	mov    (%ecx),%esi
    9c5c:	75 b2                	jne    9c10 <RlcRequest_listtoarray+0x50>
    9c5e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    9c61:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    9c64:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
    9c68:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9c6b:	89 1a                	mov    %ebx,(%edx)
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
    9c6d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9c70:	89 02                	mov    %eax,(%edx)
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9c72:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9c75:	8b 50 13             	mov    0x13(%eax),%edx
    9c78:	39 d7                	cmp    %edx,%edi
    9c7a:	8b 1a                	mov    (%edx),%ebx
    9c7c:	75 04                	jne    9c82 <RlcRequest_listtoarray+0xc2>
    9c7e:	eb 1f                	jmp    9c9f <RlcRequest_listtoarray+0xdf>
    9c80:	89 f2                	mov    %esi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    9c82:	8b 4a 04             	mov    0x4(%edx),%ecx
    9c85:	89 de                	mov    %ebx,%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    9c87:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    9c8a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    9c8d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9c8f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    9c91:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);//
    9c94:	e8 fc ff ff ff       	call   9c95 <RlcRequest_listtoarray+0xd5>
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9c99:	39 fe                	cmp    %edi,%esi
    9c9b:	8b 1b                	mov    (%ebx),%ebx
    9c9d:	75 e1                	jne    9c80 <RlcRequest_listtoarray+0xc0>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);//
	}
	fsm_mem_free(rlc_request);
    9c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9ca2:	e8 fc ff ff ff       	call   9ca3 <RlcRequest_listtoarray+0xe3>
	FRET(rlc_report);
}
    9ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9caa:	83 c4 10             	add    $0x10,%esp
    9cad:	5b                   	pop    %ebx
    9cae:	5e                   	pop    %esi
    9caf:	5f                   	pop    %edi
    9cb0:	5d                   	pop    %ebp
    9cb1:	c3                   	ret    
    9cb2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    9cb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009cc0 <Rlc_MacRequest_copy>:
->Output:RLC_Request
->Special:
*******************************
*/
RLC_Request* Rlc_MacRequest_copy(RlcBufferRequest *temp)
{
    9cc0:	55                   	push   %ebp
    9cc1:	89 e5                	mov    %esp,%ebp
    9cc3:	53                   	push   %ebx
    9cc4:	e8 fc ff ff ff       	call   9cc5 <Rlc_MacRequest_copy+0x5>
    9cc9:	89 c3                	mov    %eax,%ebx
	FIN(Rlc_MacRequest_copy(RlcBufferRequest *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9ccb:	b8 13 00 00 00       	mov    $0x13,%eax
    9cd0:	e8 fc ff ff ff       	call   9cd1 <Rlc_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9cd5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9cd9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9cdc:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9ce0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9ce4:	8b 53 09             	mov    0x9(%ebx),%edx
    9ce7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9cea:	0f b7 13             	movzwl (%ebx),%edx
    9ced:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9cf0:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9cf4:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9cf8:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9cfc:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9d00:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9d04:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9d08:	8b 53 03             	mov    0x3(%ebx),%edx
    9d0b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9d0e:	5b                   	pop    %ebx
    9d0f:	5d                   	pop    %ebp
    9d10:	c3                   	ret    
    9d11:	eb 0d                	jmp    9d20 <LogicalChannel_ConfigInfo_copy>
    9d13:	90                   	nop
    9d14:	90                   	nop
    9d15:	90                   	nop
    9d16:	90                   	nop
    9d17:	90                   	nop
    9d18:	90                   	nop
    9d19:	90                   	nop
    9d1a:	90                   	nop
    9d1b:	90                   	nop
    9d1c:	90                   	nop
    9d1d:	90                   	nop
    9d1e:	90                   	nop
    9d1f:	90                   	nop

00009d20 <LogicalChannel_ConfigInfo_copy>:
->Output:LogicalChannelConfigInfo:MAC
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp)
{
    9d20:	55                   	push   %ebp
    9d21:	89 e5                	mov    %esp,%ebp
    9d23:	53                   	push   %ebx
    9d24:	e8 fc ff ff ff       	call   9d25 <LogicalChannel_ConfigInfo_copy+0x5>
    9d29:	89 c3                	mov    %eax,%ebx
	FIN(LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp));
	LogicalChannelConfigInfo *copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9d2b:	b8 19 00 00 00       	mov    $0x19,%eax
    9d30:	e8 fc ff ff ff       	call   9d31 <LogicalChannel_ConfigInfo_copy+0x11>
	/*while(copy==0)//
	{
		copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9d35:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9d38:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9d3b:	89 50 15             	mov    %edx,0x15(%eax)
	copy->lcid=temp->logicalChannelIdentity;
    9d3e:	8b 13                	mov    (%ebx),%edx
    9d40:	88 10                	mov    %dl,(%eax)
	copy->priority=(temp->logicalChannelConfig).ul_SpecificParameters.priority;
    9d42:	8b 53 05             	mov    0x5(%ebx),%edx
    9d45:	89 50 01             	mov    %edx,0x1(%eax)
	copy->prioritizedBitRateKbps=(temp->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    9d48:	8b 53 09             	mov    0x9(%ebx),%edx
    9d4b:	89 50 05             	mov    %edx,0x5(%eax)
	copy->bucketSizeDurationMs=(temp->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    9d4e:	8b 53 0d             	mov    0xd(%ebx),%edx
    9d51:	89 50 09             	mov    %edx,0x9(%eax)
	copy->logicalChannelGroup=(temp->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    9d54:	8b 53 11             	mov    0x11(%ebx),%edx
    9d57:	89 50 0d             	mov    %edx,0xd(%eax)
	FRET(copy);
}
    9d5a:	5b                   	pop    %ebx
    9d5b:	5d                   	pop    %ebp
    9d5c:	c3                   	ret    
    9d5d:	8d 76 00             	lea    0x0(%esi),%esi

00009d60 <Mac_RlcRequest_copy>:
->Output:RlcBufferRequest:MACRLC request
->Special:
*******************************
*/
RlcBufferRequest* Mac_RlcRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9d60:	55                   	push   %ebp
    9d61:	89 e5                	mov    %esp,%ebp
    9d63:	53                   	push   %ebx
    9d64:	e8 fc ff ff ff       	call   9d65 <Mac_RlcRequest_copy+0x5>
    9d69:	89 c3                	mov    %eax,%ebx
	FIN(Mac_RlcRequest_copy(RLC_Request *temp));
	RlcBufferRequest *copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9d6b:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9d70:	e8 fc ff ff ff       	call   9d71 <Mac_RlcRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9d75:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9d78:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9d7b:	89 50 17             	mov    %edx,0x17(%eax)
	copy->lcid=temp->lcid;
    9d7e:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9d82:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9d85:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9d89:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9d8d:	8b 53 09             	mov    0x9(%ebx),%edx
    9d90:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9d93:	0f b7 13             	movzwl (%ebx),%edx
    9d96:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9d99:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9d9d:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9da1:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9da5:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9da9:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9dad:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9db1:	8b 53 03             	mov    0x3(%ebx),%edx
    9db4:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9db7:	5b                   	pop    %ebx
    9db8:	5d                   	pop    %ebp
    9db9:	c3                   	ret    
    9dba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00009dc0 <Mac_MacRequest_copy>:
->Output:RLC_Request *
->Special:
*******************************
*/
RLC_Request* Mac_MacRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9dc0:	55                   	push   %ebp
    9dc1:	89 e5                	mov    %esp,%ebp
    9dc3:	53                   	push   %ebx
    9dc4:	e8 fc ff ff ff       	call   9dc5 <Mac_MacRequest_copy+0x5>
    9dc9:	89 c3                	mov    %eax,%ebx
	FIN(Mac_MacRequest_copy(RLC_Request *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9dcb:	b8 13 00 00 00       	mov    $0x13,%eax
    9dd0:	e8 fc ff ff ff       	call   9dd1 <Mac_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9dd5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9dd9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9ddc:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9de0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9de4:	8b 53 09             	mov    0x9(%ebx),%edx
    9de7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9dea:	0f b7 13             	movzwl (%ebx),%edx
    9ded:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9df0:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9df4:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9df8:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9dfc:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9e00:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9e04:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9e08:	8b 53 03             	mov    0x3(%ebx),%edx
    9e0b:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9e0e:	5b                   	pop    %ebx
    9e0f:	5d                   	pop    %ebp
    9e10:	c3                   	ret    
    9e11:	eb 0d                	jmp    9e20 <MacBufferStatus_BSR_Info_copy>
    9e13:	90                   	nop
    9e14:	90                   	nop
    9e15:	90                   	nop
    9e16:	90                   	nop
    9e17:	90                   	nop
    9e18:	90                   	nop
    9e19:	90                   	nop
    9e1a:	90                   	nop
    9e1b:	90                   	nop
    9e1c:	90                   	nop
    9e1d:	90                   	nop
    9e1e:	90                   	nop
    9e1f:	90                   	nop

00009e20 <MacBufferStatus_BSR_Info_copy>:
->Output:MacBufferStatus_BSR_Info *
->Special:
*******************************
*/
MacBufferStatus_BSR_Info* MacBufferStatus_BSR_Info_copy(void)//BSR
{
    9e20:	55                   	push   %ebp
    9e21:	89 e5                	mov    %esp,%ebp
    9e23:	53                   	push   %ebx
    9e24:	e8 fc ff ff ff       	call   9e25 <MacBufferStatus_BSR_Info_copy+0x5>
	FIN(MacBufferStatus_BSR_Info_copy(void));
	SV_PTR_GET(rlc_mac_sv);
    9e29:	e8 fc ff ff ff       	call   9e2a <MacBufferStatus_BSR_Info_copy+0xa>
    9e2e:	89 c3                	mov    %eax,%ebx
	u32 j=0;
	MacBufferStatus_BSR_Info* copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9e30:	b8 1a 00 00 00       	mov    $0x1a,%eax
    9e35:	e8 fc ff ff ff       	call   9e36 <MacBufferStatus_BSR_Info_copy+0x16>
	/*while(copy==0)//
	{
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
    9e3a:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9e40:	8b 52 02             	mov    0x2(%edx),%edx
    9e43:	89 50 02             	mov    %edx,0x2(%eax)
	copy->m_rnti=SV(bsr)->m_rnti;
    9e46:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9e4c:	0f b7 12             	movzwl (%edx),%edx
    9e4f:	66 89 10             	mov    %dx,(%eax)
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
    9e52:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9e58:	8b 52 06             	mov    0x6(%edx),%edx
    9e5b:	89 50 06             	mov    %edx,0x6(%eax)
	for(j=0;j<LCG;j++)
    9e5e:	31 d2                	xor    %edx,%edx
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
    9e60:	8b 8b 54 01 00 00    	mov    0x154(%ebx),%ecx
    9e66:	8b 4c 91 0a          	mov    0xa(%ecx,%edx,4),%ecx
    9e6a:	89 4c 90 0a          	mov    %ecx,0xa(%eax,%edx,4)
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
	copy->m_rnti=SV(bsr)->m_rnti;
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
	for(j=0;j<LCG;j++)
    9e6e:	83 c2 01             	add    $0x1,%edx
    9e71:	83 fa 04             	cmp    $0x4,%edx
    9e74:	75 ea                	jne    9e60 <MacBufferStatus_BSR_Info_copy+0x40>
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
	FRET(copy);
}
    9e76:	5b                   	pop    %ebx
    9e77:	5d                   	pop    %ebp
    9e78:	c3                   	ret    
    9e79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009e80 <FlushBj>:
->Output:SV(LogicalChannel_Config)lcbj
->Special:lcbjMAX_BJ/8+1:
*******************************
*/
void FlushBj(void)
{
    9e80:	55                   	push   %ebp
    9e81:	89 e5                	mov    %esp,%ebp
    9e83:	57                   	push   %edi
    9e84:	56                   	push   %esi
    9e85:	53                   	push   %ebx
    9e86:	83 ec 04             	sub    $0x4,%esp
    9e89:	e8 fc ff ff ff       	call   9e8a <FlushBj+0xa>
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
    9e8e:	e8 fc ff ff ff       	call   9e8f <FlushBj+0xf>
    9e93:	89 c7                	mov    %eax,%edi
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9e95:	8b 80 44 01 00 00    	mov    0x144(%eax),%eax
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9e9b:	8b 70 05             	mov    0x5(%eax),%esi
{
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9e9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9ea1:	83 ee 05             	sub    $0x5,%esi
    9ea4:	39 f0                	cmp    %esi,%eax
    9ea6:	74 63                	je     9f0b <FlushBj+0x8b>
	{
		temp_Bj_lcid=temp->lcid;
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9ea8:	8b 8f 40 01 00 00    	mov    0x140(%edi),%ecx
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
	{
		temp_Bj_lcid=temp->lcid;
    9eae:	0f b6 1e             	movzbl (%esi),%ebx
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9eb1:	8b 51 11             	mov    0x11(%ecx),%edx
    9eb4:	8d 42 ef             	lea    -0x11(%edx),%eax
    9eb7:	39 c1                	cmp    %eax,%ecx
    9eb9:	75 0f                	jne    9eca <FlushBj+0x4a>
    9ebb:	eb 43                	jmp    9f00 <FlushBj+0x80>
    9ebd:	8d 76 00             	lea    0x0(%esi),%esi
    9ec0:	8b 50 11             	mov    0x11(%eax),%edx
    9ec3:	8d 42 ef             	lea    -0x11(%edx),%eax
    9ec6:	39 c1                	cmp    %eax,%ecx
    9ec8:	74 36                	je     9f00 <FlushBj+0x80>
		{
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
    9eca:	38 5a ef             	cmp    %bl,-0x11(%edx)
    9ecd:	75 f1                	jne    9ec0 <FlushBj+0x40>
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
    9ecf:	8b 50 05             	mov    0x5(%eax),%edx
    9ed2:	83 fa ff             	cmp    $0xffffffff,%edx
    9ed5:	74 49                	je     9f20 <FlushBj+0xa0>
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9ed7:	8b 40 09             	mov    0x9(%eax),%eax
					if(temp->lcbj < BucketSize)
    9eda:	8b 4e 01             	mov    0x1(%esi),%ecx
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9edd:	0f af c2             	imul   %edx,%eax
    9ee0:	c1 e8 03             	shr    $0x3,%eax
					if(temp->lcbj < BucketSize)
    9ee3:	0f b6 c0             	movzbl %al,%eax
    9ee6:	39 c1                	cmp    %eax,%ecx
    9ee8:	73 2e                	jae    9f18 <FlushBj+0x98>
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
    9eea:	85 d2                	test   %edx,%edx
    9eec:	8d 42 07             	lea    0x7(%edx),%eax
    9eef:	0f 48 d0             	cmovs  %eax,%edx
    9ef2:	c1 fa 03             	sar    $0x3,%edx
    9ef5:	01 ca                	add    %ecx,%edx
    9ef7:	89 56 01             	mov    %edx,0x1(%esi)
    9efa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9f00:	8b 76 05             	mov    0x5(%esi),%esi
    9f03:	83 ee 05             	sub    $0x5,%esi
    9f06:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    9f09:	75 9d                	jne    9ea8 <FlushBj+0x28>
		if(flag_tail==false)
			//fsm_printf("[UEMAC][FlushBj]FlushBj ERROR");//LogicalChannelConfigLogicalChannelConfigBj
		flag_tail=false;
	}
	FOUT;
}
    9f0b:	83 c4 04             	add    $0x4,%esp
    9f0e:	5b                   	pop    %ebx
    9f0f:	5e                   	pop    %esi
    9f10:	5f                   	pop    %edi
    9f11:	5d                   	pop    %ebp
    9f12:	c3                   	ret    
    9f13:	90                   	nop
    9f14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
					if(temp->lcbj < BucketSize)
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
					else
						temp->lcbj=BucketSize;
    9f18:	89 46 01             	mov    %eax,0x1(%esi)
    9f1b:	eb e3                	jmp    9f00 <FlushBj+0x80>
    9f1d:	8d 76 00             	lea    0x0(%esi),%esi
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
				{
					temp->lcbj=MAX_BJ/8+1;//1
    9f20:	c7 46 01 01 7d 00 00 	movl   $0x7d01,0x1(%esi)
    9f27:	eb d7                	jmp    9f00 <FlushBj+0x80>
    9f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009f30 <BufferSize2BsrSize>:
->Output:BufferSizeLevelBsrTableindex
->Special:
*******************************
*/
u32 BufferSize2BsrSize(u32 buffersize)
{
    9f30:	55                   	push   %ebp
    9f31:	89 e5                	mov    %esp,%ebp
    9f33:	53                   	push   %ebx
    9f34:	e8 fc ff ff ff       	call   9f35 <BufferSize2BsrSize+0x5>
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
    9f39:	31 d2                	xor    %edx,%edx
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9f3b:	85 c0                	test   %eax,%eax
    9f3d:	74 2b                	je     9f6a <BufferSize2BsrSize+0x3a>
    9f3f:	b2 01                	mov    $0x1,%dl
    9f41:	31 c9                	xor    %ecx,%ecx
    9f43:	eb 05                	jmp    9f4a <BufferSize2BsrSize+0x1a>
    9f45:	8d 76 00             	lea    0x0(%esi),%esi
    9f48:	89 da                	mov    %ebx,%edx
			FRET(i);
		if(BufferSizeLevelBsrTable[i]< buffersize && BufferSizeLevelBsrTable[i+1]>= buffersize)
    9f4a:	39 c8                	cmp    %ecx,%eax
    9f4c:	76 09                	jbe    9f57 <BufferSize2BsrSize+0x27>
    9f4e:	3b 04 95 40 33 00 00 	cmp    0x3340(,%edx,4),%eax
    9f55:	76 13                	jbe    9f6a <BufferSize2BsrSize+0x3a>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
    9f57:	83 fa 3f             	cmp    $0x3f,%edx
    9f5a:	74 0e                	je     9f6a <BufferSize2BsrSize+0x3a>
    9f5c:	8d 5a 01             	lea    0x1(%edx),%ebx
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9f5f:	8b 0c 9d 3c 33 00 00 	mov    0x333c(,%ebx,4),%ecx
    9f66:	39 c1                	cmp    %eax,%ecx
    9f68:	75 de                	jne    9f48 <BufferSize2BsrSize+0x18>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
			FRET(BSRTABLEINDEX-1);
	}
	FRET(-1);
}
    9f6a:	89 d0                	mov    %edx,%eax
    9f6c:	5b                   	pop    %ebx
    9f6d:	5d                   	pop    %ebp
    9f6e:	c3                   	ret    
    9f6f:	90                   	nop

00009f70 <RefreshBufferStatusForBSR>:
->Output:SV(bsr)
->Special:
*******************************
*/
void RefreshBufferStatusForBSR(void)
{
    9f70:	55                   	push   %ebp
    9f71:	89 e5                	mov    %esp,%ebp
    9f73:	57                   	push   %edi
    9f74:	56                   	push   %esi
    9f75:	53                   	push   %ebx
    9f76:	83 ec 24             	sub    $0x24,%esp
    9f79:	e8 fc ff ff ff       	call   9f7a <RefreshBufferStatusForBSR+0xa>
	LogicalChannelConfigInfo *temp_lcc_info=NULL;
	MacBufferStatus *temp=NULL;
	struct list_head *pos1=NULL,*p1=NULL;
	struct list_head *pos=NULL,*p=NULL;
	u32 queue[LCG]={0,0,0,0};//LCG
    9f7e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    9f85:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    9f8c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    9f93:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	u32 logicalchannelgroup;
	u32 i;
	bool flag_find=false;

	FIN(RefreshBufferStatusForBSR(void));
	SV_PTR_GET(rlc_mac_sv);
    9f9a:	e8 fc ff ff ff       	call   9f9b <RefreshBufferStatusForBSR+0x2b>
    9f9f:	89 c3                	mov    %eax,%ebx
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9fa1:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9fa7:	8d 50 05             	lea    0x5(%eax),%edx
    9faa:	39 50 05             	cmp    %edx,0x5(%eax)
	{
		SV(bsr)->m_lcgnum=0;
    9fad:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9fb3:	0f 84 4e 01 00 00    	je     a107 <RefreshBufferStatusForBSR+0x197>
	{
		SV(bsr)->m_lcgnum=0;
		//printk(KERN_INFO"No BSR report to transmit\n");
		FOUT;
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
    9fb9:	0f b7 13             	movzwl (%ebx),%edx
    9fbc:	66 89 10             	mov    %dx,(%eax)
	SV(bsr)->m_lcgnum=0;
    9fbf:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9fc5:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	SV(bsr)->m_TotalLcgData=0;		
    9fcc:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9fd2:	c7 40 06 00 00 00 00 	movl   $0x0,0x6(%eax)
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9fd9:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    9fdf:	8b 48 05             	mov    0x5(%eax),%ecx
    9fe2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9fe5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9fe8:	31 c0                	xor    %eax,%eax
    9fea:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    9fed:	8b 09                	mov    (%ecx),%ecx
    9fef:	83 c2 05             	add    $0x5,%edx
    9ff2:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    9ff5:	0f 84 a1 00 00 00    	je     a09c <RefreshBufferStatusForBSR+0x12c>
    9ffb:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    9ffe:	89 cb                	mov    %ecx,%ebx
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    a000:	8b 45 d8             	mov    -0x28(%ebp),%eax
    a003:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
    a009:	8b 4e 11             	mov    0x11(%esi),%ecx
    a00c:	83 c6 11             	add    $0x11,%esi
    a00f:	8b 01                	mov    (%ecx),%eax
    a011:	39 f1                	cmp    %esi,%ecx
    a013:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    a016:	74 43                	je     a05b <RefreshBufferStatusForBSR+0xeb>
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    a018:	8b 51 fc             	mov    -0x4(%ecx),%edx
    a01b:	83 fa 03             	cmp    $0x3,%edx
    a01e:	77 52                	ja     a072 <RefreshBufferStatusForBSR+0x102>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    a020:	8b 45 e0             	mov    -0x20(%ebp),%eax
    a023:	0f b6 78 fb          	movzbl -0x5(%eax),%edi
    a027:	89 f8                	mov    %edi,%eax
    a029:	3a 41 ef             	cmp    -0x11(%ecx),%al
    a02c:	0f 84 a8 00 00 00    	je     a0da <RefreshBufferStatusForBSR+0x16a>
    a032:	89 fa                	mov    %edi,%edx
    a034:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    a037:	89 df                	mov    %ebx,%edi
    a039:	89 d3                	mov    %edx,%ebx
    a03b:	eb 16                	jmp    a053 <RefreshBufferStatusForBSR+0xe3>
    a03d:	8d 76 00             	lea    0x0(%esi),%esi
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    a040:	8b 50 fc             	mov    -0x4(%eax),%edx
    a043:	83 fa 03             	cmp    $0x3,%edx
    a046:	77 28                	ja     a070 <RefreshBufferStatusForBSR+0x100>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    a048:	38 58 ef             	cmp    %bl,-0x11(%eax)
    a04b:	0f 84 87 00 00 00    	je     a0d8 <RefreshBufferStatusForBSR+0x168>
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    a051:	89 c8                	mov    %ecx,%eax
    a053:	39 c6                	cmp    %eax,%esi
    a055:	8b 08                	mov    (%eax),%ecx
    a057:	75 e7                	jne    a040 <RefreshBufferStatusForBSR+0xd0>
    a059:	89 fb                	mov    %edi,%ebx
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    a05b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    a05e:	8b 13                	mov    (%ebx),%edx
    a060:	83 c0 05             	add    $0x5,%eax
    a063:	39 c3                	cmp    %eax,%ebx
    a065:	74 2f                	je     a096 <RefreshBufferStatusForBSR+0x126>
    a067:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    a06a:	89 d3                	mov    %edx,%ebx
    a06c:	eb 92                	jmp    a000 <RefreshBufferStatusForBSR+0x90>
    a06e:	66 90                	xchg   %ax,%ax
    a070:	89 fb                	mov    %edi,%ebx
					break;
				}
			}
			else
			{
				fsm_printf("[UEMAC][refreshBSR]:lc_group error\n");
    a072:	c7 04 24 b8 2d 00 00 	movl   $0x2db8,(%esp)
    a079:	e8 fc ff ff ff       	call   a07a <RefreshBufferStatusForBSR+0x10a>
    a07e:	8b 45 d8             	mov    -0x28(%ebp),%eax
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    a081:	8b 13                	mov    (%ebx),%edx
    a083:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    a089:	89 45 dc             	mov    %eax,-0x24(%ebp)
    a08c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    a08f:	83 c0 05             	add    $0x5,%eax
    a092:	39 c3                	cmp    %eax,%ebx
    a094:	75 d1                	jne    a067 <RefreshBufferStatusForBSR+0xf7>
    a096:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    a099:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    a09c:	31 f6                	xor    %esi,%esi
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
	{
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
    a09e:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    a0a4:	01 42 06             	add    %eax,0x6(%edx)
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
    a0a7:	8b bb 54 01 00 00    	mov    0x154(%ebx),%edi
    a0ad:	e8 fc ff ff ff       	call   a0ae <RefreshBufferStatusForBSR+0x13e>
    a0b2:	89 44 b7 0a          	mov    %eax,0xa(%edi,%esi,4)
		if((SV(bsr)->m_bufferStatus[i])!=0)
    a0b6:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a0bc:	8b 54 b0 0a          	mov    0xa(%eax,%esi,4),%edx
    a0c0:	85 d2                	test   %edx,%edx
    a0c2:	74 04                	je     a0c8 <RefreshBufferStatusForBSR+0x158>
			SV(bsr)->m_lcgnum++;
    a0c4:	83 40 02 01          	addl   $0x1,0x2(%eax)
		
		if(flag_find==false)
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
    a0c8:	83 c6 01             	add    $0x1,%esi
    a0cb:	83 fe 04             	cmp    $0x4,%esi
    a0ce:	74 40                	je     a110 <RefreshBufferStatusForBSR+0x1a0>
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    a0d0:	8b 44 b5 e4          	mov    -0x1c(%ebp,%esi,4),%eax
    a0d4:	eb c8                	jmp    a09e <RefreshBufferStatusForBSR+0x12e>
    a0d6:	66 90                	xchg   %ax,%ax
    a0d8:	89 fb                	mov    %edi,%ebx
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
			{
				if(temp->lcid==temp_lcc_info->lcid)
				{
					logicalchannelgroup=temp_lcc_info->logicalChannelGroup;
					queue[logicalchannelgroup] =queue[logicalchannelgroup] + temp->RlcRequestparams->retxQueueHeader + temp->RlcRequestparams->retxQueueSize + temp->RlcRequestparams->statusPduHeader \
    a0da:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    a0dd:	8b 41 fc             	mov    -0x4(%ecx),%eax
    a0e0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
    a0e4:	8b 48 03             	mov    0x3(%eax),%ecx
    a0e7:	03 48 09             	add    0x9(%eax),%ecx
    a0ea:	01 f1                	add    %esi,%ecx
    a0ec:	0f b7 70 11          	movzwl 0x11(%eax),%esi
    a0f0:	01 f1                	add    %esi,%ecx
					+ temp->RlcRequestparams->statusPduSize + temp->RlcRequestparams->txQueueHeader + temp->RlcRequestparams->txQueueSize;
    a0f2:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    a0f6:	0f b7 40 07          	movzwl 0x7(%eax),%eax
    a0fa:	01 f1                	add    %esi,%ecx
    a0fc:	01 c1                	add    %eax,%ecx
    a0fe:	01 4c 95 e4          	add    %ecx,-0x1c(%ebp,%edx,4)
					flag_find=true;
					break;
    a102:	e9 54 ff ff ff       	jmp    a05b <RefreshBufferStatusForBSR+0xeb>
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
	{
		SV(bsr)->m_lcgnum=0;
    a107:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
    a10e:	66 90                	xchg   %ax,%ax
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
		if((SV(bsr)->m_bufferStatus[i])!=0)
			SV(bsr)->m_lcgnum++;
	}
}
    a110:	83 c4 24             	add    $0x24,%esp
    a113:	5b                   	pop    %ebx
    a114:	5e                   	pop    %esi
    a115:	5f                   	pop    %edi
    a116:	5d                   	pop    %ebp
    a117:	c3                   	ret    
    a118:	90                   	nop
    a119:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a120 <GetTBsize_Allocation>:
->Output:
->Special:
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
    a120:	55                   	push   %ebp
    a121:	89 e5                	mov    %esp,%ebp
    a123:	83 ec 08             	sub    $0x8,%esp
    a126:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    a129:	89 75 fc             	mov    %esi,-0x4(%ebp)
    a12c:	e8 fc ff ff ff       	call   a12d <GetTBsize_Allocation+0xd>
    a131:	89 c3                	mov    %eax,%ebx
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    a133:	e8 fc ff ff ff       	call   a134 <GetTBsize_Allocation+0x14>
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    a138:	c1 eb 03             	shr    $0x3,%ebx
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    a13b:	89 c6                	mov    %eax,%esi
	RefreshBufferStatusForBSR();
    a13d:	e8 fc ff ff ff       	call   a13e <GetTBsize_Allocation+0x1e>
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    a142:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
    a148:	3b 58 06             	cmp    0x6(%eax),%ebx
    a14b:	72 13                	jb     a160 <GetTBsize_Allocation+0x40>
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
	}
	else
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
    a14d:	c6 86 59 01 00 00 00 	movb   $0x0,0x159(%esi)
		FRET((tbsize)/8);
	}
}
    a154:	89 d8                	mov    %ebx,%eax
    a156:	8b 75 fc             	mov    -0x4(%ebp),%esi
    a159:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    a15c:	89 ec                	mov    %ebp,%esp
    a15e:	5d                   	pop    %ebp
    a15f:	c3                   	ret    
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=true;
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
    a160:	83 eb 04             	sub    $0x4,%ebx
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
		FRET((tbsize)/8);
	}
}
    a163:	8b 75 fc             	mov    -0x4(%ebp),%esi
    a166:	89 d8                	mov    %ebx,%eax
    a168:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    a16b:	89 ec                	mov    %ebp,%esp
    a16d:	5d                   	pop    %ebp
    a16e:	c3                   	ret    
    a16f:	90                   	nop

0000a170 <DoRefreshRLCBuffserRequest>:
->Output:SV(MacBuffer_RLC) :MAC
->Special:
*******************************
*/
void DoRefreshRLCBuffserRequest (RlcBufferRequest* params)	//
{
    a170:	55                   	push   %ebp
    a171:	89 e5                	mov    %esp,%ebp
    a173:	57                   	push   %edi
    a174:	56                   	push   %esi
    a175:	53                   	push   %ebx
    a176:	83 ec 14             	sub    $0x14,%esp
    a179:	e8 fc ff ff ff       	call   a17a <DoRefreshRLCBuffserRequest+0xa>
    a17e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos,*p;
	u8 temp_lcid,temp_mac_bufferstatus_lcid;
	FIN(DoRefreshRLCBuffserRequest(RlcBufferRequest* params));
	
	SV_PTR_GET(rlc_mac_sv);
    a181:	e8 fc ff ff ff       	call   a182 <DoRefreshRLCBuffserRequest+0x12>
    a186:	89 45 f0             	mov    %eax,-0x10(%ebp)
	MacBufferStatus *temp_mac_bufferstatus=NULL;
	MacBufferStatus *temp_mac_findno=NULL;	
	bool flag=false;

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
    a189:	e8 fc ff ff ff       	call   a18a <DoRefreshRLCBuffserRequest+0x1a>
	if (SV(bsr)->m_lcgnum==0)
    a18e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a191:	8b 82 54 01 00 00    	mov    0x154(%edx),%eax
    a197:	8b 48 02             	mov    0x2(%eax),%ecx
    a19a:	85 c9                	test   %ecx,%ecx
    a19c:	75 07                	jne    a1a5 <DoRefreshRLCBuffserRequest+0x35>
		SV(LCGZeroToData)=true;
    a19e:	c6 82 58 01 00 00 01 	movb   $0x1,0x158(%edx)
	SV(DATA_WAIT_ALLOCATION)=true;
    a1a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
	list_for_each_safe(pos,p,&(RLChead->list))//
    a1a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
    a1ab:	c6 80 5a 01 00 00 01 	movb   $0x1,0x15a(%eax)
	list_for_each_safe(pos,p,&(RLChead->list))//
    a1b2:	8b 42 13             	mov    0x13(%edx),%eax
    a1b5:	83 c2 13             	add    $0x13,%edx
    a1b8:	89 55 e8             	mov    %edx,-0x18(%ebp)
    a1bb:	39 d0                	cmp    %edx,%eax
    a1bd:	8b 38                	mov    (%eax),%edi
    a1bf:	0f 84 ea 00 00 00    	je     a2af <DoRefreshRLCBuffserRequest+0x13f>
    a1c5:	8d 76 00             	lea    0x0(%esi),%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    a1c8:	8d 48 ed             	lea    -0x13(%eax),%ecx
		temp_lcid=temp->lcid;
    a1cb:	0f b6 58 ef          	movzbl -0x11(%eax),%ebx
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    a1cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    a1d2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		temp_lcid=temp->lcid;
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    a1d5:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a1db:	8b 42 05             	mov    0x5(%edx),%eax
    a1de:	8d 70 fb             	lea    -0x5(%eax),%esi
    a1e1:	39 f2                	cmp    %esi,%edx
    a1e3:	75 0d                	jne    a1f2 <DoRefreshRLCBuffserRequest+0x82>
    a1e5:	eb 39                	jmp    a220 <DoRefreshRLCBuffserRequest+0xb0>
    a1e7:	90                   	nop
    a1e8:	8b 46 05             	mov    0x5(%esi),%eax
    a1eb:	8d 70 fb             	lea    -0x5(%eax),%esi
    a1ee:	39 f2                	cmp    %esi,%edx
    a1f0:	74 2e                	je     a220 <DoRefreshRLCBuffserRequest+0xb0>
		{
			temp_mac_bufferstatus_lcid=temp_mac_bufferstatus->lcid;
			if(temp_lcid==temp_mac_bufferstatus_lcid)
    a1f2:	3a 58 fb             	cmp    -0x5(%eax),%bl
    a1f5:	75 f1                	jne    a1e8 <DoRefreshRLCBuffserRequest+0x78>
			{
				temp_mac_bufferstatus->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a1f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a1fa:	e8 fc ff ff ff       	call   a1fb <DoRefreshRLCBuffserRequest+0x8b>
    a1ff:	89 46 01             	mov    %eax,0x1(%esi)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    a202:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a205:	39 7d e8             	cmp    %edi,-0x18(%ebp)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    a208:	c6 80 59 01 00 00 01 	movb   $0x1,0x159(%eax)
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a20f:	8b 17                	mov    (%edi),%edx
    a211:	74 65                	je     a278 <DoRefreshRLCBuffserRequest+0x108>
    a213:	89 f8                	mov    %edi,%eax
    a215:	89 d7                	mov    %edx,%edi
    a217:	eb af                	jmp    a1c8 <DoRefreshRLCBuffserRequest+0x58>
    a219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a220:	b8 0d 00 00 00       	mov    $0xd,%eax
    a225:	e8 fc ff ff ff       	call   a226 <DoRefreshRLCBuffserRequest+0xb6>
			while(temp_mac_findno==0)//
    a22a:	85 c0                	test   %eax,%eax
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a22c:	89 c6                	mov    %eax,%esi
			while(temp_mac_findno==0)//
    a22e:	75 10                	jne    a240 <DoRefreshRLCBuffserRequest+0xd0>
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a230:	b8 0d 00 00 00       	mov    $0xd,%eax
    a235:	e8 fc ff ff ff       	call   a236 <DoRefreshRLCBuffserRequest+0xc6>
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
    a23a:	85 c0                	test   %eax,%eax
    a23c:	74 f2                	je     a230 <DoRefreshRLCBuffserRequest+0xc0>
    a23e:	89 c6                	mov    %eax,%esi
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a240:	8b 45 ec             	mov    -0x14(%ebp),%eax
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
    a243:	8d 56 05             	lea    0x5(%esi),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a246:	89 56 05             	mov    %edx,0x5(%esi)
	list->prev = list;
    a249:	89 56 09             	mov    %edx,0x9(%esi)
			temp_mac_findno->lcid=temp_lcid;
    a24c:	88 1e                	mov    %bl,(%esi)
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a24e:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a251:	e8 fc ff ff ff       	call   a252 <DoRefreshRLCBuffserRequest+0xe2>
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    a256:	8b 4d f0             	mov    -0x10(%ebp),%ecx
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a259:	89 46 01             	mov    %eax,0x1(%esi)
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    a25c:	8b 81 48 01 00 00    	mov    0x148(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a262:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a265:	8b 48 09             	mov    0x9(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a268:	89 50 09             	mov    %edx,0x9(%eax)
    a26b:	83 c0 05             	add    $0x5,%eax
    a26e:	89 46 05             	mov    %eax,0x5(%esi)
	new->next = next;
	new->prev = prev;
    a271:	89 4e 09             	mov    %ecx,0x9(%esi)
	prev->next = new;
    a274:	89 11                	mov    %edx,(%ecx)
    a276:	eb 8a                	jmp    a202 <DoRefreshRLCBuffserRequest+0x92>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a278:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a27b:	8b 50 13             	mov    0x13(%eax),%edx
    a27e:	3b 55 e8             	cmp    -0x18(%ebp),%edx
    a281:	8b 1a                	mov    (%edx),%ebx
    a283:	74 2a                	je     a2af <DoRefreshRLCBuffserRequest+0x13f>
    a285:	89 d9                	mov    %ebx,%ecx
    a287:	8b 75 e8             	mov    -0x18(%ebp),%esi
    a28a:	eb 08                	jmp    a294 <DoRefreshRLCBuffserRequest+0x124>
    a28c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a290:	89 da                	mov    %ebx,%edx
    a292:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a294:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    a297:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a29a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a29d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a29f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a2a1:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);
    a2a4:	e8 fc ff ff ff       	call   a2a5 <DoRefreshRLCBuffserRequest+0x135>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a2a9:	39 f3                	cmp    %esi,%ebx
    a2ab:	8b 0b                	mov    (%ebx),%ecx
    a2ad:	75 e1                	jne    a290 <DoRefreshRLCBuffserRequest+0x120>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);
	}
	fsm_mem_free(RLChead);
    a2af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a2b2:	e8 fc ff ff ff       	call   a2b3 <DoRefreshRLCBuffserRequest+0x143>
	FOUT;
}
    a2b7:	83 c4 14             	add    $0x14,%esp
    a2ba:	5b                   	pop    %ebx
    a2bb:	5e                   	pop    %esi
    a2bc:	5f                   	pop    %edi
    a2bd:	5d                   	pop    %ebp
    a2be:	c3                   	ret    
    a2bf:	90                   	nop

0000a2c0 <LogicalChannel_ConfigInfo_Rank_Priority>:
->Output:LogicalChannelConfigInfo 
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_Rank_Priority()
{
    a2c0:	55                   	push   %ebp
    a2c1:	89 e5                	mov    %esp,%ebp
    a2c3:	57                   	push   %edi
    a2c4:	56                   	push   %esi
    a2c5:	53                   	push   %ebx
    a2c6:	83 ec 0c             	sub    $0xc,%esp
    a2c9:	e8 fc ff ff ff       	call   a2ca <LogicalChannel_ConfigInfo_Rank_Priority+0xa>
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
    a2ce:	e8 fc ff ff ff       	call   a2cf <LogicalChannel_ConfigInfo_Rank_Priority+0xf>
    a2d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a2d6:	b8 19 00 00 00       	mov    $0x19,%eax
    a2db:	e8 fc ff ff ff       	call   a2dc <LogicalChannel_ConfigInfo_Rank_Priority+0x1c>
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a2e0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a2e3:	8d 50 11             	lea    0x11(%eax),%edx
{
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a2e6:	89 c3                	mov    %eax,%ebx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a2e8:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a2eb:	89 50 15             	mov    %edx,0x15(%eax)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a2ee:	8b 81 40 01 00 00    	mov    0x140(%ecx),%eax
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a2f4:	89 55 ec             	mov    %edx,-0x14(%ebp)
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a2f7:	8b 70 11             	mov    0x11(%eax),%esi
    a2fa:	83 ee 11             	sub    $0x11,%esi
    a2fd:	39 f0                	cmp    %esi,%eax
    a2ff:	0f 84 7f 00 00 00    	je     a384 <LogicalChannel_ConfigInfo_Rank_Priority+0xc4>
    a305:	8d 76 00             	lea    0x0(%esi),%esi
	{
		next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a308:	b8 19 00 00 00       	mov    $0x19,%eax
    a30d:	e8 fc ff ff ff       	call   a30e <LogicalChannel_ConfigInfo_Rank_Priority+0x4e>
		/*while(next_node==0)//
		{
			next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
		}*/
		next_node->lcid=temp->lcid;
    a312:	0f b6 16             	movzbl (%esi),%edx
    a315:	88 10                	mov    %dl,(%eax)
		next_node->priority=temp->priority;
    a317:	8b 7e 01             	mov    0x1(%esi),%edi
    a31a:	89 78 01             	mov    %edi,0x1(%eax)
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
    a31d:	8b 56 05             	mov    0x5(%esi),%edx
    a320:	89 50 05             	mov    %edx,0x5(%eax)
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
    a323:	8b 56 09             	mov    0x9(%esi),%edx
    a326:	89 50 09             	mov    %edx,0x9(%eax)
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
    a329:	8b 56 0d             	mov    0xd(%esi),%edx
    a32c:	89 50 0d             	mov    %edx,0xd(%eax)
		INIT_LIST_HEAD(&(next_node->list));
    a32f:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a332:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a335:	89 50 15             	mov    %edx,0x15(%eax)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    a338:	8b 4b 11             	mov    0x11(%ebx),%ecx
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a33b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
		next_node->lcid=temp->lcid;
		next_node->priority=temp->priority;
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
		INIT_LIST_HEAD(&(next_node->list));
    a33e:	89 55 f0             	mov    %edx,-0x10(%ebp)
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a341:	74 4d                	je     a390 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			else
			{
				flag_add=false;
				list_for_each_entry(temp_next, &(lcc_info_priority->list),list)//
    a343:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a346:	39 d3                	cmp    %edx,%ebx
    a348:	75 10                	jne    a35a <LogicalChannel_ConfigInfo_Rank_Priority+0x9a>
    a34a:	eb 44                	jmp    a390 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
    a34c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a350:	8b 4a 11             	mov    0x11(%edx),%ecx
    a353:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a356:	39 d3                	cmp    %edx,%ebx
    a358:	74 36                	je     a390 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				{
					//  if(temp_next->prioritizedBitRateKbps==-1)
						//  continue;
					if ((next_node->priority) <= (temp_next->priority))
    a35a:	3b 79 f0             	cmp    -0x10(%ecx),%edi
    a35d:	7f f1                	jg     a350 <LogicalChannel_ConfigInfo_Rank_Priority+0x90>
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a35f:	8b 7d f0             	mov    -0x10(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a362:	8b 4a 15             	mov    0x15(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a365:	89 7a 15             	mov    %edi,0x15(%edx)
					{
						list_add_tail(&(next_node->list), &(temp_next->list));
    a368:	83 c2 11             	add    $0x11,%edx
    a36b:	89 50 11             	mov    %edx,0x11(%eax)
	new->next = next;
	new->prev = prev;
    a36e:	89 48 15             	mov    %ecx,0x15(%eax)
	prev->next = new;
    a371:	89 39                	mov    %edi,(%ecx)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a373:	8b 76 11             	mov    0x11(%esi),%esi
    a376:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a379:	83 ee 11             	sub    $0x11,%esi
    a37c:	39 b0 40 01 00 00    	cmp    %esi,0x140(%eax)
    a382:	75 84                	jne    a308 <LogicalChannel_ConfigInfo_Rank_Priority+0x48>
					list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			}

	}
	FRET(lcc_info_priority);
}
    a384:	83 c4 0c             	add    $0xc,%esp
    a387:	89 d8                	mov    %ebx,%eax
    a389:	5b                   	pop    %ebx
    a38a:	5e                   	pop    %esi
    a38b:	5f                   	pop    %edi
    a38c:	5d                   	pop    %ebp
    a38d:	c3                   	ret    
    a38e:	66 90                	xchg   %ax,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a390:	8b 53 15             	mov    0x15(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a393:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	new->next = next;
    a396:	8b 7d ec             	mov    -0x14(%ebp),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a399:	89 4b 15             	mov    %ecx,0x15(%ebx)
	new->next = next;
    a39c:	89 78 11             	mov    %edi,0x11(%eax)
	new->prev = prev;
    a39f:	89 50 15             	mov    %edx,0x15(%eax)
	prev->next = new;
    a3a2:	89 0a                	mov    %ecx,(%edx)
    a3a4:	eb cd                	jmp    a373 <LogicalChannel_ConfigInfo_Rank_Priority+0xb3>
    a3a6:	8d 76 00             	lea    0x0(%esi),%esi
    a3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a3b0 <PrioritySort>:
->Output:MacBufferStatus *:SV(MacBuffer_RLC)
->Special:
*******************************
*/
MacBufferStatus* PrioritySort(void)
{
    a3b0:	55                   	push   %ebp
    a3b1:	89 e5                	mov    %esp,%ebp
    a3b3:	57                   	push   %edi
    a3b4:	56                   	push   %esi
    a3b5:	53                   	push   %ebx
    a3b6:	83 ec 14             	sub    $0x14,%esp
    a3b9:	e8 fc ff ff ff       	call   a3ba <PrioritySort+0xa>
	u8 temp_Bj_lcid;
	MacBufferStatus *temp_node;
	struct list_head *pos,*p;

	FIN(PrioritySort(void));
	SV_PTR_GET(rlc_mac_sv);
    a3be:	e8 fc ff ff ff       	call   a3bf <PrioritySort+0xf>
    a3c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *Priority_logicalChannel=NULL,*temp_logicalChannel=NULL;
	MacBufferStatus *PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus)),*temp_mbs=NULL;
    a3c6:	b8 0d 00 00 00       	mov    $0xd,%eax
    a3cb:	e8 fc ff ff ff       	call   a3cc <PrioritySort+0x1c>
    a3d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a3d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(PriorityMacBufferStatus==0)//
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
    a3d6:	83 c0 05             	add    $0x5,%eax
    a3d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a3dc:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    a3df:	89 42 09             	mov    %eax,0x9(%edx)
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a3e2:	e8 fc ff ff ff       	call   a3e3 <PrioritySort+0x33>
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a3e7:	8b 50 11             	mov    0x11(%eax),%edx
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a3ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a3ed:	8d 72 ef             	lea    -0x11(%edx),%esi
    a3f0:	39 f0                	cmp    %esi,%eax
    a3f2:	74 7b                	je     a46f <PrioritySort+0xbf>
    a3f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a3f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
    a3fb:	0f b6 0e             	movzbl (%esi),%ecx
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a3fe:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a404:	8b 42 05             	mov    0x5(%edx),%eax
    a407:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a40a:	39 da                	cmp    %ebx,%edx
    a40c:	75 0c                	jne    a41a <PrioritySort+0x6a>
    a40e:	eb 4e                	jmp    a45e <PrioritySort+0xae>
    a410:	8b 43 05             	mov    0x5(%ebx),%eax
    a413:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a416:	39 da                	cmp    %ebx,%edx
    a418:	74 44                	je     a45e <PrioritySort+0xae>
		{
			if(temp_Bj_lcid==temp_node->lcid)
    a41a:	38 48 fb             	cmp    %cl,-0x5(%eax)
    a41d:	75 f1                	jne    a410 <PrioritySort+0x60>
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a41f:	b8 0d 00 00 00       	mov    $0xd,%eax
    a424:	e8 fc ff ff ff       	call   a425 <PrioritySort+0x75>
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
    a429:	8d 50 05             	lea    0x5(%eax),%edx
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
		{
			if(temp_Bj_lcid==temp_node->lcid)
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a42c:	89 c7                	mov    %eax,%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a42e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a431:	89 50 09             	mov    %edx,0x9(%eax)
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
				temp_mbs->lcid=temp_node->lcid;
    a434:	0f b6 03             	movzbl (%ebx),%eax
    a437:	88 07                	mov    %al,(%edi)
				temp_mbs->RlcRequestparams=Mac_MacRequest_copy(temp_node->RlcRequestparams);
    a439:	8b 43 01             	mov    0x1(%ebx),%eax
    a43c:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a43f:	e8 fc ff ff ff       	call   a440 <PrioritySort+0x90>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a444:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a447:	89 47 01             	mov    %eax,0x1(%edi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a44a:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a44d:	8b 41 09             	mov    0x9(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a450:	89 51 09             	mov    %edx,0x9(%ecx)
	new->next = next;
    a453:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	new->prev = prev;
    a456:	89 47 09             	mov    %eax,0x9(%edi)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    a459:	89 4f 05             	mov    %ecx,0x5(%edi)
	new->prev = prev;
	prev->next = new;
    a45c:	89 10                	mov    %edx,(%eax)
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a45e:	8b 76 11             	mov    0x11(%esi),%esi
    a461:	83 ee 11             	sub    $0x11,%esi
    a464:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a467:	75 8f                	jne    a3f8 <PrioritySort+0x48>
    a469:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a46c:	8b 50 11             	mov    0x11(%eax),%edx
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a46f:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a472:	8b 1a                	mov    (%edx),%ebx
    a474:	83 c6 11             	add    $0x11,%esi
    a477:	39 f2                	cmp    %esi,%edx
    a479:	89 d9                	mov    %ebx,%ecx
    a47b:	75 07                	jne    a484 <PrioritySort+0xd4>
    a47d:	eb 20                	jmp    a49f <PrioritySort+0xef>
    a47f:	90                   	nop
    a480:	89 da                	mov    %ebx,%edx
    a482:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a484:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
    a487:	8d 42 ef             	lea    -0x11(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a48a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a48d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a48f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a491:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp_logicalChannel);//
    a494:	e8 fc ff ff ff       	call   a495 <PrioritySort+0xe5>
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a499:	39 de                	cmp    %ebx,%esi
    a49b:	8b 0b                	mov    (%ebx),%ecx
    a49d:	75 e1                	jne    a480 <PrioritySort+0xd0>
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
		fsm_mem_free(temp_logicalChannel);//
	}
	fsm_mem_free(Priority_logicalChannel);
    a49f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a4a2:	e8 fc ff ff ff       	call   a4a3 <PrioritySort+0xf3>
	FRET(PriorityMacBufferStatus);
}
    a4a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a4aa:	83 c4 14             	add    $0x14,%esp
    a4ad:	5b                   	pop    %ebx
    a4ae:	5e                   	pop    %esi
    a4af:	5f                   	pop    %edi
    a4b0:	5d                   	pop    %ebp
    a4b1:	c3                   	ret    
    a4b2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    a4b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a4c0 <DoProduceBsr_LCGZeroToData>:
->Output: SV(Regularbsr) :BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
    a4c0:	55                   	push   %ebp
    a4c1:	89 e5                	mov    %esp,%ebp
    a4c3:	53                   	push   %ebx
    a4c4:	e8 fc ff ff ff       	call   a4c5 <DoProduceBsr_LCGZeroToData+0x5>
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a4c9:	e8 fc ff ff ff       	call   a4ca <DoProduceBsr_LCGZeroToData+0xa>
	if(SV(LCGZeroToData) == true)
    a4ce:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a4d5:	89 c3                	mov    %eax,%ebx
	if(SV(LCGZeroToData) == true)
    a4d7:	75 0f                	jne    a4e8 <DoProduceBsr_LCGZeroToData+0x28>
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a4d9:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a4e0:	5b                   	pop    %ebx
    a4e1:	5d                   	pop    %ebp
    a4e2:	c3                   	ret    
    a4e3:	90                   	nop
    a4e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(LCGZeroToData) == true)
	{
		RefreshBufferStatusForBSR();
    a4e8:	e8 fc ff ff ff       	call   a4e9 <DoProduceBsr_LCGZeroToData+0x29>
		if (SV(bsr)!=NULL)
    a4ed:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a4f3:	85 c0                	test   %eax,%eax
    a4f5:	74 e2                	je     a4d9 <DoProduceBsr_LCGZeroToData+0x19>
		{
			//fsm_printf("[UEMAC][BSR]have BSR\n");
			if(SV(Regularbsr)!=NULL)
    a4f7:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a4fd:	85 c0                	test   %eax,%eax
    a4ff:	74 0f                	je     a510 <DoProduceBsr_LCGZeroToData+0x50>
			{
				fsm_mem_free(SV(Regularbsr));//Regularbsr
    a501:	e8 fc ff ff ff       	call   a502 <DoProduceBsr_LCGZeroToData+0x42>
				SV(Regularbsr)=NULL;
    a506:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a50d:	00 00 00 
			}
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a510:	e8 fc ff ff ff       	call   a511 <DoProduceBsr_LCGZeroToData+0x51>
    a515:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
			if((SV(Regularbsr)->m_lcgnum) >1)
    a51b:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a51f:	76 1f                	jbe    a540 <DoProduceBsr_LCGZeroToData+0x80>
			{
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a521:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a528:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a52f:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a535:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a53c:	5b                   	pop    %ebx
    a53d:	5d                   	pop    %ebp
    a53e:	c3                   	ret    
    a53f:	90                   	nop
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR long:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
			else if((SV(Regularbsr)->m_lcgnum) ==1)
    a540:	75 97                	jne    a4d9 <DoProduceBsr_LCGZeroToData+0x19>
			{
				SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a542:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a549:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a550:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
    a556:	eb 81                	jmp    a4d9 <DoProduceBsr_LCGZeroToData+0x19>
    a558:	90                   	nop
    a559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a560 <DoProduceBsr_PeriodicBSRTimer>:
->Output: SV(Periodicbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
    a560:	55                   	push   %ebp
    a561:	89 e5                	mov    %esp,%ebp
    a563:	53                   	push   %ebx
    a564:	e8 fc ff ff ff       	call   a565 <DoProduceBsr_PeriodicBSRTimer+0x5>
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a569:	e8 fc ff ff ff       	call   a56a <DoProduceBsr_PeriodicBSRTimer+0xa>
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a56e:	80 b8 59 01 00 00 00 	cmpb   $0x0,0x159(%eax)
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a575:	89 c3                	mov    %eax,%ebx
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a577:	75 07                	jne    a580 <DoProduceBsr_PeriodicBSRTimer+0x20>
			}
		}
		SV(m_freshUlBsr)=false;
	}
	FOUT;
}
    a579:	5b                   	pop    %ebx
    a57a:	5d                   	pop    %ebp
    a57b:	c3                   	ret    
    a57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
	{
		RefreshBufferStatusForBSR ();
    a580:	e8 fc ff ff ff       	call   a581 <DoProduceBsr_PeriodicBSRTimer+0x21>
		if (SV(bsr)!=NULL)
    a585:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a58b:	85 c0                	test   %eax,%eax
    a58d:	74 34                	je     a5c3 <DoProduceBsr_PeriodicBSRTimer+0x63>
		{
			if(SV(Periodicbsr)==NULL)
    a58f:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a595:	85 c0                	test   %eax,%eax
    a597:	74 05                	je     a59e <DoProduceBsr_PeriodicBSRTimer+0x3e>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();
			else
			{
				fsm_mem_free(SV(Periodicbsr));//Regularbsr
    a599:	e8 fc ff ff ff       	call   a59a <DoProduceBsr_PeriodicBSRTimer+0x3a>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();//
    a59e:	e8 fc ff ff ff       	call   a59f <DoProduceBsr_PeriodicBSRTimer+0x3f>
    a5a3:	89 83 50 01 00 00    	mov    %eax,0x150(%ebx)
			}
			// if(SV(ALLOCATION_RESOURCE_BSR_INFO)==true)
			// {
			if((SV(Periodicbsr)->m_lcgnum) >1)
    a5a9:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a5ad:	76 21                	jbe    a5d0 <DoProduceBsr_PeriodicBSRTimer+0x70>
			{
				SV(MAC_CE_Tags)[period_longBSR_CE].addinPDU_flag=true;
    a5af:	c6 83 dc 01 00 00 01 	movb   $0x1,0x1dc(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
    a5b6:	c6 83 dd 01 00 00 1e 	movb   $0x1e,0x1dd(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a5bd:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
		}
		SV(m_freshUlBsr)=false;
    a5c3:	c6 83 59 01 00 00 00 	movb   $0x0,0x159(%ebx)
	}
	FOUT;
}
    a5ca:	5b                   	pop    %ebx
    a5cb:	5d                   	pop    %ebp
    a5cc:	c3                   	ret    
    a5cd:	8d 76 00             	lea    0x0(%esi),%esi
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
			else
			{
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
    a5d0:	c6 83 d4 01 00 00 01 	movb   $0x1,0x1d4(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a5d7:	c6 83 d5 01 00 00 1d 	movb   $0x1d,0x1d5(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a5de:	89 83 d8 01 00 00    	mov    %eax,0x1d8(%ebx)
    a5e4:	eb dd                	jmp    a5c3 <DoProduceBsr_PeriodicBSRTimer+0x63>
    a5e6:	8d 76 00             	lea    0x0(%esi),%esi
    a5e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a5f0 <DoProduceBsr_RetxBSRTimer>:
->Output: SV(Regularbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_RetxBSRTimer(void)
{
    a5f0:	55                   	push   %ebp
    a5f1:	89 e5                	mov    %esp,%ebp
    a5f3:	53                   	push   %ebx
    a5f4:	e8 fc ff ff ff       	call   a5f5 <DoProduceBsr_RetxBSRTimer+0x5>
	FIN(DoProduceBsr_RetxBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a5f9:	e8 fc ff ff ff       	call   a5fa <DoProduceBsr_RetxBSRTimer+0xa>
    a5fe:	89 c3                	mov    %eax,%ebx
	if(list_empty((&(SV(MacBuffer_RLC)->list))))//BSRTTI BSR
    a600:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    a606:	8d 50 05             	lea    0x5(%eax),%edx
    a609:	39 50 05             	cmp    %edx,0x5(%eax)
    a60c:	74 43                	je     a651 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		FOUT;
	}
	RefreshBufferStatusForBSR ();
    a60e:	e8 fc ff ff ff       	call   a60f <DoProduceBsr_RetxBSRTimer+0x1f>
	if (SV(bsr)!=NULL)
    a613:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a619:	85 c0                	test   %eax,%eax
    a61b:	74 34                	je     a651 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		if(SV(Regularbsr)==NULL)//Regularbsr
    a61d:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a623:	85 c0                	test   %eax,%eax
    a625:	74 05                	je     a62c <DoProduceBsr_RetxBSRTimer+0x3c>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();
		else
		{
			fsm_mem_free(SV(Regularbsr));//Regularbsr
    a627:	e8 fc ff ff ff       	call   a628 <DoProduceBsr_RetxBSRTimer+0x38>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a62c:	e8 fc ff ff ff       	call   a62d <DoProduceBsr_RetxBSRTimer+0x3d>
    a631:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
		}
		if((SV(Regularbsr)->m_lcgnum) >1)
    a637:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a63b:	76 1b                	jbe    a658 <DoProduceBsr_RetxBSRTimer+0x68>
		{
			SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a63d:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a644:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a64b:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
	}
	FOUT;
}
    a651:	5b                   	pop    %ebx
    a652:	5d                   	pop    %ebp
    a653:	c3                   	ret    
    a654:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
		else
		{
			SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a658:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a65f:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a666:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
		}
	}
	FOUT;
}
    a66c:	5b                   	pop    %ebx
    a66d:	5d                   	pop    %ebp
    a66e:	c3                   	ret    
    a66f:	90                   	nop

0000a670 <Free_Bsr_Info>:
->Output: 
->Special:
*******************************
*/
void Free_Bsr_Info(void)
{
    a670:	55                   	push   %ebp
    a671:	89 e5                	mov    %esp,%ebp
    a673:	53                   	push   %ebx
    a674:	e8 fc ff ff ff       	call   a675 <Free_Bsr_Info+0x5>
	FIN(Free_Bsr_Info(void));
	SV_PTR_GET(rlc_mac_sv);
    a679:	e8 fc ff ff ff       	call   a67a <Free_Bsr_Info+0xa>
    a67e:	89 c3                	mov    %eax,%ebx
	if(SV(Regularbsr)!=NULL)
    a680:	8b 80 4c 01 00 00    	mov    0x14c(%eax),%eax
    a686:	85 c0                	test   %eax,%eax
    a688:	74 0f                	je     a699 <Free_Bsr_Info+0x29>
	{
		fsm_mem_free(SV(Regularbsr));
    a68a:	e8 fc ff ff ff       	call   a68b <Free_Bsr_Info+0x1b>
		SV(Regularbsr)=NULL;
    a68f:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a696:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    a699:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a69f:	85 c0                	test   %eax,%eax
    a6a1:	74 0f                	je     a6b2 <Free_Bsr_Info+0x42>
	{
		fsm_mem_free(SV(Periodicbsr));
    a6a3:	e8 fc ff ff ff       	call   a6a4 <Free_Bsr_Info+0x34>
		SV(Periodicbsr)=NULL;
    a6a8:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    a6af:	00 00 00 
	}
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    a6b2:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a6b8:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    a6bd:	31 d2                	xor    %edx,%edx
    a6bf:	e8 fc ff ff ff       	call   a6c0 <Free_Bsr_Info+0x50>
	FOUT;
}
    a6c4:	5b                   	pop    %ebx
    a6c5:	5d                   	pop    %ebp
    a6c6:	c3                   	ret    
    a6c7:	89 f6                	mov    %esi,%esi
    a6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a6d0 <Zero_LogicalChannel_Bj_Reset>:
->Output: SV(LogicalChannel_Bj)lcbj0
->Special:
*******************************
*/
void Zero_LogicalChannel_Bj_Reset()
{
    a6d0:	55                   	push   %ebp
    a6d1:	89 e5                	mov    %esp,%ebp
    a6d3:	56                   	push   %esi
    a6d4:	53                   	push   %ebx
    a6d5:	e8 fc ff ff ff       	call   a6d6 <Zero_LogicalChannel_Bj_Reset+0x6>
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
    a6da:	e8 fc ff ff ff       	call   a6db <Zero_LogicalChannel_Bj_Reset+0xb>
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a6df:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
    a6e5:	8b 4b 05             	mov    0x5(%ebx),%ecx
    a6e8:	8d 73 05             	lea    0x5(%ebx),%esi
    a6eb:	39 f1                	cmp    %esi,%ecx
    a6ed:	8b 11                	mov    (%ecx),%edx
    a6ef:	75 0b                	jne    a6fc <Zero_LogicalChannel_Bj_Reset+0x2c>
    a6f1:	eb 28                	jmp    a71b <Zero_LogicalChannel_Bj_Reset+0x4b>
    a6f3:	90                   	nop
    a6f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a6f8:	89 d1                	mov    %edx,%ecx
    a6fa:	89 f2                	mov    %esi,%edx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
    a6fc:	81 79 fc 01 7d 00 00 	cmpl   $0x7d01,-0x4(%ecx)
    a703:	74 0d                	je     a712 <Zero_LogicalChannel_Bj_Reset+0x42>
			temp->lcbj=0;//BJ0			
    a705:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
    a70c:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a712:	8d 4b 05             	lea    0x5(%ebx),%ecx
    a715:	8b 32                	mov    (%edx),%esi
    a717:	39 ca                	cmp    %ecx,%edx
    a719:	75 dd                	jne    a6f8 <Zero_LogicalChannel_Bj_Reset+0x28>
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
			temp->lcbj=0;//BJ0			
	}
	FOUT;
}
    a71b:	5b                   	pop    %ebx
    a71c:	5e                   	pop    %esi
    a71d:	5d                   	pop    %ebp
    a71e:	c3                   	ret    
    a71f:	90                   	nop

0000a720 <Init_LogicalChannel_ConfigInfo>:
->Output: SV(LogicalChannel_Bj)
->Special:
*******************************
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
    a720:	55                   	push   %ebp
    a721:	89 e5                	mov    %esp,%ebp
    a723:	57                   	push   %edi
    a724:	56                   	push   %esi
    a725:	53                   	push   %ebx
    a726:	83 ec 04             	sub    $0x4,%esp
    a729:	e8 fc ff ff ff       	call   a72a <Init_LogicalChannel_ConfigInfo+0xa>
    a72e:	89 c3                	mov    %eax,%ebx
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a730:	e8 fc ff ff ff       	call   a731 <Init_LogicalChannel_ConfigInfo+0x11>
	bool flag=false;
	struct list_head *pos=NULL,*p=NULL;
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
    a735:	0f b6 3b             	movzbl (%ebx),%edi
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a738:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a73e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a741:	8b 56 11             	mov    0x11(%esi),%edx
    a744:	83 c6 11             	add    $0x11,%esi
    a747:	39 f2                	cmp    %esi,%edx
    a749:	8b 02                	mov    (%edx),%eax
    a74b:	75 0d                	jne    a75a <Init_LogicalChannel_ConfigInfo+0x3a>
    a74d:	eb 39                	jmp    a788 <Init_LogicalChannel_ConfigInfo+0x68>
    a74f:	90                   	nop
    a750:	39 c6                	cmp    %eax,%esi
    a752:	8b 08                	mov    (%eax),%ecx
    a754:	74 32                	je     a788 <Init_LogicalChannel_ConfigInfo+0x68>
    a756:	89 c2                	mov    %eax,%edx
    a758:	89 c8                	mov    %ecx,%eax
	{
		temp_lc_config=list_entry(pos,LogicalChannelConfigInfo,list);
		temp_lc_config_lcid=temp_lc_config->lcid;
		if(temp_lcid==temp_lc_config_lcid)
    a75a:	89 f9                	mov    %edi,%ecx
    a75c:	3a 4a ef             	cmp    -0x11(%edx),%cl
    a75f:	75 ef                	jne    a750 <Init_LogicalChannel_ConfigInfo+0x30>
		{
			if((lc_info->logicalChannelConfig).haveUl_SpecificParameters==true)
    a761:	80 7b 04 00          	cmpb   $0x0,0x4(%ebx)
    a765:	74 e9                	je     a750 <Init_LogicalChannel_ConfigInfo+0x30>
			{
				temp_lc_config->priority=(lc_info->logicalChannelConfig).ul_SpecificParameters.priority;
    a767:	8b 43 05             	mov    0x5(%ebx),%eax
    a76a:	89 42 f0             	mov    %eax,-0x10(%edx)
				temp_lc_config->prioritizedBitRateKbps=(lc_info->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    a76d:	8b 43 09             	mov    0x9(%ebx),%eax
    a770:	89 42 f4             	mov    %eax,-0xc(%edx)
				temp_lc_config->bucketSizeDurationMs=(lc_info->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    a773:	8b 43 0d             	mov    0xd(%ebx),%eax
    a776:	89 42 f8             	mov    %eax,-0x8(%edx)
				temp_lc_config->logicalChannelGroup=(lc_info->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    a779:	8b 43 11             	mov    0x11(%ebx),%eax
    a77c:	89 42 fc             	mov    %eax,-0x4(%edx)
			temp_bj->lcbj=0;
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a77f:	83 c4 04             	add    $0x4,%esp
    a782:	5b                   	pop    %ebx
    a783:	5e                   	pop    %esi
    a784:	5f                   	pop    %edi
    a785:	5d                   	pop    %ebp
    a786:	c3                   	ret    
    a787:	90                   	nop
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a788:	89 d8                	mov    %ebx,%eax
    a78a:	e8 fc ff ff ff       	call   a78b <Init_LogicalChannel_ConfigInfo+0x6b>
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a78f:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a792:	89 c6                	mov    %eax,%esi
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a794:	8b 82 40 01 00 00    	mov    0x140(%edx),%eax
    a79a:	8d 4e 11             	lea    0x11(%esi),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a79d:	8b 50 15             	mov    0x15(%eax),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a7a0:	89 48 15             	mov    %ecx,0x15(%eax)
    a7a3:	83 c0 11             	add    $0x11,%eax
    a7a6:	89 46 11             	mov    %eax,0x11(%esi)
		temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    a7a9:	b8 0d 00 00 00       	mov    $0xd,%eax
	new->next = next;
	new->prev = prev;
    a7ae:	89 56 15             	mov    %edx,0x15(%esi)
	prev->next = new;
    a7b1:	89 0a                	mov    %ecx,(%edx)
    a7b3:	e8 fc ff ff ff       	call   a7b4 <Init_LogicalChannel_ConfigInfo+0x94>
		/*while(temp_bj==0)//
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
    a7b8:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a7bb:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a7be:	89 50 09             	mov    %edx,0x9(%eax)
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a7c1:	8b 0b                	mov    (%ebx),%ecx
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a7c3:	bb 01 7d 00 00       	mov    $0x7d01,%ebx
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a7c8:	88 08                	mov    %cl,(%eax)
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a7ca:	31 c9                	xor    %ecx,%ecx
    a7cc:	83 7e 05 ff          	cmpl   $0xffffffff,0x5(%esi)
    a7d0:	0f 44 cb             	cmove  %ebx,%ecx
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a7d3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a7d6:	89 48 01             	mov    %ecx,0x1(%eax)
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a7d9:	8b 8b 44 01 00 00    	mov    0x144(%ebx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a7df:	8b 59 09             	mov    0x9(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a7e2:	89 51 09             	mov    %edx,0x9(%ecx)
    a7e5:	83 c1 05             	add    $0x5,%ecx
    a7e8:	89 48 05             	mov    %ecx,0x5(%eax)
	new->next = next;
	new->prev = prev;
    a7eb:	89 58 09             	mov    %ebx,0x9(%eax)
	prev->next = new;
    a7ee:	89 13                	mov    %edx,(%ebx)
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a7f0:	83 c4 04             	add    $0x4,%esp
    a7f3:	5b                   	pop    %ebx
    a7f4:	5e                   	pop    %esi
    a7f5:	5f                   	pop    %edi
    a7f6:	5d                   	pop    %ebp
    a7f7:	c3                   	ret    
    a7f8:	90                   	nop
    a7f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a800 <leftresource_morethan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a800:	55                   	push   %ebp
    a801:	89 e5                	mov    %esp,%ebp
    a803:	83 ec 18             	sub    $0x18,%esp
    a806:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a809:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a80c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a80f:	e8 fc ff ff ff       	call   a810 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x10>
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a814:	8b 71 01             	mov    0x1(%ecx),%esi
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a817:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a81a:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a81d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a820:	8b 45 14             	mov    0x14(%ebp),%eax
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a823:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a827:	66 89 72 0d          	mov    %si,0xd(%edx)
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a82b:	8b 71 01             	mov    0x1(%ecx),%esi
    a82e:	8b 76 09             	mov    0x9(%esi),%esi
    a831:	89 72 09             	mov    %esi,0x9(%edx)
	*res_length=*res_length-retxlength;
    a834:	29 38                	sub    %edi,(%eax)
	temp_logicalchannel_bj->lcbj-=retxlength;
    a836:	29 7b 01             	sub    %edi,0x1(%ebx)
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a839:	8b 30                	mov    (%eax),%esi
    a83b:	8b 7d 10             	mov    0x10(%ebp),%edi
    a83e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    a841:	39 fe                	cmp    %edi,%esi
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a843:	8b 71 01             	mov    0x1(%ecx),%esi
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
	*res_length=*res_length-retxlength;
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a846:	0f 83 b4 00 00 00    	jae    a900 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x100>
		*res_length-=txlength;
		//  break;
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
    a84c:	0f b7 7e 07          	movzwl 0x7(%esi),%edi
    a850:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    a854:	0f b7 ff             	movzwl %di,%edi
    a857:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    a85a:	73 4c                	jae    a8a8 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xa8>
			// break;
		}
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
    a85c:	8b 76 03             	mov    0x3(%esi),%esi
    a85f:	39 75 e8             	cmp    %esi,-0x18(%ebp)
    a862:	0f 83 d8 00 00 00    	jae    a940 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x140>
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a868:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a86b:	8b 7d ec             	mov    -0x14(%ebp),%edi
				temp_rlc_report->txQueueHeader=0;
    a86e:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a874:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
    a877:	8b 08                	mov    (%eax),%ecx
    a879:	29 4b 01             	sub    %ecx,0x1(%ebx)
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a87c:	89 fb                	mov    %edi,%ebx
    a87e:	8d 4a 13             	lea    0x13(%edx),%ecx
    a881:	83 c3 13             	add    $0x13,%ebx
			{
				temp_rlc_report->txQueueSize=*res_length;
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
    a884:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a88a:	8b 47 17             	mov    0x17(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a88d:	89 4f 17             	mov    %ecx,0x17(%edi)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a890:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a893:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a896:	89 08                	mov    %ecx,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a898:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a89b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a89e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8a1:	89 ec                	mov    %ebp,%esp
    a8a3:	5d                   	pop    %ebp
    a8a4:	c3                   	ret    
    a8a5:	8d 76 00             	lea    0x0(%esi),%esi
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a8a8:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
    a8ac:	66 89 72 07          	mov    %si,0x7(%edx)
			*res_length=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    a8b0:	8b 71 01             	mov    0x1(%ecx),%esi
    a8b3:	8b 38                	mov    (%eax),%edi
    a8b5:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a8b9:	29 f7                	sub    %esi,%edi
    a8bb:	89 38                	mov    %edi,(%eax)
			temp_rlc_report->txQueueSize=*res_length;
    a8bd:	89 7a 03             	mov    %edi,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=(temp_mac_buffer->RlcRequestparams->txQueueHeader+temp_rlc_report->txQueueSize);
    a8c0:	8b 49 01             	mov    0x1(%ecx),%ecx
    a8c3:	0f b7 71 07          	movzwl 0x7(%ecx),%esi
    a8c7:	8b 4b 01             	mov    0x1(%ebx),%ecx
    a8ca:	29 f1                	sub    %esi,%ecx
    a8cc:	29 f9                	sub    %edi,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a8ce:	8b 7d ec             	mov    -0x14(%ebp),%edi
    a8d1:	89 4b 01             	mov    %ecx,0x1(%ebx)
			// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
			// temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a8d4:	8d 5a 13             	lea    0x13(%edx),%ebx
    a8d7:	8b 4f 17             	mov    0x17(%edi),%ecx
    a8da:	89 fe                	mov    %edi,%esi
    a8dc:	83 c6 13             	add    $0x13,%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a8df:	89 5f 17             	mov    %ebx,0x17(%edi)
    a8e2:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a8e5:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a8e8:	89 19                	mov    %ebx,(%ecx)
			*res_length=0;
    a8ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a8f0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a8f3:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a8f6:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8f9:	89 ec                	mov    %ebp,%esp
    a8fb:	5d                   	pop    %ebp
    a8fc:	c3                   	ret    
    a8fd:	8d 76 00             	lea    0x0(%esi),%esi
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a900:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a904:	66 89 72 07          	mov    %si,0x7(%edx)
		temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a908:	8b 49 01             	mov    0x1(%ecx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a90b:	8b 75 ec             	mov    -0x14(%ebp),%esi
    a90e:	8b 49 03             	mov    0x3(%ecx),%ecx
    a911:	89 4a 03             	mov    %ecx,0x3(%edx)
		temp_logicalchannel_bj->lcbj-=txlength;
    a914:	29 7b 01             	sub    %edi,0x1(%ebx)
    a917:	8b 4e 17             	mov    0x17(%esi),%ecx
		// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a91a:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a91d:	89 5e 17             	mov    %ebx,0x17(%esi)
    a920:	83 c6 13             	add    $0x13,%esi
    a923:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a926:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a929:	89 19                	mov    %ebx,(%ecx)
		*res_length-=txlength;
    a92b:	29 38                	sub    %edi,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a92d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a930:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a933:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a936:	89 ec                	mov    %ebp,%esp
    a938:	5d                   	pop    %ebp
    a939:	c3                   	ret    
    a93a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
			{
				temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a940:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);
    a943:	8b 49 01             	mov    0x1(%ecx),%ecx
    a946:	8b 30                	mov    (%eax),%esi
    a948:	66 2b 71 03          	sub    0x3(%ecx),%si
    a94c:	66 89 72 07          	mov    %si,0x7(%edx)

				temp_logicalchannel_bj->lcbj-=*res_length;
    a950:	8b 08                	mov    (%eax),%ecx
    a952:	29 4b 01             	sub    %ecx,0x1(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a955:	8b 5d ec             	mov    -0x14(%ebp),%ebx
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a958:	8d 4a 13             	lea    0x13(%edx),%ecx
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);

				temp_logicalchannel_bj->lcbj-=*res_length;
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
    a95b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a961:	8b 43 17             	mov    0x17(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a964:	89 4b 17             	mov    %ecx,0x17(%ebx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a967:	83 c3 13             	add    $0x13,%ebx
    a96a:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a96d:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a970:	89 08                	mov    %ecx,(%eax)
    a972:	e9 79 ff ff ff       	jmp    a8f0 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xf0>
    a977:	89 f6                	mov    %esi,%esi
    a979:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a980 <leftresource_lessthan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a980:	55                   	push   %ebp
    a981:	89 e5                	mov    %esp,%ebp
    a983:	83 ec 10             	sub    $0x10,%esp
    a986:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a989:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a98c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a98f:	e8 fc ff ff ff       	call   a990 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x10>
    a994:	8b 5d 14             	mov    0x14(%ebp),%ebx
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
    a997:	8b 33                	mov    (%ebx),%esi
    a999:	89 75 f0             	mov    %esi,-0x10(%ebp)
    a99c:	8b 71 01             	mov    0x1(%ecx),%esi
    a99f:	0f b7 7e 0d          	movzwl 0xd(%esi),%edi
    a9a3:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    a9a6:	73 58                	jae    aa00 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x80>
		*res_length=0;
		// break;
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
    a9a8:	8b 76 09             	mov    0x9(%esi),%esi
    a9ab:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a9ae:	0f 83 ac 00 00 00    	jae    aa60 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0xe0>
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a9b4:	8b 7d f0             	mov    -0x10(%ebp),%edi
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
			temp_logicalchannel_bj->lcbj-=*res_length;
    a9b7:	8b 75 08             	mov    0x8(%ebp),%esi
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
			temp_rlc_report->retxQueueHeader=0;
    a9ba:	66 c7 42 0d 00 00    	movw   $0x0,0xd(%edx)
			temp_rlc_report->txQueueHeader=0;
    a9c0:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a9c6:	89 7a 09             	mov    %edi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
    a9c9:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=*res_length;
    a9d0:	8b 0b                	mov    (%ebx),%ecx
    a9d2:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
			*res_length=0;
    a9d5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a9db:	8b 48 17             	mov    0x17(%eax),%ecx
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a9de:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a9e1:	89 58 17             	mov    %ebx,0x17(%eax)
    a9e4:	83 c0 13             	add    $0x13,%eax
    a9e7:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a9ea:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a9ed:	89 19                	mov    %ebx,(%ecx)
			//break;
		}
	}
	FOUT;
}
    a9ef:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a9f2:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a9f5:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a9f8:	89 ec                	mov    %ebp,%esp
    a9fa:	5d                   	pop    %ebp
    a9fb:	c3                   	ret    
    a9fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
    aa00:	8b 7d 08             	mov    0x8(%ebp),%edi
    aa03:	8b 75 f0             	mov    -0x10(%ebp),%esi
    aa06:	29 77 01             	sub    %esi,0x1(%edi)
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aa09:	89 df                	mov    %ebx,%edi
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    aa0b:	8b 71 01             	mov    0x1(%ecx),%esi
    aa0e:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    aa12:	66 89 72 0d          	mov    %si,0xd(%edx)
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aa16:	8b 49 01             	mov    0x1(%ecx),%ecx
		temp_rlc_report->retxQueueSize=*res_length;
		temp_rlc_report->txQueueHeader=0;
		temp_rlc_report->txQueueSize=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    aa19:	8d 72 13             	lea    0x13(%edx),%esi
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aa1c:	0f b7 49 0d          	movzwl 0xd(%ecx),%ecx
    aa20:	c1 e1 02             	shl    $0x2,%ecx
    aa23:	29 cf                	sub    %ecx,%edi
    aa25:	89 3b                	mov    %edi,(%ebx)
		temp_rlc_report->retxQueueSize=*res_length;
    aa27:	89 7a 09             	mov    %edi,0x9(%edx)
		temp_rlc_report->txQueueHeader=0;
    aa2a:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
		temp_rlc_report->txQueueSize=0;
    aa30:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    aa37:	8b 48 17             	mov    0x17(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    aa3a:	89 70 17             	mov    %esi,0x17(%eax)
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    aa3d:	83 c0 13             	add    $0x13,%eax
    aa40:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    aa43:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    aa46:	89 31                	mov    %esi,(%ecx)
		*res_length=0;
    aa48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			//break;
		}
	}
	FOUT;
}
    aa4e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aa51:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aa54:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aa57:	89 ec                	mov    %ebp,%esp
    aa59:	5d                   	pop    %ebp
    aa5a:	c3                   	ret    
    aa5b:	90                   	nop
    aa5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
		{
			temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    aa60:	89 72 09             	mov    %esi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->retxQueueSize);
    aa63:	8b 49 01             	mov    0x1(%ecx),%ecx
    aa66:	8b 33                	mov    (%ebx),%esi
    aa68:	66 2b 71 09          	sub    0x9(%ecx),%si
    aa6c:	66 89 72 0d          	mov    %si,0xd(%edx)

			temp_logicalchannel_bj->lcbj-=*res_length;
    aa70:	8b 75 08             	mov    0x8(%ebp),%esi
    aa73:	8b 0b                	mov    (%ebx),%ecx
    aa75:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueHeader-=temp_rlc_report->retxQueueHeader;
			//temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
			temp_rlc_report->txQueueHeader=0;
    aa78:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			temp_rlc_report->txQueueSize=0;
    aa7e:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
    aa85:	e9 4b ff ff ff       	jmp    a9d5 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x55>
    aa8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000aa90 <ResourceAllocation_logicalchannel_firstretxbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    aa90:	55                   	push   %ebp
    aa91:	89 e5                	mov    %esp,%ebp
    aa93:	83 ec 24             	sub    $0x24,%esp
    aa96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    aa99:	89 75 f8             	mov    %esi,-0x8(%ebp)
    aa9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    aa9f:	e8 fc ff ff ff       	call   aaa0 <ResourceAllocation_logicalchannel_firstretxbuffer+0x10>
    aaa4:	8b 7d 10             	mov    0x10(%ebp),%edi
    aaa7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aaaa:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    aaaf:	89 d6                	mov    %edx,%esi
    aab1:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aab4:	e8 fc ff ff ff       	call   aab5 <ResourceAllocation_logicalchannel_firstretxbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    aab9:	31 d2                	xor    %edx,%edx
    aabb:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aac0:	89 c3                	mov    %eax,%ebx
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    aac2:	e8 fc ff ff ff       	call   aac3 <ResourceAllocation_logicalchannel_firstretxbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
    aac7:	8d 43 13             	lea    0x13(%ebx),%eax
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aaca:	89 f1                	mov    %esi,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aacc:	89 43 13             	mov    %eax,0x13(%ebx)
    aacf:	89 da                	mov    %ebx,%edx
	list->prev = list;
    aad1:	89 43 17             	mov    %eax,0x17(%ebx)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    aad4:	8b 46 01             	mov    0x1(%esi),%eax
    aad7:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    aadb:	88 43 02             	mov    %al,0x2(%ebx)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    aade:	8b 46 01             	mov    0x1(%esi),%eax
    aae1:	0f b7 00             	movzwl (%eax),%eax
	temp_rlc_report->statusPduHeader=0;
    aae4:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
	temp_rlc_report->statusPduSize=0;//PDU
    aaea:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    aaf0:	66 89 03             	mov    %ax,(%ebx)
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    aaf3:	8b 45 08             	mov    0x8(%ebp),%eax
    aaf6:	39 07                	cmp    %eax,(%edi)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aaf8:	8b 45 0c             	mov    0xc(%ebp),%eax
    aafb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    aaff:	89 44 24 08          	mov    %eax,0x8(%esp)
    ab03:	8b 45 08             	mov    0x8(%ebp),%eax
    ab06:	89 44 24 04          	mov    %eax,0x4(%esp)
    ab0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ab0d:	89 04 24             	mov    %eax,(%esp)
    ab10:	8b 45 f0             	mov    -0x10(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    ab13:	73 13                	jae    ab28 <ResourceAllocation_logicalchannel_firstretxbuffer+0x98>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    ab15:	e8 fc ff ff ff       	call   ab16 <ResourceAllocation_logicalchannel_firstretxbuffer+0x86>
	}
	FOUT;
}
    ab1a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ab1d:	8b 75 f8             	mov    -0x8(%ebp),%esi
    ab20:	8b 7d fc             	mov    -0x4(%ebp),%edi
    ab23:	89 ec                	mov    %ebp,%esp
    ab25:	5d                   	pop    %ebp
    ab26:	c3                   	ret    
    ab27:	90                   	nop
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    ab28:	e8 fc ff ff ff       	call   ab29 <ResourceAllocation_logicalchannel_firstretxbuffer+0x99>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    ab2d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ab30:	8b 75 f8             	mov    -0x8(%ebp),%esi
    ab33:	8b 7d fc             	mov    -0x4(%ebp),%edi
    ab36:	89 ec                	mov    %ebp,%esp
    ab38:	5d                   	pop    %ebp
    ab39:	c3                   	ret    
    ab3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000ab40 <ResourceAllocation_logicalchannel_firststatusbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    ab40:	55                   	push   %ebp
    ab41:	89 e5                	mov    %esp,%ebp
    ab43:	83 ec 24             	sub    $0x24,%esp
    ab46:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    ab49:	89 75 f8             	mov    %esi,-0x8(%ebp)
    ab4c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    ab4f:	e8 fc ff ff ff       	call   ab50 <ResourceAllocation_logicalchannel_firststatusbuffer+0x10>
    ab54:	8b 7d 14             	mov    0x14(%ebp),%edi
    ab57:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ab5a:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    ab5f:	89 d3                	mov    %edx,%ebx
    ab61:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ab64:	e8 fc ff ff ff       	call   ab65 <ResourceAllocation_logicalchannel_firststatusbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    ab69:	31 d2                	xor    %edx,%edx
    ab6b:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ab70:	89 c6                	mov    %eax,%esi
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    ab72:	e8 fc ff ff ff       	call   ab73 <ResourceAllocation_logicalchannel_firststatusbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));
    ab77:	8d 46 13             	lea    0x13(%esi),%eax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    ab7a:	89 d9                	mov    %ebx,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ab7c:	89 46 13             	mov    %eax,0x13(%esi)
    ab7f:	89 f2                	mov    %esi,%edx
	list->prev = list;
    ab81:	89 46 17             	mov    %eax,0x17(%esi)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    ab84:	8b 43 01             	mov    0x1(%ebx),%eax
    ab87:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    ab8b:	88 46 02             	mov    %al,0x2(%esi)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    ab8e:	8b 43 01             	mov    0x1(%ebx),%eax
    ab91:	0f b7 00             	movzwl (%eax),%eax
    ab94:	66 89 06             	mov    %ax,(%esi)
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
    ab97:	8b 43 01             	mov    0x1(%ebx),%eax
    ab9a:	0f b7 40 11          	movzwl 0x11(%eax),%eax
    ab9e:	66 89 46 11          	mov    %ax,0x11(%esi)
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
    aba2:	8b 43 01             	mov    0x1(%ebx),%eax
    aba5:	0f b7 40 0f          	movzwl 0xf(%eax),%eax
    aba9:	66 89 46 0f          	mov    %ax,0xf(%esi)
	*res_length=*res_length-statuslength;        
    abad:	8b 07                	mov    (%edi),%eax
    abaf:	2b 45 08             	sub    0x8(%ebp),%eax
	if(*res_length >= retxlength)
    abb2:	3b 45 0c             	cmp    0xc(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
    abb5:	89 07                	mov    %eax,(%edi)
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    abb7:	8b 45 10             	mov    0x10(%ebp),%eax
    abba:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    abbe:	89 44 24 08          	mov    %eax,0x8(%esp)
    abc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    abc5:	89 44 24 04          	mov    %eax,0x4(%esp)
    abc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    abcc:	89 04 24             	mov    %eax,(%esp)
    abcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
    abd2:	73 14                	jae    abe8 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa8>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    abd4:	e8 fc ff ff ff       	call   abd5 <ResourceAllocation_logicalchannel_firststatusbuffer+0x95>
	}
	FOUT;
}
    abd9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    abdc:	8b 75 f8             	mov    -0x8(%ebp),%esi
    abdf:	8b 7d fc             	mov    -0x4(%ebp),%edi
    abe2:	89 ec                	mov    %ebp,%esp
    abe4:	5d                   	pop    %ebp
    abe5:	c3                   	ret    
    abe6:	66 90                	xchg   %ax,%ax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    abe8:	e8 fc ff ff ff       	call   abe9 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa9>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    abed:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    abf0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    abf3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    abf6:	89 ec                	mov    %ebp,%esp
    abf8:	5d                   	pop    %ebp
    abf9:	c3                   	ret    
    abfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000ac00 <ResourceAllocation_foreach_logicalchannel>:
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    ac00:	55                   	push   %ebp
    ac01:	89 e5                	mov    %esp,%ebp
    ac03:	83 ec 30             	sub    $0x30,%esp
    ac06:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    ac09:	89 75 f8             	mov    %esi,-0x8(%ebp)
    ac0c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    ac0f:	e8 fc ff ff ff       	call   ac10 <ResourceAllocation_foreach_logicalchannel+0x10>
    ac14:	8b 75 14             	mov    0x14(%ebp),%esi
    ac17:	8b 5d 08             	mov    0x8(%ebp),%ebx
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    ac1a:	89 55 e8             	mov    %edx,-0x18(%ebp)
    ac1d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    ac20:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    ac23:	e8 fc ff ff ff       	call   ac24 <ResourceAllocation_foreach_logicalchannel+0x24>
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    ac28:	8b 7d 0c             	mov    0xc(%ebp),%edi
    ac2b:	8b 06                	mov    (%esi),%eax
    ac2d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ac30:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ac33:	01 df                	add    %ebx,%edi
    ac35:	03 7d 10             	add    0x10(%ebp),%edi
    ac38:	39 f8                	cmp    %edi,%eax
    ac3a:	73 2c                	jae    ac68 <ResourceAllocation_foreach_logicalchannel+0x68>
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
		*res_length=*res_length-(statuslength+retxlength+txlength);
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
    ac3c:	39 d8                	cmp    %ebx,%eax
    ac3e:	73 70                	jae    acb0 <ResourceAllocation_foreach_logicalchannel+0xb0>
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
	}
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ac40:	8b 5d 10             	mov    0x10(%ebp),%ebx
    ac43:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ac46:	89 74 24 08          	mov    %esi,0x8(%esp)
    ac4a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    ac4e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ac51:	89 1c 24             	mov    %ebx,(%esp)
    ac54:	e8 fc ff ff ff       	call   ac55 <ResourceAllocation_foreach_logicalchannel+0x55>
	}
	FOUT;
}
    ac59:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ac5c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    ac5f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    ac62:	89 ec                	mov    %ebp,%esp
    ac64:	5d                   	pop    %ebp
    ac65:	c3                   	ret    
    ac66:	66 90                	xchg   %ax,%ax
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
	{
		temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    ac68:	8b 42 01             	mov    0x1(%edx),%eax
    ac6b:	e8 fc ff ff ff       	call   ac6c <ResourceAllocation_foreach_logicalchannel+0x6c>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ac70:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    ac73:	8b 5b 17             	mov    0x17(%ebx),%ebx
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    ac76:	8d 50 13             	lea    0x13(%eax),%edx
    ac79:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ac7c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ac7f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    ac82:	89 53 17             	mov    %edx,0x17(%ebx)
    ac85:	83 c3 13             	add    $0x13,%ebx
	new->next = next;
	new->prev = prev;
    ac88:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ac8b:	89 58 13             	mov    %ebx,0x13(%eax)
	prev->next = new;
    ac8e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    ac91:	89 50 17             	mov    %edx,0x17(%eax)
	prev->next = new;
    ac94:	89 1a                	mov    %ebx,(%edx)
		*res_length=*res_length-(statuslength+retxlength+txlength);
    ac96:	29 3e                	sub    %edi,(%esi)
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
    ac98:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ac9b:	29 79 01             	sub    %edi,0x1(%ecx)
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    ac9e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aca1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aca4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aca7:	89 ec                	mov    %ebp,%esp
    aca9:	5d                   	pop    %ebp
    acaa:	c3                   	ret    
    acab:	90                   	nop
    acac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    acb0:	8b 45 10             	mov    0x10(%ebp),%eax
    acb3:	89 74 24 0c          	mov    %esi,0xc(%esp)
    acb7:	89 1c 24             	mov    %ebx,(%esp)
    acba:	89 44 24 08          	mov    %eax,0x8(%esp)
    acbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    acc1:	89 44 24 04          	mov    %eax,0x4(%esp)
    acc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    acc8:	e8 fc ff ff ff       	call   acc9 <ResourceAllocation_foreach_logicalchannel+0xc9>
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    accd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    acd0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    acd3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    acd6:	89 ec                	mov    %ebp,%esp
    acd8:	5d                   	pop    %ebp
    acd9:	c3                   	ret    
    acda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000ace0 <Delete_LogicalChannel_ConfigInfo>:
->Output:int *num:reportvoid *:RLC report
->Special:
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
    ace0:	55                   	push   %ebp
    ace1:	89 e5                	mov    %esp,%ebp
    ace3:	57                   	push   %edi
    ace4:	56                   	push   %esi
    ace5:	53                   	push   %ebx
    ace6:	83 ec 04             	sub    $0x4,%esp
    ace9:	e8 fc ff ff ff       	call   acea <Delete_LogicalChannel_ConfigInfo+0xa>
    acee:	89 c6                	mov    %eax,%esi
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    acf0:	e8 fc ff ff ff       	call   acf1 <Delete_LogicalChannel_ConfigInfo+0x11>
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    acf5:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    acfb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    acfe:	8b 51 11             	mov    0x11(%ecx),%edx
    ad01:	8d 41 11             	lea    0x11(%ecx),%eax
    ad04:	39 c2                	cmp    %eax,%edx
    ad06:	8b 1a                	mov    (%edx),%ebx
    ad08:	75 13                	jne    ad1d <Delete_LogicalChannel_ConfigInfo+0x3d>
    ad0a:	eb 44                	jmp    ad50 <Delete_LogicalChannel_ConfigInfo+0x70>
    ad0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ad10:	8d 51 11             	lea    0x11(%ecx),%edx
    ad13:	8b 03                	mov    (%ebx),%eax
    ad15:	39 d3                	cmp    %edx,%ebx
    ad17:	74 37                	je     ad50 <Delete_LogicalChannel_ConfigInfo+0x70>
    ad19:	89 da                	mov    %ebx,%edx
    ad1b:	89 c3                	mov    %eax,%ebx
	{
		temp_free=list_entry(pos,LogicalChannelConfigInfo,list);
		if(temp_free->lcid==lcid_delete)
    ad1d:	0f b6 42 ef          	movzbl -0x11(%edx),%eax
    ad21:	66 39 f0             	cmp    %si,%ax
    ad24:	75 ea                	jne    ad10 <Delete_LogicalChannel_ConfigInfo+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ad26:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
    ad29:	8d 42 ef             	lea    -0x11(%edx),%eax
    ad2c:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ad2e:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    ad31:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad33:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    ad35:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp_free);
    ad38:	e8 fc ff ff ff       	call   ad39 <Delete_LogicalChannel_ConfigInfo+0x59>
    ad3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad40:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    ad46:	8b 03                	mov    (%ebx),%eax
    ad48:	8d 51 11             	lea    0x11(%ecx),%edx
    ad4b:	39 d3                	cmp    %edx,%ebx
    ad4d:	75 ca                	jne    ad19 <Delete_LogicalChannel_ConfigInfo+0x39>
    ad4f:	90                   	nop
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    ad50:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad53:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
    ad59:	8b 51 05             	mov    0x5(%ecx),%edx
    ad5c:	8d 41 05             	lea    0x5(%ecx),%eax
    ad5f:	39 c2                	cmp    %eax,%edx
    ad61:	8b 1a                	mov    (%edx),%ebx
    ad63:	75 10                	jne    ad75 <Delete_LogicalChannel_ConfigInfo+0x95>
    ad65:	eb 41                	jmp    ada8 <Delete_LogicalChannel_ConfigInfo+0xc8>
    ad67:	90                   	nop
    ad68:	8d 51 05             	lea    0x5(%ecx),%edx
    ad6b:	8b 03                	mov    (%ebx),%eax
    ad6d:	39 d3                	cmp    %edx,%ebx
    ad6f:	74 37                	je     ada8 <Delete_LogicalChannel_ConfigInfo+0xc8>
    ad71:	89 da                	mov    %ebx,%edx
    ad73:	89 c3                	mov    %eax,%ebx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcid==lcid_delete)
    ad75:	0f b6 42 fb          	movzbl -0x5(%edx),%eax
    ad79:	66 39 f0             	cmp    %si,%ax
    ad7c:	75 ea                	jne    ad68 <Delete_LogicalChannel_ConfigInfo+0x88>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ad7e:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
    ad81:	8d 42 fb             	lea    -0x5(%edx),%eax
    ad84:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ad86:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    ad89:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad8b:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    ad8d:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp);
    ad90:	e8 fc ff ff ff       	call   ad91 <Delete_LogicalChannel_ConfigInfo+0xb1>
    ad95:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ad98:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    ad9e:	8b 03                	mov    (%ebx),%eax
    ada0:	8d 51 05             	lea    0x5(%ecx),%edx
    ada3:	39 d3                	cmp    %edx,%ebx
    ada5:	75 ca                	jne    ad71 <Delete_LogicalChannel_ConfigInfo+0x91>
    ada7:	90                   	nop
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
			fsm_mem_free(temp);
		}
	}
	FOUT;
}
    ada8:	83 c4 04             	add    $0x4,%esp
    adab:	5b                   	pop    %ebx
    adac:	5e                   	pop    %esi
    adad:	5f                   	pop    %edi
    adae:	5d                   	pop    %ebp
    adaf:	c3                   	ret    

0000adb0 <Empty_MACBuffer_Rlc>:
->Output:
->Special:
*******************************
*/
void Empty_MACBuffer_Rlc(void)
{
    adb0:	55                   	push   %ebp
    adb1:	89 e5                	mov    %esp,%ebp
    adb3:	57                   	push   %edi
    adb4:	56                   	push   %esi
    adb5:	53                   	push   %ebx
    adb6:	e8 fc ff ff ff       	call   adb7 <Empty_MACBuffer_Rlc+0x7>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
    adbb:	e8 fc ff ff ff       	call   adbc <Empty_MACBuffer_Rlc+0xc>
    adc0:	89 c7                	mov    %eax,%edi
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    adc2:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    adc8:	8b 58 05             	mov    0x5(%eax),%ebx
    adcb:	83 c0 05             	add    $0x5,%eax
    adce:	39 c3                	cmp    %eax,%ebx
    add0:	8b 33                	mov    (%ebx),%esi
    add2:	75 08                	jne    addc <Empty_MACBuffer_Rlc+0x2c>
    add4:	eb 34                	jmp    ae0a <Empty_MACBuffer_Rlc+0x5a>
    add6:	66 90                	xchg   %ax,%ax
    add8:	89 f3                	mov    %esi,%ebx
    adda:	89 d6                	mov    %edx,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    addc:	8b 43 fc             	mov    -0x4(%ebx),%eax
    addf:	e8 fc ff ff ff       	call   ade0 <Empty_MACBuffer_Rlc+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ade4:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_free->list));
    ade7:	8d 43 fb             	lea    -0x5(%ebx),%eax
    adea:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    adec:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    adef:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    adf1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    adf3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    adf6:	e8 fc ff ff ff       	call   adf7 <Empty_MACBuffer_Rlc+0x47>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    adfb:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
    ae01:	8b 16                	mov    (%esi),%edx
    ae03:	83 c0 05             	add    $0x5,%eax
    ae06:	39 c6                	cmp    %eax,%esi
    ae08:	75 ce                	jne    add8 <Empty_MACBuffer_Rlc+0x28>
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}	
	FOUT;
}
    ae0a:	5b                   	pop    %ebx
    ae0b:	5e                   	pop    %esi
    ae0c:	5f                   	pop    %edi
    ae0d:	5d                   	pop    %ebp
    ae0e:	c3                   	ret    
    ae0f:	90                   	nop

0000ae10 <ResourceAllocation_Algorithm>:
->Special:
*******************************
*/

void * ResourceAllocation_Algorithm(u32 resource_len,u32 *num)//numreport
{
    ae10:	55                   	push   %ebp
    ae11:	89 e5                	mov    %esp,%ebp
    ae13:	57                   	push   %edi
    ae14:	56                   	push   %esi
    ae15:	53                   	push   %ebx
    ae16:	83 ec 3c             	sub    $0x3c,%esp
    ae19:	e8 fc ff ff ff       	call   ae1a <ResourceAllocation_Algorithm+0xa>
    ae1e:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ae21:	89 45 f0             	mov    %eax,-0x10(%ebp)
	u32 *res_length;
	u32 statuslength,retxlength,txlength;
	struct list_head *pos,*p;

	FIN(ResourceAllocation_Algorithm(int resource_len));
	SV_PTR_GET(rlc_mac_sv);
    ae24:	e8 fc ff ff ff       	call   ae25 <ResourceAllocation_Algorithm+0x15>
    ae29:	89 45 dc             	mov    %eax,-0x24(%ebp)
	priority_mac_buffer=NULL;
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ae2c:	b8 1b 00 00 00       	mov    $0x1b,%eax
    ae31:	e8 fc ff ff ff       	call   ae32 <ResourceAllocation_Algorithm+0x22>
    ae36:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ae39:	b8 0d 00 00 00       	mov    $0xd,%eax
    ae3e:	e8 fc ff ff ff       	call   ae3f <ResourceAllocation_Algorithm+0x2f>
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
    ae43:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ae46:	83 c6 13             	add    $0x13,%esi
    ae49:	89 75 cc             	mov    %esi,-0x34(%ebp)
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ae4c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ae4f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
    ae52:	83 c0 05             	add    $0x5,%eax
    ae55:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ae58:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    ae5b:	89 42 09             	mov    %eax,0x9(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ae5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae61:	89 70 13             	mov    %esi,0x13(%eax)
	list->prev = list;
    ae64:	89 70 17             	mov    %esi,0x17(%eax)
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ae67:	e8 fc ff ff ff       	call   ae68 <ResourceAllocation_Algorithm+0x58>
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ae6c:	89 c2                	mov    %eax,%edx
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ae6e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ae71:	8b 40 05             	mov    0x5(%eax),%eax
    ae74:	8d 78 fb             	lea    -0x5(%eax),%edi
    ae77:	39 fa                	cmp    %edi,%edx
    ae79:	0f 84 cc 02 00 00    	je     b14b <ResourceAllocation_Algorithm+0x33b>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ae7f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ae82:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ae86:	85 c9                	test   %ecx,%ecx
    ae88:	0f 84 e5 00 00 00    	je     af73 <ResourceAllocation_Algorithm+0x163>
    ae8e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ae95:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ae9c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    aea3:	90                   	nop
    aea4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    aea8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    aeab:	8b b0 44 01 00 00    	mov    0x144(%eax),%esi
    aeb1:	8b 46 05             	mov    0x5(%esi),%eax
    aeb4:	8d 58 fb             	lea    -0x5(%eax),%ebx
    aeb7:	39 de                	cmp    %ebx,%esi
    aeb9:	75 13                	jne    aece <ResourceAllocation_Algorithm+0xbe>
    aebb:	e9 68 01 00 00       	jmp    b028 <ResourceAllocation_Algorithm+0x218>
    aec0:	8b 43 05             	mov    0x5(%ebx),%eax
    aec3:	8d 58 fb             	lea    -0x5(%eax),%ebx
    aec6:	39 de                	cmp    %ebx,%esi
    aec8:	0f 84 5a 01 00 00    	je     b028 <ResourceAllocation_Algorithm+0x218>
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
    aece:	38 50 fb             	cmp    %dl,-0x5(%eax)
    aed1:	75 ed                	jne    aec0 <ResourceAllocation_Algorithm+0xb0>
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    aed3:	8b 47 01             	mov    0x1(%edi),%eax
    aed6:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    aeda:	0f b7 50 11          	movzwl 0x11(%eax),%edx
    aede:	01 f2                	add    %esi,%edx
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aee0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    aee4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aee7:	8b 50 09             	mov    0x9(%eax),%edx
    aeea:	01 d6                	add    %edx,%esi
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    aeec:	8b 50 03             	mov    0x3(%eax),%edx
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    aeef:	89 75 ec             	mov    %esi,-0x14(%ebp)
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    aef2:	0f b7 70 07          	movzwl 0x7(%eax),%esi
    aef6:	01 d6                	add    %edx,%esi
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    aef8:	81 7b 01 01 7d 00 00 	cmpl   $0x7d01,0x1(%ebx)
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    aeff:	89 75 e8             	mov    %esi,-0x18(%ebp)
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    af02:	0f 85 a0 01 00 00    	jne    b0a8 <ResourceAllocation_Algorithm+0x298>
    af08:	8b 55 ec             	mov    -0x14(%ebp),%edx
    af0b:	09 f2                	or     %esi,%edx
    af0d:	0b 55 e4             	or     -0x1c(%ebp),%edx
    af10:	0f 84 92 01 00 00    	je     b0a8 <ResourceAllocation_Algorithm+0x298>
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    af16:	8b 55 ec             	mov    -0x14(%ebp),%edx
    af19:	01 f2                	add    %esi,%edx
    af1b:	03 55 e4             	add    -0x1c(%ebp),%edx
    af1e:	39 ca                	cmp    %ecx,%edx
    af20:	0f 86 b3 01 00 00    	jbe    b0d9 <ResourceAllocation_Algorithm+0x2c9>
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    af26:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    af29:	8d 45 f0             	lea    -0x10(%ebp),%eax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    af2c:	0f 86 eb 01 00 00    	jbe    b11d <ResourceAllocation_Algorithm+0x30d>
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    af32:	8b 75 e8             	mov    -0x18(%ebp),%esi
    af35:	89 d9                	mov    %ebx,%ecx
    af37:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    af39:	89 44 24 08          	mov    %eax,0x8(%esp)
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    af3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    af40:	89 74 24 04          	mov    %esi,0x4(%esp)
    af44:	8b 75 ec             	mov    -0x14(%ebp),%esi
    af47:	89 34 24             	mov    %esi,(%esp)
						break;
    af4a:	89 de                	mov    %ebx,%esi
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    af4c:	e8 fc ff ff ff       	call   af4d <ResourceAllocation_Algorithm+0x13d>
    af51:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    af54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    af58:	8b 47 05             	mov    0x5(%edi),%eax
    af5b:	8d 78 fb             	lea    -0x5(%eax),%edi
    af5e:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    af61:	0f 84 d3 00 00 00    	je     b03a <ResourceAllocation_Algorithm+0x22a>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    af67:	85 c9                	test   %ecx,%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    af69:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    af6d:	0f 85 35 ff ff ff    	jne    aea8 <ResourceAllocation_Algorithm+0x98>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
    af73:	8b 55 c8             	mov    -0x38(%ebp),%edx
    af76:	8b 45 d8             	mov    -0x28(%ebp),%eax
    af79:	e8 fc ff ff ff       	call   af7a <ResourceAllocation_Algorithm+0x16a>
    af7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    af81:	8b 45 e0             	mov    -0x20(%ebp),%eax
    af84:	8b 58 05             	mov    0x5(%eax),%ebx
    af87:	89 c7                	mov    %eax,%edi
    af89:	83 c7 05             	add    $0x5,%edi
    af8c:	39 fb                	cmp    %edi,%ebx
    af8e:	8b 33                	mov    (%ebx),%esi
    af90:	75 0a                	jne    af9c <ResourceAllocation_Algorithm+0x18c>
    af92:	eb 2d                	jmp    afc1 <ResourceAllocation_Algorithm+0x1b1>
    af94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    af98:	89 f3                	mov    %esi,%ebx
    af9a:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    af9c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    af9f:	e8 fc ff ff ff       	call   afa0 <ResourceAllocation_Algorithm+0x190>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    afa4:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    afa6:	8d 43 fb             	lea    -0x5(%ebx),%eax
    afa9:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    afac:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    afaf:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    afb1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    afb3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    afb6:	e8 fc ff ff ff       	call   afb7 <ResourceAllocation_Algorithm+0x1a7>
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    afbb:	39 fe                	cmp    %edi,%esi
    afbd:	8b 06                	mov    (%esi),%eax
    afbf:	75 d7                	jne    af98 <ResourceAllocation_Algorithm+0x188>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
    afc1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    afc4:	e8 fc ff ff ff       	call   afc5 <ResourceAllocation_Algorithm+0x1b5>
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    afc9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    afcc:	8b 7d d0             	mov    -0x30(%ebp),%edi
    afcf:	8b 58 05             	mov    0x5(%eax),%ebx
    afd2:	39 5d d0             	cmp    %ebx,-0x30(%ebp)
    afd5:	8b 33                	mov    (%ebx),%esi
    afd7:	75 0b                	jne    afe4 <ResourceAllocation_Algorithm+0x1d4>
    afd9:	eb 2e                	jmp    b009 <ResourceAllocation_Algorithm+0x1f9>
    afdb:	90                   	nop
    afdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    afe0:	89 f3                	mov    %esi,%ebx
    afe2:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    afe4:	8b 43 fc             	mov    -0x4(%ebx),%eax
    afe7:	e8 fc ff ff ff       	call   afe8 <ResourceAllocation_Algorithm+0x1d8>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    afec:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    afee:	8d 43 fb             	lea    -0x5(%ebx),%eax
    aff1:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aff4:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    aff7:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aff9:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    affb:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    affe:	e8 fc ff ff ff       	call   afff <ResourceAllocation_Algorithm+0x1ef>
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    b003:	39 f7                	cmp    %esi,%edi
    b005:	8b 06                	mov    (%esi),%eax
    b007:	75 d7                	jne    afe0 <ResourceAllocation_Algorithm+0x1d0>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(lcbj_lessthan_zero);
    b009:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b00c:	e8 fc ff ff ff       	call   b00d <ResourceAllocation_Algorithm+0x1fd>
	Empty_MACBuffer_Rlc();//MacBufferStatus
    b011:	e8 fc ff ff ff       	call   b012 <ResourceAllocation_Algorithm+0x202>
	FRET(report_array);
}
    b016:	8b 45 ec             	mov    -0x14(%ebp),%eax
    b019:	83 c4 3c             	add    $0x3c,%esp
    b01c:	5b                   	pop    %ebx
    b01d:	5e                   	pop    %esi
    b01e:	5f                   	pop    %edi
    b01f:	5d                   	pop    %ebp
    b020:	c3                   	ret    
    b021:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    b028:	8b 47 05             	mov    0x5(%edi),%eax
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    b02b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    b02e:	8d 78 fb             	lea    -0x5(%eax),%edi
    b031:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    b034:	0f 85 2d ff ff ff    	jne    af67 <ResourceAllocation_Algorithm+0x157>
				}			
				break;
			}
		}
	}
	if(*res_length>0)
    b03a:	85 c9                	test   %ecx,%ecx
    b03c:	0f 84 31 ff ff ff    	je     af73 <ResourceAllocation_Algorithm+0x163>
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    b042:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    b045:	8b 58 05             	mov    0x5(%eax),%ebx
    b048:	83 eb 05             	sub    $0x5,%ebx
    b04b:	39 d8                	cmp    %ebx,%eax
    b04d:	0f 84 20 ff ff ff    	je     af73 <ResourceAllocation_Algorithm+0x163>
    b053:	8b 7d e8             	mov    -0x18(%ebp),%edi
    b056:	0b 7d ec             	or     -0x14(%ebp),%edi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b059:	89 75 dc             	mov    %esi,-0x24(%ebp)
    b05c:	89 c6                	mov    %eax,%esi
		}
	}
	if(*res_length>0)
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    b05e:	0b 7d e4             	or     -0x1c(%ebp),%edi
    b061:	eb 13                	jmp    b076 <ResourceAllocation_Algorithm+0x266>
    b063:	90                   	nop
    b064:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b068:	8b 5b 05             	mov    0x5(%ebx),%ebx
    b06b:	83 eb 05             	sub    $0x5,%ebx
    b06e:	39 de                	cmp    %ebx,%esi
    b070:	0f 84 fd fe ff ff    	je     af73 <ResourceAllocation_Algorithm+0x163>
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
    b076:	85 ff                	test   %edi,%edi
    b078:	74 ee                	je     b068 <ResourceAllocation_Algorithm+0x258>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    b07a:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b07d:	8d 55 f0             	lea    -0x10(%ebp),%edx
    b080:	89 54 24 0c          	mov    %edx,0xc(%esp)
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    b084:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b087:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    b08a:	89 44 24 08          	mov    %eax,0x8(%esp)
    b08e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    b091:	89 54 24 04          	mov    %edx,0x4(%esp)
    b095:	89 da                	mov    %ebx,%edx
    b097:	89 04 24             	mov    %eax,(%esp)
    b09a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b09d:	e8 fc ff ff ff       	call   b09e <ResourceAllocation_Algorithm+0x28e>
    b0a2:	eb c4                	jmp    b068 <ResourceAllocation_Algorithm+0x258>
    b0a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b0a8:	8b 75 e8             	mov    -0x18(%ebp),%esi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b0ab:	8d 45 f0             	lea    -0x10(%ebp),%eax
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b0ae:	89 d9                	mov    %ebx,%ecx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b0b0:	89 44 24 0c          	mov    %eax,0xc(%esp)
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b0b4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b0b7:	89 fa                	mov    %edi,%edx
    b0b9:	89 74 24 08          	mov    %esi,0x8(%esp)
    b0bd:	8b 75 ec             	mov    -0x14(%ebp),%esi
    b0c0:	89 74 24 04          	mov    %esi,0x4(%esp)
    b0c4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    b0c7:	89 34 24             	mov    %esi,(%esp)
					break;
    b0ca:	89 de                	mov    %ebx,%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b0cc:	e8 fc ff ff ff       	call   b0cd <ResourceAllocation_Algorithm+0x2bd>
    b0d1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					break;
    b0d4:	e9 7f fe ff ff       	jmp    af58 <ResourceAllocation_Algorithm+0x148>
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    b0d9:	e8 fc ff ff ff       	call   b0da <ResourceAllocation_Algorithm+0x2ca>
    b0de:	89 c2                	mov    %eax,%edx
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    b0e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b0e3:	66 03 42 0f          	add    0xf(%edx),%ax
    b0e7:	66 2b 45 ec          	sub    -0x14(%ebp),%ax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    b0eb:	8d 4a 13             	lea    0x13(%edx),%ecx
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    b0ee:	66 29 f0             	sub    %si,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    b0f1:	8b 75 d8             	mov    -0x28(%ebp),%esi
    b0f4:	66 2b 45 e4          	sub    -0x1c(%ebp),%ax
    b0f8:	66 89 42 0f          	mov    %ax,0xf(%edx)
    b0fc:	8b 46 17             	mov    0x17(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    b0ff:	89 4e 17             	mov    %ecx,0x17(%esi)
	new->next = next;
    b102:	8b 75 cc             	mov    -0x34(%ebp),%esi
	new->prev = prev;
    b105:	89 42 17             	mov    %eax,0x17(%edx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    b108:	89 72 13             	mov    %esi,0x13(%edx)
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    b10b:	89 de                	mov    %ebx,%esi
	new->prev = prev;
	prev->next = new;
    b10d:	89 08                	mov    %ecx,(%eax)
    b10f:	31 c9                	xor    %ecx,%ecx
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
    b111:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    b118:	e9 3b fe ff ff       	jmp    af58 <ResourceAllocation_Algorithm+0x148>
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b11d:	8b 75 e8             	mov    -0x18(%ebp),%esi
    b120:	89 d9                	mov    %ebx,%ecx
    b122:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b124:	89 44 24 0c          	mov    %eax,0xc(%esp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b128:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b12b:	89 74 24 08          	mov    %esi,0x8(%esp)
    b12f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    b132:	89 74 24 04          	mov    %esi,0x4(%esp)
    b136:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    b139:	89 34 24             	mov    %esi,(%esp)
						break;
    b13c:	89 de                	mov    %ebx,%esi
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b13e:	e8 fc ff ff ff       	call   b13f <ResourceAllocation_Algorithm+0x32f>
    b143:	8b 4d f0             	mov    -0x10(%ebp),%ecx
						break;
    b146:	e9 0d fe ff ff       	jmp    af58 <ResourceAllocation_Algorithm+0x148>
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    b14b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
    b14e:	31 f6                	xor    %esi,%esi
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
    b150:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    b157:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    b15e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    b165:	e9 d0 fe ff ff       	jmp    b03a <ResourceAllocation_Algorithm+0x22a>
    b16a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000b170 <DoResourceAllocation>:
->Output: RLC report
->Special:
*******************************
*/
void DoResourceAllocation(u32 tb_size)//
{
    b170:	55                   	push   %ebp
    b171:	89 e5                	mov    %esp,%ebp
    b173:	83 ec 10             	sub    $0x10,%esp
    b176:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b179:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b17c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b17f:	e8 fc ff ff ff       	call   b180 <DoResourceAllocation+0x10>
    b184:	89 c7                	mov    %eax,%edi
	u32 num;
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
    b186:	b8 04 00 00 00       	mov    $0x4,%eax
    b18b:	e8 fc ff ff ff       	call   b18c <DoResourceAllocation+0x1c>
    b190:	89 c3                	mov    %eax,%ebx
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    b192:	e8 fc ff ff ff       	call   b193 <DoResourceAllocation+0x23>
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b197:	89 da                	mov    %ebx,%edx
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    b199:	89 c6                	mov    %eax,%esi
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b19b:	89 f8                	mov    %edi,%eax
    b19d:	e8 fc ff ff ff       	call   b19e <DoResourceAllocation+0x2e>
	SV(DATA_WAIT_ALLOCATION)=false;
    b1a2:	c6 86 5a 01 00 00 00 	movb   $0x0,0x15a(%esi)

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b1a9:	89 c7                	mov    %eax,%edi
		printk(KERN_INFO" rlc_Report_statusPduSize:%d\n",rlc_temp[j].statusPduSize);
		printk(KERN_INFO" rlc_Report_statusPduHeader:%d\n",rlc_temp[j].statusPduHeader);
	}*/
	//fsm_printf("MAC :%d\n",sizeof(RLC_Request));
	//fsm_do_ioctrl(STRM_TO_RLC,IOCCMD_MACtoRLC_datasend_Allow,UEmac_Rlc_Report,*rlc_report_num);//MACRLC
	fsm_printf("[UEMAC][SCHEDULER]SEND DATA ALLOW IOCTL\n");
    b1ab:	c7 04 24 dc 2d 00 00 	movl   $0x2ddc,(%esp)
    b1b2:	e8 fc ff ff ff       	call   b1b3 <DoResourceAllocation+0x43>
	
	PMRLC_TRANSOP_IND ((void *)UEmac_Rlc_Report); 	//modify in 20150804
    b1b7:	89 f8                	mov    %edi,%eax
    b1b9:	e8 fc ff ff ff       	call   b1ba <DoResourceAllocation+0x4a>
	//fsm_mem_free(UEmac_Rlc_Report);//report 
	fsm_mem_free(rlc_report_num);
    b1be:	89 d8                	mov    %ebx,%eax
    b1c0:	e8 fc ff ff ff       	call   b1c1 <DoResourceAllocation+0x51>
	FOUT;

}
    b1c5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b1c8:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b1cb:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b1ce:	89 ec                	mov    %ebp,%esp
    b1d0:	5d                   	pop    %ebp
    b1d1:	c3                   	ret    
    b1d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b1d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b1e0 <Free_Uemac_Scheduler_Resource>:
->Output:
->Special:
*******************************
*/
void Free_Uemac_Scheduler_Resource(void)
{
    b1e0:	55                   	push   %ebp
    b1e1:	89 e5                	mov    %esp,%ebp
    b1e3:	57                   	push   %edi
    b1e4:	56                   	push   %esi
    b1e5:	53                   	push   %ebx
    b1e6:	e8 fc ff ff ff       	call   b1e7 <Free_Uemac_Scheduler_Resource+0x7>
	struct list_head *pos,*p;
	MacBufferStatus *temp_rlc_free=NULL;
	LogicalChannelBj *temp_bj_free=NULL;
	LogicalChannelConfigInfo *temp_lcginfo_free=NULL;//

	SV_PTR_GET(rlc_mac_sv);
    b1eb:	e8 fc ff ff ff       	call   b1ec <Free_Uemac_Scheduler_Resource+0xc>
    b1f0:	89 c6                	mov    %eax,%esi
	fsm_mem_free(SV(bsr));
    b1f2:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
    b1f8:	e8 fc ff ff ff       	call   b1f9 <Free_Uemac_Scheduler_Resource+0x19>
	//fsm_mem_free(Frame_No_Allocation);
	if(SV(Regularbsr)!=NULL)
    b1fd:	8b 86 4c 01 00 00    	mov    0x14c(%esi),%eax
    b203:	85 c0                	test   %eax,%eax
    b205:	74 0f                	je     b216 <Free_Uemac_Scheduler_Resource+0x36>
	{
		fsm_mem_free(SV(Regularbsr));
    b207:	e8 fc ff ff ff       	call   b208 <Free_Uemac_Scheduler_Resource+0x28>
		SV(Regularbsr)=NULL;
    b20c:	c7 86 4c 01 00 00 00 	movl   $0x0,0x14c(%esi)
    b213:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    b216:	8b 86 50 01 00 00    	mov    0x150(%esi),%eax
    b21c:	85 c0                	test   %eax,%eax
    b21e:	74 0f                	je     b22f <Free_Uemac_Scheduler_Resource+0x4f>
	{
		fsm_mem_free(SV(Periodicbsr));
    b220:	e8 fc ff ff ff       	call   b221 <Free_Uemac_Scheduler_Resource+0x41>
		SV(Periodicbsr)=NULL;
    b225:	c7 86 50 01 00 00 00 	movl   $0x0,0x150(%esi)
    b22c:	00 00 00 
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    b22f:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b235:	8b 58 05             	mov    0x5(%eax),%ebx
    b238:	83 c0 05             	add    $0x5,%eax
    b23b:	39 c3                	cmp    %eax,%ebx
    b23d:	8b 3b                	mov    (%ebx),%edi
    b23f:	75 0b                	jne    b24c <Free_Uemac_Scheduler_Resource+0x6c>
    b241:	eb 37                	jmp    b27a <Free_Uemac_Scheduler_Resource+0x9a>
    b243:	90                   	nop
    b244:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b248:	89 fb                	mov    %edi,%ebx
    b24a:	89 d7                	mov    %edx,%edi
	{
		temp_rlc_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_rlc_free->RlcRequestparams);
    b24c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    b24f:	e8 fc ff ff ff       	call   b250 <Free_Uemac_Scheduler_Resource+0x70>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b254:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_rlc_free->list));
    b257:	8d 43 fb             	lea    -0x5(%ebx),%eax
    b25a:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b25c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    b25f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b261:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    b263:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_rlc_free);
    b266:	e8 fc ff ff ff       	call   b267 <Free_Uemac_Scheduler_Resource+0x87>
	if(SV(Periodicbsr)!=NULL)
	{
		fsm_mem_free(SV(Periodicbsr));
		SV(Periodicbsr)=NULL;
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    b26b:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b271:	8b 17                	mov    (%edi),%edx
    b273:	83 c0 05             	add    $0x5,%eax
    b276:	39 c7                	cmp    %eax,%edi
    b278:	75 ce                	jne    b248 <Free_Uemac_Scheduler_Resource+0x68>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b27a:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b280:	8b 50 05             	mov    0x5(%eax),%edx
    b283:	83 c0 05             	add    $0x5,%eax
    b286:	39 c2                	cmp    %eax,%edx
    b288:	8b 1a                	mov    (%edx),%ebx
    b28a:	75 06                	jne    b292 <Free_Uemac_Scheduler_Resource+0xb2>
    b28c:	eb 2a                	jmp    b2b8 <Free_Uemac_Scheduler_Resource+0xd8>
    b28e:	66 90                	xchg   %ax,%ax
    b290:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b292:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
    b295:	8d 42 fb             	lea    -0x5(%edx),%eax
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b298:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b29a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b29d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b29f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b2a1:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
    b2a4:	e8 fc ff ff ff       	call   b2a5 <Free_Uemac_Scheduler_Resource+0xc5>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b2a9:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b2af:	8b 1b                	mov    (%ebx),%ebx
    b2b1:	83 c0 05             	add    $0x5,%eax
    b2b4:	39 c7                	cmp    %eax,%edi
    b2b6:	75 d8                	jne    b290 <Free_Uemac_Scheduler_Resource+0xb0>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b2b8:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b2be:	8b 50 11             	mov    0x11(%eax),%edx
    b2c1:	83 c0 11             	add    $0x11,%eax
    b2c4:	39 c2                	cmp    %eax,%edx
    b2c6:	8b 1a                	mov    (%edx),%ebx
    b2c8:	75 08                	jne    b2d2 <Free_Uemac_Scheduler_Resource+0xf2>
    b2ca:	eb 2c                	jmp    b2f8 <Free_Uemac_Scheduler_Resource+0x118>
    b2cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b2d0:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b2d2:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
    b2d5:	8d 42 ef             	lea    -0x11(%edx),%eax
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b2d8:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b2da:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b2dd:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b2df:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b2e1:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
    b2e4:	e8 fc ff ff ff       	call   b2e5 <Free_Uemac_Scheduler_Resource+0x105>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b2e9:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b2ef:	8b 1b                	mov    (%ebx),%ebx
    b2f1:	83 c0 11             	add    $0x11,%eax
    b2f4:	39 c7                	cmp    %eax,%edi
    b2f6:	75 d8                	jne    b2d0 <Free_Uemac_Scheduler_Resource+0xf0>
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
	}
	fsm_mem_free(SV(MacBuffer_RLC));
    b2f8:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b2fe:	e8 fc ff ff ff       	call   b2ff <Free_Uemac_Scheduler_Resource+0x11f>
	fsm_mem_free(SV(LogicalChannel_Bj));
    b303:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b309:	e8 fc ff ff ff       	call   b30a <Free_Uemac_Scheduler_Resource+0x12a>
	fsm_mem_free(SV(LogicalChannel_Config));
    b30e:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b314:	e8 fc ff ff ff       	call   b315 <Free_Uemac_Scheduler_Resource+0x135>
	
	FOUT;
}
    b319:	5b                   	pop    %ebx
    b31a:	5e                   	pop    %esi
    b31b:	5f                   	pop    %edi
    b31c:	5d                   	pop    %ebp
    b31d:	c3                   	ret    
    b31e:	66 90                	xchg   %ax,%ax

0000b320 <GetRbsize>:
->Output:
->Special:
*******************************
*/
u32 GetRbsize(u32  channel_bandwidth)
{
    b320:	55                   	push   %ebp
    b321:	89 e5                	mov    %esp,%ebp
    b323:	83 ec 04             	sub    $0x4,%esp
    b326:	e8 fc ff ff ff       	call   b327 <GetRbsize+0x7>

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b32b:	83 e8 03             	sub    $0x3,%eax
    b32e:	83 f8 11             	cmp    $0x11,%eax
    b331:	76 15                	jbe    b348 <GetRbsize+0x28>
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
    b333:	c7 04 24 08 2e 00 00 	movl   $0x2e08,(%esp)
    b33a:	e8 fc ff ff ff       	call   b33b <GetRbsize+0x1b>
    b33f:	31 c0                	xor    %eax,%eax
	}
	//}
	FRET(rbsize);
}
    b341:	c9                   	leave  
    b342:	c3                   	ret    
    b343:	90                   	nop
    b344:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b348:	ff 24 85 e0 03 00 00 	jmp    *0x3e0(,%eax,4)
    b34f:	90                   	nop
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
    b350:	b8 64 00 00 00       	mov    $0x64,%eax
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b355:	c9                   	leave  
    b356:	c3                   	ret    
    b357:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b358:	b8 0f 00 00 00       	mov    $0xf,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b35d:	c9                   	leave  
    b35e:	c3                   	ret    
    b35f:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b360:	b8 19 00 00 00       	mov    $0x19,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b365:	c9                   	leave  
    b366:	c3                   	ret    
    b367:	90                   	nop
	// {
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
    b368:	b8 32 00 00 00       	mov    $0x32,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b36d:	c9                   	leave  
    b36e:	c3                   	ret    
    b36f:	90                   	nop
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
    b370:	b8 4b 00 00 00       	mov    $0x4b,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b375:	c9                   	leave  
    b376:	c3                   	ret    
    b377:	89 f6                	mov    %esi,%esi
    b379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b380 <DoReceiveULgrant_Tbsize>:
    //???????????????? delay
    FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    b380:	55                   	push   %ebp
    b381:	89 e5                	mov    %esp,%ebp
    b383:	83 ec 20             	sub    $0x20,%esp
    b386:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b389:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b38c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b38f:	e8 fc ff ff ff       	call   b390 <DoReceiveULgrant_Tbsize+0x10>
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b394:	89 c7                	mov    %eax,%edi
    u16 mcs=receive_ulgrant.m_mcs;//20140725
    b396:	c1 e8 0f             	shr    $0xf,%eax
    b399:	83 e0 1f             	and    $0x1f,%eax
    b39c:	88 45 e4             	mov    %al,-0x1c(%ebp)
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b39f:	c1 ef 02             	shr    $0x2,%edi
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b3a2:	e8 fc ff ff ff       	call   b3a3 <DoReceiveULgrant_Tbsize+0x23>
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b3a7:	66 81 e7 ff 1f       	and    $0x1fff,%di
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b3ac:	89 c3                	mov    %eax,%ebx
    rb_number=GetRbsize(BANDWIDTH);
    b3ae:	b8 14 00 00 00       	mov    $0x14,%eax
    b3b3:	e8 fc ff ff ff       	call   b3b4 <DoReceiveULgrant_Tbsize+0x34>
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b3b8:	31 d2                	xor    %edx,%edx
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    b3ba:	89 c6                	mov    %eax,%esi
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b3bc:	89 f8                	mov    %edi,%eax
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b3be:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b3c2:	66 f7 f6             	div    %si
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b3c5:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b3cb:	8d 4e 01             	lea    0x1(%esi),%ecx
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b3ce:	01 c2                	add    %eax,%edx
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b3d0:	66 29 c1             	sub    %ax,%cx
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    b3d3:	83 c0 01             	add    $0x1,%eax
    b3d6:	66 39 d6             	cmp    %dx,%si
    b3d9:	0f 47 c8             	cmova  %eax,%ecx
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b3dc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b3e0:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME2 && (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME7)
    b3e6:	8d 50 01             	lea    0x1(%eax),%edx
    b3e9:	83 fa 04             	cmp    $0x4,%edx
    b3ec:	77 3a                	ja     b428 <DoReceiveULgrant_Tbsize+0xa8>
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
    b3ee:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b3f2:	66 c7 43 10 07 00    	movw   $0x7,0x10(%ebx)
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b3f8:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b3fc:	0f b7 c9             	movzwl %cx,%ecx
    b3ff:	8d 44 49 fd          	lea    -0x3(%ecx,%ecx,2),%eax
    b403:	8d 04 c0             	lea    (%eax,%eax,8),%eax
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b406:	83 e2 1f             	and    $0x1f,%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b409:	03 04 95 40 04 00 00 	add    0x440(,%edx,4),%eax
    b410:	8b 34 85 c0 04 00 00 	mov    0x4c0(,%eax,4),%esi
    //FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}
    b417:	89 f0                	mov    %esi,%eax
    b419:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b41c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b41f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b422:	89 ec                	mov    %ebp,%esp
    b424:	5d                   	pop    %ebp
    b425:	c3                   	ret    
    b426:	66 90                	xchg   %ax,%ax
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME7 && (SCHEDULE_ADVANCE+temp_subframe)<=9)
    b428:	8d 50 fc             	lea    -0x4(%eax),%edx
    b42b:	83 fa 01             	cmp    $0x1,%edx
    b42e:	76 26                	jbe    b456 <DoReceiveULgrant_Tbsize+0xd6>
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b430:	83 c0 04             	add    $0x4,%eax
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
    b433:	31 f6                	xor    %esi,%esi
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b435:	83 f8 09             	cmp    $0x9,%eax
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b438:	89 45 e0             	mov    %eax,-0x20(%ebp)
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b43b:	7e da                	jle    b417 <DoReceiveULgrant_Tbsize+0x97>
    b43d:	ba 67 66 66 66       	mov    $0x66666667,%edx
    b442:	f7 ea                	imul   %edx
    b444:	c1 ea 02             	shr    $0x2,%edx
    b447:	8d 04 92             	lea    (%edx,%edx,4),%eax
    b44a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b44d:	01 c0                	add    %eax,%eax
    b44f:	29 c2                	sub    %eax,%edx
    b451:	83 fa 02             	cmp    $0x2,%edx
    b454:	7f c1                	jg     b417 <DoReceiveULgrant_Tbsize+0x97>
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b456:	83 c7 01             	add    $0x1,%edi
    b459:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b45d:	66 c7 43 10 02 00    	movw   $0x2,0x10(%ebx)
    b463:	eb 93                	jmp    b3f8 <DoReceiveULgrant_Tbsize+0x78>
    b465:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b469:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b470 <My_Pow>:
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b470:	55                   	push   %ebp
    b471:	89 e5                	mov    %esp,%ebp
    b473:	53                   	push   %ebx
    b474:	e8 fc ff ff ff       	call   b475 <My_Pow+0x5>
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b479:	85 d2                	test   %edx,%edx
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b47b:	89 c1                	mov    %eax,%ecx
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b47d:	b8 01 00 00 00       	mov    $0x1,%eax
    b482:	74 16                	je     b49a <My_Pow+0x2a>
    b484:	bb 01 00 00 00       	mov    $0x1,%ebx
    b489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b490:	83 c3 01             	add    $0x1,%ebx
		powint*=num;
    b493:	0f af c1             	imul   %ecx,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b496:	39 da                	cmp    %ebx,%edx
    b498:	73 f6                	jae    b490 <My_Pow+0x20>
		powint*=num;
	FRET(powint);
}
    b49a:	5b                   	pop    %ebx
    b49b:	5d                   	pop    %ebp
    b49c:	c3                   	ret    
    b49d:	8d 76 00             	lea    0x0(%esi),%esi

0000b4a0 <My_Log2>:
->Output:log2(rb)
->Special:
*******************************
*/
u32 My_Log2(u32 rb)
{
    b4a0:	55                   	push   %ebp
    b4a1:	89 e5                	mov    %esp,%ebp
    b4a3:	83 ec 04             	sub    $0x4,%esp
    b4a6:	e8 fc ff ff ff       	call   b4a7 <My_Log2+0x7>
	ret=0;
	switch(rb)//20140514modified by lhl float
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
    b4ab:	ba 98 20 00 00       	mov    $0x2098,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4b0:	83 f8 19             	cmp    $0x19,%eax
    b4b3:	74 23                	je     b4d8 <My_Log2+0x38>
    b4b5:	76 29                	jbe    b4e0 <My_Log2+0x40>
    b4b7:	83 f8 4b             	cmp    $0x4b,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
    b4ba:	ba d5 2c 00 00       	mov    $0x2cd5,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4bf:	74 17                	je     b4d8 <My_Log2+0x38>
    b4c1:	83 f8 64             	cmp    $0x64,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
    b4c4:	66 ba 0e 30          	mov    $0x300e,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4c8:	74 0e                	je     b4d8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b4ca:	c7 04 24 3c 2e 00 00 	movl   $0x2e3c,(%esp)
    b4d1:	e8 fc ff ff ff       	call   b4d2 <My_Log2+0x32>
    b4d6:	31 d2                	xor    %edx,%edx
	}
	FRET(ret);
}//2
    b4d8:	89 d0                	mov    %edx,%eax
    b4da:	c9                   	leave  
    b4db:	c3                   	ret    
    b4dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4e0:	83 f8 06             	cmp    $0x6,%eax
	{
		case 6   : ret=4392 ;break;
    b4e3:	66 ba 28 11          	mov    $0x1128,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4e7:	74 ef                	je     b4d8 <My_Log2+0x38>
    b4e9:	83 f8 0f             	cmp    $0xf,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
    b4ec:	66 ba fb 1a          	mov    $0x1afb,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b4f0:	74 e6                	je     b4d8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b4f2:	c7 04 24 3c 2e 00 00 	movl   $0x2e3c,(%esp)
    b4f9:	e8 fc ff ff ff       	call   b4fa <My_Log2+0x5a>
    b4fe:	31 d2                	xor    %edx,%edx
    b500:	eb d6                	jmp    b4d8 <My_Log2+0x38>
    b502:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b510 <DoReceiveRARULgrant_Tbsize>:
->Output:
->Special:
*******************************
*/
u32 DoReceiveRARULgrant_Tbsize(RAR_ULgrant *receive_rar_ulgrant)
{
    b510:	55                   	push   %ebp
    b511:	89 e5                	mov    %esp,%ebp
    b513:	57                   	push   %edi
    b514:	56                   	push   %esi
    b515:	53                   	push   %ebx
    b516:	83 ec 1c             	sub    $0x1c,%esp
    b519:	e8 fc ff ff ff       	call   b51a <DoReceiveRARULgrant_Tbsize+0xa>
    b51e:	89 c6                	mov    %eax,%esi
	u16 rb_number;
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
    b520:	e8 fc ff ff ff       	call   b521 <DoReceiveRARULgrant_Tbsize+0x11>
    b525:	89 c7                	mov    %eax,%edi
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
    b527:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b52b:	c0 e8 03             	shr    $0x3,%al
    b52e:	83 e0 0f             	and    $0xf,%eax
    b531:	88 45 f1             	mov    %al,-0xf(%ebp)
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b534:	0f b6 06             	movzbl (%esi),%eax
    b537:	89 c3                	mov    %eax,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b539:	d0 e8                	shr    %al
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b53b:	83 e3 01             	and    $0x1,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b53e:	0f b6 d0             	movzbl %al,%edx
    b541:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b545:	83 e0 07             	and    $0x7,%eax
    b548:	c1 e0 07             	shl    $0x7,%eax
    b54b:	09 d0                	or     %edx,%eax
    b54d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b551:	0f b6 56 02          	movzbl 0x2(%esi),%edx
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b555:	b8 14 00 00 00       	mov    $0x14,%eax
	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b55a:	c0 ea 02             	shr    $0x2,%dl
    b55d:	83 e2 01             	and    $0x1,%edx
    b560:	88 55 f0             	mov    %dl,-0x10(%ebp)
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b563:	e8 fc ff ff ff       	call   b564 <DoReceiveRARULgrant_Tbsize+0x54>
	if(rb_number<=44)
    b568:	66 83 f8 2c          	cmp    $0x2c,%ax
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b56c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	if(rb_number<=44)
    b570:	0f 86 6a 01 00 00    	jbe    b6e0 <DoReceiveRARULgrant_Tbsize+0x1d0>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b576:	84 db                	test   %bl,%bl
    b578:	0f 85 b2 00 00 00    	jne    b630 <DoReceiveRARULgrant_Tbsize+0x120>
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b57e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b582:	bb 0a 00 00 00       	mov    $0xa,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b587:	e8 fc ff ff ff       	call   b588 <DoReceiveRARULgrant_Tbsize+0x78>
    b58c:	31 d2                	xor    %edx,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b58e:	b8 01 00 00 00       	mov    $0x1,%eax
    b593:	b9 01 00 00 00       	mov    $0x1,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b598:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b59b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b59d:	39 d8                	cmp    %ebx,%eax
    b59f:	76 f7                	jbe    b598 <DoReceiveRARULgrant_Tbsize+0x88>
    b5a1:	83 e9 01             	sub    $0x1,%ecx
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
    b5a4:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b5a8:	09 d1                	or     %edx,%ecx
    b5aa:	31 d2                	xor    %edx,%edx
    b5ac:	89 c8                	mov    %ecx,%eax
    b5ae:	66 f7 75 f2          	divw   -0xe(%ebp)
    b5b2:	89 d3                	mov    %edx,%ebx
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b5b4:	89 c8                	mov    %ecx,%eax
    b5b6:	31 d2                	xor    %edx,%edx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b5b8:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b5bc:	66 f7 75 f2          	divw   -0xe(%ebp)
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b5c0:	83 c1 01             	add    $0x1,%ecx
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b5c3:	66 29 c1             	sub    %ax,%cx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b5c6:	01 c3                	add    %eax,%ebx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b5c8:	66 39 5d f2          	cmp    %bx,-0xe(%ebp)
    b5cc:	8d 50 01             	lea    0x1(%eax),%edx
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b5cf:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b5d3:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b5d9:	0f 46 d1             	cmovbe %ecx,%edx
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b5dc:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if(ulDelay == true)//?????????????????????????????,delay
    b5e0:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b5e4:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
	if(ulDelay == true)//?????????????????????????????,delay
    b5ea:	0f 84 b8 00 00 00    	je     b6a8 <DoReceiveRARULgrant_Tbsize+0x198>
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b5f0:	66 83 f8 01          	cmp    $0x1,%ax
    b5f4:	76 19                	jbe    b60f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b5f6:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b5f9:	66 83 fb 04          	cmp    $0x4,%bx
    b5fd:	0f 86 c5 00 00 00    	jbe    b6c8 <DoReceiveRARULgrant_Tbsize+0x1b8>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b603:	83 e8 07             	sub    $0x7,%eax
    b606:	66 83 f8 02          	cmp    $0x2,%ax
    b60a:	77 0d                	ja     b619 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b60c:	83 c1 01             	add    $0x1,%ecx
    b60f:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b613:	66 c7 47 10 07 00    	movw   $0x7,0x10(%edi)
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b619:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    b61d:	0f b7 d2             	movzwl %dx,%edx
}
    b620:	83 c4 1c             	add    $0x1c,%esp
    b623:	5b                   	pop    %ebx
    b624:	5e                   	pop    %esi
    b625:	5f                   	pop    %edi
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b626:	6b c0 54             	imul   $0x54,%eax,%eax
}
    b629:	5d                   	pop    %ebp
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b62a:	0f af c2             	imul   %edx,%eax
}
    b62d:	c3                   	ret    
    b62e:	66 90                	xchg   %ax,%ax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b630:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b635:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b639:	19 c9                	sbb    %ecx,%ecx
    b63b:	f7 d1                	not    %ecx
    b63d:	83 c1 09             	add    $0x9,%ecx
    b640:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
    b645:	89 cb                	mov    %ecx,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b647:	89 4d d8             	mov    %ecx,-0x28(%ebp)
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b64a:	19 f6                	sbb    %esi,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b64c:	e8 fc ff ff ff       	call   b64d <DoReceiveRARULgrant_Tbsize+0x13d>
    b651:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b656:	8b 4d d8             	mov    -0x28(%ebp),%ecx
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b659:	83 c6 02             	add    $0x2,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b65c:	f7 e2                	mul    %edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b65e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b662:	c1 ea 06             	shr    $0x6,%edx
    b665:	83 ea 09             	sub    $0x9,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b668:	d3 f8                	sar    %cl,%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b66a:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b66e:	ba 01 00 00 00       	mov    $0x1,%edx
    b673:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    b677:	b8 01 00 00 00       	mov    $0x1,%eax
    b67c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b680:	83 c2 01             	add    $0x1,%edx
		powint*=num;
    b683:	01 c0                	add    %eax,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b685:	39 d6                	cmp    %edx,%esi
    b687:	73 f7                	jae    b680 <DoReceiveRARULgrant_Tbsize+0x170>
    b689:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
    b68d:	83 e8 01             	sub    $0x1,%eax
    b690:	66 23 45 dc          	and    -0x24(%ebp),%ax
    b694:	29 f2                	sub    %esi,%edx
    b696:	0f b7 c0             	movzwl %ax,%eax
    b699:	8d 4a 0a             	lea    0xa(%edx),%ecx
    b69c:	89 c2                	mov    %eax,%edx
    b69e:	d3 e2                	shl    %cl,%edx
    b6a0:	e9 e9 fe ff ff       	jmp    b58e <DoReceiveRARULgrant_Tbsize+0x7e>
    b6a5:	8d 76 00             	lea    0x0(%esi),%esi
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
	}
	else
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b6a8:	66 83 f8 01          	cmp    $0x1,%ax
    b6ac:	76 1d                	jbe    b6cb <DoReceiveRARULgrant_Tbsize+0x1bb>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b6ae:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b6b1:	66 83 fb 04          	cmp    $0x4,%bx
    b6b5:	0f 86 54 ff ff ff    	jbe    b60f <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b6bb:	83 e8 07             	sub    $0x7,%eax
    b6be:	66 83 f8 02          	cmp    $0x2,%ax
    b6c2:	0f 87 51 ff ff ff    	ja     b619 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b6c8:	83 c1 01             	add    $0x1,%ecx
    b6cb:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b6cf:	66 c7 47 10 02 00    	movw   $0x2,0x10(%edi)
    b6d5:	e9 3f ff ff ff       	jmp    b619 <DoReceiveRARULgrant_Tbsize+0x109>
    b6da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
    b6e0:	0f b7 c0             	movzwl %ax,%eax
    b6e3:	e8 fc ff ff ff       	call   b6e4 <DoReceiveRARULgrant_Tbsize+0x1d4>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b6e8:	b9 01 00 00 00       	mov    $0x1,%ecx
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b6ed:	66 c1 e8 03          	shr    $0x3,%ax
    b6f1:	0f b7 d0             	movzwl %ax,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b6f4:	b8 01 00 00 00       	mov    $0x1,%eax
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b6f9:	69 d2 c5 20 00 00    	imul   $0x20c5,%edx,%edx
    b6ff:	c1 ea 14             	shr    $0x14,%edx
    b702:	83 c2 01             	add    $0x1,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b705:	0f b7 d2             	movzwl %dx,%edx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b708:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b70b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b70d:	39 c2                	cmp    %eax,%edx
    b70f:	73 f7                	jae    b708 <DoReceiveRARULgrant_Tbsize+0x1f8>
    b711:	83 e9 01             	sub    $0x1,%ecx
    b714:	31 d2                	xor    %edx,%edx
    b716:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b71a:	89 c8                	mov    %ecx,%eax
    b71c:	66 f7 75 f2          	divw   -0xe(%ebp)
    b720:	89 d3                	mov    %edx,%ebx
    b722:	e9 8d fe ff ff       	jmp    b5b4 <DoReceiveRARULgrant_Tbsize+0xa4>
    b727:	90                   	nop
    b728:	90                   	nop
    b729:	90                   	nop
    b72a:	90                   	nop
    b72b:	90                   	nop
    b72c:	90                   	nop
    b72d:	90                   	nop
    b72e:	90                   	nop
    b72f:	90                   	nop

0000b730 <creat_subhead.isra.0>:
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b730:	55                   	push   %ebp
    b731:	89 e5                	mov    %esp,%ebp
    b733:	83 ec 10             	sub    $0x10,%esp
    b736:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b739:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b73c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b73f:	e8 fc ff ff ff       	call   b740 <creat_subhead.isra.0+0x10>
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b744:	83 38 7f             	cmpl   $0x7f,(%eax)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b747:	8b 75 0c             	mov    0xc(%ebp),%esi
    b74a:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
    b74e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b751:	76 3d                	jbe    b790 <creat_subhead.isra.0+0x60>
		*data += 2;
		//fsm_printf("the data is %d\n",  *data);
	}
	else
	{
		subfif= (MRLC_subHead_fif_IciMsg *)*ptr;
    b753:	8b 1a                	mov    (%edx),%ebx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
    b755:	83 e7 1f             	and    $0x1f,%edi
    b758:	83 cf 20             	or     $0x20,%edi
    b75b:	89 f9                	mov    %edi,%ecx
    b75d:	88 0b                	mov    %cl,(%ebx)
		subfif->fandl1 = skb->len>>8;
    b75f:	8b 38                	mov    (%eax),%edi
    b761:	c1 ef 08             	shr    $0x8,%edi
		subfif->fandl1 |= 0x80;
    b764:	83 cf 80             	or     $0xffffff80,%edi
    b767:	89 f9                	mov    %edi,%ecx
    b769:	88 4b 01             	mov    %cl,0x1(%ebx)
		subfif->fandl2 = skb->len&0xff;
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b76c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
		subfif->fandl1 = skb->len>>8;
		subfif->fandl1 |= 0x80;
		subfif->fandl2 = skb->len&0xff;
    b76f:	8b 00                	mov    (%eax),%eax
    b771:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b774:	89 19                	mov    %ebx,(%ecx)
		*ptr = subfif + 1;
    b776:	83 c3 03             	add    $0x3,%ebx
    b779:	89 1a                	mov    %ebx,(%edx)
		*data += 3;
    b77b:	83 06 03             	addl   $0x3,(%esi)
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b77e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b781:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b784:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b787:	89 ec                	mov    %ebp,%esp
    b789:	5d                   	pop    %ebp
    b78a:	c3                   	ret    
    b78b:	90                   	nop
    b78c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
	{
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
    b790:	8b 0a                	mov    (%edx),%ecx
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
    b792:	83 e7 1f             	and    $0x1f,%edi
    b795:	83 cf 20             	or     $0x20,%edi
    b798:	89 fb                	mov    %edi,%ebx
    b79a:	88 19                	mov    %bl,(%ecx)
		subsev->fandl = skb->len;
    b79c:	8b 00                	mov    (%eax),%eax
		subsev->fandl  &= 0x7f;
		*preptr = subsev;
		*ptr = subsev+1;
    b79e:	8d 59 02             	lea    0x2(%ecx),%ebx
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
		subsev->fandl = skb->len;
		subsev->fandl  &= 0x7f;
    b7a1:	83 e0 7f             	and    $0x7f,%eax
    b7a4:	88 41 01             	mov    %al,0x1(%ecx)
		*preptr = subsev;
    b7a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b7aa:	89 08                	mov    %ecx,(%eax)
		*ptr = subsev+1;
    b7ac:	89 1a                	mov    %ebx,(%edx)
		*data += 2;
    b7ae:	83 06 02             	addl   $0x2,(%esi)
		*preptr = subfif;
		*ptr = subfif + 1;
		*data += 3;
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b7b1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b7b4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b7b7:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b7ba:	89 ec                	mov    %ebp,%esp
    b7bc:	5d                   	pop    %ebp
    b7bd:	c3                   	ret    
    b7be:	66 90                	xchg   %ax,%ax

0000b7c0 <PCRLC_CONFIG_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_CONFIG_REQ(void)
{
    b7c0:	55                   	push   %ebp
    b7c1:	89 e5                	mov    %esp,%ebp
    b7c3:	56                   	push   %esi
    b7c4:	53                   	push   %ebx
    b7c5:	83 ec 10             	sub    $0x10,%esp
    b7c8:	e8 fc ff ff ff       	call   b7c9 <PCRLC_CONFIG_REQ+0x9>
	CRLC_ReConfigReq_IoctrlMsg *cIoctrl = (CRLC_ReConfigReq_IoctrlMsg*)fsm_data_get();
    b7cd:	e8 fc ff ff ff       	call   b7ce <PCRLC_CONFIG_REQ+0xe>
    b7d2:	89 c3                	mov    %eax,%ebx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b7d4:	e8 fc ff ff ff       	call   b7d5 <PCRLC_CONFIG_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b7d9:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b7dc:	89 c6                	mov    %eax,%esi
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b7de:	0f b6 03             	movzbl (%ebx),%eax
    b7e1:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    b7e7:	89 14 24             	mov    %edx,(%esp)
    b7ea:	8d 55 f0             	lea    -0x10(%ebp),%edx
    b7ed:	e8 fc ff ff ff       	call   b7ee <PCRLC_CONFIG_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
    b7f2:	c7 04 24 60 2e 00 00 	movl   $0x2e60,(%esp)
    b7f9:	e8 fc ff ff ff       	call   b7fa <PCRLC_CONFIG_REQ+0x3a>
	switch(cIoctrl->Mode)
    b7fe:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
    b802:	66 83 f8 02          	cmp    $0x2,%ax
    b806:	0f 84 b4 00 00 00    	je     b8c0 <PCRLC_CONFIG_REQ+0x100>
    b80c:	77 2a                	ja     b838 <PCRLC_CONFIG_REQ+0x78>
    b80e:	66 83 f8 01          	cmp    $0x1,%ax
    b812:	0f 84 e0 00 00 00    	je     b8f8 <PCRLC_CONFIG_REQ+0x138>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
		}
		break;

	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
    b818:	c7 04 24 c0 30 00 00 	movl   $0x30c0,(%esp)
    b81f:	e8 fc ff ff ff       	call   b820 <PCRLC_CONFIG_REQ+0x60>
		break;

	}
	fsm_data_destroy(cIoctrl);
    b824:	89 d8                	mov    %ebx,%eax
    b826:	e8 fc ff ff ff       	call   b827 <PCRLC_CONFIG_REQ+0x67>
	cIoctrl = NULL;
	FOUT;
}
    b82b:	83 c4 10             	add    $0x10,%esp
    b82e:	5b                   	pop    %ebx
    b82f:	5e                   	pop    %esi
    b830:	5d                   	pop    %ebp
    b831:	c3                   	ret    
    b832:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
    b838:	66 83 f8 03          	cmp    $0x3,%ax
    b83c:	74 4a                	je     b888 <PCRLC_CONFIG_REQ+0xc8>
    b83e:	66 83 f8 04          	cmp    $0x4,%ax
    b842:	75 d4                	jne    b818 <PCRLC_CONFIG_REQ+0x58>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
		}
		break;

	case UM_DOWN:			//UM
		if(SV(ins_mode) == UM_MODE)
    b844:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b84b:	0f 85 3f 01 00 00    	jne    b990 <PCRLC_CONFIG_REQ+0x1d0>
		{
			if(insptrd == NULL)
    b851:	8b 75 f4             	mov    -0xc(%ebp),%esi
    b854:	85 f6                	test   %esi,%esi
    b856:	74 cc                	je     b824 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b858:	0f b6 03             	movzbl (%ebx),%eax
    b85b:	c7 04 24 84 2f 00 00 	movl   $0x2f84,(%esp)
    b862:	89 44 24 04          	mov    %eax,0x4(%esp)
    b866:	e8 fc ff ff ff       	call   b867 <PCRLC_CONFIG_REQ+0xa7>
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b86b:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
    b86f:	66 89 46 06          	mov    %ax,0x6(%esi)
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
    b873:	8b 43 08             	mov    0x8(%ebx),%eax
    b876:	89 46 10             	mov    %eax,0x10(%esi)
	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
		break;

	}
	fsm_data_destroy(cIoctrl);
    b879:	89 d8                	mov    %ebx,%eax
    b87b:	e8 fc ff ff ff       	call   b87c <PCRLC_CONFIG_REQ+0xbc>
	cIoctrl = NULL;
	FOUT;
}
    b880:	83 c4 10             	add    $0x10,%esp
    b883:	5b                   	pop    %ebx
    b884:	5e                   	pop    %esi
    b885:	5d                   	pop    %ebp
    b886:	c3                   	ret    
    b887:	90                   	nop
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
		}
		break;

	case UM_UP:			//UM
		if(SV(ins_mode) ==  UM_MODE)
    b888:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b88f:	0f 85 e3 00 00 00    	jne    b978 <PCRLC_CONFIG_REQ+0x1b8>
		{
			if(insptru == NULL)
    b895:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b898:	85 f6                	test   %esi,%esi
    b89a:	74 88                	je     b824 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b89c:	0f b6 03             	movzbl (%ebx),%eax
    b89f:	c7 04 24 30 2f 00 00 	movl   $0x2f30,(%esp)
    b8a6:	89 44 24 04          	mov    %eax,0x4(%esp)
    b8aa:	e8 fc ff ff ff       	call   b8ab <PCRLC_CONFIG_REQ+0xeb>
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b8af:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b8b3:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b8b7:	e9 68 ff ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b8bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
		}
		break;

	case UM_UPDOWN:              	 //UM
		if(SV(ins_mode) == UM_MODE)
    b8c0:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b8c7:	0f 85 93 00 00 00    	jne    b960 <PCRLC_CONFIG_REQ+0x1a0>
		{
			if(insptru != NULL)
    b8cd:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b8d0:	85 f6                	test   %esi,%esi
    b8d2:	0f 84 79 ff ff ff    	je     b851 <PCRLC_CONFIG_REQ+0x91>
			{
				umTxIns = (UM_TX_Instance *)insptru;
				fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b8d8:	0f b6 03             	movzbl (%ebx),%eax
    b8db:	c7 04 24 30 2f 00 00 	movl   $0x2f30,(%esp)
    b8e2:	89 44 24 04          	mov    %eax,0x4(%esp)
    b8e6:	e8 fc ff ff ff       	call   b8e7 <PCRLC_CONFIG_REQ+0x127>
				umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b8eb:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b8ef:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b8f3:	e9 59 ff ff ff       	jmp    b851 <PCRLC_CONFIG_REQ+0x91>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		if(SV(ins_mode) == AM_MODE)
    b8f8:	83 be 18 02 00 00 03 	cmpl   $0x3,0x218(%esi)
    b8ff:	0f 85 a3 00 00 00    	jne    b9a8 <PCRLC_CONFIG_REQ+0x1e8>
		{
			if(insptru == NULL)
    b905:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b908:	85 f6                	test   %esi,%esi
    b90a:	0f 84 14 ff ff ff    	je     b824 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			amIns = (AM_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:am instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b910:	0f b6 03             	movzbl (%ebx),%eax
    b913:	c7 04 24 94 2e 00 00 	movl   $0x2e94,(%esp)
    b91a:	89 44 24 04          	mov    %eax,0x4(%esp)
    b91e:	e8 fc ff ff ff       	call   b91f <PCRLC_CONFIG_REQ+0x15f>
			amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
    b923:	8b 43 14             	mov    0x14(%ebx),%eax
    b926:	89 46 1c             	mov    %eax,0x1c(%esi)
			amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
    b929:	8b 43 10             	mov    0x10(%ebx),%eax
    b92c:	89 46 28             	mov    %eax,0x28(%esi)
			amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
    b92f:	8b 43 18             	mov    0x18(%ebx),%eax
    b932:	89 46 10             	mov    %eax,0x10(%esi)
			amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    b935:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
    b939:	66 89 86 f6 22 00 00 	mov    %ax,0x22f6(%esi)
			amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    b940:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
    b944:	66 89 86 f8 22 00 00 	mov    %ax,0x22f8(%esi)
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    b94b:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
    b94f:	66 89 86 fa 22 00 00 	mov    %ax,0x22fa(%esi)
			break;
    b956:	e9 c9 fe ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b95b:	90                   	nop
    b95c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
    b960:	c7 04 24 d8 2f 00 00 	movl   $0x2fd8,(%esp)
    b967:	e8 fc ff ff ff       	call   b968 <PCRLC_CONFIG_REQ+0x1a8>
    b96c:	e9 b3 fe ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b971:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
    b978:	c7 04 24 24 30 00 00 	movl   $0x3024,(%esp)
    b97f:	e8 fc ff ff ff       	call   b980 <PCRLC_CONFIG_REQ+0x1c0>
    b984:	e9 9b fe ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
    b990:	c7 04 24 70 30 00 00 	movl   $0x3070,(%esp)
    b997:	e8 fc ff ff ff       	call   b998 <PCRLC_CONFIG_REQ+0x1d8>
    b99c:	e9 83 fe ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b9a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
			break;
		}
		else
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
    b9a8:	c7 04 24 e4 2e 00 00 	movl   $0x2ee4,(%esp)
    b9af:	e8 fc ff ff ff       	call   b9b0 <PCRLC_CONFIG_REQ+0x1f0>
		}
		break;
    b9b4:	e9 6b fe ff ff       	jmp    b824 <PCRLC_CONFIG_REQ+0x64>
    b9b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000b9c0 <PCRLC_BULID_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_BULID_REQ(void)
{
    b9c0:	55                   	push   %ebp
    b9c1:	89 e5                	mov    %esp,%ebp
    b9c3:	57                   	push   %edi
    b9c4:	56                   	push   %esi
    b9c5:	53                   	push   %ebx
    b9c6:	83 ec 0c             	sub    $0xc,%esp
    b9c9:	e8 fc ff ff ff       	call   b9ca <PCRLC_BULID_REQ+0xa>
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
	
	SV_PTR_GET(rlc_mac_sv);
    b9ce:	e8 fc ff ff ff       	call   b9cf <PCRLC_BULID_REQ+0xf>
    b9d3:	89 c6                	mov    %eax,%esi
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
    b9d5:	c7 04 24 f0 30 00 00 	movl   $0x30f0,(%esp)
    b9dc:	e8 fc ff ff ff       	call   b9dd <PCRLC_BULID_REQ+0x1d>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
    b9e1:	e8 fc ff ff ff       	call   b9e2 <PCRLC_BULID_REQ+0x22>
    b9e6:	89 c7                	mov    %eax,%edi
	switch(cIoctrl->Mode)
    b9e8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b9ec:	66 83 f8 02          	cmp    $0x2,%ax
    b9f0:	0f 84 e2 01 00 00    	je     bbd8 <PCRLC_BULID_REQ+0x218>
    b9f6:	77 38                	ja     ba30 <PCRLC_BULID_REQ+0x70>
    b9f8:	66 83 f8 01          	cmp    $0x1,%ax
    b9fc:	0f 84 4f 03 00 00    	je     bd51 <PCRLC_BULID_REQ+0x391>
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
		break;

	default:
		fsm_printf("[RLC][PCRLC_BULID_REQ] wrong CRLC_BULID_REQ");
    ba02:	c7 04 24 1c 33 00 00 	movl   $0x331c,(%esp)
    ba09:	e8 fc ff ff ff       	call   ba0a <PCRLC_BULID_REQ+0x4a>
		break;

	}
	
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    ba0e:	b8 01 00 00 00       	mov    $0x1,%eax
    ba13:	e8 fc ff ff ff       	call   ba14 <PCRLC_BULID_REQ+0x54>
	cItrl->V_Flag = true;
    ba18:	c6 00 01             	movb   $0x1,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    ba1b:	e8 fc ff ff ff       	call   ba1c <PCRLC_BULID_REQ+0x5c>
	cItrl = NULL;
	fsm_data_destroy(cIoctrl);
    ba20:	89 f8                	mov    %edi,%eax
    ba22:	e8 fc ff ff ff       	call   ba23 <PCRLC_BULID_REQ+0x63>
	cIoctrl = NULL;
	FOUT;
}
    ba27:	83 c4 0c             	add    $0xc,%esp
    ba2a:	5b                   	pop    %ebx
    ba2b:	5e                   	pop    %esi
    ba2c:	5f                   	pop    %edi
    ba2d:	5d                   	pop    %ebp
    ba2e:	c3                   	ret    
    ba2f:	90                   	nop
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
    ba30:	66 83 f8 03          	cmp    $0x3,%ax
    ba34:	0f 84 22 01 00 00    	je     bb5c <PCRLC_BULID_REQ+0x19c>
    ba3a:	66 83 f8 04          	cmp    $0x4,%ax
    ba3e:	75 c2                	jne    ba02 <PCRLC_BULID_REQ+0x42>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    ba40:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    ba45:	e8 fc ff ff ff       	call   ba46 <PCRLC_BULID_REQ+0x86>
    ba4a:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    ba4c:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    ba50:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    ba54:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    ba58:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    ba5f:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    ba62:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    ba66:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    ba69:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    ba6c:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    ba73:	00 00 
    ba75:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    ba7c:	00 00 
    ba7e:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    ba85:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    ba87:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    ba8a:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    ba8c:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    ba92:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    ba99:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    baa0:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    baa6:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    baac:	eb 0d                	jmp    babb <PCRLC_BULID_REQ+0xfb>
    baae:	66 90                	xchg   %ax,%ax
    bab0:	83 fa 32             	cmp    $0x32,%edx
    bab3:	0f 84 52 05 00 00    	je     c00b <PCRLC_BULID_REQ+0x64b>
    bab9:	89 d0                	mov    %edx,%eax
    babb:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bac2:	ff 
    bac3:	8d 50 01             	lea    0x1(%eax),%edx
    bac6:	74 e8                	je     bab0 <PCRLC_BULID_REQ+0xf0>
		if(i >= MAX_CODE) 
    bac8:	83 fa 32             	cmp    $0x32,%edx
    bacb:	0f 84 3a 05 00 00    	je     c00b <PCRLC_BULID_REQ+0x64b>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    bad1:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bad4:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    badb:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    badf:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bae2:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    bae5:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    bae8:	31 c0                	xor    %eax,%eax
    baea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    baf0:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    baf7:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    baf8:	83 c0 01             	add    $0x1,%eax
    bafb:	83 f8 20             	cmp    $0x20,%eax
    bafe:	75 f0                	jne    baf0 <PCRLC_BULID_REQ+0x130>
    bb00:	30 c0                	xor    %al,%al
    bb02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    bb08:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    bb0f:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    bb13:	83 c0 01             	add    $0x1,%eax
    bb16:	3d 00 04 00 00       	cmp    $0x400,%eax
    bb1b:	75 eb                	jne    bb08 <PCRLC_BULID_REQ+0x148>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bb1d:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    bb23:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bb29:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    bb2f:	81 c6 c0 36 00 00    	add    $0x36c0,%esi
    bb35:	89 b3 c4 10 00 00    	mov    %esi,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    bb3b:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    bb41:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
    bb43:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    bb47:	c7 04 24 c4 32 00 00 	movl   $0x32c4,(%esp)
    bb4e:	89 44 24 04          	mov    %eax,0x4(%esp)
    bb52:	e8 fc ff ff ff       	call   bb53 <PCRLC_BULID_REQ+0x193>
		break;
    bb57:	e9 b2 fe ff ff       	jmp    ba0e <PCRLC_BULID_REQ+0x4e>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
    bb5c:	b8 38 00 00 00       	mov    $0x38,%eax
    bb61:	e8 fc ff ff ff       	call   bb62 <PCRLC_BULID_REQ+0x1a2>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    bb66:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    bb6a:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    bb6e:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bb72:	8d 48 30             	lea    0x30(%eax),%ecx
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    bb75:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    bb78:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    bb7b:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    bb7f:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bb85:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    bb8c:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    bb8f:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bb92:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bb99:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    bb9c:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bb9f:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bba5:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bbab:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    bbb1:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    bbb4:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    bbb7:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
    bbb9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    bbbd:	c7 04 24 6c 32 00 00 	movl   $0x326c,(%esp)
    bbc4:	89 44 24 04          	mov    %eax,0x4(%esp)
    bbc8:	e8 fc ff ff ff       	call   bbc9 <PCRLC_BULID_REQ+0x209>
		break;
    bbcd:	e9 3c fe ff ff       	jmp    ba0e <PCRLC_BULID_REQ+0x4e>
    bbd2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    bbd8:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    bbdd:	e8 fc ff ff ff       	call   bbde <PCRLC_BULID_REQ+0x21e>
    bbe2:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    bbe4:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    bbe8:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    bbec:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    bbf0:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    bbf7:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    bbfa:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    bbfe:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    bc01:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    bc04:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    bc0b:	00 00 
    bc0d:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    bc14:	00 00 
    bc16:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    bc1d:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    bc1f:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    bc22:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    bc24:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    bc2a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    bc31:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    bc38:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    bc3e:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    bc44:	eb 0d                	jmp    bc53 <PCRLC_BULID_REQ+0x293>
    bc46:	66 90                	xchg   %ax,%ax
    bc48:	83 fa 32             	cmp    $0x32,%edx
    bc4b:	0f 84 a9 03 00 00    	je     bffa <PCRLC_BULID_REQ+0x63a>
    bc51:	89 d0                	mov    %edx,%eax
    bc53:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bc5a:	ff 
    bc5b:	8d 50 01             	lea    0x1(%eax),%edx
    bc5e:	74 e8                	je     bc48 <PCRLC_BULID_REQ+0x288>
		if(i >= MAX_CODE) 
    bc60:	83 fa 32             	cmp    $0x32,%edx
    bc63:	0f 84 91 03 00 00    	je     bffa <PCRLC_BULID_REQ+0x63a>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    bc69:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bc6c:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    bc73:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    bc77:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc7a:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    bc7d:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    bc80:	31 c0                	xor    %eax,%eax
    bc82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    bc88:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    bc8f:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    bc90:	83 c0 01             	add    $0x1,%eax
    bc93:	83 f8 20             	cmp    $0x20,%eax
    bc96:	75 f0                	jne    bc88 <PCRLC_BULID_REQ+0x2c8>
    bc98:	30 c0                	xor    %al,%al
    bc9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    bca0:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    bca7:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    bcab:	83 c0 01             	add    $0x1,%eax
    bcae:	3d 00 04 00 00       	cmp    $0x400,%eax
    bcb3:	75 eb                	jne    bca0 <PCRLC_BULID_REQ+0x2e0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bcb5:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    bcbb:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
    bcc1:	8d 8e c0 36 00 00    	lea    0x36c0(%esi),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bcc7:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    bccd:	89 8b c4 10 00 00    	mov    %ecx,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    bcd3:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    bcd9:	89 10                	mov    %edx,(%eax)
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
    bcdb:	b8 38 00 00 00       	mov    $0x38,%eax
    bce0:	e8 fc ff ff ff       	call   bce1 <PCRLC_BULID_REQ+0x321>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    bce5:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    bce9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    bced:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bcf1:	8d 48 30             	lea    0x30(%eax),%ecx
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    bcf4:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    bcf7:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    bcfa:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    bcfe:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bd04:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    bd0b:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    bd0e:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bd11:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bd18:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    bd1b:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bd1e:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bd24:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bd2a:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    bd30:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    bd33:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    bd36:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
    bd38:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    bd3c:	c7 04 24 0c 32 00 00 	movl   $0x320c,(%esp)
    bd43:	89 44 24 04          	mov    %eax,0x4(%esp)
    bd47:	e8 fc ff ff ff       	call   bd48 <PCRLC_BULID_REQ+0x388>
		break;
    bd4c:	e9 bd fc ff ff       	jmp    ba0e <PCRLC_BULID_REQ+0x4e>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		amIns =  instance_create(struct AM_Instance);
    bd51:	b8 0c 23 00 00       	mov    $0x230c,%eax
    bd56:	e8 fc ff ff ff       	call   bd57 <PCRLC_BULID_REQ+0x397>
    bd5b:	89 c3                	mov    %eax,%ebx
		amIns->rbId = cIoctrl->rbIdentity;
    bd5d:	0f b6 07             	movzbl (%edi),%eax
    bd60:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
    bd63:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    bd67:	88 43 03             	mov    %al,0x3(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
    bd6a:	0f b6 c0             	movzbl %al,%eax
    bd6d:	89 44 24 04          	mov    %eax,0x4(%esp)
    bd71:	c7 04 24 24 31 00 00 	movl   $0x3124,(%esp)
    bd78:	e8 fc ff ff ff       	call   bd79 <PCRLC_BULID_REQ+0x3b9>
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    bd7d:	31 d2                	xor    %edx,%edx
		amIns =  instance_create(struct AM_Instance);
		amIns->rbId = cIoctrl->rbIdentity;
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
    bd7f:	6b 47 14 64          	imul   $0x64,0x14(%edi),%eax
    bd83:	89 43 1c             	mov    %eax,0x1c(%ebx)
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
    bd86:	6b 47 10 64          	imul   $0x64,0x10(%edi),%eax
    bd8a:	89 43 28             	mov    %eax,0x28(%ebx)
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
    bd8d:	6b 47 18 64          	imul   $0x64,0x18(%edi),%eax
    bd91:	89 43 10             	mov    %eax,0x10(%ebx)
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    bd94:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
    bd98:	66 89 83 f6 22 00 00 	mov    %ax,0x22f6(%ebx)
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    bd9f:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
    bda3:	66 89 83 f8 22 00 00 	mov    %ax,0x22f8(%ebx)
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bdaa:	0f b7 47 20          	movzwl 0x20(%edi),%eax
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bdae:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%ebx)
    bdb5:	00 00 00 
    bdb8:	c7 83 b8 01 00 00 00 	movl   $0x0,0x1b8(%ebx)
    bdbf:	00 00 00 
    bdc2:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bdc9:	66 89 83 fa 22 00 00 	mov    %ax,0x22fa(%ebx)
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bdd0:	c7 83 a4 01 00 00 00 	movl   $0x0,0x1a4(%ebx)
    bdd7:	00 00 00 
		amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = amIns->amTransmittedBufferNum = 0;
    bdda:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
    bde1:	00 00 00 
    bde4:	c7 83 bc 01 00 00 00 	movl   $0x0,0x1bc(%ebx)
    bdeb:	00 00 00 
    bdee:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
    bdf5:	c7 83 a8 01 00 00 00 	movl   $0x0,0x1a8(%ebx)
    bdfc:	00 00 00 
		amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
    bdff:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    be06:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    be0d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		amIns->currentStatVar = ST_TRAN;
    be14:	66 c7 43 2c 08 00    	movw   $0x8,0x2c(%ebx)
		amIns->pduLft.sduLeft = NULL;
    be1a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
		amIns->pduLft.SN_Left = -1;
    be21:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
		amIns->pduLft.SN5_Left = -1;
    be27:	66 c7 43 30 ff ff    	movw   $0xffff,0x30(%ebx)
		//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
		//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    be2d:	eb 0c                	jmp    be3b <PCRLC_BULID_REQ+0x47b>
    be2f:	90                   	nop
    be30:	83 f8 32             	cmp    $0x32,%eax
    be33:	0f 84 ab 01 00 00    	je     bfe4 <PCRLC_BULID_REQ+0x624>
    be39:	89 c2                	mov    %eax,%edx
    be3b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    be42:	ff 
    be43:	8d 42 01             	lea    0x1(%edx),%eax
    be46:	74 e8                	je     be30 <PCRLC_BULID_REQ+0x470>
		if(i >= MAX_CODE) 
    be48:	83 f8 32             	cmp    $0x32,%eax
    be4b:	0f 84 93 01 00 00    	je     bfe4 <PCRLC_BULID_REQ+0x624>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->pollRetxTimerCode = i - 1;
    be51:	89 53 0c             	mov    %edx,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    be54:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    be5b:	ff ff ff ff 
    be5f:	eb 09                	jmp    be6a <PCRLC_BULID_REQ+0x4aa>
    be61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    be68:	89 d0                	mov    %edx,%eax
    be6a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    be71:	ff 
    be72:	8d 50 01             	lea    0x1(%eax),%edx
    be75:	0f 85 a1 01 00 00    	jne    c01c <PCRLC_BULID_REQ+0x65c>
    be7b:	83 fa 31             	cmp    $0x31,%edx
    be7e:	7e e8                	jle    be68 <PCRLC_BULID_REQ+0x4a8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    be80:	89 55 f0             	mov    %edx,-0x10(%ebp)
    be83:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    be8a:	e8 fc ff ff ff       	call   be8b <PCRLC_BULID_REQ+0x4cb>
    be8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    be92:	eb 06                	jmp    be9a <PCRLC_BULID_REQ+0x4da>
    be94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		else
		{
			amIns->reorderTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    be98:	89 c2                	mov    %eax,%edx
    be9a:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bea1:	ff 
    bea2:	8d 42 01             	lea    0x1(%edx),%eax
    bea5:	0f 85 8d 01 00 00    	jne    c038 <PCRLC_BULID_REQ+0x678>
    beab:	83 f8 31             	cmp    $0x31,%eax
    beae:	7e e8                	jle    be98 <PCRLC_BULID_REQ+0x4d8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    beb0:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    beb7:	e8 fc ff ff ff       	call   beb8 <PCRLC_BULID_REQ+0x4f8>
		else
		{
			amIns->statProhTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
    bebc:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
    bec3:	00 00 
    bec5:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
    becc:	00 00 
    bece:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
    bed5:	00 00 
    bed7:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
    bede:	00 00 
    bee0:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
    bee7:	00 00 
    bee9:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
    bef0:	00 00 
		amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
    bef2:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
    bef9:	00 02 
    befb:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
    bf02:	00 02 
		amIns->SN = 0;
    bf04:	66 c7 43 2e 00 00    	movw   $0x0,0x2e(%ebx)
		amIns->statFlag = false;
    bf0a:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] init SN is %d\n",amIns->SN);
    bf0e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    bf15:	00 
    bf16:	c7 04 24 90 31 00 00 	movl   $0x3190,(%esp)
    bf1d:	e8 fc ff ff ff       	call   bf1e <PCRLC_BULID_REQ+0x55e>
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
    bf22:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bf25:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
    bf28:	89 43 48             	mov    %eax,0x48(%ebx)
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
    bf2b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bf31:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
    bf37:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
    bf3d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bf43:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
    bf49:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
    bf4f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bf55:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
    bf5b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
    bf61:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bf67:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
    bf6d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
		for(i = 0;  i < 1024; ++i )
    bf73:	31 c0                	xor    %eax,%eax
    bf75:	8d 76 00             	lea    0x0(%esi),%esi
		{
			amIns->amRecvWindow[i] = NULL;
    bf78:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
    bf7f:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
    bf83:	83 c0 01             	add    $0x1,%eax
    bf86:	3d 00 04 00 00       	cmp    $0x400,%eax
    bf8b:	75 eb                	jne    bf78 <PCRLC_BULID_REQ+0x5b8>
    bf8d:	66 31 c0             	xor    %ax,%ax
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amTranWindow[i]= NULL;
    bf90:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
    bf97:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
    bf9b:	83 c0 01             	add    $0x1,%eax
    bf9e:	3d 00 04 00 00       	cmp    $0x400,%eax
    bfa3:	75 eb                	jne    bf90 <PCRLC_BULID_REQ+0x5d0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bfa5:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		{
			amIns->amTranWindow[i]= NULL;
		}
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
    bfab:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bfb1:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
    bfb7:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
    bfbd:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
    bfc3:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
    bfc9:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
    bfcb:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    bfcf:	c7 04 24 b8 31 00 00 	movl   $0x31b8,(%esp)
    bfd6:	89 44 24 04          	mov    %eax,0x4(%esp)
    bfda:	e8 fc ff ff ff       	call   bfdb <PCRLC_BULID_REQ+0x61b>
		break;
    bfdf:	e9 2a fa ff ff       	jmp    ba0e <PCRLC_BULID_REQ+0x4e>
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bfe4:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    bfeb:	e8 fc ff ff ff       	call   bfec <PCRLC_BULID_REQ+0x62c>
    bff0:	b8 32 00 00 00       	mov    $0x32,%eax
    bff5:	e9 70 fe ff ff       	jmp    be6a <PCRLC_BULID_REQ+0x4aa>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bffa:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    c001:	e8 fc ff ff ff       	call   c002 <PCRLC_BULID_REQ+0x642>
    c006:	e9 6c fc ff ff       	jmp    bc77 <PCRLC_BULID_REQ+0x2b7>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    c00b:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    c012:	e8 fc ff ff ff       	call   c013 <PCRLC_BULID_REQ+0x653>
    c017:	e9 c3 fa ff ff       	jmp    badf <PCRLC_BULID_REQ+0x11f>
		{
			amIns->pollRetxTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    c01c:	83 fa 31             	cmp    $0x31,%edx
    c01f:	0f 8f 5b fe ff ff    	jg     be80 <PCRLC_BULID_REQ+0x4c0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->reorderTimerCode = i - 1;
    c025:	89 43 18             	mov    %eax,0x18(%ebx)
			SV(allocCode[i - 1]) = -1;
    c028:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    c02f:	ff ff ff ff 
    c033:	e9 62 fe ff ff       	jmp    be9a <PCRLC_BULID_REQ+0x4da>
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    c038:	83 f8 31             	cmp    $0x31,%eax
    c03b:	0f 8f 6f fe ff ff    	jg     beb0 <PCRLC_BULID_REQ+0x4f0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->statProhTimerCode = i - 1;
    c041:	89 53 24             	mov    %edx,0x24(%ebx)
			SV(allocCode[i - 1]) = -1;
    c044:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    c04b:	ff ff ff ff 
    c04f:	e9 68 fe ff ff       	jmp    bebc <PCRLC_BULID_REQ+0x4fc>
    c054:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    c05a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0000c060 <PCRLC_DEACT_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_DEACT_REQ(void)
{
    c060:	55                   	push   %ebp
    c061:	89 e5                	mov    %esp,%ebp
    c063:	57                   	push   %edi
    c064:	56                   	push   %esi
    c065:	53                   	push   %ebx
    c066:	83 ec 20             	sub    $0x20,%esp
    c069:	e8 fc ff ff ff       	call   c06a <PCRLC_DEACT_REQ+0xa>
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
    c06e:	e8 fc ff ff ff       	call   c06f <PCRLC_DEACT_REQ+0xf>
    c073:	89 c3                	mov    %eax,%ebx
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    c075:	e8 fc ff ff ff       	call   c076 <PCRLC_DEACT_REQ+0x16>
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    c07a:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c080:	8d 4d f0             	lea    -0x10(%ebp),%ecx
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    c083:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    c086:	0f b6 00             	movzbl (%eax),%eax
    c089:	89 14 24             	mov    %edx,(%esp)
    c08c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    c08f:	e8 fc ff ff ff       	call   c090 <PCRLC_DEACT_REQ+0x30>
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
    c094:	c7 04 24 48 33 00 00 	movl   $0x3348,(%esp)
    c09b:	e8 fc ff ff ff       	call   c09c <PCRLC_DEACT_REQ+0x3c>
	switch(SV(ins_mode))
    c0a0:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c0a6:	83 f8 02             	cmp    $0x2,%eax
    c0a9:	74 3d                	je     c0e8 <PCRLC_DEACT_REQ+0x88>
    c0ab:	83 f8 03             	cmp    $0x3,%eax
    c0ae:	0f 84 a4 01 00 00    	je     c258 <PCRLC_DEACT_REQ+0x1f8>
		//AM
		fsm_mem_free(amIns);
		amIns = NULL;
		break;
	default:
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:cannot distinguish the instance to distinguish.\n");
    c0b4:	c7 04 24 80 34 00 00 	movl   $0x3480,(%esp)
    c0bb:	e8 fc ff ff ff       	call   c0bc <PCRLC_DEACT_REQ+0x5c>
		break;
	}
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    c0c0:	b8 01 00 00 00       	mov    $0x1,%eax
    c0c5:	e8 fc ff ff ff       	call   c0c6 <PCRLC_DEACT_REQ+0x66>
	cItrl->V_Flag = false;
    c0ca:	c6 00 00             	movb   $0x0,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    c0cd:	e8 fc ff ff ff       	call   c0ce <PCRLC_DEACT_REQ+0x6e>
	cItrl = NULL;
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c0d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c0d5:	e8 fc ff ff ff       	call   c0d6 <PCRLC_DEACT_REQ+0x76>
	cIoctrl = NULL;

	FOUT;
}
    c0da:	83 c4 20             	add    $0x20,%esp
    c0dd:	5b                   	pop    %ebx
    c0de:	5e                   	pop    %esi
    c0df:	5f                   	pop    %edi
    c0e0:	5d                   	pop    %ebp
    c0e1:	c3                   	ret    
    c0e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    c0e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c0eb:	85 d2                	test   %edx,%edx
    c0ed:	0f 84 b7 00 00 00    	je     c1aa <PCRLC_DEACT_REQ+0x14a>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c0f3:	8b 8a c4 10 00 00    	mov    0x10c4(%edx),%ecx
    c0f9:	8b 82 c8 10 00 00    	mov    0x10c8(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c0ff:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
    c102:	89 08                	mov    %ecx,(%eax)
		{
			umRxIns = (UM_RX_Instance *)insptrd;
			//UM
			list_del(&umRxIns->umRxList);
			fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um recv instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c104:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c107:	c7 82 c4 10 00 00 00 	movl   $0x100100,0x10c4(%edx)
    c10e:	01 10 00 
	entry->prev = LIST_POISON2;
    c111:	c7 82 c8 10 00 00 00 	movl   $0x200200,0x10c8(%edx)
    c118:	02 20 00 
    c11b:	0f b6 01             	movzbl (%ecx),%eax
    c11e:	89 55 dc             	mov    %edx,-0x24(%ebp)
    c121:	c7 04 24 7c 33 00 00 	movl   $0x337c,(%esp)
    c128:	89 44 24 04          	mov    %eax,0x4(%esp)
    c12c:	e8 fc ff ff ff       	call   c12d <PCRLC_DEACT_REQ+0xcd>
			//
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    c131:	8b 55 dc             	mov    -0x24(%ebp),%edx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c134:	8b 72 30             	mov    0x30(%edx),%esi
    c137:	8d 4a 30             	lea    0x30(%edx),%ecx
    c13a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    c13d:	39 f1                	cmp    %esi,%ecx
    c13f:	74 62                	je     c1a3 <PCRLC_DEACT_REQ+0x143>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    c141:	8b 06                	mov    (%esi),%eax
    c143:	83 ee 10             	sub    $0x10,%esi
    c146:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    c149:	89 d3                	mov    %edx,%ebx
    c14b:	8d 78 f0             	lea    -0x10(%eax),%edi
    c14e:	eb 12                	jmp    c162 <PCRLC_DEACT_REQ+0x102>
    c150:	8b 47 10             	mov    0x10(%edi),%eax
    c153:	8d 4f 10             	lea    0x10(%edi),%ecx
    c156:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    c159:	8d 50 f0             	lea    -0x10(%eax),%edx
    c15c:	74 43                	je     c1a1 <PCRLC_DEACT_REQ+0x141>
    c15e:	89 fe                	mov    %edi,%esi
    c160:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c162:	8b 56 14             	mov    0x14(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c165:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c168:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
    c16a:	8b 55 e0             	mov    -0x20(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c16d:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    c174:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    c17b:	8b 43 0c             	mov    0xc(%ebx),%eax
    c17e:	89 84 82 28 02 00 00 	mov    %eax,0x228(%edx,%eax,4)
					fsm_pkt_destroy(umBuffer->pkt);
    c185:	8b 06                	mov    (%esi),%eax
    c187:	e8 fc ff ff ff       	call   c188 <PCRLC_DEACT_REQ+0x128>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    c18c:	89 f0                	mov    %esi,%eax
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    c18e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(umBuffer);
    c194:	e8 fc ff ff ff       	call   c195 <PCRLC_DEACT_REQ+0x135>
					umBuffer = NULL;
					if(list_empty(&umRxIns->umRecvBuffer.list))
    c199:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    c19c:	3b 4b 30             	cmp    0x30(%ebx),%ecx
    c19f:	75 af                	jne    c150 <PCRLC_DEACT_REQ+0xf0>
    c1a1:	89 da                	mov    %ebx,%edx
						break;
					}
				}
			}
			//UM
			fsm_mem_free(umRxIns);
    c1a3:	89 d0                	mov    %edx,%eax
    c1a5:	e8 fc ff ff ff       	call   c1a6 <PCRLC_DEACT_REQ+0x146>
			umRxIns = NULL;
		}
		if(insptru == NULL)
    c1aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c1ad:	85 c0                	test   %eax,%eax
    c1af:	89 45 e8             	mov    %eax,-0x18(%ebp)
    c1b2:	0f 84 08 ff ff ff    	je     c0c0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c1b8:	8b 50 30             	mov    0x30(%eax),%edx
    c1bb:	89 c1                	mov    %eax,%ecx
    c1bd:	8b 40 34             	mov    0x34(%eax),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c1c0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    c1c3:	89 10                	mov    %edx,(%eax)
		}
		umTxIns = (UM_TX_Instance *)insptru;

		//UM
		list_del(&umTxIns->umTxList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um tran instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c1c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c1c8:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    c1cf:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    c1d6:	0f b6 02             	movzbl (%edx),%eax
    c1d9:	c7 04 24 d4 33 00 00 	movl   $0x33d4,(%esp)
    c1e0:	89 44 24 04          	mov    %eax,0x4(%esp)
    c1e4:	e8 fc ff ff ff       	call   c1e5 <PCRLC_DEACT_REQ+0x185>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c1e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
		//UM
		if(!list_empty(&umTxIns->umSduBuffer.list))
    c1ec:	8b 7d e8             	mov    -0x18(%ebp),%edi
    c1ef:	8b 58 18             	mov    0x18(%eax),%ebx
    c1f2:	83 c7 18             	add    $0x18,%edi
    c1f5:	39 df                	cmp    %ebx,%edi
    c1f7:	74 52                	je     c24b <PCRLC_DEACT_REQ+0x1eb>
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    c1f9:	8b 03                	mov    (%ebx),%eax
    c1fb:	83 eb 10             	sub    $0x10,%ebx
    c1fe:	8d 70 f0             	lea    -0x10(%eax),%esi
    c201:	eb 16                	jmp    c219 <PCRLC_DEACT_REQ+0x1b9>
    c203:	90                   	nop
    c204:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c208:	8b 46 10             	mov    0x10(%esi),%eax
    c20b:	8d 4e 10             	lea    0x10(%esi),%ecx
    c20e:	39 cf                	cmp    %ecx,%edi
    c210:	8d 50 f0             	lea    -0x10(%eax),%edx
    c213:	74 36                	je     c24b <PCRLC_DEACT_REQ+0x1eb>
    c215:	89 f3                	mov    %esi,%ebx
    c217:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c219:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c21c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c21f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
    c221:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c223:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    c22a:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    c231:	e8 fc ff ff ff       	call   c232 <PCRLC_DEACT_REQ+0x1d2>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    c236:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    c238:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    c23e:	e8 fc ff ff ff       	call   c23f <PCRLC_DEACT_REQ+0x1df>
				umBuffer = NULL;
				if(list_empty(&umTxIns->umSduBuffer.list))
    c243:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c246:	3b 78 18             	cmp    0x18(%eax),%edi
    c249:	75 bd                	jne    c208 <PCRLC_DEACT_REQ+0x1a8>
					break;
				}
			}
		}
		//UM
		fsm_mem_free(umTxIns);
    c24b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c24e:	e8 fc ff ff ff       	call   c24f <PCRLC_DEACT_REQ+0x1ef>
		umTxIns = NULL;
		break;
    c253:	e9 68 fe ff ff       	jmp    c0c0 <PCRLC_DEACT_REQ+0x60>
	case AM_MODE:
		amIns = (AM_Instance *)insptru;
    c258:	8b 75 ec             	mov    -0x14(%ebp),%esi
		if(amIns == NULL)
    c25b:	85 f6                	test   %esi,%esi
    c25d:	0f 84 5d fe ff ff    	je     c0c0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c263:	8b 96 04 23 00 00    	mov    0x2304(%esi),%edx
    c269:	8b 86 08 23 00 00    	mov    0x2308(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c26f:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    c272:	89 10                	mov    %edx,(%eax)
		{
			break;
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c274:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c277:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    c27e:	01 10 00 
	entry->prev = LIST_POISON2;
    c281:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    c288:	02 20 00 
    c28b:	0f b6 02             	movzbl (%edx),%eax
    c28e:	c7 04 24 2c 34 00 00 	movl   $0x342c,(%esp)
    c295:	89 44 24 04          	mov    %eax,0x4(%esp)
    c299:	e8 fc ff ff ff       	call   c29a <PCRLC_DEACT_REQ+0x23a>
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c29e:	8b 46 0c             	mov    0xc(%esi),%eax
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c2a1:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c2a7:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
    c2ae:	8b 46 18             	mov    0x18(%esi),%eax
    c2b1:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
    c2b8:	8b 46 24             	mov    0x24(%esi),%eax
    c2bb:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c2c2:	8b 9e 9c 01 00 00    	mov    0x19c(%esi),%ebx
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c2c8:	39 da                	cmp    %ebx,%edx
    c2ca:	74 77                	je     c343 <PCRLC_DEACT_REQ+0x2e3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    c2cc:	8b 03                	mov    (%ebx),%eax
    c2ce:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c2d4:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c2d7:	89 d6                	mov    %edx,%esi
    c2d9:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c2df:	eb 21                	jmp    c302 <PCRLC_DEACT_REQ+0x2a2>
    c2e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c2e8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c2ee:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c2f4:	39 ce                	cmp    %ecx,%esi
    c2f6:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c2fc:	74 42                	je     c340 <PCRLC_DEACT_REQ+0x2e0>
    c2fe:	89 fb                	mov    %edi,%ebx
    c300:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c302:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c308:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c30b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c30d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c30f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c316:	01 10 00 
	entry->prev = LIST_POISON2;
    c319:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c320:	02 20 00 
    c323:	e8 fc ff ff ff       	call   c324 <PCRLC_DEACT_REQ+0x2c4>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c328:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c32a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c330:	e8 fc ff ff ff       	call   c331 <PCRLC_DEACT_REQ+0x2d1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRetxBuffer.list))
    c335:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c338:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    c33e:	75 a8                	jne    c2e8 <PCRLC_DEACT_REQ+0x288>
    c340:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c343:	8b 9e f0 00 00 00    	mov    0xf0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amTransmittedBuffer.list))
    c349:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    c34f:	39 da                	cmp    %ebx,%edx
    c351:	74 70                	je     c3c3 <PCRLC_DEACT_REQ+0x363>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    c353:	8b 03                	mov    (%ebx),%eax
    c355:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c35b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c35e:	89 d6                	mov    %edx,%esi
    c360:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c366:	eb 1a                	jmp    c382 <PCRLC_DEACT_REQ+0x322>
    c368:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c36e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c374:	39 ce                	cmp    %ecx,%esi
    c376:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c37c:	74 42                	je     c3c0 <PCRLC_DEACT_REQ+0x360>
    c37e:	89 fb                	mov    %edi,%ebx
    c380:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c382:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c388:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c38b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c38d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c38f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c396:	01 10 00 
	entry->prev = LIST_POISON2;
    c399:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c3a0:	02 20 00 
    c3a3:	e8 fc ff ff ff       	call   c3a4 <PCRLC_DEACT_REQ+0x344>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c3a8:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c3aa:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c3b0:	e8 fc ff ff ff       	call   c3b1 <PCRLC_DEACT_REQ+0x351>
				amBuffer = NULL;
				if(list_empty(&amIns->amTransmittedBuffer.list))
    c3b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c3b8:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    c3be:	75 a8                	jne    c368 <PCRLC_DEACT_REQ+0x308>
    c3c0:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c3c3:	8b 5e 44             	mov    0x44(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amSduBuffer.list))
    c3c6:	8d 56 44             	lea    0x44(%esi),%edx
    c3c9:	39 da                	cmp    %ebx,%edx
    c3cb:	74 59                	je     c426 <PCRLC_DEACT_REQ+0x3c6>
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    c3cd:	8b 03                	mov    (%ebx),%eax
    c3cf:	83 eb 0c             	sub    $0xc,%ebx
    c3d2:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c3d5:	89 d6                	mov    %edx,%esi
    c3d7:	8d 78 f4             	lea    -0xc(%eax),%edi
    c3da:	eb 15                	jmp    c3f1 <PCRLC_DEACT_REQ+0x391>
    c3dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c3e0:	8b 47 0c             	mov    0xc(%edi),%eax
    c3e3:	8d 4f 0c             	lea    0xc(%edi),%ecx
    c3e6:	39 ce                	cmp    %ecx,%esi
    c3e8:	8d 50 f4             	lea    -0xc(%eax),%edx
    c3eb:	74 36                	je     c423 <PCRLC_DEACT_REQ+0x3c3>
    c3ed:	89 fb                	mov    %edi,%ebx
    c3ef:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c3f1:	8b 53 10             	mov    0x10(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c3f4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c3f7:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
    c3f9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c3fb:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    c402:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
    c409:	e8 fc ff ff ff       	call   c40a <PCRLC_DEACT_REQ+0x3aa>
				amsBuffer->pkt = NULL;
				fsm_mem_free(amsBuffer);
    c40e:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
				amsBuffer->pkt = NULL;
    c410:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amsBuffer);
    c416:	e8 fc ff ff ff       	call   c417 <PCRLC_DEACT_REQ+0x3b7>
				amsBuffer = NULL;
				if(list_empty(&amIns->amSduBuffer.list))
    c41b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c41e:	3b 70 44             	cmp    0x44(%eax),%esi
    c421:	75 bd                	jne    c3e0 <PCRLC_DEACT_REQ+0x380>
    c423:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c426:	8b 9e b0 01 00 00    	mov    0x1b0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->ctrlPduBuffer.list))
    c42c:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    c432:	39 da                	cmp    %ebx,%edx
    c434:	74 5b                	je     c491 <PCRLC_DEACT_REQ+0x431>
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    c436:	8b 03                	mov    (%ebx),%eax
    c438:	83 eb 04             	sub    $0x4,%ebx
    c43b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c43e:	89 d6                	mov    %edx,%esi
    c440:	8d 78 fc             	lea    -0x4(%eax),%edi
    c443:	eb 14                	jmp    c459 <PCRLC_DEACT_REQ+0x3f9>
    c445:	8d 76 00             	lea    0x0(%esi),%esi
    c448:	8b 47 04             	mov    0x4(%edi),%eax
    c44b:	8d 4f 04             	lea    0x4(%edi),%ecx
    c44e:	39 ce                	cmp    %ecx,%esi
    c450:	8d 50 fc             	lea    -0x4(%eax),%edx
    c453:	74 39                	je     c48e <PCRLC_DEACT_REQ+0x42e>
    c455:	89 fb                	mov    %edi,%ebx
    c457:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c459:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c45c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c45f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
    c461:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c463:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    c46a:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    c471:	e8 fc ff ff ff       	call   c472 <PCRLC_DEACT_REQ+0x412>
				buffer->pkt = NULL;
				fsm_mem_free(buffer);
    c476:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
				buffer->pkt = NULL;
    c478:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(buffer);
    c47e:	e8 fc ff ff ff       	call   c47f <PCRLC_DEACT_REQ+0x41f>
				buffer = NULL;
				if(list_empty(&amIns->ctrlPduBuffer.list))
    c483:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c486:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    c48c:	75 ba                	jne    c448 <PCRLC_DEACT_REQ+0x3e8>
    c48e:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c491:	8b 9e 5c 02 00 00    	mov    0x25c(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amRecvBuffer.list))
    c497:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    c49d:	39 da                	cmp    %ebx,%edx
    c49f:	74 72                	je     c513 <PCRLC_DEACT_REQ+0x4b3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    c4a1:	8b 03                	mov    (%ebx),%eax
    c4a3:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c4a9:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c4ac:	89 d6                	mov    %edx,%esi
    c4ae:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c4b4:	eb 1c                	jmp    c4d2 <PCRLC_DEACT_REQ+0x472>
    c4b6:	66 90                	xchg   %ax,%ax
    c4b8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c4be:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c4c4:	39 ce                	cmp    %ecx,%esi
    c4c6:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c4cc:	74 42                	je     c510 <PCRLC_DEACT_REQ+0x4b0>
    c4ce:	89 fb                	mov    %edi,%ebx
    c4d0:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c4d2:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c4d8:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c4db:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c4dd:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c4df:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c4e6:	01 10 00 
	entry->prev = LIST_POISON2;
    c4e9:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c4f0:	02 20 00 
    c4f3:	e8 fc ff ff ff       	call   c4f4 <PCRLC_DEACT_REQ+0x494>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c4f8:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c4fa:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c500:	e8 fc ff ff ff       	call   c501 <PCRLC_DEACT_REQ+0x4a1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRecvBuffer.list))
    c505:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c508:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    c50e:	75 a8                	jne    c4b8 <PCRLC_DEACT_REQ+0x458>
    c510:	8b 75 e8             	mov    -0x18(%ebp),%esi
					break;
				}
			}
		}
		//AM
		fsm_mem_free(amIns);
    c513:	89 f0                	mov    %esi,%eax
    c515:	e8 fc ff ff ff       	call   c516 <PCRLC_DEACT_REQ+0x4b6>
		amIns = NULL;
		break;
    c51a:	e9 a1 fb ff ff       	jmp    c0c0 <PCRLC_DEACT_REQ+0x60>
    c51f:	90                   	nop

0000c520 <PCRLC_SUSPEND_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_SUSPEND_REQ(void)
{
    c520:	55                   	push   %ebp
    c521:	89 e5                	mov    %esp,%ebp
    c523:	56                   	push   %esi
    c524:	53                   	push   %ebx
    c525:	83 ec 14             	sub    $0x14,%esp
    c528:	e8 fc ff ff ff       	call   c529 <PCRLC_SUSPEND_REQ+0x9>
	CRLC_SuspendReq_IoctrlMsg *cIoctrl = (CRLC_SuspendReq_IoctrlMsg*) fsm_data_get();
    c52d:	e8 fc ff ff ff       	call   c52e <PCRLC_SUSPEND_REQ+0xe>
    c532:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c534:	e8 fc ff ff ff       	call   c535 <PCRLC_SUSPEND_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c539:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c53c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c53e:	0f b6 06             	movzbl (%esi),%eax
    c541:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c547:	89 14 24             	mov    %edx,(%esp)
    c54a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c54d:	e8 fc ff ff ff       	call   c54e <PCRLC_SUSPEND_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
    c552:	0f b6 06             	movzbl (%esi),%eax
    c555:	89 44 24 08          	mov    %eax,0x8(%esp)
    c559:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c55f:	c7 04 24 d8 34 00 00 	movl   $0x34d8,(%esp)
    c566:	89 44 24 04          	mov    %eax,0x4(%esp)
    c56a:	e8 fc ff ff ff       	call   c56b <PCRLC_SUSPEND_REQ+0x4b>
	switch(SV(ins_mode))
    c56f:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c575:	83 f8 02             	cmp    $0x2,%eax
    c578:	74 26                	je     c5a0 <PCRLC_SUSPEND_REQ+0x80>
    c57a:	83 f8 03             	cmp    $0x3,%eax
    c57d:	0f 84 85 00 00 00    	je     c608 <PCRLC_SUSPEND_REQ+0xe8>
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
		}
		break;
	default:
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:cannot distinguish the instance \n");
    c583:	c7 04 24 40 36 00 00 	movl   $0x3640,(%esp)
    c58a:	e8 fc ff ff ff       	call   c58b <PCRLC_SUSPEND_REQ+0x6b>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c58f:	89 f0                	mov    %esi,%eax
    c591:	e8 fc ff ff ff       	call   c592 <PCRLC_SUSPEND_REQ+0x72>
	cIoctrl = NULL;
	FOUT;
}
    c596:	83 c4 14             	add    $0x14,%esp
    c599:	5b                   	pop    %ebx
    c59a:	5e                   	pop    %esi
    c59b:	5d                   	pop    %ebp
    c59c:	c3                   	ret    
    c59d:	8d 76 00             	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    c5a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c5a3:	85 db                	test   %ebx,%ebx
    c5a5:	74 2e                	je     c5d5 <PCRLC_SUSPEND_REQ+0xb5>
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c5a7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
	case UM_MODE:
		if(insptrd != NULL)
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
    c5ab:	c6 83 c2 10 00 00 09 	movb   $0x9,0x10c2(%ebx)
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c5b2:	c7 04 24 3c 35 00 00 	movl   $0x353c,(%esp)
    c5b9:	89 44 24 04          	mov    %eax,0x4(%esp)
    c5bd:	e8 fc ff ff ff       	call   c5be <PCRLC_SUSPEND_REQ+0x9e>
			if(umRxIns->reorderTimer)
    c5c2:	8b 43 08             	mov    0x8(%ebx),%eax
    c5c5:	85 c0                	test   %eax,%eax
    c5c7:	74 0c                	je     c5d5 <PCRLC_SUSPEND_REQ+0xb5>
			{
				fsm_schedule_cancel(umRxIns->reorderTimer);
    c5c9:	e8 fc ff ff ff       	call   c5ca <PCRLC_SUSPEND_REQ+0xaa>
				umRxIns->reorderTimer = 0;
    c5ce:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			}
		}
		if(insptru == NULL)
    c5d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c5d8:	85 c0                	test   %eax,%eax
    c5da:	74 b3                	je     c58f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		umTxIns = (UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_SUSPEND;
    c5dc:	c6 40 2c 09          	movb   $0x9,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
    c5e0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    c5e4:	c7 04 24 94 35 00 00 	movl   $0x3594,(%esp)
    c5eb:	89 44 24 04          	mov    %eax,0x4(%esp)
    c5ef:	e8 fc ff ff ff       	call   c5f0 <PCRLC_SUSPEND_REQ+0xd0>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c5f4:	89 f0                	mov    %esi,%eax
    c5f6:	e8 fc ff ff ff       	call   c5f7 <PCRLC_SUSPEND_REQ+0xd7>
	cIoctrl = NULL;
	FOUT;
}
    c5fb:	83 c4 14             	add    $0x14,%esp
    c5fe:	5b                   	pop    %ebx
    c5ff:	5e                   	pop    %esi
    c600:	5d                   	pop    %ebp
    c601:	c3                   	ret    
    c602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c608:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    c60b:	85 db                	test   %ebx,%ebx
    c60d:	0f 84 7c ff ff ff    	je     c58f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c613:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
		if(insptru == NULL)
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
    c617:	66 c7 43 2c 09 00    	movw   $0x9,0x2c(%ebx)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c61d:	c7 04 24 ec 35 00 00 	movl   $0x35ec,(%esp)
    c624:	89 44 24 04          	mov    %eax,0x4(%esp)
    c628:	e8 fc ff ff ff       	call   c629 <PCRLC_SUSPEND_REQ+0x109>
		if(amIns->pollRetxTimer)
    c62d:	8b 43 08             	mov    0x8(%ebx),%eax
    c630:	85 c0                	test   %eax,%eax
    c632:	74 0c                	je     c640 <PCRLC_SUSPEND_REQ+0x120>
		{
			fsm_schedule_cancel(amIns->pollRetxTimer);
    c634:	e8 fc ff ff ff       	call   c635 <PCRLC_SUSPEND_REQ+0x115>
			amIns->pollRetxTimer = 0;
    c639:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		}
		if(amIns->reorderTimer)
    c640:	8b 43 14             	mov    0x14(%ebx),%eax
    c643:	85 c0                	test   %eax,%eax
    c645:	74 0c                	je     c653 <PCRLC_SUSPEND_REQ+0x133>
		{
			fsm_schedule_cancel(amIns->reorderTimer);
    c647:	e8 fc ff ff ff       	call   c648 <PCRLC_SUSPEND_REQ+0x128>
			amIns->reorderTimer = 0;
    c64c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		}
		if(amIns->statProhTimer)
    c653:	8b 43 20             	mov    0x20(%ebx),%eax
    c656:	85 c0                	test   %eax,%eax
    c658:	0f 84 31 ff ff ff    	je     c58f <PCRLC_SUSPEND_REQ+0x6f>
		{
			fsm_schedule_cancel(amIns->statProhTimer);
    c65e:	e8 fc ff ff ff       	call   c65f <PCRLC_SUSPEND_REQ+0x13f>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c663:	89 f0                	mov    %esi,%eax
			amIns->reorderTimer = 0;
		}
		if(amIns->statProhTimer)
		{
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
    c665:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c66c:	e8 fc ff ff ff       	call   c66d <PCRLC_SUSPEND_REQ+0x14d>
	cIoctrl = NULL;
	FOUT;
}
    c671:	83 c4 14             	add    $0x14,%esp
    c674:	5b                   	pop    %ebx
    c675:	5e                   	pop    %esi
    c676:	5d                   	pop    %ebp
    c677:	c3                   	ret    
    c678:	90                   	nop
    c679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c680 <PCRLC_RESUME_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_RESUME_REQ(void)
{
    c680:	55                   	push   %ebp
    c681:	89 e5                	mov    %esp,%ebp
    c683:	56                   	push   %esi
    c684:	53                   	push   %ebx
    c685:	83 ec 10             	sub    $0x10,%esp
    c688:	e8 fc ff ff ff       	call   c689 <PCRLC_RESUME_REQ+0x9>
	CRLC_ResumeReq_IoctrlMsg *cIoctrl = (CRLC_ResumeReq_IoctrlMsg*) fsm_data_get();
    c68d:	e8 fc ff ff ff       	call   c68e <PCRLC_RESUME_REQ+0xe>
    c692:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c694:	e8 fc ff ff ff       	call   c695 <PCRLC_RESUME_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c699:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c69c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c69e:	0f b6 06             	movzbl (%esi),%eax
    c6a1:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c6a7:	89 14 24             	mov    %edx,(%esp)
    c6aa:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c6ad:	e8 fc ff ff ff       	call   c6ae <PCRLC_RESUME_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
    c6b2:	c7 04 24 90 36 00 00 	movl   $0x3690,(%esp)
    c6b9:	e8 fc ff ff ff       	call   c6ba <PCRLC_RESUME_REQ+0x3a>
	switch(SV(ins_mode))
    c6be:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c6c4:	83 f8 02             	cmp    $0x2,%eax
    c6c7:	74 1f                	je     c6e8 <PCRLC_RESUME_REQ+0x68>
    c6c9:	83 f8 03             	cmp    $0x3,%eax
    c6cc:	74 6a                	je     c738 <PCRLC_RESUME_REQ+0xb8>
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
    c6ce:	c7 04 24 81 07 00 00 	movl   $0x781,(%esp)
    c6d5:	e8 fc ff ff ff       	call   c6d6 <PCRLC_RESUME_REQ+0x56>
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c6da:	89 f0                	mov    %esi,%eax
    c6dc:	e8 fc ff ff ff       	call   c6dd <PCRLC_RESUME_REQ+0x5d>
	FOUT;
}
    c6e1:	83 c4 10             	add    $0x10,%esp
    c6e4:	5b                   	pop    %ebx
    c6e5:	5e                   	pop    %esi
    c6e6:	5d                   	pop    %ebp
    c6e7:	c3                   	ret    
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd == NULL)
    c6e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6eb:	85 c0                	test   %eax,%eax
    c6ed:	74 eb                	je     c6da <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umRxIns = ( UM_RX_Instance *)insptrd;
		umRxIns->currentStatVar = ST_TRAN;
    c6ef:	c6 80 c2 10 00 00 08 	movb   $0x8,0x10c2(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um recv instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c6f6:	0f b6 06             	movzbl (%esi),%eax
    c6f9:	c7 04 24 c4 36 00 00 	movl   $0x36c4,(%esp)
    c700:	89 44 24 04          	mov    %eax,0x4(%esp)
    c704:	e8 fc ff ff ff       	call   c705 <PCRLC_RESUME_REQ+0x85>

		if(insptru == NULL)
    c709:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c70c:	85 c0                	test   %eax,%eax
    c70e:	74 ca                	je     c6da <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umTxIns = ( UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_TRAN;
    c710:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c714:	0f b6 06             	movzbl (%esi),%eax
    c717:	c7 04 24 18 37 00 00 	movl   $0x3718,(%esp)
    c71e:	89 44 24 04          	mov    %eax,0x4(%esp)
    c722:	e8 fc ff ff ff       	call   c723 <PCRLC_RESUME_REQ+0xa3>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c727:	89 f0                	mov    %esi,%eax
    c729:	e8 fc ff ff ff       	call   c72a <PCRLC_RESUME_REQ+0xaa>
	FOUT;
}
    c72e:	83 c4 10             	add    $0x10,%esp
    c731:	5b                   	pop    %ebx
    c732:	5e                   	pop    %esi
    c733:	5d                   	pop    %ebp
    c734:	c3                   	ret    
    c735:	8d 76 00             	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c738:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c73b:	85 c0                	test   %eax,%eax
    c73d:	74 9b                	je     c6da <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
    c73f:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c745:	0f b6 06             	movzbl (%esi),%eax
    c748:	c7 04 24 6c 37 00 00 	movl   $0x376c,(%esp)
    c74f:	89 44 24 04          	mov    %eax,0x4(%esp)
    c753:	e8 fc ff ff ff       	call   c754 <PCRLC_RESUME_REQ+0xd4>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c758:	89 f0                	mov    %esi,%eax
    c75a:	e8 fc ff ff ff       	call   c75b <PCRLC_RESUME_REQ+0xdb>
	FOUT;
}
    c75f:	83 c4 10             	add    $0x10,%esp
    c762:	5b                   	pop    %ebx
    c763:	5e                   	pop    %esi
    c764:	5d                   	pop    %ebp
    c765:	c3                   	ret    
    c766:	8d 76 00             	lea    0x0(%esi),%esi
    c769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c770 <PCRLC_STATUS_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c770:	55                   	push   %ebp
    c771:	89 e5                	mov    %esp,%ebp
    c773:	83 ec 10             	sub    $0x10,%esp
    c776:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    c779:	89 75 f8             	mov    %esi,-0x8(%ebp)
    c77c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    c77f:	e8 fc ff ff ff       	call   c780 <PCRLC_STATUS_IND+0x10>
    c784:	89 c6                	mov    %eax,%esi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c786:	b8 04 00 00 00       	mov    $0x4,%eax
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c78b:	89 d7                	mov    %edx,%edi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c78d:	e8 fc ff ff ff       	call   c78e <PCRLC_STATUS_IND+0x1e>
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c792:	ba 51 00 00 00       	mov    $0x51,%edx
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c797:	89 c3                	mov    %eax,%ebx
	cioctrl->eventCode = evCode;
    c799:	66 89 38             	mov    %di,(%eax)
	cioctrl->rbIdentity = rbid;
    c79c:	89 f0                	mov    %esi,%eax
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c79e:	89 d9                	mov    %ebx,%ecx
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
    c7a0:	88 43 02             	mov    %al,0x2(%ebx)
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c7a3:	b8 05 00 00 00       	mov    $0x5,%eax
    c7a8:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    c7af:	e8 fc ff ff ff       	call   c7b0 <PCRLC_STATUS_IND+0x40>
	fsm_mem_free(cioctrl);
    c7b4:	89 d8                	mov    %ebx,%eax
    c7b6:	e8 fc ff ff ff       	call   c7b7 <PCRLC_STATUS_IND+0x47>
	//fsm_data_destroy(cioctrl);
	cioctrl = NULL;
	FOUT;
}
    c7bb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c7be:	8b 75 f8             	mov    -0x8(%ebp),%esi
    c7c1:	8b 7d fc             	mov    -0x4(%ebp),%edi
    c7c4:	89 ec                	mov    %ebp,%esp
    c7c6:	5d                   	pop    %ebp
    c7c7:	c3                   	ret    
    c7c8:	90                   	nop
    c7c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c7d0 <PPRLC_DISC_REQ>:

//
inline void PPRLC_DISC_REQ(void)  {}
    c7d0:	55                   	push   %ebp
    c7d1:	89 e5                	mov    %esp,%ebp
    c7d3:	5d                   	pop    %ebp
    c7d4:	c3                   	ret    
    c7d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c7d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c7e0 <PMRLC_BUFFERREP_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void* PMRLC_BUFFERREP_REQ(void)
{
    c7e0:	55                   	push   %ebp
    c7e1:	89 e5                	mov    %esp,%ebp
    c7e3:	57                   	push   %edi
    c7e4:	56                   	push   %esi
    c7e5:	53                   	push   %ebx
    c7e6:	83 ec 20             	sub    $0x20,%esp
    c7e9:	e8 fc ff ff ff       	call   c7ea <PMRLC_BUFFERREP_REQ+0xa>
	struct AM_Instance * amIns;
	struct UM_TX_Instance *umTxIns;
	struct TM_TX_Instance *tmTxIns;
	struct AmBuffer *amBuffer;
	CtrlBuffer *ctrlBf;
	u32 num = 0,*nump;  //
    c7ee:	31 db                	xor    %ebx,%ebx

	SV_PTR_GET(rlc_mac_sv);
    c7f0:	e8 fc ff ff ff       	call   c7f1 <PMRLC_BUFFERREP_REQ+0x11>
    c7f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c7f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c7fb:	05 f4 25 00 00       	add    $0x25f4,%eax
    c800:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c803:	8b 82 f4 25 00 00    	mov    0x25f4(%edx),%eax
    c809:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    c80c:	74 33                	je     c841 <PMRLC_BUFFERREP_REQ+0x61>
    c80e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c811:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c818:	8b b8 48 dd ff ff    	mov    -0x22b8(%eax),%edi
    c81e:	85 ff                	test   %edi,%edi
    c820:	75 16                	jne    c838 <PMRLC_BUFFERREP_REQ+0x58>
    c822:	8b b0 a0 de ff ff    	mov    -0x2160(%eax),%esi
    c828:	85 f6                	test   %esi,%esi
    c82a:	75 0c                	jne    c838 <PMRLC_BUFFERREP_REQ+0x58>
    c82c:	8b 88 b4 de ff ff    	mov    -0x214c(%eax),%ecx
    c832:	85 c9                	test   %ecx,%ecx
    c834:	74 05                	je     c83b <PMRLC_BUFFERREP_REQ+0x5b>
    c836:	66 90                	xchg   %ax,%ax
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] am instance (rbid is %d) has data to report\n", amIns->rbId);
				num++;
    c838:	83 c3 01             	add    $0x1,%ebx

	SV_PTR_GET(rlc_mac_sv);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c83b:	8b 00                	mov    (%eax),%eax
    c83d:	39 c2                	cmp    %eax,%edx
    c83f:	75 d7                	jne    c818 <PMRLC_BUFFERREP_REQ+0x38>
				num++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c841:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c844:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c847:	05 f8 36 00 00       	add    $0x36f8,%eax
    c84c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c84f:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
    c855:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c858:	74 13                	je     c86d <PMRLC_BUFFERREP_REQ+0x8d>
    c85a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c85d:	8d 76 00             	lea    0x0(%esi),%esi
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c860:	83 78 f0 01          	cmpl   $0x1,-0x10(%eax)
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c864:	8b 00                	mov    (%eax),%eax
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c866:	83 db ff             	sbb    $0xffffffff,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c869:	39 c2                	cmp    %eax,%edx
    c86b:	75 f3                	jne    c860 <PMRLC_BUFFERREP_REQ+0x80>
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c86d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c870:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c873:	05 2c 37 00 00       	add    $0x372c,%eax
    c878:	89 45 dc             	mov    %eax,-0x24(%ebp)
    c87b:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
    c881:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c884:	74 17                	je     c89d <PMRLC_BUFFERREP_REQ+0xbd>
    c886:	8b 55 dc             	mov    -0x24(%ebp),%edx
    c889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c890:	83 78 f8 01          	cmpl   $0x1,-0x8(%eax)
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c894:	8b 00                	mov    (%eax),%eax
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c896:	83 db ff             	sbb    $0xffffffff,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c899:	39 c2                	cmp    %eax,%edx
    c89b:	75 f3                	jne    c890 <PMRLC_BUFFERREP_REQ+0xb0>
				num++;
			}
		}
	}
	
	if(num == 0)
    c89d:	85 db                	test   %ebx,%ebx
    c89f:	0f 84 9f 02 00 00    	je     cb44 <PMRLC_BUFFERREP_REQ+0x364>
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c8a5:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    c8a8:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
    c8ac:	e8 fc ff ff ff       	call   c8ad <PMRLC_BUFFERREP_REQ+0xcd>
	*nump = num;
    c8b1:	89 18                	mov    %ebx,(%eax)
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c8b3:	89 c3                	mov    %eax,%ebx
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c8b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    c8b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c8bb:	83 c3 04             	add    $0x4,%ebx
    c8be:	8b b8 f4 25 00 00    	mov    0x25f4(%eax),%edi
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c8c4:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c8c7:	0f 84 47 01 00 00    	je     ca14 <PMRLC_BUFFERREP_REQ+0x234>
    c8cd:	8d 76 00             	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c8d0:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    c8d6:	8d 97 fc dc ff ff    	lea    -0x2304(%edi),%edx
    c8dc:	89 55 f0             	mov    %edx,-0x10(%ebp)
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c8df:	85 c0                	test   %eax,%eax
    c8e1:	75 1d                	jne    c900 <PMRLC_BUFFERREP_REQ+0x120>
    c8e3:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
    c8e9:	85 c0                	test   %eax,%eax
    c8eb:	75 13                	jne    c900 <PMRLC_BUFFERREP_REQ+0x120>
    c8ed:	8b b7 b4 de ff ff    	mov    -0x214c(%edi),%esi
    c8f3:	85 f6                	test   %esi,%esi
    c8f5:	0f 84 0e 01 00 00    	je     ca09 <PMRLC_BUFFERREP_REQ+0x229>
    c8fb:	90                   	nop
    c8fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			{
				mioctrl->rnti = 0;
    c900:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = amIns->lcId;
    c905:	0f b6 87 ff dc ff ff 	movzbl -0x2301(%edi),%eax
    c90c:	88 43 02             	mov    %al,0x2(%ebx)
				mioctrl->txQueueSize = amIns->amSduBufferSize;
    c90f:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
    c915:	89 43 03             	mov    %eax,0x3(%ebx)
				mioctrl->txQueueHeader = 2 + 2* amIns->amSduBufferNum;
    c918:	8b 97 4c dd ff ff    	mov    -0x22b4(%edi),%edx
    c91e:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
    c922:	66 89 53 07          	mov    %dx,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c926:	0f b7 d2             	movzwl %dx,%edx
    c929:	01 c2                	add    %eax,%edx
    c92b:	83 fa 7f             	cmp    $0x7f,%edx
    c92e:	0f 87 6c 01 00 00    	ja     caa0 <PMRLC_BUFFERREP_REQ+0x2c0>
				{
					mioctrl->txQueueSize += 2;
    c934:	83 c0 02             	add    $0x2,%eax
    c937:	89 43 03             	mov    %eax,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c93a:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
				mioctrl->retxQueueHeader = 2;
    c940:	66 c7 43 0d 02 00    	movw   $0x2,0xd(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c946:	89 43 09             	mov    %eax,0x9(%ebx)
    c949:	8b b7 98 de ff ff    	mov    -0x2168(%edi),%esi
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
    c94f:	8d 87 98 de ff ff    	lea    -0x2168(%edi),%eax
    c955:	39 f0                	cmp    %esi,%eax
    c957:	74 55                	je     c9ae <PMRLC_BUFFERREP_REQ+0x1ce>
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c959:	89 7d e8             	mov    %edi,-0x18(%ebp)
    c95c:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
    c962:	89 c7                	mov    %eax,%edi
    c964:	eb 16                	jmp    c97c <PMRLC_BUFFERREP_REQ+0x19c>
    c966:	66 90                	xchg   %ax,%ax
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
						{
							if( amBuffer->pkt->len < 128 )
							{
								mioctrl->retxQueueSize += 2;
    c968:	83 43 09 02          	addl   $0x2,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c96c:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c972:	39 c7                	cmp    %eax,%edi
    c974:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c97a:	74 2f                	je     c9ab <PMRLC_BUFFERREP_REQ+0x1cb>
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
    c97c:	0f bf 96 94 00 00 00 	movswl 0x94(%esi),%edx
    c983:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c986:	e8 fc ff ff ff       	call   c987 <PMRLC_BUFFERREP_REQ+0x1a7>
    c98b:	84 c0                	test   %al,%al
    c98d:	74 dd                	je     c96c <PMRLC_BUFFERREP_REQ+0x18c>
						{
							if( amBuffer->pkt->len < 128 )
    c98f:	8b 06                	mov    (%esi),%eax
    c991:	83 78 50 7f          	cmpl   $0x7f,0x50(%eax)
    c995:	76 d1                	jbe    c968 <PMRLC_BUFFERREP_REQ+0x188>
							{
								mioctrl->retxQueueSize += 2;
							}
							else
							{
								mioctrl->retxQueueSize += 3;
    c997:	83 43 09 03          	addl   $0x3,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c99b:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c9a1:	39 c7                	cmp    %eax,%edi
    c9a3:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c9a9:	75 d1                	jne    c97c <PMRLC_BUFFERREP_REQ+0x19c>
    c9ab:	8b 7d e8             	mov    -0x18(%ebp),%edi
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c9ae:	8b 87 b4 de ff ff    	mov    -0x214c(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c9b4:	8d b7 ac de ff ff    	lea    -0x2154(%edi),%esi
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
    c9ba:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c9c0:	89 c2                	mov    %eax,%edx
    c9c2:	66 89 43 0f          	mov    %ax,0xf(%ebx)
    c9c6:	8b 87 ac de ff ff    	mov    -0x2154(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c9cc:	39 c6                	cmp    %eax,%esi
    c9ce:	74 36                	je     ca06 <PMRLC_BUFFERREP_REQ+0x226>
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c9d0:	83 e8 04             	sub    $0x4,%eax
    c9d3:	eb 18                	jmp    c9ed <PMRLC_BUFFERREP_REQ+0x20d>
    c9d5:	8d 76 00             	lea    0x0(%esi),%esi
					{
						if( ctrlBf->pkt->len < 128 )
						{
							mioctrl->statusPduSize += 2;
    c9d8:	83 c2 02             	add    $0x2,%edx
    c9db:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c9df:	8b 50 04             	mov    0x4(%eax),%edx
    c9e2:	39 d6                	cmp    %edx,%esi
    c9e4:	8d 42 fc             	lea    -0x4(%edx),%eax
    c9e7:	74 1d                	je     ca06 <PMRLC_BUFFERREP_REQ+0x226>
    c9e9:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
					{
						if( ctrlBf->pkt->len < 128 )
    c9ed:	8b 08                	mov    (%eax),%ecx
    c9ef:	83 79 50 7f          	cmpl   $0x7f,0x50(%ecx)
    c9f3:	76 e3                	jbe    c9d8 <PMRLC_BUFFERREP_REQ+0x1f8>
						{
							mioctrl->statusPduSize += 2;
						}
						else
						{
							mioctrl->statusPduSize += 3;
    c9f5:	83 c2 03             	add    $0x3,%edx
    c9f8:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c9fc:	8b 50 04             	mov    0x4(%eax),%edx
    c9ff:	39 d6                	cmp    %edx,%esi
    ca01:	8d 42 fc             	lea    -0x4(%edx),%eax
    ca04:	75 e3                	jne    c9e9 <PMRLC_BUFFERREP_REQ+0x209>
				}
				else
				{
					mioctrl->statusPduSize += 3;
				}*/
				mioctrl++;
    ca06:	83 c3 13             	add    $0x13,%ebx
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    ca09:	8b 3f                	mov    (%edi),%edi
    ca0b:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    ca0e:	0f 85 bc fe ff ff    	jne    c8d0 <PMRLC_BUFFERREP_REQ+0xf0>
    ca14:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ca17:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
				mioctrl++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    ca1d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    ca20:	0f 84 b2 00 00 00    	je     cad8 <PMRLC_BUFFERREP_REQ+0x2f8>
    ca26:	8b 75 e0             	mov    -0x20(%ebp),%esi
    ca29:	eb 18                	jmp    ca43 <PMRLC_BUFFERREP_REQ+0x263>
    ca2b:	90                   	nop
    ca2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    ca30:	83 c2 02             	add    $0x2,%edx
    ca33:	89 53 03             	mov    %edx,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
    ca36:	83 c3 13             	add    $0x13,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    ca39:	8b 00                	mov    (%eax),%eax
    ca3b:	39 c6                	cmp    %eax,%esi
    ca3d:	0f 84 95 00 00 00    	je     cad8 <PMRLC_BUFFERREP_REQ+0x2f8>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
    ca43:	8b 48 f0             	mov    -0x10(%eax),%ecx
    ca46:	85 c9                	test   %ecx,%ecx
    ca48:	74 ef                	je     ca39 <PMRLC_BUFFERREP_REQ+0x259>
			{
				mioctrl->rnti = 0;
    ca4a:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = umTxIns->lcid;
    ca4f:	0f b6 50 d3          	movzbl -0x2d(%eax),%edx
    ca53:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    ca56:	8b 50 f0             	mov    -0x10(%eax),%edx
				mioctrl->retxQueueSize = 0;
    ca59:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->retxQueueHeader = 0;
    ca60:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				mioctrl->statusPduSize = 0;
    ca66:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = umTxIns->lcid;
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    ca6c:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->retxQueueSize = 0;
				mioctrl->retxQueueHeader = 0;
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;
    ca6f:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)

				if(umTxIns->snFiledLength == 5)
    ca75:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    ca79:	66 83 f9 05          	cmp    $0x5,%cx
    ca7d:	74 41                	je     cac0 <PMRLC_BUFFERREP_REQ+0x2e0>
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
    ca7f:	66 83 f9 0a          	cmp    $0xa,%cx
    ca83:	74 2b                	je     cab0 <PMRLC_BUFFERREP_REQ+0x2d0>
    ca85:	0f b7 4b 07          	movzwl 0x7(%ebx),%ecx
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    ca89:	0f b7 c9             	movzwl %cx,%ecx
    ca8c:	01 d1                	add    %edx,%ecx
    ca8e:	83 f9 7f             	cmp    $0x7f,%ecx
    ca91:	76 9d                	jbe    ca30 <PMRLC_BUFFERREP_REQ+0x250>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    ca93:	83 c2 03             	add    $0x3,%edx
    ca96:	89 53 03             	mov    %edx,0x3(%ebx)
    ca99:	eb 9b                	jmp    ca36 <PMRLC_BUFFERREP_REQ+0x256>
    ca9b:	90                   	nop
    ca9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    caa0:	83 c0 03             	add    $0x3,%eax
    caa3:	89 43 03             	mov    %eax,0x3(%ebx)
    caa6:	e9 8f fe ff ff       	jmp    c93a <PMRLC_BUFFERREP_REQ+0x15a>
    caab:	90                   	nop
    caac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
    cab0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    cab3:	8d 4c 09 02          	lea    0x2(%ecx,%ecx,1),%ecx
    cab7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    cabb:	eb cc                	jmp    ca89 <PMRLC_BUFFERREP_REQ+0x2a9>
    cabd:	8d 76 00             	lea    0x0(%esi),%esi
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;

				if(umTxIns->snFiledLength == 5)
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
    cac0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    cac3:	8d 4c 09 01          	lea    0x1(%ecx,%ecx,1),%ecx
    cac7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    cacb:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    cacf:	eb ae                	jmp    ca7f <PMRLC_BUFFERREP_REQ+0x29f>
    cad1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    cad8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    cadb:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    cae1:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    cae4:	74 72                	je     cb58 <PMRLC_BUFFERREP_REQ+0x378>
    cae6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    cae9:	eb 2d                	jmp    cb18 <PMRLC_BUFFERREP_REQ+0x338>
    caeb:	90                   	nop
    caec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    caf0:	83 c2 02             	add    $0x2,%edx
    caf3:	89 53 03             	mov    %edx,0x3(%ebx)
				}
				else
				{
					mioctrl->txQueueSize += 3;
				}
				mioctrl->retxQueueSize = 0;
    caf6:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->statusPduSize = 0;
    cafd:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
				mioctrl->statusPduHeader = 0;
    cb03:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
				mioctrl->retxQueueHeader = 0;
    cb09:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				//fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize, mioctrl->lcid);
				mioctrl++;
    cb0f:	83 c3 13             	add    $0x13,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    cb12:	8b 00                	mov    (%eax),%eax
    cb14:	39 c1                	cmp    %eax,%ecx
    cb16:	74 40                	je     cb58 <PMRLC_BUFFERREP_REQ+0x378>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
    cb18:	8b 50 f8             	mov    -0x8(%eax),%edx
    cb1b:	85 d2                	test   %edx,%edx
    cb1d:	74 f3                	je     cb12 <PMRLC_BUFFERREP_REQ+0x332>
			{
				mioctrl->rnti = 0;
    cb1f:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = tmTxIns->lcId;
    cb24:	0f b6 50 e7          	movzbl -0x19(%eax),%edx
    cb28:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    cb2b:	8b 50 f8             	mov    -0x8(%eax),%edx
				mioctrl->txQueueHeader = 0;
    cb2e:	66 c7 43 07 00 00    	movw   $0x0,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    cb34:	83 fa 7f             	cmp    $0x7f,%edx
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    cb37:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    cb3a:	76 b4                	jbe    caf0 <PMRLC_BUFFERREP_REQ+0x310>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    cb3c:	83 c2 03             	add    $0x3,%edx
    cb3f:	89 53 03             	mov    %edx,0x3(%ebx)
    cb42:	eb b2                	jmp    caf6 <PMRLC_BUFFERREP_REQ+0x316>
		}
	}
	
	if(num == 0)
	{
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] There is no data to report\n");
    cb44:	c7 04 24 bc 37 00 00 	movl   $0x37bc,(%esp)
    cb4b:	e8 fc ff ff ff       	call   cb4c <PMRLC_BUFFERREP_REQ+0x36c>
		if( SV(bufferReqTimer) )
		{
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}*/
		return NULL; 	//modify 20150901
    cb50:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    cb57:	90                   	nop
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cb58:	8b 45 d8             	mov    -0x28(%ebp),%eax
    cb5b:	83 c4 20             	add    $0x20,%esp
    cb5e:	5b                   	pop    %ebx
    cb5f:	5e                   	pop    %esi
    cb60:	5f                   	pop    %edi
    cb61:	5d                   	pop    %ebp
    cb62:	c3                   	ret    
    cb63:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    cb69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000cb70 <PMRLC_TRANSOP_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
{
    cb70:	55                   	push   %ebp
    cb71:	89 e5                	mov    %esp,%ebp
    cb73:	57                   	push   %edi
    cb74:	56                   	push   %esi
    cb75:	53                   	push   %ebx
    cb76:	83 ec 70             	sub    $0x70,%esp
    cb79:	e8 fc ff ff ff       	call   cb7a <PMRLC_TRANSOP_IND+0xa>
    cb7e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	u32 subHeadLen;
	u32 size = 0;     //the total size in a buffer to transimit	
	u16 rnti;
	//int i=0;  //FOR TEST
	
	SV_PTR_GET(rlc_mac_sv);
    cb81:	e8 fc ff ff ff       	call   cb82 <PMRLC_TRANSOP_IND+0x12>
    cb86:	89 45 cc             	mov    %eax,-0x34(%ebp)
	SV(isBufferReq) = 0;
    cb89:	c6 80 24 02 00 00 00 	movb   $0x0,0x224(%eax)
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    cb90:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	if(hptr == NULL)
    cb93:	85 c0                	test   %eax,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	SV(isBufferReq) = 0;
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    cb95:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(hptr == NULL)
    cb98:	0f 84 d4 01 00 00    	je     cd72 <PMRLC_TRANSOP_IND+0x202>
	{
		FOUT;
	}	
	nump = (u32*)hptr;
	num = *nump;
    cb9e:	89 c2                	mov    %eax,%edx
    cba0:	8b 00                	mov    (%eax),%eax
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
    cba2:	85 c0                	test   %eax,%eax
    cba4:	0f 84 40 0a 00 00    	je     d5ea <PMRLC_TRANSOP_IND+0xa7a>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cbaa:	8b 75 b4             	mov    -0x4c(%ebp),%esi
    cbad:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    cbb0:	8d 04 50             	lea    (%eax,%edx,2),%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    cbb3:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	subhead = data = sevNum = fifNum = 0;
    cbb6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    cbbd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cbc4:	83 ee 0f             	sub    $0xf,%esi
    cbc7:	01 f0                	add    %esi,%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    cbc9:	83 c1 04             	add    $0x4,%ecx
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cbcc:	89 45 d0             	mov    %eax,-0x30(%ebp)
    cbcf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cbd2:	89 75 ac             	mov    %esi,-0x54(%ebp)
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    cbd5:	89 ce                	mov    %ecx,%esi
    cbd7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    cbda:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    cbdd:	05 18 02 00 00       	add    $0x218,%eax
    cbe2:	89 45 c0             	mov    %eax,-0x40(%ebp)
    cbe5:	8d 76 00             	lea    0x0(%esi),%esi
	subhead = data = sevNum = fifNum = 0;
	//controlelm = 14 + 10;
	while(num > 0)
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    cbe8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    cbeb:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    cbee:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    cbf2:	89 14 24             	mov    %edx,(%esp)
    cbf5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    cbf8:	e8 fc ff ff ff       	call   cbf9 <PMRLC_TRANSOP_IND+0x89>
		switch(SV(ins_mode))
    cbfd:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    cc00:	8b 81 18 02 00 00    	mov    0x218(%ecx),%eax
    cc06:	83 f8 02             	cmp    $0x2,%eax
    cc09:	0f 84 b9 08 00 00    	je     d4c8 <PMRLC_TRANSOP_IND+0x958>
    cc0f:	83 f8 03             	cmp    $0x3,%eax
    cc12:	0f 84 58 07 00 00    	je     d370 <PMRLC_TRANSOP_IND+0x800>
    cc18:	83 f8 01             	cmp    $0x1,%eax
    cc1b:	0f 84 bf 06 00 00    	je     d2e0 <PMRLC_TRANSOP_IND+0x770>
			}

			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    cc21:	c7 04 24 f4 37 00 00 	movl   $0x37f4,(%esp)
    cc28:	e8 fc ff ff ff       	call   cc29 <PMRLC_TRANSOP_IND+0xb9>
			break;
		}	
		num--;
		if(num>0)
    cc2d:	3b 75 d0             	cmp    -0x30(%ebp),%esi
    cc30:	74 06                	je     cc38 <PMRLC_TRANSOP_IND+0xc8>
		{
			mIoctrl++;
    cc32:	83 c6 13             	add    $0x13,%esi
    cc35:	eb b1                	jmp    cbe8 <PMRLC_TRANSOP_IND+0x78>
    cc37:	90                   	nop
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    cc38:	8b 45 e0             	mov    -0x20(%ebp),%eax
    cc3b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    cc3e:	83 c0 04             	add    $0x4,%eax
    cc41:	e8 fc ff ff ff       	call   cc42 <PMRLC_TRANSOP_IND+0xd2>
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cc46:	8b 75 dc             	mov    -0x24(%ebp),%esi
    cc49:	83 c6 04             	add    $0x4,%esi
			mIoctrl++;
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    cc4c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cc4f:	89 f0                	mov    %esi,%eax
    cc51:	e8 fc ff ff ff       	call   cc52 <PMRLC_TRANSOP_IND+0xe2>
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    cc56:	89 f2                	mov    %esi,%edx
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cc58:	89 45 b8             	mov    %eax,-0x48(%ebp)
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    cc5b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cc5e:	e8 fc ff ff ff       	call   cc5f <PMRLC_TRANSOP_IND+0xef>

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    cc63:	8b 45 b8             	mov    -0x48(%ebp),%eax
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    cc66:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
	data = 0;     //
    cc69:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    cc70:	83 c0 04             	add    $0x4,%eax
    cc73:	89 45 ec             	mov    %eax,-0x14(%ebp)
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    cc76:	8b 01                	mov    (%ecx),%eax
	while(num > 0)
    cc78:	85 c0                	test   %eax,%eax
    cc7a:	74 60                	je     ccdc <PMRLC_TRANSOP_IND+0x16c>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cc7c:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    cc7f:	8d 04 50             	lea    (%eax,%edx,2),%eax
    cc82:	03 45 ac             	add    -0x54(%ebp),%eax
    cc85:	89 45 bc             	mov    %eax,-0x44(%ebp)
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
	while(num > 0)
	{
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] number %d:\n", num);
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    cc88:	8b 75 d8             	mov    -0x28(%ebp),%esi
    cc8b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    cc8e:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    cc91:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    cc95:	8b 75 c0             	mov    -0x40(%ebp),%esi
    cc98:	89 34 24             	mov    %esi,(%esp)
    cc9b:	e8 fc ff ff ff       	call   cc9c <PMRLC_TRANSOP_IND+0x12c>
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
    cca0:	8b 55 cc             	mov    -0x34(%ebp),%edx
    cca3:	8b 82 18 02 00 00    	mov    0x218(%edx),%eax
    cca9:	83 f8 02             	cmp    $0x2,%eax
    ccac:	0f 84 5e 04 00 00    	je     d110 <PMRLC_TRANSOP_IND+0x5a0>
    ccb2:	83 f8 03             	cmp    $0x3,%eax
    ccb5:	0f 84 dd 01 00 00    	je     ce98 <PMRLC_TRANSOP_IND+0x328>
    ccbb:	83 f8 01             	cmp    $0x1,%eax
    ccbe:	0f 84 cc 00 00 00    	je     cd90 <PMRLC_TRANSOP_IND+0x220>
				}          
            }
			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    ccc4:	c7 04 24 f4 37 00 00 	movl   $0x37f4,(%esp)
    cccb:	e8 fc ff ff ff       	call   cccc <PMRLC_TRANSOP_IND+0x15c>
			break;
		}
	
		num--;
		if(num>0)
    ccd0:	8b 75 bc             	mov    -0x44(%ebp),%esi
    ccd3:	39 75 d8             	cmp    %esi,-0x28(%ebp)
    ccd6:	0f 85 a4 00 00 00    	jne    cd80 <PMRLC_TRANSOP_IND+0x210>
		{
			mIoctrl++;
		}
	}
		
	if(0 == pkptr->len)
    ccdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ccdf:	8b 48 50             	mov    0x50(%eax),%ecx
    cce2:	85 c9                	test   %ecx,%ecx
    cce4:	0f 84 7d 08 00 00    	je     d567 <PMRLC_TRANSOP_IND+0x9f7>
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
		SV(bufferReqTimer) = 0;
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
    ccea:	8b 45 f0             	mov    -0x10(%ebp),%eax
	fix->E = 0;    //E0
    cced:	80 20 df             	andb   $0xdf,(%eax)
	icimsg->len = data;
    ccf0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ccf3:	8b 55 b8             	mov    -0x48(%ebp),%edx
	icimsg->rnti = mIoctrl->rnti;
    ccf6:	8b 75 d8             	mov    -0x28(%ebp),%esi
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
	fix->E = 0;    //E0
	icimsg->len = data;
    ccf9:	66 89 42 02          	mov    %ax,0x2(%edx)
	icimsg->rnti = mIoctrl->rnti;
    ccfd:	0f b7 06             	movzwl (%esi),%eax
    cd00:	66 89 02             	mov    %ax,(%edx)
	fsm_mem_cpy(pkptr->head, head,  data + sizeof(MRLC_toMac_IciMsg));
    cd03:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cd06:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    cd09:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
    cd0f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    cd12:	83 c1 04             	add    $0x4,%ecx
    cd15:	e8 fc ff ff ff       	call   cd16 <PMRLC_TRANSOP_IND+0x1a6>
	fsm_mem_free(head);
    cd1a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd1d:	e8 fc ff ff ff       	call   cd1e <PMRLC_TRANSOP_IND+0x1ae>
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cd22:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cd25:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
	{
		send_msg3(pkptr);
    cd2a:	8b 45 d0             	mov    -0x30(%ebp),%eax
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cd2d:	0f 85 d9 08 00 00    	jne    d60c <PMRLC_TRANSOP_IND+0xa9c>
		send_msg3(pkptr);
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
		FOUT;
	}
	else{
		complexUeMacPdu(pkptr); //add in 20150804
    cd33:	e8 fc ff ff ff       	call   cd34 <PMRLC_TRANSOP_IND+0x1c4>
		if(SV(Tbsize_Complex)!=0)
    cd38:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cd3b:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    cd41:	85 d2                	test   %edx,%edx
    cd43:	74 0a                	je     cd4f <PMRLC_TRANSOP_IND+0x1df>
				SV(Tbsize_Complex)=0;
    cd45:	c7 80 f4 01 00 00 00 	movl   $0x0,0x1f4(%eax)
    cd4c:	00 00 00 
		
		fsm_printf("[RLC][PMRLC_TRANSOP_IND][<--] send to MAC\n");
    cd4f:	c7 04 24 4c 3a 00 00 	movl   $0x3a4c,(%esp)
    cd56:	e8 fc ff ff ff       	call   cd57 <PMRLC_TRANSOP_IND+0x1e7>
		SV(countSentToLower)++;
    cd5b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cd5e:	83 80 98 5a 00 00 01 	addl   $0x1,0x5a98(%eax)
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] bufferReqTimer restart\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));*/
		fsm_data_destroy(hptr);
    cd65:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    cd68:	e8 fc ff ff ff       	call   cd69 <PMRLC_TRANSOP_IND+0x1f9>
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
    cd6d:	e8 fc ff ff ff       	call   cd6e <PMRLC_TRANSOP_IND+0x1fe>
		FOUT;
	}
}
    cd72:	83 c4 70             	add    $0x70,%esp
    cd75:	5b                   	pop    %ebx
    cd76:	5e                   	pop    %esi
    cd77:	5f                   	pop    %edi
    cd78:	5d                   	pop    %ebp
    cd79:	c3                   	ret    
    cd7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
	
		num--;
		if(num>0)
		{
			mIoctrl++;
    cd80:	83 45 d8 13          	addl   $0x13,-0x28(%ebp)
    cd84:	e9 ff fe ff ff       	jmp    cc88 <PMRLC_TRANSOP_IND+0x118>
    cd89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    cd90:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cd93:	85 f6                	test   %esi,%esi
    cd95:	0f 84 35 ff ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
    cd9b:	8b 46 0c             	mov    0xc(%esi),%eax
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    cd9e:	8d 4e 0c             	lea    0xc(%esi),%ecx
    cda1:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    cda4:	39 c1                	cmp    %eax,%ecx
    cda6:	0f 84 24 ff ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
    cdac:	8b 38                	mov    (%eax),%edi
    cdae:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cdb1:	83 ef 04             	sub    $0x4,%edi
    cdb4:	eb 18                	jmp    cdce <PMRLC_TRANSOP_IND+0x25e>
    cdb6:	66 90                	xchg   %ax,%ax
    cdb8:	8b 47 04             	mov    0x4(%edi),%eax
    cdbb:	8d 57 04             	lea    0x4(%edi),%edx
    cdbe:	89 fb                	mov    %edi,%ebx
    cdc0:	83 e8 04             	sub    $0x4,%eax
    cdc3:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cdc6:	0f 84 04 ff ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
    cdcc:	89 c7                	mov    %eax,%edi
				{
					if(buffer->pkt->len < 128)
    cdce:	8b 03                	mov    (%ebx),%eax
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cdd0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
    cdd3:	8b 40 50             	mov    0x50(%eax),%eax
					{
						subHeadLen = 2;
    cdd6:	3d 80 00 00 00       	cmp    $0x80,%eax
    cddb:	19 d2                	sbb    %edx,%edx
    cddd:	83 c2 03             	add    $0x3,%edx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cde0:	01 d0                	add    %edx,%eax
    cde2:	3b 41 03             	cmp    0x3(%ecx),%eax
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
					{
						subHeadLen = 2;
    cde5:	89 55 dc             	mov    %edx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    cde8:	0f 87 e2 fe ff ff    	ja     ccd0 <PMRLC_TRANSOP_IND+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cdee:	8b 53 04             	mov    0x4(%ebx),%edx
    cdf1:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cdf4:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cdf7:	89 10                	mov    %edx,(%eax)
						break;
					}
					else
					{
						list_del(&buffer->list);
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
    cdf9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cdfb:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    ce02:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    ce09:	8b 40 50             	mov    0x50(%eax),%eax
    ce0c:	29 46 14             	sub    %eax,0x14(%esi)
						tmTxIns->tmSduBufferNum--;
    ce0f:	83 6e 18 01          	subl   $0x1,0x18(%esi)
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
    ce13:	8b 03                	mov    (%ebx),%eax
    ce15:	8b 48 50             	mov    0x50(%eax),%ecx
    ce18:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    ce1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ce21:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ce27:	89 45 a0             	mov    %eax,-0x60(%ebp)
    ce2a:	e8 fc ff ff ff       	call   ce2b <PMRLC_TRANSOP_IND+0x2bb>
						fsm_skb_put(pkptr, buffer->pkt->len);
    ce2f:	8b 03                	mov    (%ebx),%eax
    ce31:	8b 50 50             	mov    0x50(%eax),%edx
    ce34:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ce37:	e8 fc ff ff ff       	call   ce38 <PMRLC_TRANSOP_IND+0x2c8>

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    ce3c:	8d 55 e0             	lea    -0x20(%ebp),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ce3f:	8b 03                	mov    (%ebx),%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    ce41:	8d 4d f0             	lea    -0x10(%ebp),%ecx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ce44:	83 c0 50             	add    $0x50,%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    ce47:	89 54 24 04          	mov    %edx,0x4(%esp)
    ce4b:	0f b6 56 03          	movzbl 0x3(%esi),%edx
    ce4f:	89 14 24             	mov    %edx,(%esp)
    ce52:	8d 55 ec             	lea    -0x14(%ebp),%edx
    ce55:	e8 d6 e8 ff ff       	call   b730 <creat_subhead.isra.0>
						mIoctrl->txQueueSize -= subHeadLen + buffer->pkt->len;
    ce5a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ce5d:	8b 13                	mov    (%ebx),%edx
    ce5f:	8b 41 03             	mov    0x3(%ecx),%eax
    ce62:	2b 42 50             	sub    0x50(%edx),%eax
    ce65:	2b 45 dc             	sub    -0x24(%ebp),%eax
    ce68:	89 41 03             	mov    %eax,0x3(%ecx)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
    ce6b:	8b 03                	mov    (%ebx),%eax
    ce6d:	e8 fc ff ff ff       	call   ce6e <PMRLC_TRANSOP_IND+0x2fe>
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
    ce72:	89 d8                	mov    %ebx,%eax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
    ce74:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(buffer);  //20140922
    ce7a:	e8 fc ff ff ff       	call   ce7b <PMRLC_TRANSOP_IND+0x30b>
						buffer = NULL;
						if(list_empty(&tmTxIns->tmSduBuffer.list))
    ce7f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ce82:	3b 46 0c             	cmp    0xc(%esi),%eax
    ce85:	0f 85 2d ff ff ff    	jne    cdb8 <PMRLC_TRANSOP_IND+0x248>
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
						buffer = NULL;
    ce8b:	31 db                	xor    %ebx,%ebx
    ce8d:	e9 3e fe ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
    ce92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
				break;
			}

		case AM_MODE:
			if(insptru == NULL)
    ce98:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    ce9b:	85 f6                	test   %esi,%esi
    ce9d:	0f 84 2d fe ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cea3:	8b 86 b0 01 00 00    	mov    0x1b0(%esi),%eax
				break;
			}*/

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    cea9:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    ceaf:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    ceb2:	39 c2                	cmp    %eax,%edx
    ceb4:	0f 84 10 01 00 00    	je     cfca <PMRLC_TRANSOP_IND+0x45a>
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    ceba:	8b 38                	mov    (%eax),%edi
    cebc:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cebf:	83 ef 04             	sub    $0x4,%edi
    cec2:	e9 c0 00 00 00       	jmp    cf87 <PMRLC_TRANSOP_IND+0x417>
    cec7:	90                   	nop
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cec8:	8b 53 04             	mov    0x4(%ebx),%edx
    cecb:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cece:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ced1:	89 10                	mov    %edx,(%eax)
					else
					{
						list_del(&buffer->list);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu has been remove from list\n");
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] buffer->pkt->len=%d\n",buffer->pkt->len);
						SV(countSendCtrlPdu)++;
    ced3:	8b 45 cc             	mov    -0x34(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ced6:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cedd:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cee4:	83 80 a0 5a 00 00 01 	addl   $0x1,0x5aa0(%eax)
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
    ceeb:	8b 03                	mov    (%ebx),%eax
    ceed:	8b 40 50             	mov    0x50(%eax),%eax
    cef0:	29 86 b8 01 00 00    	sub    %eax,0x1b8(%esi)
						amIns->ctrlPduBufferNum--;
    cef6:	83 ae bc 01 00 00 01 	subl   $0x1,0x1bc(%esi)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
    cefd:	8b 03                	mov    (%ebx),%eax
    ceff:	8b 48 50             	mov    0x50(%eax),%ecx
    cf02:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cf08:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf0b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cf11:	89 45 98             	mov    %eax,-0x68(%ebp)
    cf14:	e8 fc ff ff ff       	call   cf15 <PMRLC_TRANSOP_IND+0x3a5>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cf19:	8b 03                	mov    (%ebx),%eax
    cf1b:	8b 50 50             	mov    0x50(%eax),%edx
    cf1e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf21:	e8 fc ff ff ff       	call   cf22 <PMRLC_TRANSOP_IND+0x3b2>
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    cf26:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cf29:	8b 13                	mov    (%ebx),%edx
    cf2b:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    cf2f:	66 2b 42 50          	sub    0x50(%edx),%ax
    cf33:	66 2b 45 dc          	sub    -0x24(%ebp),%ax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cf37:	8d 55 e0             	lea    -0x20(%ebp),%edx
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
						amIns->ctrlPduBufferNum--;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    cf3a:	66 89 41 0f          	mov    %ax,0xf(%ecx)
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cf3e:	8b 03                	mov    (%ebx),%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cf40:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cf43:	89 54 24 04          	mov    %edx,0x4(%esp)
    cf47:	0f b6 56 03          	movzbl 0x3(%esi),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cf4b:	83 c0 50             	add    $0x50,%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    cf4e:	89 14 24             	mov    %edx,(%esp)
    cf51:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cf54:	e8 d7 e7 ff ff       	call   b730 <creat_subhead.isra.0>
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] am instance mIoctrl->statusPduSize is %d, buffer->pkt->len is %d\n", \
						//	mIoctrl->statusPduSize, buffer->pkt->len);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] ctrl data transport\n");
						//fsm_octets_print(buffer->pkt->data,10);
						
						if(buffer->pkt != NULL)
    cf59:	8b 03                	mov    (%ebx),%eax
    cf5b:	85 c0                	test   %eax,%eax
    cf5d:	74 0b                	je     cf6a <PMRLC_TRANSOP_IND+0x3fa>
						{
							fsm_pkt_destroy(buffer->pkt);  //20140922
    cf5f:	e8 fc ff ff ff       	call   cf60 <PMRLC_TRANSOP_IND+0x3f0>
							buffer->pkt = NULL;
    cf64:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						}
						if(buffer != NULL)
    cf6a:	85 db                	test   %ebx,%ebx
    cf6c:	74 07                	je     cf75 <PMRLC_TRANSOP_IND+0x405>
						{
							fsm_mem_free(buffer);  //20140922
    cf6e:	89 d8                	mov    %ebx,%eax
    cf70:	e8 fc ff ff ff       	call   cf71 <PMRLC_TRANSOP_IND+0x401>

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cf75:	8b 47 04             	mov    0x4(%edi),%eax
    cf78:	8d 57 04             	lea    0x4(%edi),%edx
    cf7b:	89 fb                	mov    %edi,%ebx
    cf7d:	83 e8 04             	sub    $0x4,%eax
    cf80:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    cf83:	74 3a                	je     cfbf <PMRLC_TRANSOP_IND+0x44f>
    cf85:	89 c7                	mov    %eax,%edi
				{
					if( buffer->pkt->len < 128 )
    cf87:	8b 03                	mov    (%ebx),%eax
    cf89:	8b 50 50             	mov    0x50(%eax),%edx
					{
						subHeadLen = 2;
    cf8c:	81 fa 80 00 00 00    	cmp    $0x80,%edx
    cf92:	19 c9                	sbb    %ecx,%ecx
    cf94:	83 c1 03             	add    $0x3,%ecx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    cf97:	01 ca                	add    %ecx,%edx
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
				{
					if( buffer->pkt->len < 128 )
					{
						subHeadLen = 2;
    cf99:	89 4d dc             	mov    %ecx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    cf9c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cf9f:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    cfa3:	39 c2                	cmp    %eax,%edx
    cfa5:	0f 86 1d ff ff ff    	jbe    cec8 <PMRLC_TRANSOP_IND+0x358>
					{
						fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->statusPduSize is %d, data is %d\n", \
    cfab:	89 54 24 08          	mov    %edx,0x8(%esp)
    cfaf:	89 44 24 04          	mov    %eax,0x4(%esp)
    cfb3:	c7 04 24 ac 38 00 00 	movl   $0x38ac,(%esp)
    cfba:	e8 fc ff ff ff       	call   cfbb <PMRLC_TRANSOP_IND+0x44b>
							break;
						}*/
					}
				}
				//
				if( !amIns->statProhTimer )
    cfbf:	8b 7e 20             	mov    0x20(%esi),%edi
    cfc2:	85 ff                	test   %edi,%edi
    cfc4:	0f 84 2f 06 00 00    	je     d5f9 <PMRLC_TRANSOP_IND+0xa89>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    cfca:	8b 45 d8             	mov    -0x28(%ebp),%eax
    cfcd:	8b 48 09             	mov    0x9(%eax),%ecx
    cfd0:	0f b7 50 0d          	movzwl 0xd(%eax),%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cfd4:	8d 86 9c 01 00 00    	lea    0x19c(%esi),%eax
    cfda:	89 45 c8             	mov    %eax,-0x38(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cfdd:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
    cfe3:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    cfe6:	0f 84 cf 01 00 00    	je     d1bb <PMRLC_TRANSOP_IND+0x64b>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    cfec:	0f b7 d2             	movzwl %dx,%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cfef:	01 ca                	add    %ecx,%edx
    cff1:	89 55 dc             	mov    %edx,-0x24(%ebp)
    cff4:	0f 84 c1 01 00 00    	je     d1bb <PMRLC_TRANSOP_IND+0x64b>
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    cffa:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    d000:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    d003:	e9 b8 00 00 00       	jmp    d0c0 <PMRLC_TRANSOP_IND+0x550>
						}
						if( subHeadLen < size )
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
    d008:	ba 78 05 00 00       	mov    $0x578,%edx
    d00d:	89 f8                	mov    %edi,%eax
    d00f:	e8 fc ff ff ff       	call   d010 <PMRLC_TRANSOP_IND+0x4a0>
    d014:	89 c3                	mov    %eax,%ebx
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
							}

							if( amIns->pduWithoutPoll >= amIns->pollPDU || amIns->byteWithoutPoll >= amIns->pollBYTE )
    d016:	0f b7 86 f6 22 00 00 	movzwl 0x22f6(%esi),%eax
    d01d:	66 39 86 fc 22 00 00 	cmp    %ax,0x22fc(%esi)
    d024:	73 10                	jae    d036 <PMRLC_TRANSOP_IND+0x4c6>
    d026:	0f b7 96 f8 22 00 00 	movzwl 0x22f8(%esi),%edx
    d02d:	66 39 96 fe 22 00 00 	cmp    %dx,0x22fe(%esi)
    d034:	72 09                	jb     d03f <PMRLC_TRANSOP_IND+0x4cf>
							{
								rlc_poll(amIns, pkp);
    d036:	89 da                	mov    %ebx,%edx
    d038:	89 f0                	mov    %esi,%eax
    d03a:	e8 fc ff ff ff       	call   d03b <PMRLC_TRANSOP_IND+0x4cb>
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
    d03f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d042:	8b 4b 50             	mov    0x50(%ebx),%ecx
    d045:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    d04b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    d051:	89 45 94             	mov    %eax,-0x6c(%ebp)
    d054:	e8 fc ff ff ff       	call   d055 <PMRLC_TRANSOP_IND+0x4e5>
							fsm_skb_put( pkptr,pkp->len);
    d059:	8b 53 50             	mov    0x50(%ebx),%edx
    d05c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d05f:	e8 fc ff ff ff       	call   d060 <PMRLC_TRANSOP_IND+0x4f0>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    d064:	8d 43 50             	lea    0x50(%ebx),%eax
    d067:	89 45 c4             	mov    %eax,-0x3c(%ebp)
								rlc_poll(amIns, pkp);
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
    d06a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d06d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d070:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d073:	89 44 24 04          	mov    %eax,0x4(%esp)
    d077:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    d07b:	89 04 24             	mov    %eax,(%esp)
    d07e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    d081:	e8 aa e6 ff ff       	call   b730 <creat_subhead.isra.0>
							size -= pkp->len + subHeadLen;
    d086:	8b 53 50             	mov    0x50(%ebx),%edx
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND] am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, pkp->len);

							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
    d089:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    d090:	01 
							amIns->byteWithoutPoll += pkp->len;  //??
    d091:	8b 43 50             	mov    0x50(%ebx),%eax
    d094:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    d09b:	89 d8                	mov    %ebx,%eax
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
							size -= pkp->len + subHeadLen;
    d09d:	29 55 dc             	sub    %edx,-0x24(%ebp)
    d0a0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d0a3:	29 4d dc             	sub    %ecx,-0x24(%ebp)
							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
							amIns->byteWithoutPoll += pkp->len;  //??
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    d0a6:	e8 fc ff ff ff       	call   d0a7 <PMRLC_TRANSOP_IND+0x537>
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d0ab:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    d0b1:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    d0b4:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    d0ba:	0f 84 f8 00 00 00    	je     d1b8 <PMRLC_TRANSOP_IND+0x648>
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
    d0c0:	0f bf 97 94 00 00 00 	movswl 0x94(%edi),%edx
    d0c7:	89 f0                	mov    %esi,%eax
    d0c9:	e8 fc ff ff ff       	call   d0ca <PMRLC_TRANSOP_IND+0x55a>
    d0ce:	84 c0                	test   %al,%al
    d0d0:	74 d9                	je     d0ab <PMRLC_TRANSOP_IND+0x53b>
					{
						if( amBuffer->pkt->len < 128 )
    d0d2:	8b 07                	mov    (%edi),%eax
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    d0d4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
    d0d7:	8b 40 50             	mov    0x50(%eax),%eax
						{
							subHeadLen = 2;
    d0da:	3d 80 00 00 00       	cmp    $0x80,%eax
    d0df:	19 d2                	sbb    %edx,%edx
    d0e1:	83 c2 03             	add    $0x3,%edx
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    d0e4:	39 ca                	cmp    %ecx,%edx
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
						{
							subHeadLen = 2;
    d0e6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    d0e9:	0f 83 a1 04 00 00    	jae    d590 <PMRLC_TRANSOP_IND+0xa20>
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
    d0ef:	89 ca                	mov    %ecx,%edx
    d0f1:	2b 55 d4             	sub    -0x2c(%ebp),%edx
    d0f4:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    d0fa:	0f 87 08 ff ff ff    	ja     d008 <PMRLC_TRANSOP_IND+0x498>
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
							}
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
    d100:	89 f8                	mov    %edi,%eax
    d102:	e8 fc ff ff ff       	call   d103 <PMRLC_TRANSOP_IND+0x593>
    d107:	89 c3                	mov    %eax,%ebx
    d109:	e9 08 ff ff ff       	jmp    d016 <PMRLC_TRANSOP_IND+0x4a6>
    d10e:	66 90                	xchg   %ax,%ax
				}
			}
			break;

		case UM_MODE:
			if(insptru == NULL)
    d110:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d113:	85 ff                	test   %edi,%edi
    d115:	0f 84 b5 fb ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d11b:	8b 75 d8             	mov    -0x28(%ebp),%esi
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d11e:	81 7f 20 80 00 00 00 	cmpl   $0x80,0x20(%edi)
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d125:	8b 4e 03             	mov    0x3(%esi),%ecx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d128:	19 c0                	sbb    %eax,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d12a:	0f b7 56 07          	movzwl 0x7(%esi),%edx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d12e:	83 c0 03             	add    $0x3,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d131:	01 ca                	add    %ecx,%edx
    d133:	39 d0                	cmp    %edx,%eax
    d135:	0f 83 cd 03 00 00    	jae    d508 <PMRLC_TRANSOP_IND+0x998>
			{
				//pkp = rlc_UM_segment(umTxIns , mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);//mIoctrl->txQueueHeader,  /20140726
				if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen > MAX_PDU_SIZE )
    d13b:	29 c2                	sub    %eax,%edx
    d13d:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    d143:	0f 86 af 03 00 00    	jbe    d4f8 <PMRLC_TRANSOP_IND+0x988>
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
    d149:	ba 78 05 00 00       	mov    $0x578,%edx
    d14e:	89 f8                	mov    %edi,%eax
    d150:	e8 fc ff ff ff       	call   d151 <PMRLC_TRANSOP_IND+0x5e1>
    d155:	89 c6                	mov    %eax,%esi
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
    d157:	85 f6                	test   %esi,%esi
    d159:	0f 84 e2 04 00 00    	je     d641 <PMRLC_TRANSOP_IND+0xad1>
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    d15f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d162:	8b 4e 50             	mov    0x50(%esi),%ecx
    d165:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    d16b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    d171:	89 45 9c             	mov    %eax,-0x64(%ebp)
    d174:	e8 fc ff ff ff       	call   d175 <PMRLC_TRANSOP_IND+0x605>
				fsm_skb_put( pkptr,pkp->len);
    d179:	8b 56 50             	mov    0x50(%esi),%edx
    d17c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d17f:	e8 fc ff ff ff       	call   d180 <PMRLC_TRANSOP_IND+0x610>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    d184:	8d 46 50             	lea    0x50(%esi),%eax
    d187:	89 45 dc             	mov    %eax,-0x24(%ebp)
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
				fsm_skb_put( pkptr,pkp->len);
				creat_subhead(pkp, &ptr,  &preptr, umTxIns->lcid, &data);
    d18a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d18d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d190:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d193:	89 44 24 04          	mov    %eax,0x4(%esp)
    d197:	0f b6 47 03          	movzbl 0x3(%edi),%eax
    d19b:	89 04 24             	mov    %eax,(%esp)
    d19e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d1a1:	e8 8a e5 ff ff       	call   b730 <creat_subhead.isra.0>

				fsm_pkt_destroy(pkp);  //20140922
    d1a6:	89 f0                	mov    %esi,%eax
    d1a8:	e8 fc ff ff ff       	call   d1a9 <PMRLC_TRANSOP_IND+0x639>
				pkp = NULL;
				break;
    d1ad:	e9 1e fb ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
    d1b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d1b8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d1bb:	8b 55 d8             	mov    -0x28(%ebp),%edx
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d1be:	89 f0                	mov    %esi,%eax
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d1c0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    d1c3:	8b 52 03             	mov    0x3(%edx),%edx
    d1c6:	0f b7 79 07          	movzwl 0x7(%ecx),%edi
    d1ca:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d1cd:	0f bf 56 2e          	movswl 0x2e(%esi),%edx
    d1d1:	e8 fc ff ff ff       	call   d1d2 <PMRLC_TRANSOP_IND+0x662>
    d1d6:	84 c0                	test   %al,%al
    d1d8:	0f 84 f2 fa ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d1de:	0f b7 ff             	movzwl %di,%edi
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d1e1:	03 7d dc             	add    -0x24(%ebp),%edi
    d1e4:	0f 84 e6 fa ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
    d1ea:	8d 46 44             	lea    0x44(%esi),%eax
    d1ed:	39 46 44             	cmp    %eax,0x44(%esi)
    d1f0:	0f 84 da fa ff ff    	je     ccd0 <PMRLC_TRANSOP_IND+0x160>
			//if(((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
			{
				//fsm_printf("[RLC][PMRLC_TRANSOP_IND] run to am sdu transport\n");
				if( amIns->amSduBufferSize < 128 )
				{
					subHeadLen = 2;
    d1f6:	81 7e 4c 80 00 00 00 	cmpl   $0x80,0x4c(%esi)
    d1fd:	19 c0                	sbb    %eax,%eax
    d1ff:	83 c0 03             	add    $0x3,%eax
				}
				else
				{
					subHeadLen = 3;
				}
				if( size > subHeadLen )
    d202:	39 f8                	cmp    %edi,%eax
    d204:	0f 83 b8 03 00 00    	jae    d5c2 <PMRLC_TRANSOP_IND+0xa52>
				{
					if( size - subHeadLen > MAX_PDU_SIZE )
    d20a:	29 c7                	sub    %eax,%edi
    d20c:	81 ff 78 05 00 00    	cmp    $0x578,%edi
    d212:	0f 86 9a 03 00 00    	jbe    d5b2 <PMRLC_TRANSOP_IND+0xa42>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
    d218:	ba 78 05 00 00       	mov    $0x578,%edx
    d21d:	89 f0                	mov    %esi,%eax
    d21f:	e8 fc ff ff ff       	call   d220 <PMRLC_TRANSOP_IND+0x6b0>
    d224:	89 c7                	mov    %eax,%edi
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
    d226:	85 ff                	test   %edi,%edi
    d228:	0f 84 02 04 00 00    	je     d630 <PMRLC_TRANSOP_IND+0xac0>
						//fsm_printf("[RLC] pduWithoutPoll is %d\n",amIns->pduWithoutPoll);
						//fsm_printf("[RLC] byteWithoutPoll is %d\n",amIns->byteWithoutPoll);
						rlc_poll(amIns,pkp);
					}*/
					//printk("[RLC][PMRLC_TRANSOP_IND] size=%d, pkp->len=%d, subHeadLen=%d\n",size,pkp->len,subHeadLen);
					fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    d22e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d231:	8b 4f 50             	mov    0x50(%edi),%ecx
    d234:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    d23a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    d240:	89 45 90             	mov    %eax,-0x70(%ebp)
    d243:	e8 fc ff ff ff       	call   d244 <PMRLC_TRANSOP_IND+0x6d4>
					if(pkptr->tail+pkp->len > pkptr->end)
    d248:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d24b:	8b 57 50             	mov    0x50(%edi),%edx
    d24e:	89 d0                	mov    %edx,%eax
    d250:	03 81 a0 00 00 00    	add    0xa0(%ecx),%eax
    d256:	39 81 a4 00 00 00    	cmp    %eax,0xa4(%ecx)
    d25c:	0f 82 10 fb ff ff    	jb     cd72 <PMRLC_TRANSOP_IND+0x202>
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
    d262:	89 c8                	mov    %ecx,%eax
    d264:	e8 fc ff ff ff       	call   d265 <PMRLC_TRANSOP_IND+0x6f5>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    d269:	8d 47 50             	lea    0x50(%edi),%eax
    d26c:	89 45 dc             	mov    %eax,-0x24(%ebp)
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
    d26f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d272:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d275:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d278:	89 44 24 04          	mov    %eax,0x4(%esp)
    d27c:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    d280:	89 04 24             	mov    %eax,(%esp)
    d283:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d286:	e8 a5 e4 ff ff       	call   b730 <creat_subhead.isra.0>
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d28b:	0f bf 86 64 12 00 00 	movswl 0x1264(%esi),%eax
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
    d292:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    d299:	01 
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d29a:	83 c0 01             	add    $0x1,%eax
    d29d:	89 c2                	mov    %eax,%edx
    d29f:	c1 fa 1f             	sar    $0x1f,%edx
    d2a2:	c1 ea 16             	shr    $0x16,%edx
    d2a5:	01 d0                	add    %edx,%eax
    d2a7:	25 ff 03 00 00       	and    $0x3ff,%eax
    d2ac:	29 d0                	sub    %edx,%eax

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d2ae:	ba 0a 00 00 00       	mov    $0xa,%edx
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d2b3:	66 89 86 64 12 00 00 	mov    %ax,0x1264(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
    d2ba:	8b 47 50             	mov    0x50(%edi),%eax
    d2bd:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d2c4:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    d2ca:	e8 fc ff ff ff       	call   d2cb <PMRLC_TRANSOP_IND+0x75b>

					fsm_pkt_destroy(pkp);  //20140922
    d2cf:	89 f8                	mov    %edi,%eax
    d2d1:	e8 fc ff ff ff       	call   d2d2 <PMRLC_TRANSOP_IND+0x762>
    d2d6:	e9 f5 f9 ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
    d2db:	90                   	nop
    d2dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    d2e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d2e3:	85 c0                	test   %eax,%eax
    d2e5:	0f 84 42 f9 ff ff    	je     cc2d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d2eb:	8b 5d e0             	mov    -0x20(%ebp),%ebx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d2ee:	8d 78 0c             	lea    0xc(%eax),%edi
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d2f1:	8b 56 03             	mov    0x3(%esi),%edx
    d2f4:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    d2f8:	01 d3                	add    %edx,%ebx
    d2fa:	01 d9                	add    %ebx,%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d2fc:	31 db                	xor    %ebx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d2fe:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d301:	8b 48 0c             	mov    0xc(%eax),%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d304:	39 cf                	cmp    %ecx,%edi
    d306:	74 5c                	je     d364 <PMRLC_TRANSOP_IND+0x7f4>
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
    d308:	8b 41 fc             	mov    -0x4(%ecx),%eax
    d30b:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d30e:	29 c2                	sub    %eax,%edx
    d310:	78 52                	js     d364 <PMRLC_TRANSOP_IND+0x7f4>
    d312:	89 75 c8             	mov    %esi,-0x38(%ebp)
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d315:	83 e9 04             	sub    $0x4,%ecx
    d318:	31 f6                	xor    %esi,%esi
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
    d31a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    d321:	eb 20                	jmp    d343 <PMRLC_TRANSOP_IND+0x7d3>
    d323:	90                   	nop
    d324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d328:	8b 41 04             	mov    0x4(%ecx),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
			{
				if(txBuffer->pkt->len < 127)
				{
					(*sevNum)++;
    d32b:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d32e:	39 c7                	cmp    %eax,%edi
    d330:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d333:	74 20                	je     d355 <PMRLC_TRANSOP_IND+0x7e5>
		{
			size -= txBuffer->pkt->len;
    d335:	8b 40 fc             	mov    -0x4(%eax),%eax
    d338:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d33b:	29 c2                	sub    %eax,%edx
    d33d:	0f 88 e5 01 00 00    	js     d528 <PMRLC_TRANSOP_IND+0x9b8>
			{
				if(txBuffer->pkt->len < 127)
    d343:	83 f8 7e             	cmp    $0x7e,%eax
    d346:	76 e0                	jbe    d328 <PMRLC_TRANSOP_IND+0x7b8>
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d348:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d34b:	83 c3 01             	add    $0x1,%ebx
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d34e:	39 c7                	cmp    %eax,%edi
    d350:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d353:	75 e0                	jne    d335 <PMRLC_TRANSOP_IND+0x7c5>
    d355:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    d358:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d35b:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d35e:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d361:	8d 1c 48             	lea    (%eax,%ecx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d364:	01 5d dc             	add    %ebx,-0x24(%ebp)
			break;
    d367:	e9 c1 f8 ff ff       	jmp    cc2d <PMRLC_TRANSOP_IND+0xbd>
    d36c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			//fsm_printf("[RLC][PMRLC_TRANSOP_IND] um instance(lcid is %d)'s buffer's subhead is %d \n",umTxIns->lcid,subhead);
			break;

		case AM_MODE:
			if(insptru == NULL)
    d370:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d373:	85 ff                	test   %edi,%edi
    d375:	0f 84 b2 f8 ff ff    	je     cc2d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d37b:	8b 56 03             	mov    0x3(%esi),%edx
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d37e:	8d 9f 9c 01 00 00    	lea    0x19c(%edi),%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d384:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d388:	8b 4d e0             	mov    -0x20(%ebp),%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d38b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    d392:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d399:	01 d0                	add    %edx,%eax
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d39b:	8b 56 09             	mov    0x9(%esi),%edx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d39e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    d3a1:	0f b7 46 0d          	movzwl 0xd(%esi),%eax
    d3a5:	01 d1                	add    %edx,%ecx
    d3a7:	01 c1                	add    %eax,%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d3a9:	0f b7 46 11          	movzwl 0x11(%esi),%eax
    d3ad:	01 c8                	add    %ecx,%eax
    d3af:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    d3b3:	01 c8                	add    %ecx,%eax
    d3b5:	89 4d bc             	mov    %ecx,-0x44(%ebp)
    d3b8:	8b 8f 9c 01 00 00    	mov    0x19c(%edi),%ecx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d3be:	03 45 d4             	add    -0x2c(%ebp),%eax
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d3c1:	39 cb                	cmp    %ecx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d3c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d3c6:	74 78                	je     d440 <PMRLC_TRANSOP_IND+0x8d0>
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d3c8:	8b 81 64 ff ff ff    	mov    -0x9c(%ecx),%eax
    d3ce:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d3d1:	29 c2                	sub    %eax,%edx
    d3d3:	0f 88 4c 02 00 00    	js     d625 <PMRLC_TRANSOP_IND+0xab5>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d3d9:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
    d3df:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
    d3e2:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
    d3e5:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d3e8:	31 f6                	xor    %esi,%esi
    d3ea:	89 7d a8             	mov    %edi,-0x58(%ebp)
    d3ed:	31 ff                	xor    %edi,%edi
    d3ef:	eb 2b                	jmp    d41c <PMRLC_TRANSOP_IND+0x8ac>
    d3f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    d3f8:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
			size -= amBuffer->pkt->len;
			if(0 <= size)
			{
				if(amBuffer->pkt->len  <  128)
				{
					(*sevNum)++;
    d3fe:	83 c7 01             	add    $0x1,%edi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d401:	39 c3                	cmp    %eax,%ebx
    d403:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d409:	74 29                	je     d434 <PMRLC_TRANSOP_IND+0x8c4>
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d40b:	8b 80 64 ff ff ff    	mov    -0x9c(%eax),%eax
    d411:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d414:	29 c2                	sub    %eax,%edx
    d416:	0f 88 24 01 00 00    	js     d540 <PMRLC_TRANSOP_IND+0x9d0>
			{
				if(amBuffer->pkt->len  <  128)
    d41c:	83 f8 7f             	cmp    $0x7f,%eax
    d41f:	76 d7                	jbe    d3f8 <PMRLC_TRANSOP_IND+0x888>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d421:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d427:	83 c6 01             	add    $0x1,%esi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d42a:	39 c3                	cmp    %eax,%ebx
    d42c:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d432:	75 d7                	jne    d40b <PMRLC_TRANSOP_IND+0x89b>
    d434:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d437:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d43a:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d43d:	8b 7d a8             	mov    -0x58(%ebp),%edi
    d440:	8b 8f b0 01 00 00    	mov    0x1b0(%edi),%ecx
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d446:	8d 9f b0 01 00 00    	lea    0x1b0(%edi),%ebx

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
    d44c:	31 ff                	xor    %edi,%edi
    d44e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d455:	39 cb                	cmp    %ecx,%ebx
    d457:	74 46                	je     d49f <PMRLC_TRANSOP_IND+0x92f>
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d459:	8b 41 fc             	mov    -0x4(%ecx),%eax
			if(0 <= size)
    d45c:	8b 55 bc             	mov    -0x44(%ebp),%edx
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d45f:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d462:	29 c2                	sub    %eax,%edx
    d464:	78 39                	js     d49f <PMRLC_TRANSOP_IND+0x92f>
    d466:	89 75 bc             	mov    %esi,-0x44(%ebp)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d469:	83 e9 04             	sub    $0x4,%ecx
    d46c:	31 f6                	xor    %esi,%esi
    d46e:	eb 17                	jmp    d487 <PMRLC_TRANSOP_IND+0x917>
    d470:	8b 41 04             	mov    0x4(%ecx),%eax
			size -= statBuffer->pkt->len;
			if(0 <= size)
			{
				if(statBuffer->pkt->len< 128)
				{
					(*sevNum)++;
    d473:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d476:	39 c3                	cmp    %eax,%ebx
    d478:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d47b:	74 1c                	je     d499 <PMRLC_TRANSOP_IND+0x929>
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d47d:	8b 40 fc             	mov    -0x4(%eax),%eax
    d480:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d483:	29 c2                	sub    %eax,%edx
    d485:	78 12                	js     d499 <PMRLC_TRANSOP_IND+0x929>
			{
				if(statBuffer->pkt->len< 128)
    d487:	83 f8 7f             	cmp    $0x7f,%eax
    d48a:	76 e4                	jbe    d470 <PMRLC_TRANSOP_IND+0x900>
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d48c:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					( *fifNum)++;
    d48f:	83 c7 01             	add    $0x1,%edi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d492:	39 c3                	cmp    %eax,%ebx
    d494:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d497:	75 e4                	jne    d47d <PMRLC_TRANSOP_IND+0x90d>
    d499:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d49c:	8b 75 bc             	mov    -0x44(%ebp),%esi
    d49f:	03 7d c8             	add    -0x38(%ebp),%edi
    d4a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d4a5:	03 45 c4             	add    -0x3c(%ebp),%eax
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d4a8:	8d 14 7f             	lea    (%edi,%edi,2),%edx
    d4ab:	8d 04 42             	lea    (%edx,%eax,2),%eax
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
			check_stat_num(amIns,mIoctrl->statusPduSize, &sevNum, &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d4ae:	03 45 dc             	add    -0x24(%ebp),%eax
			//fsm_printf("am instance(lcid is %d)'s status buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{				
				subhead += 2;
    d4b1:	8d 50 02             	lea    0x2(%eax),%edx
    d4b4:	83 c0 03             	add    $0x3,%eax
    d4b7:	83 7d d4 7f          	cmpl   $0x7f,-0x2c(%ebp)
    d4bb:	0f 46 c2             	cmovbe %edx,%eax
    d4be:	89 45 dc             	mov    %eax,-0x24(%ebp)
    d4c1:	e9 67 f7 ff ff       	jmp    cc2d <PMRLC_TRANSOP_IND+0xbd>
    d4c6:	66 90                	xchg   %ax,%ax
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			break;

		case UM_MODE:
			if(insptru == NULL)
    d4c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d4cb:	85 c0                	test   %eax,%eax
    d4cd:	0f 84 5a f7 ff ff    	je     cc2d <PMRLC_TRANSOP_IND+0xbd>
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d4d3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d4d6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d4d9:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d4dd:	03 46 03             	add    0x3(%esi),%eax
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d4e0:	83 c2 02             	add    $0x2,%edx
    d4e3:	83 c1 03             	add    $0x3,%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d4e6:	01 45 e0             	add    %eax,-0x20(%ebp)
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d4e9:	83 f8 7f             	cmp    $0x7f,%eax
    d4ec:	0f 47 d1             	cmova  %ecx,%edx
    d4ef:	89 55 dc             	mov    %edx,-0x24(%ebp)
    d4f2:	e9 36 f7 ff ff       	jmp    cc2d <PMRLC_TRANSOP_IND+0xbd>
    d4f7:	90                   	nop
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
				}
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
    d4f8:	89 f8                	mov    %edi,%eax
    d4fa:	e8 fc ff ff ff       	call   d4fb <PMRLC_TRANSOP_IND+0x98b>
    d4ff:	89 c6                	mov    %eax,%esi
    d501:	e9 51 fc ff ff       	jmp    d157 <PMRLC_TRANSOP_IND+0x5e7>
    d506:	66 90                	xchg   %ax,%ax
				pkp = NULL;
				break;
			}
			else
			{
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
    d508:	8b 13                	mov    (%ebx),%edx
    d50a:	03 42 50             	add    0x50(%edx),%eax
    d50d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    d511:	c7 04 24 54 38 00 00 	movl   $0x3854,(%esp)
    d518:	89 44 24 08          	mov    %eax,0x8(%esp)
    d51c:	e8 fc ff ff ff       	call   d51d <PMRLC_TRANSOP_IND+0x9ad>
				break;
    d521:	e9 aa f7 ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
    d526:	66 90                	xchg   %ax,%ax
    d528:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d52b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d52e:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d531:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d534:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d537:	01 5d dc             	add    %ebx,-0x24(%ebp)
    d53a:	e9 ee f6 ff ff       	jmp    cc2d <PMRLC_TRANSOP_IND+0xbd>
    d53f:	90                   	nop
    d540:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d543:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d546:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d549:	8b 7d a8             	mov    -0x58(%ebp),%edi
					(*fifNum)++;
				}
			}
			else
			{
				if(( size + amBuffer->pkt->len + 2 ) < 128)
    d54c:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    d550:	83 f8 7f             	cmp    $0x7f,%eax
    d553:	77 09                	ja     d55e <PMRLC_TRANSOP_IND+0x9ee>
				{
					(*sevNum)++;
    d555:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
    d559:	e9 e2 fe ff ff       	jmp    d440 <PMRLC_TRANSOP_IND+0x8d0>
				}
				else
				{
					(*fifNum)++;
    d55e:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
    d562:	e9 d9 fe ff ff       	jmp    d440 <PMRLC_TRANSOP_IND+0x8d0>
		}
	}
		
	if(0 == pkptr->len)
	{
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
    d567:	c7 04 24 f8 39 00 00 	movl   $0x39f8,(%esp)
    d56e:	e8 fc ff ff ff       	call   d56f <PMRLC_TRANSOP_IND+0x9ff>
		SV(bufferReqTimer) = 0;
    d573:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d576:	c7 80 34 37 00 00 00 	movl   $0x0,0x3734(%eax)
    d57d:	00 00 00 
		fsm_data_destroy(hptr);
    d580:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d583:	e8 fc ff ff ff       	call   d584 <PMRLC_TRANSOP_IND+0xa14>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d588:	83 c4 70             	add    $0x70,%esp
    d58b:	5b                   	pop    %ebx
    d58c:	5e                   	pop    %esi
    d58d:	5f                   	pop    %edi
    d58e:	5d                   	pop    %ebp
    d58f:	c3                   	ret    
							fsm_pkt_destroy(pkp);  //20140922
							pkp = NULL;
						}
						else
						{
							fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] break:am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, amBuffer->pkt->len+subHeadLen);
    d590:	03 45 d4             	add    -0x2c(%ebp),%eax
    d593:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    d596:	c7 04 24 04 39 00 00 	movl   $0x3904,(%esp)
    d59d:	89 44 24 08          	mov    %eax,0x8(%esp)
    d5a1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d5a4:	89 44 24 04          	mov    %eax,0x4(%esp)
    d5a8:	e8 fc ff ff ff       	call   d5a9 <PMRLC_TRANSOP_IND+0xa39>
							break;
    d5ad:	e9 09 fc ff ff       	jmp    d1bb <PMRLC_TRANSOP_IND+0x64b>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
    d5b2:	89 fa                	mov    %edi,%edx
    d5b4:	89 f0                	mov    %esi,%eax
    d5b6:	e8 fc ff ff ff       	call   d5b7 <PMRLC_TRANSOP_IND+0xa47>
    d5bb:	89 c7                	mov    %eax,%edi
    d5bd:	e9 64 fc ff ff       	jmp    d226 <PMRLC_TRANSOP_IND+0x6b6>
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
    d5c2:	8b 13                	mov    (%ebx),%edx
					fsm_pkt_destroy(pkp);  //20140922
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
    d5c4:	8b 75 d8             	mov    -0x28(%ebp),%esi
    d5c7:	03 42 50             	add    0x50(%edx),%eax
    d5ca:	89 44 24 08          	mov    %eax,0x8(%esp)
    d5ce:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d5d2:	03 46 03             	add    0x3(%esi),%eax
    d5d5:	c7 04 24 8c 39 00 00 	movl   $0x398c,(%esp)
    d5dc:	89 44 24 04          	mov    %eax,0x4(%esp)
    d5e0:	e8 fc ff ff ff       	call   d5e1 <PMRLC_TRANSOP_IND+0xa71>
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
					break;
    d5e5:	e9 e6 f6 ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
	nump = (u32*)hptr;
	num = *nump;
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
	{
		fsm_data_destroy(hptr);
    d5ea:	89 d0                	mov    %edx,%eax
    d5ec:	e8 fc ff ff ff       	call   d5ed <PMRLC_TRANSOP_IND+0xa7d>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d5f1:	83 c4 70             	add    $0x70,%esp
    d5f4:	5b                   	pop    %ebx
    d5f5:	5e                   	pop    %esi
    d5f6:	5f                   	pop    %edi
    d5f7:	5d                   	pop    %ebp
    d5f8:	c3                   	ret    
				}
				//
				if( !amIns->statProhTimer )
				{
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] the statProhTimer start\n");
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    d5f9:	8b 56 24             	mov    0x24(%esi),%edx
    d5fc:	8b 46 28             	mov    0x28(%esi),%eax
    d5ff:	e8 fc ff ff ff       	call   d600 <PMRLC_TRANSOP_IND+0xa90>
    d604:	89 46 20             	mov    %eax,0x20(%esi)
    d607:	e9 be f9 ff ff       	jmp    cfca <PMRLC_TRANSOP_IND+0x45a>
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
	{
		send_msg3(pkptr);
    d60c:	e8 fc ff ff ff       	call   d60d <PMRLC_TRANSOP_IND+0xa9d>
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
    d611:	c7 04 24 2c 3a 00 00 	movl   $0x3a2c,(%esp)
    d618:	e8 fc ff ff ff       	call   d619 <PMRLC_TRANSOP_IND+0xaa9>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d61d:	83 c4 70             	add    $0x70,%esp
    d620:	5b                   	pop    %ebx
    d621:	5e                   	pop    %esi
    d622:	5f                   	pop    %edi
    d623:	5d                   	pop    %ebp
    d624:	c3                   	ret    
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d625:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d628:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d62b:	e9 1c ff ff ff       	jmp    d54c <PMRLC_TRANSOP_IND+0x9dc>
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
					{
						printk("[RLC][PMRLC_TRANSOP_IND][AM] pkp == NULL\n");
    d630:	c7 04 24 60 39 00 00 	movl   $0x3960,(%esp)
    d637:	e8 fc ff ff ff       	call   d638 <PMRLC_TRANSOP_IND+0xac8>
						break;
    d63c:	e9 8f f6 ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
    d641:	c7 04 24 28 38 00 00 	movl   $0x3828,(%esp)
    d648:	e8 fc ff ff ff       	call   d649 <PMRLC_TRANSOP_IND+0xad9>
					break;
    d64d:	e9 7e f6 ff ff       	jmp    ccd0 <PMRLC_TRANSOP_IND+0x160>
    d652:	90                   	nop
    d653:	90                   	nop
    d654:	90                   	nop
    d655:	90                   	nop
    d656:	90                   	nop
    d657:	90                   	nop
    d658:	90                   	nop
    d659:	90                   	nop
    d65a:	90                   	nop
    d65b:	90                   	nop
    d65c:	90                   	nop
    d65d:	90                   	nop
    d65e:	90                   	nop
    d65f:	90                   	nop

0000d660 <get_AmPduhdExt>:
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d660:	55                   	push   %ebp
    d661:	89 e5                	mov    %esp,%ebp
    d663:	83 ec 14             	sub    $0x14,%esp
    d666:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d669:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d66c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d66f:	e8 fc ff ff ff       	call   d670 <get_AmPduhdExt+0x10>
    d674:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d677:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d67b:	89 d6                	mov    %edx,%esi
    d67d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d67f:	74 0f                	je     d690 <get_AmPduhdExt+0x30>
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
	}
	return count;
}
    d681:	89 d8                	mov    %ebx,%eax
    d683:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d686:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d689:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d68c:	89 ec                	mov    %ebp,%esp
    d68e:	5d                   	pop    %ebp
    d68f:	c3                   	ret    
u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d690:	8b 02                	mov    (%edx),%eax
    d692:	b9 02 00 00 00       	mov    $0x2,%ecx

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d697:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d69d:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d6a3:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d6a6:	e8 fc ff ff ff       	call   d6a7 <get_AmPduhdExt+0x47>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d6ab:	8b 06                	mov    (%esi),%eax
    d6ad:	ba 02 00 00 00       	mov    $0x2,%edx
    d6b2:	e8 fc ff ff ff       	call   d6b3 <get_AmPduhdExt+0x53>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d6b7:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d6bb:	0f b7 d3             	movzwl %bx,%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
    d6be:	83 c3 01             	add    $0x1,%ebx
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d6c1:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d6c4:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d6ca:	66 25 ff 7f          	and    $0x7fff,%ax
    d6ce:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d6d3:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d6d8:	89 f2                	mov    %esi,%edx
    d6da:	89 3c 24             	mov    %edi,(%esp)
    d6dd:	e8 fc ff ff ff       	call   d6de <get_AmPduhdExt+0x7e>
	}
	return count;
}
    d6e2:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d6e5:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d6e8:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d6ea:	89 d8                	mov    %ebx,%eax
    d6ec:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d6ef:	89 ec                	mov    %ebp,%esp
    d6f1:	5d                   	pop    %ebp
    d6f2:	c3                   	ret    
    d6f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d6f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000d700 <get_UmPduhdExt>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d700:	55                   	push   %ebp
    d701:	89 e5                	mov    %esp,%ebp
    d703:	83 ec 18             	sub    $0x18,%esp
    d706:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d709:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d70c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d70f:	e8 fc ff ff ff       	call   d710 <get_UmPduhdExt+0x10>
    d714:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d717:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d71b:	89 d6                	mov    %edx,%esi
    d71d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d71f:	74 0f                	je     d730 <get_UmPduhdExt+0x30>

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
	}
	return count;
}
    d721:	89 d8                	mov    %ebx,%eax
    d723:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d726:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d729:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d72c:	89 ec                	mov    %ebp,%esp
    d72e:	5d                   	pop    %ebp
    d72f:	c3                   	ret    
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d730:	0f b7 c1             	movzwl %cx,%eax
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d733:	b9 02 00 00 00       	mov    $0x2,%ecx
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d738:	89 45 ec             	mov    %eax,-0x14(%ebp)
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d73b:	8b 02                	mov    (%edx),%eax
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
    d73d:	83 c3 01             	add    $0x1,%ebx

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d740:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d746:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d74c:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d74f:	e8 fc ff ff ff       	call   d750 <get_UmPduhdExt+0x50>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d754:	8b 06                	mov    (%esi),%eax
    d756:	ba 02 00 00 00       	mov    $0x2,%edx
    d75b:	e8 fc ff ff ff       	call   d75c <get_UmPduhdExt+0x5c>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d760:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d764:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d767:	8b 55 ec             	mov    -0x14(%ebp),%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
    d76a:	66 25 ff 7f          	and    $0x7fff,%ax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d76e:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d774:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d779:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d77e:	89 f2                	mov    %esi,%edx
    d780:	89 3c 24             	mov    %edi,(%esp)
    d783:	e8 fc ff ff ff       	call   d784 <get_UmPduhdExt+0x84>
	}
	return count;
}
    d788:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d78b:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d78e:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d790:	89 d8                	mov    %ebx,%eax
    d792:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d795:	89 ec                	mov    %ebp,%esp
    d797:	5d                   	pop    %ebp
    d798:	c3                   	ret    
    d799:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000d7a0 <clear_left_pdu>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void clear_left_pdu(struct pduLeft *pdu_left)
{	
    d7a0:	55                   	push   %ebp
    d7a1:	89 e5                	mov    %esp,%ebp
    d7a3:	53                   	push   %ebx
    d7a4:	e8 fc ff ff ff       	call   d7a5 <clear_left_pdu+0x5>
    d7a9:	89 c3                	mov    %eax,%ebx
	pdu_left->SN_Left = -1;
    d7ab:	66 c7 40 02 ff ff    	movw   $0xffff,0x2(%eax)
	pdu_left->SN5_Left = -1;
    d7b1:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
	if(pdu_left->sduLeft != NULL)
    d7b6:	8b 40 04             	mov    0x4(%eax),%eax
    d7b9:	85 c0                	test   %eax,%eax
    d7bb:	74 0c                	je     d7c9 <clear_left_pdu+0x29>
	{
	    fsm_pkt_destroy(pdu_left->sduLeft);
    d7bd:	e8 fc ff ff ff       	call   d7be <clear_left_pdu+0x1e>
		pdu_left->sduLeft = NULL;
    d7c2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	}               
}
    d7c9:	5b                   	pop    %ebx
    d7ca:	5d                   	pop    %ebp
    d7cb:	c3                   	ret    
    d7cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000d7d0 <rlc_AM_segment>:
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d7d0:	55                   	push   %ebp
    d7d1:	89 e5                	mov    %esp,%ebp
    d7d3:	57                   	push   %edi
    d7d4:	56                   	push   %esi
    d7d5:	53                   	push   %ebx
    d7d6:	83 ec 38             	sub    $0x38,%esp
    d7d9:	e8 fc ff ff ff       	call   d7da <rlc_AM_segment+0xa>
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d7de:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d7e2:	89 c7                	mov    %eax,%edi

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d7e4:	8b 40 50             	mov    0x50(%eax),%eax
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d7e7:	66 81 e6 00 fc       	and    $0xfc00,%si
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d7ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d7ef:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
    d7f3:	66 25 ff 03          	and    $0x3ff,%ax
    d7f7:	09 c6                	or     %eax,%esi
    d7f9:	66 89 75 f2          	mov    %si,-0xe(%ebp)
	fixhead->DorC=1;
    d7fd:	66 c1 ee 08          	shr    $0x8,%si
	fixhead->RF=0;
    d801:	83 e6 1f             	and    $0x1f,%esi
	fixhead->P=1;
    d804:	83 ce a0             	or     $0xffffffa0,%esi
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d807:	83 fa 02             	cmp    $0x2,%edx
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
	fixhead->DorC=1;
	fixhead->RF=0;
	fixhead->P=1;
    d80a:	89 f1                	mov    %esi,%ecx
    d80c:	88 4d f3             	mov    %cl,-0xd(%ebp)
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d80f:	0f 86 e1 06 00 00    	jbe    def6 <rlc_AM_segment+0x726>
    d815:	8b 47 44             	mov    0x44(%edi),%eax
	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
	FSM_PKT *skb;//*skb_copy;
	struct list_head *head =&(amIns->amSduBuffer.list);
    d818:	8d 5f 44             	lea    0x44(%edi),%ebx
    d81b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
    d81e:	39 c3                	cmp    %eax,%ebx
    d820:	0f 84 02 05 00 00    	je     dd28 <rlc_AM_segment+0x558>
	{
		list_for_each_entry(amBuffer,head,list)
    d826:	8d 58 f4             	lea    -0xc(%eax),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d829:	8b 40 f4             	mov    -0xc(%eax),%eax
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
    d82c:	83 ea 02             	sub    $0x2,%edx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d82f:	8b 40 50             	mov    0x50(%eax),%eax
    d832:	39 c2                	cmp    %eax,%edx
    d834:	0f 82 5f 06 00 00    	jb     de99 <rlc_AM_segment+0x6c9>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d83a:	0f 84 2a 06 00 00    	je     de6a <rlc_AM_segment+0x69a>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d840:	8d 48 02             	lea    0x2(%eax),%ecx
    d843:	39 ca                	cmp    %ecx,%edx
    d845:	0f 86 7d 06 00 00    	jbe    dec8 <rlc_AM_segment+0x6f8>
    d84b:	89 7d e0             	mov    %edi,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    d84e:	b9 01 00 00 00       	mov    $0x1,%ecx
    d853:	bf 01 00 00 00       	mov    $0x1,%edi
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d858:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    d85e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d864:	eb 56                	jmp    d8bc <rlc_AM_segment+0xec>
    d866:	66 90                	xchg   %ax,%ax
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(amBuffer->pktstatus != FULL_SDU && flag)
    d868:	84 c9                	test   %cl,%cl
    d86a:	74 08                	je     d874 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
    d86c:	83 ce 14             	or     $0x14,%esi
    d86f:	89 f1                	mov    %esi,%ecx
    d871:	88 4d f3             	mov    %cl,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    d874:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
    d878:	74 66                	je     d8e0 <rlc_AM_segment+0x110>
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d87a:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    d87d:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
    d880:	8d 59 f4             	lea    -0xc(%ecx),%ebx
    d883:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    d886:	0f 84 a9 03 00 00    	je     dc35 <rlc_AM_segment+0x465>
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d88c:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d891:	83 c7 01             	add    $0x1,%edi
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d894:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d896:	8b 41 f4             	mov    -0xc(%ecx),%eax
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d899:	01 da                	add    %ebx,%edx
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d89b:	8b 5d dc             	mov    -0x24(%ebp),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d89e:	8b 40 50             	mov    0x50(%eax),%eax
    d8a1:	39 d0                	cmp    %edx,%eax
    d8a3:	0f 87 98 03 00 00    	ja     dc41 <rlc_AM_segment+0x471>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d8a9:	0f 84 e7 03 00 00    	je     dc96 <rlc_AM_segment+0x4c6>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d8af:	8d 48 02             	lea    0x2(%eax),%ecx
    d8b2:	39 d1                	cmp    %edx,%ecx
    d8b4:	0f 83 1b 04 00 00    	jae    dcd5 <rlc_AM_segment+0x505>
    d8ba:	31 c9                	xor    %ecx,%ecx
			{

				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
    d8bc:	66 01 45 ec          	add    %ax,-0x14(%ebp)
				if(amBuffer->pktstatus == FULL_SDU && flag)
    d8c0:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d8c4:	75 a2                	jne    d868 <rlc_AM_segment+0x98>
    d8c6:	84 c9                	test   %cl,%cl
    d8c8:	74 aa                	je     d874 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=0;
    d8ca:	83 e6 ef             	and    $0xffffffef,%esi
					fixhead->E=1;
    d8cd:	83 ce 04             	or     $0x4,%esi
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d8d0:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
				if(amBuffer->pktstatus == FULL_SDU && flag)
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
    d8d4:	89 f1                	mov    %esi,%ecx
    d8d6:	88 4d f3             	mov    %cl,-0xd(%ebp)
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d8d9:	75 9f                	jne    d87a <rlc_AM_segment+0xaa>
    d8db:	90                   	nop
    d8dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    d8e0:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d8e4:	8b 7d e0             	mov    -0x20(%ebp),%edi
				{
					if((amIns->amSduBufferNum)==1)
					{
						fixhead->E=0;
    d8e7:	89 f0                	mov    %esi,%eax
    d8e9:	83 e0 fb             	and    $0xfffffffb,%eax
    d8ec:	83 7f 50 01          	cmpl   $0x1,0x50(%edi)
    d8f0:	0f 45 c6             	cmovne %esi,%eax
					}
					fixhead->FIsecond=0;
    d8f3:	83 e0 f7             	and    $0xfffffff7,%eax
    d8f6:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=amBuffer->pkt->len;
    d8f9:	8b 03                	mov    (%ebx),%eax
    d8fb:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    d8ff:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d903:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
    d907:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d90b:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d90f:	8d 34 58             	lea    (%eax,%ebx,2),%esi
    d912:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
    d915:	0f b7 de             	movzwl %si,%ebx
    d918:	89 55 e0             	mov    %edx,-0x20(%ebp)
    d91b:	89 55 c8             	mov    %edx,-0x38(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    d91e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    d922:	0f b7 d0             	movzwl %ax,%edx
    d925:	c1 e2 08             	shl    $0x8,%edx
    d928:	66 c1 e8 08          	shr    $0x8,%ax
    d92c:	09 d0                	or     %edx,%eax
	fsm_octets_print(fixhead,2);
    d92e:	ba 02 00 00 00       	mov    $0x2,%edx
    d933:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    d937:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d93a:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d93d:	e8 fc ff ff ff       	call   d93e <rlc_AM_segment+0x16e>
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d942:	89 d8                	mov    %ebx,%eax
    d944:	e8 fc ff ff ff       	call   d945 <rlc_AM_segment+0x175>
	pos = head->next;
    d949:	8b 5f 44             	mov    0x44(%edi),%ebx
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d94c:	66 83 7d da 01       	cmpw   $0x1,-0x26(%ebp)
    d951:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
	fsm_octets_print(fixhead,2);
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d954:	89 45 e8             	mov    %eax,-0x18(%ebp)
	pos = head->next;
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d957:	0f 84 f1 03 00 00    	je     dd4e <rlc_AM_segment+0x57e>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			amIns->amSduBufferSize -= lastCopyLen;
			tbuff->pktstatus = LAST_SEGMENT;
		}		
	}
	else if(count > 1)
    d95d:	0f 86 79 01 00 00    	jbe    dadc <rlc_AM_segment+0x30c>
	{
		fsm_skb_reserve(skb,2*count);		
    d963:	8b 55 e0             	mov    -0x20(%ebp),%edx
    d966:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d969:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d96c:	e8 fc ff ff ff       	call   d96d <rlc_AM_segment+0x19d>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d971:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    d974:	83 e9 01             	sub    $0x1,%ecx
    d977:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d97a:	01 c9                	add    %ecx,%ecx
    d97c:	89 c8                	mov    %ecx,%eax
    d97e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    d981:	e8 fc ff ff ff       	call   d982 <rlc_AM_segment+0x1b2>
    d986:	89 45 d0             	mov    %eax,-0x30(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d989:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d98c:	e8 fc ff ff ff       	call   d98d <rlc_AM_segment+0x1bd>
    d991:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		i = 0;
		u8 *des = skb->data;
    d994:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d997:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    d99d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d9a0:	8b 47 44             	mov    0x44(%edi),%eax
    d9a3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
    d9a6:	8b 30                	mov    (%eax),%esi
    d9a8:	8d 58 f4             	lea    -0xc(%eax),%ebx
    d9ab:	0f 84 cf 00 00 00    	je     da80 <rlc_AM_segment+0x2b0>
    d9b1:	83 ee 0c             	sub    $0xc,%esi
	else if(count > 1)
	{
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
    d9b4:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d9ba:	eb 20                	jmp    d9dc <rlc_AM_segment+0x20c>
    d9bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
			}
			else if(i==count-1)
    d9c0:	0f 84 fa 01 00 00    	je     dbc0 <rlc_AM_segment+0x3f0>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d9c6:	8b 46 0c             	mov    0xc(%esi),%eax
    d9c9:	8d 56 0c             	lea    0xc(%esi),%edx
    d9cc:	83 e8 0c             	sub    $0xc,%eax
    d9cf:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d9d2:	0f 84 a8 00 00 00    	je     da80 <rlc_AM_segment+0x2b0>
    d9d8:	89 f3                	mov    %esi,%ebx
    d9da:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    d9dc:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d9e0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    d9e3:	7e db                	jle    d9c0 <rlc_AM_segment+0x1f0>
			{
				*(LI+i) = amBuffer->pkt->len;
    d9e5:	8b 13                	mov    (%ebx),%edx
    d9e7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d9ea:	8b 52 50             	mov    0x50(%edx),%edx
    d9ed:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				*(headExt+i) = 0x8000|(*(LI+i));
    d9f1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d9f4:	66 81 ca 00 80       	or     $0x8000,%dx
    d9f9:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				fsm_skb_put(skb,amBuffer->pkt->len);
    d9fd:	8b 03                	mov    (%ebx),%eax
    d9ff:	8b 50 50             	mov    0x50(%eax),%edx
    da02:	8b 45 e8             	mov    -0x18(%ebp),%eax
    da05:	e8 fc ff ff ff       	call   da06 <rlc_AM_segment+0x236>
				fsm_mem_cpy(des,amBuffer->pkt->data,amBuffer->pkt->len);
    da0a:	8b 03                	mov    (%ebx),%eax
    da0c:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    da12:	8b 48 50             	mov    0x50(%eax),%ecx
    da15:	8b 45 dc             	mov    -0x24(%ebp),%eax
    da18:	e8 fc ff ff ff       	call   da19 <rlc_AM_segment+0x249>
				des = des + amBuffer->pkt->len ;
    da1d:	8b 03                	mov    (%ebx),%eax
    da1f:	8b 50 50             	mov    0x50(%eax),%edx
    da22:	01 55 dc             	add    %edx,-0x24(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    da25:	8b 43 10             	mov    0x10(%ebx),%eax
    da28:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    da2b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    da2e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    da30:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    da37:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				list_del(&amBuffer->list);
				amIns->amSduBufferNum--;
    da3e:	83 6f 50 01          	subl   $0x1,0x50(%edi)
				amIns->amSduBufferSize -= amBuffer->pkt->len;
    da42:	8b 03                	mov    (%ebx),%eax
    da44:	8b 40 50             	mov    0x50(%eax),%eax
    da47:	29 47 4c             	sub    %eax,0x4c(%edi)

				if(amBuffer->pkt != NULL)
    da4a:	8b 03                	mov    (%ebx),%eax
    da4c:	85 c0                	test   %eax,%eax
    da4e:	74 0b                	je     da5b <rlc_AM_segment+0x28b>
				{
					fsm_pkt_destroy(amBuffer->pkt);
    da50:	e8 fc ff ff ff       	call   da51 <rlc_AM_segment+0x281>
					amBuffer->pkt = NULL;
    da55:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				}
				if(amBuffer != NULL)
    da5b:	85 db                	test   %ebx,%ebx
    da5d:	74 07                	je     da66 <rlc_AM_segment+0x296>
				{
					fsm_mem_free(amBuffer);
    da5f:	89 d8                	mov    %ebx,%eax
    da61:	e8 fc ff ff ff       	call   da62 <rlc_AM_segment+0x292>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    da66:	8b 46 0c             	mov    0xc(%esi),%eax
    da69:	8d 56 0c             	lea    0xc(%esi),%edx
				if(amBuffer != NULL)
				{
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
    da6c:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    da71:	83 e8 0c             	sub    $0xc,%eax
    da74:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    da77:	0f 85 5b ff ff ff    	jne    d9d8 <rlc_AM_segment+0x208>
    da7d:	8d 76 00             	lea    0x0(%esi),%esi
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    da80:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    da84:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    da87:	8b 55 cc             	mov    -0x34(%ebp),%edx
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    da8a:	66 81 64 41 fc ff 7f 	andw   $0x7fff,-0x4(%ecx,%eax,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    da91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    da94:	e8 fc ff ff ff       	call   da95 <rlc_AM_segment+0x2c5>
    da99:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    da9c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    da9f:	e8 fc ff ff ff       	call   daa0 <rlc_AM_segment+0x2d0>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    daa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    daa7:	ba 02 00 00 00       	mov    $0x2,%edx
    daac:	e8 fc ff ff ff       	call   daad <rlc_AM_segment+0x2dd>
    dab1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    dab4:	b9 02 00 00 00       	mov    $0x2,%ecx
    dab9:	e8 fc ff ff ff       	call   daba <rlc_AM_segment+0x2ea>
		if(LI != NULL)
    dabe:	8b 55 d0             	mov    -0x30(%ebp),%edx
    dac1:	85 d2                	test   %edx,%edx
    dac3:	74 08                	je     dacd <rlc_AM_segment+0x2fd>
		{
			fsm_mem_free(LI);
    dac5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    dac8:	e8 fc ff ff ff       	call   dac9 <rlc_AM_segment+0x2f9>
			LI = NULL;
		}
		if(headExt != NULL)
    dacd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    dad0:	85 c0                	test   %eax,%eax
    dad2:	74 08                	je     dadc <rlc_AM_segment+0x30c>
		{
			fsm_mem_free(headExt);
    dad4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    dad7:	e8 fc ff ff ff       	call   dad8 <rlc_AM_segment+0x308>
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    dadc:	b8 a4 00 00 00       	mov    $0xa4,%eax
    dae1:	e8 fc ff ff ff       	call   dae2 <rlc_AM_segment+0x312>
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    dae6:	8b 55 e8             	mov    -0x18(%ebp),%edx
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    dae9:	89 c3                	mov    %eax,%ebx
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    daeb:	8b 82 b0 00 00 00    	mov    0xb0(%edx),%eax
    daf1:	e8 fc ff ff ff       	call   daf2 <rlc_AM_segment+0x322>
    daf6:	89 03                	mov    %eax,(%ebx)
	amBuf->pkt = fsm_pkt_duplicate(skb);
    daf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dafb:	e8 fc ff ff ff       	call   dafc <rlc_AM_segment+0x32c>
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
    db00:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    db03:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
    db06:	89 03                	mov    %eax,(%ebx)
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    db08:	8b 40 50             	mov    0x50(%eax),%eax
	amBuf->segnum = 0;
    db0b:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
    db12:	00 00 00 
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    db15:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    db1b:	31 c0                	xor    %eax,%eax
    db1d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		amBuf->segStart[j] = -1;
    db20:	c7 44 83 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%eax,4)
    db27:	ff 
		amBuf->segEnd[j] = -1;
    db28:	c7 44 83 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%eax,4)
    db2f:	ff 
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    db30:	83 c0 01             	add    $0x1,%eax
    db33:	83 f8 10             	cmp    $0x10,%eax
    db36:	75 e8                	jne    db20 <rlc_AM_segment+0x350>
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    db38:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    db3c:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
    db42:	66 c7 83 96 00 00 00 	movw   $0xffff,0x96(%ebx)
    db49:	ff ff 
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    db4b:	8d 8f f0 00 00 00    	lea    0xf0(%edi),%ecx
	for( j = 0; j < segNumMax; j++ )
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    db51:	66 89 83 94 00 00 00 	mov    %ax,0x94(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    db58:	8b 87 f4 00 00 00    	mov    0xf4(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    db5e:	89 97 f4 00 00 00    	mov    %edx,0xf4(%edi)
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    db64:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    db6a:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    db70:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
    db72:	8b 03                	mov    (%ebx),%eax
    db74:	8b 40 50             	mov    0x50(%eax),%eax
    db77:	01 87 f8 00 00 00    	add    %eax,0xf8(%edi)
	amIns->amTransmittedBufferNum++;
	amIns->SN++;
    db7d:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
	amIns->amTransmittedBufferNum++;
    db81:	83 87 fc 00 00 00 01 	addl   $0x1,0xfc(%edi)
	amIns->SN++;
    db88:	83 c0 01             	add    $0x1,%eax
	amIns->SN %= 1024;
    db8b:	89 c2                	mov    %eax,%edx
    db8d:	66 c1 fa 0f          	sar    $0xf,%dx
    db91:	66 c1 ea 06          	shr    $0x6,%dx
    db95:	01 d0                	add    %edx,%eax
    db97:	66 25 ff 03          	and    $0x3ff,%ax
    db9b:	66 29 d0             	sub    %dx,%ax
    db9e:	66 89 47 2e          	mov    %ax,0x2e(%edi)
	fsm_printf("[RLC][rlc_AM_segment] SN = %d\n",amIns->SN);
    dba2:	98                   	cwtl   
    dba3:	89 44 24 04          	mov    %eax,0x4(%esp)
    dba7:	c7 04 24 9c 3a 00 00 	movl   $0x3a9c,(%esp)
    dbae:	e8 fc ff ff ff       	call   dbaf <rlc_AM_segment+0x3df>
	return skb;
}
    dbb3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dbb6:	83 c4 38             	add    $0x38,%esp
    dbb9:	5b                   	pop    %ebx
    dbba:	5e                   	pop    %esi
    dbbb:	5f                   	pop    %edi
    dbbc:	5d                   	pop    %ebp
    dbbd:	c3                   	ret    
    dbbe:	66 90                	xchg   %ax,%ax
				}				
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    dbc0:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    dbc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dbc7:	89 f2                	mov    %esi,%edx
    dbc9:	e8 fc ff ff ff       	call   dbca <rlc_AM_segment+0x3fa>
				fsm_mem_cpy(des,amBuffer->pkt->data,lastCopyLen);
    dbce:	8b 03                	mov    (%ebx),%eax
    dbd0:	89 f1                	mov    %esi,%ecx
    dbd2:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    dbd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbdb:	e8 fc ff ff ff       	call   dbdc <rlc_AM_segment+0x40c>
				
				if(amBuffer->pkt->len == lastCopyLen)
    dbe0:	8b 03                	mov    (%ebx),%eax
    dbe2:	3b 70 50             	cmp    0x50(%eax),%esi
    dbe5:	0f 85 fc 01 00 00    	jne    dde7 <rlc_AM_segment+0x617>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    dbeb:	8b 43 10             	mov    0x10(%ebx),%eax
    dbee:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dbf1:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dbf4:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    dbf6:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    dbfd:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				{
					list_del(&amBuffer->list);
					amIns->amSduBufferNum--;
    dc04:	83 6f 50 01          	subl   $0x1,0x50(%edi)
					amIns->amSduBufferSize -= amBuffer->pkt->len;
    dc08:	8b 03                	mov    (%ebx),%eax
    dc0a:	8b 40 50             	mov    0x50(%eax),%eax
    dc0d:	29 47 4c             	sub    %eax,0x4c(%edi)
					if(amBuffer->pkt != NULL)
    dc10:	8b 03                	mov    (%ebx),%eax
    dc12:	85 c0                	test   %eax,%eax
    dc14:	74 0b                	je     dc21 <rlc_AM_segment+0x451>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    dc16:	e8 fc ff ff ff       	call   dc17 <rlc_AM_segment+0x447>
						amBuffer->pkt = NULL;
    dc1b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    dc21:	85 db                	test   %ebx,%ebx
    dc23:	0f 84 57 fe ff ff    	je     da80 <rlc_AM_segment+0x2b0>
					{
						fsm_mem_free(amBuffer);
    dc29:	89 d8                	mov    %ebx,%eax
    dc2b:	e8 fc ff ff ff       	call   dc2c <rlc_AM_segment+0x45c>
    dc30:	e9 4b fe ff ff       	jmp    da80 <rlc_AM_segment+0x2b0>
    dc35:	66 89 7d da          	mov    %di,-0x26(%ebp)
    dc39:	8b 7d e0             	mov    -0x20(%ebp),%edi
    dc3c:	e9 c2 fc ff ff       	jmp    d903 <rlc_AM_segment+0x133>
    dc41:	66 89 7d da          	mov    %di,-0x26(%ebp)
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dc45:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    dc49:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    dc4d:	8b 7d e0             	mov    -0x20(%ebp),%edi
    dc50:	01 c0                	add    %eax,%eax
    dc52:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    dc56:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    dc59:	89 45 e0             	mov    %eax,-0x20(%ebp)
    dc5c:	89 45 c8             	mov    %eax,-0x38(%ebp)
    dc5f:	31 c0                	xor    %eax,%eax
			{
				if(amBuffer->pktstatus ==FULL_SDU)
    dc61:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dc65:	0f 84 92 01 00 00    	je     ddfd <rlc_AM_segment+0x62d>
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    dc6b:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    dc6d:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    dc6f:	0f 84 8e 01 00 00    	je     de03 <rlc_AM_segment+0x633>
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    dc75:	83 e0 e3             	and    $0xffffffe3,%eax
						fixhead->FIsecond=1;
    dc78:	83 c8 18             	or     $0x18,%eax
    dc7b:	88 45 f3             	mov    %al,-0xd(%ebp)
    dc7e:	66 90                	xchg   %ax,%ax
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
				length = length + size;
    dc80:	0f b7 75 e8          	movzwl -0x18(%ebp),%esi
    dc84:	66 03 75 ec          	add    -0x14(%ebp),%si
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
    dc88:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    dc8c:	01 d6                	add    %edx,%esi
    dc8e:	0f b7 de             	movzwl %si,%ebx
				length = length + size;
				break;
    dc91:	e9 88 fc ff ff       	jmp    d91e <rlc_AM_segment+0x14e>
    dc96:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    dc9a:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    dc9e:	8b 7d e0             	mov    -0x20(%ebp),%edi
    dca1:	01 c9                	add    %ecx,%ecx
    dca3:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
    dca7:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    dcab:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    dcae:	89 45 e0             	mov    %eax,-0x20(%ebp)
    dcb1:	89 45 c8             	mov    %eax,-0x38(%ebp)
    dcb4:	31 c0                	xor    %eax,%eax
			{

				if(amBuffer->pktstatus == FULL_SDU)
    dcb6:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dcba:	0f 84 88 01 00 00    	je     de48 <rlc_AM_segment+0x678>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dcc0:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    dcc2:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dcc4:	0f 84 44 01 00 00    	je     de0e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=1;
    dcca:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    dccd:	83 e0 f3             	and    $0xfffffff3,%eax
    dcd0:	88 45 f3             	mov    %al,-0xd(%ebp)
    dcd3:	eb ab                	jmp    dc80 <rlc_AM_segment+0x4b0>
    dcd5:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    dcd9:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    dcdd:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
    dce1:	8b 7d e0             	mov    -0x20(%ebp),%edi
    dce4:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    dce7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    dcea:	01 d2                	add    %edx,%edx
    dcec:	89 45 c8             	mov    %eax,-0x38(%ebp)
    dcef:	31 c0                	xor    %eax,%eax
					break;
				}				
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
    dcf1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dcf5:	0f 84 5e 01 00 00    	je     de59 <rlc_AM_segment+0x689>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dcfb:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    dcfd:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dcff:	0f 84 14 01 00 00    	je     de19 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=1;
    dd05:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    dd08:	83 e0 f3             	and    $0xfffffff3,%eax
    dd0b:	88 45 f3             	mov    %al,-0xd(%ebp)
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dd0e:	8b 03                	mov    (%ebx),%eax
				length = length + amBuffer->pkt->len;
    dd10:	0f b7 75 ec          	movzwl -0x14(%ebp),%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dd14:	0f b7 40 50          	movzwl 0x50(%eax),%eax
				length = length + amBuffer->pkt->len;
    dd18:	01 d6                	add    %edx,%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dd1a:	01 c6                	add    %eax,%esi
    dd1c:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    dd20:	0f b7 de             	movzwl %si,%ebx
				length = length + amBuffer->pkt->len;
				break;
    dd23:	e9 f6 fb ff ff       	jmp    d91e <rlc_AM_segment+0x14e>
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dd28:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    dd2c:	31 c9                	xor    %ecx,%ecx
    dd2e:	31 db                	xor    %ebx,%ebx
    dd30:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    dd37:	31 f6                	xor    %esi,%esi
    dd39:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dd40:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dd46:	0f b7 d0             	movzwl %ax,%edx
    dd49:	e9 d7 fb ff ff       	jmp    d925 <rlc_AM_segment+0x155>
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    dd4e:	0f b7 d6             	movzwl %si,%edx
    dd51:	e8 fc ff ff ff       	call   dd52 <rlc_AM_segment+0x582>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    dd56:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dd59:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    dd5d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    dd63:	89 f2                	mov    %esi,%edx
    dd65:	89 45 ec             	mov    %eax,-0x14(%ebp)
    dd68:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd6b:	e8 fc ff ff ff       	call   dd6c <rlc_AM_segment+0x59c>
    dd70:	8b 55 ec             	mov    -0x14(%ebp),%edx
    dd73:	89 f1                	mov    %esi,%ecx
    dd75:	e8 fc ff ff ff       	call   dd76 <rlc_AM_segment+0x5a6>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    dd7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dd7d:	ba 02 00 00 00       	mov    $0x2,%edx
    dd82:	e8 fc ff ff ff       	call   dd83 <rlc_AM_segment+0x5b3>
    dd87:	b9 02 00 00 00       	mov    $0x2,%ecx
    dd8c:	8d 55 f2             	lea    -0xe(%ebp),%edx
    dd8f:	e8 fc ff ff ff       	call   dd90 <rlc_AM_segment+0x5c0>
		
		if(lastCopyLen == tbuff->pkt->len)
    dd94:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dd97:	3b 70 50             	cmp    0x50(%eax),%esi
    dd9a:	0f 85 84 00 00 00    	jne    de24 <rlc_AM_segment+0x654>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    dda0:	8b 43 04             	mov    0x4(%ebx),%eax
    dda3:	8b 13                	mov    (%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dda5:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dda8:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ddaa:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
	entry->prev = LIST_POISON2;
    ddb0:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
		{
			list_del(&tbuff->list);
			amIns->amSduBufferNum--;
    ddb7:	83 6f 50 01          	subl   $0x1,0x50(%edi)
			amIns->amSduBufferSize -= tbuff->pkt->len;
    ddbb:	8b 43 f4             	mov    -0xc(%ebx),%eax
    ddbe:	8b 40 50             	mov    0x50(%eax),%eax
    ddc1:	29 47 4c             	sub    %eax,0x4c(%edi)
			if(tbuff->pkt != NULL)
    ddc4:	8b 43 f4             	mov    -0xc(%ebx),%eax
    ddc7:	85 c0                	test   %eax,%eax
    ddc9:	74 0c                	je     ddd7 <rlc_AM_segment+0x607>
			{
				fsm_pkt_destroy(tbuff->pkt);
    ddcb:	e8 fc ff ff ff       	call   ddcc <rlc_AM_segment+0x5fc>
				tbuff->pkt = NULL;
    ddd0:	c7 43 f4 00 00 00 00 	movl   $0x0,-0xc(%ebx)
			}
			if(tbuff != NULL)
    ddd7:	89 d8                	mov    %ebx,%eax
    ddd9:	83 e8 0c             	sub    $0xc,%eax
    dddc:	0f 85 f5 fc ff ff    	jne    dad7 <rlc_AM_segment+0x307>
    dde2:	e9 f5 fc ff ff       	jmp    dadc <rlc_AM_segment+0x30c>
						amBuffer = NULL;
					}				
				}
				else
				{
					fsm_skb_pull(amBuffer->pkt,lastCopyLen);
    dde7:	89 f2                	mov    %esi,%edx
    dde9:	e8 fc ff ff ff       	call   ddea <rlc_AM_segment+0x61a>
					amIns->amSduBufferSize -= lastCopyLen;
    ddee:	29 77 4c             	sub    %esi,0x4c(%edi)
					amBuffer->pktstatus = LAST_SEGMENT;
    ddf1:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    ddf8:	e9 83 fc ff ff       	jmp    da80 <rlc_AM_segment+0x2b0>
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    ddfd:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    ddff:	89 f0                	mov    %esi,%eax
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    de01:	75 37                	jne    de3a <rlc_AM_segment+0x66a>
						fixhead->FIsecond=1;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=1;
    de03:	83 c8 08             	or     $0x8,%eax
    de06:	88 45 f3             	mov    %al,-0xd(%ebp)
    de09:	e9 72 fe ff ff       	jmp    dc80 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    de0e:	83 e0 f7             	and    $0xfffffff7,%eax
    de11:	88 45 f3             	mov    %al,-0xd(%ebp)
    de14:	e9 67 fe ff ff       	jmp    dc80 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    de19:	83 e0 f7             	and    $0xfffffff7,%eax
    de1c:	88 45 f3             	mov    %al,-0xd(%ebp)
    de1f:	e9 ea fe ff ff       	jmp    dd0e <rlc_AM_segment+0x53e>
				tbuff = NULL;
			}		
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    de24:	89 f2                	mov    %esi,%edx
    de26:	e8 fc ff ff ff       	call   de27 <rlc_AM_segment+0x657>
			amIns->amSduBufferSize -= lastCopyLen;
    de2b:	29 77 4c             	sub    %esi,0x4c(%edi)
			tbuff->pktstatus = LAST_SEGMENT;
    de2e:	c7 43 f8 02 00 00 00 	movl   $0x2,-0x8(%ebx)
    de35:	e9 a2 fc ff ff       	jmp    dadc <rlc_AM_segment+0x30c>
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    de3a:	83 e0 eb             	and    $0xffffffeb,%eax
						fixhead->FIsecond=1;
    de3d:	83 c8 08             	or     $0x8,%eax
    de40:	88 45 f3             	mov    %al,-0xd(%ebp)
    de43:	e9 38 fe ff ff       	jmp    dc80 <rlc_AM_segment+0x4b0>
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    de48:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    de4a:	89 f0                	mov    %esi,%eax
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    de4c:	74 c0                	je     de0e <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    de4e:	83 e0 e3             	and    $0xffffffe3,%eax
    de51:	88 45 f3             	mov    %al,-0xd(%ebp)
    de54:	e9 27 fe ff ff       	jmp    dc80 <rlc_AM_segment+0x4b0>
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    de59:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    de5b:	89 f0                	mov    %esi,%eax
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    de5d:	74 ba                	je     de19 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    de5f:	83 e0 e3             	and    $0xffffffe3,%eax
    de62:	88 45 f3             	mov    %al,-0xd(%ebp)
    de65:	e9 a4 fe ff ff       	jmp    dd0e <rlc_AM_segment+0x53e>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    de6a:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    de71:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    de76:	b8 01 00 00 00       	mov    $0x1,%eax
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    de7b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    de82:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    de88:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    de8e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    de94:	e9 1d fe ff ff       	jmp    dcb6 <rlc_AM_segment+0x4e6>
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    de99:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dea0:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dea5:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    deaa:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    deb1:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    deb7:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    debd:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dec3:	e9 99 fd ff ff       	jmp    dc61 <rlc_AM_segment+0x491>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    dec8:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    decf:	b9 01 00 00 00       	mov    $0x1,%ecx
    ded4:	ba 02 00 00 00       	mov    $0x2,%edx
    ded9:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dee0:	b8 01 00 00 00       	mov    $0x1,%eax
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dee5:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    deeb:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    def1:	e9 fb fd ff ff       	jmp    dcf1 <rlc_AM_segment+0x521>
	fixhead->P=1;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
    def6:	c7 04 24 78 3a 00 00 	movl   $0x3a78,(%esp)
    defd:	e8 fc ff ff ff       	call   defe <rlc_AM_segment+0x72e>
		return NULL;
    df02:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    df09:	e9 a5 fc ff ff       	jmp    dbb3 <rlc_AM_segment+0x3e3>
    df0e:	66 90                	xchg   %ax,%ax

0000df10 <rlc_UM_segment>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    df10:	55                   	push   %ebp
    df11:	89 e5                	mov    %esp,%ebp
    df13:	57                   	push   %edi
    df14:	56                   	push   %esi
    df15:	53                   	push   %ebx
    df16:	83 ec 34             	sub    $0x34,%esp
    df19:	e8 fc ff ff ff       	call   df1a <rlc_UM_segment+0xa>
    df1e:	89 d3                	mov    %edx,%ebx
		u32 size;
		int num = umIns->umSduBufferNum;
    df20:	8b 50 24             	mov    0x24(%eax),%edx
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    df23:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		u32 size;
		int num = umIns->umSduBufferNum;
    df26:	89 55 e8             	mov    %edx,-0x18(%ebp)
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    df29:	0f b7 50 28          	movzwl 0x28(%eax),%edx
    df2d:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    df31:	c7 04 24 9c 07 00 00 	movl   $0x79c,(%esp)
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    df38:	66 81 e2 ff 03       	and    $0x3ff,%dx
    df3d:	66 25 00 fc          	and    $0xfc00,%ax
    df41:	09 d0                	or     %edx,%eax
    df43:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		fixhead->R11=0;
    df47:	66 c1 e8 08          	shr    $0x8,%ax
		fixhead->R12=0;
		fixhead->R13=0;
    df4b:	83 e0 1f             	and    $0x1f,%eax
    df4e:	88 45 f3             	mov    %al,-0xd(%ebp)
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    df51:	e8 fc ff ff ff       	call   df52 <rlc_UM_segment+0x42>
		if(sizeFromMac <= 2)
    df56:	83 fb 02             	cmp    $0x2,%ebx
    df59:	0f 86 7e 05 00 00    	jbe    e4dd <rlc_UM_segment+0x5cd>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    df5f:	8b 75 e4             	mov    -0x1c(%ebp),%esi

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
		u32 size;
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
    df62:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    df65:	8b 46 18             	mov    0x18(%esi),%eax
    df68:	83 c1 18             	add    $0x18,%ecx
    df6b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
    df6e:	39 c1                	cmp    %eax,%ecx
    df70:	0f 84 82 03 00 00    	je     e2f8 <rlc_UM_segment+0x3e8>
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
    df76:	8d 53 fe             	lea    -0x2(%ebx),%edx
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    df79:	8d 58 f0             	lea    -0x10(%eax),%ebx
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    df7c:	8b 40 f0             	mov    -0x10(%eax),%eax
    df7f:	8b 40 50             	mov    0x50(%eax),%eax
    df82:	39 c2                	cmp    %eax,%edx
    df84:	0f 82 11 05 00 00    	jb     e49b <rlc_UM_segment+0x58b>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    df8a:	0f 84 21 05 00 00    	je     e4b1 <rlc_UM_segment+0x5a1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    df90:	8d 48 02             	lea    0x2(%eax),%ecx
    df93:	39 ca                	cmp    %ecx,%edx
    df95:	0f 86 2c 05 00 00    	jbe    e4c7 <rlc_UM_segment+0x5b7>
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    df9b:	31 f6                	xor    %esi,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    df9d:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    dfa2:	b9 01 00 00 00       	mov    $0x1,%ecx
    dfa7:	66 89 75 e0          	mov    %si,-0x20(%ebp)
    dfab:	eb 4c                	jmp    dff9 <rlc_UM_segment+0xe9>
    dfad:	8d 76 00             	lea    0x0(%esi),%esi
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
						flag=false;
					}
					else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    dfb0:	84 c9                	test   %cl,%cl
    dfb2:	74 04                	je     dfb8 <rlc_UM_segment+0xa8>
					{
	
						fixhead->FIfirst=1;
						fixhead->E=1;
    dfb4:	80 4d f3 14          	orb    $0x14,-0xd(%ebp)
						flag=false;
					}
					if(num == 0)
    dfb8:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    dfbb:	74 63                	je     e020 <rlc_UM_segment+0x110>
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dfbd:	8b 4b 10             	mov    0x10(%ebx),%ecx
    dfc0:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
    dfc3:	8d 59 f0             	lea    -0x10(%ecx),%ebx
    dfc6:	0f 84 b4 02 00 00    	je     e280 <rlc_UM_segment+0x370>
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dfcc:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dfd1:	83 c7 01             	add    $0x1,%edi
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dfd4:	29 c6                	sub    %eax,%esi
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dfd6:	8b 41 f0             	mov    -0x10(%ecx),%eax
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dfd9:	01 f2                	add    %esi,%edx
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dfdb:	8b 40 50             	mov    0x50(%eax),%eax
    dfde:	39 d0                	cmp    %edx,%eax
    dfe0:	0f 87 aa 02 00 00    	ja     e290 <rlc_UM_segment+0x380>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    dfe6:	0f 84 dc 02 00 00    	je     e2c8 <rlc_UM_segment+0x3b8>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dfec:	8d 48 02             	lea    0x2(%eax),%ecx
    dfef:	39 d1                	cmp    %edx,%ecx
    dff1:	0f 83 19 03 00 00    	jae    e310 <rlc_UM_segment+0x400>
    dff7:	31 c9                	xor    %ecx,%ecx
				{
	
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
    dff9:	66 01 45 e0          	add    %ax,-0x20(%ebp)
					if(umBuffer->pktstatus==FULL_SDU &&flag)
    dffd:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e001:	75 ad                	jne    dfb0 <rlc_UM_segment+0xa0>
    e003:	84 c9                	test   %cl,%cl
    e005:	74 b1                	je     dfb8 <rlc_UM_segment+0xa8>
					{	
						fixhead->FIfirst=0;
    e007:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    e00b:	83 e1 ef             	and    $0xffffffef,%ecx
						fixhead->E=1;
    e00e:	83 c9 04             	or     $0x4,%ecx
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    e011:	39 7d e8             	cmp    %edi,-0x18(%ebp)
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
					if(umBuffer->pktstatus==FULL_SDU &&flag)
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
    e014:	88 4d f3             	mov    %cl,-0xd(%ebp)
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    e017:	75 a4                	jne    dfbd <rlc_UM_segment+0xad>
    e019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    e020:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    e024:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    e027:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    e02b:	89 d0                	mov    %edx,%eax
    e02d:	83 e0 fb             	and    $0xfffffffb,%eax
    e030:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
						fixhead->FIsecond=0;
						lastCopyLen = umBuffer->pkt->len;
    e034:	8d 34 7e             	lea    (%esi,%edi,2),%esi
						flag=false;
					}
					if(num == 0)
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    e037:	0f 45 c2             	cmovne %edx,%eax
						fixhead->FIsecond=0;
    e03a:	83 e0 f7             	and    $0xfffffff7,%eax
    e03d:	88 45 f3             	mov    %al,-0xd(%ebp)
						lastCopyLen = umBuffer->pkt->len;
    e040:	8b 03                	mov    (%ebx),%eax
    e042:	0f b7 de             	movzwl %si,%ebx
    e045:	8b 40 50             	mov    0x50(%eax),%eax
    e048:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e04b:	90                   	nop
    e04c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e050:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    e054:	0f b7 d0             	movzwl %ax,%edx
    e057:	c1 e2 08             	shl    $0x8,%edx
    e05a:	66 c1 e8 08          	shr    $0x8,%ax
    e05e:	09 d0                	or     %edx,%eax
		fsm_octets_print(fixhead,2);
    e060:	ba 02 00 00 00       	mov    $0x2,%edx
    e065:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    e069:	8d 45 f2             	lea    -0xe(%ebp),%eax
    e06c:	e8 fc ff ff ff       	call   e06d <rlc_UM_segment+0x15d>
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    e071:	89 d8                	mov    %ebx,%eax
    e073:	e8 fc ff ff ff       	call   e074 <rlc_UM_segment+0x164>
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    e078:	83 ff 01             	cmp    $0x1,%edi
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    e07b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		pos = head->next;
    e07e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e081:	8b 58 18             	mov    0x18(%eax),%ebx
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    e084:	0f 84 c2 02 00 00    	je     e34c <rlc_UM_segment+0x43c>
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
				umIns->umSduBufferSize -= lastCopyLen;
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
    e08a:	0f 8e 59 01 00 00    	jle    e1e9 <rlc_UM_segment+0x2d9>
		{
			fsm_skb_reserve(skb,2*count);
    e090:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e093:	8d 14 3f             	lea    (%edi,%edi,1),%edx
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e096:	8d 77 ff             	lea    -0x1(%edi),%esi
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
    e099:	e8 fc ff ff ff       	call   e09a <rlc_UM_segment+0x18a>
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e09e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    e0a1:	01 f6                	add    %esi,%esi
    e0a3:	89 f0                	mov    %esi,%eax
    e0a5:	89 75 cc             	mov    %esi,-0x34(%ebp)
    e0a8:	e8 fc ff ff ff       	call   e0a9 <rlc_UM_segment+0x199>
    e0ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e0b0:	89 f0                	mov    %esi,%eax
    e0b2:	e8 fc ff ff ff       	call   e0b3 <rlc_UM_segment+0x1a3>
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e0b7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e0ba:	89 45 d8             	mov    %eax,-0x28(%ebp)
			int i = 0;
			unsigned char *des = skb->data;
    e0bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e0c0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e0c6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e0c9:	8b 42 18             	mov    0x18(%edx),%eax
    e0cc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    e0cf:	8b 30                	mov    (%eax),%esi
    e0d1:	8d 58 f0             	lea    -0x10(%eax),%ebx
    e0d4:	0f 84 c5 00 00 00    	je     e19f <rlc_UM_segment+0x28f>
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
    e0da:	31 c0                	xor    %eax,%eax
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e0dc:	83 ee 10             	sub    $0x10,%esi
    e0df:	89 7d c8             	mov    %edi,-0x38(%ebp)
    e0e2:	89 c7                	mov    %eax,%edi
    e0e4:	eb 1e                	jmp    e104 <rlc_UM_segment+0x1f4>
    e0e6:	66 90                	xchg   %ax,%ax
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
    e0e8:	0f 84 42 01 00 00    	je     e230 <rlc_UM_segment+0x320>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e0ee:	8b 46 10             	mov    0x10(%esi),%eax
    e0f1:	8d 56 10             	lea    0x10(%esi),%edx
    e0f4:	83 e8 10             	sub    $0x10,%eax
    e0f7:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    e0fa:	0f 84 9c 00 00 00    	je     e19c <rlc_UM_segment+0x28c>
    e100:	89 f3                	mov    %esi,%ebx
    e102:	89 c6                	mov    %eax,%esi
			{
				if(i<count-1)
    e104:	3b 7d e8             	cmp    -0x18(%ebp),%edi
    e107:	7d df                	jge    e0e8 <rlc_UM_segment+0x1d8>
				{
					*(LI+i) = umBuffer->pkt->len;
    e109:	8b 03                	mov    (%ebx),%eax
    e10b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
					*(headExt+i) = 0x8000|(*(LI+i));
    e10e:	8b 55 d8             	mov    -0x28(%ebp),%edx
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
    e111:	8b 40 50             	mov    0x50(%eax),%eax
    e114:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
					*(headExt+i) = 0x8000|(*(LI+i));
    e118:	66 0d 00 80          	or     $0x8000,%ax
    e11c:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
					fsm_skb_put(skb,umBuffer->pkt->len);
    e120:	8b 03                	mov    (%ebx),%eax
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
    e122:	83 c7 01             	add    $0x1,%edi
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
    e125:	8b 50 50             	mov    0x50(%eax),%edx
    e128:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e12b:	e8 fc ff ff ff       	call   e12c <rlc_UM_segment+0x21c>
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e130:	8b 03                	mov    (%ebx),%eax
    e132:	8b 48 50             	mov    0x50(%eax),%ecx
    e135:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e13b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e13e:	e8 fc ff ff ff       	call   e13f <rlc_UM_segment+0x22f>
					des = des + umBuffer->pkt->len ;
    e143:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e145:	8b 53 10             	mov    0x10(%ebx),%edx
    e148:	8b 48 50             	mov    0x50(%eax),%ecx
    e14b:	8b 43 14             	mov    0x14(%ebx),%eax
    e14e:	01 4d e0             	add    %ecx,-0x20(%ebp)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e151:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e154:	89 10                	mov    %edx,(%eax)
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e156:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e159:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    e160:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e163:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e16a:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    e16e:	8b 03                	mov    (%ebx),%eax
    e170:	8b 40 50             	mov    0x50(%eax),%eax
    e173:	29 42 20             	sub    %eax,0x20(%edx)
					fsm_pkt_destroy(umBuffer->pkt);
    e176:	8b 03                	mov    (%ebx),%eax
    e178:	e8 fc ff ff ff       	call   e179 <rlc_UM_segment+0x269>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    e17d:	89 d8                	mov    %ebx,%eax
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    e17f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer);
    e185:	e8 fc ff ff ff       	call   e186 <rlc_UM_segment+0x276>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e18a:	8b 46 10             	mov    0x10(%esi),%eax
    e18d:	8d 56 10             	lea    0x10(%esi),%edx
    e190:	83 e8 10             	sub    $0x10,%eax
    e193:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    e196:	0f 85 64 ff ff ff    	jne    e100 <rlc_UM_segment+0x1f0>
    e19c:	8b 7d c8             	mov    -0x38(%ebp),%edi
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e19f:	8b 45 d8             	mov    -0x28(%ebp),%eax
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e1a2:	8b 55 cc             	mov    -0x34(%ebp),%edx
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e1a5:	66 81 64 78 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%edi,2)
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e1ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e1af:	e8 fc ff ff ff       	call   e1b0 <rlc_UM_segment+0x2a0>
    e1b4:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    e1b7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e1ba:	e8 fc ff ff ff       	call   e1bb <rlc_UM_segment+0x2ab>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e1bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e1c2:	ba 02 00 00 00       	mov    $0x2,%edx
    e1c7:	e8 fc ff ff ff       	call   e1c8 <rlc_UM_segment+0x2b8>
    e1cc:	b9 02 00 00 00       	mov    $0x2,%ecx
    e1d1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e1d4:	e8 fc ff ff ff       	call   e1d5 <rlc_UM_segment+0x2c5>
			fsm_mem_free(LI);
    e1d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e1dc:	e8 fc ff ff ff       	call   e1dd <rlc_UM_segment+0x2cd>
			fsm_mem_free(headExt);
    e1e1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e1e4:	e8 fc ff ff ff       	call   e1e5 <rlc_UM_segment+0x2d5>
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    e1e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		umIns->SN %= 1024;
    e1ec:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
			fsm_mem_free(headExt);
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    e1ef:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e1f3:	83 c0 01             	add    $0x1,%eax
		umIns->SN %= 1024;
    e1f6:	89 c2                	mov    %eax,%edx
    e1f8:	66 c1 fa 0f          	sar    $0xf,%dx
    e1fc:	66 c1 ea 06          	shr    $0x6,%dx
    e200:	01 d0                	add    %edx,%eax
    e202:	66 25 ff 03          	and    $0x3ff,%ax
    e206:	66 29 d0             	sub    %dx,%ax
    e209:	66 89 41 28          	mov    %ax,0x28(%ecx)
		fsm_printf("[RLC][rlc_UM_segment] SN = %d\n",umIns->SN);
    e20d:	98                   	cwtl   
    e20e:	89 44 24 04          	mov    %eax,0x4(%esp)
    e212:	c7 04 24 e0 3a 00 00 	movl   $0x3ae0,(%esp)
    e219:	e8 fc ff ff ff       	call   e21a <rlc_UM_segment+0x30a>
		return skb;

}
    e21e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e221:	83 c4 34             	add    $0x34,%esp
    e224:	5b                   	pop    %ebx
    e225:	5e                   	pop    %esi
    e226:	5f                   	pop    %edi
    e227:	5d                   	pop    %ebp
    e228:	c3                   	ret    
    e229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
				{
					fsm_skb_put(skb,lastCopyLen);
    e230:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e233:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e236:	8b 7d c8             	mov    -0x38(%ebp),%edi
    e239:	e8 fc ff ff ff       	call   e23a <rlc_UM_segment+0x32a>
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e23e:	8b 03                	mov    (%ebx),%eax
    e240:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e243:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e249:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e24c:	e8 fc ff ff ff       	call   e24d <rlc_UM_segment+0x33d>
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e251:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e254:	8b 03                	mov    (%ebx),%eax
    e256:	e8 fc ff ff ff       	call   e257 <rlc_UM_segment+0x347>
					if(umBuffer->pkt->len == lastCopyLen)
    e25b:	8b 03                	mov    (%ebx),%eax
    e25d:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e260:	39 70 50             	cmp    %esi,0x50(%eax)
    e263:	0f 84 ee 01 00 00    	je     e457 <rlc_UM_segment+0x547>
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
						umIns->umSduBufferSize -= lastCopyLen;
    e269:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e26c:	8b 75 d0             	mov    -0x30(%ebp),%esi
						fsm_mem_free(umBuffer);
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
    e26f:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
						umIns->umSduBufferSize -= lastCopyLen;
    e276:	29 70 20             	sub    %esi,0x20(%eax)
    e279:	e9 21 ff ff ff       	jmp    e19f <rlc_UM_segment+0x28f>
    e27e:	66 90                	xchg   %ax,%ax
    e280:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    e284:	8d 34 7e             	lea    (%esi,%edi,2),%esi
    e287:	0f b7 de             	movzwl %si,%ebx
    e28a:	e9 c1 fd ff ff       	jmp    e050 <rlc_UM_segment+0x140>
    e28f:	90                   	nop
    e290:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e294:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e297:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e299:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e29d:	0f 84 3e 01 00 00    	je     e3e1 <rlc_UM_segment+0x4d1>
							fixhead->FIsecond=1;
						}
					}
					else
					{
						if(flag)
    e2a3:	84 c0                	test   %al,%al
    e2a5:	0f 84 0d 01 00 00    	je     e3b8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=1;
    e2ab:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e2af:	83 e0 e3             	and    $0xffffffe3,%eax
							fixhead->FIsecond=1;
    e2b2:	83 c8 18             	or     $0x18,%eax
    e2b5:	88 45 f3             	mov    %al,-0xd(%ebp)
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = size;
					length += size;
    e2b8:	01 ce                	add    %ecx,%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e2ba:	01 d6                	add    %edx,%esi
    e2bc:	0f b7 de             	movzwl %si,%ebx
						}
					}
					lastCopyLen = size;
					length += size;
					break;
    e2bf:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e2c2:	e9 89 fd ff ff       	jmp    e050 <rlc_UM_segment+0x140>
    e2c7:	90                   	nop
    e2c8:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e2cc:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e2cf:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e2d1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e2d5:	0f 84 1c 01 00 00    	je     e3f7 <rlc_UM_segment+0x4e7>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e2db:	84 c0                	test   %al,%al
    e2dd:	0f 84 e5 00 00 00    	je     e3c8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=1;
    e2e3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e2e7:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e2ea:	83 e0 f3             	and    $0xfffffff3,%eax
    e2ed:	88 45 f3             	mov    %al,-0xd(%ebp)
    e2f0:	eb c6                	jmp    e2b8 <rlc_UM_segment+0x3a8>
    e2f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e2f8:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    e2fc:	31 db                	xor    %ebx,%ebx
    e2fe:	31 f6                	xor    %esi,%esi
		fixhead->SN=umIns->SN;
		fixhead->R11=0;
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
    e300:	31 ff                	xor    %edi,%edi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e302:	0f b7 d0             	movzwl %ax,%edx
    e305:	e9 4d fd ff ff       	jmp    e057 <rlc_UM_segment+0x147>
    e30a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e310:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e314:	8d 14 3f             	lea    (%edi,%edi,1),%edx
    e317:	31 c0                	xor    %eax,%eax
						break;
					}
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e319:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e31d:	0f 84 e1 00 00 00    	je     e404 <rlc_UM_segment+0x4f4>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e323:	84 c0                	test   %al,%al
    e325:	0f 84 ad 00 00 00    	je     e3d8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=1;
    e32b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e32f:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e332:	83 e0 f3             	and    $0xfffffff3,%eax
    e335:	88 45 f3             	mov    %al,-0xd(%ebp)
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e338:	8b 03                	mov    (%ebx),%eax
					length += umBuffer->pkt->len;
    e33a:	01 d6                	add    %edx,%esi
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e33c:	8b 40 50             	mov    0x50(%eax),%eax
    e33f:	01 c6                	add    %eax,%esi
    e341:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e344:	0f b7 de             	movzwl %si,%ebx
					length += umBuffer->pkt->len;
					break;
    e347:	e9 04 fd ff ff       	jmp    e050 <rlc_UM_segment+0x140>
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
		{
			fsm_skb_reserve(skb,length);
    e34c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e34f:	0f b7 d6             	movzwl %si,%edx
    e352:	e8 fc ff ff ff       	call   e353 <rlc_UM_segment+0x443>
			fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e357:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e35a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e35d:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e363:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e366:	e8 fc ff ff ff       	call   e367 <rlc_UM_segment+0x457>
    e36b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e36e:	89 f2                	mov    %esi,%edx
    e370:	e8 fc ff ff ff       	call   e371 <rlc_UM_segment+0x461>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e375:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e378:	ba 02 00 00 00       	mov    $0x2,%edx
    e37d:	e8 fc ff ff ff       	call   e37e <rlc_UM_segment+0x46e>
    e382:	b9 02 00 00 00       	mov    $0x2,%ecx
    e387:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e38a:	e8 fc ff ff ff       	call   e38b <rlc_UM_segment+0x47b>
			
			if(lastCopyLen == tbuff->pkt->len)
    e38f:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e392:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e395:	39 70 50             	cmp    %esi,0x50(%eax)
    e398:	74 77                	je     e411 <rlc_UM_segment+0x501>
				fsm_mem_free(tbuff);
				tbuff = NULL;
			}
			else
			{
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e39a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e39d:	e8 fc ff ff ff       	call   e39e <rlc_UM_segment+0x48e>
				umIns->umSduBufferSize -= lastCopyLen;
    e3a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e3a5:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e3a8:	29 70 20             	sub    %esi,0x20(%eax)
				tbuff->pktstatus = LAST_SEGMENT;
    e3ab:	c7 43 f4 02 00 00 00 	movl   $0x2,-0xc(%ebx)
    e3b2:	e9 32 fe ff ff       	jmp    e1e9 <rlc_UM_segment+0x2d9>
    e3b7:	90                   	nop
							fixhead->FIsecond=1;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=1;
    e3b8:	80 4d f3 08          	orb    $0x8,-0xd(%ebp)
    e3bc:	e9 f7 fe ff ff       	jmp    e2b8 <rlc_UM_segment+0x3a8>
    e3c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e3c8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e3cc:	e9 e7 fe ff ff       	jmp    e2b8 <rlc_UM_segment+0x3a8>
    e3d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e3d8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e3dc:	e9 57 ff ff ff       	jmp    e338 <rlc_UM_segment+0x428>
				num--;
				if(size < umBuffer->pkt->len)
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e3e1:	84 c0                	test   %al,%al
    e3e3:	74 d3                	je     e3b8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=0;
    e3e5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e3e9:	83 e0 eb             	and    $0xffffffeb,%eax
							fixhead->FIsecond=1;
    e3ec:	83 c8 08             	or     $0x8,%eax
    e3ef:	88 45 f3             	mov    %al,-0xd(%ebp)
    e3f2:	e9 c1 fe ff ff       	jmp    e2b8 <rlc_UM_segment+0x3a8>
				}
				else if(size == umBuffer->pkt->len) 
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e3f7:	84 c0                	test   %al,%al
    e3f9:	74 cd                	je     e3c8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e3fb:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e3ff:	e9 b4 fe ff ff       	jmp    e2b8 <rlc_UM_segment+0x3a8>
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e404:	84 c0                	test   %al,%al
    e406:	74 d0                	je     e3d8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e408:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e40c:	e9 27 ff ff ff       	jmp    e338 <rlc_UM_segment+0x428>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e411:	8b 13                	mov    (%ebx),%edx
    e413:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e416:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e419:	89 10                	mov    %edx,(%eax)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e41b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e41e:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e424:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e427:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e42e:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e432:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e435:	8b 40 50             	mov    0x50(%eax),%eax
    e438:	29 42 20             	sub    %eax,0x20(%edx)
				fsm_pkt_destroy(tbuff->pkt);
    e43b:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e43e:	e8 fc ff ff ff       	call   e43f <rlc_UM_segment+0x52f>
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
    e443:	8d 43 f0             	lea    -0x10(%ebx),%eax
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(tbuff->pkt);
				tbuff->pkt = NULL;
    e446:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
				fsm_mem_free(tbuff);
    e44d:	e8 fc ff ff ff       	call   e44e <rlc_UM_segment+0x53e>
    e452:	e9 92 fd ff ff       	jmp    e1e9 <rlc_UM_segment+0x2d9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e457:	8b 53 10             	mov    0x10(%ebx),%edx
    e45a:	8b 43 14             	mov    0x14(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e45d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e460:	89 10                	mov    %edx,(%eax)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e462:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e465:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e46c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e46f:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e476:	83 68 24 01          	subl   $0x1,0x24(%eax)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e47a:	8b 03                	mov    (%ebx),%eax
    e47c:	8b 40 50             	mov    0x50(%eax),%eax
    e47f:	29 42 20             	sub    %eax,0x20(%edx)
						fsm_pkt_destroy(umBuffer->pkt);
    e482:	8b 03                	mov    (%ebx),%eax
    e484:	e8 fc ff ff ff       	call   e485 <rlc_UM_segment+0x575>
						umBuffer->pkt = NULL;
						fsm_mem_free(umBuffer);
    e489:	89 d8                	mov    %ebx,%eax
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
						umIns->umSduBufferSize -= umBuffer->pkt->len;
						fsm_pkt_destroy(umBuffer->pkt);
						umBuffer->pkt = NULL;
    e48b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(umBuffer);
    e491:	e8 fc ff ff ff       	call   e492 <rlc_UM_segment+0x582>
    e496:	e9 04 fd ff ff       	jmp    e19f <rlc_UM_segment+0x28f>
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e49b:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e4a0:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e4a5:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e4aa:	31 f6                	xor    %esi,%esi
    e4ac:	e9 e8 fd ff ff       	jmp    e299 <rlc_UM_segment+0x389>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e4b1:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e4b6:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e4bb:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e4c0:	31 f6                	xor    %esi,%esi
    e4c2:	e9 0a fe ff ff       	jmp    e2d1 <rlc_UM_segment+0x3c1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e4c7:	ba 02 00 00 00       	mov    $0x2,%edx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e4cc:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e4d1:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e4d6:	31 f6                	xor    %esi,%esi
    e4d8:	e9 3c fe ff ff       	jmp    e319 <rlc_UM_segment+0x409>
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
    e4dd:	c7 04 24 bc 3a 00 00 	movl   $0x3abc,(%esp)
    e4e4:	e8 fc ff ff ff       	call   e4e5 <rlc_UM_segment+0x5d5>
			return NULL;
    e4e9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    e4f0:	e9 29 fd ff ff       	jmp    e21e <rlc_UM_segment+0x30e>
    e4f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e4f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000e500 <rlc_UM5_segment>:
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e500:	55                   	push   %ebp
    e501:	89 e5                	mov    %esp,%ebp
    e503:	57                   	push   %edi
    e504:	56                   	push   %esi
    e505:	53                   	push   %ebx
    e506:	83 ec 38             	sub    $0x38,%esp
    e509:	e8 fc ff ff ff       	call   e50a <rlc_UM5_segment+0xa>
	u32 size;
	int num = umIns->umSduBufferNum;
    e50e:	8b 78 24             	mov    0x24(%eax),%edi
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e511:	89 d3                	mov    %edx,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e513:	0f b7 50 28          	movzwl 0x28(%eax),%edx
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e517:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e51a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e51e:	83 e2 1f             	and    $0x1f,%edx
    e521:	83 e0 e0             	and    $0xffffffe0,%eax
    e524:	09 d0                	or     %edx,%eax
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e526:	83 fb 01             	cmp    $0x1,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e529:	88 45 f3             	mov    %al,-0xd(%ebp)
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e52c:	0f 86 9f 05 00 00    	jbe    ead1 <rlc_UM5_segment+0x5d1>
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e532:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e535:	c7 04 24 24 3b 00 00 	movl   $0x3b24,(%esp)
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e53c:	83 c0 18             	add    $0x18,%eax
    e53f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e542:	e8 fc ff ff ff       	call   e543 <rlc_UM5_segment+0x43>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    e547:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e54a:	8b 42 18             	mov    0x18(%edx),%eax
	if(!list_empty(head))
    e54d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e550:	0f 84 72 03 00 00    	je     e8c8 <rlc_UM5_segment+0x3c8>
	{
		list_for_each_entry(umBuffer,head,list)
    e556:	8d 70 f0             	lea    -0x10(%eax),%esi
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e559:	8b 40 f0             	mov    -0x10(%eax),%eax
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
    e55c:	8d 53 ff             	lea    -0x1(%ebx),%edx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e55f:	8b 40 50             	mov    0x50(%eax),%eax
    e562:	39 c2                	cmp    %eax,%edx
    e564:	0f 82 22 05 00 00    	jb     ea8c <rlc_UM5_segment+0x58c>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e56a:	0f 84 33 05 00 00    	je     eaa3 <rlc_UM5_segment+0x5a3>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e570:	8d 48 02             	lea    0x2(%eax),%ecx
    e573:	39 ca                	cmp    %ecx,%edx
    e575:	0f 86 3f 05 00 00    	jbe    eaba <rlc_UM5_segment+0x5ba>

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e57b:	31 db                	xor    %ebx,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e57d:	83 ef 01             	sub    $0x1,%edi
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e580:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e586:	b9 01 00 00 00       	mov    $0x1,%ecx
    e58b:	66 89 5d e0          	mov    %bx,-0x20(%ebp)
    e58f:	eb 54                	jmp    e5e5 <rlc_UM5_segment+0xe5>
    e591:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    e598:	84 c9                	test   %cl,%cl
    e59a:	74 04                	je     e5a0 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=1;
					fixhead->E=1;
    e59c:	80 4d f3 a0          	orb    $0xa0,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    e5a0:	85 ff                	test   %edi,%edi
    e5a2:	74 64                	je     e608 <rlc_UM5_segment+0x108>
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e5a4:	8b 4e 10             	mov    0x10(%esi),%ecx
    e5a7:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    e5aa:	8d 71 f0             	lea    -0x10(%ecx),%esi
    e5ad:	0f 84 95 02 00 00    	je     e848 <rlc_UM5_segment+0x348>
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e5b3:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e5b8:	83 ef 01             	sub    $0x1,%edi
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e5bb:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e5bd:	8b 41 f0             	mov    -0x10(%ecx),%eax
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e5c0:	01 da                	add    %ebx,%edx
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e5c2:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
			num--;
			if(size < umBuffer->pkt->len)
    e5c7:	8b 40 50             	mov    0x50(%eax),%eax
    e5ca:	39 d0                	cmp    %edx,%eax
    e5cc:	0f 87 86 02 00 00    	ja     e858 <rlc_UM5_segment+0x358>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e5d2:	0f 84 c0 02 00 00    	je     e898 <rlc_UM5_segment+0x398>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e5d8:	8d 48 02             	lea    0x2(%eax),%ecx
    e5db:	39 d1                	cmp    %edx,%ecx
    e5dd:	0f 83 05 03 00 00    	jae    e8e8 <rlc_UM5_segment+0x3e8>
    e5e3:	31 c9                	xor    %ecx,%ecx
			{

				size = size - umBuffer->pkt->len - 2;
				length += umBuffer->pkt->len;
    e5e5:	66 01 45 e0          	add    %ax,-0x20(%ebp)
				if(umBuffer->pktstatus==FULL_SDU &&flag)
    e5e9:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e5ed:	75 a9                	jne    e598 <rlc_UM5_segment+0x98>
    e5ef:	84 c9                	test   %cl,%cl
    e5f1:	74 ad                	je     e5a0 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=0;
    e5f3:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    e5f7:	83 e1 7f             	and    $0x7f,%ecx
					fixhead->E=1;
    e5fa:	83 c9 20             	or     $0x20,%ecx

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e5fd:	85 ff                	test   %edi,%edi
				length += umBuffer->pkt->len;
				if(umBuffer->pktstatus==FULL_SDU &&flag)
				{

					fixhead->FIfirst=0;
					fixhead->E=1;
    e5ff:	88 4d f3             	mov    %cl,-0xd(%ebp)

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e602:	75 a0                	jne    e5a4 <rlc_UM5_segment+0xa4>
    e604:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e608:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e60c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e60f:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e613:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
					flag=false;
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e617:	89 d0                	mov    %edx,%eax
    e619:	83 e0 df             	and    $0xffffffdf,%eax
    e61c:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
    e620:	0f 45 c2             	cmovne %edx,%eax
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e623:	01 ff                	add    %edi,%edi
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
					fixhead->FIsecond=0;
    e625:	83 e0 bf             	and    $0xffffffbf,%eax
    e628:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=umBuffer->pkt->len;
    e62b:	8b 06                	mov    (%esi),%eax
    e62d:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e631:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
    e635:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e638:	ba 02 00 00 00       	mov    $0x2,%edx
    e63d:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e640:	e8 fc ff ff ff       	call   e641 <rlc_UM5_segment+0x141>
	length = length + (2*count-1);
    e645:	8d 5c 3b ff          	lea    -0x1(%ebx,%edi,1),%ebx
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e649:	0f b7 db             	movzwl %bx,%ebx
    e64c:	89 d8                	mov    %ebx,%eax
    e64e:	e8 fc ff ff ff       	call   e64f <rlc_UM5_segment+0x14f>
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e653:	66 83 7d ec 01       	cmpw   $0x1,-0x14(%ebp)
	}
	
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e658:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pos = head->next;
    e65b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e65e:	8b 40 18             	mov    0x18(%eax),%eax
    e661:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e664:	0f 84 be 02 00 00    	je     e928 <rlc_UM5_segment+0x428>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			tbuff->pktstatus = LAST_SEGMENT;
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
    e66a:	0f 86 4d 01 00 00    	jbe    e7bd <rlc_UM5_segment+0x2bd>
	{
		fsm_skb_reserve(skb,(2*count-1));
    e670:	0f b7 5d ec          	movzwl -0x14(%ebp),%ebx
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
    e674:	31 ff                	xor    %edi,%edi
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e676:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e679:	8d 54 1b ff          	lea    -0x1(%ebx,%ebx,1),%edx
    e67d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e680:	83 eb 01             	sub    $0x1,%ebx
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e683:	e8 fc ff ff ff       	call   e684 <rlc_UM5_segment+0x184>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e688:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    e68b:	01 db                	add    %ebx,%ebx
    e68d:	89 d8                	mov    %ebx,%eax
    e68f:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    e692:	e8 fc ff ff ff       	call   e693 <rlc_UM5_segment+0x193>
    e697:	89 45 c8             	mov    %eax,-0x38(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e69a:	89 d8                	mov    %ebx,%eax
    e69c:	e8 fc ff ff ff       	call   e69d <rlc_UM5_segment+0x19d>
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e6a1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e6a4:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int i = 0;
		unsigned char *des = skb->data;
    e6a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6aa:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e6b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e6b3:	8b 42 18             	mov    0x18(%edx),%eax
    e6b6:	8b 30                	mov    (%eax),%esi
    e6b8:	8d 58 f0             	lea    -0x10(%eax),%ebx
    e6bb:	83 ee 10             	sub    $0x10,%esi
    e6be:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e6c1:	75 21                	jne    e6e4 <rlc_UM5_segment+0x1e4>
    e6c3:	e9 b8 00 00 00       	jmp    e780 <rlc_UM5_segment+0x280>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
    e6c8:	0f 84 32 01 00 00    	je     e800 <rlc_UM5_segment+0x300>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e6ce:	8b 46 10             	mov    0x10(%esi),%eax
    e6d1:	8d 56 10             	lea    0x10(%esi),%edx
    e6d4:	83 e8 10             	sub    $0x10,%eax
    e6d7:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e6da:	0f 84 a0 00 00 00    	je     e780 <rlc_UM5_segment+0x280>
    e6e0:	89 f3                	mov    %esi,%ebx
    e6e2:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    e6e4:	3b 7d ec             	cmp    -0x14(%ebp),%edi
    e6e7:	7d df                	jge    e6c8 <rlc_UM5_segment+0x1c8>
			{
				*(LI+i) = umBuffer->pkt->len;
    e6e9:	8b 03                	mov    (%ebx),%eax
    e6eb:	8b 4d c8             	mov    -0x38(%ebp),%ecx
				*(headExt+i) = 0x80|(*(LI+i));
    e6ee:	8b 55 d8             	mov    -0x28(%ebp),%edx
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
    e6f1:	8b 40 50             	mov    0x50(%eax),%eax
    e6f4:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
				*(headExt+i) = 0x80|(*(LI+i));
    e6f8:	0c 80                	or     $0x80,%al
    e6fa:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
				fsm_skb_put(skb,umBuffer->pkt->len);
    e6fe:	8b 03                	mov    (%ebx),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
    e700:	83 c7 01             	add    $0x1,%edi
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
    e703:	8b 50 50             	mov    0x50(%eax),%edx
    e706:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e709:	e8 fc ff ff ff       	call   e70a <rlc_UM5_segment+0x20a>
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e70e:	8b 03                	mov    (%ebx),%eax
    e710:	8b 48 50             	mov    0x50(%eax),%ecx
    e713:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e719:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e71c:	e8 fc ff ff ff       	call   e71d <rlc_UM5_segment+0x21d>
				des = des + umBuffer->pkt->len ;
    e721:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e723:	8b 53 10             	mov    0x10(%ebx),%edx
    e726:	8b 48 50             	mov    0x50(%eax),%ecx
    e729:	8b 43 14             	mov    0x14(%ebx),%eax
    e72c:	01 4d dc             	add    %ecx,-0x24(%ebp)
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e72f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e732:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e735:	89 10                	mov    %edx,(%eax)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e737:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e73a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e73d:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e744:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e74b:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e74f:	8b 42 f0             	mov    -0x10(%edx),%eax
    e752:	8b 40 50             	mov    0x50(%eax),%eax
    e755:	29 41 20             	sub    %eax,0x20(%ecx)
				fsm_pkt_destroy(umBuffer->pkt);
    e758:	8b 03                	mov    (%ebx),%eax
    e75a:	e8 fc ff ff ff       	call   e75b <rlc_UM5_segment+0x25b>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    e75f:	89 d8                	mov    %ebx,%eax
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    e761:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    e767:	e8 fc ff ff ff       	call   e768 <rlc_UM5_segment+0x268>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e76c:	8b 46 10             	mov    0x10(%esi),%eax
    e76f:	8d 56 10             	lea    0x10(%esi),%edx
    e772:	83 e8 10             	sub    $0x10,%eax
    e775:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e778:	0f 85 62 ff ff ff    	jne    e6e0 <rlc_UM5_segment+0x1e0>
    e77e:	66 90                	xchg   %ax,%ax
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e780:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e783:	8b 5d cc             	mov    -0x34(%ebp),%ebx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e786:	8b 55 d0             	mov    -0x30(%ebp),%edx
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e789:	66 81 64 58 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%ebx,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e790:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e793:	e8 fc ff ff ff       	call   e794 <rlc_UM5_segment+0x294>
    e798:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e79b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e79e:	e8 fc ff ff ff       	call   e79f <rlc_UM5_segment+0x29f>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e7a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e7a6:	ba 01 00 00 00       	mov    $0x1,%edx
    e7ab:	e8 fc ff ff ff       	call   e7ac <rlc_UM5_segment+0x2ac>
    e7b0:	b9 01 00 00 00       	mov    $0x1,%ecx
    e7b5:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e7b8:	e8 fc ff ff ff       	call   e7b9 <rlc_UM5_segment+0x2b9>
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e7bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	umIns->SN %= 32;
    e7c0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e7c3:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e7c7:	83 c0 01             	add    $0x1,%eax
	umIns->SN %= 32;
    e7ca:	89 c2                	mov    %eax,%edx
    e7cc:	66 c1 fa 0f          	sar    $0xf,%dx
    e7d0:	66 c1 ea 0b          	shr    $0xb,%dx
    e7d4:	01 d0                	add    %edx,%eax
    e7d6:	83 e0 1f             	and    $0x1f,%eax
    e7d9:	66 29 d0             	sub    %dx,%ax
    e7dc:	66 89 41 28          	mov    %ax,0x28(%ecx)
	fsm_printf("[RLC][rlc_UM5_segment] SN = %d\n",umIns->SN);
    e7e0:	98                   	cwtl   
    e7e1:	89 44 24 04          	mov    %eax,0x4(%esp)
    e7e5:	c7 04 24 44 3b 00 00 	movl   $0x3b44,(%esp)
    e7ec:	e8 fc ff ff ff       	call   e7ed <rlc_UM5_segment+0x2ed>
	return skb;
}
    e7f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e7f4:	83 c4 38             	add    $0x38,%esp
    e7f7:	5b                   	pop    %ebx
    e7f8:	5e                   	pop    %esi
    e7f9:	5f                   	pop    %edi
    e7fa:	5d                   	pop    %ebp
    e7fb:	c3                   	ret    
    e7fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    e800:	0f b7 75 c6          	movzwl -0x3a(%ebp),%esi
    e804:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e807:	89 f2                	mov    %esi,%edx
    e809:	e8 fc ff ff ff       	call   e80a <rlc_UM5_segment+0x30a>
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e80e:	8b 03                	mov    (%ebx),%eax
    e810:	89 f1                	mov    %esi,%ecx
    e812:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e818:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e81b:	e8 fc ff ff ff       	call   e81c <rlc_UM5_segment+0x31c>
				
				if(umBuffer->pkt->len == lastCopyLen)
    e820:	8b 03                	mov    (%ebx),%eax
    e822:	3b 70 50             	cmp    0x50(%eax),%esi
    e825:	0f 84 9e 01 00 00    	je     e9c9 <rlc_UM5_segment+0x4c9>
					fsm_mem_free(umBuffer); 
					umBuffer = NULL;
				}
				else
				{
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e82b:	89 f2                	mov    %esi,%edx
    e82d:	e8 fc ff ff ff       	call   e82e <rlc_UM5_segment+0x32e>
					umIns->umSduBufferSize -=lastCopyLen;
    e832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e835:	29 70 20             	sub    %esi,0x20(%eax)
					umBuffer->pktstatus=LAST_SEGMENT;
    e838:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    e83f:	e9 3c ff ff ff       	jmp    e780 <rlc_UM5_segment+0x280>
    e844:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e848:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e84c:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e850:	01 ff                	add    %edi,%edi
    e852:	e9 e1 fd ff ff       	jmp    e638 <rlc_UM5_segment+0x138>
    e857:	90                   	nop
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e858:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e85c:	31 c0                	xor    %eax,%eax
    e85e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e862:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e864:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e868:	0f 84 a3 01 00 00    	je     ea11 <rlc_UM5_segment+0x511>
					else
						fixhead->FIsecond=1;
				}
				else
				{
					if(flag)
    e86e:	84 c0                	test   %al,%al
    e870:	0f 84 2a 01 00 00    	je     e9a0 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=1;
    e876:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e87a:	83 e0 1f             	and    $0x1f,%eax
						fixhead->FIsecond=1;
    e87d:	83 c8 c0             	or     $0xffffffc0,%eax
    e880:	88 45 f3             	mov    %al,-0xd(%ebp)
    e883:	90                   	nop
    e884:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = size;
    e888:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
				length += size;
    e88c:	01 d3                	add    %edx,%ebx
				break;
    e88e:	e9 a5 fd ff ff       	jmp    e638 <rlc_UM5_segment+0x138>
    e893:	90                   	nop
    e894:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e898:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e89c:	31 c0                	xor    %eax,%eax
    e89e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e8a2:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e8a4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e8a8:	0f 84 79 01 00 00    	je     ea27 <rlc_UM5_segment+0x527>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e8ae:	84 c0                	test   %al,%al
    e8b0:	0f 84 fa 00 00 00    	je     e9b0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=1;
    e8b6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e8ba:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e8bd:	83 e0 9f             	and    $0xffffff9f,%eax
    e8c0:	88 45 f3             	mov    %al,-0xd(%ebp)
    e8c3:	eb c3                	jmp    e888 <rlc_UM5_segment+0x388>
    e8c5:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e8c8:	ba 02 00 00 00       	mov    $0x2,%edx
    e8cd:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e8d0:	e8 fc ff ff ff       	call   e8d1 <rlc_UM5_segment+0x3d1>
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e8d5:	b8 ff ff 00 00       	mov    $0xffff,%eax
    e8da:	e8 fc ff ff ff       	call   e8db <rlc_UM5_segment+0x3db>
    e8df:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e8e2:	e9 d6 fe ff ff       	jmp    e7bd <rlc_UM5_segment+0x2bd>
    e8e7:	90                   	nop
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e8e8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e8ec:	31 c0                	xor    %eax,%eax
    e8ee:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e8f2:	01 ff                	add    %edi,%edi
				}
			}
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e8f4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e8f8:	0f 84 36 01 00 00    	je     ea34 <rlc_UM5_segment+0x534>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e8fe:	84 c0                	test   %al,%al
    e900:	0f 84 ba 00 00 00    	je     e9c0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=1;
    e906:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e90a:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e90d:	83 e0 9f             	and    $0xffffff9f,%eax
    e910:	88 45 f3             	mov    %al,-0xd(%ebp)
						flag=false;
					}
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = umBuffer->pkt->len ;
    e913:	8b 06                	mov    (%esi),%eax
    e915:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e919:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
				length += umBuffer->pkt->len;
    e91d:	01 c3                	add    %eax,%ebx
				break;
    e91f:	e9 14 fd ff ff       	jmp    e638 <rlc_UM5_segment+0x138>
    e924:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    e928:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e92b:	89 da                	mov    %ebx,%edx
    e92d:	e8 fc ff ff ff       	call   e92e <rlc_UM5_segment+0x42e>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e932:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    e935:	0f b7 5d c6          	movzwl -0x3a(%ebp),%ebx
    e939:	8b 42 f0             	mov    -0x10(%edx),%eax
    e93c:	89 da                	mov    %ebx,%edx
    e93e:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e944:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e947:	e8 fc ff ff ff       	call   e948 <rlc_UM5_segment+0x448>
    e94c:	89 d9                	mov    %ebx,%ecx
    e94e:	89 f2                	mov    %esi,%edx
    e950:	e8 fc ff ff ff       	call   e951 <rlc_UM5_segment+0x451>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e955:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e958:	ba 01 00 00 00       	mov    $0x1,%edx
    e95d:	e8 fc ff ff ff       	call   e95e <rlc_UM5_segment+0x45e>
    e962:	b9 01 00 00 00       	mov    $0x1,%ecx
    e967:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e96a:	e8 fc ff ff ff       	call   e96b <rlc_UM5_segment+0x46b>
		
		if(lastCopyLen == tbuff->pkt->len)
    e96f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e972:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e975:	3b 58 50             	cmp    0x50(%eax),%ebx
    e978:	0f 84 c3 00 00 00    	je     ea41 <rlc_UM5_segment+0x541>
			fsm_mem_free(tbuff);
			tbuff = NULL;
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e97e:	89 da                	mov    %ebx,%edx
    e980:	e8 fc ff ff ff       	call   e981 <rlc_UM5_segment+0x481>
			tbuff->pktstatus = LAST_SEGMENT;
    e985:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e988:	c7 40 f4 02 00 00 00 	movl   $0x2,-0xc(%eax)
			umIns->umSduBufferSize -=lastCopyLen;
    e98f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e992:	29 58 20             	sub    %ebx,0x20(%eax)
    e995:	e9 23 fe ff ff       	jmp    e7bd <rlc_UM5_segment+0x2bd>
    e99a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
						fixhead->E=0;
						fixhead->FIsecond=1;
						flag=false;
					}
					else
						fixhead->FIsecond=1;
    e9a0:	80 4d f3 40          	orb    $0x40,-0xd(%ebp)
    e9a4:	e9 df fe ff ff       	jmp    e888 <rlc_UM5_segment+0x388>
    e9a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
    e9b0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e9b4:	e9 cf fe ff ff       	jmp    e888 <rlc_UM5_segment+0x388>
    e9b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}
					else
						fixhead->FIsecond=0;
    e9c0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e9c4:	e9 4a ff ff ff       	jmp    e913 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e9c9:	8b 53 10             	mov    0x10(%ebx),%edx
    e9cc:	8b 43 14             	mov    0x14(%ebx),%eax
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e9cf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e9d2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e9d5:	89 10                	mov    %edx,(%eax)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e9d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e9da:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e9dd:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e9e4:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e9eb:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e9ef:	8b 42 f0             	mov    -0x10(%edx),%eax
    e9f2:	8b 40 50             	mov    0x50(%eax),%eax
    e9f5:	29 41 20             	sub    %eax,0x20(%ecx)
					fsm_pkt_destroy(umBuffer->pkt);
    e9f8:	8b 03                	mov    (%ebx),%eax
    e9fa:	e8 fc ff ff ff       	call   e9fb <rlc_UM5_segment+0x4fb>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer); 
    e9ff:	89 d8                	mov    %ebx,%eax
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    ea01:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer); 
    ea07:	e8 fc ff ff ff       	call   ea08 <rlc_UM5_segment+0x508>
    ea0c:	e9 6f fd ff ff       	jmp    e780 <rlc_UM5_segment+0x280>
			if(size < umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    ea11:	84 c0                	test   %al,%al
    ea13:	74 8b                	je     e9a0 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=0;
    ea15:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    ea19:	83 e0 5f             	and    $0x5f,%eax
						fixhead->FIsecond=1;
    ea1c:	83 c8 40             	or     $0x40,%eax
    ea1f:	88 45 f3             	mov    %al,-0xd(%ebp)
    ea22:	e9 61 fe ff ff       	jmp    e888 <rlc_UM5_segment+0x388>
			else if(size == umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    ea27:	84 c0                	test   %al,%al
    ea29:	74 85                	je     e9b0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    ea2b:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    ea2f:	e9 54 fe ff ff       	jmp    e888 <rlc_UM5_segment+0x388>
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    ea34:	84 c0                	test   %al,%al
    ea36:	74 88                	je     e9c0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    ea38:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    ea3c:	e9 d2 fe ff ff       	jmp    e913 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ea41:	8b 11                	mov    (%ecx),%edx
    ea43:	8b 41 04             	mov    0x4(%ecx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ea46:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ea49:	89 10                	mov    %edx,(%eax)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    ea4b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ea4e:	c7 01 00 01 10 00    	movl   $0x100100,(%ecx)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    ea54:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    ea57:	c7 41 04 00 02 20 00 	movl   $0x200200,0x4(%ecx)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    ea5e:	83 68 24 01          	subl   $0x1,0x24(%eax)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    ea62:	8b 41 f0             	mov    -0x10(%ecx),%eax
    ea65:	8b 40 50             	mov    0x50(%eax),%eax
    ea68:	29 42 20             	sub    %eax,0x20(%edx)
			fsm_pkt_destroy(tbuff->pkt);
    ea6b:	8b 41 f0             	mov    -0x10(%ecx),%eax
    ea6e:	e8 fc ff ff ff       	call   ea6f <rlc_UM5_segment+0x56f>
			tbuff->pkt = NULL;
    ea73:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    ea76:	89 d8                	mov    %ebx,%eax
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
    ea78:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    ea7f:	83 e8 10             	sub    $0x10,%eax
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
			fsm_mem_free(tbuff);
    ea82:	e8 fc ff ff ff       	call   ea83 <rlc_UM5_segment+0x583>
    ea87:	e9 31 fd ff ff       	jmp    e7bd <rlc_UM5_segment+0x2bd>
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    ea8c:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    ea91:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    ea96:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    ea9c:	31 db                	xor    %ebx,%ebx
    ea9e:	e9 c1 fd ff ff       	jmp    e864 <rlc_UM5_segment+0x364>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    eaa3:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    eaa8:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    eaad:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    eab3:	31 db                	xor    %ebx,%ebx
    eab5:	e9 ea fd ff ff       	jmp    e8a4 <rlc_UM5_segment+0x3a4>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    eaba:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    eabf:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    eac4:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    eaca:	31 db                	xor    %ebx,%ebx
    eacc:	e9 23 fe ff ff       	jmp    e8f4 <rlc_UM5_segment+0x3f4>
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
    ead1:	c7 04 24 00 3b 00 00 	movl   $0x3b00,(%esp)
    ead8:	e8 fc ff ff ff       	call   ead9 <rlc_UM5_segment+0x5d9>
		return NULL;
    eadd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    eae4:	e9 08 fd ff ff       	jmp    e7f1 <rlc_UM5_segment+0x2f1>
    eae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000eaf0 <rlc_resegment>:
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    eaf0:	55                   	push   %ebp
    eaf1:	89 e5                	mov    %esp,%ebp
    eaf3:	57                   	push   %edi
    eaf4:	56                   	push   %esi
    eaf5:	53                   	push   %ebx
    eaf6:	83 ec 20             	sub    $0x20,%esp
    eaf9:	e8 fc ff ff ff       	call   eafa <rlc_resegment+0xa>
	if(tbuff->segStart[0] != -1)
    eafe:	83 78 10 ff          	cmpl   $0xffffffff,0x10(%eax)
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    eb02:	89 c3                	mov    %eax,%ebx
    eb04:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if(tbuff->segStart[0] != -1)
    eb07:	0f 84 63 02 00 00    	je     ed70 <rlc_resegment+0x280>
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    eb0d:	b8 02 00 00 00       	mov    $0x2,%eax
    eb12:	e8 fc ff ff ff       	call   eb13 <rlc_resegment+0x23>
		int start = tbuff->segStart[0];
    eb17:	8b 4b 10             	mov    0x10(%ebx),%ecx
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
    eb1a:	8b 73 0c             	mov    0xc(%ebx),%esi
    eb1d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    eb20:	83 c6 02             	add    $0x2,%esi
{
	if(tbuff->segStart[0] != -1)
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    eb23:	89 c7                	mov    %eax,%edi
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    eb25:	8b 43 50             	mov    0x50(%ebx),%eax
		int headLen = tbuff->headLen + 2;
    eb28:	89 75 ec             	mov    %esi,-0x14(%ebp)
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    eb2b:	8b b3 90 00 00 00    	mov    0x90(%ebx),%esi
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    eb31:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
    eb34:	29 c8                	sub    %ecx,%eax
    eb36:	83 c0 01             	add    $0x1,%eax
    eb39:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int retxSize = headLen + dataLen;
    eb3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb3f:	03 45 e8             	add    -0x18(%ebp),%eax
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    eb42:	3b 45 f0             	cmp    -0x10(%ebp),%eax
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    eb45:	89 75 e0             	mov    %esi,-0x20(%ebp)
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
    eb48:	88 0f                	mov    %cl,(%edi)
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    eb4a:	0f 87 48 01 00 00    	ja     ec98 <rlc_resegment+0x1a8>
		{
			exthead->SO = start;
    eb50:	0f b6 d5             	movzbl %ch,%edx
    eb53:	83 e2 7f             	and    $0x7f,%edx
    eb56:	89 d6                	mov    %edx,%esi
    eb58:	0f b6 57 01          	movzbl 0x1(%edi),%edx
    eb5c:	83 e2 80             	and    $0xffffff80,%edx
    eb5f:	09 f2                	or     %esi,%edx
    eb61:	88 57 01             	mov    %dl,0x1(%edi)
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
    eb64:	8b 75 d8             	mov    -0x28(%ebp),%esi
    eb67:	03 75 ec             	add    -0x14(%ebp),%esi
    eb6a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    eb6d:	8b 33                	mov    (%ebx),%esi
    eb6f:	8b b6 ac 00 00 00    	mov    0xac(%esi),%esi
    eb75:	01 75 e4             	add    %esi,-0x1c(%ebp)
    eb78:	8b 33                	mov    (%ebx),%esi
    eb7a:	8b b6 a0 00 00 00    	mov    0xa0(%esi),%esi
    eb80:	83 ee 01             	sub    $0x1,%esi
    eb83:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
    eb86:	0f 84 d4 01 00 00    	je     ed60 <rlc_resegment+0x270>
			{
				exthead->LSF = 1;
			}
			else
			{
				exthead->LSF = 0;
    eb8c:	83 e2 7f             	and    $0x7f,%edx
    eb8f:	88 57 01             	mov    %dl,0x1(%edi)
			}
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    eb92:	8b 13                	mov    (%ebx),%edx
    eb94:	8b 92 ac 00 00 00    	mov    0xac(%edx),%edx
    eb9a:	89 55 f0             	mov    %edx,-0x10(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    eb9d:	80 4a 01 40          	orb    $0x40,0x1(%edx)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    eba1:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    eba4:	e8 fc ff ff ff       	call   eba5 <rlc_resegment+0xb5>
			fsm_skb_reserve(skb,headLen);
    eba9:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    ebac:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    ebae:	e8 fc ff ff ff       	call   ebaf <rlc_resegment+0xbf>
			tail = fsm_skb_put(skb,dataLen);
    ebb3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ebb6:	89 f0                	mov    %esi,%eax
    ebb8:	e8 fc ff ff ff       	call   ebb9 <rlc_resegment+0xc9>
			fsm_mem_cpy(skb->data,(tbuff->pkt->data + tbuff->headLen  + start),dataLen); 
    ebbd:	8b 03                	mov    (%ebx),%eax
    ebbf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ebc2:	8b 53 0c             	mov    0xc(%ebx),%edx
    ebc5:	01 ca                	add    %ecx,%edx
    ebc7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ebca:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    ebd0:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    ebd6:	e8 fc ff ff ff       	call   ebd7 <rlc_resegment+0xe7>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4); //kuo zhan tou fu zhi
    ebdb:	8b 03                	mov    (%ebx),%eax
    ebdd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ebe0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ebe6:	83 e9 04             	sub    $0x4,%ecx
    ebe9:	89 ca                	mov    %ecx,%edx
    ebeb:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ebee:	83 c0 02             	add    $0x2,%eax
    ebf1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ebf4:	89 f0                	mov    %esi,%eax
    ebf6:	e8 fc ff ff ff       	call   ebf7 <rlc_resegment+0x107>
    ebfb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ebfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec01:	e8 fc ff ff ff       	call   ec02 <rlc_resegment+0x112>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    ec06:	ba 02 00 00 00       	mov    $0x2,%edx
    ec0b:	89 f0                	mov    %esi,%eax
    ec0d:	e8 fc ff ff ff       	call   ec0e <rlc_resegment+0x11e>
    ec12:	b9 02 00 00 00       	mov    $0x2,%ecx
    ec17:	89 fa                	mov    %edi,%edx
    ec19:	e8 fc ff ff ff       	call   ec1a <rlc_resegment+0x12a>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    ec1e:	ba 02 00 00 00       	mov    $0x2,%edx
    ec23:	89 f0                	mov    %esi,%eax
    ec25:	e8 fc ff ff ff       	call   ec26 <rlc_resegment+0x136>
    ec2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ec2d:	b9 02 00 00 00       	mov    $0x2,%ecx
    ec32:	e8 fc ff ff ff       	call   ec33 <rlc_resegment+0x143>

			if(count == 1)
    ec37:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
    ec3b:	0f 84 47 01 00 00    	je     ed88 <rlc_resegment+0x298>
			{
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
    ec41:	7e 3e                	jle    ec81 <rlc_resegment+0x191>
			{				
				for(i=0; i < count-1; i++)
    ec43:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    ec46:	89 d8                	mov    %ebx,%eax
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    ec48:	31 d2                	xor    %edx,%edx
    ec4a:	89 75 ec             	mov    %esi,-0x14(%ebp)
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    ec4d:	83 e9 01             	sub    $0x1,%ecx
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    ec50:	89 ce                	mov    %ecx,%esi
    ec52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
    ec58:	8b 48 14             	mov    0x14(%eax),%ecx
    ec5b:	83 c2 01             	add    $0x1,%edx
    ec5e:	89 48 10             	mov    %ecx,0x10(%eax)
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
    ec61:	8b 48 54             	mov    0x54(%eax),%ecx
    ec64:	89 48 50             	mov    %ecx,0x50(%eax)
    ec67:	83 c0 04             	add    $0x4,%eax
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    ec6a:	39 f2                	cmp    %esi,%edx
    ec6c:	75 ea                	jne    ec58 <rlc_resegment+0x168>
    ec6e:	8b 75 ec             	mov    -0x14(%ebp),%esi
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
				}
				tbuff->segStart[count-1] = -1;
    ec71:	c7 44 93 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%edx,4)
    ec78:	ff 
				tbuff->segEnd[count-1] = -1;
    ec79:	c7 44 93 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%edx,4)
    ec80:	ff 
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			tbuff->segStart[0] += len;
		}
		if(exthead != NULL)
    ec81:	85 ff                	test   %edi,%edi
    ec83:	74 07                	je     ec8c <rlc_resegment+0x19c>
		{
			fsm_mem_free(exthead);
    ec85:	89 f8                	mov    %edi,%eax
    ec87:	e8 fc ff ff ff       	call   ec88 <rlc_resegment+0x198>
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    ec8c:	83 c4 20             	add    $0x20,%esp
		if(exthead != NULL)
		{
			fsm_mem_free(exthead);
			exthead=NULL;
		}
		return skb;
    ec8f:	89 f0                	mov    %esi,%eax
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    ec91:	5b                   	pop    %ebx
    ec92:	5e                   	pop    %esi
    ec93:	5f                   	pop    %edi
    ec94:	5d                   	pop    %ebp
    ec95:	c3                   	ret    
    ec96:	66 90                	xchg   %ax,%ax
				count--;
			}
		}
		else                    //need resegment
		{
			exthead->SO = start;
    ec98:	0f b6 c5             	movzbl %ch,%eax
			exthead->LSF = 0;
    ec9b:	83 e0 7f             	and    $0x7f,%eax
    ec9e:	88 47 01             	mov    %al,0x1(%edi)
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    eca1:	8b 03                	mov    (%ebx),%eax
    eca3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    eca9:	89 45 e8             	mov    %eax,-0x18(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    ecac:	80 48 01 40          	orb    $0x40,0x1(%eax)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    ecb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecb3:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ecb6:	e8 fc ff ff ff       	call   ecb7 <rlc_resegment+0x1c7>
			fsm_skb_reserve(skb,headLen);
    ecbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    ecbe:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    ecc0:	e8 fc ff ff ff       	call   ecc1 <rlc_resegment+0x1d1>
			len = sizeFromMac - headLen;
    ecc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecc8:	2b 45 ec             	sub    -0x14(%ebp),%eax
			tail = fsm_skb_put(skb,len);
    eccb:	89 c2                	mov    %eax,%edx
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
			fsm_skb_reserve(skb,headLen);
			len = sizeFromMac - headLen;
    eccd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			tail = fsm_skb_put(skb,len);
    ecd0:	89 f0                	mov    %esi,%eax
    ecd2:	e8 fc ff ff ff       	call   ecd3 <rlc_resegment+0x1e3>
			fsm_mem_cpy(skb->data,tbuff->pkt->data + tbuff->headLen  + start,len); 
    ecd7:	8b 03                	mov    (%ebx),%eax
    ecd9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ecdc:	8b 53 0c             	mov    0xc(%ebx),%edx
    ecdf:	01 ca                	add    %ecx,%edx
    ece1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ece4:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    ecea:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    ecf0:	e8 fc ff ff ff       	call   ecf1 <rlc_resegment+0x201>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
    ecf5:	8b 03                	mov    (%ebx),%eax
    ecf7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    ecfa:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ed00:	83 e9 02             	sub    $0x2,%ecx
    ed03:	89 ca                	mov    %ecx,%edx
    ed05:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ed08:	83 c0 02             	add    $0x2,%eax
    ed0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ed0e:	89 f0                	mov    %esi,%eax
    ed10:	e8 fc ff ff ff       	call   ed11 <rlc_resegment+0x221>
    ed15:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ed18:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed1b:	e8 fc ff ff ff       	call   ed1c <rlc_resegment+0x22c>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    ed20:	ba 02 00 00 00       	mov    $0x2,%edx
    ed25:	89 f0                	mov    %esi,%eax
    ed27:	e8 fc ff ff ff       	call   ed28 <rlc_resegment+0x238>
    ed2c:	b9 02 00 00 00       	mov    $0x2,%ecx
    ed31:	89 fa                	mov    %edi,%edx
    ed33:	e8 fc ff ff ff       	call   ed34 <rlc_resegment+0x244>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    ed38:	ba 02 00 00 00       	mov    $0x2,%edx
    ed3d:	89 f0                	mov    %esi,%eax
    ed3f:	e8 fc ff ff ff       	call   ed40 <rlc_resegment+0x250>
    ed44:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ed47:	b9 02 00 00 00       	mov    $0x2,%ecx
    ed4c:	e8 fc ff ff ff       	call   ed4d <rlc_resegment+0x25d>
			tbuff->segStart[0] += len;
    ed51:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ed54:	01 53 10             	add    %edx,0x10(%ebx)
    ed57:	e9 25 ff ff ff       	jmp    ec81 <rlc_resegment+0x191>
    ed5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
			{
				exthead->LSF = 1;
    ed60:	83 ca 80             	or     $0xffffff80,%edx
    ed63:	88 57 01             	mov    %dl,0x1(%edi)
    ed66:	e9 27 fe ff ff       	jmp    eb92 <rlc_resegment+0xa2>
    ed6b:	90                   	nop
    ed6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		return skb;
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
    ed70:	c7 04 24 64 3b 00 00 	movl   $0x3b64,(%esp)
    ed77:	e8 fc ff ff ff       	call   ed78 <rlc_resegment+0x288>
	}
}
    ed7c:	83 c4 20             	add    $0x20,%esp
    ed7f:	5b                   	pop    %ebx
    ed80:	5e                   	pop    %esi
    ed81:	5f                   	pop    %edi
    ed82:	5d                   	pop    %ebp
    ed83:	c3                   	ret    
    ed84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);

			if(count == 1)
			{
				tbuff->segStart[0]=-1;
    ed88:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
				tbuff->segEnd[0]=-1;
    ed8f:	c7 43 50 ff ff ff ff 	movl   $0xffffffff,0x50(%ebx)
    ed96:	e9 e6 fe ff ff       	jmp    ec81 <rlc_resegment+0x191>
    ed9b:	90                   	nop
    ed9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000eda0 <rlc_AM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
{
    eda0:	55                   	push   %ebp
    eda1:	89 e5                	mov    %esp,%ebp
    eda3:	57                   	push   %edi
    eda4:	56                   	push   %esi
    eda5:	53                   	push   %ebx
    eda6:	83 ec 44             	sub    $0x44,%esp
    eda9:	e8 fc ff ff ff       	call   edaa <rlc_AM_reassemble_deliver+0xa>
    edae:	89 55 c0             	mov    %edx,-0x40(%ebp)
    edb1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    edb4:	e8 fc ff ff ff       	call   edb5 <rlc_AM_reassemble_deliver+0x15>
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    edb9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    edbc:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    edbf:	0f bf 82 ee 22 00 00 	movswl 0x22ee(%edx),%eax
    edc6:	89 44 24 08          	mov    %eax,0x8(%esp)
    edca:	0f bf 82 f4 22 00 00 	movswl 0x22f4(%edx),%eax
    edd1:	c7 04 24 a0 3b 00 00 	movl   $0x3ba0,(%esp)
    edd8:	89 44 24 04          	mov    %eax,0x4(%esp)
    eddc:	e8 fc ff ff ff       	call   eddd <rlc_AM_reassemble_deliver+0x3d>
	u16 h=(amIns->vr_h + 1)%1024;
    ede1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    ede4:	0f bf 81 ee 22 00 00 	movswl 0x22ee(%ecx),%eax
    edeb:	83 c0 01             	add    $0x1,%eax
    edee:	89 c2                	mov    %eax,%edx
    edf0:	c1 fa 1f             	sar    $0x1f,%edx
    edf3:	c1 ea 16             	shr    $0x16,%edx
    edf6:	01 d0                	add    %edx,%eax
    edf8:	25 ff 03 00 00       	and    $0x3ff,%eax
    edfd:	29 d0                	sub    %edx,%eax
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    edff:	0f b7 c0             	movzwl %ax,%eax
    ee02:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    ee05:	0f b7 81 f4 22 00 00 	movzwl 0x22f4(%ecx),%eax
    ee0c:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    ee0f:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    ee15:	89 d0                	mov    %edx,%eax
    ee17:	c1 f8 1f             	sar    $0x1f,%eax
    ee1a:	c1 e8 16             	shr    $0x16,%eax
    ee1d:	01 c2                	add    %eax,%edx
    ee1f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    ee25:	29 c2                	sub    %eax,%edx
    ee27:	85 d2                	test   %edx,%edx
    ee29:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ee2c:	0f 8e 16 04 00 00    	jle    f248 <rlc_AM_reassemble_deliver+0x4a8>
    ee32:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    ee35:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    ee38:	e9 8d 00 00 00       	jmp    eeca <rlc_AM_reassemble_deliver+0x12a>
    ee3d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    ee40:	84 c0                	test   %al,%al
    ee42:	0f 84 88 01 00 00    	je     efd0 <rlc_AM_reassemble_deliver+0x230>
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
					//fsm_octets_print(tbuff->pkt->data,64);
				}
			}
			else if(pduhdr->E==1)
    ee48:	83 e2 04             	and    $0x4,%edx
    ee4b:	0f 85 e7 01 00 00    	jne    f038 <rlc_AM_reassemble_deliver+0x298>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ee51:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    ee57:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ee5d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ee60:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
				{
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
    ee62:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ee64:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
    ee6b:	01 10 00 
	entry->prev = LIST_POISON2;
    ee6e:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
    ee75:	02 20 00 
    ee78:	e8 fc ff ff ff       	call   ee79 <rlc_AM_reassemble_deliver+0xd9>
					tbuff = NULL;
				}
			if(icimsg != NULL)
    ee7d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ee80:	85 c9                	test   %ecx,%ecx
    ee82:	74 08                	je     ee8c <rlc_AM_reassemble_deliver+0xec>
			{
				fsm_mem_free(icimsg);
    ee84:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ee87:	e8 fc ff ff ff       	call   ee88 <rlc_AM_reassemble_deliver+0xe8>
				icimsg=NULL;
			}
			amIns->amRecvWindow[i]=NULL;
    ee8c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    ee8f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ee92:	c7 44 98 0c 00 00 00 	movl   $0x0,0xc(%eax,%ebx,4)
    ee99:	00 
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
	u16 h=(amIns->vr_h + 1)%1024;
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    ee9a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ee9e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    eea5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eea8:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    eeab:	05 00 04 00 00       	add    $0x400,%eax
    eeb0:	89 c2                	mov    %eax,%edx
    eeb2:	c1 fa 1f             	sar    $0x1f,%edx
    eeb5:	c1 ea 16             	shr    $0x16,%edx
    eeb8:	01 d0                	add    %edx,%eax
    eeba:	25 ff 03 00 00       	and    $0x3ff,%eax
    eebf:	29 d0                	sub    %edx,%eax
    eec1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    eec4:	0f 8d 7e 03 00 00    	jge    f248 <rlc_AM_reassemble_deliver+0x4a8>
	//for(i=0; i<=AM_WINDOW_SIZE; i++)
	{
		if(amIns->amRecvWindow[i] != NULL)
    eeca:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    eecd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    eed0:	81 c3 98 04 00 00    	add    $0x498,%ebx
    eed6:	8b 74 98 0c          	mov    0xc(%eax,%ebx,4),%esi
    eeda:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    eedd:	85 f6                	test   %esi,%esi
    eedf:	74 b9                	je     ee9a <rlc_AM_reassemble_deliver+0xfa>
		{
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    eee1:	8b 06                	mov    (%esi),%eax
    eee3:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    eee9:	b8 02 00 00 00       	mov    $0x2,%eax
    eeee:	e8 fc ff ff ff       	call   eeef <rlc_AM_reassemble_deliver+0x14f>
    eef3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    eef6:	8b 43 02             	mov    0x2(%ebx),%eax
    eef9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eefc:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    eefe:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    ef02:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ef05:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ef07:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    ef0c:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    ef12:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ef15:	e8 fc ff ff ff       	call   ef16 <rlc_AM_reassemble_deliver+0x176>
    		fsm_printf("[RLC][rlc_AM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    ef1a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef1e:	c0 e8 03             	shr    $0x3,%al
    ef21:	83 e0 01             	and    $0x1,%eax
    ef24:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ef28:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef2c:	c0 e8 04             	shr    $0x4,%al
    ef2f:	83 e0 01             	and    $0x1,%eax
    ef32:	89 44 24 08          	mov    %eax,0x8(%esp)
    ef36:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef3a:	c7 04 24 d4 3b 00 00 	movl   $0x3bd4,(%esp)
    ef41:	c0 e8 02             	shr    $0x2,%al
    ef44:	83 e0 01             	and    $0x1,%eax
    ef47:	89 44 24 04          	mov    %eax,0x4(%esp)
    ef4b:	e8 fc ff ff ff       	call   ef4c <rlc_AM_reassemble_deliver+0x1ac>
			//fsm_octets_print(tbuff->pkt->data,64);
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    ef50:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    ef54:	89 d0                	mov    %edx,%eax
    ef56:	83 e0 14             	and    $0x14,%eax
    ef59:	3c 10                	cmp    $0x10,%al
    ef5b:	0f 85 df fe ff ff    	jne    ee40 <rlc_AM_reassemble_deliver+0xa0>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ef61:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ef64:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    ef68:	66 83 f9 ff          	cmp    $0xffff,%cx
    ef6c:	74 2f                	je     ef9d <rlc_AM_reassemble_deliver+0x1fd>
    ef6e:	0f bf c9             	movswl %cx,%ecx
    ef71:	0f b6 13             	movzbl (%ebx),%edx
    ef74:	83 c1 01             	add    $0x1,%ecx
    ef77:	89 c8                	mov    %ecx,%eax
    ef79:	c1 f8 1f             	sar    $0x1f,%eax
    ef7c:	c1 e8 16             	shr    $0x16,%eax
    ef7f:	01 c1                	add    %eax,%ecx
    ef81:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ef87:	29 c1                	sub    %eax,%ecx
    ef89:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef8d:	83 e0 03             	and    $0x3,%eax
    ef90:	c1 e0 08             	shl    $0x8,%eax
    ef93:	09 d0                	or     %edx,%eax
    ef95:	39 c1                	cmp    %eax,%ecx
    ef97:	0f 84 e3 03 00 00    	je     f380 <rlc_AM_reassemble_deliver+0x5e0>
						//fsm_octets_print(new_skb->data,new_skb->len);
					}
				}
				else
				{
					SV(countDropPacket)++;
    ef9d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    efa0:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    efa7:	8b 45 c0             	mov    -0x40(%ebp),%eax
    efaa:	e8 fc ff ff ff       	call   efab <rlc_AM_reassemble_deliver+0x20b>
                    
					if(tbuff->pkt != NULL)
    efaf:	8b 06                	mov    (%esi),%eax
    efb1:	85 c0                	test   %eax,%eax
    efb3:	0f 84 98 fe ff ff    	je     ee51 <rlc_AM_reassemble_deliver+0xb1>
					{
						fsm_pkt_destroy(tbuff->pkt);
    efb9:	e8 fc ff ff ff       	call   efba <rlc_AM_reassemble_deliver+0x21a>
						tbuff->pkt = NULL;
    efbe:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    efc4:	e9 88 fe ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
    efc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{
				clear_left_pdu(pdu_left);
    efd0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    efd3:	e8 fc ff ff ff       	call   efd4 <rlc_AM_reassemble_deliver+0x234>
				if(pduhdr->FIsecond==0)
    efd8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    efdb:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    efdf:	0f 85 6b 02 00 00    	jne    f250 <rlc_AM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    efe5:	8b 1e                	mov    (%esi),%ebx
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    efe7:	89 d8                	mov    %ebx,%eax
    efe9:	e8 fc ff ff ff       	call   efea <rlc_AM_reassemble_deliver+0x24a>
    efee:	83 f8 01             	cmp    $0x1,%eax
    eff1:	0f 86 9f 04 00 00    	jbe    f496 <rlc_AM_reassemble_deliver+0x6f6>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    eff7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    effa:	b9 02 00 00 00       	mov    $0x2,%ecx
    efff:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f005:	e8 fc ff ff ff       	call   f006 <rlc_AM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f00a:	89 d8                	mov    %ebx,%eax
    f00c:	ba 06 00 00 00       	mov    $0x6,%edx
    f011:	e8 fc ff ff ff       	call   f012 <rlc_AM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					//list_del(&tbuff->list);
					//fsm_mem_free(tbuff);
					//tbuff=NULL;
					SV(countSendToUpper)++;
    f016:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f019:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP2\n");
    f020:	c7 04 24 98 3c 00 00 	movl   $0x3c98,(%esp)
    f027:	e8 fc ff ff ff       	call   f028 <rlc_AM_reassemble_deliver+0x288>
    f02c:	e9 20 fe ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
    f031:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f038:	b8 40 00 00 00       	mov    $0x40,%eax
    f03d:	e8 fc ff ff ff       	call   f03e <rlc_AM_reassemble_deliver+0x29e>
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f042:	31 c9                	xor    %ecx,%ecx
    f044:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f046:	89 45 d0             	mov    %eax,-0x30(%ebp)
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f049:	89 04 24             	mov    %eax,(%esp)
    f04c:	b8 01 00 00 00       	mov    $0x1,%eax
    f051:	e8 fc ff ff ff       	call   f052 <rlc_AM_reassemble_deliver+0x2b2>
               
				if(pduhdr->FIfirst==1)
    f056:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f059:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
               
				if(pduhdr->FIfirst==1)
    f05d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    f061:	0f 84 81 02 00 00    	je     f2e8 <rlc_AM_reassemble_deliver+0x548>
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f067:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f06a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    f06e:	66 83 f8 ff          	cmp    $0xffff,%ax
    f072:	74 2d                	je     f0a1 <rlc_AM_reassemble_deliver+0x301>
    f074:	98                   	cwtl   
    f075:	0f b6 13             	movzbl (%ebx),%edx
    f078:	8d 48 01             	lea    0x1(%eax),%ecx
    f07b:	89 c8                	mov    %ecx,%eax
    f07d:	c1 f8 1f             	sar    $0x1f,%eax
    f080:	c1 e8 16             	shr    $0x16,%eax
    f083:	01 c1                	add    %eax,%ecx
    f085:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f08b:	29 c1                	sub    %eax,%ecx
    f08d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f091:	83 e0 03             	and    $0x3,%eax
    f094:	c1 e0 08             	shl    $0x8,%eax
    f097:	09 d0                	or     %edx,%eax
    f099:	39 c1                	cmp    %eax,%ecx
    f09b:	0f 84 08 04 00 00    	je     f4a9 <rlc_AM_reassemble_deliver+0x709>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    f0a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f0a4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    f0ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f0ae:	e8 fc ff ff ff       	call   f0af <rlc_AM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f0b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f0b6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f0ba:	8b 06                	mov    (%esi),%eax
    f0bc:	e8 fc ff ff ff       	call   f0bd <rlc_AM_reassemble_deliver+0x31d>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f0c1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    f0c5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    f0c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f0ce:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f0d2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    f0d5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f0d8:	7f 47                	jg     f121 <rlc_AM_reassemble_deliver+0x381>
    f0da:	e9 ab 00 00 00       	jmp    f18a <rlc_AM_reassemble_deliver+0x3ea>
    f0df:	90                   	nop
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f0e0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f0e6:	b9 02 00 00 00       	mov    $0x2,%ecx
    f0eb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f0ee:	e8 fc ff ff ff       	call   f0ef <rlc_AM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f0f3:	89 d8                	mov    %ebx,%eax
    f0f5:	ba 06 00 00 00       	mov    $0x6,%edx
    f0fa:	e8 fc ff ff ff       	call   f0fb <rlc_AM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f0ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f102:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    f109:	c7 04 24 34 3d 00 00 	movl   $0x3d34,(%esp)
    f110:	e8 fc ff ff ff       	call   f111 <rlc_AM_reassemble_deliver+0x371>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f115:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    f118:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f11c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f11f:	74 67                	je     f188 <rlc_AM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f121:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f124:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f127:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f12c:	89 d8                	mov    %ebx,%eax
    f12e:	e8 fc ff ff ff       	call   f12f <rlc_AM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f133:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1;  j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f135:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f137:	e8 fc ff ff ff       	call   f138 <rlc_AM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f13c:	8b 07                	mov    (%edi),%eax
    f13e:	89 da                	mov    %ebx,%edx
    f140:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f146:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f149:	89 f0                	mov    %esi,%eax
    f14b:	e8 fc ff ff ff       	call   f14c <rlc_AM_reassemble_deliver+0x3ac>
    f150:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f153:	89 d9                	mov    %ebx,%ecx
    f155:	e8 fc ff ff ff       	call   f156 <rlc_AM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f15a:	8b 07                	mov    (%edi),%eax
    f15c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f15e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f160:	e8 fc ff ff ff       	call   f161 <rlc_AM_reassemble_deliver+0x3c1>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f165:	89 f0                	mov    %esi,%eax
    f167:	e8 fc ff ff ff       	call   f168 <rlc_AM_reassemble_deliver+0x3c8>
    f16c:	83 f8 01             	cmp    $0x1,%eax
    f16f:	0f 87 6b ff ff ff    	ja     f0e0 <rlc_AM_reassemble_deliver+0x340>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f175:	ba 02 00 00 00       	mov    $0x2,%edx
    f17a:	89 f0                	mov    %esi,%eax
    f17c:	e8 fc ff ff ff       	call   f17d <rlc_AM_reassemble_deliver+0x3dd>
    f181:	89 c3                	mov    %eax,%ebx
    f183:	e9 58 ff ff ff       	jmp    f0e0 <rlc_AM_reassemble_deliver+0x340>
    f188:	89 fe                	mov    %edi,%esi
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f18a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f18d:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f18f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f193:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f197:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f199:	0f 85 e1 00 00 00    	jne    f280 <rlc_AM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f19f:	e8 fc ff ff ff       	call   f1a0 <rlc_AM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f1a4:	89 da                	mov    %ebx,%edx
                }
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f1a6:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f1a8:	e8 fc ff ff ff       	call   f1a9 <rlc_AM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f1ad:	8b 06                	mov    (%esi),%eax
    f1af:	89 da                	mov    %ebx,%edx
    f1b1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f1b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f1ba:	89 f8                	mov    %edi,%eax
    f1bc:	e8 fc ff ff ff       	call   f1bd <rlc_AM_reassemble_deliver+0x41d>
    f1c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f1c4:	89 d9                	mov    %ebx,%ecx
    f1c6:	e8 fc ff ff ff       	call   f1c7 <rlc_AM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f1cb:	8b 06                	mov    (%esi),%eax
    f1cd:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f1cf:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f1d1:	e8 fc ff ff ff       	call   f1d2 <rlc_AM_reassemble_deliver+0x432>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f1d6:	89 f8                	mov    %edi,%eax
    f1d8:	e8 fc ff ff ff       	call   f1d9 <rlc_AM_reassemble_deliver+0x439>
    f1dd:	83 f8 01             	cmp    $0x1,%eax
    f1e0:	0f 86 9d 02 00 00    	jbe    f483 <rlc_AM_reassemble_deliver+0x6e3>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f1e6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f1e9:	b9 02 00 00 00       	mov    $0x2,%ecx
    f1ee:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f1f4:	e8 fc ff ff ff       	call   f1f5 <rlc_AM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f1f9:	ba 06 00 00 00       	mov    $0x6,%edx
    f1fe:	89 d8                	mov    %ebx,%eax
    f200:	e8 fc ff ff ff       	call   f201 <rlc_AM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f205:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f208:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP6\n");
    f20f:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
    f216:	e8 fc ff ff ff       	call   f217 <rlc_AM_reassemble_deliver+0x477>
					//fsm_octets_print(skb->data,64);

					//list_del(&tbuff->list);
					if(tbuff->pkt != NULL)
    f21b:	8b 06                	mov    (%esi),%eax
    f21d:	85 c0                	test   %eax,%eax
    f21f:	74 0b                	je     f22c <rlc_AM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
                    {
                    	fsm_pkt_destroy(tbuff->pkt);
    f221:	e8 fc ff ff ff       	call   f222 <rlc_AM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    f226:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					{
						fsm_mem_free(tbuff);
						tbuff = NULL;
					}*/
				}
				if(pPduhdrExt != NULL)
    f22c:	8b 5d d0             	mov    -0x30(%ebp),%ebx
    f22f:	85 db                	test   %ebx,%ebx
    f231:	0f 84 1a fc ff ff    	je     ee51 <rlc_AM_reassemble_deliver+0xb1>
				{
					fsm_mem_free(pPduhdrExt);
    f237:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f23a:	e8 fc ff ff ff       	call   f23b <rlc_AM_reassemble_deliver+0x49b>
    f23f:	e9 0d fc ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
    f244:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			amIns->amRecvWindow[i]=NULL;
		}//end if
	}//end for
	FOUT;
}
    f248:	83 c4 44             	add    $0x44,%esp
    f24b:	5b                   	pop    %ebx
    f24c:	5e                   	pop    %esi
    f24d:	5f                   	pop    %edi
    f24e:	5d                   	pop    %ebp
    f24f:	c3                   	ret    
					//fsm_printf("[RLC][rlc_AM_reassemble_deliver] data len = %d\n", skb->len);
					//fsm_octets_print(skb->data,skb->len);
				}
				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    f250:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f253:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f257:	0f b6 13             	movzbl (%ebx),%edx
    f25a:	83 e0 03             	and    $0x3,%eax
    f25d:	c1 e0 08             	shl    $0x8,%eax
    f260:	09 d0                	or     %edx,%eax
    f262:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f265:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = tbuff->pkt;
    f269:	8b 06                	mov    (%esi),%eax
    f26b:	89 42 04             	mov    %eax,0x4(%edx)
					/*list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f26e:	c7 04 24 60 3c 00 00 	movl   $0x3c60,(%esp)
    f275:	e8 fc ff ff ff       	call   f276 <rlc_AM_reassemble_deliver+0x4d6>
    f27a:	e9 d2 fb ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
    f27f:	90                   	nop
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f280:	e8 fc ff ff ff       	call   f281 <rlc_AM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f285:	89 da                	mov    %ebx,%edx
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f287:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f289:	e8 fc ff ff ff       	call   f28a <rlc_AM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f28e:	8b 06                	mov    (%esi),%eax
    f290:	89 da                	mov    %ebx,%edx
    f292:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f298:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f29b:	89 f8                	mov    %edi,%eax
    f29d:	e8 fc ff ff ff       	call   f29e <rlc_AM_reassemble_deliver+0x4fe>
    f2a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f2a5:	89 d9                	mov    %ebx,%ecx
    f2a7:	e8 fc ff ff ff       	call   f2a8 <rlc_AM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f2ac:	8b 06                	mov    (%esi),%eax
    f2ae:	8b 50 50             	mov    0x50(%eax),%edx
    f2b1:	e8 fc ff ff ff       	call   f2b2 <rlc_AM_reassemble_deliver+0x512>

					pdu_left->SN_Left = pduhdr->SN;
    f2b6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f2b9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f2bd:	0f b6 13             	movzbl (%ebx),%edx
    f2c0:	83 e0 03             	and    $0x3,%eax
    f2c3:	c1 e0 08             	shl    $0x8,%eax
    f2c6:	09 d0                	or     %edx,%eax
    f2c8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f2cb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f2cf:	89 7a 04             	mov    %edi,0x4(%edx)
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
    f2d2:	8b 06                	mov    (%esi),%eax
    f2d4:	85 c0                	test   %eax,%eax
    f2d6:	0f 85 45 ff ff ff    	jne    f221 <rlc_AM_reassemble_deliver+0x481>
    f2dc:	e9 4b ff ff ff       	jmp    f22c <rlc_AM_reassemble_deliver+0x48c>
    f2e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f2e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f2eb:	e8 fc ff ff ff       	call   f2ec <rlc_AM_reassemble_deliver+0x54c>
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f2f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f2f3:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f2f7:	89 d8                	mov    %ebx,%eax
    f2f9:	e8 fc ff ff ff       	call   f2fa <rlc_AM_reassemble_deliver+0x55a>

					fsm_skb_reserve(new_skb,length);
    f2fe:	89 da                	mov    %ebx,%edx
				}
				else
				{
					clear_left_pdu(pdu_left);
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f300:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
    f302:	e8 fc ff ff ff       	call   f303 <rlc_AM_reassemble_deliver+0x563>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f307:	8b 06                	mov    (%esi),%eax
    f309:	89 da                	mov    %ebx,%edx
    f30b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f311:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f314:	89 f8                	mov    %edi,%eax
    f316:	e8 fc ff ff ff       	call   f317 <rlc_AM_reassemble_deliver+0x577>
    f31b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f31e:	89 d9                	mov    %ebx,%ecx
    f320:	e8 fc ff ff ff       	call   f321 <rlc_AM_reassemble_deliver+0x581>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f325:	8b 06                	mov    (%esi),%eax
    f327:	89 da                	mov    %ebx,%edx


					skb = new_skb;
    f329:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f32b:	e8 fc ff ff ff       	call   f32c <rlc_AM_reassemble_deliver+0x58c>


					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f330:	89 f8                	mov    %edi,%eax
    f332:	e8 fc ff ff ff       	call   f333 <rlc_AM_reassemble_deliver+0x593>
    f337:	83 f8 01             	cmp    $0x1,%eax
    f33a:	0f 86 34 02 00 00    	jbe    f574 <rlc_AM_reassemble_deliver+0x7d4>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f340:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f343:	b9 02 00 00 00       	mov    $0x2,%ecx
    f348:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f34e:	e8 fc ff ff ff       	call   f34f <rlc_AM_reassemble_deliver+0x5af>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f353:	89 d8                	mov    %ebx,%eax
    f355:	ba 06 00 00 00       	mov    $0x6,%edx
    f35a:	e8 fc ff ff ff       	call   f35b <rlc_AM_reassemble_deliver+0x5bb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f35f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f362:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP4\n");
    f369:	c7 04 24 00 3d 00 00 	movl   $0x3d00,(%esp)
    f370:	e8 fc ff ff ff       	call   f371 <rlc_AM_reassemble_deliver+0x5d1>
    f375:	e9 47 fd ff ff       	jmp    f0c1 <rlc_AM_reassemble_deliver+0x321>
    f37a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f380:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f383:	8b 16                	mov    (%esi),%edx
    f385:	8b 41 04             	mov    0x4(%ecx),%eax
    f388:	8b 40 50             	mov    0x50(%eax),%eax
    f38b:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f38f:	0f b7 d8             	movzwl %ax,%ebx
    f392:	89 d8                	mov    %ebx,%eax
    f394:	e8 fc ff ff ff       	call   f395 <rlc_AM_reassemble_deliver+0x5f5>
					fsm_skb_reserve(new_skb,length);
    f399:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f39b:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f39d:	e8 fc ff ff ff       	call   f39e <rlc_AM_reassemble_deliver+0x5fe>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f3a2:	8b 06                	mov    (%esi),%eax
    f3a4:	8b 58 50             	mov    0x50(%eax),%ebx
    f3a7:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f3ad:	89 f8                	mov    %edi,%eax
    f3af:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f3b2:	89 da                	mov    %ebx,%edx
    f3b4:	e8 fc ff ff ff       	call   f3b5 <rlc_AM_reassemble_deliver+0x615>
    f3b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3bc:	89 d9                	mov    %ebx,%ecx
    f3be:	e8 fc ff ff ff       	call   f3bf <rlc_AM_reassemble_deliver+0x61f>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f3c3:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f3c6:	8b 42 04             	mov    0x4(%edx),%eax
    f3c9:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f3cf:	8b 58 50             	mov    0x50(%eax),%ebx
    f3d2:	89 f8                	mov    %edi,%eax
    f3d4:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f3d7:	89 da                	mov    %ebx,%edx
    f3d9:	e8 fc ff ff ff       	call   f3da <rlc_AM_reassemble_deliver+0x63a>
    f3de:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f3e1:	89 d9                	mov    %ebx,%ecx
    f3e3:	e8 fc ff ff ff       	call   f3e4 <rlc_AM_reassemble_deliver+0x644>
					clear_left_pdu(pdu_left);
    f3e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f3eb:	e8 fc ff ff ff       	call   f3ec <rlc_AM_reassemble_deliver+0x64c>
					if(tbuff->pkt != NULL)
    f3f0:	8b 06                	mov    (%esi),%eax
    f3f2:	85 c0                	test   %eax,%eax
    f3f4:	74 0b                	je     f401 <rlc_AM_reassemble_deliver+0x661>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f3f6:	e8 fc ff ff ff       	call   f3f7 <rlc_AM_reassemble_deliver+0x657>
						tbuff->pkt = NULL;							
    f3fb:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f401:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f404:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f408:	75 4c                	jne    f456 <rlc_AM_reassemble_deliver+0x6b6>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f40a:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;							
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f40c:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f40e:	e8 fc ff ff ff       	call   f40f <rlc_AM_reassemble_deliver+0x66f>
    f413:	83 f8 01             	cmp    $0x1,%eax
    f416:	0f 86 6b 01 00 00    	jbe    f587 <rlc_AM_reassemble_deliver+0x7e7>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f41c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f41f:	b9 02 00 00 00       	mov    $0x2,%ecx
    f424:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f42a:	e8 fc ff ff ff       	call   f42b <rlc_AM_reassemble_deliver+0x68b>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f42f:	89 d8                	mov    %ebx,%eax
    f431:	ba 06 00 00 00       	mov    $0x6,%edx
    f436:	e8 fc ff ff ff       	call   f437 <rlc_AM_reassemble_deliver+0x697>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f43b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f43e:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP1\n");
    f445:	c7 04 24 2c 3c 00 00 	movl   $0x3c2c,(%esp)
    f44c:	e8 fc ff ff ff       	call   f44d <rlc_AM_reassemble_deliver+0x6ad>
    f451:	e9 fb f9 ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
						//fsm_octets_print(skb->data,skb->len);
						//list_del(&tbuff->list);//20150123
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f456:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f459:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f45d:	0f b6 13             	movzbl (%ebx),%edx
    f460:	83 e0 03             	and    $0x3,%eax
    f463:	c1 e0 08             	shl    $0x8,%eax
    f466:	09 d0                	or     %edx,%eax
    f468:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f46b:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    f46f:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f472:	c7 04 24 60 3c 00 00 	movl   $0x3c60,(%esp)
    f479:	e8 fc ff ff ff       	call   f47a <rlc_AM_reassemble_deliver+0x6da>
    f47e:	e9 ce f9 ff ff       	jmp    ee51 <rlc_AM_reassemble_deliver+0xb1>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f483:	ba 02 00 00 00       	mov    $0x2,%edx
    f488:	89 f8                	mov    %edi,%eax
    f48a:	e8 fc ff ff ff       	call   f48b <rlc_AM_reassemble_deliver+0x6eb>
    f48f:	89 c3                	mov    %eax,%ebx
    f491:	e9 50 fd ff ff       	jmp    f1e6 <rlc_AM_reassemble_deliver+0x446>
				if(pduhdr->FIsecond==0)
				{
					skb = tbuff->pkt;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f496:	89 d8                	mov    %ebx,%eax
    f498:	ba 02 00 00 00       	mov    $0x2,%edx
    f49d:	e8 fc ff ff ff       	call   f49e <rlc_AM_reassemble_deliver+0x6fe>
    f4a2:	89 c3                	mov    %eax,%ebx
    f4a4:	e9 4e fb ff ff       	jmp    eff7 <rlc_AM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    f4a9:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f4ac:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    f4af:	8b 42 04             	mov    0x4(%edx),%eax
    f4b2:	8b 40 50             	mov    0x50(%eax),%eax
    f4b5:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    f4b9:	0f b7 d8             	movzwl %ax,%ebx
    f4bc:	89 d8                	mov    %ebx,%eax
    f4be:	e8 fc ff ff ff       	call   f4bf <rlc_AM_reassemble_deliver+0x71f>

						fsm_skb_reserve(new_skb,length);
    f4c3:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    f4c5:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
    f4c7:	e8 fc ff ff ff       	call   f4c8 <rlc_AM_reassemble_deliver+0x728>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    f4cc:	8b 06                	mov    (%esi),%eax
    f4ce:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f4d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f4d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f4da:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f4de:	89 f8                	mov    %edi,%eax
    f4e0:	89 da                	mov    %ebx,%edx
    f4e2:	e8 fc ff ff ff       	call   f4e3 <rlc_AM_reassemble_deliver+0x743>
    f4e7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f4ea:	89 d9                	mov    %ebx,%ecx
    f4ec:	e8 fc ff ff ff       	call   f4ed <rlc_AM_reassemble_deliver+0x74d>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f4f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f4f4:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f4f8:	8b 06                	mov    (%esi),%eax
    f4fa:	e8 fc ff ff ff       	call   f4fb <rlc_AM_reassemble_deliver+0x75b>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f4ff:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f502:	8b 42 04             	mov    0x4(%edx),%eax
    f505:	8b 58 50             	mov    0x50(%eax),%ebx
    f508:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f50e:	89 f8                	mov    %edi,%eax
    f510:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f513:	89 da                	mov    %ebx,%edx
    f515:	e8 fc ff ff ff       	call   f516 <rlc_AM_reassemble_deliver+0x776>
    f51a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f51d:	89 d9                	mov    %ebx,%ecx
						skb = new_skb;
    f51f:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f521:	e8 fc ff ff ff       	call   f522 <rlc_AM_reassemble_deliver+0x782>
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f526:	89 f8                	mov    %edi,%eax
    f528:	e8 fc ff ff ff       	call   f529 <rlc_AM_reassemble_deliver+0x789>
    f52d:	83 f8 01             	cmp    $0x1,%eax
    f530:	76 68                	jbe    f59a <rlc_AM_reassemble_deliver+0x7fa>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f532:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f535:	b9 02 00 00 00       	mov    $0x2,%ecx
    f53a:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f540:	e8 fc ff ff ff       	call   f541 <rlc_AM_reassemble_deliver+0x7a1>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f545:	ba 06 00 00 00       	mov    $0x6,%edx
    f54a:	89 d8                	mov    %ebx,%eax
    f54c:	e8 fc ff ff ff       	call   f54d <rlc_AM_reassemble_deliver+0x7ad>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f551:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f554:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP3\n");
    f55b:	c7 04 24 cc 3c 00 00 	movl   $0x3ccc,(%esp)
    f562:	e8 fc ff ff ff       	call   f563 <rlc_AM_reassemble_deliver+0x7c3>
						//fsm_octets_print(skb->data,64);
						clear_left_pdu(pdu_left);
    f567:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f56a:	e8 fc ff ff ff       	call   f56b <rlc_AM_reassemble_deliver+0x7cb>
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
               
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    f56f:	e9 4d fb ff ff       	jmp    f0c1 <rlc_AM_reassemble_deliver+0x321>

					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f574:	ba 02 00 00 00       	mov    $0x2,%edx
    f579:	89 f8                	mov    %edi,%eax
    f57b:	e8 fc ff ff ff       	call   f57c <rlc_AM_reassemble_deliver+0x7dc>
    f580:	89 c3                	mov    %eax,%ebx
    f582:	e9 b9 fd ff ff       	jmp    f340 <rlc_AM_reassemble_deliver+0x5a0>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f587:	ba 02 00 00 00       	mov    $0x2,%edx
    f58c:	89 f8                	mov    %edi,%eax
    f58e:	e8 fc ff ff ff       	call   f58f <rlc_AM_reassemble_deliver+0x7ef>
    f593:	89 c3                	mov    %eax,%ebx
    f595:	e9 82 fe ff ff       	jmp    f41c <rlc_AM_reassemble_deliver+0x67c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f59a:	ba 02 00 00 00       	mov    $0x2,%edx
    f59f:	89 f8                	mov    %edi,%eax
    f5a1:	e8 fc ff ff ff       	call   f5a2 <rlc_AM_reassemble_deliver+0x802>
    f5a6:	89 c3                	mov    %eax,%ebx
    f5a8:	eb 88                	jmp    f532 <rlc_AM_reassemble_deliver+0x792>
    f5aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f5b0 <rlc_UM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    f5b0:	55                   	push   %ebp
    f5b1:	89 e5                	mov    %esp,%ebp
    f5b3:	57                   	push   %edi
    f5b4:	56                   	push   %esi
    f5b5:	53                   	push   %ebx
    f5b6:	83 ec 44             	sub    $0x44,%esp
    f5b9:	e8 fc ff ff ff       	call   f5ba <rlc_UM_reassemble_deliver+0xa>
    f5be:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f5c1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
    f5c4:	c7 04 24 9c 3d 00 00 	movl   $0x3d9c,(%esp)
    f5cb:	e8 fc ff ff ff       	call   f5cc <rlc_UM_reassemble_deliver+0x1c>
	SV_PTR_GET(rlc_mac_sv);
    f5d0:	e8 fc ff ff ff       	call   f5d1 <rlc_UM_reassemble_deliver+0x21>
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f5d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f5d8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
	SV_PTR_GET(rlc_mac_sv);
    f5db:	89 45 e0             	mov    %eax,-0x20(%ebp)
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f5de:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    f5e5:	83 c0 01             	add    $0x1,%eax
    f5e8:	89 c2                	mov    %eax,%edx
    f5ea:	c1 fa 1f             	sar    $0x1f,%edx
    f5ed:	c1 ea 16             	shr    $0x16,%edx
    f5f0:	01 d0                	add    %edx,%eax
    f5f2:	25 ff 03 00 00       	and    $0x3ff,%eax
    f5f7:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f5f9:	0f b7 c0             	movzwl %ax,%eax
    f5fc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    f5ff:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    f606:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f609:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    f60f:	89 d0                	mov    %edx,%eax
    f611:	c1 f8 1f             	sar    $0x1f,%eax
    f614:	c1 e8 16             	shr    $0x16,%eax
    f617:	01 c2                	add    %eax,%edx
    f619:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    f61f:	29 c2                	sub    %eax,%edx
    f621:	85 d2                	test   %edx,%edx
    f623:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f626:	0f 8e 2c 04 00 00    	jle    fa58 <rlc_UM_reassemble_deliver+0x4a8>
    f62c:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    f62f:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    f632:	e9 83 00 00 00       	jmp    f6ba <rlc_UM_reassemble_deliver+0x10a>
    f637:	90                   	nop
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    f638:	84 c0                	test   %al,%al
    f63a:	0f 84 a0 01 00 00    	je     f7e0 <rlc_UM_reassemble_deliver+0x230>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft=tbuff->pkt;
					fsm_printf("[RLC] Not a complet SDU\n");
				}
			}
			else if(pduhdr->E==1)
    f640:	83 e2 04             	and    $0x4,%edx
    f643:	0f 85 ff 01 00 00    	jne    f848 <rlc_UM_reassemble_deliver+0x298>
				{
					fsm_mem_free(pPduhdrExt);
					pPduhdrExt = NULL;
				}
			}
			if(tbuff != NULL)
    f649:	85 f6                	test   %esi,%esi
    f64b:	74 20                	je     f66d <rlc_UM_reassemble_deliver+0xbd>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    f64d:	8b 46 14             	mov    0x14(%esi),%eax
    f650:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    f653:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    f656:	89 10                	mov    %edx,(%eax)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    f658:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    f65a:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    f661:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    f668:	e8 fc ff ff ff       	call   f669 <rlc_UM_reassemble_deliver+0xb9>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    f66d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    f670:	85 f6                	test   %esi,%esi
    f672:	74 08                	je     f67c <rlc_UM_reassemble_deliver+0xcc>
			{
				fsm_mem_free(icimsg);
    f674:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f677:	e8 fc ff ff ff       	call   f678 <rlc_UM_reassemble_deliver+0xc8>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    f67c:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f67f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f682:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
    f689:	00 
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f68a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f68e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    f695:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f698:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f69b:	05 00 04 00 00       	add    $0x400,%eax
    f6a0:	89 c2                	mov    %eax,%edx
    f6a2:	c1 fa 1f             	sar    $0x1f,%edx
    f6a5:	c1 ea 16             	shr    $0x16,%edx
    f6a8:	01 d0                	add    %edx,%eax
    f6aa:	25 ff 03 00 00       	and    $0x3ff,%eax
    f6af:	29 d0                	sub    %edx,%eax
    f6b1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    f6b4:	0f 8d 9e 03 00 00    	jge    fa58 <rlc_UM_reassemble_deliver+0x4a8>
	{
		if(umIns->umRecvWindow10[i] != NULL)
    f6ba:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f6bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f6c0:	83 c3 2c             	add    $0x2c,%ebx
    f6c3:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
    f6c7:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    f6ca:	85 c0                	test   %eax,%eax
    f6cc:	74 bc                	je     f68a <rlc_UM_reassemble_deliver+0xda>
		{
			fsm_printf("[RLC]  umIns->umRecvWindow10[i] != NULL, i = %d\n",i);
    f6ce:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f6d1:	c7 04 24 c4 3d 00 00 	movl   $0x3dc4,(%esp)
    f6d8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    f6dc:	e8 fc ff ff ff       	call   f6dd <rlc_UM_reassemble_deliver+0x12d>
			tbuff = umIns->umRecvWindow10[i];
    f6e1:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f6e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f6e7:	8b 74 98 08          	mov    0x8(%eax,%ebx,4),%esi
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    f6eb:	8b 06                	mov    (%esi),%eax
    f6ed:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    f6f3:	b8 02 00 00 00       	mov    $0x2,%eax
    f6f8:	e8 fc ff ff ff       	call   f6f9 <rlc_UM_reassemble_deliver+0x149>
    f6fd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    f700:	8b 43 02             	mov    0x2(%ebx),%eax
    f703:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f706:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    f708:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    f70c:	88 42 01             	mov    %al,0x1(%edx)
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f70f:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f711:	ba 02 00 00 00       	mov    $0x2,%edx
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f716:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    f71c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f71f:	e8 fc ff ff ff       	call   f720 <rlc_UM_reassemble_deliver+0x170>
			//get_UmPduhead(umIns->umRecvWindow10[i],pduhdr) ;
			fsm_octets_print(pduhdr,2);
    f724:	ba 02 00 00 00       	mov    $0x2,%edx
    f729:	89 d8                	mov    %ebx,%eax
    f72b:	e8 fc ff ff ff       	call   f72c <rlc_UM_reassemble_deliver+0x17c>
          	fsm_printf("[RLC][rlc_UM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    f730:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f734:	c0 e8 03             	shr    $0x3,%al
    f737:	83 e0 01             	and    $0x1,%eax
    f73a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f73e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f742:	c0 e8 04             	shr    $0x4,%al
    f745:	83 e0 01             	and    $0x1,%eax
    f748:	89 44 24 08          	mov    %eax,0x8(%esp)
    f74c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f750:	c7 04 24 f8 3d 00 00 	movl   $0x3df8,(%esp)
    f757:	c0 e8 02             	shr    $0x2,%al
    f75a:	83 e0 01             	and    $0x1,%eax
    f75d:	89 44 24 04          	mov    %eax,0x4(%esp)
    f761:	e8 fc ff ff ff       	call   f762 <rlc_UM_reassemble_deliver+0x1b2>
			
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    f766:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    f76a:	89 d0                	mov    %edx,%eax
    f76c:	83 e0 14             	and    $0x14,%eax
    f76f:	3c 10                	cmp    $0x10,%al
    f771:	0f 85 c1 fe ff ff    	jne    f638 <rlc_UM_reassemble_deliver+0x88>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f777:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f77a:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    f77e:	66 83 f9 ff          	cmp    $0xffff,%cx
    f782:	74 2f                	je     f7b3 <rlc_UM_reassemble_deliver+0x203>
    f784:	0f bf c9             	movswl %cx,%ecx
    f787:	0f b6 13             	movzbl (%ebx),%edx
    f78a:	83 c1 01             	add    $0x1,%ecx
    f78d:	89 c8                	mov    %ecx,%eax
    f78f:	c1 f8 1f             	sar    $0x1f,%eax
    f792:	c1 e8 16             	shr    $0x16,%eax
    f795:	01 c1                	add    %eax,%ecx
    f797:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f79d:	29 c1                	sub    %eax,%ecx
    f79f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f7a3:	83 e0 03             	and    $0x3,%eax
    f7a6:	c1 e0 08             	shl    $0x8,%eax
    f7a9:	09 d0                	or     %edx,%eax
    f7ab:	39 c1                	cmp    %eax,%ecx
    f7ad:	0f 84 e5 03 00 00    	je     fb98 <rlc_UM_reassemble_deliver+0x5e8>
						fsm_printf("[RLC] Not a complet SDU\n");
					}
				}
				else
				{
					SV(countDropPacket)++;
    f7b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f7b6:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    f7bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f7c0:	e8 fc ff ff ff       	call   f7c1 <rlc_UM_reassemble_deliver+0x211>
					if(tbuff->pkt != NULL)
    f7c5:	8b 06                	mov    (%esi),%eax
    f7c7:	85 c0                	test   %eax,%eax
    f7c9:	0f 84 7a fe ff ff    	je     f649 <rlc_UM_reassemble_deliver+0x99>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f7cf:	e8 fc ff ff ff       	call   f7d0 <rlc_UM_reassemble_deliver+0x220>
						tbuff->pkt = NULL;
    f7d4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    f7da:	e9 6a fe ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
    f7df:	90                   	nop
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    f7e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f7e3:	e8 fc ff ff ff       	call   f7e4 <rlc_UM_reassemble_deliver+0x234>

				if(pduhdr->FIsecond==0)
    f7e8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f7eb:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f7ef:	0f 85 6b 02 00 00    	jne    fa60 <rlc_UM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    f7f5:	8b 1e                	mov    (%esi),%ebx
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f7f7:	89 d8                	mov    %ebx,%eax
    f7f9:	e8 fc ff ff ff       	call   f7fa <rlc_UM_reassemble_deliver+0x24a>
    f7fe:	83 f8 01             	cmp    $0x1,%eax
    f801:	0f 86 a7 04 00 00    	jbe    fcae <rlc_UM_reassemble_deliver+0x6fe>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f807:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f80a:	b9 02 00 00 00       	mov    $0x2,%ecx
    f80f:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f815:	e8 fc ff ff ff       	call   f816 <rlc_UM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f81a:	89 d8                	mov    %ebx,%eax
    f81c:	ba 06 00 00 00       	mov    $0x6,%edx
    f821:	e8 fc ff ff ff       	call   f822 <rlc_UM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f826:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f829:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
    f830:	c7 04 24 84 3e 00 00 	movl   $0x3e84,(%esp)
    f837:	e8 fc ff ff ff       	call   f838 <rlc_UM_reassemble_deliver+0x288>
    f83c:	e9 08 fe ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
    f841:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f848:	b8 40 00 00 00       	mov    $0x40,%eax
    f84d:	e8 fc ff ff ff       	call   f84e <rlc_UM_reassemble_deliver+0x29e>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f852:	31 c9                	xor    %ecx,%ecx
    f854:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f856:	89 45 d0             	mov    %eax,-0x30(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f859:	89 04 24             	mov    %eax,(%esp)
    f85c:	b8 01 00 00 00       	mov    $0x1,%eax
    f861:	e8 fc ff ff ff       	call   f862 <rlc_UM_reassemble_deliver+0x2b2>
                
				if(pduhdr->FIfirst==1)
    f866:	8b 5d e8             	mov    -0x18(%ebp),%ebx
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f869:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
                
				if(pduhdr->FIfirst==1)
    f86d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    f871:	0f 84 89 02 00 00    	je     fb00 <rlc_UM_reassemble_deliver+0x550>
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f877:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f87a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    f87e:	66 83 f8 ff          	cmp    $0xffff,%ax
    f882:	74 2d                	je     f8b1 <rlc_UM_reassemble_deliver+0x301>
    f884:	98                   	cwtl   
    f885:	0f b6 13             	movzbl (%ebx),%edx
    f888:	8d 48 01             	lea    0x1(%eax),%ecx
    f88b:	89 c8                	mov    %ecx,%eax
    f88d:	c1 f8 1f             	sar    $0x1f,%eax
    f890:	c1 e8 16             	shr    $0x16,%eax
    f893:	01 c1                	add    %eax,%ecx
    f895:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f89b:	29 c1                	sub    %eax,%ecx
    f89d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f8a1:	83 e0 03             	and    $0x3,%eax
    f8a4:	c1 e0 08             	shl    $0x8,%eax
    f8a7:	09 d0                	or     %edx,%eax
    f8a9:	39 c1                	cmp    %eax,%ecx
    f8ab:	0f 84 10 04 00 00    	je     fcc1 <rlc_UM_reassemble_deliver+0x711>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    f8b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f8b4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    f8bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f8be:	e8 fc ff ff ff       	call   f8bf <rlc_UM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f8c3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f8c6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f8ca:	8b 06                	mov    (%esi),%eax
    f8cc:	e8 fc ff ff ff       	call   f8cd <rlc_UM_reassemble_deliver+0x31d>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f8d1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    f8d5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f8d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f8de:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f8e2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f8e5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f8e8:	7f 47                	jg     f931 <rlc_UM_reassemble_deliver+0x381>
    f8ea:	e9 ab 00 00 00       	jmp    f99a <rlc_UM_reassemble_deliver+0x3ea>
    f8ef:	90                   	nop
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f8f0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f8f6:	b9 02 00 00 00       	mov    $0x2,%ecx
    f8fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f8fe:	e8 fc ff ff ff       	call   f8ff <rlc_UM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f903:	89 d8                	mov    %ebx,%eax
    f905:	ba 06 00 00 00       	mov    $0x6,%edx
    f90a:	e8 fc ff ff ff       	call   f90b <rlc_UM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f90f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f912:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f919:	c7 04 24 20 3f 00 00 	movl   $0x3f20,(%esp)
    f920:	e8 fc ff ff ff       	call   f921 <rlc_UM_reassemble_deliver+0x371>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f925:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f928:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f92c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f92f:	74 67                	je     f998 <rlc_UM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f931:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f934:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f937:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f93c:	89 d8                	mov    %ebx,%eax
    f93e:	e8 fc ff ff ff       	call   f93f <rlc_UM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f943:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f945:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f947:	e8 fc ff ff ff       	call   f948 <rlc_UM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f94c:	8b 07                	mov    (%edi),%eax
    f94e:	89 da                	mov    %ebx,%edx
    f950:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f956:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f959:	89 f0                	mov    %esi,%eax
    f95b:	e8 fc ff ff ff       	call   f95c <rlc_UM_reassemble_deliver+0x3ac>
    f960:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f963:	89 d9                	mov    %ebx,%ecx
    f965:	e8 fc ff ff ff       	call   f966 <rlc_UM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f96a:	8b 07                	mov    (%edi),%eax
    f96c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f96e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f970:	e8 fc ff ff ff       	call   f971 <rlc_UM_reassemble_deliver+0x3c1>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f975:	89 f0                	mov    %esi,%eax
    f977:	e8 fc ff ff ff       	call   f978 <rlc_UM_reassemble_deliver+0x3c8>
    f97c:	83 f8 01             	cmp    $0x1,%eax
    f97f:	0f 87 6b ff ff ff    	ja     f8f0 <rlc_UM_reassemble_deliver+0x340>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f985:	ba 02 00 00 00       	mov    $0x2,%edx
    f98a:	89 f0                	mov    %esi,%eax
    f98c:	e8 fc ff ff ff       	call   f98d <rlc_UM_reassemble_deliver+0x3dd>
    f991:	89 c3                	mov    %eax,%ebx
    f993:	e9 58 ff ff ff       	jmp    f8f0 <rlc_UM_reassemble_deliver+0x340>
    f998:	89 fe                	mov    %edi,%esi
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f99a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f99d:	8b 06                	mov    (%esi),%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f99f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f9a3:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f9a7:	89 d8                	mov    %ebx,%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f9a9:	0f 85 e1 00 00 00    	jne    fa90 <rlc_UM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f9af:	e8 fc ff ff ff       	call   f9b0 <rlc_UM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f9b4:	89 da                	mov    %ebx,%edx
				}
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f9b6:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f9b8:	e8 fc ff ff ff       	call   f9b9 <rlc_UM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f9bd:	8b 06                	mov    (%esi),%eax
    f9bf:	89 da                	mov    %ebx,%edx
    f9c1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f9c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9ca:	89 f8                	mov    %edi,%eax
    f9cc:	e8 fc ff ff ff       	call   f9cd <rlc_UM_reassemble_deliver+0x41d>
    f9d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9d4:	89 d9                	mov    %ebx,%ecx
    f9d6:	e8 fc ff ff ff       	call   f9d7 <rlc_UM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f9db:	8b 06                	mov    (%esi),%eax
    f9dd:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    f9df:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f9e1:	e8 fc ff ff ff       	call   f9e2 <rlc_UM_reassemble_deliver+0x432>
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f9e6:	89 f8                	mov    %edi,%eax
    f9e8:	e8 fc ff ff ff       	call   f9e9 <rlc_UM_reassemble_deliver+0x439>
    f9ed:	83 f8 01             	cmp    $0x1,%eax
    f9f0:	0f 86 a5 02 00 00    	jbe    fc9b <rlc_UM_reassemble_deliver+0x6eb>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f9f6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f9f9:	b9 02 00 00 00       	mov    $0x2,%ecx
    f9fe:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fa04:	e8 fc ff ff ff       	call   fa05 <rlc_UM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fa09:	ba 06 00 00 00       	mov    $0x6,%edx
    fa0e:	89 d8                	mov    %ebx,%eax
    fa10:	e8 fc ff ff ff       	call   fa11 <rlc_UM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fa15:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fa18:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP6\n");				
    fa1f:	c7 04 24 54 3f 00 00 	movl   $0x3f54,(%esp)
    fa26:	e8 fc ff ff ff       	call   fa27 <rlc_UM_reassemble_deliver+0x477>
					if(tbuff->pkt != NULL)
    fa2b:	8b 06                	mov    (%esi),%eax
    fa2d:	85 c0                	test   %eax,%eax
    fa2f:	74 0b                	je     fa3c <rlc_UM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					fsm_printf("[RLC]Not a complet SDU\n");
					if(tbuff->pkt != NULL)
					{
						fsm_pkt_destroy(tbuff->pkt);
    fa31:	e8 fc ff ff ff       	call   fa32 <rlc_UM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    fa36:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
				}
				if(pPduhdrExt != NULL)
    fa3c:	8b 7d d0             	mov    -0x30(%ebp),%edi
    fa3f:	85 ff                	test   %edi,%edi
    fa41:	0f 84 02 fc ff ff    	je     f649 <rlc_UM_reassemble_deliver+0x99>
				{
					fsm_mem_free(pPduhdrExt);
    fa47:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fa4a:	e8 fc ff ff ff       	call   fa4b <rlc_UM_reassemble_deliver+0x49b>
    fa4f:	e9 f5 fb ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
    fa54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			umIns->umRecvWindow10[i]=NULL;
			
		}//end if
	}//end for
}
    fa58:	83 c4 44             	add    $0x44,%esp
    fa5b:	5b                   	pop    %ebx
    fa5c:	5e                   	pop    %esi
    fa5d:	5f                   	pop    %edi
    fa5e:	5d                   	pop    %ebp
    fa5f:	c3                   	ret    
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
				}

				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    fa60:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fa63:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    fa67:	0f b6 13             	movzbl (%ebx),%edx
    fa6a:	83 e0 03             	and    $0x3,%eax
    fa6d:	c1 e0 08             	shl    $0x8,%eax
    fa70:	09 d0                	or     %edx,%eax
    fa72:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fa75:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    fa79:	8b 06                	mov    (%esi),%eax
    fa7b:	89 42 04             	mov    %eax,0x4(%edx)
					fsm_printf("[RLC] Not a complet SDU\n");
    fa7e:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    fa85:	e8 fc ff ff ff       	call   fa86 <rlc_UM_reassemble_deliver+0x4d6>
    fa8a:	e9 ba fb ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
    fa8f:	90                   	nop
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fa90:	e8 fc ff ff ff       	call   fa91 <rlc_UM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    fa95:	89 da                	mov    %ebx,%edx
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    fa97:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fa99:	e8 fc ff ff ff       	call   fa9a <rlc_UM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fa9e:	8b 06                	mov    (%esi),%eax
    faa0:	89 da                	mov    %ebx,%edx
    faa2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    faa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    faab:	89 f8                	mov    %edi,%eax
    faad:	e8 fc ff ff ff       	call   faae <rlc_UM_reassemble_deliver+0x4fe>
    fab2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fab5:	89 d9                	mov    %ebx,%ecx
    fab7:	e8 fc ff ff ff       	call   fab8 <rlc_UM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    fabc:	8b 06                	mov    (%esi),%eax
    fabe:	8b 50 50             	mov    0x50(%eax),%edx
    fac1:	e8 fc ff ff ff       	call   fac2 <rlc_UM_reassemble_deliver+0x512>
                   
					pdu_left->SN_Left = pduhdr->SN;
    fac6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fac9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    facd:	0f b6 13             	movzbl (%ebx),%edx
    fad0:	83 e0 03             	and    $0x3,%eax
    fad3:	c1 e0 08             	shl    $0x8,%eax
    fad6:	09 d0                	or     %edx,%eax
    fad8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fadb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    fadf:	89 7a 04             	mov    %edi,0x4(%edx)
					fsm_printf("[RLC]Not a complet SDU\n");
    fae2:	c7 04 24 d3 07 00 00 	movl   $0x7d3,(%esp)
    fae9:	e8 fc ff ff ff       	call   faea <rlc_UM_reassemble_deliver+0x53a>
					if(tbuff->pkt != NULL)
    faee:	8b 06                	mov    (%esi),%eax
    faf0:	85 c0                	test   %eax,%eax
    faf2:	0f 85 39 ff ff ff    	jne    fa31 <rlc_UM_reassemble_deliver+0x481>
    faf8:	e9 3f ff ff ff       	jmp    fa3c <rlc_UM_reassemble_deliver+0x48c>
    fafd:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    fb00:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fb03:	e8 fc ff ff ff       	call   fb04 <rlc_UM_reassemble_deliver+0x554>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    fb08:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fb0b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    fb0f:	89 d8                	mov    %ebx,%eax
    fb11:	e8 fc ff ff ff       	call   fb12 <rlc_UM_reassemble_deliver+0x562>
					fsm_skb_reserve(new_skb,length);
    fb16:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    fb18:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fb1a:	e8 fc ff ff ff       	call   fb1b <rlc_UM_reassemble_deliver+0x56b>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fb1f:	8b 06                	mov    (%esi),%eax
    fb21:	89 da                	mov    %ebx,%edx
    fb23:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fb29:	89 45 d8             	mov    %eax,-0x28(%ebp)
    fb2c:	89 f8                	mov    %edi,%eax
    fb2e:	e8 fc ff ff ff       	call   fb2f <rlc_UM_reassemble_deliver+0x57f>
    fb33:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fb36:	89 d9                	mov    %ebx,%ecx
    fb38:	e8 fc ff ff ff       	call   fb39 <rlc_UM_reassemble_deliver+0x589>
					fsm_skb_pull(tbuff->pkt,length ) ;
    fb3d:	8b 06                	mov    (%esi),%eax
    fb3f:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    fb41:	89 fb                	mov    %edi,%ebx

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    fb43:	e8 fc ff ff ff       	call   fb44 <rlc_UM_reassemble_deliver+0x594>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fb48:	89 f8                	mov    %edi,%eax
    fb4a:	e8 fc ff ff ff       	call   fb4b <rlc_UM_reassemble_deliver+0x59b>
    fb4f:	83 f8 01             	cmp    $0x1,%eax
    fb52:	0f 86 34 02 00 00    	jbe    fd8c <rlc_UM_reassemble_deliver+0x7dc>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fb58:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fb5b:	b9 02 00 00 00       	mov    $0x2,%ecx
    fb60:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fb66:	e8 fc ff ff ff       	call   fb67 <rlc_UM_reassemble_deliver+0x5b7>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fb6b:	89 d8                	mov    %ebx,%eax
    fb6d:	ba 06 00 00 00       	mov    $0x6,%edx
    fb72:	e8 fc ff ff ff       	call   fb73 <rlc_UM_reassemble_deliver+0x5c3>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fb77:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fb7a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
    fb81:	c7 04 24 ec 3e 00 00 	movl   $0x3eec,(%esp)
    fb88:	e8 fc ff ff ff       	call   fb89 <rlc_UM_reassemble_deliver+0x5d9>
    fb8d:	e9 3f fd ff ff       	jmp    f8d1 <rlc_UM_reassemble_deliver+0x321>
    fb92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    fb98:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    fb9b:	8b 16                	mov    (%esi),%edx
    fb9d:	8b 41 04             	mov    0x4(%ecx),%eax
    fba0:	8b 40 50             	mov    0x50(%eax),%eax
    fba3:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    fba7:	0f b7 d8             	movzwl %ax,%ebx
    fbaa:	89 d8                	mov    %ebx,%eax
    fbac:	e8 fc ff ff ff       	call   fbad <rlc_UM_reassemble_deliver+0x5fd>
					fsm_skb_reserve(new_skb,length);
    fbb1:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    fbb3:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fbb5:	e8 fc ff ff ff       	call   fbb6 <rlc_UM_reassemble_deliver+0x606>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    fbba:	8b 06                	mov    (%esi),%eax
    fbbc:	8b 58 50             	mov    0x50(%eax),%ebx
    fbbf:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fbc5:	89 f8                	mov    %edi,%eax
    fbc7:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fbca:	89 da                	mov    %ebx,%edx
    fbcc:	e8 fc ff ff ff       	call   fbcd <rlc_UM_reassemble_deliver+0x61d>
    fbd1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbd4:	89 d9                	mov    %ebx,%ecx
    fbd6:	e8 fc ff ff ff       	call   fbd7 <rlc_UM_reassemble_deliver+0x627>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fbdb:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fbde:	8b 42 04             	mov    0x4(%edx),%eax
    fbe1:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fbe7:	8b 58 50             	mov    0x50(%eax),%ebx
    fbea:	89 f8                	mov    %edi,%eax
    fbec:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fbef:	89 da                	mov    %ebx,%edx
    fbf1:	e8 fc ff ff ff       	call   fbf2 <rlc_UM_reassemble_deliver+0x642>
    fbf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbf9:	89 d9                	mov    %ebx,%ecx
    fbfb:	e8 fc ff ff ff       	call   fbfc <rlc_UM_reassemble_deliver+0x64c>
					clear_left_pdu(pdu_left);
    fc00:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fc03:	e8 fc ff ff ff       	call   fc04 <rlc_UM_reassemble_deliver+0x654>
					if(tbuff->pkt != NULL)
    fc08:	8b 06                	mov    (%esi),%eax
    fc0a:	85 c0                	test   %eax,%eax
    fc0c:	74 0b                	je     fc19 <rlc_UM_reassemble_deliver+0x669>
					{
						fsm_pkt_destroy(tbuff->pkt);
    fc0e:	e8 fc ff ff ff       	call   fc0f <rlc_UM_reassemble_deliver+0x65f>
						tbuff->pkt = NULL;
    fc13:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    fc19:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fc1c:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    fc20:	75 4c                	jne    fc6e <rlc_UM_reassemble_deliver+0x6be>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fc22:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    fc24:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fc26:	e8 fc ff ff ff       	call   fc27 <rlc_UM_reassemble_deliver+0x677>
    fc2b:	83 f8 01             	cmp    $0x1,%eax
    fc2e:	0f 86 6b 01 00 00    	jbe    fd9f <rlc_UM_reassemble_deliver+0x7ef>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fc34:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fc37:	b9 02 00 00 00       	mov    $0x2,%ecx
    fc3c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fc42:	e8 fc ff ff ff       	call   fc43 <rlc_UM_reassemble_deliver+0x693>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    fc47:	89 d8                	mov    %ebx,%eax
    fc49:	ba 06 00 00 00       	mov    $0x6,%edx
    fc4e:	e8 fc ff ff ff       	call   fc4f <rlc_UM_reassemble_deliver+0x69f>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    fc53:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fc56:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP1\n");
    fc5d:	c7 04 24 50 3e 00 00 	movl   $0x3e50,(%esp)
    fc64:	e8 fc ff ff ff       	call   fc65 <rlc_UM_reassemble_deliver+0x6b5>
    fc69:	e9 db f9 ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    fc6e:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fc71:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    fc75:	0f b6 13             	movzbl (%ebx),%edx
    fc78:	83 e0 03             	and    $0x3,%eax
    fc7b:	c1 e0 08             	shl    $0x8,%eax
    fc7e:	09 d0                	or     %edx,%eax
    fc80:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fc83:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    fc87:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC] Not a complet SDU\n");
    fc8a:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
    fc91:	e8 fc ff ff ff       	call   fc92 <rlc_UM_reassemble_deliver+0x6e2>
    fc96:	e9 ae f9 ff ff       	jmp    f649 <rlc_UM_reassemble_deliver+0x99>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fc9b:	ba 02 00 00 00       	mov    $0x2,%edx
    fca0:	89 f8                	mov    %edi,%eax
    fca2:	e8 fc ff ff ff       	call   fca3 <rlc_UM_reassemble_deliver+0x6f3>
    fca7:	89 c3                	mov    %eax,%ebx
    fca9:	e9 48 fd ff ff       	jmp    f9f6 <rlc_UM_reassemble_deliver+0x446>
				{
					skb = tbuff->pkt;
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fcae:	89 d8                	mov    %ebx,%eax
    fcb0:	ba 02 00 00 00       	mov    $0x2,%edx
    fcb5:	e8 fc ff ff ff       	call   fcb6 <rlc_UM_reassemble_deliver+0x706>
    fcba:	89 c3                	mov    %eax,%ebx
    fcbc:	e9 46 fb ff ff       	jmp    f807 <rlc_UM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    fcc1:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fcc4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    fcc7:	8b 42 04             	mov    0x4(%edx),%eax
    fcca:	8b 40 50             	mov    0x50(%eax),%eax
    fccd:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    fcd1:	0f b7 d8             	movzwl %ax,%ebx
    fcd4:	89 d8                	mov    %ebx,%eax
    fcd6:	e8 fc ff ff ff       	call   fcd7 <rlc_UM_reassemble_deliver+0x727>
						fsm_skb_reserve(new_skb,length);
    fcdb:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    fcdd:	89 c7                	mov    %eax,%edi
						fsm_skb_reserve(new_skb,length);
    fcdf:	e8 fc ff ff ff       	call   fce0 <rlc_UM_reassemble_deliver+0x730>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    fce4:	8b 06                	mov    (%esi),%eax
    fce6:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fcec:	89 45 d8             	mov    %eax,-0x28(%ebp)
    fcef:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fcf2:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    fcf6:	89 f8                	mov    %edi,%eax
    fcf8:	89 da                	mov    %ebx,%edx
    fcfa:	e8 fc ff ff ff       	call   fcfb <rlc_UM_reassemble_deliver+0x74b>
    fcff:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fd02:	89 d9                	mov    %ebx,%ecx
    fd04:	e8 fc ff ff ff       	call   fd05 <rlc_UM_reassemble_deliver+0x755>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fd09:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fd0c:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    fd10:	8b 06                	mov    (%esi),%eax
    fd12:	e8 fc ff ff ff       	call   fd13 <rlc_UM_reassemble_deliver+0x763>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fd17:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fd1a:	8b 42 04             	mov    0x4(%edx),%eax
    fd1d:	8b 58 50             	mov    0x50(%eax),%ebx
    fd20:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fd26:	89 f8                	mov    %edi,%eax
    fd28:	89 55 d8             	mov    %edx,-0x28(%ebp)
    fd2b:	89 da                	mov    %ebx,%edx
    fd2d:	e8 fc ff ff ff       	call   fd2e <rlc_UM_reassemble_deliver+0x77e>
    fd32:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fd35:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
    fd37:	89 fb                	mov    %edi,%ebx
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fd39:	e8 fc ff ff ff       	call   fd3a <rlc_UM_reassemble_deliver+0x78a>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fd3e:	89 f8                	mov    %edi,%eax
    fd40:	e8 fc ff ff ff       	call   fd41 <rlc_UM_reassemble_deliver+0x791>
    fd45:	83 f8 01             	cmp    $0x1,%eax
    fd48:	76 68                	jbe    fdb2 <rlc_UM_reassemble_deliver+0x802>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fd4a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fd4d:	b9 02 00 00 00       	mov    $0x2,%ecx
    fd52:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fd58:	e8 fc ff ff ff       	call   fd59 <rlc_UM_reassemble_deliver+0x7a9>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    fd5d:	ba 06 00 00 00       	mov    $0x6,%edx
    fd62:	89 d8                	mov    %ebx,%eax
    fd64:	e8 fc ff ff ff       	call   fd65 <rlc_UM_reassemble_deliver+0x7b5>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    fd69:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fd6c:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP3\n");
    fd73:	c7 04 24 b8 3e 00 00 	movl   $0x3eb8,(%esp)
    fd7a:	e8 fc ff ff ff       	call   fd7b <rlc_UM_reassemble_deliver+0x7cb>
						
						clear_left_pdu(pdu_left);
    fd7f:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fd82:	e8 fc ff ff ff       	call   fd83 <rlc_UM_reassemble_deliver+0x7d3>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    fd87:	e9 45 fb ff ff       	jmp    f8d1 <rlc_UM_reassemble_deliver+0x321>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fd8c:	ba 02 00 00 00       	mov    $0x2,%edx
    fd91:	89 f8                	mov    %edi,%eax
    fd93:	e8 fc ff ff ff       	call   fd94 <rlc_UM_reassemble_deliver+0x7e4>
    fd98:	89 c3                	mov    %eax,%ebx
    fd9a:	e9 b9 fd ff ff       	jmp    fb58 <rlc_UM_reassemble_deliver+0x5a8>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fd9f:	ba 02 00 00 00       	mov    $0x2,%edx
    fda4:	89 f8                	mov    %edi,%eax
    fda6:	e8 fc ff ff ff       	call   fda7 <rlc_UM_reassemble_deliver+0x7f7>
    fdab:	89 c3                	mov    %eax,%ebx
    fdad:	e9 82 fe ff ff       	jmp    fc34 <rlc_UM_reassemble_deliver+0x684>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fdb2:	ba 02 00 00 00       	mov    $0x2,%edx
    fdb7:	89 f8                	mov    %edi,%eax
    fdb9:	e8 fc ff ff ff       	call   fdba <rlc_UM_reassemble_deliver+0x80a>
    fdbe:	89 c3                	mov    %eax,%ebx
    fdc0:	eb 88                	jmp    fd4a <rlc_UM_reassemble_deliver+0x79a>
    fdc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    fdc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000fdd0 <rlc_UM5_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fdd0:	55                   	push   %ebp
    fdd1:	89 e5                	mov    %esp,%ebp
    fdd3:	57                   	push   %edi
    fdd4:	56                   	push   %esi
    fdd5:	53                   	push   %ebx
    fdd6:	83 ec 34             	sub    $0x34,%esp
    fdd9:	e8 fc ff ff ff       	call   fdda <rlc_UM5_reassemble_deliver+0xa>
    fdde:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    fde1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	SV_PTR_GET(rlc_mac_sv);
    fde4:	e8 fc ff ff ff       	call   fde5 <rlc_UM5_reassemble_deliver+0x15>
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fde9:	8b 55 d8             	mov    -0x28(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fdec:	8b 4d d8             	mov    -0x28(%ebp),%ecx
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
	SV_PTR_GET(rlc_mac_sv);
    fdef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fdf2:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    fdf9:	83 c0 01             	add    $0x1,%eax
    fdfc:	89 c2                	mov    %eax,%edx
    fdfe:	c1 fa 1f             	sar    $0x1f,%edx
    fe01:	c1 ea 1b             	shr    $0x1b,%edx
    fe04:	01 d0                	add    %edx,%eax
    fe06:	83 e0 1f             	and    $0x1f,%eax
    fe09:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fe0b:	0f b7 c0             	movzwl %ax,%eax
    fe0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    fe11:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    fe18:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fe1b:	8d 50 20             	lea    0x20(%eax),%edx
    fe1e:	89 d0                	mov    %edx,%eax
    fe20:	c1 f8 1f             	sar    $0x1f,%eax
    fe23:	c1 e8 1b             	shr    $0x1b,%eax
    fe26:	01 c2                	add    %eax,%edx
    fe28:	83 e2 1f             	and    $0x1f,%edx
    fe2b:	29 c2                	sub    %eax,%edx
    fe2d:	85 d2                	test   %edx,%edx
    fe2f:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fe32:	0f 8e d8 03 00 00    	jle    10210 <rlc_UM5_reassemble_deliver+0x440>
    fe38:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fe3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fe3e:	e9 8d 00 00 00       	jmp    fed0 <rlc_UM5_reassemble_deliver+0x100>
    fe43:	90                   	nop
    fe44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    fe48:	84 d2                	test   %dl,%dl
    fe4a:	0f 84 38 01 00 00    	je     ff88 <rlc_UM5_reassemble_deliver+0x1b8>
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;
				}
			}
			else if(pduhdr->E==1)
    fe50:	a8 20                	test   $0x20,%al
    fe52:	0f 85 98 01 00 00    	jne    fff0 <rlc_UM5_reassemble_deliver+0x220>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    fe58:	8b 46 14             	mov    0x14(%esi),%eax
    fe5b:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    fe5e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    fe61:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    fe63:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    fe65:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    fe6c:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    fe73:	e8 fc ff ff ff       	call   fe74 <rlc_UM5_reassemble_deliver+0xa4>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    fe78:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fe7b:	85 c0                	test   %eax,%eax
    fe7d:	74 08                	je     fe87 <rlc_UM5_reassemble_deliver+0xb7>
			{
				fsm_mem_free(icimsg);
    fe7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fe82:	e8 fc ff ff ff       	call   fe83 <rlc_UM5_reassemble_deliver+0xb3>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    fe87:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    fe8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fe8d:	c7 84 88 b8 00 00 00 	movl   $0x0,0xb8(%eax,%ecx,4)
    fe94:	00 00 00 00 
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fe98:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fe9b:	83 c2 01             	add    $0x1,%edx
    fe9e:	89 d0                	mov    %edx,%eax
    fea0:	c1 f8 1f             	sar    $0x1f,%eax
    fea3:	c1 e8 1b             	shr    $0x1b,%eax
    fea6:	01 c2                	add    %eax,%edx
    fea8:	83 e2 1f             	and    $0x1f,%edx
    feab:	29 c2                	sub    %eax,%edx
    fead:	89 d0                	mov    %edx,%eax
    feaf:	2b 45 c8             	sub    -0x38(%ebp),%eax
    feb2:	89 55 f0             	mov    %edx,-0x10(%ebp)
    feb5:	83 c0 20             	add    $0x20,%eax
    feb8:	89 c2                	mov    %eax,%edx
    feba:	c1 fa 1f             	sar    $0x1f,%edx
    febd:	c1 ea 1b             	shr    $0x1b,%edx
    fec0:	01 d0                	add    %edx,%eax
    fec2:	83 e0 1f             	and    $0x1f,%eax
    fec5:	29 d0                	sub    %edx,%eax
    fec7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    feca:	0f 8d 40 03 00 00    	jge    10210 <rlc_UM5_reassemble_deliver+0x440>
	{
		if(umIns->umRecvWindow5[i] != NULL)
    fed0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fed3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fed6:	8b 74 90 38          	mov    0x38(%eax,%edx,4),%esi
    feda:	85 f6                	test   %esi,%esi
    fedc:	74 ba                	je     fe98 <rlc_UM5_reassemble_deliver+0xc8>
		{

			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    fede:	8b 06                	mov    (%esi),%eax
    fee0:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    fee6:	b8 02 00 00 00       	mov    $0x2,%eax
    feeb:	e8 fc ff ff ff       	call   feec <rlc_UM5_reassemble_deliver+0x11c>
    fef0:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    fef3:	8b 43 02             	mov    0x2(%ebx),%eax
    fef6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fef9:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    fefb:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    feff:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    ff02:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ff04:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    ff09:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
    ff0f:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ff12:	e8 fc ff ff ff       	call   ff13 <rlc_UM5_reassemble_deliver+0x143>
          
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    ff17:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff1a:	0f b6 02             	movzbl (%edx),%eax
    ff1d:	89 c2                	mov    %eax,%edx
    ff1f:	83 e2 a0             	and    $0xffffffa0,%edx
    ff22:	80 fa 80             	cmp    $0x80,%dl
    ff25:	0f 85 1d ff ff ff    	jne    fe48 <rlc_UM5_reassemble_deliver+0x78>
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
    ff2b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    ff2e:	0f b7 11             	movzwl (%ecx),%edx
    ff31:	66 83 fa ff          	cmp    $0xffff,%dx
    ff35:	74 20                	je     ff57 <rlc_UM5_reassemble_deliver+0x187>
    ff37:	0f bf d2             	movswl %dx,%edx
    ff3a:	83 e0 1f             	and    $0x1f,%eax
    ff3d:	83 c2 01             	add    $0x1,%edx
    ff40:	89 d1                	mov    %edx,%ecx
    ff42:	c1 f9 1f             	sar    $0x1f,%ecx
    ff45:	c1 e9 1b             	shr    $0x1b,%ecx
    ff48:	01 ca                	add    %ecx,%edx
    ff4a:	83 e2 1f             	and    $0x1f,%edx
    ff4d:	29 ca                	sub    %ecx,%edx
    ff4f:	39 c2                	cmp    %eax,%edx
    ff51:	0f 84 c1 03 00 00    	je     10318 <rlc_UM5_reassemble_deliver+0x548>
						pdu_left->sduLeft = new_skb;
					}
				}
				else
				{
					SV(countDropPacket)++;
    ff57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ff5a:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    ff61:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ff64:	e8 fc ff ff ff       	call   ff65 <rlc_UM5_reassemble_deliver+0x195>
					if(tbuff->pkt != NULL)
    ff69:	8b 06                	mov    (%esi),%eax
    ff6b:	85 c0                	test   %eax,%eax
    ff6d:	0f 84 e5 fe ff ff    	je     fe58 <rlc_UM5_reassemble_deliver+0x88>
					{
						fsm_pkt_destroy(tbuff->pkt);
    ff73:	e8 fc ff ff ff       	call   ff74 <rlc_UM5_reassemble_deliver+0x1a4>
						tbuff->pkt = NULL;
    ff78:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    ff7e:	e9 d5 fe ff ff       	jmp    fe58 <rlc_UM5_reassemble_deliver+0x88>
    ff83:	90                   	nop
    ff84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    ff88:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ff8b:	e8 fc ff ff ff       	call   ff8c <rlc_UM5_reassemble_deliver+0x1bc>

				if(pduhdr->FIsecond==0)
    ff90:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff93:	0f b6 02             	movzbl (%edx),%eax
    ff96:	a8 40                	test   $0x40,%al
    ff98:	0f 85 7a 02 00 00    	jne    10218 <rlc_UM5_reassemble_deliver+0x448>
				{

					skb = tbuff->pkt;
    ff9e:	8b 1e                	mov    (%esi),%ebx
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    ffa0:	89 d8                	mov    %ebx,%eax
    ffa2:	e8 fc ff ff ff       	call   ffa3 <rlc_UM5_reassemble_deliver+0x1d3>
    ffa7:	83 f8 01             	cmp    $0x1,%eax
    ffaa:	0f 86 35 04 00 00    	jbe    103e5 <rlc_UM5_reassemble_deliver+0x615>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ffb0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ffb3:	b9 02 00 00 00       	mov    $0x2,%ecx
    ffb8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ffbe:	e8 fc ff ff ff       	call   ffbf <rlc_UM5_reassemble_deliver+0x1ef>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ffc3:	89 d8                	mov    %ebx,%eax
    ffc5:	ba 06 00 00 00       	mov    $0x6,%edx
    ffca:	e8 fc ff ff ff       	call   ffcb <rlc_UM5_reassemble_deliver+0x1fb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ffcf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ffd2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    ffd9:	c7 04 24 88 3f 00 00 	movl   $0x3f88,(%esp)
    ffe0:	e8 fc ff ff ff       	call   ffe1 <rlc_UM5_reassemble_deliver+0x211>
    ffe5:	e9 6e fe ff ff       	jmp    fe58 <rlc_UM5_reassemble_deliver+0x88>
    ffea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fff0:	b8 40 00 00 00       	mov    $0x40,%eax
    fff5:	e8 fc ff ff ff       	call   fff6 <rlc_UM5_reassemble_deliver+0x226>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fffa:	31 c9                	xor    %ecx,%ecx
    fffc:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fffe:	89 45 dc             	mov    %eax,-0x24(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
   10001:	89 04 24             	mov    %eax,(%esp)
   10004:	b8 01 00 00 00       	mov    $0x1,%eax
   10009:	e8 fc ff ff ff       	call   1000a <rlc_UM5_reassemble_deliver+0x23a>
   1000e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
                
				if(pduhdr->FIfirst==1)
   10012:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10015:	0f b6 08             	movzbl (%eax),%ecx
   10018:	84 c9                	test   %cl,%cl
   1001a:	0f 89 60 02 00 00    	jns    10280 <rlc_UM5_reassemble_deliver+0x4b0>
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
   10020:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10023:	0f b7 02             	movzwl (%edx),%eax
   10026:	66 83 f8 ff          	cmp    $0xffff,%ax
   1002a:	74 20                	je     1004c <rlc_UM5_reassemble_deliver+0x27c>
   1002c:	98                   	cwtl   
   1002d:	83 e1 1f             	and    $0x1f,%ecx
   10030:	83 c0 01             	add    $0x1,%eax
   10033:	89 c2                	mov    %eax,%edx
   10035:	c1 fa 1f             	sar    $0x1f,%edx
   10038:	c1 ea 17             	shr    $0x17,%edx
   1003b:	01 d0                	add    %edx,%eax
   1003d:	25 ff 01 00 00       	and    $0x1ff,%eax
   10042:	29 d0                	sub    %edx,%eax
   10044:	39 c8                	cmp    %ecx,%eax
   10046:	0f 84 ac 03 00 00    	je     103f8 <rlc_UM5_reassemble_deliver+0x628>
						clear_left_pdu(pdu_left);
                        
					}
					else
					{
						SV(countDropPacket)++;
   1004c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1004f:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
   10056:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10059:	e8 fc ff ff ff       	call   1005a <rlc_UM5_reassemble_deliver+0x28a>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
   1005e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10061:	0f b7 50 20          	movzwl 0x20(%eax),%edx
   10065:	8b 06                	mov    (%esi),%eax
   10067:	e8 fc ff ff ff       	call   10068 <rlc_UM5_reassemble_deliver+0x298>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
   1006c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10070:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
   10072:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   10079:	8d 54 00 fe          	lea    -0x2(%eax,%eax,1),%edx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
   1007d:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
   10080:	89 55 d0             	mov    %edx,-0x30(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
   10083:	7f 4c                	jg     100d1 <rlc_UM5_reassemble_deliver+0x301>
   10085:	e9 b0 00 00 00       	jmp    1013a <rlc_UM5_reassemble_deliver+0x36a>
   1008a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   10090:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10093:	b9 02 00 00 00       	mov    $0x2,%ecx
   10098:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1009e:	e8 fc ff ff ff       	call   1009f <rlc_UM5_reassemble_deliver+0x2cf>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   100a3:	ba 06 00 00 00       	mov    $0x6,%edx
   100a8:	89 d8                	mov    %ebx,%eax
   100aa:	e8 fc ff ff ff       	call   100ab <rlc_UM5_reassemble_deliver+0x2db>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   100af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   100b2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   100b9:	c7 04 24 88 3f 00 00 	movl   $0x3f88,(%esp)
   100c0:	e8 fc ff ff ff       	call   100c1 <rlc_UM5_reassemble_deliver+0x2f1>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
   100c5:	8b 55 d0             	mov    -0x30(%ebp),%edx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   100c8:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
   100cc:	39 55 ec             	cmp    %edx,-0x14(%ebp)
   100cf:	74 67                	je     10138 <rlc_UM5_reassemble_deliver+0x368>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
   100d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   100d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   100d7:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
   100dc:	89 d8                	mov    %ebx,%eax
   100de:	e8 fc ff ff ff       	call   100df <rlc_UM5_reassemble_deliver+0x30f>

					fsm_skb_reserve(new_skb,length);
   100e3:	89 da                	mov    %ebx,%edx
                
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
   100e5:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
   100e7:	e8 fc ff ff ff       	call   100e8 <rlc_UM5_reassemble_deliver+0x318>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   100ec:	8b 07                	mov    (%edi),%eax
   100ee:	89 da                	mov    %ebx,%edx
   100f0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   100f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
   100f9:	89 f0                	mov    %esi,%eax
   100fb:	e8 fc ff ff ff       	call   100fc <rlc_UM5_reassemble_deliver+0x32c>
   10100:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10103:	89 d9                	mov    %ebx,%ecx
   10105:	e8 fc ff ff ff       	call   10106 <rlc_UM5_reassemble_deliver+0x336>
					fsm_skb_pull(tbuff->pkt,length ) ;
   1010a:	8b 07                	mov    (%edi),%eax
   1010c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
   1010e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
   10110:	e8 fc ff ff ff       	call   10111 <rlc_UM5_reassemble_deliver+0x341>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10115:	89 f0                	mov    %esi,%eax
   10117:	e8 fc ff ff ff       	call   10118 <rlc_UM5_reassemble_deliver+0x348>
   1011c:	83 f8 01             	cmp    $0x1,%eax
   1011f:	0f 87 6b ff ff ff    	ja     10090 <rlc_UM5_reassemble_deliver+0x2c0>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   10125:	ba 02 00 00 00       	mov    $0x2,%edx
   1012a:	89 f0                	mov    %esi,%eax
   1012c:	e8 fc ff ff ff       	call   1012d <rlc_UM5_reassemble_deliver+0x35d>
   10131:	89 c3                	mov    %eax,%ebx
   10133:	e9 58 ff ff ff       	jmp    10090 <rlc_UM5_reassemble_deliver+0x2c0>
   10138:	89 fe                	mov    %edi,%esi
                    
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
   1013a:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   1013c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   1013f:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   10143:	f6 01 40             	testb  $0x40,(%ecx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10146:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   10148:	0f 85 e2 00 00 00    	jne    10230 <rlc_UM5_reassemble_deliver+0x460>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   1014e:	e8 fc ff ff ff       	call   1014f <rlc_UM5_reassemble_deliver+0x37f>
					fsm_skb_reserve(new_skb,length);
   10153:	89 da                	mov    %ebx,%edx
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10155:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
   10157:	e8 fc ff ff ff       	call   10158 <rlc_UM5_reassemble_deliver+0x388>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1015c:	8b 06                	mov    (%esi),%eax
   1015e:	89 da                	mov    %ebx,%edx
   10160:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10166:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10169:	89 f8                	mov    %edi,%eax
   1016b:	e8 fc ff ff ff       	call   1016c <rlc_UM5_reassemble_deliver+0x39c>
   10170:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10173:	89 d9                	mov    %ebx,%ecx
   10175:	e8 fc ff ff ff       	call   10176 <rlc_UM5_reassemble_deliver+0x3a6>
					fsm_skb_pull(tbuff->pkt,length) ;
   1017a:	8b 06                	mov    (%esi),%eax
   1017c:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
   1017e:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
   10180:	e8 fc ff ff ff       	call   10181 <rlc_UM5_reassemble_deliver+0x3b1>
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10185:	89 f8                	mov    %edi,%eax
   10187:	e8 fc ff ff ff       	call   10188 <rlc_UM5_reassemble_deliver+0x3b8>
   1018c:	83 f8 01             	cmp    $0x1,%eax
   1018f:	0f 86 1f 02 00 00    	jbe    103b4 <rlc_UM5_reassemble_deliver+0x5e4>
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
			    	}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   10195:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10198:	b9 02 00 00 00       	mov    $0x2,%ecx
   1019d:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   101a3:	e8 fc ff ff ff       	call   101a4 <rlc_UM5_reassemble_deliver+0x3d4>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   101a8:	89 d8                	mov    %ebx,%eax
   101aa:	ba 06 00 00 00       	mov    $0x6,%edx
   101af:	e8 fc ff ff ff       	call   101b0 <rlc_UM5_reassemble_deliver+0x3e0>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   101b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   101b7:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");                  
   101be:	c7 04 24 88 3f 00 00 	movl   $0x3f88,(%esp)
   101c5:	e8 fc ff ff ff       	call   101c6 <rlc_UM5_reassemble_deliver+0x3f6>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   101ca:	8b 56 10             	mov    0x10(%esi),%edx
   101cd:	8b 46 14             	mov    0x14(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   101d0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   101d3:	89 10                	mov    %edx,(%eax)
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
   101d5:	8b 06                	mov    (%esi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   101d7:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
   101de:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
   101e5:	e8 fc ff ff ff       	call   101e6 <rlc_UM5_reassemble_deliver+0x416>
					tbuff->pkt = NULL;
					fsm_mem_free(tbuff);
   101ea:	89 f0                	mov    %esi,%eax
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
					tbuff->pkt = NULL;
   101ec:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(tbuff);
   101f2:	e8 fc ff ff ff       	call   101f3 <rlc_UM5_reassemble_deliver+0x423>
					tbuff = NULL;
				}
				if(pPduhdrExt != NULL)
   101f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   101fa:	85 c0                	test   %eax,%eax
   101fc:	0f 84 76 fc ff ff    	je     fe78 <rlc_UM5_reassemble_deliver+0xa8>
				{
					fsm_mem_free(pPduhdrExt);
   10202:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10205:	e8 fc ff ff ff       	call   10206 <rlc_UM5_reassemble_deliver+0x436>
   1020a:	e9 69 fc ff ff       	jmp    fe78 <rlc_UM5_reassemble_deliver+0xa8>
   1020f:	90                   	nop
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
   10210:	83 c4 34             	add    $0x34,%esp
   10213:	5b                   	pop    %ebx
   10214:	5e                   	pop    %esi
   10215:	5f                   	pop    %edi
   10216:	5d                   	pop    %ebp
   10217:	c3                   	ret    
					tbuff=NULL;
				}

				else
				{
					pdu_left->SN5_Left = pduhdr->SN;
   10218:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1021b:	83 e0 1f             	and    $0x1f,%eax
   1021e:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft=tbuff->pkt;
   10221:	8b 06                	mov    (%esi),%eax
   10223:	89 42 04             	mov    %eax,0x4(%edx)
   10226:	e9 2d fc ff ff       	jmp    fe58 <rlc_UM5_reassemble_deliver+0x88>
   1022b:	90                   	nop
   1022c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10230:	e8 fc ff ff ff       	call   10231 <rlc_UM5_reassemble_deliver+0x461>
					fsm_skb_reserve(new_skb,length);
   10235:	89 da                	mov    %ebx,%edx
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10237:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
   10239:	e8 fc ff ff ff       	call   1023a <rlc_UM5_reassemble_deliver+0x46a>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1023e:	8b 06                	mov    (%esi),%eax
   10240:	89 da                	mov    %ebx,%edx
   10242:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10248:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1024b:	89 f8                	mov    %edi,%eax
   1024d:	e8 fc ff ff ff       	call   1024e <rlc_UM5_reassemble_deliver+0x47e>
   10252:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10255:	89 d9                	mov    %ebx,%ecx
   10257:	e8 fc ff ff ff       	call   10258 <rlc_UM5_reassemble_deliver+0x488>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
   1025c:	8b 06                	mov    (%esi),%eax
   1025e:	8b 50 50             	mov    0x50(%eax),%edx
   10261:	e8 fc ff ff ff       	call   10262 <rlc_UM5_reassemble_deliver+0x492>
                    
					pdu_left->SN5_Left = pduhdr->SN;
   10266:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10269:	0f b6 02             	movzbl (%edx),%eax
   1026c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1026f:	83 e0 1f             	and    $0x1f,%eax
   10272:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft = new_skb;
   10275:	89 7a 04             	mov    %edi,0x4(%edx)
   10278:	e9 4d ff ff ff       	jmp    101ca <rlc_UM5_reassemble_deliver+0x3fa>
   1027d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
   10280:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10283:	e8 fc ff ff ff       	call   10284 <rlc_UM5_reassemble_deliver+0x4b4>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10288:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1028b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1028f:	89 d8                	mov    %ebx,%eax
   10291:	e8 fc ff ff ff       	call   10292 <rlc_UM5_reassemble_deliver+0x4c2>

					fsm_skb_reserve(new_skb,length);
   10296:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10298:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   1029a:	e8 fc ff ff ff       	call   1029b <rlc_UM5_reassemble_deliver+0x4cb>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1029f:	8b 06                	mov    (%esi),%eax
   102a1:	89 da                	mov    %ebx,%edx
   102a3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   102a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
   102ac:	89 f8                	mov    %edi,%eax
   102ae:	e8 fc ff ff ff       	call   102af <rlc_UM5_reassemble_deliver+0x4df>
   102b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
   102b6:	89 d9                	mov    %ebx,%ecx
   102b8:	e8 fc ff ff ff       	call   102b9 <rlc_UM5_reassemble_deliver+0x4e9>
					fsm_skb_pull(tbuff->pkt,length ) ;
   102bd:	8b 06                	mov    (%esi),%eax
   102bf:	89 da                	mov    %ebx,%edx
					skb = new_skb;
   102c1:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
   102c3:	e8 fc ff ff ff       	call   102c4 <rlc_UM5_reassemble_deliver+0x4f4>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   102c8:	89 f8                	mov    %edi,%eax
   102ca:	e8 fc ff ff ff       	call   102cb <rlc_UM5_reassemble_deliver+0x4fb>
   102cf:	83 f8 01             	cmp    $0x1,%eax
   102d2:	0f 86 f7 01 00 00    	jbe    104cf <rlc_UM5_reassemble_deliver+0x6ff>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   102d8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   102db:	b9 02 00 00 00       	mov    $0x2,%ecx
   102e0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   102e6:	e8 fc ff ff ff       	call   102e7 <rlc_UM5_reassemble_deliver+0x517>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   102eb:	89 d8                	mov    %ebx,%eax
   102ed:	ba 06 00 00 00       	mov    $0x6,%edx
   102f2:	e8 fc ff ff ff       	call   102f3 <rlc_UM5_reassemble_deliver+0x523>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   102f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   102fa:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   10301:	c7 04 24 88 3f 00 00 	movl   $0x3f88,(%esp)
   10308:	e8 fc ff ff ff       	call   10309 <rlc_UM5_reassemble_deliver+0x539>
   1030d:	e9 5a fd ff ff       	jmp    1006c <rlc_UM5_reassemble_deliver+0x29c>
   10312:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
   10318:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
   1031b:	8b 16                	mov    (%esi),%edx
   1031d:	8b 41 04             	mov    0x4(%ecx),%eax
   10320:	8b 40 50             	mov    0x50(%eax),%eax
   10323:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
   10327:	0f b7 d8             	movzwl %ax,%ebx
   1032a:	89 d8                	mov    %ebx,%eax
   1032c:	e8 fc ff ff ff       	call   1032d <rlc_UM5_reassemble_deliver+0x55d>

					fsm_skb_reserve(new_skb,length);
   10331:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
   10333:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   10335:	e8 fc ff ff ff       	call   10336 <rlc_UM5_reassemble_deliver+0x566>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
   1033a:	8b 06                	mov    (%esi),%eax
   1033c:	8b 58 50             	mov    0x50(%eax),%ebx
   1033f:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10345:	89 f8                	mov    %edi,%eax
   10347:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1034a:	89 da                	mov    %ebx,%edx
   1034c:	e8 fc ff ff ff       	call   1034d <rlc_UM5_reassemble_deliver+0x57d>
   10351:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10354:	89 d9                	mov    %ebx,%ecx
   10356:	e8 fc ff ff ff       	call   10357 <rlc_UM5_reassemble_deliver+0x587>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1035b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1035e:	8b 42 04             	mov    0x4(%edx),%eax
   10361:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10367:	8b 58 50             	mov    0x50(%eax),%ebx
   1036a:	89 f8                	mov    %edi,%eax
   1036c:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1036f:	89 da                	mov    %ebx,%edx
   10371:	e8 fc ff ff ff       	call   10372 <rlc_UM5_reassemble_deliver+0x5a2>
   10376:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10379:	89 d9                	mov    %ebx,%ecx
   1037b:	e8 fc ff ff ff       	call   1037c <rlc_UM5_reassemble_deliver+0x5ac>
					clear_left_pdu(pdu_left);
   10380:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10383:	e8 fc ff ff ff       	call   10384 <rlc_UM5_reassemble_deliver+0x5b4>
					if(tbuff->pkt != NULL)
   10388:	8b 06                	mov    (%esi),%eax
   1038a:	85 c0                	test   %eax,%eax
   1038c:	74 0b                	je     10399 <rlc_UM5_reassemble_deliver+0x5c9>
					{
						fsm_pkt_destroy(tbuff->pkt);
   1038e:	e8 fc ff ff ff       	call   1038f <rlc_UM5_reassemble_deliver+0x5bf>
						tbuff->pkt = NULL;
   10393:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
   10399:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1039c:	0f b6 01             	movzbl (%ecx),%eax
   1039f:	a8 40                	test   $0x40,%al
   103a1:	74 24                	je     103c7 <rlc_UM5_reassemble_deliver+0x5f7>
						SV(countSendToUpper)++;
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n"); 
					}
					else
					{
						pdu_left->SN5_Left = pduhdr->SN;
   103a3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   103a6:	83 e0 1f             	and    $0x1f,%eax
   103a9:	66 89 02             	mov    %ax,(%edx)
						pdu_left->sduLeft = new_skb;
   103ac:	89 7a 04             	mov    %edi,0x4(%edx)
   103af:	e9 a4 fa ff ff       	jmp    fe58 <rlc_UM5_reassemble_deliver+0x88>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   103b4:	ba 02 00 00 00       	mov    $0x2,%edx
   103b9:	89 f8                	mov    %edi,%eax
   103bb:	e8 fc ff ff ff       	call   103bc <rlc_UM5_reassemble_deliver+0x5ec>
   103c0:	89 c3                	mov    %eax,%ebx
   103c2:	e9 ce fd ff ff       	jmp    10195 <rlc_UM5_reassemble_deliver+0x3c5>
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   103c7:	ba 06 00 00 00       	mov    $0x6,%edx
   103cc:	89 f8                	mov    %edi,%eax
   103ce:	e8 fc ff ff ff       	call   103cf <rlc_UM5_reassemble_deliver+0x5ff>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   103d3:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
   103d5:	89 fb                	mov    %edi,%ebx
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   103d7:	e8 fc ff ff ff       	call   103d8 <rlc_UM5_reassemble_deliver+0x608>
   103dc:	83 f8 01             	cmp    $0x1,%eax
   103df:	0f 87 cb fb ff ff    	ja     ffb0 <rlc_UM5_reassemble_deliver+0x1e0>

					skb = tbuff->pkt;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   103e5:	89 d8                	mov    %ebx,%eax
   103e7:	ba 02 00 00 00       	mov    $0x2,%edx
   103ec:	e8 fc ff ff ff       	call   103ed <rlc_UM5_reassemble_deliver+0x61d>
   103f1:	89 c3                	mov    %eax,%ebx
   103f3:	e9 b8 fb ff ff       	jmp    ffb0 <rlc_UM5_reassemble_deliver+0x1e0>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
   103f8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   103fb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   103fe:	8b 42 04             	mov    0x4(%edx),%eax
   10401:	8b 40 50             	mov    0x50(%eax),%eax
   10404:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
   10408:	0f b7 d8             	movzwl %ax,%ebx
   1040b:	89 d8                	mov    %ebx,%eax
   1040d:	e8 fc ff ff ff       	call   1040e <rlc_UM5_reassemble_deliver+0x63e>

						fsm_skb_reserve(new_skb,length);
   10412:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
   10414:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
   10416:	e8 fc ff ff ff       	call   10417 <rlc_UM5_reassemble_deliver+0x647>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
   1041b:	8b 06                	mov    (%esi),%eax
   1041d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10423:	89 45 e0             	mov    %eax,-0x20(%ebp)
   10426:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10429:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1042d:	89 f8                	mov    %edi,%eax
   1042f:	89 da                	mov    %ebx,%edx
   10431:	e8 fc ff ff ff       	call   10432 <rlc_UM5_reassemble_deliver+0x662>
   10436:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10439:	89 d9                	mov    %ebx,%ecx
   1043b:	e8 fc ff ff ff       	call   1043c <rlc_UM5_reassemble_deliver+0x66c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
   10440:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10443:	0f b7 50 20          	movzwl 0x20(%eax),%edx
   10447:	8b 06                	mov    (%esi),%eax
   10449:	e8 fc ff ff ff       	call   1044a <rlc_UM5_reassemble_deliver+0x67a>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1044e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10451:	8b 42 04             	mov    0x4(%edx),%eax
   10454:	8b 58 50             	mov    0x50(%eax),%ebx
   10457:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   1045d:	89 f8                	mov    %edi,%eax
   1045f:	89 55 e0             	mov    %edx,-0x20(%ebp)
   10462:	89 da                	mov    %ebx,%edx
   10464:	e8 fc ff ff ff       	call   10465 <rlc_UM5_reassemble_deliver+0x695>
   10469:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1046c:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
   1046e:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   10470:	e8 fc ff ff ff       	call   10471 <rlc_UM5_reassemble_deliver+0x6a1>

						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10475:	ba 06 00 00 00       	mov    $0x6,%edx
   1047a:	89 f8                	mov    %edi,%eax
   1047c:	e8 fc ff ff ff       	call   1047d <rlc_UM5_reassemble_deliver+0x6ad>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10481:	89 f8                	mov    %edi,%eax
   10483:	e8 fc ff ff ff       	call   10484 <rlc_UM5_reassemble_deliver+0x6b4>
   10488:	83 f8 01             	cmp    $0x1,%eax
   1048b:	76 55                	jbe    104e2 <rlc_UM5_reassemble_deliver+0x712>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   1048d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10490:	b9 02 00 00 00       	mov    $0x2,%ecx
   10495:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1049b:	e8 fc ff ff ff       	call   1049c <rlc_UM5_reassemble_deliver+0x6cc>
						fsm_pkt_send(skb,STRM_TO_PDCP);
   104a0:	ba 06 00 00 00       	mov    $0x6,%edx
   104a5:	89 d8                	mov    %ebx,%eax
   104a7:	e8 fc ff ff ff       	call   104a8 <rlc_UM5_reassemble_deliver+0x6d8>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
   104ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   104af:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   104b6:	c7 04 24 88 3f 00 00 	movl   $0x3f88,(%esp)
   104bd:	e8 fc ff ff ff       	call   104be <rlc_UM5_reassemble_deliver+0x6ee>
                      
						clear_left_pdu(pdu_left);
   104c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   104c5:	e8 fc ff ff ff       	call   104c6 <rlc_UM5_reassemble_deliver+0x6f6>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
   104ca:	e9 9d fb ff ff       	jmp    1006c <rlc_UM5_reassemble_deliver+0x29c>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   104cf:	ba 02 00 00 00       	mov    $0x2,%edx
   104d4:	89 f8                	mov    %edi,%eax
   104d6:	e8 fc ff ff ff       	call   104d7 <rlc_UM5_reassemble_deliver+0x707>
   104db:	89 c3                	mov    %eax,%ebx
   104dd:	e9 f6 fd ff ff       	jmp    102d8 <rlc_UM5_reassemble_deliver+0x508>
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   104e2:	ba 02 00 00 00       	mov    $0x2,%edx
   104e7:	89 f8                	mov    %edi,%eax
   104e9:	e8 fc ff ff ff       	call   104ea <rlc_UM5_reassemble_deliver+0x71a>
   104ee:	89 c3                	mov    %eax,%ebx
   104f0:	eb 9b                	jmp    1048d <rlc_UM5_reassemble_deliver+0x6bd>
   104f2:	90                   	nop
   104f3:	90                   	nop
   104f4:	90                   	nop
   104f5:	90                   	nop
   104f6:	90                   	nop
   104f7:	90                   	nop
   104f8:	90                   	nop
   104f9:	90                   	nop
   104fa:	90                   	nop
   104fb:	90                   	nop
   104fc:	90                   	nop
   104fd:	90                   	nop
   104fe:	90                   	nop
   104ff:	90                   	nop

00010500 <Am_instance_build>:
void skb_printf(FSM_PKT *pkt);
void buff_printf(struct AM_Instance *amIns);


void Am_instance_build()
{
   10500:	55                   	push   %ebp
   10501:	89 e5                	mov    %esp,%ebp
   10503:	57                   	push   %edi
   10504:	56                   	push   %esi
   10505:	53                   	push   %ebx
   10506:	83 ec 08             	sub    $0x8,%esp
   10509:	e8 fc ff ff ff       	call   1050a <Am_instance_build+0xa>
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
   1050e:	e8 fc ff ff ff       	call   1050f <Am_instance_build+0xf>
   10513:	89 c2                	mov    %eax,%edx
	amIns =  instance_create(struct AM_Instance);
   10515:	b8 0c 23 00 00       	mov    $0x230c,%eax
   1051a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1051d:	e8 fc ff ff ff       	call   1051e <Am_instance_build+0x1e>
	amIns->rbId = 4;
   10522:	c6 40 02 04          	movb   $0x4,0x2(%eax)
void Am_instance_build()
{
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   10526:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 4;
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 4;
   10528:	c6 40 03 04          	movb   $0x4,0x3(%eax)
	amIns->reorderTimerValue= 100*100;
   1052c:	c7 40 1c 10 27 00 00 	movl   $0x2710,0x1c(%eax)
	amIns->statProhTimerValue =150*150;
   10533:	c7 40 28 e4 57 00 00 	movl   $0x57e4,0x28(%eax)
	amIns->pollRetxTimerValue = 100*100;
   1053a:	c7 40 10 10 27 00 00 	movl   $0x2710,0x10(%eax)
	amIns->pollPDU = 32;
   10541:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10548:	20 00 
	amIns->pollBYTE = 1000;
   1054a:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10551:	e8 03 
	amIns->maxRetxThreshold = 4;
   10553:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   1055a:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   1055c:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10563:	00 00 00 
   10566:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   1056d:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10574:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10577:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   1057e:	00 00 00 
   10581:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10588:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   1058f:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10592:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10599:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   105a0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   105a7:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   105ad:	8b 55 f0             	mov    -0x10(%ebp),%edx
   105b0:	eb 08                	jmp    105ba <Am_instance_build+0xba>
   105b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   105b8:	89 fe                	mov    %edi,%esi
   105ba:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   105c1:	ff 
   105c2:	8d 7e 01             	lea    0x1(%esi),%edi
   105c5:	0f 85 b4 01 00 00    	jne    1077f <Am_instance_build+0x27f>
   105cb:	83 ff 31             	cmp    $0x31,%edi
   105ce:	7e e8                	jle    105b8 <Am_instance_build+0xb8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   105d0:	89 55 f0             	mov    %edx,-0x10(%ebp)
   105d3:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   105da:	e8 fc ff ff ff       	call   105db <Am_instance_build+0xdb>
   105df:	8b 55 f0             	mov    -0x10(%ebp),%edx
   105e2:	eb 06                	jmp    105ea <Am_instance_build+0xea>
   105e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   105e8:	89 f7                	mov    %esi,%edi
   105ea:	83 bc ba 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%edi,4)
   105f1:	ff 
   105f2:	8d 77 01             	lea    0x1(%edi),%esi
   105f5:	0f 85 68 01 00 00    	jne    10763 <Am_instance_build+0x263>
   105fb:	83 fe 31             	cmp    $0x31,%esi
   105fe:	7e e8                	jle    105e8 <Am_instance_build+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10600:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10603:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1060a:	e8 fc ff ff ff       	call   1060b <Am_instance_build+0x10b>
   1060f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10612:	eb 06                	jmp    1061a <Am_instance_build+0x11a>
   10614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10618:	89 c6                	mov    %eax,%esi
   1061a:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   10621:	ff 
   10622:	8d 46 01             	lea    0x1(%esi),%eax
   10625:	0f 85 1c 01 00 00    	jne    10747 <Am_instance_build+0x247>
   1062b:	83 f8 31             	cmp    $0x31,%eax
   1062e:	7e e8                	jle    10618 <Am_instance_build+0x118>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10630:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10633:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   1063a:	e8 fc ff ff ff       	call   1063b <Am_instance_build+0x13b>
   1063f:	8b 55 f0             	mov    -0x10(%ebp),%edx
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10642:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10645:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   10648:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   1064b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10651:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10657:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   1065d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10663:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   10669:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   1066f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10675:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   1067b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10681:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10687:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   1068d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10693:	31 c0                	xor    %eax,%eax
	else
		{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10695:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   1069c:	00 00 
   1069e:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   106a5:	00 00 
   106a7:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   106ae:	00 00 
   106b0:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   106b7:	00 00 
   106b9:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   106c0:	00 00 
   106c2:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   106c9:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   106cb:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   106d2:	00 02 
   106d4:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   106db:	00 02 
   106dd:	8d 76 00             	lea    0x0(%esi),%esi
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   106e0:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   106e7:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   106eb:	83 c0 01             	add    $0x1,%eax
   106ee:	3d 00 04 00 00       	cmp    $0x400,%eax
   106f3:	75 eb                	jne    106e0 <Am_instance_build+0x1e0>
   106f5:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   106f8:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   106ff:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10703:	83 c0 01             	add    $0x1,%eax
   10706:	3d 00 04 00 00       	cmp    $0x400,%eax
   1070b:	75 eb                	jne    106f8 <Am_instance_build+0x1f8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1070d:	8b 82 f8 25 00 00    	mov    0x25f8(%edx),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10713:	8d 8b 04 23 00 00    	lea    0x2304(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10719:	89 8a f8 25 00 00    	mov    %ecx,0x25f8(%edx)
   1071f:	81 c2 f4 25 00 00    	add    $0x25f4,%edx
   10725:	89 93 04 23 00 00    	mov    %edx,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   1072b:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10731:	89 08                	mov    %ecx,(%eax)
	fsm_printf(" am instance has established\n");
   10733:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   1073a:	e8 fc ff ff ff       	call   1073b <Am_instance_build+0x23b>

    FOUT;
}
   1073f:	83 c4 08             	add    $0x8,%esp
   10742:	5b                   	pop    %ebx
   10743:	5e                   	pop    %esi
   10744:	5f                   	pop    %edi
   10745:	5d                   	pop    %ebp
   10746:	c3                   	ret    
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10747:	83 f8 31             	cmp    $0x31,%eax
   1074a:	0f 8f e0 fe ff ff    	jg     10630 <Am_instance_build+0x130>
	else
		{
		amIns->statProhTimerCode = i - 1;
   10750:	89 73 24             	mov    %esi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10753:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   1075a:	ff ff ff ff 
   1075e:	e9 df fe ff ff       	jmp    10642 <Am_instance_build+0x142>
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10763:	83 fe 31             	cmp    $0x31,%esi
   10766:	0f 8f 94 fe ff ff    	jg     10600 <Am_instance_build+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   1076c:	89 7b 18             	mov    %edi,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   1076f:	c7 84 ba 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%edi,4)
   10776:	ff ff ff ff 
   1077a:	e9 9b fe ff ff       	jmp    1061a <Am_instance_build+0x11a>
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   1077f:	83 ff 31             	cmp    $0x31,%edi
   10782:	0f 8f 48 fe ff ff    	jg     105d0 <Am_instance_build+0xd0>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10788:	89 73 0c             	mov    %esi,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   1078b:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   10792:	ff ff ff ff 
   10796:	e9 4f fe ff ff       	jmp    105ea <Am_instance_build+0xea>
   1079b:	90                   	nop
   1079c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000107a0 <UM_instance_bulid>:

    FOUT;
}

void UM_instance_bulid(void)
{
   107a0:	55                   	push   %ebp
   107a1:	89 e5                	mov    %esp,%ebp
   107a3:	83 ec 08             	sub    $0x8,%esp
   107a6:	e8 fc ff ff ff       	call   107a7 <UM_instance_bulid+0x7>
	SV_PTR_GET(rlc_mac_sv);
   107ab:	e8 fc ff ff ff       	call   107ac <UM_instance_bulid+0xc>
	SV(umText).snFiledLength = 5;
	SV(umText).lcid = 2;
	SV(umText).rbid = 2 ;
	SV(umText).CurrentStatVar = ST_TRAN;
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
   107b0:	8d 90 64 5a 00 00    	lea    0x5a64(%eax),%edx

void UM_instance_bulid(void)
{
	SV_PTR_GET(rlc_mac_sv);
 //    SV(umText) =  instance_create(UM_TX_Instance);
	SV(umText).snFiledLength = 5;
   107b6:	66 c7 80 76 5a 00 00 	movw   $0x5,0x5a76(%eax)
   107bd:	05 00 
	SV(umText).lcid = 2;
   107bf:	c6 80 4f 5a 00 00 02 	movb   $0x2,0x5a4f(%eax)
	SV(umText).rbid = 2 ;
   107c6:	c6 80 4e 5a 00 00 02 	movb   $0x2,0x5a4e(%eax)
	SV(umText).CurrentStatVar = ST_TRAN;
   107cd:	c6 80 78 5a 00 00 08 	movb   $0x8,0x5a78(%eax)
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
   107d4:	c7 80 6c 5a 00 00 00 	movl   $0x0,0x5a6c(%eax)
   107db:	00 00 00 
   107de:	c7 80 70 5a 00 00 00 	movl   $0x0,0x5a70(%eax)
   107e5:	00 00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   107e8:	89 90 64 5a 00 00    	mov    %edx,0x5a64(%eax)
	list->prev = list;
   107ee:	89 90 68 5a 00 00    	mov    %edx,0x5a68(%eax)
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
   107f4:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
   107fb:	00 
   107fc:	c7 04 24 bc 3f 00 00 	movl   $0x3fbc,(%esp)
   10803:	e8 fc ff ff ff       	call   10804 <UM_instance_bulid+0x64>
}
   10808:	c9                   	leave  
   10809:	c3                   	ret    
   1080a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00010810 <test>:
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
void test()
{
   10810:	55                   	push   %ebp
   10811:	89 e5                	mov    %esp,%ebp
   10813:	53                   	push   %ebx
   10814:	83 ec 10             	sub    $0x10,%esp
   10817:	e8 fc ff ff ff       	call   10818 <test+0x8>
	struct AM_Instance *amIns;
	void *up, *down;
	SV_PTR_GET(rlc_mac_sv);
   1081c:	e8 fc ff ff ff       	call   1081d <test+0xd>
	//fsm_schedule_self(0,SEGMENT);
	//
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
   10821:	8d 4d f8             	lea    -0x8(%ebp),%ecx
   10824:	8d 55 f4             	lea    -0xc(%ebp),%edx
   10827:	05 18 02 00 00       	add    $0x218,%eax
   1082c:	89 04 24             	mov    %eax,(%esp)
   1082f:	b8 08 00 00 00       	mov    $0x8,%eax
   10834:	e8 fc ff ff ff       	call   10835 <test+0x25>
	amIns = (AM_Instance *)up;	
   10839:	8b 5d f4             	mov    -0xc(%ebp),%ebx
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   1083c:	85 db                	test   %ebx,%ebx
   1083e:	74 30                	je     10870 <test+0x60>
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
   10840:	8b 53 18             	mov    0x18(%ebx),%edx
   10843:	b8 40 0d 03 00       	mov    $0x30d40,%eax
   10848:	e8 fc ff ff ff       	call   10849 <test+0x39>
   1084d:	89 43 14             	mov    %eax,0x14(%ebx)
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
   10850:	8b 43 18             	mov    0x18(%ebx),%eax
   10853:	c7 04 24 fc 3f 00 00 	movl   $0x3ffc,(%esp)
   1085a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1085e:	e8 fc ff ff ff       	call   1085f <test+0x4f>
}
   10863:	83 c4 10             	add    $0x10,%esp
   10866:	5b                   	pop    %ebx
   10867:	5d                   	pop    %ebp
   10868:	c3                   	ret    
   10869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
	amIns = (AM_Instance *)up;	
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   10870:	c7 04 24 25 08 00 00 	movl   $0x825,(%esp)
   10877:	e8 fc ff ff ff       	call   10878 <test+0x68>
   1087c:	eb d2                	jmp    10850 <test+0x40>
   1087e:	66 90                	xchg   %ax,%ax

00010880 <skb_printf>:
	}
	nposBf = NULL;
}

void skb_printf(FSM_PKT *pkt)
{
   10880:	55                   	push   %ebp
   10881:	89 e5                	mov    %esp,%ebp
   10883:	83 ec 08             	sub    $0x8,%esp
   10886:	e8 fc ff ff ff       	call   10887 <skb_printf+0x7>
	fsm_printf("%s\n",(char *)(pkt->data+4));
   1088b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10891:	c7 04 24 40 08 00 00 	movl   $0x840,(%esp)
   10898:	83 c0 04             	add    $0x4,%eax
   1089b:	89 44 24 04          	mov    %eax,0x4(%esp)
   1089f:	e8 fc ff ff ff       	call   108a0 <skb_printf+0x20>
	FOUT;
}
   108a4:	c9                   	leave  
   108a5:	c3                   	ret    
   108a6:	8d 76 00             	lea    0x0(%esi),%esi
   108a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000108b0 <buff_printf>:
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
}

void buff_printf(struct AM_Instance *amIns)
{
   108b0:	55                   	push   %ebp
   108b1:	89 e5                	mov    %esp,%ebp
   108b3:	57                   	push   %edi
   108b4:	56                   	push   %esi
   108b5:	53                   	push   %ebx
   108b6:	83 ec 08             	sub    $0x8,%esp
   108b9:	e8 fc ff ff ff       	call   108ba <buff_printf+0xa>
   108be:	89 c3                	mov    %eax,%ebx
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   108c0:	c7 04 24 44 08 00 00 	movl   $0x844,(%esp)
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
   108c7:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   108cd:	e8 fc ff ff ff       	call   108ce <buff_printf+0x1e>
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
   108d2:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   108d8:	c7 04 24 5d 08 00 00 	movl   $0x85d,(%esp)
   108df:	89 44 24 04          	mov    %eax,0x4(%esp)
   108e3:	e8 fc ff ff ff       	call   108e4 <buff_printf+0x34>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   108e8:	8b b3 9c 01 00 00    	mov    0x19c(%ebx),%esi
	if( !list_empty(&amIns->amRetxBuffer.list) )
   108ee:	39 f7                	cmp    %esi,%edi
   108f0:	74 56                	je     10948 <buff_printf+0x98>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   108f2:	8b 1e                	mov    (%esi),%ebx
   108f4:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   108fa:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
   10900:	eb 0a                	jmp    1090c <buff_printf+0x5c>
   10902:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10908:	89 de                	mov    %ebx,%esi
   1090a:	89 d3                	mov    %edx,%ebx
		{
			fsm_printf("The PDU SN is %d\n",amRetxBf->SN);
   1090c:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   10913:	c7 04 24 79 08 00 00 	movl   $0x879,(%esp)
   1091a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1091e:	e8 fc ff ff ff       	call   1091f <buff_printf+0x6f>
			skb_printf(amRetxBf->pkt);
   10923:	8b 06                	mov    (%esi),%eax
   10925:	e8 fc ff ff ff       	call   10926 <buff_printf+0x76>
	//
	fsm_printf("printf the amRetxBuffer\n");
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   1092a:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   10930:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   10936:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1093c:	39 c7                	cmp    %eax,%edi
   1093e:	75 c8                	jne    10908 <buff_printf+0x58>
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
	}
	nposBf = NULL;
}
   10940:	83 c4 08             	add    $0x8,%esp
   10943:	5b                   	pop    %ebx
   10944:	5e                   	pop    %esi
   10945:	5f                   	pop    %edi
   10946:	5d                   	pop    %ebp
   10947:	c3                   	ret    
			skb_printf(amRetxBf->pkt);
		}
	}
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
   10948:	c7 04 24 8b 08 00 00 	movl   $0x88b,(%esp)
   1094f:	e8 fc ff ff ff       	call   10950 <buff_printf+0xa0>
   10954:	eb ea                	jmp    10940 <buff_printf+0x90>
   10956:	8d 76 00             	lea    0x0(%esi),%esi
   10959:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010960 <add_data_retx>:
{
	fsm_printf("%s\n",(char *)(pkt->data+4));
	FOUT;
}
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
   10960:	55                   	push   %ebp
   10961:	89 e5                	mov    %esp,%ebp
   10963:	57                   	push   %edi
   10964:	56                   	push   %esi
   10965:	53                   	push   %ebx
   10966:	83 ec 04             	sub    $0x4,%esp
   10969:	e8 fc ff ff ff       	call   1096a <add_data_retx+0xa>
   1096e:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
   10970:	e8 fc ff ff ff       	call   10971 <add_data_retx+0x11>
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10975:	b8 1a 00 00 00       	mov    $0x1a,%eax
   1097a:	e8 fc ff ff ff       	call   1097b <add_data_retx+0x1b>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   1097f:	ba 02 00 00 00       	mov    $0x2,%edx
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
	SV_PTR_GET(rlc_mac_sv);
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10984:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->data;;
   10986:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
   1098c:	c6 00 00             	movb   $0x0,(%eax)
   1098f:	c6 40 01 84          	movb   $0x84,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10993:	89 d8                	mov    %ebx,%eax
   10995:	e8 fc ff ff ff       	call   10996 <add_data_retx+0x36>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   1099a:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   109a0:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   109a5:	c6 00 0b             	movb   $0xb,(%eax)
   109a8:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   109ac:	89 d8                	mov    %ebx,%eax
   109ae:	e8 fc ff ff ff       	call   109af <add_data_retx+0x4f>
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
   109b3:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   109b8:	e8 fc ff ff ff       	call   109b9 <add_data_retx+0x59>
   109bd:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   109c3:	ba a6 08 00 00       	mov    $0x8a6,%edx
   109c8:	89 c1                	mov    %eax,%ecx
   109ca:	89 f8                	mov    %edi,%eax
   109cc:	e8 fc ff ff ff       	call   109cd <add_data_retx+0x6d>
	fsm_skb_put(skb,strlen(sdu1));
   109d1:	b8 a6 08 00 00       	mov    $0x8a6,%eax
   109d6:	e8 fc ff ff ff       	call   109d7 <add_data_retx+0x77>
   109db:	89 c2                	mov    %eax,%edx
   109dd:	89 d8                	mov    %ebx,%eax
   109df:	e8 fc ff ff ff       	call   109e0 <add_data_retx+0x80>
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
   109e4:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   109e9:	e8 fc ff ff ff       	call   109ea <add_data_retx+0x8a>
   109ee:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   109f4:	ba b1 08 00 00       	mov    $0x8b1,%edx
   109f9:	89 c1                	mov    %eax,%ecx
   109fb:	89 f8                	mov    %edi,%eax
   109fd:	e8 fc ff ff ff       	call   109fe <add_data_retx+0x9e>
	fsm_skb_put(skb,strlen(sdu2));
   10a02:	b8 b1 08 00 00       	mov    $0x8b1,%eax
   10a07:	e8 fc ff ff ff       	call   10a08 <add_data_retx+0xa8>
   10a0c:	89 c2                	mov    %eax,%edx
   10a0e:	89 d8                	mov    %ebx,%eax
   10a10:	e8 fc ff ff ff       	call   10a11 <add_data_retx+0xb1>

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10a15:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10a1a:	e8 fc ff ff ff       	call   10a1b <add_data_retx+0xbb>
	ambuf->pkt = skb;
   10a1f:	89 18                	mov    %ebx,(%eax)
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
	fsm_skb_put(skb,strlen(sdu1));
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
	fsm_skb_put(skb,strlen(sdu2));

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10a21:	89 c7                	mov    %eax,%edi
	ambuf->pkt = skb;
	ambuf->pktstatus = FULL_SDU;
   10a23:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	ambuf->pos = 0;
   10a2a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10a31:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10a38:	00 00 00 
	ambuf->segStart[0] = 0;
   10a3b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	ambuf->segEnd[0] = 20;
   10a42:	c7 40 50 14 00 00 00 	movl   $0x14,0x50(%eax)
	ambuf->retxCount = 0;
   10a49:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10a50:	00 00 
	ambuf->SN = 0;
   10a52:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10a59:	00 00 
	ambuf->headLen = 2*2;
   10a5b:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 20;
   10a62:	c7 80 98 00 00 00 14 	movl   $0x14,0x98(%eax)
   10a69:	00 00 00 
	fsm_printf("add data in retx buffer\n");
   10a6c:	c7 04 24 bc 08 00 00 	movl   $0x8bc,(%esp)
   10a73:	e8 fc ff ff ff       	call   10a74 <add_data_retx+0x114>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10a78:	8b 86 a0 01 00 00    	mov    0x1a0(%esi),%eax
	list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
   10a7e:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10a84:	89 96 a0 01 00 00    	mov    %edx,0x1a0(%esi)
   10a8a:	81 c6 9c 01 00 00    	add    $0x19c,%esi
   10a90:	89 b7 9c 00 00 00    	mov    %esi,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   10a96:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   10a9c:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   10a9e:	83 c4 04             	add    $0x4,%esp
   10aa1:	5b                   	pop    %ebx
   10aa2:	5e                   	pop    %esi
   10aa3:	5f                   	pop    %edi
   10aa4:	5d                   	pop    %ebp
   10aa5:	c3                   	ret    
   10aa6:	8d 76 00             	lea    0x0(%esi),%esi
   10aa9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010ab0 <Am_instance_add>:
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
}

void Am_instance_add()
{
   10ab0:	55                   	push   %ebp
   10ab1:	89 e5                	mov    %esp,%ebp
   10ab3:	57                   	push   %edi
   10ab4:	56                   	push   %esi
   10ab5:	53                   	push   %ebx
   10ab6:	83 ec 04             	sub    $0x4,%esp
   10ab9:	e8 fc ff ff ff       	call   10aba <Am_instance_add+0xa>
    struct AM_Instance *amIns;
    int i = 0;
    SV_PTR_GET(rlc_mac_sv);
   10abe:	e8 fc ff ff ff       	call   10abf <Am_instance_add+0xf>
   10ac3:	89 c6                	mov    %eax,%esi
	amIns =  instance_create(struct AM_Instance);
   10ac5:	b8 0c 23 00 00       	mov    $0x230c,%eax
   10aca:	e8 fc ff ff ff       	call   10acb <Am_instance_add+0x1b>
}

void Am_instance_add()
{
    struct AM_Instance *amIns;
    int i = 0;
   10acf:	31 d2                	xor    %edx,%edx
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   10ad1:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 8;
   10ad3:	c6 40 02 08          	movb   $0x8,0x2(%eax)
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 8;
   10ad7:	c6 40 03 08          	movb   $0x8,0x3(%eax)
	amIns->reorderTimerValue= 1000*100;
   10adb:	c7 40 1c a0 86 01 00 	movl   $0x186a0,0x1c(%eax)
	amIns->statProhTimerValue = 2000*100;
   10ae2:	c7 40 28 40 0d 03 00 	movl   $0x30d40,0x28(%eax)
	amIns->pollRetxTimerValue = 1000*100;
   10ae9:	c7 40 10 a0 86 01 00 	movl   $0x186a0,0x10(%eax)
	amIns->pollPDU = 32;
   10af0:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10af7:	20 00 
	amIns->pollBYTE = 1000;
   10af9:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10b00:	e8 03 
	amIns->maxRetxThreshold = 4;
   10b02:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   10b09:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   10b0b:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10b12:	00 00 00 
   10b15:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   10b1c:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10b23:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10b26:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   10b2d:	00 00 00 
   10b30:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10b37:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   10b3e:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10b41:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10b48:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   10b4f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   10b56:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   10b5c:	eb 0d                	jmp    10b6b <Am_instance_add+0xbb>
   10b5e:	66 90                	xchg   %ax,%ax
   10b60:	83 f8 32             	cmp    $0x32,%eax
   10b63:	0f 84 8a 01 00 00    	je     10cf3 <Am_instance_add+0x243>
   10b69:	89 c2                	mov    %eax,%edx
   10b6b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
   10b72:	ff 
   10b73:	8d 42 01             	lea    0x1(%edx),%eax
   10b76:	74 e8                	je     10b60 <Am_instance_add+0xb0>
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10b78:	83 f8 32             	cmp    $0x32,%eax
   10b7b:	0f 84 72 01 00 00    	je     10cf3 <Am_instance_add+0x243>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10b81:	89 53 0c             	mov    %edx,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   10b84:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
   10b8b:	ff ff ff ff 
   10b8f:	eb 09                	jmp    10b9a <Am_instance_add+0xea>
   10b91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10b98:	89 f8                	mov    %edi,%eax
   10b9a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10ba1:	ff 
   10ba2:	8d 78 01             	lea    0x1(%eax),%edi
   10ba5:	0f 85 6a 01 00 00    	jne    10d15 <Am_instance_add+0x265>
   10bab:	83 ff 31             	cmp    $0x31,%edi
   10bae:	7e e8                	jle    10b98 <Am_instance_add+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10bb0:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10bb7:	e8 fc ff ff ff       	call   10bb8 <Am_instance_add+0x108>
   10bbc:	eb 04                	jmp    10bc2 <Am_instance_add+0x112>
   10bbe:	66 90                	xchg   %ax,%ax
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10bc0:	89 c7                	mov    %eax,%edi
   10bc2:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10bc9:	ff 
   10bca:	8d 47 01             	lea    0x1(%edi),%eax
   10bcd:	0f 85 6a 01 00 00    	jne    10d3d <Am_instance_add+0x28d>
   10bd3:	83 f8 31             	cmp    $0x31,%eax
   10bd6:	7e e8                	jle    10bc0 <Am_instance_add+0x110>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10bd8:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10bdf:	e8 fc ff ff ff       	call   10be0 <Am_instance_add+0x130>
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10be4:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10be7:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   10bea:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   10bed:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10bf3:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10bf9:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   10bff:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10c05:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   10c0b:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   10c11:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10c17:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   10c1d:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10c23:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10c29:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   10c2f:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10c35:	31 c0                	xor    %eax,%eax
	else
	{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10c37:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   10c3e:	00 00 
   10c40:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   10c47:	00 00 
   10c49:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   10c50:	00 00 
   10c52:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   10c59:	00 00 
   10c5b:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   10c62:	00 00 
   10c64:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   10c6b:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   10c6d:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   10c74:	00 02 
   10c76:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   10c7d:	00 02 
   10c7f:	90                   	nop
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   10c80:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   10c87:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   10c8b:	83 c0 01             	add    $0x1,%eax
   10c8e:	3d 00 04 00 00       	cmp    $0x400,%eax
   10c93:	75 eb                	jne    10c80 <Am_instance_add+0x1d0>
   10c95:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   10c98:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   10c9f:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10ca3:	83 c0 01             	add    $0x1,%eax
   10ca6:	3d 00 04 00 00       	cmp    $0x400,%eax
   10cab:	75 eb                	jne    10c98 <Am_instance_add+0x1e8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10cad:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10cb3:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10cb9:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
   10cbf:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
   10cc5:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   10ccb:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10cd1:	89 10                	mov    %edx,(%eax)
	fsm_printf(" am instance has established\n");
   10cd3:	c7 04 24 07 08 00 00 	movl   $0x807,(%esp)
   10cda:	e8 fc ff ff ff       	call   10cdb <Am_instance_add+0x22b>

//
	add_data_retx(amIns,8);
   10cdf:	89 d8                	mov    %ebx,%eax
   10ce1:	ba 08 00 00 00       	mov    $0x8,%edx
   10ce6:	e8 fc ff ff ff       	call   10ce7 <Am_instance_add+0x237>
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
   10ceb:	83 c4 04             	add    $0x4,%esp
   10cee:	5b                   	pop    %ebx
   10cef:	5e                   	pop    %esi
   10cf0:	5f                   	pop    %edi
   10cf1:	5d                   	pop    %ebp
   10cf2:	c3                   	ret    
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10cf3:	c7 04 24 eb 07 00 00 	movl   $0x7eb,(%esp)
   10cfa:	e8 fc ff ff ff       	call   10cfb <Am_instance_add+0x24b>
   10cff:	b8 32 00 00 00       	mov    $0x32,%eax
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10d04:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10d0b:	ff 
   10d0c:	8d 78 01             	lea    0x1(%eax),%edi
   10d0f:	0f 84 96 fe ff ff    	je     10bab <Am_instance_add+0xfb>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10d15:	83 ff 31             	cmp    $0x31,%edi
   10d18:	0f 8f 92 fe ff ff    	jg     10bb0 <Am_instance_add+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   10d1e:	89 43 18             	mov    %eax,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   10d21:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
   10d28:	ff ff ff ff 
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10d2c:	8d 47 01             	lea    0x1(%edi),%eax
   10d2f:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10d36:	ff 
   10d37:	0f 84 96 fe ff ff    	je     10bd3 <Am_instance_add+0x123>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10d3d:	83 f8 31             	cmp    $0x31,%eax
   10d40:	0f 8f 92 fe ff ff    	jg     10bd8 <Am_instance_add+0x128>
	else
	{
		amIns->statProhTimerCode = i - 1;
   10d46:	89 7b 24             	mov    %edi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10d49:	c7 84 be 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edi,4)
   10d50:	ff ff ff ff 
   10d54:	e9 8b fe ff ff       	jmp    10be4 <Am_instance_add+0x134>
   10d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00010d60 <addPollData>:
}


//build()
void addPollData()
{
   10d60:	55                   	push   %ebp
   10d61:	89 e5                	mov    %esp,%ebp
   10d63:	57                   	push   %edi
   10d64:	56                   	push   %esi
   10d65:	53                   	push   %ebx
   10d66:	83 ec 04             	sub    $0x4,%esp
   10d69:	e8 fc ff ff ff       	call   10d6a <addPollData+0xa>
	FSM_PKT *skb = NULL;
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
   10d6e:	66 c7 45 f0 01 80    	movw   $0x8001,-0x10(%ebp)
	unsigned short data = 0x0002;
   10d74:	66 c7 45 f2 02 00    	movw   $0x2,-0xe(%ebp)
	SV_PTR_GET(rlc_mac_sv);
   10d7a:	e8 fc ff ff ff       	call   10d7b <addPollData+0x1b>
   10d7f:	89 c6                	mov    %eax,%esi
	skb = fsm_pkt_create(4);
   10d81:	b8 04 00 00 00       	mov    $0x4,%eax
   10d86:	e8 fc ff ff ff       	call   10d87 <addPollData+0x27>
   10d8b:	89 c7                	mov    %eax,%edi
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d8d:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10d92:	e8 fc ff ff ff       	call   10d93 <addPollData+0x33>

	fsm_mem_cpy(skb->tail,&hdr,2);
   10d97:	b9 02 00 00 00       	mov    $0x2,%ecx
   10d9c:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
	unsigned short data = 0x0002;
	SV_PTR_GET(rlc_mac_sv);
	skb = fsm_pkt_create(4);
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10d9f:	89 c3                	mov    %eax,%ebx

	fsm_mem_cpy(skb->tail,&hdr,2);
   10da1:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10da7:	e8 fc ff ff ff       	call   10da8 <addPollData+0x48>
	fsm_skb_put(skb,2);
   10dac:	ba 02 00 00 00       	mov    $0x2,%edx
   10db1:	89 f8                	mov    %edi,%eax
   10db3:	e8 fc ff ff ff       	call   10db4 <addPollData+0x54>
	fsm_mem_cpy(skb->tail,&data,2);
   10db8:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10dbe:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10dc1:	b9 02 00 00 00       	mov    $0x2,%ecx
   10dc6:	e8 fc ff ff ff       	call   10dc7 <addPollData+0x67>
	fsm_skb_put(skb,2);
   10dcb:	ba 02 00 00 00       	mov    $0x2,%edx
   10dd0:	89 f8                	mov    %edi,%eax
   10dd2:	e8 fc ff ff ff       	call   10dd3 <addPollData+0x73>
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10dd7:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx

	fsm_mem_cpy(skb->tail,&hdr,2);
	fsm_skb_put(skb,2);
	fsm_mem_cpy(skb->tail,&data,2);
	fsm_skb_put(skb,2);
	amTxedBuffer->pkt = skb;
   10ddd:	89 3b                	mov    %edi,(%ebx)
	amTxedBuffer->SN = 0x0001;
   10ddf:	66 c7 83 94 00 00 00 	movw   $0x1,0x94(%ebx)
   10de6:	01 00 
	amTxedBuffer->pktstatus = 1;
   10de8:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	amTxedBuffer->headLen = 2;
   10def:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amTxedBuffer->retxCount = 0;
   10df6:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   10dfd:	00 00 
	amTxedBuffer->segnum = 0;
   10dff:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
   10e06:	00 00 00 
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
   10e09:	83 86 e8 38 00 00 01 	addl   $0x1,0x38e8(%esi)
	amTxedBuffer->SN = 0x0001;
	amTxedBuffer->pktstatus = 1;
	amTxedBuffer->headLen = 2;
	amTxedBuffer->retxCount = 0;
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
   10e10:	66 c7 86 3c 5a 00 00 	movw   $0x20,0x5a3c(%esi)
   10e17:	20 00 
	SV(amText).byteWithoutPoll = 1000;
   10e19:	66 c7 86 3e 5a 00 00 	movw   $0x3e8,0x5a3e(%esi)
   10e20:	e8 03 
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
   10e22:	8b 47 50             	mov    0x50(%edi),%eax
   10e25:	01 86 e4 38 00 00    	add    %eax,0x38e4(%esi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10e2b:	8b 86 e0 38 00 00    	mov    0x38e0(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10e31:	89 96 e0 38 00 00    	mov    %edx,0x38e0(%esi)
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10e37:	81 c6 dc 38 00 00    	add    $0x38dc,%esi
   10e3d:	89 b3 9c 00 00 00    	mov    %esi,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
   10e43:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
   10e49:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   10e4b:	83 c4 04             	add    $0x4,%esp
   10e4e:	5b                   	pop    %ebx
   10e4f:	5e                   	pop    %esi
   10e50:	5f                   	pop    %edi
   10e51:	5d                   	pop    %ebp
   10e52:	c3                   	ret    
   10e53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010e60 <addPollRetxData>:
void addPollRetxData(struct AM_Instance*amIns)
{
   10e60:	55                   	push   %ebp
   10e61:	89 e5                	mov    %esp,%ebp
   10e63:	57                   	push   %edi
   10e64:	56                   	push   %esi
   10e65:	53                   	push   %ebx
   10e66:	e8 fc ff ff ff       	call   10e67 <addPollRetxData+0x7>
   10e6b:	89 c6                	mov    %eax,%esi
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10e6d:	b8 1a 00 00 00       	mov    $0x1a,%eax
   10e72:	e8 fc ff ff ff       	call   10e73 <addPollRetxData+0x13>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10e77:	ba 02 00 00 00       	mov    $0x2,%edx
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10e7c:	8d be f0 00 00 00    	lea    0xf0(%esi),%edi
void addPollRetxData(struct AM_Instance*amIns)
{
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10e82:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->tail;
   10e84:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
   10e8a:	c6 00 00             	movb   $0x0,(%eax)
   10e8d:	c6 40 01 dc          	movb   $0xdc,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10e91:	89 d8                	mov    %ebx,%eax
   10e93:	e8 fc ff ff ff       	call   10e94 <addPollRetxData+0x34>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   10e98:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10e9e:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10ea3:	c6 00 0b             	movb   $0xb,(%eax)
   10ea6:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10eaa:	89 d8                	mov    %ebx,%eax
   10eac:	e8 fc ff ff ff       	call   10ead <addPollRetxData+0x4d>
	fsm_mem_cpy(skb->tail, sdu1, 11);
   10eb1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10eb7:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10ebc:	ba d5 08 00 00       	mov    $0x8d5,%edx
   10ec1:	e8 fc ff ff ff       	call   10ec2 <addPollRetxData+0x62>
	fsm_skb_put(skb,11);
   10ec6:	ba 0b 00 00 00       	mov    $0xb,%edx
   10ecb:	89 d8                	mov    %ebx,%eax
   10ecd:	e8 fc ff ff ff       	call   10ece <addPollRetxData+0x6e>
	fsm_mem_cpy(skb->tail, sdu2, 11);
   10ed2:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10ed8:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10edd:	ba e1 08 00 00       	mov    $0x8e1,%edx
   10ee2:	e8 fc ff ff ff       	call   10ee3 <addPollRetxData+0x83>
	fsm_skb_put(skb,11);
   10ee7:	ba 0b 00 00 00       	mov    $0xb,%edx
   10eec:	89 d8                	mov    %ebx,%eax
   10eee:	e8 fc ff ff ff       	call   10eef <addPollRetxData+0x8f>

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
   10ef3:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10ef8:	e8 fc ff ff ff       	call   10ef9 <addPollRetxData+0x99>
	ambuf->pkt = skb;
   10efd:	89 18                	mov    %ebx,(%eax)
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10eff:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
	fsm_mem_cpy(skb->tail, sdu2, 11);
	fsm_skb_put(skb,11);

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
	ambuf->pkt = skb;
	ambuf->pktstatus = ANY_SEGMENT;
   10f05:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	ambuf->pos = 0;
   10f0c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10f13:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10f1a:	00 00 00 
	ambuf->segStart[0] = 3;
   10f1d:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
	ambuf->segEnd[0] = 18;
   10f24:	c7 40 50 12 00 00 00 	movl   $0x12,0x50(%eax)
	ambuf->retxCount = 0;
   10f2b:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10f32:	00 00 
	ambuf->SN = 0;
   10f34:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10f3b:	00 00 
	ambuf->headLen = 2*2;
   10f3d:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 22;
   10f44:	c7 80 98 00 00 00 16 	movl   $0x16,0x98(%eax)
   10f4b:	00 00 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10f4e:	8b 96 f4 00 00 00    	mov    0xf4(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10f54:	89 8e f4 00 00 00    	mov    %ecx,0xf4(%esi)
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10f5a:	89 b8 9c 00 00 00    	mov    %edi,0x9c(%eax)
	new->next = next;
	new->prev = prev;
   10f60:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
   10f66:	89 0a                	mov    %ecx,(%edx)
	amIns->amTransmittedBufferNum++;
   10f68:	83 86 fc 00 00 00 01 	addl   $0x1,0xfc(%esi)
	amIns->amTransmittedBufferSize += skb->len;
   10f6f:	8b 43 50             	mov    0x50(%ebx),%eax
   10f72:	01 86 f8 00 00 00    	add    %eax,0xf8(%esi)
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10f78:	5b                   	pop    %ebx
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
   10f79:	66 83 86 64 12 00 00 	addw   $0x1,0x1264(%esi)
   10f80:	01 
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10f81:	5e                   	pop    %esi
   10f82:	5f                   	pop    %edi
   10f83:	5d                   	pop    %ebp
   10f84:	c3                   	ret    
   10f85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   10f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010f90 <addpkt_recvData>:


void addpkt_recvData(struct AM_Instance *amIns)
{
   10f90:	55                   	push   %ebp
   10f91:	89 e5                	mov    %esp,%ebp
   10f93:	57                   	push   %edi
   10f94:	56                   	push   %esi
   10f95:	53                   	push   %ebx
   10f96:	83 ec 20             	sub    $0x20,%esp
   10f99:	e8 fc ff ff ff       	call   10f9a <addpkt_recvData+0xa>
   10f9e:	89 c3                	mov    %eax,%ebx
	unsigned short hdr;
	unsigned char *str1 = "pkt1";
	unsigned char *str2 = "pkt2";
	unsigned char *str3 = "pkt3";
	unsigned char *str4 = "pkt4";
	SV_PTR_GET(rlc_mac_sv);
   10fa0:	e8 fc ff ff ff       	call   10fa1 <addpkt_recvData+0x11>

	skb1 = fsm_pkt_create(6);
   10fa5:	b8 06 00 00 00       	mov    $0x6,%eax
   10faa:	e8 fc ff ff ff       	call   10fab <addpkt_recvData+0x1b>
   10faf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	amTxedBuffer1= (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));	
   10fb2:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10fb7:	e8 fc ff ff ff       	call   10fb8 <addpkt_recvData+0x28>
   10fbc:	89 c7                	mov    %eax,%edi
	skb2 = fsm_pkt_create(6);
   10fbe:	b8 06 00 00 00       	mov    $0x6,%eax
   10fc3:	e8 fc ff ff ff       	call   10fc4 <addpkt_recvData+0x34>
   10fc8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10fcb:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10fd0:	e8 fc ff ff ff       	call   10fd1 <addpkt_recvData+0x41>
   10fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	skb3 = fsm_pkt_create(6);
   10fd8:	b8 06 00 00 00       	mov    $0x6,%eax
   10fdd:	e8 fc ff ff ff       	call   10fde <addpkt_recvData+0x4e>
   10fe2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10fe5:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10fea:	e8 fc ff ff ff       	call   10feb <addpkt_recvData+0x5b>
   10fef:	89 45 e8             	mov    %eax,-0x18(%ebp)
	skb4 = fsm_pkt_create(6);
   10ff2:	b8 06 00 00 00       	mov    $0x6,%eax
   10ff7:	e8 fc ff ff ff       	call   10ff8 <addpkt_recvData+0x68>
   10ffc:	89 45 d8             	mov    %eax,-0x28(%ebp)
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10fff:	b8 a4 00 00 00       	mov    $0xa4,%eax
   11004:	e8 fc ff ff ff       	call   11005 <addpkt_recvData+0x75>

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   11009:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1100c:	b9 02 00 00 00       	mov    $0x2,%ecx
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));

	hdr = 0x8000;
   11011:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	skb2 = fsm_pkt_create(6);
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   11017:	89 c6                	mov    %eax,%esi

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   11019:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   1101f:	8d 55 f2             	lea    -0xe(%ebp),%edx
   11022:	e8 fc ff ff ff       	call   11023 <addpkt_recvData+0x93>
	fsm_skb_put(skb1,2);
   11027:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1102a:	ba 02 00 00 00       	mov    $0x2,%edx
   1102f:	e8 fc ff ff ff       	call   11030 <addpkt_recvData+0xa0>
	fsm_mem_cpy(skb1->tail,str1,4);
   11034:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11037:	ba ed 08 00 00       	mov    $0x8ed,%edx
   1103c:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   11042:	b9 04 00 00 00       	mov    $0x4,%ecx
   11047:	e8 fc ff ff ff       	call   11048 <addpkt_recvData+0xb8>
	fsm_skb_put(skb1,4);
   1104c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1104f:	ba 04 00 00 00       	mov    $0x4,%edx
   11054:	e8 fc ff ff ff       	call   11055 <addpkt_recvData+0xc5>
	amTxedBuffer1->pkt = skb1;
   11059:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   1105c:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
   11062:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   11069:	00 00 
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   1106b:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
   11071:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amTxedBuffer1->headLen = 2;
   11078:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
   1107f:	89 07                	mov    %eax,(%edi)
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
	amTxedBuffer1->headLen = 2;
	amTxedBuffer1->datalen = 4;
   11081:	c7 87 98 00 00 00 04 	movl   $0x4,0x98(%edi)
   11088:	00 00 00 
	amTxedBuffer1->retxCount = -1;
   1108b:	66 c7 87 96 00 00 00 	movw   $0xffff,0x96(%edi)
   11092:	ff ff 
	amTxedBuffer1->segnum = 0;
   11094:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   1109b:	00 00 00 
	amTxedBuffer1->pos = 0;
   1109e:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	amTxedBuffer1->segEnd[0] = -1;
   110a5:	c7 47 50 ff ff ff ff 	movl   $0xffffffff,0x50(%edi)
	amTxedBuffer1->segStart[0] = -1;
   110ac:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edi)
	amIns->amTransmittedBufferNum++;
   110b3:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb1->len;
   110ba:	8b 40 50             	mov    0x50(%eax),%eax
   110bd:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   110c3:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   110c9:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   110d0:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   110d1:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   110d7:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->prev = prev;
   110dd:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   110e3:	8b 7d e0             	mov    -0x20(%ebp),%edi
	prev->next = new;
   110e6:	89 10                	mov    %edx,(%eax)
   110e8:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   110eb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   110ee:	b9 02 00 00 00       	mov    $0x2,%ecx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
   110f3:	66 c7 45 f2 01 80    	movw   $0x8001,-0xe(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   110f9:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   110ff:	e8 fc ff ff ff       	call   11100 <addpkt_recvData+0x170>
	fsm_skb_put(skb2,2);
   11104:	ba 02 00 00 00       	mov    $0x2,%edx
   11109:	89 f8                	mov    %edi,%eax
   1110b:	e8 fc ff ff ff       	call   1110c <addpkt_recvData+0x17c>
	fsm_mem_cpy(skb2->tail,str2,4);
   11110:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   11116:	b9 04 00 00 00       	mov    $0x4,%ecx
   1111b:	ba f2 08 00 00       	mov    $0x8f2,%edx
   11120:	e8 fc ff ff ff       	call   11121 <addpkt_recvData+0x191>
	fsm_skb_put(skb2,4);
   11125:	ba 04 00 00 00       	mov    $0x4,%edx
   1112a:	89 f8                	mov    %edi,%eax
   1112c:	e8 fc ff ff ff       	call   1112d <addpkt_recvData+0x19d>
	amTxedBuffer2->pkt = skb2;
   11131:	8b 45 ec             	mov    -0x14(%ebp),%eax
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   11134:	8b 55 ec             	mov    -0x14(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11137:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
   1113a:	89 38                	mov    %edi,(%eax)
	amTxedBuffer2->SN = 0x0001;
   1113c:	66 c7 80 94 00 00 00 	movw   $0x1,0x94(%eax)
   11143:	01 00 
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   11145:	81 c2 9c 00 00 00    	add    $0x9c,%edx
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
	amTxedBuffer2->SN = 0x0001;
	amTxedBuffer2->pktstatus = FULL_SDU;
   1114b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	amTxedBuffer2->headLen = 2;
   11152:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer2->datalen = 4;
   11159:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   11160:	00 00 00 
	amTxedBuffer2->retxCount = -1;
   11163:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   1116a:	ff ff 
	amTxedBuffer2->segnum = 0;
   1116c:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
   11173:	00 00 00 
	amTxedBuffer2->pos = 0;
   11176:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer2->segEnd[0] = -1;
   1117d:	c7 40 50 ff ff ff ff 	movl   $0xffffffff,0x50(%eax)
	amTxedBuffer2->segStart[0] = -1;
   11184:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   1118b:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb2->len;
   11192:	8b 47 50             	mov    0x50(%edi),%eax
   11195:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
   1119b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1119e:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   111a4:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   111ab:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   111ac:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   111b2:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)
	new->prev = prev;
   111b8:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
   111be:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   111c3:	89 10                	mov    %edx,(%eax)
   111c5:	8b 55 dc             	mov    -0x24(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
   111c8:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	fsm_mem_cpy(skb3->tail,&hdr,2);
   111ce:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   111d4:	8d 55 f2             	lea    -0xe(%ebp),%edx
   111d7:	e8 fc ff ff ff       	call   111d8 <addpkt_recvData+0x248>
	fsm_skb_put(skb3,2);
   111dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111df:	ba 02 00 00 00       	mov    $0x2,%edx
   111e4:	e8 fc ff ff ff       	call   111e5 <addpkt_recvData+0x255>
	fsm_mem_cpy(skb3->tail,str3,4);
   111e9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   111ec:	ba f7 08 00 00       	mov    $0x8f7,%edx
   111f1:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   111f7:	b9 04 00 00 00       	mov    $0x4,%ecx
   111fc:	e8 fc ff ff ff       	call   111fd <addpkt_recvData+0x26d>
	fsm_skb_put(skb3,4);
   11201:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11204:	ba 04 00 00 00       	mov    $0x4,%edx
   11209:	e8 fc ff ff ff       	call   1120a <addpkt_recvData+0x27a>
	amTxedBuffer3->pkt = skb3;
   1120e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11211:	8b 55 dc             	mov    -0x24(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11214:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	amTxedBuffer3->SN = 0x0002;
   11217:	66 c7 80 94 00 00 00 	movw   $0x2,0x94(%eax)
   1121e:	02 00 
	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
	fsm_skb_put(skb3,2);
	fsm_mem_cpy(skb3->tail,str3,4);
	fsm_skb_put(skb3,4);
	amTxedBuffer3->pkt = skb3;
   11220:	89 10                	mov    %edx,(%eax)
	amTxedBuffer3->SN = 0x0002;
	amTxedBuffer3->pktstatus = ANY_SEGMENT;
   11222:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	amTxedBuffer3->headLen = 2;
   11229:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer3->datalen = 4;
   11230:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   11237:	00 00 00 
	amTxedBuffer3->retxCount = -1;
   1123a:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   11241:	ff ff 
	amTxedBuffer3->segnum = 1;
   11243:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   1124a:	00 00 00 
	amTxedBuffer3->pos = 0;
   1124d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer3->segEnd[0] = 6;
   11254:	c7 40 50 06 00 00 00 	movl   $0x6,0x50(%eax)
	amTxedBuffer3->segStart[0] = 2;
   1125b:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   11262:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb3->len;
   11269:	8b 42 50             	mov    0x50(%edx),%eax
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   1126c:	8b 55 e8             	mov    -0x18(%ebp),%edx
	amTxedBuffer3->segnum = 1;
	amTxedBuffer3->pos = 0;
	amTxedBuffer3->segEnd[0] = 6;
	amTxedBuffer3->segStart[0] = 2;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
   1126f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->vt_s++;
   11275:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   1127c:	01 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1127d:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   11283:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11289:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1128f:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)

	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
   11295:	8b 7d d8             	mov    -0x28(%ebp),%edi
	new->prev = prev;
   11298:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   1129e:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   112a3:	89 10                	mov    %edx,(%eax)
   112a5:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8003;
   112a8:	66 c7 45 f2 03 80    	movw   $0x8003,-0xe(%ebp)
	fsm_mem_cpy(skb4->tail,&hdr,2);
   112ae:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   112b4:	e8 fc ff ff ff       	call   112b5 <addpkt_recvData+0x325>
	fsm_skb_put(skb4,2);
   112b9:	ba 02 00 00 00       	mov    $0x2,%edx
   112be:	89 f8                	mov    %edi,%eax
   112c0:	e8 fc ff ff ff       	call   112c1 <addpkt_recvData+0x331>
	fsm_mem_cpy(skb4->tail,str4,4);
   112c5:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   112cb:	b9 04 00 00 00       	mov    $0x4,%ecx
   112d0:	ba fc 08 00 00       	mov    $0x8fc,%edx
   112d5:	e8 fc ff ff ff       	call   112d6 <addpkt_recvData+0x346>
	fsm_skb_put(skb4,4);
   112da:	ba 04 00 00 00       	mov    $0x4,%edx
   112df:	89 f8                	mov    %edi,%eax
   112e1:	e8 fc ff ff ff       	call   112e2 <addpkt_recvData+0x352>
	amTxedBuffer4->segStart[1] = 8;

	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb4->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
   112e6:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
	fsm_skb_put(skb4,2);
	fsm_mem_cpy(skb4->tail,str4,4);
	fsm_skb_put(skb4,4);
	amTxedBuffer4->pkt = skb4;
   112ec:	89 3e                	mov    %edi,(%esi)
	amTxedBuffer4->SN = 0x0003;
   112ee:	66 c7 86 94 00 00 00 	movw   $0x3,0x94(%esi)
   112f5:	03 00 
	amTxedBuffer4->pktstatus = ANY_SEGMENT;
   112f7:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
	amTxedBuffer4->headLen = 2;
   112fe:	c7 46 0c 02 00 00 00 	movl   $0x2,0xc(%esi)
	amTxedBuffer4->datalen = 4;
   11305:	c7 86 98 00 00 00 04 	movl   $0x4,0x98(%esi)
   1130c:	00 00 00 
	amTxedBuffer4->retxCount = -1;
   1130f:	66 c7 86 96 00 00 00 	movw   $0xffff,0x96(%esi)
   11316:	ff ff 
	amTxedBuffer4->segnum = 2;
   11318:	c7 86 90 00 00 00 02 	movl   $0x2,0x90(%esi)
   1131f:	00 00 00 
	amTxedBuffer4->pos = 0;
   11322:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	amTxedBuffer4->segEnd[0] = 7;
   11329:	c7 46 50 07 00 00 00 	movl   $0x7,0x50(%esi)
	amTxedBuffer4->segStart[0] = 5;
   11330:	c7 46 10 05 00 00 00 	movl   $0x5,0x10(%esi)
	amTxedBuffer4->segEnd[1] = 10;
   11337:	c7 46 54 0a 00 00 00 	movl   $0xa,0x54(%esi)
	amTxedBuffer4->segStart[1] = 8;
   1133e:	c7 46 14 08 00 00 00 	movl   $0x8,0x14(%esi)

	amIns->amTransmittedBufferNum++;
   11345:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb4->len;
   1134c:	8b 47 50             	mov    0x50(%edi),%eax
   1134f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11355:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11358:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   1135e:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   11365:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11366:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1136c:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
	new->prev = prev;
   11372:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   11378:	89 10                	mov    %edx,(%eax)
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
	fsm_printf("has added data for ctrl_pkt_recv\n");
   1137a:	c7 04 24 1c 40 00 00 	movl   $0x401c,(%esp)
   11381:	e8 fc ff ff ff       	call   11382 <addpkt_recvData+0x3f2>
	FOUT;
}
   11386:	83 c4 20             	add    $0x20,%esp
   11389:	5b                   	pop    %ebx
   1138a:	5e                   	pop    %esi
   1138b:	5f                   	pop    %edi
   1138c:	5d                   	pop    %ebp
   1138d:	c3                   	ret    
   1138e:	66 90                	xchg   %ax,%ax

00011390 <addPktTranData>:

void addPktTranData(struct AM_Instance*amIns)
{
   11390:	55                   	push   %ebp
   11391:	89 e5                	mov    %esp,%ebp
   11393:	57                   	push   %edi
   11394:	56                   	push   %esi
   11395:	53                   	push   %ebx
   11396:	83 ec 0c             	sub    $0xc,%esp
   11399:	e8 fc ff ff ff       	call   1139a <addPktTranData+0xa>
   1139e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	FSM_PKT *skb1 = NULL;
	struct AmBuffer *amRecvBuffer1 = NULL;
	FSM_PKT *skb2 = NULL;
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
   113a1:	b8 06 00 00 00       	mov    $0x6,%eax
   113a6:	e8 fc ff ff ff       	call   113a7 <addPktTranData+0x17>
   113ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   113ae:	b8 a4 00 00 00       	mov    $0xa4,%eax
   113b3:	e8 fc ff ff ff       	call   113b4 <addPktTranData+0x24>
   113b8:	89 c7                	mov    %eax,%edi
	skb2= fsm_pkt_create(2+6);
   113ba:	b8 08 00 00 00       	mov    $0x8,%eax
   113bf:	e8 fc ff ff ff       	call   113c0 <addPktTranData+0x30>
   113c4:	89 c6                	mov    %eax,%esi
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   113c6:	b8 a4 00 00 00       	mov    $0xa4,%eax
   113cb:	e8 fc ff ff ff       	call   113cc <addPktTranData+0x3c>

	unsigned short data = 0x0000;
   113d0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	unsigned short hdr = 0X0000;
   113d6:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb2= fsm_pkt_create(2+6);
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   113dc:	89 c3                	mov    %eax,%ebx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);
   113de:	e8 fc ff ff ff       	call   113df <addPktTranData+0x4f>

	hdr = 0x8000;
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
   113e3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   113e6:	b9 02 00 00 00       	mov    $0x2,%ecx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);

	hdr = 0x8000;
   113eb:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	data = 0x0001;	
   113f1:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
	fsm_mem_cpy(skb1->tail,&hdr,2);
   113f7:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   113fd:	8d 55 f2             	lea    -0xe(%ebp),%edx
   11400:	e8 fc ff ff ff       	call   11401 <addPktTranData+0x71>
	fsm_skb_put(skb1,2);
   11405:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11408:	ba 02 00 00 00       	mov    $0x2,%edx
   1140d:	e8 fc ff ff ff       	call   1140e <addPktTranData+0x7e>
	fsm_mem_cpy(skb1->tail,&data,2);
   11412:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11415:	b9 02 00 00 00       	mov    $0x2,%ecx
   1141a:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   11420:	8d 55 f0             	lea    -0x10(%ebp),%edx
   11423:	e8 fc ff ff ff       	call   11424 <addPktTranData+0x94>
	fsm_skb_put(skb1,2);
   11428:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1142b:	ba 02 00 00 00       	mov    $0x2,%edx
   11430:	e8 fc ff ff ff       	call   11431 <addPktTranData+0xa1>
	amRecvBuffer1->pkt = skb1;
   11435:	8b 45 e8             	mov    -0x18(%ebp),%eax

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11438:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
   1143d:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   11444:	00 00 

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11446:	8d 55 f2             	lea    -0xe(%ebp),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
   11449:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amRecvBuffer1->headLen = 2;
   11450:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
   11457:	89 07                	mov    %eax,(%edi)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11459:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
   1145c:	66 c7 87 96 00 00 00 	movw   $0x0,0x96(%edi)
   11463:	00 00 
	amRecvBuffer1->segnum = 0;
   11465:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   1146c:	00 00 00 
	amIns->vr_r++;
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
   1146f:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11475:	66 83 80 f4 22 00 00 	addw   $0x1,0x22f4(%eax)
   1147c:	01 
	amIns->amRecvWindow[0] = amRecvBuffer1;
   1147d:	89 b8 6c 12 00 00    	mov    %edi,0x126c(%eax)

	amIns->amRecvWindow[1] = NULL;
   11483:	c7 80 70 12 00 00 00 	movl   $0x0,0x1270(%eax)
   1148a:	00 00 00 

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   1148d:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
   11493:	66 c7 45 f0 03 00    	movw   $0x3,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11499:	e8 fc ff ff ff       	call   1149a <addPktTranData+0x10a>
	fsm_skb_put(skb2,2);
   1149e:	ba 02 00 00 00       	mov    $0x2,%edx
   114a3:	89 f0                	mov    %esi,%eax
   114a5:	e8 fc ff ff ff       	call   114a6 <addPktTranData+0x116>
	fsm_mem_cpy(skb2->tail,&data,2);
   114aa:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   114b0:	b9 02 00 00 00       	mov    $0x2,%ecx
   114b5:	8d 55 f0             	lea    -0x10(%ebp),%edx
   114b8:	e8 fc ff ff ff       	call   114b9 <addPktTranData+0x129>
	fsm_skb_put(skb2,2);
   114bd:	ba 02 00 00 00       	mov    $0x2,%edx
   114c2:	89 f0                	mov    %esi,%eax
   114c4:	e8 fc ff ff ff       	call   114c5 <addPktTranData+0x135>
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
   114c9:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   114cf:	8d 55 f0             	lea    -0x10(%ebp),%edx
   114d2:	b9 02 00 00 00       	mov    $0x2,%ecx
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);
	data = 0x0004;
   114d7:	66 c7 45 f0 04 00    	movw   $0x4,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&data,2);
   114dd:	e8 fc ff ff ff       	call   114de <addPktTranData+0x14e>
	fsm_skb_put(skb2,2);
   114e2:	89 f0                	mov    %esi,%eax
   114e4:	ba 02 00 00 00       	mov    $0x2,%edx
   114e9:	e8 fc ff ff ff       	call   114ea <addPktTranData+0x15a>
	amRecvBuffer2->segEnd[0] = 1;
	amRecvBuffer2->segStart[1] = -1;
	amRecvBuffer2->segEnd[1] = -1;
	amRecvBuffer2->segStart[2] = -1;
	amRecvBuffer2->segEnd[2] = -1;
	amIns->amRecvWindow[2] = amRecvBuffer2;
   114ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb2,2);
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);

	amRecvBuffer2->pkt = skb2;
   114f1:	89 33                	mov    %esi,(%ebx)
	amRecvBuffer2->SN = 0x0002;
   114f3:	66 c7 83 94 00 00 00 	movw   $0x2,0x94(%ebx)
   114fa:	02 00 
	amRecvBuffer2->pktstatus = 2;
   114fc:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	amRecvBuffer2->headLen = 2;
   11503:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amRecvBuffer2->retxCount = 0;
   1150a:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   11511:	00 00 
	amRecvBuffer2->segnum = 3;
   11513:	c7 83 90 00 00 00 03 	movl   $0x3,0x90(%ebx)
   1151a:	00 00 00 
	amRecvBuffer2->segStart[0] = 0;
   1151d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	amRecvBuffer2->segEnd[0] = 1;
   11524:	c7 43 50 01 00 00 00 	movl   $0x1,0x50(%ebx)
	amRecvBuffer2->segStart[1] = -1;
   1152b:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
	amRecvBuffer2->segEnd[1] = -1;
   11532:	c7 43 54 ff ff ff ff 	movl   $0xffffffff,0x54(%ebx)
	amRecvBuffer2->segStart[2] = -1;
   11539:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
	amRecvBuffer2->segEnd[2] = -1;
   11540:	c7 43 58 ff ff ff ff 	movl   $0xffffffff,0x58(%ebx)
	amIns->amRecvWindow[2] = amRecvBuffer2;
   11547:	89 98 74 12 00 00    	mov    %ebx,0x1274(%eax)
	amIns->vr_h = 3;
   1154d:	66 c7 80 ee 22 00 00 	movw   $0x3,0x22ee(%eax)
   11554:	03 00 
	amIns->vr_ms = 1;
   11556:	66 c7 80 f2 22 00 00 	movw   $0x1,0x22f2(%eax)
   1155d:	01 00 
   1155f:	83 c4 0c             	add    $0xc,%esp
   11562:	5b                   	pop    %ebx
   11563:	5e                   	pop    %esi
   11564:	5f                   	pop    %edi
   11565:	5d                   	pop    %ebp
   11566:	c3                   	ret    
   11567:	90                   	nop
   11568:	90                   	nop
   11569:	90                   	nop
   1156a:	90                   	nop
   1156b:	90                   	nop
   1156c:	90                   	nop
   1156d:	90                   	nop
   1156e:	90                   	nop
   1156f:	90                   	nop

00011570 <Assemble_ctrlPduPart2>:
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11570:	55                   	push   %ebp
   11571:	89 e5                	mov    %esp,%ebp
   11573:	57                   	push   %edi
   11574:	56                   	push   %esi
   11575:	53                   	push   %ebx
   11576:	83 ec 1c             	sub    $0x1c,%esp
   11579:	e8 fc ff ff ff       	call   1157a <Assemble_ctrlPduPart2+0xa>
   1157e:	89 c7                	mov    %eax,%edi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11580:	b8 02 00 00 00       	mov    $0x2,%eax
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11585:	89 ce                	mov    %ecx,%esi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11587:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1158a:	e8 fc ff ff ff       	call   1158b <Assemble_ctrlPduPart2+0x1b>
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1158f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11592:	89 d1                	mov    %edx,%ecx
   11594:	c1 e1 06             	shl    $0x6,%ecx
   11597:	66 c1 ea 02          	shr    $0x2,%dx
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   1159b:	89 c3                	mov    %eax,%ebx
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1159d:	88 50 01             	mov    %dl,0x1(%eax)
	part2->E2 = 1;	
   115a0:	89 c8                	mov    %ecx,%eax
   115a2:	83 c8 10             	or     $0x10,%eax
   115a5:	88 45 eb             	mov    %al,-0x15(%ebp)
   115a8:	88 03                	mov    %al,(%ebx)
	if (*pduLen + 6 < size)
   115aa:	8b 06                	mov    (%esi),%eax
   115ac:	8d 50 06             	lea    0x6(%eax),%edx
   115af:	89 55 f0             	mov    %edx,-0x10(%ebp)
   115b2:	8b 55 08             	mov    0x8(%ebp),%edx
   115b5:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   115b8:	73 66                	jae    11620 <Assemble_ctrlPduPart2+0xb0>
	{
		part2->E1 =1;
   115ba:	83 c9 30             	or     $0x30,%ecx
   115bd:	ba 01 00 00 00       	mov    $0x1,%edx
   115c2:	88 0b                	mov    %cl,(%ebx)
   115c4:	8b 06                	mov    (%esi),%eax
	}
	else if (*pduLen + 6 == size)
	{
		part2->E1 =0;
	}
	fsm_printf("[RLC][Assemble_ctrlPduPart2] pdulen = %d, size = %d, E1 = %d\n",*pduLen,size,part2->E1);
   115c6:	89 54 24 0c          	mov    %edx,0xc(%esp)
   115ca:	8b 55 08             	mov    0x8(%ebp),%edx
   115cd:	89 44 24 04          	mov    %eax,0x4(%esp)
   115d1:	c7 04 24 40 40 00 00 	movl   $0x4040,(%esp)
   115d8:	89 54 24 08          	mov    %edx,0x8(%esp)
   115dc:	e8 fc ff ff ff       	call   115dd <Assemble_ctrlPduPart2+0x6d>
	*(u16 *)part2 = htons(*(u16 *)part2);
	fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   115e1:	b9 02 00 00 00       	mov    $0x2,%ecx
   115e6:	89 da                	mov    %ebx,%edx
   115e8:	66 c1 03 08          	rolw   $0x8,(%ebx)
   115ec:	8b 07                	mov    (%edi),%eax
   115ee:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   115f4:	e8 fc ff ff ff       	call   115f5 <Assemble_ctrlPduPart2+0x85>
	fsm_skb_put(ctrlBf->pkt,2);
   115f9:	8b 07                	mov    (%edi),%eax
   115fb:	ba 02 00 00 00       	mov    $0x2,%edx
   11600:	e8 fc ff ff ff       	call   11601 <Assemble_ctrlPduPart2+0x91>
	*pduLen += 2;
   11605:	83 06 02             	addl   $0x2,(%esi)
	if ( part2 != NULL )
   11608:	85 db                	test   %ebx,%ebx
   1160a:	74 07                	je     11613 <Assemble_ctrlPduPart2+0xa3>
	{
		fsm_mem_free(part2);
   1160c:	89 d8                	mov    %ebx,%eax
   1160e:	e8 fc ff ff ff       	call   1160f <Assemble_ctrlPduPart2+0x9f>
		part2=NULL;
	}
}
   11613:	83 c4 1c             	add    $0x1c,%esp
   11616:	5b                   	pop    %ebx
   11617:	5e                   	pop    %esi
   11618:	5f                   	pop    %edi
   11619:	5d                   	pop    %ebp
   1161a:	c3                   	ret    
   1161b:	90                   	nop
   1161c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	part2->E2 = 1;	
	if (*pduLen + 6 < size)
	{
		part2->E1 =1;
	}
	else if (*pduLen + 6 == size)
   11620:	74 06                	je     11628 <Assemble_ctrlPduPart2+0xb8>
	{
		part2->E1 =0;
   11622:	31 d2                	xor    %edx,%edx
   11624:	eb a0                	jmp    115c6 <Assemble_ctrlPduPart2+0x56>
   11626:	66 90                	xchg   %ax,%ax
   11628:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   1162c:	83 e2 df             	and    $0xffffffdf,%edx
   1162f:	88 13                	mov    %dl,(%ebx)
   11631:	31 d2                	xor    %edx,%edx
   11633:	8b 06                	mov    (%esi),%eax
   11635:	eb 8f                	jmp    115c6 <Assemble_ctrlPduPart2+0x56>
   11637:	89 f6                	mov    %esi,%esi
   11639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00011640 <size_of_ctrl_pdu>:
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
{
   11640:	55                   	push   %ebp
   11641:	89 e5                	mov    %esp,%ebp
   11643:	57                   	push   %edi
   11644:	56                   	push   %esi
   11645:	53                   	push   %ebx
   11646:	83 ec 0c             	sub    $0xc,%esp
   11649:	e8 fc ff ff ff       	call   1164a <size_of_ctrl_pdu+0xa>
	u32 size = 0;
	int i;
	//PDU
	size = 2;  //
   1164e:	bb 02 00 00 00       	mov    $0x2,%ebx
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
   11653:	0f bf 90 ee 22 00 00 	movswl 0x22ee(%eax),%edx
   1165a:	0f bf 88 f4 22 00 00 	movswl 0x22f4(%eax),%ecx
   11661:	83 ea 01             	sub    $0x1,%edx
   11664:	39 d1                	cmp    %edx,%ecx
   11666:	7c 20                	jl     11688 <size_of_ctrl_pdu+0x48>
					}
				}
			}
		}
	}
	fsm_printf("[RLC][size_of_ctrl_pdu] size of ctrl pdu is %d\n",size);
   11668:	89 5c 24 04          	mov    %ebx,0x4(%esp)
   1166c:	c7 04 24 80 40 00 00 	movl   $0x4080,(%esp)
   11673:	e8 fc ff ff ff       	call   11674 <size_of_ctrl_pdu+0x34>
	return size;
}
   11678:	89 d8                	mov    %ebx,%eax
   1167a:	83 c4 0c             	add    $0xc,%esp
   1167d:	5b                   	pop    %ebx
   1167e:	5e                   	pop    %esi
   1167f:	5f                   	pop    %edi
   11680:	5d                   	pop    %ebp
   11681:	c3                   	ret    
   11682:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   11688:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
   1168f:	39 d1                	cmp    %edx,%ecx
   11691:	7d d5                	jge    11668 <size_of_ctrl_pdu+0x28>
**Created Date: 2014/10/15
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
   11693:	29 ca                	sub    %ecx,%edx
   11695:	c1 e2 02             	shl    $0x2,%edx
   11698:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1169b:	8d 3c 88             	lea    (%eax,%ecx,4),%edi
   1169e:	31 d2                	xor    %edx,%edx
   116a0:	eb 13                	jmp    116b5 <size_of_ctrl_pdu+0x75>
   116a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
   116a8:	83 f9 03             	cmp    $0x3,%ecx
   116ab:	74 43                	je     116f0 <size_of_ctrl_pdu+0xb0>
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   116ad:	83 c2 04             	add    $0x4,%edx
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   116b0:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   116b3:	74 b3                	je     11668 <size_of_ctrl_pdu+0x28>
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
   116b5:	8b 84 17 6c 12 00 00 	mov    0x126c(%edi,%edx,1),%eax
   116bc:	85 c0                	test   %eax,%eax
   116be:	74 28                	je     116e8 <size_of_ctrl_pdu+0xa8>
			{
				size += 2;//2
			}
			else //PDU
			{
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)
   116c0:	8b 48 04             	mov    0x4(%eax),%ecx
   116c3:	83 f9 01             	cmp    $0x1,%ecx
   116c6:	74 e5                	je     116ad <size_of_ctrl_pdu+0x6d>
				{
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{
						size += 6;//soendsostart6
   116c8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   116cc:	8d 73 06             	lea    0x6(%ebx),%esi
   116cf:	0f 4f de             	cmovg  %esi,%ebx
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
   116d2:	83 f9 02             	cmp    $0x2,%ecx
   116d5:	75 d1                	jne    116a8 <size_of_ctrl_pdu+0x68>
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
   116d7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   116dd:	8d 04 40             	lea    (%eax,%eax,2),%eax
   116e0:	8d 5c 43 fa          	lea    -0x6(%ebx,%eax,2),%ebx
   116e4:	eb c7                	jmp    116ad <size_of_ctrl_pdu+0x6d>
   116e6:	66 90                	xchg   %ax,%ax
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
			{
				size += 2;//2
   116e8:	83 c3 02             	add    $0x2,%ebx
   116eb:	eb c0                	jmp    116ad <size_of_ctrl_pdu+0x6d>
   116ed:	8d 76 00             	lea    0x0(%esi),%esi
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   116f0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   116f6:	8d 04 40             	lea    (%eax,%eax,2),%eax
   116f9:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
   116fc:	eb af                	jmp    116ad <size_of_ctrl_pdu+0x6d>
   116fe:	66 90                	xchg   %ax,%ax

00011700 <rlc_ctrl_pkt_trans>:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   11700:	55                   	push   %ebp
   11701:	89 e5                	mov    %esp,%ebp
   11703:	57                   	push   %edi
   11704:	56                   	push   %esi
   11705:	53                   	push   %ebx
   11706:	83 ec 30             	sub    $0x30,%esp
   11709:	e8 fc ff ff ff       	call   1170a <rlc_ctrl_pkt_trans+0xa>
   1170e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32 pduLen;
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
   11711:	c7 04 24 b0 40 00 00 	movl   $0x40b0,(%esp)
   11718:	e8 fc ff ff ff       	call   11719 <rlc_ctrl_pkt_trans+0x19>
	pduLen = 0;
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   1171d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
	pduLen = 0;
   11720:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   11727:	e8 fc ff ff ff       	call   11728 <rlc_ctrl_pkt_trans+0x28>
   1172c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
   1172f:	89 44 24 04          	mov    %eax,0x4(%esp)
   11733:	c7 04 24 ec 40 00 00 	movl   $0x40ec,(%esp)
   1173a:	e8 fc ff ff ff       	call   1173b <rlc_ctrl_pkt_trans+0x3b>
	if( size < 2)  //PDU2
   1173f:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
   11743:	0f 86 fc 04 00 00    	jbe    11c45 <rlc_ctrl_pkt_trans+0x545>
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
   11749:	b8 0c 00 00 00       	mov    $0xc,%eax
   1174e:	e8 fc ff ff ff       	call   1174f <rlc_ctrl_pkt_trans+0x4f>
   11753:	89 45 ec             	mov    %eax,-0x14(%ebp)
	memset(ctrlBf,0,sizeof(struct Buffer));
   11756:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1175c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11763:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ctrlBf->pkt = fsm_pkt_create(size);
   1176a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1176d:	e8 fc ff ff ff       	call   1176e <rlc_ctrl_pkt_trans+0x6e>
   11772:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11775:	89 02                	mov    %eax,(%edx)
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11777:	b8 02 00 00 00       	mov    $0x2,%eax
   1177c:	e8 fc ff ff ff       	call   1177d <rlc_ctrl_pkt_trans+0x7d>
	memset(part1,0,sizeof(ctrlPduPart1));
   11781:	66 c7 00 00 00       	movw   $0x0,(%eax)
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
	memset(ctrlBf,0,sizeof(struct Buffer));
	ctrlBf->pkt = fsm_pkt_create(size);
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11786:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	part1->D_C = 0;
	part1->CPT = 0;
   11788:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	part1->ACK_SN = amIns->vr_ms;	
   1178c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1178f:	0f b6 90 f2 22 00 00 	movzbl 0x22f2(%eax),%edx
   11796:	0f b6 03             	movzbl (%ebx),%eax
   11799:	c1 e2 02             	shl    $0x2,%edx
   1179c:	83 e0 03             	and    $0x3,%eax
   1179f:	09 d0                	or     %edx,%eax
   117a1:	88 03                	mov    %al,(%ebx)
   117a3:	8b 55 d8             	mov    -0x28(%ebp),%edx
   117a6:	0f b7 82 f2 22 00 00 	movzwl 0x22f2(%edx),%eax
   117ad:	66 c1 e8 06          	shr    $0x6,%ax
   117b1:	83 e0 0f             	and    $0xf,%eax
   117b4:	88 43 01             	mov    %al,0x1(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
   117b7:	0f bf 82 f2 22 00 00 	movswl 0x22f2(%edx),%eax
   117be:	c7 04 24 40 41 00 00 	movl   $0x4140,(%esp)
   117c5:	89 44 24 04          	mov    %eax,0x4(%esp)
   117c9:	e8 fc ff ff ff       	call   117ca <rlc_ctrl_pkt_trans+0xca>
	fsm_octets_print(part1,2);
   117ce:	ba 02 00 00 00       	mov    $0x2,%edx
   117d3:	89 d8                	mov    %ebx,%eax
   117d5:	e8 fc ff ff ff       	call   117d6 <rlc_ctrl_pkt_trans+0xd6>
	if( size == 2 )  //PDU
   117da:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
   117de:	0f 84 9b 02 00 00    	je     11a7f <rlc_ctrl_pkt_trans+0x37f>
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
   117e4:	c7 04 24 68 41 00 00 	movl   $0x4168,(%esp)
   117eb:	e8 fc ff ff ff       	call   117ec <rlc_ctrl_pkt_trans+0xec>
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   117f0:	b9 02 00 00 00       	mov    $0x2,%ecx
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
   117f5:	80 0b 02             	orb    $0x2,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   117f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   117fb:	66 c1 03 08          	rolw   $0x8,(%ebx)
   117ff:	8b 02                	mov    (%edx),%eax
   11801:	89 da                	mov    %ebx,%edx
   11803:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11809:	e8 fc ff ff ff       	call   1180a <rlc_ctrl_pkt_trans+0x10a>
		fsm_skb_put(ctrlBf->pkt,2);
   1180e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11811:	ba 02 00 00 00       	mov    $0x2,%edx
   11816:	8b 01                	mov    (%ecx),%eax
   11818:	e8 fc ff ff ff       	call   11819 <rlc_ctrl_pkt_trans+0x119>
		pduLen += 2;
   1181d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11820:	83 c0 02             	add    $0x2,%eax
		if( part1 != NULL )
   11823:	85 db                	test   %ebx,%ebx
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
   11825:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if( part1 != NULL )
   11828:	74 0a                	je     11834 <rlc_ctrl_pkt_trans+0x134>
		{
			fsm_mem_free(part1);
   1182a:	89 d8                	mov    %ebx,%eax
   1182c:	e8 fc ff ff ff       	call   1182d <rlc_ctrl_pkt_trans+0x12d>
   11831:	8b 45 f0             	mov    -0x10(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
   11834:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11837:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1183b:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11842:	89 44 24 08          	mov    %eax,0x8(%esp)
   11846:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
   1184d:	c7 04 24 94 41 00 00 	movl   $0x4194,(%esp)
   11854:	89 44 24 04          	mov    %eax,0x4(%esp)
   11858:	e8 fc ff ff ff       	call   11859 <rlc_ctrl_pkt_trans+0x159>
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1185d:	0f b7 83 f4 22 00 00 	movzwl 0x22f4(%ebx),%eax
   11864:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11867:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   1186a:	0f bf d0             	movswl %ax,%edx
   1186d:	0f 83 3d 02 00 00    	jae    11ab0 <rlc_ctrl_pkt_trans+0x3b0>
   11873:	0f bf 8b f2 22 00 00 	movswl 0x22f2(%ebx),%ecx
   1187a:	39 ca                	cmp    %ecx,%edx
   1187c:	0f 8d 2e 02 00 00    	jge    11ab0 <rlc_ctrl_pkt_trans+0x3b0>
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11882:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11885:	8d 5a 01             	lea    0x1(%edx),%ebx
   11888:	89 5d dc             	mov    %ebx,-0x24(%ebp)
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1188b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   1188f:	8d b4 91 6c 12 00 00 	lea    0x126c(%ecx,%edx,4),%esi
   11896:	66 90                	xchg   %ax,%ax
   11898:	8b 45 dc             	mov    -0x24(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   1189b:	c7 04 24 d4 41 00 00 	movl   $0x41d4,(%esp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   118a2:	83 e8 01             	sub    $0x1,%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   118a5:	89 44 24 04          	mov    %eax,0x4(%esp)
   118a9:	e8 fc ff ff ff       	call   118aa <rlc_ctrl_pkt_trans+0x1aa>
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
   118ae:	8b 0e                	mov    (%esi),%ecx
   118b0:	85 c9                	test   %ecx,%ecx
   118b2:	0f 84 f8 02 00 00    	je     11bb0 <rlc_ctrl_pkt_trans+0x4b0>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] != NULL\n");
   118b8:	c7 04 24 34 42 00 00 	movl   $0x4234,(%esp)
   118bf:	e8 fc ff ff ff       	call   118c0 <rlc_ctrl_pkt_trans+0x1c0>
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
   118c4:	8b 06                	mov    (%esi),%eax
   118c6:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   118ca:	0f 84 80 01 00 00    	je     11a50 <rlc_ctrl_pkt_trans+0x350>
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
   118d0:	8b 50 10             	mov    0x10(%eax),%edx
   118d3:	85 d2                	test   %edx,%edx
   118d5:	0f 8e 8d 00 00 00    	jle    11968 <rlc_ctrl_pkt_trans+0x268>
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
   118db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   118de:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   118e1:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   118e5:	89 04 24             	mov    %eax,(%esp)
   118e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   118eb:	e8 fc ff ff ff       	call   118ec <rlc_ctrl_pkt_trans+0x1ec>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   118f0:	b8 04 00 00 00       	mov    $0x4,%eax
   118f5:	e8 fc ff ff ff       	call   118f6 <rlc_ctrl_pkt_trans+0x1f6>
						memset(part3,0,sizeof(ctrlPduPart3));
   118fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11900:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
   11902:	c6 40 02 00          	movb   $0x0,0x2(%eax)
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   11906:	8b 06                	mov    (%esi),%eax
   11908:	8b 50 10             	mov    0x10(%eax),%edx
   1190b:	0f b6 03             	movzbl (%ebx),%eax
   1190e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
   11915:	83 e0 03             	and    $0x3,%eax
   11918:	09 c8                	or     %ecx,%eax
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1191a:	b9 04 00 00 00       	mov    $0x4,%ecx
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   1191f:	88 03                	mov    %al,(%ebx)
   11921:	89 d0                	mov    %edx,%eax
   11923:	66 c1 e8 06          	shr    $0x6,%ax
   11927:	88 43 01             	mov    %al,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   1192a:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1192d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11930:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
						*(u32 *)part3 = htons(*(u32 *)part3);
   11934:	0f b7 c0             	movzwl %ax,%eax
   11937:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11939:	8b 02                	mov    (%edx),%eax
   1193b:	89 da                	mov    %ebx,%edx
   1193d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11943:	e8 fc ff ff ff       	call   11944 <rlc_ctrl_pkt_trans+0x244>
						fsm_skb_put(ctrlBf->pkt,4);
   11948:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1194b:	ba 04 00 00 00       	mov    $0x4,%edx
   11950:	8b 01                	mov    (%ecx),%eax
   11952:	e8 fc ff ff ff       	call   11953 <rlc_ctrl_pkt_trans+0x253>
						pduLen += 4;
   11957:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   1195b:	85 db                	test   %ebx,%ebx
   1195d:	74 07                	je     11966 <rlc_ctrl_pkt_trans+0x266>
						{
							fsm_mem_free(part3);
   1195f:	89 d8                	mov    %ebx,%eax
   11961:	e8 fc ff ff ff       	call   11962 <rlc_ctrl_pkt_trans+0x262>
   11966:	8b 06                	mov    (%esi),%eax
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11968:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   1196e:	31 ff                	xor    %edi,%edi
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11970:	0f bf 5d e8          	movswl -0x18(%ebp),%ebx
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11974:	83 ea 01             	sub    $0x1,%edx
   11977:	39 d7                	cmp    %edx,%edi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11979:	89 5d e0             	mov    %ebx,-0x20(%ebp)
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   1197c:	0f 83 c4 00 00 00    	jae    11a46 <rlc_ctrl_pkt_trans+0x346>
   11982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11988:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1198b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1198e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11991:	89 04 24             	mov    %eax,(%esp)
   11994:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11997:	e8 fc ff ff ff       	call   11998 <rlc_ctrl_pkt_trans+0x298>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1199c:	b8 04 00 00 00       	mov    $0x4,%eax
   119a1:	e8 fc ff ff ff       	call   119a2 <rlc_ctrl_pkt_trans+0x2a2>
						memset(part3,0,sizeof(ctrlPduPart3));
   119a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   119ac:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   119ae:	8b 06                	mov    (%esi),%eax
   119b0:	8b 54 b8 50          	mov    0x50(%eax,%edi,4),%edx
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   119b4:	83 c7 01             	add    $0x1,%edi
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   119b7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
   119bb:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
   119be:	83 e0 01             	and    $0x1,%eax
   119c1:	09 c8                	or     %ecx,%eax
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   119c3:	b9 04 00 00 00       	mov    $0x4,%ecx
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   119c8:	66 c1 ea 07          	shr    $0x7,%dx
   119cc:	88 43 02             	mov    %al,0x2(%ebx)
   119cf:	88 53 03             	mov    %dl,0x3(%ebx)
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   119d2:	8b 16                	mov    (%esi),%edx
   119d4:	8b 54 ba 10          	mov    0x10(%edx,%edi,4),%edx
   119d8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   119db:	c1 e2 02             	shl    $0x2,%edx
   119de:	88 55 eb             	mov    %dl,-0x15(%ebp)
   119e1:	0f b6 13             	movzbl (%ebx),%edx
   119e4:	83 e2 03             	and    $0x3,%edx
   119e7:	0a 55 eb             	or     -0x15(%ebp),%dl
   119ea:	88 13                	mov    %dl,(%ebx)
   119ec:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
   119f0:	66 c1 ea 06          	shr    $0x6,%dx
   119f4:	88 53 01             	mov    %dl,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   119f7:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   119fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
   119fd:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
   11a01:	0f b7 c0             	movzwl %ax,%eax
   11a04:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11a06:	8b 02                	mov    (%edx),%eax
   11a08:	89 da                	mov    %ebx,%edx
   11a0a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11a10:	e8 fc ff ff ff       	call   11a11 <rlc_ctrl_pkt_trans+0x311>
						fsm_skb_put(ctrlBf->pkt,4);
   11a15:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11a18:	ba 04 00 00 00       	mov    $0x4,%edx
   11a1d:	8b 01                	mov    (%ecx),%eax
   11a1f:	e8 fc ff ff ff       	call   11a20 <rlc_ctrl_pkt_trans+0x320>
						pduLen += 4;
   11a24:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   11a28:	85 db                	test   %ebx,%ebx
   11a2a:	74 07                	je     11a33 <rlc_ctrl_pkt_trans+0x333>
						{
							fsm_mem_free(part3);
   11a2c:	89 d8                	mov    %ebx,%eax
   11a2e:	e8 fc ff ff ff       	call   11a2f <rlc_ctrl_pkt_trans+0x32f>
   11a33:	8b 06                	mov    (%esi),%eax
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11a35:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   11a3b:	83 ea 01             	sub    $0x1,%edx
   11a3e:	39 d7                	cmp    %edx,%edi
   11a40:	0f 82 42 ff ff ff    	jb     11988 <rlc_ctrl_pkt_trans+0x288>
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
   11a46:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
   11a4a:	0f 84 e1 00 00 00    	je     11b31 <rlc_ctrl_pkt_trans+0x431>
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
						if( part3 != NULL )
						{
							fsm_mem_free(part3);
   11a50:	8b 45 f0             	mov    -0x10(%ebp),%eax
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   11a53:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11a56:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
   11a59:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11a60:	0f 97 c2             	seta   %dl
   11a63:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   11a66:	0f 9f c0             	setg   %al
   11a69:	83 c6 04             	add    $0x4,%esi
   11a6c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   11a70:	66 83 45 e8 01       	addw   $0x1,-0x18(%ebp)
   11a75:	84 c2                	test   %al,%dl
   11a77:	0f 85 1b fe ff ff    	jne    11898 <rlc_ctrl_pkt_trans+0x198>
   11a7d:	eb 31                	jmp    11ab0 <rlc_ctrl_pkt_trans+0x3b0>
	part1->ACK_SN = amIns->vr_ms;	
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
	fsm_octets_print(part1,2);
	if( size == 2 )  //PDU
	{
		part1->E1 = 0;
   11a7f:	80 23 fd             	andb   $0xfd,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11a82:	89 da                	mov    %ebx,%edx
   11a84:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11a87:	66 c1 03 08          	rolw   $0x8,(%ebx)
   11a8b:	8b 01                	mov    (%ecx),%eax
   11a8d:	b9 02 00 00 00       	mov    $0x2,%ecx
   11a92:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11a98:	e8 fc ff ff ff       	call   11a99 <rlc_ctrl_pkt_trans+0x399>
		fsm_skb_put(ctrlBf->pkt,2);
   11a9d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   11aa0:	ba 02 00 00 00       	mov    $0x2,%edx
   11aa5:	8b 03                	mov    (%ebx),%eax
   11aa7:	e8 fc ff ff ff       	call   11aa8 <rlc_ctrl_pkt_trans+0x3a8>
		pduLen += 2;
   11aac:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   11ab0:	8b 45 d8             	mov    -0x28(%ebp),%eax
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   11ab3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11ab6:	8b 5d d8             	mov    -0x28(%ebp),%ebx
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   11ab9:	8b 90 bc 01 00 00    	mov    0x1bc(%eax),%edx
   11abf:	83 c2 01             	add    $0x1,%edx
   11ac2:	89 90 bc 01 00 00    	mov    %edx,0x1bc(%eax)
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   11ac8:	8b 01                	mov    (%ecx),%eax
   11aca:	8b 40 50             	mov    0x50(%eax),%eax
   11acd:	03 83 b8 01 00 00    	add    0x1b8(%ebx),%eax
   11ad3:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
   11ad9:	89 54 24 04          	mov    %edx,0x4(%esp)
   11add:	89 44 24 08          	mov    %eax,0x8(%esp)
   11ae1:	c7 04 24 70 42 00 00 	movl   $0x4270,(%esp)
   11ae8:	e8 fc ff ff ff       	call   11ae9 <rlc_ctrl_pkt_trans+0x3e9>
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
   11aed:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11af0:	89 d9                	mov    %ebx,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11af2:	8b 83 b4 01 00 00    	mov    0x1b4(%ebx),%eax
   11af8:	81 c1 b0 01 00 00    	add    $0x1b0,%ecx
   11afe:	83 c2 04             	add    $0x4,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11b01:	89 93 b4 01 00 00    	mov    %edx,0x1b4(%ebx)
   11b07:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	new->next = next;
	new->prev = prev;
   11b0a:	89 43 08             	mov    %eax,0x8(%ebx)
   11b0d:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = new;
   11b10:	89 10                	mov    %edx,(%eax)
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
   11b12:	8b 03                	mov    (%ebx),%eax
   11b14:	8b 50 50             	mov    0x50(%eax),%edx
   11b17:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11b1d:	e8 fc ff ff ff       	call   11b1e <rlc_ctrl_pkt_trans+0x41e>
	amIns->statFlag = false;
   11b22:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b25:	c6 40 06 00          	movb   $0x0,0x6(%eax)
	FOUT;
}
   11b29:	83 c4 30             	add    $0x30,%esp
   11b2c:	5b                   	pop    %ebx
   11b2d:	5e                   	pop    %esi
   11b2e:	5f                   	pop    %edi
   11b2f:	5d                   	pop    %ebp
   11b30:	c3                   	ret    
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11b31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11b34:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   11b37:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   11b3b:	89 04 24             	mov    %eax,(%esp)
   11b3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b41:	e8 fc ff ff ff       	call   11b42 <rlc_ctrl_pkt_trans+0x442>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11b46:	b8 04 00 00 00       	mov    $0x4,%eax
   11b4b:	e8 fc ff ff ff       	call   11b4c <rlc_ctrl_pkt_trans+0x44c>
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11b50:	b9 04 00 00 00       	mov    $0x4,%ecx
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
   11b55:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11b5b:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
   11b5d:	80 08 fc             	orb    $0xfc,(%eax)
   11b60:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
						*(u32 *)part3 = htons(*(u32 *)part3);
   11b64:	0f b7 00             	movzwl (%eax),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11b67:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11b6a:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
   11b6e:	0f b7 c0             	movzwl %ax,%eax
   11b71:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11b73:	8b 02                	mov    (%edx),%eax
   11b75:	89 da                	mov    %ebx,%edx
   11b77:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11b7d:	e8 fc ff ff ff       	call   11b7e <rlc_ctrl_pkt_trans+0x47e>
						fsm_skb_put(ctrlBf->pkt,4);
   11b82:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11b85:	ba 04 00 00 00       	mov    $0x4,%edx
   11b8a:	8b 01                	mov    (%ecx),%eax
   11b8c:	e8 fc ff ff ff       	call   11b8d <rlc_ctrl_pkt_trans+0x48d>
						pduLen += 4;
   11b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b94:	83 c0 04             	add    $0x4,%eax
						if( part3 != NULL )
   11b97:	85 db                	test   %ebx,%ebx
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
   11b99:	89 45 f0             	mov    %eax,-0x10(%ebp)
						if( part3 != NULL )
   11b9c:	0f 84 b1 fe ff ff    	je     11a53 <rlc_ctrl_pkt_trans+0x353>
						{
							fsm_mem_free(part3);
   11ba2:	89 d8                	mov    %ebx,%eax
   11ba4:	e8 fc ff ff ff       	call   11ba5 <rlc_ctrl_pkt_trans+0x4a5>
   11ba9:	e9 a2 fe ff ff       	jmp    11a50 <rlc_ctrl_pkt_trans+0x350>
   11bae:	66 90                	xchg   %ax,%ax
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] == NULL\n");
   11bb0:	c7 04 24 f8 41 00 00 	movl   $0x41f8,(%esp)
   11bb7:	e8 fc ff ff ff       	call   11bb8 <rlc_ctrl_pkt_trans+0x4b8>
				if( pduLen+2<=size )
   11bbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bbf:	8d 50 02             	lea    0x2(%eax),%edx
   11bc2:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
   11bc5:	0f 82 88 fe ff ff    	jb     11a53 <rlc_ctrl_pkt_trans+0x353>
				{
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11bcb:	b8 02 00 00 00       	mov    $0x2,%eax
   11bd0:	e8 fc ff ff ff       	call   11bd1 <rlc_ctrl_pkt_trans+0x4d1>
   11bd5:	89 c3                	mov    %eax,%ebx
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
   11bd7:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   11bdb:	c1 e0 06             	shl    $0x6,%eax
   11bde:	88 03                	mov    %al,(%ebx)
   11be0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   11be4:	66 c1 ea 02          	shr    $0x2,%dx
   11be8:	88 53 01             	mov    %dl,0x1(%ebx)
					if( pduLen+2==size )
   11beb:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11bee:	83 c2 02             	add    $0x2,%edx
   11bf1:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
   11bf4:	74 48                	je     11c3e <rlc_ctrl_pkt_trans+0x53e>
					{
						part2->E1=0; //E11
					}
					else
					{
						part2->E1=1;
   11bf6:	83 c8 20             	or     $0x20,%eax
   11bf9:	88 03                	mov    %al,(%ebx)
					}
					part2->E2=0;
   11bfb:	80 23 ef             	andb   $0xef,(%ebx)
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   11bfe:	b9 02 00 00 00       	mov    $0x2,%ecx
   11c03:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11c06:	66 c1 03 08          	rolw   $0x8,(%ebx)
   11c0a:	8b 02                	mov    (%edx),%eax
   11c0c:	89 da                	mov    %ebx,%edx
   11c0e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11c14:	e8 fc ff ff ff       	call   11c15 <rlc_ctrl_pkt_trans+0x515>
					fsm_skb_put(ctrlBf->pkt,2);
   11c19:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11c1c:	ba 02 00 00 00       	mov    $0x2,%edx
   11c21:	8b 01                	mov    (%ecx),%eax
   11c23:	e8 fc ff ff ff       	call   11c24 <rlc_ctrl_pkt_trans+0x524>
					pduLen += 2;
   11c28:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c2b:	83 c0 02             	add    $0x2,%eax
					if( part2 != NULL )
   11c2e:	85 db                	test   %ebx,%ebx
					}
					part2->E2=0;
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
					fsm_skb_put(ctrlBf->pkt,2);
					pduLen += 2;
   11c30:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if( part2 != NULL )
   11c33:	0f 85 69 ff ff ff    	jne    11ba2 <rlc_ctrl_pkt_trans+0x4a2>
   11c39:	e9 15 fe ff ff       	jmp    11a53 <rlc_ctrl_pkt_trans+0x353>
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
					if( pduLen+2==size )
					{
						part2->E1=0; //E11
   11c3e:	83 e0 df             	and    $0xffffffdf,%eax
   11c41:	88 03                	mov    %al,(%ebx)
   11c43:	eb b6                	jmp    11bfb <rlc_ctrl_pkt_trans+0x4fb>
	size = 0;
	size = size_of_ctrl_pdu(amIns);
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
	if( size < 2)  //PDU2
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
   11c45:	c7 04 24 14 41 00 00 	movl   $0x4114,(%esp)
   11c4c:	e8 fc ff ff ff       	call   11c4d <rlc_ctrl_pkt_trans+0x54d>
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
	amIns->statFlag = false;
	FOUT;
}
   11c51:	83 c4 30             	add    $0x30,%esp
   11c54:	5b                   	pop    %ebx
   11c55:	5e                   	pop    %esi
   11c56:	5f                   	pop    %edi
   11c57:	5d                   	pop    %ebp
   11c58:	c3                   	ret    
   11c59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00011c60 <ack_handler>:
**----------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014/10/13
**********************************************************************************************/
void ack_handler(struct AM_Instance *amIns,SequenceNumber ackSn)   //20141013
{
   11c60:	55                   	push   %ebp
   11c61:	89 e5                	mov    %esp,%ebp
   11c63:	57                   	push   %edi
   11c64:	56                   	push   %esi
   11c65:	53                   	push   %ebx
   11c66:	83 ec 10             	sub    $0x10,%esp
   11c69:	e8 fc ff ff ff       	call   11c6a <ack_handler+0xa>
   11c6e:	89 c3                	mov    %eax,%ebx
   11c70:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11c74:	0f b7 90 66 12 00 00 	movzwl 0x1266(%eax),%edx
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11c7b:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
   11c7f:	89 45 e8             	mov    %eax,-0x18(%ebp)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11c82:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
   11c88:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11c8b:	90                   	nop
   11c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11c90:	66 39 55 ee          	cmp    %dx,-0x12(%ebp)
   11c94:	7f 12                	jg     11ca8 <ack_handler+0x48>
   11c96:	0f bf c2             	movswl %dx,%eax
   11c99:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11c9f:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
   11ca2:	0f 8d 17 02 00 00    	jge    11ebf <ack_handler+0x25f>
   11ca8:	0f b7 b3 64 12 00 00 	movzwl 0x1264(%ebx),%esi
   11caf:	66 39 d6             	cmp    %dx,%si
   11cb2:	7f 14                	jg     11cc8 <ack_handler+0x68>
   11cb4:	0f bf c2             	movswl %dx,%eax
   11cb7:	0f bf f6             	movswl %si,%esi
   11cba:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11cc0:	39 ce                	cmp    %ecx,%esi
   11cc2:	0f 8d f7 01 00 00    	jge    11ebf <ack_handler+0x25f>
	{
		if( amIns->vt_a == amIns->pollSn )
   11cc8:	66 39 93 00 23 00 00 	cmp    %dx,0x2300(%ebx)
   11ccf:	0f 84 bb 01 00 00    	je     11e90 <ack_handler+0x230>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11cd5:	8b 8b f0 00 00 00    	mov    0xf0(%ebx),%ecx
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11cdb:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   11cde:	74 45                	je     11d25 <ack_handler+0xc5>
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11ce0:	8b 01                	mov    (%ecx),%eax
   11ce2:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11ce8:	8b 7d f0             	mov    -0x10(%ebp),%edi
   11ceb:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11cf0:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11cf4:	75 19                	jne    11d0f <ack_handler+0xaf>
   11cf6:	e9 2f 01 00 00       	jmp    11e2a <ack_handler+0x1ca>
   11cfb:	90                   	nop
   11cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11d00:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11d07:	0f 84 1b 01 00 00    	je     11e28 <ack_handler+0x1c8>
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11d0d:	89 f0                	mov    %esi,%eax
   11d0f:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11d15:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11d1b:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11d21:	39 cf                	cmp    %ecx,%edi
   11d23:	75 db                	jne    11d00 <ack_handler+0xa0>
   11d25:	8b 8b 9c 01 00 00    	mov    0x19c(%ebx),%ecx
			}
			//nposBf = NULL;
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
   11d2b:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
   11d31:	39 cf                	cmp    %ecx,%edi
   11d33:	74 3c                	je     11d71 <ack_handler+0x111>
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11d35:	8b 01                	mov    (%ecx),%eax
   11d37:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11d3d:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amRetxBf->SN == amIns->vt_a )
   11d42:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11d46:	75 13                	jne    11d5b <ack_handler+0xfb>
   11d48:	eb 50                	jmp    11d9a <ack_handler+0x13a>
   11d4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11d50:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11d57:	74 3f                	je     11d98 <ack_handler+0x138>
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11d59:	89 f0                	mov    %esi,%eax
   11d5b:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11d61:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11d67:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11d6d:	39 cf                	cmp    %ecx,%edi
   11d6f:	75 df                	jne    11d50 <ack_handler+0xf0>
					break;
				}
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
   11d71:	0f bf c2             	movswl %dx,%eax
   11d74:	83 c0 01             	add    $0x1,%eax
   11d77:	89 c1                	mov    %eax,%ecx
   11d79:	c1 f9 1f             	sar    $0x1f,%ecx
   11d7c:	c1 e9 16             	shr    $0x16,%ecx
   11d7f:	01 c8                	add    %ecx,%eax
   11d81:	25 ff 03 00 00       	and    $0x3ff,%eax
   11d86:	29 c8                	sub    %ecx,%eax
   11d88:	89 c2                	mov    %eax,%edx
   11d8a:	66 89 83 66 12 00 00 	mov    %ax,0x1266(%ebx)
   11d91:	e9 fa fe ff ff       	jmp    11c90 <ack_handler+0x30>
   11d96:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
   11d98:	89 c6                	mov    %eax,%esi
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11d9a:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
   11da0:	31 d2                	xor    %edx,%edx
   11da2:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   11da8:	85 ff                	test   %edi,%edi
   11daa:	74 1d                	je     11dc9 <ack_handler+0x169>
   11dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11db0:	03 44 96 10          	add    0x10(%esi,%edx,4),%eax
   11db4:	2b 44 96 50          	sub    0x50(%esi,%edx,4),%eax
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11db8:	83 c2 01             	add    $0x1,%edx
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11dbb:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11dc1:	3b 96 90 00 00 00    	cmp    0x90(%esi),%edx
   11dc7:	72 e7                	jb     11db0 <ack_handler+0x150>
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11dc9:	2b 46 0c             	sub    0xc(%esi),%eax
					amIns->amRetxBufferNum--;
   11dcc:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				{
					for( i = 0; i <amRetxBf->segnum; i++)
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11dd3:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
					amIns->amRetxBufferNum--;
					if(amRetxBf->pkt != NULL)
   11dd9:	8b 06                	mov    (%esi),%eax
   11ddb:	85 c0                	test   %eax,%eax
   11ddd:	74 0b                	je     11dea <ack_handler+0x18a>
					{
						fsm_pkt_destroy( amRetxBf->pkt );
   11ddf:	e8 fc ff ff ff       	call   11de0 <ack_handler+0x180>
						amRetxBf->pkt = NULL;
   11de4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11dea:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amRetxBf->list);
					if(amRetxBf != NULL)
   11df0:	85 f6                	test   %esi,%esi
   11df2:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11df8:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11dfb:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11dfd:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11e04:	01 10 00 
	entry->prev = LIST_POISON2;
   11e07:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11e0e:	02 20 00 
   11e11:	74 07                	je     11e1a <ack_handler+0x1ba>
					{
						fsm_mem_free(amRetxBf);
   11e13:	89 f0                	mov    %esi,%eax
   11e15:	e8 fc ff ff ff       	call   11e16 <ack_handler+0x1b6>
   11e1a:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11e21:	e9 4b ff ff ff       	jmp    11d71 <ack_handler+0x111>
   11e26:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11e28:	89 c6                	mov    %eax,%esi
				{
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11e2a:	8b 06                	mov    (%esi),%eax
   11e2c:	8b 40 50             	mov    0x50(%eax),%eax
   11e2f:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11e35:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					if(amTxedBuffer->pkt != NULL)
   11e3c:	8b 06                	mov    (%esi),%eax
   11e3e:	85 c0                	test   %eax,%eax
   11e40:	74 0b                	je     11e4d <ack_handler+0x1ed>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   11e42:	e8 fc ff ff ff       	call   11e43 <ack_handler+0x1e3>
						amTxedBuffer->pkt = NULL;
   11e47:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11e4d:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   11e53:	85 f6                	test   %esi,%esi
   11e55:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11e5b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11e5e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11e60:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11e67:	01 10 00 
	entry->prev = LIST_POISON2;
   11e6a:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11e71:	02 20 00 
   11e74:	74 07                	je     11e7d <ack_handler+0x21d>
					{
						fsm_mem_free(amTxedBuffer);
   11e76:	89 f0                	mov    %esi,%eax
   11e78:	e8 fc ff ff ff       	call   11e79 <ack_handler+0x219>
   11e7d:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11e84:	e9 9c fe ff ff       	jmp    11d25 <ack_handler+0xc5>
   11e89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
	{
		if( amIns->vt_a == amIns->pollSn )
		{
			//
			if(amIns->pollRetxTimer)
   11e90:	8b 43 08             	mov    0x8(%ebx),%eax
   11e93:	85 c0                	test   %eax,%eax
   11e95:	0f 84 3a fe ff ff    	je     11cd5 <ack_handler+0x75>
			{
				fsm_schedule_cancel(amIns->pollRetxTimer);
   11e9b:	e8 fc ff ff ff       	call   11e9c <ack_handler+0x23c>
				amIns->pollRetxTimer = 0;
   11ea0:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
   11ea7:	c7 04 24 b4 42 00 00 	movl   $0x42b4,(%esp)
   11eae:	e8 fc ff ff ff       	call   11eaf <ack_handler+0x24f>
   11eb3:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11eba:	e9 16 fe ff ff       	jmp    11cd5 <ack_handler+0x75>
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
	}
	amIns->vt_ms = (amIns->vt_a + AM_WINDOW_SIZE)%(AM_WINDOW_SIZE*2);
   11ebf:	05 00 02 00 00       	add    $0x200,%eax
   11ec4:	89 c2                	mov    %eax,%edx
   11ec6:	c1 fa 1f             	sar    $0x1f,%edx
   11ec9:	c1 ea 16             	shr    $0x16,%edx
   11ecc:	01 d0                	add    %edx,%eax
   11ece:	25 ff 03 00 00       	and    $0x3ff,%eax
   11ed3:	29 d0                	sub    %edx,%eax
   11ed5:	66 89 83 68 12 00 00 	mov    %ax,0x1268(%ebx)
}
   11edc:	83 c4 10             	add    $0x10,%esp
   11edf:	5b                   	pop    %ebx
   11ee0:	5e                   	pop    %esi
   11ee1:	5f                   	pop    %edi
   11ee2:	5d                   	pop    %ebp
   11ee3:	c3                   	ret    
   11ee4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11eea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00011ef0 <no_so_handler>:
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11ef0:	55                   	push   %ebp
   11ef1:	89 e5                	mov    %esp,%ebp
   11ef3:	57                   	push   %edi
   11ef4:	56                   	push   %esi
   11ef5:	53                   	push   %ebx
   11ef6:	83 ec 14             	sub    $0x14,%esp
   11ef9:	e8 fc ff ff ff       	call   11efa <no_so_handler+0xa>
   11efe:	89 c3                	mov    %eax,%ebx
   11f00:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11f03:	8d bb f0 00 00 00    	lea    0xf0(%ebx),%edi
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11f09:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	struct AmBuffer *amTxedBuffer;	//
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
   11f0c:	c7 04 24 e0 42 00 00 	movl   $0x42e0,(%esp)
   11f13:	e8 fc ff ff ff       	call   11f14 <no_so_handler+0x24>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11f18:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11f1e:	39 c7                	cmp    %eax,%edi
   11f20:	74 61                	je     11f83 <no_so_handler+0x93>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11f22:	8b 10                	mov    (%eax),%edx
   11f24:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11f2a:	8b 75 f0             	mov    -0x10(%ebp),%esi
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11f2d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   11f30:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11f33:	0f b6 16             	movzbl (%esi),%edx
   11f36:	0f b6 76 01          	movzbl 0x1(%esi),%esi
   11f3a:	c0 ea 06             	shr    $0x6,%dl
   11f3d:	0f b6 d2             	movzbl %dl,%edx
   11f40:	c1 e6 02             	shl    $0x2,%esi
   11f43:	09 d6                	or     %edx,%esi
   11f45:	0f bf 50 f8          	movswl -0x8(%eax),%edx
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11f49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f4c:	2d 9c 00 00 00       	sub    $0x9c,%eax
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11f51:	39 d6                	cmp    %edx,%esi
   11f53:	75 18                	jne    11f6d <no_so_handler+0x7d>
   11f55:	e9 e7 01 00 00       	jmp    12141 <no_so_handler+0x251>
   11f5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11f60:	0f bf 90 94 00 00 00 	movswl 0x94(%eax),%edx
   11f67:	39 f2                	cmp    %esi,%edx
   11f69:	74 25                	je     11f90 <no_so_handler+0xa0>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11f6b:	89 c8                	mov    %ecx,%eax
   11f6d:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   11f73:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   11f79:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   11f7f:	39 d7                	cmp    %edx,%edi
   11f81:	75 dd                	jne    11f60 <no_so_handler+0x70>
				break;
			}
		}
	}
	FOUT;
}
   11f83:	83 c4 14             	add    $0x14,%esp
   11f86:	5b                   	pop    %ebx
   11f87:	5e                   	pop    %esi
   11f88:	5f                   	pop    %edi
   11f89:	5d                   	pop    %ebp
   11f8a:	c3                   	ret    
   11f8b:	90                   	nop
   11f8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11f90:	89 c6                	mov    %eax,%esi
			{
				*isPduFound = true;
   11f92:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11f95:	c6 01 01             	movb   $0x1,(%ecx)
				amTxedBuffer->segStart[0] = 0;
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11f98:	8b 06                	mov    (%esi),%eax
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
			{
				*isPduFound = true;
				amTxedBuffer->segStart[0] = 0;
   11f9a:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11fa1:	8b 40 50             	mov    0x50(%eax),%eax
   11fa4:	89 46 50             	mov    %eax,0x50(%esi)

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   11fa7:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   11fae:	66 83 f8 ff          	cmp    $0xffff,%ax
   11fb2:	0f 84 28 01 00 00    	je     120e0 <no_so_handler+0x1f0>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   11fb8:	83 c0 01             	add    $0x1,%eax
   11fbb:	66 89 86 96 00 00 00 	mov    %ax,0x96(%esi)
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
   11fc2:	c7 04 24 10 43 00 00 	movl   $0x4310,(%esp)
   11fc9:	e8 fc ff ff ff       	call   11fca <no_so_handler+0xda>
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   11fce:	0f bf 96 96 00 00 00 	movswl 0x96(%esi),%edx
   11fd5:	0f b7 83 fa 22 00 00 	movzwl 0x22fa(%ebx),%eax
   11fdc:	39 c2                	cmp    %eax,%edx
   11fde:	74 18                	je     11ff8 <no_so_handler+0x108>
						}
					}
				}
				else
				{
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   11fe0:	c7 04 24 38 43 00 00 	movl   $0x4338,(%esp)
   11fe7:	e8 fc ff ff ff       	call   11fe8 <no_so_handler+0xf8>
				break;
			}
		}
	}
	FOUT;
}
   11fec:	83 c4 14             	add    $0x14,%esp
   11fef:	5b                   	pop    %ebx
   11ff0:	5e                   	pop    %esi
   11ff1:	5f                   	pop    %edi
   11ff2:	5d                   	pop    %ebp
   11ff3:	c3                   	ret    
   11ff4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   11ff8:	b8 04 00 00 00       	mov    $0x4,%eax
   11ffd:	e8 fc ff ff ff       	call   11ffe <no_so_handler+0x10e>
					mioctrl->eventCode = 0;
   12002:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12007:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
   1200b:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   1200e:	e8 fc ff ff ff       	call   1200f <no_so_handler+0x11f>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   12013:	8b 06                	mov    (%esi),%eax
   12015:	8b 40 50             	mov    0x50(%eax),%eax
   12018:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   1201e:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   12025:	8b 06                	mov    (%esi),%eax
   12027:	e8 fc ff ff ff       	call   12028 <no_so_handler+0x138>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   1202c:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   12032:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
					amTxedBuffer->pkt = NULL;
   12038:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1203e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   12041:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   12043:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12045:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   1204c:	01 10 00 
	entry->prev = LIST_POISON2;
   1204f:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   12056:	02 20 00 
   12059:	e8 fc ff ff ff       	call   1205a <no_so_handler+0x16a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   1205e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12064:	8d 93 9c 01 00 00    	lea    0x19c(%ebx),%edx
   1206a:	39 c2                	cmp    %eax,%edx
   1206c:	0f 84 11 ff ff ff    	je     11f83 <no_so_handler+0x93>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12072:	8b 30                	mov    (%eax),%esi
   12074:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   1207a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   1207d:	89 7d ec             	mov    %edi,-0x14(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   12080:	0f bf 40 f8          	movswl -0x8(%eax),%eax
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12084:	89 75 e8             	mov    %esi,-0x18(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   12087:	0f b6 31             	movzbl (%ecx),%esi
   1208a:	89 f1                	mov    %esi,%ecx
   1208c:	c0 e9 06             	shr    $0x6,%cl
   1208f:	89 ce                	mov    %ecx,%esi
   12091:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12094:	81 e6 ff 00 00 00    	and    $0xff,%esi
   1209a:	0f b6 79 01          	movzbl 0x1(%ecx),%edi
   1209e:	c1 e7 02             	shl    $0x2,%edi
   120a1:	09 f7                	or     %esi,%edi
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   120a3:	8b 75 e8             	mov    -0x18(%ebp),%esi
   120a6:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   120ac:	39 f8                	cmp    %edi,%eax
   120ae:	75 15                	jne    120c5 <no_so_handler+0x1d5>
   120b0:	eb 3c                	jmp    120ee <no_so_handler+0x1fe>
   120b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   120b8:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   120bf:	39 f8                	cmp    %edi,%eax
   120c1:	74 2e                	je     120f1 <no_so_handler+0x201>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   120c3:	89 ce                	mov    %ecx,%esi
   120c5:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
   120cb:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   120d1:	8d 86 9c 00 00 00    	lea    0x9c(%esi),%eax
   120d7:	39 c2                	cmp    %eax,%edx
   120d9:	75 dd                	jne    120b8 <no_so_handler+0x1c8>
   120db:	e9 a3 fe ff ff       	jmp    11f83 <no_so_handler+0x93>
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   120e0:	66 c7 86 96 00 00 00 	movw   $0x0,0x96(%esi)
   120e7:	00 00 
   120e9:	e9 d4 fe ff ff       	jmp    11fc2 <no_so_handler+0xd2>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   120ee:	8b 75 ec             	mov    -0x14(%ebp),%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
							{
								amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   120f1:	8b 06                	mov    (%esi),%eax
   120f3:	8b 40 50             	mov    0x50(%eax),%eax
   120f6:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
								amIns->amRetxBufferNum--;
   120fc:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
								fsm_pkt_destroy( amRetxBf->pkt );
   12103:	8b 06                	mov    (%esi),%eax
   12105:	e8 fc ff ff ff       	call   12106 <no_so_handler+0x216>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   1210a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   12110:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
								amRetxBf->pkt = NULL;
   12116:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1211c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1211f:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   12121:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12123:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   1212a:	01 10 00 
	entry->prev = LIST_POISON2;
   1212d:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   12134:	02 20 00 
   12137:	e8 fc ff ff ff       	call   12138 <no_so_handler+0x248>
								amRetxBf = NULL;
								break;
   1213c:	e9 42 fe ff ff       	jmp    11f83 <no_so_handler+0x93>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12141:	89 ce                	mov    %ecx,%esi
   12143:	e9 4a fe ff ff       	jmp    11f92 <no_so_handler+0xa2>
   12148:	90                   	nop
   12149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00012150 <rlc_ctrl_pkt_recv>:
**Modified by:
**Modified Date:
************************************************************************/

void rlc_ctrl_pkt_recv(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   12150:	55                   	push   %ebp
   12151:	89 e5                	mov    %esp,%ebp
   12153:	56                   	push   %esi
   12154:	53                   	push   %ebx
   12155:	83 ec 08             	sub    $0x8,%esp
   12158:	e8 fc ff ff ff       	call   12159 <rlc_ctrl_pkt_recv+0x9>
   1215d:	89 d6                	mov    %edx,%esi
	u32 pduLen=0;
	u8 E1=0;
	bool isPduFound = false;

	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
   1215f:	c7 04 24 64 43 00 00 	movl   $0x4364,(%esp)
   12166:	e8 fc ff ff ff       	call   12167 <rlc_ctrl_pkt_recv+0x17>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
   1216b:	8b 46 50             	mov    0x50(%esi),%eax
   1216e:	c7 04 24 a4 43 00 00 	movl   $0x43a4,(%esp)
   12175:	89 44 24 04          	mov    %eax,0x4(%esp)
   12179:	e8 fc ff ff ff       	call   1217a <rlc_ctrl_pkt_recv+0x2a>
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   1217e:	b8 02 00 00 00       	mov    $0x2,%eax
   12183:	e8 fc ff ff ff       	call   12184 <rlc_ctrl_pkt_recv+0x34>
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   12188:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
	memset(part1,0,sizeof(ctrlPduPart1));
   1218d:	66 c7 00 00 00       	movw   $0x0,(%eax)
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   12192:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   12198:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   1219a:	e8 fc ff ff ff       	call   1219b <rlc_ctrl_pkt_recv+0x4b>
	fsm_skb_pull(pkt,2);
   1219f:	ba 02 00 00 00       	mov    $0x2,%edx
   121a4:	89 f0                	mov    %esi,%eax
   121a6:	e8 fc ff ff ff       	call   121a7 <rlc_ctrl_pkt_recv+0x57>
	*(u16 *)part1 = ntohs(*(u16 *)part1);
	pduLen -= 2;
	fsm_octets_print(part1,2);
   121ab:	ba 02 00 00 00       	mov    $0x2,%edx
   121b0:	89 d8                	mov    %ebx,%eax
   121b2:	66 c1 03 08          	rolw   $0x8,(%ebx)
   121b6:	e8 fc ff ff ff       	call   121b7 <rlc_ctrl_pkt_recv+0x67>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->E1 is %d)\n",part1->E1);	
   121bb:	0f b6 03             	movzbl (%ebx),%eax
   121be:	d0 e8                	shr    %al
   121c0:	83 e0 01             	and    $0x1,%eax
   121c3:	89 44 24 04          	mov    %eax,0x4(%esp)
   121c7:	c7 04 24 d0 43 00 00 	movl   $0x43d0,(%esp)
   121ce:	e8 fc ff ff ff       	call   121cf <rlc_ctrl_pkt_recv+0x7f>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->acksn is %d)\n",part1->ACK_SN);
   121d3:	0f b6 03             	movzbl (%ebx),%eax
   121d6:	c0 e8 02             	shr    $0x2,%al
   121d9:	0f b6 d0             	movzbl %al,%edx
   121dc:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   121e0:	c7 04 24 fc 43 00 00 	movl   $0x43fc,(%esp)
   121e7:	83 e0 0f             	and    $0xf,%eax
   121ea:	c1 e0 06             	shl    $0x6,%eax
   121ed:	09 d0                	or     %edx,%eax
   121ef:	89 44 24 04          	mov    %eax,0x4(%esp)
   121f3:	e8 fc ff ff ff       	call   121f4 <rlc_ctrl_pkt_recv+0xa4>
		{
			fsm_mem_free(part3);
			part3=NULL;
		}
	}
}
   121f8:	83 c4 08             	add    $0x8,%esp
   121fb:	5b                   	pop    %ebx
   121fc:	5e                   	pop    %esi
   121fd:	5d                   	pop    %ebp
   121fe:	c3                   	ret    
   121ff:	90                   	nop

00012200 <rlc_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_retx(struct AM_Instance *amIns,struct AmBuffer *amTxedBuffer)
{
   12200:	55                   	push   %ebp
   12201:	89 e5                	mov    %esp,%ebp
   12203:	57                   	push   %edi
   12204:	56                   	push   %esi
   12205:	53                   	push   %ebx
   12206:	83 ec 10             	sub    $0x10,%esp
   12209:	e8 fc ff ff ff       	call   1220a <rlc_retx+0xa>
   1220e:	89 c3                	mov    %eax,%ebx
   12210:	89 d6                	mov    %edx,%esi
	struct AmBuffer *amRetxBf;
	struct AmBuffer *nposBf;
	int i;

	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
   12212:	c7 04 24 2c 44 00 00 	movl   $0x442c,(%esp)
   12219:	e8 fc ff ff ff       	call   1221a <rlc_retx+0x1a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   1221e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
   12224:	8d 8b 9c 01 00 00    	lea    0x19c(%ebx),%ecx
   1222a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1222d:	39 c1                	cmp    %eax,%ecx
   1222f:	74 5a                	je     1228b <rlc_retx+0x8b>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12231:	8b 38                	mov    (%eax),%edi
   12233:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   12239:	0f b7 8e 94 00 00 00 	movzwl 0x94(%esi),%ecx
   12240:	0f b7 40 f8          	movzwl -0x8(%eax),%eax
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12244:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   1224a:	66 39 c8             	cmp    %cx,%ax
   1224d:	0f 84 a2 02 00 00    	je     124f5 <rlc_retx+0x2f5>
   12253:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12256:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   12259:	eb 17                	jmp    12272 <rlc_retx+0x72>
   1225b:	90                   	nop
   1225c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12260:	0f b7 87 94 00 00 00 	movzwl 0x94(%edi),%eax
   12267:	66 39 c8             	cmp    %cx,%ax
   1226a:	0f 84 b8 01 00 00    	je     12428 <rlc_retx+0x228>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12270:	89 d7                	mov    %edx,%edi
   12272:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
   12278:	8d 87 9c 00 00 00    	lea    0x9c(%edi),%eax
   1227e:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12284:	39 c3                	cmp    %eax,%ebx
   12286:	75 d8                	jne    12260 <rlc_retx+0x60>
   12288:	8b 5d ec             	mov    -0x14(%ebp),%ebx
		}
		//nposBf = NULL;
	}

	//
	amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   1228b:	8b 06                	mov    (%esi),%eax
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   1228d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12290:	8b 40 50             	mov    0x50(%eax),%eax
   12293:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum--;
   12299:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   122a0:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   122a6:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   122ac:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   122af:	89 10                	mov    %edx,(%eax)
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
   122b1:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   122b7:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   122be:	01 10 00 
	entry->prev = LIST_POISON2;
   122c1:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   122c8:	02 20 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   122cb:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   122d1:	89 93 a0 01 00 00    	mov    %edx,0x1a0(%ebx)
	new->next = next;
   122d7:	89 8e 9c 00 00 00    	mov    %ecx,0x9c(%esi)
	new->prev = prev;
   122dd:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   122e3:	89 10                	mov    %edx,(%eax)
	if( amTxedBuffer->pktstatus != FULL_SDU )
   122e5:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
   122e9:	0f 84 e9 01 00 00    	je     124d8 <rlc_retx+0x2d8>
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   122ef:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   122f5:	8b 93 a4 01 00 00    	mov    0x1a4(%ebx),%edx
   122fb:	85 c0                	test   %eax,%eax
   122fd:	74 29                	je     12328 <rlc_retx+0x128>
   122ff:	31 c0                	xor    %eax,%eax
   12301:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			if( amTxedBuffer->segStart[i] != -1 )
   12308:	8b 4c 86 10          	mov    0x10(%esi,%eax,4),%ecx
   1230c:	83 f9 ff             	cmp    $0xffffffff,%ecx
   1230f:	74 0c                	je     1231d <rlc_retx+0x11d>
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
   12311:	29 ca                	sub    %ecx,%edx
   12313:	03 54 86 50          	add    0x50(%esi,%eax,4),%edx
   12317:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	amIns->amTransmittedBufferNum--;
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
	if( amTxedBuffer->pktstatus != FULL_SDU )
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   1231d:	83 c0 01             	add    $0x1,%eax
   12320:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   12326:	72 e0                	jb     12308 <rlc_retx+0x108>
			if( amTxedBuffer->segStart[i] != -1 )
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
			}
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
   12328:	03 56 0c             	add    0xc(%esi),%edx
   1232b:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
	}
	amIns->amRetxBufferNum++;
   12331:	83 83 a8 01 00 00 01 	addl   $0x1,0x1a8(%ebx)
	fsm_printf("[RLC][rlc_retx] has move to RetxBuffer,%d\n",amTxedBuffer->SN);
   12338:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   1233f:	c7 04 24 90 44 00 00 	movl   $0x4490,(%esp)
   12346:	89 44 24 04          	mov    %eax,0x4(%esp)
   1234a:	e8 fc ff ff ff       	call   1234b <rlc_retx+0x14b>
	//
	amTxedBf = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1234f:	b8 a4 00 00 00       	mov    $0xa4,%eax
   12354:	e8 fc ff ff ff       	call   12355 <rlc_retx+0x155>
   12359:	89 c7                	mov    %eax,%edi
	//amTxedBf->pkt = fsm_pkt_create(amTxedBuffer->pkt->len+fsm_skb_headroom(amTxedBuffer->pkt));
	amTxedBf->pkt = fsm_pkt_duplicate(amTxedBuffer->pkt);
   1235b:	8b 06                	mov    (%esi),%eax
   1235d:	e8 fc ff ff ff       	call   1235e <rlc_retx+0x15e>
   12362:	89 07                	mov    %eax,(%edi)
	//fsm_mem_cpy(amTxedBf->pkt->data,amTxedBuffer->pkt->data,amTxedBuffer->pkt->len);
	//fsm_skb_put(amTxedBf->pkt,amTxedBuffer->pkt->len);
	amTxedBf->datalen = amTxedBuffer->datalen;
   12364:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
   1236a:	89 87 98 00 00 00    	mov    %eax,0x98(%edi)
	amTxedBf->headLen = amTxedBuffer->headLen;
   12370:	8b 46 0c             	mov    0xc(%esi),%eax
   12373:	89 47 0c             	mov    %eax,0xc(%edi)
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
   12376:	8b 46 04             	mov    0x4(%esi),%eax
   12379:	89 47 04             	mov    %eax,0x4(%edi)
	amTxedBf->pos = amTxedBuffer->pos;
   1237c:	8b 46 08             	mov    0x8(%esi),%eax
   1237f:	89 47 08             	mov    %eax,0x8(%edi)
	amTxedBf->retxCount = amTxedBuffer->retxCount;
   12382:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   12389:	66 89 87 96 00 00 00 	mov    %ax,0x96(%edi)
	amTxedBf->segnum = amTxedBuffer->segnum;
   12390:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12396:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
	for( i = 0;i < amTxedBuffer->segnum; i++)
   1239c:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   123a2:	85 c0                	test   %eax,%eax
   123a4:	74 1d                	je     123c3 <rlc_retx+0x1c3>
   123a6:	31 c0                	xor    %eax,%eax
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
   123a8:	8b 54 86 10          	mov    0x10(%esi,%eax,4),%edx
   123ac:	89 54 87 10          	mov    %edx,0x10(%edi,%eax,4)
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
   123b0:	8b 54 86 50          	mov    0x50(%esi,%eax,4),%edx
   123b4:	89 54 87 50          	mov    %edx,0x50(%edi,%eax,4)
	amTxedBf->headLen = amTxedBuffer->headLen;
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
	amTxedBf->pos = amTxedBuffer->pos;
	amTxedBf->retxCount = amTxedBuffer->retxCount;
	amTxedBf->segnum = amTxedBuffer->segnum;
	for( i = 0;i < amTxedBuffer->segnum; i++)
   123b8:	83 c0 01             	add    $0x1,%eax
   123bb:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   123c1:	72 e5                	jb     123a8 <rlc_retx+0x1a8>
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   123c3:	0f b7 86 94 00 00 00 	movzwl 0x94(%esi),%eax
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   123ca:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   123d0:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	for( i = 0;i < amTxedBuffer->segnum; i++)
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   123d6:	66 89 87 94 00 00 00 	mov    %ax,0x94(%edi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   123dd:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   123e3:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   123e9:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   123ef:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   123f5:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amTxedBf->pkt->len;
   123f7:	8b 07                	mov    (%edi),%eax
   123f9:	8b 40 50             	mov    0x50(%eax),%eax
   123fc:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum++;
   12402:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	fsm_printf("[RLC][rlc_retx] has copy to amTxedBuffer,%d\n",amTxedBuffer->SN);
   12409:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   12410:	c7 04 24 bc 44 00 00 	movl   $0x44bc,(%esp)
   12417:	89 44 24 04          	mov    %eax,0x4(%esp)
   1241b:	e8 fc ff ff ff       	call   1241c <rlc_retx+0x21c>
	FOUT;
}
   12420:	83 c4 10             	add    $0x10,%esp
   12423:	5b                   	pop    %ebx
   12424:	5e                   	pop    %esi
   12425:	5f                   	pop    %edi
   12426:	5d                   	pop    %ebp
   12427:	c3                   	ret    
   12428:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
   1242b:	98                   	cwtl   
   1242c:	89 44 24 04          	mov    %eax,0x4(%esp)
   12430:	c7 04 24 5c 44 00 00 	movl   $0x445c,(%esp)
   12437:	e8 fc ff ff ff       	call   12438 <rlc_retx+0x238>
				if( amRetxBf->pktstatus != FULL_SDU )
   1243c:	83 7f 04 01          	cmpl   $0x1,0x4(%edi)
   12440:	0f 84 a2 00 00 00    	je     124e8 <rlc_retx+0x2e8>
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   12446:	8b 87 90 00 00 00    	mov    0x90(%edi),%eax
   1244c:	8b 8b a4 01 00 00    	mov    0x1a4(%ebx),%ecx
   12452:	85 c0                	test   %eax,%eax
   12454:	74 22                	je     12478 <rlc_retx+0x278>
   12456:	31 c0                	xor    %eax,%eax
					{
						if( amRetxBf->segStart[i] != -1 )
   12458:	8b 54 87 10          	mov    0x10(%edi,%eax,4),%edx
   1245c:	83 fa ff             	cmp    $0xffffffff,%edx
   1245f:	74 0c                	je     1246d <rlc_retx+0x26d>
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12461:	2b 54 87 50          	sub    0x50(%edi,%eax,4),%edx
   12465:	01 d1                	add    %edx,%ecx
   12467:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
				if( amRetxBf->pktstatus != FULL_SDU )
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   1246d:	83 c0 01             	add    $0x1,%eax
   12470:	3b 87 90 00 00 00    	cmp    0x90(%edi),%eax
   12476:	72 e0                	jb     12458 <rlc_retx+0x258>
						if( amRetxBf->segStart[i] != -1 )
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
						}
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   12478:	2b 4f 0c             	sub    0xc(%edi),%ecx
   1247b:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
				}
				amIns->amRetxBufferNum--;
   12481:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				if(amRetxBf->pkt != NULL)
   12488:	8b 07                	mov    (%edi),%eax
   1248a:	85 c0                	test   %eax,%eax
   1248c:	74 0b                	je     12499 <rlc_retx+0x299>
				{
					fsm_pkt_destroy( amRetxBf->pkt );
   1248e:	e8 fc ff ff ff       	call   1248f <rlc_retx+0x28f>
					amRetxBf->pkt = NULL;
   12493:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12499:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
				}
				list_del(&amRetxBf->list);
				if(amRetxBf != NULL)
   1249f:	85 ff                	test   %edi,%edi
   124a1:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   124a7:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   124aa:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   124ac:	c7 87 9c 00 00 00 00 	movl   $0x100100,0x9c(%edi)
   124b3:	01 10 00 
	entry->prev = LIST_POISON2;
   124b6:	c7 87 a0 00 00 00 00 	movl   $0x200200,0xa0(%edi)
   124bd:	02 20 00 
   124c0:	0f 84 c5 fd ff ff    	je     1228b <rlc_retx+0x8b>
				{
					fsm_mem_free(amRetxBf);
   124c6:	89 f8                	mov    %edi,%eax
   124c8:	e8 fc ff ff ff       	call   124c9 <rlc_retx+0x2c9>
   124cd:	e9 b9 fd ff ff       	jmp    1228b <rlc_retx+0x8b>
   124d2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
   124d8:	8b 06                	mov    (%esi),%eax
   124da:	8b 40 50             	mov    0x50(%eax),%eax
   124dd:	01 83 a4 01 00 00    	add    %eax,0x1a4(%ebx)
   124e3:	e9 49 fe ff ff       	jmp    12331 <rlc_retx+0x131>
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   124e8:	8b 07                	mov    (%edi),%eax
   124ea:	8b 40 50             	mov    0x50(%eax),%eax
   124ed:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
   124f3:	eb 8c                	jmp    12481 <rlc_retx+0x281>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   124f5:	89 d7                	mov    %edx,%edi
   124f7:	e9 2f ff ff ff       	jmp    1242b <rlc_retx+0x22b>
   124fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00012500 <so_handler>:
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12500:	55                   	push   %ebp
   12501:	89 e5                	mov    %esp,%ebp
   12503:	57                   	push   %edi
   12504:	56                   	push   %esi
   12505:	53                   	push   %ebx
   12506:	83 ec 20             	sub    $0x20,%esp
   12509:	e8 fc ff ff ff       	call   1250a <so_handler+0xa>
   1250e:	0f b7 75 08          	movzwl 0x8(%ebp),%esi
   12512:	89 45 e8             	mov    %eax,-0x18(%ebp)
   12515:	89 cf                	mov    %ecx,%edi
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12517:	89 c1                	mov    %eax,%ecx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12519:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
   1251f:	81 c1 f0 00 00 00    	add    $0xf0,%ecx
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12525:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12528:	39 c1                	cmp    %eax,%ecx
   1252a:	74 3d                	je     12569 <so_handler+0x69>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   1252c:	8b 18                	mov    (%eax),%ebx
   1252e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   12534:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
		{
			if( nackSn == amTxedBuffer->SN )
   1253a:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   1253e:	75 13                	jne    12553 <so_handler+0x53>
   12540:	eb 2f                	jmp    12571 <so_handler+0x71>
   12542:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12548:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   1254f:	74 27                	je     12578 <so_handler+0x78>
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12551:	89 d3                	mov    %edx,%ebx
   12553:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   12559:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1255f:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12565:	39 c1                	cmp    %eax,%ecx
   12567:	75 df                	jne    12548 <so_handler+0x48>
				break;
			}
		}
	}
	FOUT;
}
   12569:	83 c4 20             	add    $0x20,%esp
   1256c:	5b                   	pop    %ebx
   1256d:	5e                   	pop    %esi
   1256e:	5f                   	pop    %edi
   1256f:	5d                   	pop    %ebp
   12570:	c3                   	ret    
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12571:	89 d3                	mov    %edx,%ebx
   12573:	90                   	nop
   12574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			if( nackSn == amTxedBuffer->SN )
			{
				*isPduFound = true;
   12578:	c6 07 01             	movb   $0x1,(%edi)
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
   1257b:	0f bf c6             	movswl %si,%eax
   1257e:	89 44 24 04          	mov    %eax,0x4(%esp)
   12582:	c7 04 24 ec 44 00 00 	movl   $0x44ec,(%esp)
   12589:	e8 fc ff ff ff       	call   1258a <so_handler+0x8a>
				for( i = 0; i < amTxedBuffer->segnum; i++ )
   1258e:	8b 8b 90 00 00 00    	mov    0x90(%ebx),%ecx
   12594:	85 c9                	test   %ecx,%ecx
   12596:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   12599:	0f 84 d1 01 00 00    	je     12770 <so_handler+0x270>
   1259f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   125a2:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   125a6:	0f b6 7a 03          	movzbl 0x3(%edx),%edi
   125aa:	31 d2                	xor    %edx,%edx
   125ac:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
   125b0:	89 d6                	mov    %edx,%esi
   125b2:	d0 e8                	shr    %al
   125b4:	0f b6 c0             	movzbl %al,%eax
   125b7:	c1 e7 07             	shl    $0x7,%edi
   125ba:	09 c7                	or     %eax,%edi
   125bc:	31 c0                	xor    %eax,%eax
   125be:	89 7d dc             	mov    %edi,-0x24(%ebp)
   125c1:	eb 0f                	jmp    125d2 <so_handler+0xd2>
   125c3:	90                   	nop
   125c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   125c8:	83 c0 01             	add    $0x1,%eax
   125cb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   125ce:	89 c6                	mov    %eax,%esi
   125d0:	74 5e                	je     12630 <so_handler+0x130>
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
   125d2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   125d5:	39 4c 83 10          	cmp    %ecx,0x10(%ebx,%eax,4)
   125d9:	75 ed                	jne    125c8 <so_handler+0xc8>
   125db:	8b 7d ec             	mov    -0x14(%ebp),%edi
   125de:	0f b6 17             	movzbl (%edi),%edx
   125e1:	c0 ea 02             	shr    $0x2,%dl
   125e4:	0f b6 fa             	movzbl %dl,%edi
   125e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   125ea:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
   125ee:	0f b6 52 02          	movzbl 0x2(%edx),%edx
   125f2:	c1 e1 06             	shl    $0x6,%ecx
   125f5:	83 e2 01             	and    $0x1,%edx
   125f8:	09 f9                	or     %edi,%ecx
   125fa:	c1 e2 0e             	shl    $0xe,%edx
   125fd:	09 ca                	or     %ecx,%edx
   125ff:	39 54 83 50          	cmp    %edx,0x50(%ebx,%eax,4)
   12603:	75 c3                	jne    125c8 <so_handler+0xc8>
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   12605:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12608:	89 f2                	mov    %esi,%edx
   1260a:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1260d:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12611:	c7 04 24 24 45 00 00 	movl   $0x4524,(%esp)
   12618:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   1261c:	e8 fc ff ff ff       	call   1261d <so_handler+0x11d>
   12621:	8b bb 90 00 00 00    	mov    0x90(%ebx),%edi
						break;
   12627:	8b 55 e0             	mov    -0x20(%ebp),%edx
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
				for( i = 0; i < amTxedBuffer->segnum; i++ )
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   1262a:	89 7d f0             	mov    %edi,-0x10(%ebp)
						break;
   1262d:	eb 07                	jmp    12636 <so_handler+0x136>
   1262f:	90                   	nop
   12630:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12634:	89 c2                	mov    %eax,%edx
					}
				}
				if( i == amTxedBuffer->segnum )
   12636:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   12639:	0f 84 31 01 00 00    	je     12770 <so_handler+0x270>
					amTxedBuffer->segnum++;
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   1263f:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
   12646:	66 83 f8 ff          	cmp    $0xffff,%ax
   1264a:	0f 84 10 01 00 00    	je     12760 <so_handler+0x260>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   12650:	83 c0 01             	add    $0x1,%eax
   12653:	66 89 83 96 00 00 00 	mov    %ax,0x96(%ebx)
   1265a:	98                   	cwtl   
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   1265b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1265e:	0f b7 91 fa 22 00 00 	movzwl 0x22fa(%ecx),%edx
   12665:	39 c2                	cmp    %eax,%edx
   12667:	74 1f                	je     12688 <so_handler+0x188>
						}
					}
				}
				else
				{
					rlc_retx(amIns,amTxedBuffer);
   12669:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1266c:	89 da                	mov    %ebx,%edx
   1266e:	e8 fc ff ff ff       	call   1266f <so_handler+0x16f>
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   12673:	c7 04 24 38 43 00 00 	movl   $0x4338,(%esp)
   1267a:	e8 fc ff ff ff       	call   1267b <so_handler+0x17b>
				break;
			}
		}
	}
	FOUT;
}
   1267f:	83 c4 20             	add    $0x20,%esp
   12682:	5b                   	pop    %ebx
   12683:	5e                   	pop    %esi
   12684:	5f                   	pop    %edi
   12685:	5d                   	pop    %ebp
   12686:	c3                   	ret    
   12687:	90                   	nop
					amTxedBuffer->retxCount++;
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
   12688:	c7 04 24 84 45 00 00 	movl   $0x4584,(%esp)
   1268f:	e8 fc ff ff ff       	call   12690 <so_handler+0x190>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   12694:	b8 04 00 00 00       	mov    $0x4,%eax
   12699:	e8 fc ff ff ff       	call   1269a <so_handler+0x19a>
					mioctrl->eventCode = 0;
					mioctrl->rbIdentity = amIns->rbId;
   1269e:	8b 7d e8             	mov    -0x18(%ebp),%edi
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
					mioctrl->eventCode = 0;
   126a1:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   126a6:	0f b6 57 02          	movzbl 0x2(%edi),%edx
   126aa:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   126ad:	e8 fc ff ff ff       	call   126ae <so_handler+0x1ae>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   126b2:	8b 03                	mov    (%ebx),%eax
   126b4:	8b 40 50             	mov    0x50(%eax),%eax
   126b7:	29 87 f8 00 00 00    	sub    %eax,0xf8(%edi)
					amIns->amTransmittedBufferNum--;
   126bd:	83 af fc 00 00 00 01 	subl   $0x1,0xfc(%edi)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   126c4:	8b 03                	mov    (%ebx),%eax
   126c6:	e8 fc ff ff ff       	call   126c7 <so_handler+0x1c7>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   126cb:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   126d1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
					amTxedBuffer->pkt = NULL;
   126d7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   126dd:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   126e0:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   126e2:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   126e4:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   126eb:	01 10 00 
	entry->prev = LIST_POISON2;
   126ee:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   126f5:	02 20 00 
   126f8:	e8 fc ff ff ff       	call   126f9 <so_handler+0x1f9>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   126fd:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12703:	89 fa                	mov    %edi,%edx
   12705:	81 c2 9c 01 00 00    	add    $0x19c,%edx
   1270b:	39 c2                	cmp    %eax,%edx
   1270d:	0f 84 56 fe ff ff    	je     12569 <so_handler+0x69>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12713:	8b 18                	mov    (%eax),%ebx
   12715:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1271b:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
						{
							if( amRetxBf->SN == nackSn)
   12721:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   12725:	75 18                	jne    1273f <so_handler+0x23f>
   12727:	e9 b6 00 00 00       	jmp    127e2 <so_handler+0x2e2>
   1272c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12730:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   12737:	0f 84 a7 00 00 00    	je     127e4 <so_handler+0x2e4>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   1273d:	89 cb                	mov    %ecx,%ebx
   1273f:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   12745:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1274b:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   12751:	39 c2                	cmp    %eax,%edx
   12753:	75 db                	jne    12730 <so_handler+0x230>
   12755:	e9 0f fe ff ff       	jmp    12569 <so_handler+0x69>
   1275a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   12760:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   12767:	00 00 
   12769:	31 c0                	xor    %eax,%eax
   1276b:	e9 eb fe ff ff       	jmp    1265b <so_handler+0x15b>
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12770:	8b 45 ec             	mov    -0x14(%ebp),%eax
					if(part3->SOend  == 0x7fff ) //
   12773:	8b 4d ec             	mov    -0x14(%ebp),%ecx
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12776:	0f b6 50 02          	movzbl 0x2(%eax),%edx
   1277a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1277e:	d0 ea                	shr    %dl
   12780:	0f b6 d2             	movzbl %dl,%edx
   12783:	c1 e0 07             	shl    $0x7,%eax
   12786:	09 d0                	or     %edx,%eax
   12788:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1278b:	89 44 93 10          	mov    %eax,0x10(%ebx,%edx,4)
					if(part3->SOend  == 0x7fff ) //
   1278f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12792:	0f b6 02             	movzbl (%edx),%eax
   12795:	0f b6 52 01          	movzbl 0x1(%edx),%edx
   12799:	c0 e8 02             	shr    $0x2,%al
   1279c:	0f b6 c0             	movzbl %al,%eax
   1279f:	c1 e2 06             	shl    $0x6,%edx
   127a2:	09 c2                	or     %eax,%edx
   127a4:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   127a8:	83 e0 01             	and    $0x1,%eax
   127ab:	c1 e0 0e             	shl    $0xe,%eax
   127ae:	09 c2                	or     %eax,%edx
   127b0:	66 81 fa ff 7f       	cmp    $0x7fff,%dx
   127b5:	0f 84 c1 00 00 00    	je     1287c <so_handler+0x37c>
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
					}
					else
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = part3->SOend;
   127bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127be:	0f b7 d2             	movzwl %dx,%edx
   127c1:	89 54 83 50          	mov    %edx,0x50(%ebx,%eax,4)
					}
					amTxedBuffer->segnum++;
   127c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   127c8:	83 c0 01             	add    $0x1,%eax
   127cb:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
   127d1:	c7 04 24 5c 45 00 00 	movl   $0x455c,(%esp)
   127d8:	e8 fc ff ff ff       	call   127d9 <so_handler+0x2d9>
   127dd:	e9 5d fe ff ff       	jmp    1263f <so_handler+0x13f>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   127e2:	89 cb                	mov    %ecx,%ebx
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   127e4:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
   127e8:	0f 84 9f 00 00 00    	je     1288d <so_handler+0x38d>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   127ee:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
   127f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   127f7:	85 d2                	test   %edx,%edx
   127f9:	8b 88 a4 01 00 00    	mov    0x1a4(%eax),%ecx
   127ff:	74 27                	je     12828 <so_handler+0x328>
   12801:	8b 75 e8             	mov    -0x18(%ebp),%esi
   12804:	31 c0                	xor    %eax,%eax
   12806:	66 90                	xchg   %ax,%ax
									{
										if( amRetxBf->segStart[i] != -1 )
   12808:	8b 54 83 10          	mov    0x10(%ebx,%eax,4),%edx
   1280c:	83 fa ff             	cmp    $0xffffffff,%edx
   1280f:	74 0c                	je     1281d <so_handler+0x31d>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12811:	2b 54 83 50          	sub    0x50(%ebx,%eax,4),%edx
   12815:	01 d1                	add    %edx,%ecx
   12817:	89 8e a4 01 00 00    	mov    %ecx,0x1a4(%esi)
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   1281d:	83 c0 01             	add    $0x1,%eax
   12820:	3b 83 90 00 00 00    	cmp    0x90(%ebx),%eax
   12826:	72 e0                	jb     12808 <so_handler+0x308>
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12828:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1282b:	2b 4b 0c             	sub    0xc(%ebx),%ecx
   1282e:	89 88 a4 01 00 00    	mov    %ecx,0x1a4(%eax)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12834:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12837:	83 a8 a8 01 00 00 01 	subl   $0x1,0x1a8(%eax)
								fsm_pkt_destroy( amRetxBf->pkt );
   1283e:	8b 03                	mov    (%ebx),%eax
   12840:	e8 fc ff ff ff       	call   12841 <so_handler+0x341>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12845:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   1284b:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
								amRetxBf->pkt = NULL;
   12851:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12857:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1285a:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   1285c:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1285e:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12865:	01 10 00 
	entry->prev = LIST_POISON2;
   12868:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   1286f:	02 20 00 
   12872:	e8 fc ff ff ff       	call   12873 <so_handler+0x373>
								amRetxBf= NULL;
								break;
   12877:	e9 ed fc ff ff       	jmp    12569 <so_handler+0x69>
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
					if(part3->SOend  == 0x7fff ) //
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
   1287c:	8b 03                	mov    (%ebx),%eax
   1287e:	8b 7d f0             	mov    -0x10(%ebp),%edi
   12881:	8b 40 50             	mov    0x50(%eax),%eax
   12884:	89 44 bb 50          	mov    %eax,0x50(%ebx,%edi,4)
   12888:	e9 38 ff ff ff       	jmp    127c5 <so_handler+0x2c5>
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   1288d:	8b 03                	mov    (%ebx),%eax
   1288f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12892:	8b 40 50             	mov    0x50(%eax),%eax
   12895:	29 82 a4 01 00 00    	sub    %eax,0x1a4(%edx)
   1289b:	eb 97                	jmp    12834 <so_handler+0x334>
   1289d:	8d 76 00             	lea    0x0(%esi),%esi

000128a0 <rlc_poll>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   128a0:	55                   	push   %ebp
   128a1:	89 e5                	mov    %esp,%ebp
   128a3:	56                   	push   %esi
   128a4:	53                   	push   %ebx
   128a5:	83 ec 04             	sub    $0x4,%esp
   128a8:	e8 fc ff ff ff       	call   128a9 <rlc_poll+0x9>
   128ad:	89 d6                	mov    %edx,%esi
   128af:	89 c3                	mov    %eax,%ebx
	//u16 amHdr = 0x0000; //AM PDU
	RLC_AMPDU_fixhead * amHdr;

	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
   128b1:	c7 04 24 c0 45 00 00 	movl   $0x45c0,(%esp)
   128b8:	e8 fc ff ff ff       	call   128b9 <rlc_poll+0x19>
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
   128bd:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	*(u16*)amHdr=htons(*(u16*)amHdr);
   128c3:	0f b7 02             	movzwl (%edx),%eax
   128c6:	66 c1 c0 08          	rol    $0x8,%ax
	if(amHdr->P!=1)
   128ca:	89 c1                	mov    %eax,%ecx
	{
		amHdr->P = 1;
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   128cc:	0f b7 f0             	movzwl %ax,%esi
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
	if(amHdr->P!=1)
   128cf:	66 c1 e9 08          	shr    $0x8,%cx
   128d3:	f6 c1 20             	test   $0x20,%cl
	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
   128d6:	66 89 02             	mov    %ax,(%edx)
	if(amHdr->P!=1)
   128d9:	75 0c                	jne    128e7 <rlc_poll+0x47>
	{
		amHdr->P = 1;
   128db:	83 c9 20             	or     $0x20,%ecx
   128de:	88 4a 01             	mov    %cl,0x1(%edx)
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   128e1:	0f b7 02             	movzwl (%edx),%eax
   128e4:	0f b7 f0             	movzwl %ax,%esi
   128e7:	66 c1 e8 08          	shr    $0x8,%ax
   128eb:	c1 e6 08             	shl    $0x8,%esi
   128ee:	09 f0                	or     %esi,%eax
   128f0:	66 89 02             	mov    %ax,(%edx)
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
	amIns->byteWithoutPoll = 0;
	amIns->pollSn = amIns->vt_s - 1;
   128f3:	0f b7 83 64 12 00 00 	movzwl 0x1264(%ebx),%eax
	/*if( (amHdr&0x2000)>>13 == 0 )
	{
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
   128fa:	66 c7 83 fc 22 00 00 	movw   $0x0,0x22fc(%ebx)
   12901:	00 00 
	amIns->byteWithoutPoll = 0;
   12903:	66 c7 83 fe 22 00 00 	movw   $0x0,0x22fe(%ebx)
   1290a:	00 00 
	amIns->pollSn = amIns->vt_s - 1;
   1290c:	83 e8 01             	sub    $0x1,%eax
   1290f:	66 89 83 00 23 00 00 	mov    %ax,0x2300(%ebx)
	if(amIns->pollRetxTimer)
   12916:	8b 43 08             	mov    0x8(%ebx),%eax
   12919:	85 c0                	test   %eax,%eax
   1291b:	74 0c                	je     12929 <rlc_poll+0x89>
	{
		fsm_schedule_cancel(amIns->pollRetxTimer);
   1291d:	e8 fc ff ff ff       	call   1291e <rlc_poll+0x7e>
		amIns->pollRetxTimer = 0;
   12922:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	}
	amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
   12929:	8b 53 0c             	mov    0xc(%ebx),%edx
   1292c:	8b 43 10             	mov    0x10(%ebx),%eax
   1292f:	e8 fc ff ff ff       	call   12930 <rlc_poll+0x90>
   12934:	89 43 08             	mov    %eax,0x8(%ebx)
	fsm_printf("[RLC][rlc_poll] pollretxTimer start\n");
   12937:	c7 04 24 e4 45 00 00 	movl   $0x45e4,(%esp)
   1293e:	e8 fc ff ff ff       	call   1293f <rlc_poll+0x9f>
	FOUT;
}
   12943:	83 c4 04             	add    $0x4,%esp
   12946:	5b                   	pop    %ebx
   12947:	5e                   	pop    %esi
   12948:	5d                   	pop    %ebp
   12949:	c3                   	ret    
   1294a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00012950 <rlc_poll_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll_retx(struct AM_Instance *amIns)
{
   12950:	55                   	push   %ebp
   12951:	89 e5                	mov    %esp,%ebp
   12953:	57                   	push   %edi
   12954:	56                   	push   %esi
   12955:	53                   	push   %ebx
   12956:	83 ec 24             	sub    $0x24,%esp
   12959:	e8 fc ff ff ff       	call   1295a <rlc_poll_retx+0xa>
   1295e:	89 c6                	mov    %eax,%esi
	struct AmBuffer *amRetxBf;  //PDU
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	FIN(rlc_poll_retx());
	fsm_printf("[RLC][rlc_poll_retx] entering rlc_poll_retx() function\n");
   12960:	c7 04 24 0c 46 00 00 	movl   $0x460c,(%esp)
   12967:	e8 fc ff ff ff       	call   12968 <rlc_poll_retx+0x18>
	//
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   1296c:	8d 8e f0 00 00 00    	lea    0xf0(%esi),%ecx
   12972:	3b 8e f0 00 00 00    	cmp    0xf0(%esi),%ecx
   12978:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1297b:	0f 84 a5 02 00 00    	je     12c26 <rlc_poll_retx+0x2d6>
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");
   12981:	c7 04 24 44 46 00 00 	movl   $0x4644,(%esp)
   12988:	e8 fc ff ff ff       	call   12989 <rlc_poll_retx+0x39>

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1298d:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
   12993:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12996:	8b 38                	mov    (%eax),%edi
   12998:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
   1299e:	0f 84 94 02 00 00    	je     12c38 <rlc_poll_retx+0x2e8>
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   129a4:	8d 8e 9c 01 00 00    	lea    0x19c(%esi),%ecx
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   129aa:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   129b0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   129b3:	eb 21                	jmp    129d6 <rlc_poll_retx+0x86>
   129b5:	8d 76 00             	lea    0x0(%esi),%esi
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   129b8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
   129be:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   129c4:	2d 9c 00 00 00       	sub    $0x9c,%eax
   129c9:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   129cc:	0f 84 66 02 00 00    	je     12c38 <rlc_poll_retx+0x2e8>
   129d2:	89 fb                	mov    %edi,%ebx
   129d4:	89 c7                	mov    %eax,%edi
		{
			//amTxedBuffer = list_entry(pos,struct AmBuffer,list);
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
   129d6:	0f bf 96 64 12 00 00 	movswl 0x1264(%esi),%edx
   129dd:	0f bf 83 94 00 00 00 	movswl 0x94(%ebx),%eax
   129e4:	83 ea 01             	sub    $0x1,%edx
   129e7:	39 d0                	cmp    %edx,%eax
   129e9:	75 cd                	jne    129b8 <rlc_poll_retx+0x68>
			{
				if( amTxedBuffer->retxCount == -1 )
   129eb:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
   129f2:	66 83 fa ff          	cmp    $0xffff,%dx
   129f6:	0f 84 1c 02 00 00    	je     12c18 <rlc_poll_retx+0x2c8>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   129fc:	83 c2 01             	add    $0x1,%edx
   129ff:	66 89 93 96 00 00 00 	mov    %dx,0x96(%ebx)
				}
				fsm_printf("[RLC][rlc_poll_retx] the pdu of rlc_poll_retx's SN is %d\n",amTxedBuffer->SN);
   12a06:	89 44 24 04          	mov    %eax,0x4(%esp)
   12a0a:	c7 04 24 8c 46 00 00 	movl   $0x468c,(%esp)
   12a11:	e8 fc ff ff ff       	call   12a12 <rlc_poll_retx+0xc2>
				fsm_printf("[RLC][rlc_poll_retx] the retxCount is %d, the maxThreshold is %d\n",amTxedBuffer->retxCount,amIns->maxRetxThreshold);
   12a16:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   12a1d:	89 44 24 08          	mov    %eax,0x8(%esp)
   12a21:	0f bf 83 96 00 00 00 	movswl 0x96(%ebx),%eax
   12a28:	c7 04 24 c8 46 00 00 	movl   $0x46c8,(%esp)
   12a2f:	89 44 24 04          	mov    %eax,0x4(%esp)
   12a33:	e8 fc ff ff ff       	call   12a34 <rlc_poll_retx+0xe4>
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   12a38:	0f bf 93 96 00 00 00 	movswl 0x96(%ebx),%edx
   12a3f:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   12a46:	39 c2                	cmp    %eax,%edx
   12a48:	0f 85 02 02 00 00    	jne    12c50 <rlc_poll_retx+0x300>
				{
					fsm_printf("[RLC][rlc_poll_retx] has reach the maxRetxThreshold\n");
   12a4e:	c7 04 24 0c 47 00 00 	movl   $0x470c,(%esp)
   12a55:	e8 fc ff ff ff       	call   12a56 <rlc_poll_retx+0x106>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   12a5a:	b8 04 00 00 00       	mov    $0x4,%eax
   12a5f:	e8 fc ff ff ff       	call   12a60 <rlc_poll_retx+0x110>
					mioctrl->eventCode = 0;
   12a64:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12a69:	0f b6 56 02          	movzbl 0x2(%esi),%edx
   12a6d:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   12a70:	e8 fc ff ff ff       	call   12a71 <rlc_poll_retx+0x121>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12a75:	8b 96 9c 01 00 00    	mov    0x19c(%esi),%edx
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12a7b:	39 55 e8             	cmp    %edx,-0x18(%ebp)
   12a7e:	74 6b                	je     12aeb <rlc_poll_retx+0x19b>
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12a80:	8d 82 64 ff ff ff    	lea    -0x9c(%edx),%eax
   12a86:	8b 0a                	mov    (%edx),%ecx
   12a88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   12a8b:	0f b7 83 94 00 00 00 	movzwl 0x94(%ebx),%eax
   12a92:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12a96:	8d 81 64 ff ff ff    	lea    -0x9c(%ecx),%eax
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   12a9c:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
   12aa0:	66 39 4a f8          	cmp    %cx,-0x8(%edx)
   12aa4:	0f 84 cc 01 00 00    	je     12c76 <rlc_poll_retx+0x326>
   12aaa:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
   12aad:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   12ab0:	89 7d e0             	mov    %edi,-0x20(%ebp)
   12ab3:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
   12ab7:	eb 16                	jmp    12acf <rlc_poll_retx+0x17f>
   12ab9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   12ac0:	66 39 b8 94 00 00 00 	cmp    %di,0x94(%eax)
   12ac7:	0f 84 93 00 00 00    	je     12b60 <rlc_poll_retx+0x210>
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12acd:	89 c8                	mov    %ecx,%eax
   12acf:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   12ad5:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   12adb:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   12ae1:	39 d3                	cmp    %edx,%ebx
   12ae3:	75 db                	jne    12ac0 <rlc_poll_retx+0x170>
   12ae5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   12ae8:	8b 7d e0             	mov    -0x20(%ebp),%edi
					//nposBf = NULL;
					}

					//PDU
					//pos = pos->next;
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   12aeb:	8b 03                	mov    (%ebx),%eax
   12aed:	8b 40 50             	mov    0x50(%eax),%eax
   12af0:	29 86 f8 00 00 00    	sub    %eax,0xf8(%esi)
					amIns->amTransmittedBufferNum--;
   12af6:	83 ae fc 00 00 00 01 	subl   $0x1,0xfc(%esi)
					if(amTxedBuffer->pkt != NULL)
   12afd:	8b 03                	mov    (%ebx),%eax
   12aff:	85 c0                	test   %eax,%eax
   12b01:	74 0b                	je     12b0e <rlc_poll_retx+0x1be>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   12b03:	e8 fc ff ff ff       	call   12b04 <rlc_poll_retx+0x1b4>
						amTxedBuffer->pkt = NULL;
   12b08:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12b0e:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   12b14:	85 db                	test   %ebx,%ebx
   12b16:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12b1c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   12b1f:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12b21:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12b28:	01 10 00 
	entry->prev = LIST_POISON2;
   12b2b:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   12b32:	02 20 00 
   12b35:	74 07                	je     12b3e <rlc_poll_retx+0x1ee>
					{
						fsm_mem_free(amTxedBuffer);
   12b37:	89 d8                	mov    %ebx,%eax
   12b39:	e8 fc ff ff ff       	call   12b3a <rlc_poll_retx+0x1ea>
						amTxedBuffer = NULL;
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
   12b3e:	8b 86 a4 01 00 00    	mov    0x1a4(%esi),%eax
   12b44:	c7 04 24 44 47 00 00 	movl   $0x4744,(%esp)
   12b4b:	89 44 24 04          	mov    %eax,0x4(%esp)
   12b4f:	e8 fc ff ff ff       	call   12b50 <rlc_poll_retx+0x200>
   12b54:	e9 5f fe ff ff       	jmp    129b8 <rlc_poll_retx+0x68>
   12b59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   12b60:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   12b63:	89 c2                	mov    %eax,%edx
   12b65:	8b 7d e0             	mov    -0x20(%ebp),%edi
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   12b68:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
   12b6c:	0f 84 ce 00 00 00    	je     12c40 <rlc_poll_retx+0x2f0>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12b72:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
   12b78:	85 c9                	test   %ecx,%ecx
   12b7a:	8b 8e a4 01 00 00    	mov    0x1a4(%esi),%ecx
   12b80:	74 33                	je     12bb5 <rlc_poll_retx+0x265>
   12b82:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12b85:	31 c0                	xor    %eax,%eax
   12b87:	89 cb                	mov    %ecx,%ebx
   12b89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
									{
										if( amRetxBf->segStart[i] != -1 )
   12b90:	8b 4c 82 10          	mov    0x10(%edx,%eax,4),%ecx
   12b94:	83 f9 ff             	cmp    $0xffffffff,%ecx
   12b97:	74 0c                	je     12ba5 <rlc_poll_retx+0x255>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12b99:	2b 4c 82 50          	sub    0x50(%edx,%eax,4),%ecx
   12b9d:	01 cb                	add    %ecx,%ebx
   12b9f:	89 9e a4 01 00 00    	mov    %ebx,0x1a4(%esi)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12ba5:	83 c0 01             	add    $0x1,%eax
   12ba8:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
   12bae:	72 e0                	jb     12b90 <rlc_poll_retx+0x240>
   12bb0:	89 d9                	mov    %ebx,%ecx
   12bb2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12bb5:	89 c8                	mov    %ecx,%eax
   12bb7:	2b 42 0c             	sub    0xc(%edx),%eax
   12bba:	89 86 a4 01 00 00    	mov    %eax,0x1a4(%esi)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12bc0:	83 ae a8 01 00 00 01 	subl   $0x1,0x1a8(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12bc7:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   12bcd:	8b 8a 9c 00 00 00    	mov    0x9c(%edx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12bd3:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
   12bd6:	89 08                	mov    %ecx,(%eax)
								list_del(&amRetxBf->list);
								if(amRetxBf->pkt != NULL)
   12bd8:	8b 02                	mov    (%edx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12bda:	c7 82 9c 00 00 00 00 	movl   $0x100100,0x9c(%edx)
   12be1:	01 10 00 
	entry->prev = LIST_POISON2;
   12be4:	c7 82 a0 00 00 00 00 	movl   $0x200200,0xa0(%edx)
   12beb:	02 20 00 
   12bee:	85 c0                	test   %eax,%eax
   12bf0:	74 11                	je     12c03 <rlc_poll_retx+0x2b3>
								{
									fsm_pkt_destroy( amRetxBf->pkt );
   12bf2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12bf5:	e8 fc ff ff ff       	call   12bf6 <rlc_poll_retx+0x2a6>
									amRetxBf->pkt = NULL;
   12bfa:	8b 55 dc             	mov    -0x24(%ebp),%edx
   12bfd:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
								}
								if(amRetxBf != NULL)
   12c03:	85 d2                	test   %edx,%edx
   12c05:	0f 84 e0 fe ff ff    	je     12aeb <rlc_poll_retx+0x19b>
								{
									fsm_mem_free(amRetxBf);
   12c0b:	89 d0                	mov    %edx,%eax
   12c0d:	e8 fc ff ff ff       	call   12c0e <rlc_poll_retx+0x2be>
   12c12:	e9 d4 fe ff ff       	jmp    12aeb <rlc_poll_retx+0x19b>
   12c17:	90                   	nop
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
			{
				if( amTxedBuffer->retxCount == -1 )
				{
					amTxedBuffer->retxCount = 0;
   12c18:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   12c1f:	00 00 
   12c21:	e9 e0 fd ff ff       	jmp    12a06 <rlc_poll_retx+0xb6>
			}
		}
	}
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
   12c26:	c7 04 24 c0 47 00 00 	movl   $0x47c0,(%esp)
   12c2d:	e8 fc ff ff ff       	call   12c2e <rlc_poll_retx+0x2de>
   12c32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	FOUT;
}
   12c38:	83 c4 24             	add    $0x24,%esp
   12c3b:	5b                   	pop    %ebx
   12c3c:	5e                   	pop    %esi
   12c3d:	5f                   	pop    %edi
   12c3e:	5d                   	pop    %ebp
   12c3f:	c3                   	ret    
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   12c40:	8b 02                	mov    (%edx),%eax
   12c42:	8b 40 50             	mov    0x50(%eax),%eax
   12c45:	29 86 a4 01 00 00    	sub    %eax,0x1a4(%esi)
   12c4b:	e9 70 ff ff ff       	jmp    12bc0 <rlc_poll_retx+0x270>
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
				}
				else
				{
					fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx pdu has not reach maxRetxThreshold\n");
   12c50:	c7 04 24 78 47 00 00 	movl   $0x4778,(%esp)
   12c57:	e8 fc ff ff ff       	call   12c58 <rlc_poll_retx+0x308>
					rlc_poll(amIns,amTxedBuffer->pkt);	//
   12c5c:	8b 13                	mov    (%ebx),%edx
   12c5e:	89 f0                	mov    %esi,%eax
   12c60:	e8 fc ff ff ff       	call   12c61 <rlc_poll_retx+0x311>
					rlc_retx(amIns,amTxedBuffer);
   12c65:	89 da                	mov    %ebx,%edx
   12c67:	89 f0                	mov    %esi,%eax
   12c69:	e8 fc ff ff ff       	call   12c6a <rlc_poll_retx+0x31a>
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
	}
	FOUT;
}
   12c6e:	83 c4 24             	add    $0x24,%esp
   12c71:	5b                   	pop    %ebx
   12c72:	5e                   	pop    %esi
   12c73:	5f                   	pop    %edi
   12c74:	5d                   	pop    %ebp
   12c75:	c3                   	ret    
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12c76:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12c79:	e9 ea fe ff ff       	jmp    12b68 <rlc_poll_retx+0x218>
