
lte_rlc_mac_module.o:     file format elf32-i386


Disassembly of section .text:

00000000 <__fsm_skb_netrx>:
{
	fsm_pkt_destroy(pkptr);
}

static void __fsm_skb_netrx(unsigned long data)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	56                   	push   %esi
       4:	53                   	push   %ebx
       5:	e8 fc ff ff ff       	call   6 <__fsm_skb_netrx+0x6>
       a:	eb 1e                	jmp    2a <__fsm_skb_netrx+0x2a>
       c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.rx_queue);
      10:	e8 fc ff ff ff       	call   11 <__fsm_skb_netrx+0x11>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
      15:	89 f2                	mov    %esi,%edx
      17:	89 c3                	mov    %eax,%ebx
      19:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      1e:	e8 fc ff ff ff       	call   1f <__fsm_skb_netrx+0x1f>
		spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
		NETIF_RX(pkptr);
      23:	89 d8                	mov    %ebx,%eax
      25:	e8 fc ff ff ff       	call   26 <__fsm_skb_netrx+0x26>
	unsigned long flags;


	while(1)
	{
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
      2a:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      2f:	e8 fc ff ff ff       	call   30 <__fsm_skb_netrx+0x30>
      34:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.rx_queue))
      36:	a1 bc 02 00 00       	mov    0x2bc,%eax
      3b:	3b 00                	cmp    (%eax),%eax
      3d:	75 d1                	jne    10 <__fsm_skb_netrx+0x10>
      3f:	89 f2                	mov    %esi,%edx
      41:	b8 d2 02 00 00       	mov    $0x2d2,%eax
      46:	e8 fc ff ff ff       	call   47 <__fsm_skb_netrx+0x47>
		NETIF_RX(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_netrx() packet receive\n");
	return;
}
      4b:	5b                   	pop    %ebx
      4c:	5e                   	pop    %esi
      4d:	5d                   	pop    %ebp
      4e:	c3                   	ret    
      4f:	90                   	nop

00000050 <__fsm_skb_xmit>:

static void __fsm_skb_xmit(unsigned long data)
{
      50:	55                   	push   %ebp
      51:	89 e5                	mov    %esp,%ebp
      53:	56                   	push   %esi
      54:	53                   	push   %ebx
      55:	e8 fc ff ff ff       	call   56 <__fsm_skb_xmit+0x6>
      5a:	eb 1e                	jmp    7a <__fsm_skb_xmit+0x2a>
      5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
		break;
		}
	else
		{
		pkptr = skb_dequeue(fsm_core.tx_queue);
      60:	e8 fc ff ff ff       	call   61 <__fsm_skb_xmit+0x11>
      65:	89 f2                	mov    %esi,%edx
      67:	89 c3                	mov    %eax,%ebx
      69:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      6e:	e8 fc ff ff ff       	call   6f <__fsm_skb_xmit+0x1f>
		spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
//		fsm_octets_print(pkptr->data, pkptr->len);
		DEV_QUEUE_XMIT(pkptr);
      73:	89 d8                	mov    %ebx,%eax
      75:	e8 fc ff ff ff       	call   76 <__fsm_skb_xmit+0x26>
{
	FSM_PKT* pkptr;
	unsigned long flags;
	while(1)
	{
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
      7a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      7f:	e8 fc ff ff ff       	call   80 <__fsm_skb_xmit+0x30>
      84:	89 c6                	mov    %eax,%esi
	if(skb_queue_empty(fsm_core.tx_queue))
      86:	a1 b8 02 00 00       	mov    0x2b8,%eax
      8b:	3b 00                	cmp    (%eax),%eax
      8d:	75 d1                	jne    60 <__fsm_skb_xmit+0x10>
      8f:	89 f2                	mov    %esi,%edx
      91:	b8 d0 02 00 00       	mov    $0x2d0,%eax
      96:	e8 fc ff ff ff       	call   97 <__fsm_skb_xmit+0x47>
		DEV_QUEUE_XMIT(pkptr);
		}
	}
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}
      9b:	5b                   	pop    %ebx
      9c:	5e                   	pop    %esi
      9d:	5d                   	pop    %ebp
      9e:	c3                   	ret    
      9f:	90                   	nop

000000a0 <__fsm_do_ioctl>:
	}
}


static void __fsm_do_ioctl(unsigned long data)
{
      a0:	55                   	push   %ebp
      a1:	89 e5                	mov    %esp,%ebp
      a3:	57                   	push   %edi
      a4:	56                   	push   %esi
      a5:	53                   	push   %ebx
      a6:	e8 fc ff ff ff       	call   a7 <__fsm_do_ioctl+0x7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
      ab:	8b 35 d4 02 00 00    	mov    0x2d4,%esi
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
      b1:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
      b7:	74 60                	je     119 <__fsm_do_ioctl+0x79>
      b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		ev_ptr = list_first_entry(&fsm_core.do_ioctl_list, struct evioctl, list_node);
		ev_ptr->dev->netdev_ops->ndo_do_ioctl(ev_ptr->dev, (struct ifreq*)&ev_ptr->ifr, IOCKERNEL);
      c0:	8b 46 f0             	mov    -0x10(%esi),%eax
      c3:	8d 56 f4             	lea    -0xc(%esi),%edx
      c6:	b9 f0 89 00 00       	mov    $0x89f0,%ecx
      cb:	8d 7e f0             	lea    -0x10(%esi),%edi
      ce:	8b 98 34 01 00 00    	mov    0x134(%eax),%ebx
      d4:	ff 53 28             	call   *0x28(%ebx)
		spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
      d7:	b8 e4 02 00 00       	mov    $0x2e4,%eax
      dc:	e8 fc ff ff ff       	call   dd <__fsm_do_ioctl+0x3d>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
      e1:	8b 4e 04             	mov    0x4(%esi),%ecx
      e4:	8b 1e                	mov    (%esi),%ebx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
      e6:	89 4b 04             	mov    %ecx,0x4(%ebx)
      e9:	89 c2                	mov    %eax,%edx
      eb:	b8 e4 02 00 00       	mov    $0x2e4,%eax
	prev->next = next;
      f0:	89 19                	mov    %ebx,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
      f2:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
      f8:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
      ff:	e8 fc ff ff ff       	call   100 <__fsm_do_ioctl+0x60>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     104:	89 f8                	mov    %edi,%eax
     106:	e8 fc ff ff ff       	call   107 <__fsm_do_ioctl+0x67>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     10b:	8b 35 d4 02 00 00    	mov    0x2d4,%esi

static void __fsm_do_ioctl(unsigned long data)
{
	struct evioctl* ev_ptr;
	unsigned long flags;
	while(!list_empty(&fsm_core.do_ioctl_list))
     111:	81 fe d4 02 00 00    	cmp    $0x2d4,%esi
     117:	75 a7                	jne    c0 <__fsm_do_ioctl+0x20>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
     119:	5b                   	pop    %ebx
     11a:	5e                   	pop    %esi
     11b:	5f                   	pop    %edi
     11c:	5d                   	pop    %ebp
     11d:	c3                   	ret    
     11e:	66 90                	xchg   %ax,%ax

00000120 <__fsm_skb_send_null>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     120:	55                   	push   %ebp
     121:	89 e5                	mov    %esp,%ebp
     123:	e8 fc ff ff ff       	call   124 <__fsm_skb_send_null+0x4>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     128:	e8 fc ff ff ff       	call   129 <__fsm_skb_send_null+0x9>
}

static void __fsm_skb_send_null(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
	fsm_pkt_destroy(pkptr);
}
     12d:	5d                   	pop    %ebp
     12e:	c3                   	ret    
     12f:	90                   	nop

00000130 <__fsm_tm_restart>:
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
}

static void __fsm_tm_restart()
{
     130:	55                   	push   %ebp
     131:	89 e5                	mov    %esp,%ebp
     133:	83 ec 04             	sub    $0x4,%esp
     136:	e8 fc ff ff ff       	call   137 <__fsm_tm_restart+0x7>
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
     13b:	8b 15 88 02 00 00    	mov    0x288,%edx
     141:	85 d2                	test   %edx,%edx
     143:	74 7b                	je     1c0 <__fsm_tm_restart+0x90>
	{
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
     145:	a1 44 02 00 00       	mov    0x244,%eax
     14a:	85 c0                	test   %eax,%eax
     14c:	74 42                	je     190 <__fsm_tm_restart+0x60>
	{	
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
     14e:	83 f8 01             	cmp    $0x1,%eax
     151:	74 05                	je     158 <__fsm_tm_restart+0x28>
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     153:	c9                   	leave  
     154:	c3                   	ret    
     155:	8d 76 00             	lea    0x0(%esi),%esi
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
     158:	b8 48 02 00 00       	mov    $0x248,%eax
     15d:	e8 fc ff ff ff       	call   15e <__fsm_tm_restart+0x2e>
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     162:	a1 88 02 00 00       	mov    0x288,%eax
		pB->tm_state = FSM_TM_RUN;
	}
	else if(pB->tm_state == FSM_TM_RUN)
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
     167:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     16e:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     171:	8b 50 08             	mov    0x8(%eax),%edx
     174:	8b 48 0c             	mov    0xc(%eax),%ecx
     177:	b8 48 02 00 00       	mov    $0x248,%eax
     17c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     183:	e8 fc ff ff ff       	call   184 <__fsm_tm_restart+0x54>
	}
}
     188:	c9                   	leave  
     189:	c3                   	ret    
     18a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		pB->tm_state = FSM_TM_STOP;
		return;
	}
	if(pB->tm_state == FSM_TM_STOP)
	{	
		pB->timer.function = __fsm_tm_expire;
     190:	c7 05 64 02 00 00 30 	movl   $0xa30,0x264
     197:	0a 00 00 
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
     19a:	8b 4a 0c             	mov    0xc(%edx),%ecx
     19d:	b8 48 02 00 00       	mov    $0x248,%eax
     1a2:	8b 52 08             	mov    0x8(%edx),%edx
     1a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     1ac:	e8 fc ff ff ff       	call   1ad <__fsm_tm_restart+0x7d>
		pB->tm_state = FSM_TM_RUN;
     1b1:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     1b8:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1bb:	c9                   	leave  
     1bc:	c3                   	ret    
     1bd:	8d 76 00             	lea    0x0(%esi),%esi
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	if(!(pB->evQ))
	{
		pB->tm_state = FSM_TM_STOP;
     1c0:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     1c7:	00 00 00 
	{	
		hrtimer_cancel(&pB->timer);
		pB->timer.function = __fsm_tm_expire;
		hrtimer_start(&pB->timer, pB->evQ->expire, HRTIMER_MODE_ABS);
	}
}
     1ca:	c9                   	leave  
     1cb:	c3                   	ret    
     1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000001d0 <__fsm_skb_pending_xmit>:
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1d0:	55                   	push   %ebp
     1d1:	89 e5                	mov    %esp,%ebp
     1d3:	83 ec 08             	sub    $0x8,%esp
     1d6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
     1d9:	89 75 fc             	mov    %esi,-0x4(%ebp)
     1dc:	e8 fc ff ff ff       	call   1dd <__fsm_skb_pending_xmit+0xd>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
     1e1:	66 89 48 66          	mov    %cx,0x66(%eax)
//	fsm_pkt_destroy(pkptr);
	return;
}

static void __fsm_skb_pending_xmit(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     1e5:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
     1e7:	89 50 14             	mov    %edx,0x14(%eax)
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1ea:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     1ef:	e8 fc ff ff ff       	call   1f0 <__fsm_skb_pending_xmit+0x20>
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f4:	89 da                	mov    %ebx,%edx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->dev = dev;
	skb->protocol = protocol;
	spin_lock_irqsave(&fsm_core.tx_queue_lock, flags);
     1f6:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.tx_queue, pkptr);
     1f8:	a1 b8 02 00 00       	mov    0x2b8,%eax
     1fd:	e8 fc ff ff ff       	call   1fe <__fsm_skb_pending_xmit+0x2e>
     202:	89 f2                	mov    %esi,%edx
     204:	b8 d0 02 00 00       	mov    $0x2d0,%eax
     209:	e8 fc ff ff ff       	call   20a <__fsm_skb_pending_xmit+0x3a>
	spin_unlock_irqrestore(&fsm_core.tx_queue_lock, flags);
	tasklet_schedule(fsm_core.tx_tsklt);
     20e:	a1 c0 02 00 00       	mov    0x2c0,%eax
 */
static inline int test_and_set_bit(int nr, volatile unsigned long *addr)
{
	int oldbit;

	asm volatile(LOCK_PREFIX "bts %2,%1\n\t"
     213:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     219:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     21b:	85 d2                	test   %edx,%edx
     21d:	75 05                	jne    224 <__fsm_skb_pending_xmit+0x54>
		__tasklet_schedule(t);
     21f:	e8 fc ff ff ff       	call   220 <__fsm_skb_pending_xmit+0x50>
//	fsm_pkt_destroy(pkptr);
	return;
}
     224:	8b 5d f8             	mov    -0x8(%ebp),%ebx
     227:	8b 75 fc             	mov    -0x4(%ebp),%esi
     22a:	89 ec                	mov    %ebp,%esp
     22c:	5d                   	pop    %ebp
     22d:	c3                   	ret    
     22e:	66 90                	xchg   %ax,%ax

00000230 <__fsm_skb_pending_netrx>:
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     230:	55                   	push   %ebp
     231:	89 e5                	mov    %esp,%ebp
     233:	56                   	push   %esi
     234:	53                   	push   %ebx
     235:	e8 fc ff ff ff       	call   236 <__fsm_skb_pending_netrx+0x6>
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
     23a:	66 83 f9 08          	cmp    $0x8,%cx
	fsm_core.ioctrl_cmd = INVALIDE;
	return;
}

static void __fsm_skb_pending_netrx(FSM_PKT* pkptr, NETDEV* dev, u16 protocol)
{
     23e:	89 c3                	mov    %eax,%ebx
	SKBUFF* skb;
	unsigned long flags;
	skb = (SKBUFF*)pkptr;
	skb->protocol = protocol;
     240:	66 89 48 66          	mov    %cx,0x66(%eax)
	skb->dev = dev;
     244:	89 50 14             	mov    %edx,0x14(%eax)
	if(skb->protocol == htons(ETH_P_IP))
     247:	75 0d                	jne    256 <__fsm_skb_pending_netrx+0x26>
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
     249:	0f b6 40 64          	movzbl 0x64(%eax),%eax
     24d:	83 e0 f3             	and    $0xfffffff3,%eax
     250:	83 c8 04             	or     $0x4,%eax
     253:	88 43 64             	mov    %al,0x64(%ebx)
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     256:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     25b:	e8 fc ff ff ff       	call   25c <__fsm_skb_pending_netrx+0x2c>
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     260:	89 da                	mov    %ebx,%edx
	skb->dev = dev;
	if(skb->protocol == htons(ETH_P_IP))
	{
		skb->ip_summed = CHECKSUM_UNNECESSARY;
	}
	spin_lock_irqsave(&fsm_core.rx_queue_lock, flags);
     262:	89 c6                	mov    %eax,%esi
	skb_queue_tail(fsm_core.rx_queue, pkptr);
     264:	a1 bc 02 00 00       	mov    0x2bc,%eax
     269:	e8 fc ff ff ff       	call   26a <__fsm_skb_pending_netrx+0x3a>
     26e:	89 f2                	mov    %esi,%edx
     270:	b8 d2 02 00 00       	mov    $0x2d2,%eax
     275:	e8 fc ff ff ff       	call   276 <__fsm_skb_pending_netrx+0x46>
	spin_unlock_irqrestore(&fsm_core.rx_queue_lock, flags);
	tasklet_schedule(fsm_core.rx_tsklt);
     27a:	a1 c4 02 00 00       	mov    0x2c4,%eax
     27f:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     285:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     287:	85 d2                	test   %edx,%edx
     289:	75 05                	jne    290 <__fsm_skb_pending_netrx+0x60>
		__tasklet_schedule(t);
     28b:	e8 fc ff ff ff       	call   28c <__fsm_skb_pending_netrx+0x5c>
//	fsm_pkt_destroy(pkptr);
	return;
}
     290:	5b                   	pop    %ebx
     291:	5e                   	pop    %esi
     292:	5d                   	pop    %ebp
     293:	c3                   	ret    
     294:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     29a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000002a0 <fsm_ev_type>:

/* ---------------------utilities for state machine-----------------------------*/

/* Return information of event.	*/
u32 fsm_ev_type()
{
     2a0:	55                   	push   %ebp
     2a1:	89 e5                	mov    %esp,%ebp
     2a3:	e8 fc ff ff ff       	call   2a4 <fsm_ev_type+0x4>
	return fsm_core.evtype;
}
     2a8:	a1 30 00 00 00       	mov    0x30,%eax
     2ad:	5d                   	pop    %ebp
     2ae:	c3                   	ret    
     2af:	90                   	nop

000002b0 <fsm_ev_code>:

u32 fsm_ev_code()
{
     2b0:	55                   	push   %ebp
     2b1:	89 e5                	mov    %esp,%ebp
     2b3:	e8 fc ff ff ff       	call   2b4 <fsm_ev_code+0x4>
	return fsm_core.code;
}
     2b8:	a1 34 00 00 00       	mov    0x34,%eax
     2bd:	5d                   	pop    %ebp
     2be:	c3                   	ret    
     2bf:	90                   	nop

000002c0 <fsm_ev_src>:

int fsm_ev_src()
{
     2c0:	55                   	push   %ebp
     2c1:	89 e5                	mov    %esp,%ebp
     2c3:	e8 fc ff ff ff       	call   2c4 <fsm_ev_src+0x4>
	return fsm_core.src;
}
     2c8:	a1 38 00 00 00       	mov    0x38,%eax
     2cd:	5d                   	pop    %ebp
     2ce:	c3                   	ret    
     2cf:	90                   	nop

000002d0 <fsm_ev_ioctrl_cmd>:

u32 fsm_ev_ioctrl_cmd()
{
     2d0:	55                   	push   %ebp
     2d1:	89 e5                	mov    %esp,%ebp
     2d3:	e8 fc ff ff ff       	call   2d4 <fsm_ev_ioctrl_cmd+0x4>
	return fsm_core.ioctrl_cmd;
}
     2d8:	a1 b0 02 00 00       	mov    0x2b0,%eax
     2dd:	5d                   	pop    %ebp
     2de:	c3                   	ret    
     2df:	90                   	nop

000002e0 <fsm_sv_ptr_get>:

/* FSM information get */
void* fsm_sv_ptr_get()
{
     2e0:	55                   	push   %ebp
     2e1:	89 e5                	mov    %esp,%ebp
     2e3:	e8 fc ff ff ff       	call   2e4 <fsm_sv_ptr_get+0x4>
	return fsm_core.fsm_sv_ptr;
}
     2e8:	a1 3c 00 00 00       	mov    0x3c,%eax
     2ed:	5d                   	pop    %ebp
     2ee:	c3                   	ret    
     2ef:	90                   	nop

000002f0 <fsm_current_state_ptr_get>:

int* fsm_current_state_ptr_get()
{
     2f0:	55                   	push   %ebp
     2f1:	89 e5                	mov    %esp,%ebp
     2f3:	e8 fc ff ff ff       	call   2f4 <fsm_current_state_ptr_get+0x4>
	return fsm_core.current_state_ptr;
}
     2f8:	a1 24 00 00 00       	mov    0x24,%eax
     2fd:	5d                   	pop    %ebp
     2fe:	c3                   	ret    
     2ff:	90                   	nop

00000300 <fsm_dev_get>:

void* fsm_dev_get()
{
     300:	55                   	push   %ebp
     301:	89 e5                	mov    %esp,%ebp
     303:	e8 fc ff ff ff       	call   304 <fsm_dev_get+0x4>
	return fsm_core.dev;
}
     308:	a1 a8 02 00 00       	mov    0x2a8,%eax
     30d:	5d                   	pop    %ebp
     30e:	c3                   	ret    
     30f:	90                   	nop

00000310 <fsm_get_id_by_name>:

int fsm_get_id_by_name(const char* name)
{
     310:	55                   	push   %ebp
     311:	89 e5                	mov    %esp,%ebp
     313:	56                   	push   %esi
     314:	53                   	push   %ebx
     315:	e8 fc ff ff ff       	call   316 <fsm_get_id_by_name+0x6>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     31a:	31 db                	xor    %ebx,%ebx
{
	return fsm_core.dev;
}

int fsm_get_id_by_name(const char* name)
{
     31c:	89 c6                	mov    %eax,%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
     31e:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
     325:	89 f2                	mov    %esi,%edx
     327:	e8 fc ff ff ff       	call   328 <fsm_get_id_by_name+0x18>
     32c:	85 c0                	test   %eax,%eax
     32e:	74 18                	je     348 <fsm_get_id_by_name+0x38>
}

int fsm_get_id_by_name(const char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     330:	83 c3 01             	add    $0x1,%ebx
     333:	83 fb 06             	cmp    $0x6,%ebx
     336:	75 e6                	jne    31e <fsm_get_id_by_name+0xe>
			{
			return FSM[i]->id;
			}
		}
	return -1;
}
     338:	5b                   	pop    %ebx
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
			}
		}
	return -1;
     339:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
     33e:	5e                   	pop    %esi
     33f:	5d                   	pop    %ebp
     340:	c3                   	ret    
     341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     348:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
			}
		}
	return -1;
}
     34f:	5b                   	pop    %ebx
     350:	5e                   	pop    %esi
     351:	5d                   	pop    %ebp
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(strcmp(FSM[i]->name, name) == 0)
			{
			return FSM[i]->id;
     352:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
			}
		}
	return -1;
}
     358:	c3                   	ret    
     359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000360 <fsm_get_name_by_id>:

void fsm_get_name_by_id(int id, char* name)
{
     360:	55                   	push   %ebp
     361:	89 e5                	mov    %esp,%ebp
     363:	53                   	push   %ebx
     364:	e8 fc ff ff ff       	call   365 <fsm_get_name_by_id+0x5>
	int i;
	for(i=0; i< MAX_FSM; ++i)
     369:	31 c9                	xor    %ecx,%ecx
		}
	return -1;
}

void fsm_get_name_by_id(int id, char* name)
{
     36b:	89 d3                	mov    %edx,%ebx
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
     36d:	8b 14 8d 90 02 00 00 	mov    0x290(,%ecx,4),%edx
     374:	39 82 80 00 00 00    	cmp    %eax,0x80(%edx)
     37a:	74 14                	je     390 <fsm_get_name_by_id+0x30>
}

void fsm_get_name_by_id(int id, char* name)
{
	int i;
	for(i=0; i< MAX_FSM; ++i)
     37c:	83 c1 01             	add    $0x1,%ecx
     37f:	83 f9 06             	cmp    $0x6,%ecx
     382:	75 e9                	jne    36d <fsm_get_name_by_id+0xd>
			{
			strcpy(name, FSM[i]->name);
			break;
			}
		}
	*name ='\0';
     384:	c6 03 00             	movb   $0x0,(%ebx)
}
     387:	5b                   	pop    %ebx
     388:	5d                   	pop    %ebp
     389:	c3                   	ret    
     38a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	for(i=0; i< MAX_FSM; ++i)
		{
		if(FSM[i]->id == id)
			{
			strcpy(name, FSM[i]->name);
     390:	89 d8                	mov    %ebx,%eax
     392:	e8 fc ff ff ff       	call   393 <fsm_get_name_by_id+0x33>
			break;
			}
		}
	*name ='\0';
     397:	c6 03 00             	movb   $0x0,(%ebx)
}
     39a:	5b                   	pop    %ebx
     39b:	5d                   	pop    %ebp
     39c:	c3                   	ret    
     39d:	8d 76 00             	lea    0x0(%esi),%esi

000003a0 <fsm_intf_addr_get>:

void* fsm_intf_addr_get(int strm_id)
{
     3a0:	55                   	push   %ebp
     3a1:	89 e5                	mov    %esp,%ebp
     3a3:	e8 fc ff ff ff       	call   3a4 <fsm_intf_addr_get+0x4>
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3a8:	c1 e0 04             	shl    $0x4,%eax
     3ab:	8d 90 40 00 00 00    	lea    0x40(%eax),%edx
		return INTF[strm_id].dev->dev_addr;
	else
		return NULL;
     3b1:	31 c0                	xor    %eax,%eax
	*name ='\0';
}

void* fsm_intf_addr_get(int strm_id)
{
	if(INTF[strm_id].valid == DEV_INTF_REQ)
     3b3:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
     3b7:	75 09                	jne    3c2 <fsm_intf_addr_get+0x22>
		return INTF[strm_id].dev->dev_addr;
     3b9:	8b 42 0c             	mov    0xc(%edx),%eax
     3bc:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
	else
		return NULL;
}
     3c2:	5d                   	pop    %ebp
     3c3:	c3                   	ret    
     3c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     3ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000003d0 <fsm_self_addr_get>:
	
u8* fsm_self_addr_get()
{
     3d0:	55                   	push   %ebp
     3d1:	89 e5                	mov    %esp,%ebp
     3d3:	e8 fc ff ff ff       	call   3d4 <fsm_self_addr_get+0x4>
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3d8:	a1 a8 02 00 00       	mov    0x2a8,%eax
}
     3dd:	5d                   	pop    %ebp
	
u8* fsm_self_addr_get()
{
	NETDEV* dev;
	dev = (NETDEV*)fsm_core.dev; 
	return (u8*)dev->dev_addr;
     3de:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
}
     3e4:	c3                   	ret    
     3e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     3e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000003f0 <fsm_data_get>:



void* fsm_data_get()
{
     3f0:	55                   	push   %ebp
     3f1:	89 e5                	mov    %esp,%ebp
     3f3:	e8 fc ff ff ff       	call   3f4 <fsm_data_get+0x4>
	void* buffer;
	buffer = fsm_core.buffer;
     3f8:	a1 ac 02 00 00       	mov    0x2ac,%eax
	fsm_core.buffer = NULL;
     3fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     404:	00 00 00 
	return buffer;
}
     407:	5d                   	pop    %ebp
     408:	c3                   	ret    
     409:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000410 <fsm_data_destroy>:

void fsm_data_destroy(void* data_ptr)
{
     410:	55                   	push   %ebp
     411:	89 e5                	mov    %esp,%ebp
     413:	e8 fc ff ff ff       	call   414 <fsm_data_destroy+0x4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     418:	e8 fc ff ff ff       	call   419 <fsm_data_destroy+0x9>
}

void fsm_data_destroy(void* data_ptr)
{
	fsm_mem_free(data_ptr);
	freenum++;
     41d:	83 05 00 00 00 00 01 	addl   $0x1,0x0
}
     424:	5d                   	pop    %ebp
     425:	c3                   	ret    
     426:	8d 76 00             	lea    0x0(%esi),%esi
     429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000430 <__fsm_core_self_drive>:
		fsm_mem_free(tmev_ptr);
	}
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
     430:	55                   	push   %ebp
     431:	89 e5                	mov    %esp,%ebp
     433:	56                   	push   %esi
     434:	53                   	push   %ebx
     435:	e8 fc ff ff ff       	call   436 <__fsm_core_self_drive+0x6>
     43a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsm_core.current_fsm = dst_id;
     43d:	89 1d 20 00 00 00    	mov    %ebx,0x20
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     443:	8b 1c 9d 90 02 00 00 	mov    0x290(,%ebx,4),%ebx
	fsm_core.evtype = evtype;
     44a:	a3 30 00 00 00       	mov    %eax,0x30
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     44f:	8b 45 08             	mov    0x8(%ebp),%eax
static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
	fsm_core.evtype = evtype;
	fsm_core.code = code;
     452:	89 15 34 00 00 00    	mov    %edx,0x34
	fsm_core.pkptr = pkptr;
     458:	89 0d 2c 00 00 00    	mov    %ecx,0x2c
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     45e:	8d b3 8c 00 00 00    	lea    0x8c(%ebx),%esi
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
     464:	a3 38 00 00 00       	mov    %eax,0x38
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     469:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
}

static void __fsm_core_self_drive(u32 evtype, u32 code, FSM_PKT* pkptr, int src_id, int dst_id, void* buffer, u32 ioctrl_cmd)		
{
	fsm_core.current_fsm = dst_id;
	fsm_core.current_state_ptr = &FSM[dst_id]->_fsm_current_block;
     46f:	89 35 24 00 00 00    	mov    %esi,0x24
	fsm_core.evtype = evtype;
	fsm_core.code = code;
	fsm_core.pkptr = pkptr;
	fsm_core.src = src_id;
	FSM_SV_PTR = FSM[dst_id]->fsm_sv_ptr;
     475:	a3 3c 00 00 00       	mov    %eax,0x3c
	fsm_core.buffer = buffer;
     47a:	8b 45 10             	mov    0x10(%ebp),%eax
     47d:	a3 ac 02 00 00       	mov    %eax,0x2ac
	fsm_core.ioctrl_cmd = ioctrl_cmd;
     482:	8b 45 14             	mov    0x14(%ebp),%eax
     485:	a3 b0 02 00 00       	mov    %eax,0x2b0
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
     48a:	8b 83 84 00 00 00    	mov    0x84(%ebx),%eax
     490:	a3 40 00 00 00       	mov    %eax,0x40
	fsm_core.fsm_drive();
     495:	ff d0                	call   *%eax

/* ------------------internal functions-------------------------------*/
static void __fsm_ev_flush()
{
	
	if(fsm_core.pkptr)
     497:	a1 2c 00 00 00       	mov    0x2c,%eax
     49c:	85 c0                	test   %eax,%eax
     49e:	74 05                	je     4a5 <__fsm_core_self_drive+0x75>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     4a0:	e8 fc ff ff ff       	call   4a1 <__fsm_core_self_drive+0x71>
		}
//	if(fsm_core.buffer && !(fsm_ev_type()==FSM_EV_TYPE_CORE && fsm_ev_code()==FSM_EV_IOCTRL && fsm_ev_src()==USER_SPACE))
//		{
//		fsm_mem_free(fsm_core.buffer);
//		}
	if(fsm_core.buffer)
     4a5:	a1 ac 02 00 00       	mov    0x2ac,%eax
     4aa:	85 c0                	test   %eax,%eax
     4ac:	74 05                	je     4b3 <__fsm_core_self_drive+0x83>
		{
		fsm_data_destroy(fsm_core.buffer);
     4ae:	e8 fc ff ff ff       	call   4af <__fsm_core_self_drive+0x7f>
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4b3:	5b                   	pop    %ebx
//		}
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
     4b4:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
     4bb:	ff ff ff 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     4be:	5e                   	pop    %esi
	if(fsm_core.buffer)
		{
		fsm_data_destroy(fsm_core.buffer);
		}
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
     4bf:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
     4c6:	00 00 00 
	fsm_core.pkptr = NULL;
     4c9:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     4d0:	00 00 00 
	fsm_core.evtype = INVALIDE;
     4d3:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
     4da:	00 00 00 
	fsm_core.code = INVALIDE;
     4dd:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
     4e4:	00 00 00 
	fsm_core.src = INVALIDE;
     4e7:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
     4ee:	00 00 00 
	FSM_SV_PTR = NULL;
     4f1:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
     4f8:	00 00 00 
	fsm_core.fsm_drive = NULL;
     4fb:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
     502:	00 00 00 
	fsm_core.buffer = NULL;
     505:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
     50c:	00 00 00 
	fsm_core.ioctrl_cmd = INVALIDE;
     50f:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
     516:	00 00 00 
	fsm_core.buffer = buffer;
	fsm_core.ioctrl_cmd = ioctrl_cmd;
	fsm_core.fsm_drive = FSM[dst_id]->fsm_main;
	fsm_core.fsm_drive();
	__fsm_ev_flush();
}
     519:	5d                   	pop    %ebp
     51a:	c3                   	ret    
     51b:	90                   	nop
     51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000520 <fsm_pkt_get>:


/* Packet operation */

FSM_PKT* fsm_pkt_get()
{
     520:	55                   	push   %ebp
     521:	89 e5                	mov    %esp,%ebp
     523:	e8 fc ff ff ff       	call   524 <fsm_pkt_get+0x4>
	FSM_PKT* ptr;
	ptr = fsm_core.pkptr;
     528:	a1 2c 00 00 00       	mov    0x2c,%eax
	fsm_core.pkptr = NULL;
     52d:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
     534:	00 00 00 
	return ptr;
}
     537:	5d                   	pop    %ebp
     538:	c3                   	ret    
     539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000540 <fsm_pkt_send>:

void fsm_pkt_send(FSM_PKT* pkptr, int oinf)
{
     540:	55                   	push   %ebp
     541:	89 e5                	mov    %esp,%ebp
     543:	53                   	push   %ebx
     544:	e8 fc ff ff ff       	call   545 <fsm_pkt_send+0x5>
	if(oinf < MAX_INTF && INTF[oinf].valid)
     549:	83 fa 1f             	cmp    $0x1f,%edx
     54c:	7f 2a                	jg     578 <fsm_pkt_send+0x38>
     54e:	c1 e2 04             	shl    $0x4,%edx
     551:	8d 9a 40 00 00 00    	lea    0x40(%edx),%ebx
     557:	8b 53 04             	mov    0x4(%ebx),%edx
     55a:	85 d2                	test   %edx,%edx
     55c:	74 1a                	je     578 <fsm_pkt_send+0x38>
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
     55e:	83 fa 01             	cmp    $0x1,%edx
     561:	74 25                	je     588 <fsm_pkt_send+0x48>
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
			}
		else if(INTF[oinf].valid == DEV_INTF_IND)
     563:	83 fa 02             	cmp    $0x2,%edx
     566:	75 15                	jne    57d <fsm_pkt_send+0x3d>
			{
			INTF[oinf].send(pkptr, fsm_core.dev, INTF[oinf].proto);
     568:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     56c:	8b 15 a8 02 00 00    	mov    0x2a8,%edx
     572:	ff 53 10             	call   *0x10(%ebx)
     575:	eb 06                	jmp    57d <fsm_pkt_send+0x3d>
     577:	90                   	nop
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
     578:	e8 fc ff ff ff       	call   579 <fsm_pkt_send+0x39>
	}
	else
	{
		fsm_pkt_destroy(pkptr);
	}
}
     57d:	5b                   	pop    %ebx
     57e:	5d                   	pop    %ebp
     57f:	90                   	nop
     580:	c3                   	ret    
     581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	if(oinf < MAX_INTF && INTF[oinf].valid)
	{
		if(INTF[oinf].valid == DEV_INTF_REQ)
			{
			INTF[oinf].send(pkptr, INTF[oinf].dev, INTF[oinf].proto);
     588:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
     58c:	8b 53 0c             	mov    0xc(%ebx),%edx
     58f:	ff 53 10             	call   *0x10(%ebx)
     592:	eb e9                	jmp    57d <fsm_pkt_send+0x3d>
     594:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     59a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000005a0 <fsm_pkt_create>:
		fsm_pkt_destroy(pkptr);
	}
}

FSM_PKT* fsm_pkt_create(unsigned int size)
{
     5a0:	55                   	push   %ebp
     5a1:	89 e5                	mov    %esp,%ebp
     5a3:	53                   	push   %ebx
     5a4:	e8 fc ff ff ff       	call   5a5 <fsm_pkt_create+0x5>
 *	allocates memory it can be called from an interrupt.
 */
static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
					       unsigned int length)
{
	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
     5a9:	b9 20 00 00 00       	mov    $0x20,%ecx
     5ae:	89 c2                	mov    %eax,%edx
     5b0:	31 c0                	xor    %eax,%eax
     5b2:	e8 fc ff ff ff       	call   5b3 <fsm_pkt_create+0x13>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5b7:	31 d2                	xor    %edx,%edx
     5b9:	89 c3                	mov    %eax,%ebx

FSM_PKT* fsm_pkt_create(unsigned int size)
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
     5bb:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
     5c1:	8b 8b a4 00 00 00    	mov    0xa4(%ebx),%ecx
     5c7:	29 c1                	sub    %eax,%ecx
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
}

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
	return FSM_MEM_SET(dst_ptr,val,size);
     5c9:	e8 fc ff ff ff       	call   5ca <fsm_pkt_create+0x2a>
{
	FSM_PKT* pkptr;
	pkptr = (FSM_PKT*) ALLOC_SKB(size);
	fsm_mem_set(pkptr->head, 0, pkptr->end - pkptr->head);
	return pkptr;
}
     5ce:	89 d8                	mov    %ebx,%eax
     5d0:	5b                   	pop    %ebx
     5d1:	5d                   	pop    %ebp
     5d2:	c3                   	ret    
     5d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     5d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000005e0 <fsm_skb_realloc_headeroom>:


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
     5e0:	55                   	push   %ebp
     5e1:	89 e5                	mov    %esp,%ebp
     5e3:	83 ec 0c             	sub    $0xc,%esp
     5e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     5e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
     5ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
     5ef:	e8 fc ff ff ff       	call   5f0 <fsm_skb_realloc_headeroom+0x10>
     5f4:	89 c3                	mov    %eax,%ebx
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5f6:	e8 fc ff ff ff       	call   5f7 <fsm_skb_realloc_headeroom+0x17>
	if (unlikely(pkptr_new == NULL))
     5fb:	85 c0                	test   %eax,%eax


FSM_PKT* fsm_skb_realloc_headeroom(FSM_PKT* pkptr, unsigned int head_len)
{
	FSM_PKT* pkptr_new;
	pkptr_new = SKB_REALLOC_HEADROOM(pkptr, head_len);
     5fd:	89 c6                	mov    %eax,%esi
	if (unlikely(pkptr_new == NULL))
     5ff:	74 27                	je     628 <fsm_skb_realloc_headeroom+0x48>
        {
        KFREE_SKB(pkptr);
        return NULL;
       	}
    if(pkptr->sk)
     601:	8b 7b 10             	mov    0x10(%ebx),%edi
     604:	85 ff                	test   %edi,%edi
     606:	74 20                	je     628 <fsm_skb_realloc_headeroom+0x48>
 *	destructor function and make the @skb unowned. The buffer continues
 *	to exist but is no longer charged to its former owner.
 */
static inline void skb_orphan(struct sk_buff *skb)
{
	if (skb->destructor)
     608:	8b 50 68             	mov    0x68(%eax),%edx
     60b:	85 d2                	test   %edx,%edx
     60d:	74 02                	je     611 <fsm_skb_realloc_headeroom+0x31>
		skb->destructor(skb);
     60f:	ff d2                	call   *%edx
 */

static inline void skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
{
	skb_orphan(skb);
	skb->sk = sk;
     611:	89 7e 10             	mov    %edi,0x10(%esi)
 *
 * Atomically adds @i to @v.
 */
static inline void atomic_add(int i, atomic_t *v)
{
	asm volatile(LOCK_PREFIX "addl %1,%0"
     614:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
	skb->destructor = sock_wfree;
     61a:	c7 46 68 00 00 00 00 	movl   $0x0,0x68(%esi)
     621:	f0 01 87 94 00 00 00 	lock add %eax,0x94(%edi)
        {
        SKB_SET_OWNER_W(pkptr_new, pkptr->sk); 
	}
	KFREE_SKB(pkptr);
     628:	89 d8                	mov    %ebx,%eax
     62a:	e8 fc ff ff ff       	call   62b <fsm_skb_realloc_headeroom+0x4b>
	return pkptr_new;
}
     62f:	89 f0                	mov    %esi,%eax
     631:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     634:	8b 75 f8             	mov    -0x8(%ebp),%esi
     637:	8b 7d fc             	mov    -0x4(%ebp),%edi
     63a:	89 ec                	mov    %ebp,%esp
     63c:	5d                   	pop    %ebp
     63d:	c3                   	ret    
     63e:	66 90                	xchg   %ax,%ax

00000640 <fsm_pkt_destroy>:

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
     640:	55                   	push   %ebp
     641:	89 e5                	mov    %esp,%ebp
     643:	e8 fc ff ff ff       	call   644 <fsm_pkt_destroy+0x4>
	KFREE_SKB(pkptr);
     648:	e8 fc ff ff ff       	call   649 <fsm_pkt_destroy+0x9>
}
     64d:	5d                   	pop    %ebp
     64e:	c3                   	ret    
     64f:	90                   	nop

00000650 <fsm_pkt_duplicate>:

FSM_PKT* fsm_pkt_duplicate(FSM_PKT* pkptr)
{
     650:	55                   	push   %ebp
     651:	89 e5                	mov    %esp,%ebp
     653:	e8 fc ff ff ff       	call   654 <fsm_pkt_duplicate+0x4>
	return SKB_COPY(pkptr, GFP_ATOMIC);
     658:	ba 20 00 00 00       	mov    $0x20,%edx
     65d:	e8 fc ff ff ff       	call   65e <fsm_pkt_duplicate+0xe>
}
     662:	5d                   	pop    %ebp
     663:	c3                   	ret    
     664:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     66a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000670 <fsm_skb_put>:

u8* fsm_skb_put(FSM_PKT* pkptr, int len)
{	
     670:	55                   	push   %ebp
     671:	89 e5                	mov    %esp,%ebp
     673:	e8 fc ff ff ff       	call   674 <fsm_skb_put+0x4>
	return (u8*)SKB_PUT(pkptr, len);
     678:	e8 fc ff ff ff       	call   679 <fsm_skb_put+0x9>
}
     67d:	5d                   	pop    %ebp
     67e:	c3                   	ret    
     67f:	90                   	nop

00000680 <fsm_skb_push>:

u8* fsm_skb_push(FSM_PKT* pkptr, int len)
{
     680:	55                   	push   %ebp
     681:	89 e5                	mov    %esp,%ebp
     683:	e8 fc ff ff ff       	call   684 <fsm_skb_push+0x4>
	return SKB_PUSH(pkptr, len);
     688:	e8 fc ff ff ff       	call   689 <fsm_skb_push+0x9>
}
     68d:	5d                   	pop    %ebp
     68e:	c3                   	ret    
     68f:	90                   	nop

00000690 <fsm_skb_pull>:

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
     690:	55                   	push   %ebp
     691:	89 e5                	mov    %esp,%ebp
     693:	e8 fc ff ff ff       	call   694 <fsm_skb_pull+0x4>
     698:	89 c1                	mov    %eax,%ecx
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     69a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	pkptr->len -= len;
     6a0:	29 51 50             	sub    %edx,0x50(%ecx)
}

u8* fsm_skb_pull(FSM_PKT* pkptr, int len)
{
	//return SKB_PULL(pkptr, len);
	pkptr->data += len;
     6a3:	01 d0                	add    %edx,%eax
     6a5:	89 81 ac 00 00 00    	mov    %eax,0xac(%ecx)
	pkptr->len -= len;
	return (u8 *)pkptr->data;
}
     6ab:	5d                   	pop    %ebp
     6ac:	c3                   	ret    
     6ad:	8d 76 00             	lea    0x0(%esi),%esi

000006b0 <fsm_skb_reserve>:

void fsm_skb_reserve(FSM_PKT* pkptr , int len)
{
     6b0:	55                   	push   %ebp
     6b1:	89 e5                	mov    %esp,%ebp
     6b3:	e8 fc ff ff ff       	call   6b4 <fsm_skb_reserve+0x4>
 *	Increase the headroom of an empty &sk_buff by reducing the tail
 *	room. This is only allowed for an empty buffer.
 */
static inline void skb_reserve(struct sk_buff *skb, int len)
{
	skb->data += len;
     6b8:	01 90 ac 00 00 00    	add    %edx,0xac(%eax)
	skb->tail += len;
     6be:	01 90 a0 00 00 00    	add    %edx,0xa0(%eax)
	SKB_RESERVE(pkptr, len);
}
     6c4:	5d                   	pop    %ebp
     6c5:	c3                   	ret    
     6c6:	8d 76 00             	lea    0x0(%esi),%esi
     6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000006d0 <fsm_skb_tailroom>:

int fsm_skb_tailroom(FSM_PKT* pkptr)
{
     6d0:	55                   	push   %ebp
     6d1:	89 e5                	mov    %esp,%ebp
     6d3:	e8 fc ff ff ff       	call   6d4 <fsm_skb_tailroom+0x4>
 *
 *	Return the number of bytes of free space at the tail of an sk_buff
 */
static inline int skb_tailroom(const struct sk_buff *skb)
{
	return skb_is_nonlinear(skb) ? 0 : skb->end - skb->tail;
     6d8:	31 d2                	xor    %edx,%edx
     6da:	8b 48 54             	mov    0x54(%eax),%ecx
     6dd:	85 c9                	test   %ecx,%ecx
     6df:	75 0c                	jne    6ed <fsm_skb_tailroom+0x1d>
     6e1:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
     6e7:	2b 90 a0 00 00 00    	sub    0xa0(%eax),%edx
	return SKB_TAILROOM(pkptr);
}
     6ed:	89 d0                	mov    %edx,%eax
     6ef:	5d                   	pop    %ebp
     6f0:	c3                   	ret    
     6f1:	eb 0d                	jmp    700 <fsm_skb_headroom>
     6f3:	90                   	nop
     6f4:	90                   	nop
     6f5:	90                   	nop
     6f6:	90                   	nop
     6f7:	90                   	nop
     6f8:	90                   	nop
     6f9:	90                   	nop
     6fa:	90                   	nop
     6fb:	90                   	nop
     6fc:	90                   	nop
     6fd:	90                   	nop
     6fe:	90                   	nop
     6ff:	90                   	nop

00000700 <fsm_skb_headroom>:

int fsm_skb_headroom(FSM_PKT* pkptr)
{
     700:	55                   	push   %ebp
     701:	89 e5                	mov    %esp,%ebp
     703:	e8 fc ff ff ff       	call   704 <fsm_skb_headroom+0x4>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
     708:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
     70e:	2b 90 a8 00 00 00    	sub    0xa8(%eax),%edx
	return SKB_HEADROOM(pkptr);
}
     714:	5d                   	pop    %ebp
     715:	89 d0                	mov    %edx,%eax
     717:	c3                   	ret    
     718:	90                   	nop
     719:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000720 <fsm_mem_alloc>:

/* Memory operation */
void* fsm_mem_alloc(size_t size)
{
     720:	55                   	push   %ebp
     721:	89 e5                	mov    %esp,%ebp
     723:	e8 fc ff ff ff       	call   724 <fsm_mem_alloc+0x4>
				return ZERO_SIZE_PTR;

			return kmem_cache_alloc_trace(s, flags, size);
		}
	}
	return __kmalloc(size, flags);
     728:	ba 20 00 00 00       	mov    $0x20,%edx
     72d:	e8 fc ff ff ff       	call   72e <fsm_mem_alloc+0xe>
	void* ptr;
	ptr = FSM_MEM_ALLOC(size);
	mallocnum++;
     732:	83 05 00 00 00 00 01 	addl   $0x1,0x0
	return ptr;
}
     739:	5d                   	pop    %ebp
     73a:	c3                   	ret    
     73b:	90                   	nop
     73c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000740 <__fsm_tm_ev_add.constprop.7>:
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     740:	55                   	push   %ebp
     741:	89 e5                	mov    %esp,%ebp
     743:	57                   	push   %edi
     744:	56                   	push   %esi
     745:	53                   	push   %ebx
     746:	83 ec 14             	sub    $0x14,%esp
     749:	e8 fc ff ff ff       	call   74a <__fsm_tm_ev_add.constprop.7+0xa>
     74e:	89 c3                	mov    %eax,%ebx
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     750:	b8 2c 00 00 00       	mov    $0x2c,%eax
	pE->pNext = p0;
	p1->pNext = pE;
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);	
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
     755:	89 d6                	mov    %edx,%esi
     757:	89 cf                	mov    %ecx,%edi
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     759:	e8 fc ff ff ff       	call   75a <__fsm_tm_ev_add.constprop.7+0x1a>
	if(pE)
     75e:	85 c0                	test   %eax,%eax
}

static evHandle __fsm_tm_ev_add(unsigned int delay, u32 type, u32 code, FSM_PKT* pkptr, int src, int dst, void* buffer)		// delay should be in 10us base
{
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
     760:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(pE)
     763:	0f 84 bc 00 00 00    	je     825 <__fsm_tm_ev_add.constprop.7+0xe5>
	{
		pE->evmask = EVMASK;
     769:	c7 40 04 d6 96 0f 04 	movl   $0x40f96d6,0x4(%eax)
		pE->pNext = 0;
		pE->type = type;
		pE->code = code;
		pE->delay = delay;
		pE->pkptr = pkptr;
		pE->src_id =src;
     770:	8b 55 f0             	mov    -0x10(%ebp),%edx
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
     773:	85 db                	test   %ebx,%ebx
	__tmEvent* pE;
	pE = (__tmEvent*)fsm_mem_alloc(sizeof(__tmEvent));
	if(pE)
	{
		pE->evmask = EVMASK;
		pE->pNext = 0;
     775:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		pE->type = type;
     77b:	89 70 18             	mov    %esi,0x18(%eax)
		pE->code = code;
     77e:	89 78 14             	mov    %edi,0x14(%eax)
		pE->delay = delay;
     781:	89 58 10             	mov    %ebx,0x10(%eax)
		pE->pkptr = pkptr;
     784:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
		pE->src_id =src;
     78b:	8b 45 08             	mov    0x8(%ebp),%eax
     78e:	89 42 24             	mov    %eax,0x24(%edx)
		pE->dst_id = dst;
     791:	8b 45 0c             	mov    0xc(%ebp),%eax
     794:	89 42 20             	mov    %eax,0x20(%edx)
		pE->buffer = buffer;
     797:	8b 45 10             	mov    0x10(%ebp),%eax
     79a:	89 42 28             	mov    %eax,0x28(%edx)
		if(delay == 0)
     79d:	0f 84 8d 00 00 00    	je     830 <__fsm_tm_ev_add.constprop.7+0xf0>
			pE->expire = ktime_add_us(ktime_get(), 10);
		else
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
     7a3:	e8 fc ff ff ff       	call   7a4 <__fsm_tm_ev_add.constprop.7+0x64>
     7a8:	8d 1c 9b             	lea    (%ebx,%ebx,4),%ebx
     7ab:	01 db                	add    %ebx,%ebx
     7ad:	89 c6                	mov    %eax,%esi
       return ktime_to_us(ktime_sub(later, earlier));
}

static inline ktime_t ktime_add_us(const ktime_t kt, const u64 usec)
{
	return ktime_add_ns(kt, usec * 1000);
     7af:	b8 e8 03 00 00       	mov    $0x3e8,%eax
     7b4:	89 d7                	mov    %edx,%edi
     7b6:	f7 e3                	mul    %ebx
     7b8:	01 f0                	add    %esi,%eax
     7ba:	8b 75 f0             	mov    -0x10(%ebp),%esi
     7bd:	11 fa                	adc    %edi,%edx
     7bf:	89 46 08             	mov    %eax,0x8(%esi)
     7c2:	89 56 0c             	mov    %edx,0xc(%esi)
	__tmEvent* p0;
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     7c5:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     7ca:	e8 fc ff ff ff       	call   7cb <__fsm_tm_ev_add.constprop.7+0x8b>
     7cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     7d2:	a1 88 02 00 00       	mov    0x288,%eax
     7d7:	85 c0                	test   %eax,%eax
     7d9:	74 24                	je     7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     7db:	8b 7d f0             	mov    -0x10(%ebp),%edi
     7de:	8b 48 08             	mov    0x8(%eax),%ecx
     7e1:	8b 58 0c             	mov    0xc(%eax),%ebx
     7e4:	8b 77 08             	mov    0x8(%edi),%esi
     7e7:	8b 7f 0c             	mov    0xc(%edi),%edi
     7ea:	89 75 e8             	mov    %esi,-0x18(%ebp)
     7ed:	89 ce                	mov    %ecx,%esi
     7ef:	89 7d ec             	mov    %edi,-0x14(%ebp)
     7f2:	89 df                	mov    %ebx,%edi
     7f4:	2b 75 e8             	sub    -0x18(%ebp),%esi
     7f7:	1b 7d ec             	sbb    -0x14(%ebp),%edi
     7fa:	83 ff 00             	cmp    $0x0,%edi
     7fd:	7e 51                	jle    850 <__fsm_tm_ev_add.constprop.7+0x110>
	{
		pE->pNext = pB->evQ;
     7ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
     802:	89 02                	mov    %eax,(%edx)
		pB->evQ = pE;
		if(pB->tm_state != FSM_TM_EXPIRE)
     804:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
	{
		pE->pNext = pB->evQ;
		pB->evQ = pE;
     80b:	89 15 88 02 00 00    	mov    %edx,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     811:	74 05                	je     818 <__fsm_tm_ev_add.constprop.7+0xd8>
		{
			__fsm_tm_restart();
     813:	e8 18 f9 ff ff       	call   130 <__fsm_tm_restart>
     818:	8b 55 e0             	mov    -0x20(%ebp),%edx
     81b:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     820:	e8 fc ff ff ff       	call   821 <__fsm_tm_ev_add.constprop.7+0xe1>
			pE->expire = ktime_add_us(ktime_get(), 10 * delay);
		__fsm_tm_ev_insert(pE);
		return EVHANDLE(pE);
	}
	return 0;
}
     825:	8b 45 f0             	mov    -0x10(%ebp),%eax
     828:	83 c4 14             	add    $0x14,%esp
     82b:	5b                   	pop    %ebx
     82c:	5e                   	pop    %esi
     82d:	5f                   	pop    %edi
     82e:	5d                   	pop    %ebp
     82f:	c3                   	ret    
		pE->pkptr = pkptr;
		pE->src_id =src;
		pE->dst_id = dst;
		pE->buffer = buffer;
		if(delay == 0)
			pE->expire = ktime_add_us(ktime_get(), 10);
     830:	e8 fc ff ff ff       	call   831 <__fsm_tm_ev_add.constprop.7+0xf1>
     835:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     838:	05 10 27 00 00       	add    $0x2710,%eax
     83d:	83 d2 00             	adc    $0x0,%edx
     840:	89 41 08             	mov    %eax,0x8(%ecx)
     843:	89 51 0c             	mov    %edx,0xc(%ecx)
     846:	e9 7a ff ff ff       	jmp    7c5 <__fsm_tm_ev_add.constprop.7+0x85>
     84b:	90                   	nop
     84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	__tmEvent* p1;
	__tmBlock* pB;
	unsigned long flags;
	pB = TMBLOCK_PTR;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(!pB->evQ || LATE_TIME(pE->expire,pB->evQ->expire))
     850:	7c 1f                	jl     871 <__fsm_tm_ev_add.constprop.7+0x131>
     852:	83 fe 00             	cmp    $0x0,%esi
     855:	76 1a                	jbe    871 <__fsm_tm_ev_add.constprop.7+0x131>
     857:	eb a6                	jmp    7ff <__fsm_tm_ev_add.constprop.7+0xbf>
     859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
	{
		p1 = p0;
		p0 = p0->pNext;
     860:	8b 10                	mov    (%eax),%edx
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return;
	}
	p0 = pB->evQ;
	while(p0 && (LATE_TIME(p0->expire,pE->expire)||ktime_equal(p0->expire, pE->expire)))
     862:	85 d2                	test   %edx,%edx
     864:	74 32                	je     898 <__fsm_tm_ev_add.constprop.7+0x158>
     866:	8b 4a 08             	mov    0x8(%edx),%ecx
     869:	8b 5a 0c             	mov    0xc(%edx),%ebx
     86c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     86f:	89 d0                	mov    %edx,%eax
     871:	8b 75 e8             	mov    -0x18(%ebp),%esi
     874:	8b 7d ec             	mov    -0x14(%ebp),%edi
     877:	29 ce                	sub    %ecx,%esi
     879:	19 df                	sbb    %ebx,%edi
     87b:	83 ff 00             	cmp    $0x0,%edi
     87e:	7f e0                	jg     860 <__fsm_tm_ev_add.constprop.7+0x120>
     880:	7c 05                	jl     887 <__fsm_tm_ev_add.constprop.7+0x147>
     882:	83 fe 00             	cmp    $0x0,%esi
     885:	77 d9                	ja     860 <__fsm_tm_ev_add.constprop.7+0x120>
     887:	8b 55 ec             	mov    -0x14(%ebp),%edx
     88a:	33 4d e8             	xor    -0x18(%ebp),%ecx
     88d:	31 da                	xor    %ebx,%edx
     88f:	09 ca                	or     %ecx,%edx
     891:	74 cd                	je     860 <__fsm_tm_ev_add.constprop.7+0x120>
     893:	89 c2                	mov    %eax,%edx
     895:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		p1 = p0;
		p0 = p0->pNext;
	}
	pE->pNext = p0;
     898:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     89b:	89 11                	mov    %edx,(%ecx)
	p1->pNext = pE;
     89d:	89 08                	mov    %ecx,(%eax)
     89f:	e9 74 ff ff ff       	jmp    818 <__fsm_tm_ev_add.constprop.7+0xd8>
     8a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     8aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

000008b0 <fsm_mem_free>:
	mallocnum++;
	return ptr;
}

void fsm_mem_free(void* ptr)
{
     8b0:	55                   	push   %ebp
     8b1:	89 e5                	mov    %esp,%ebp
     8b3:	e8 fc ff ff ff       	call   8b4 <fsm_mem_free+0x4>
	FSM_MEM_FREE(ptr);
     8b8:	e8 fc ff ff ff       	call   8b9 <fsm_mem_free+0x9>
}
     8bd:	5d                   	pop    %ebp
     8be:	c3                   	ret    
     8bf:	90                   	nop

000008c0 <fsm_mem_cpy>:

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
     8c0:	55                   	push   %ebp
     8c1:	89 e5                	mov    %esp,%ebp
     8c3:	e8 fc ff ff ff       	call   8c4 <fsm_mem_cpy+0x4>
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     8c8:	e8 fc ff ff ff       	call   8c9 <fsm_mem_cpy+0x9>
}
     8cd:	5d                   	pop    %ebp
     8ce:	c3                   	ret    
     8cf:	90                   	nop

000008d0 <fsm_mem_set>:

void* fsm_mem_set(void* dst_ptr, const int val, size_t size)
{
     8d0:	55                   	push   %ebp
     8d1:	89 e5                	mov    %esp,%ebp
     8d3:	e8 fc ff ff ff       	call   8d4 <fsm_mem_set+0x4>
	return FSM_MEM_SET(dst_ptr,val,size);
     8d8:	e8 fc ff ff ff       	call   8d9 <fsm_mem_set+0x9>
}
     8dd:	5d                   	pop    %ebp
     8de:	c3                   	ret    
     8df:	90                   	nop

000008e0 <fsm_mem_cmp>:

int fsm_mem_cmp(const void* dst_ptr, const void* src_ptr, size_t size)
{
     8e0:	55                   	push   %ebp
     8e1:	89 e5                	mov    %esp,%ebp
     8e3:	e8 fc ff ff ff       	call   8e4 <fsm_mem_cmp+0x4>
	return FSM_MEM_CMP(dst_ptr,src_ptr,size);
     8e8:	e8 fc ff ff ff       	call   8e9 <fsm_mem_cmp+0x9>
}
     8ed:	5d                   	pop    %ebp
     8ee:	c3                   	ret    
     8ef:	90                   	nop

000008f0 <fsm_printf>:


/* Print */
size_t fsm_printf(const char* fmt,...)
{
     8f0:	55                   	push   %ebp
     8f1:	89 e5                	mov    %esp,%ebp
     8f3:	83 ec 08             	sub    $0x8,%esp
     8f6:	e8 fc ff ff ff       	call   8f7 <fsm_printf+0x7>
	//return 0;
	int print_len;
	va_list args;
	va_start(args,fmt);
     8fb:	8d 45 0c             	lea    0xc(%ebp),%eax
	print_len = VPRINTK(fmt,args);
     8fe:	89 44 24 04          	mov    %eax,0x4(%esp)
     902:	8b 45 08             	mov    0x8(%ebp),%eax
     905:	89 04 24             	mov    %eax,(%esp)
     908:	e8 fc ff ff ff       	call   909 <fsm_printf+0x19>
	va_end(args);
	return print_len;
	
	return 0;
}
     90d:	c9                   	leave  
     90e:	c3                   	ret    
     90f:	90                   	nop

00000910 <__fsm_pending_expev>:
//	fsm_printf("__fsm_skb_xmit() packet send\n");
	return;
}

static void __fsm_pending_expev(unsigned long data)
{
     910:	55                   	push   %ebp
     911:	89 e5                	mov    %esp,%ebp
     913:	57                   	push   %edi
     914:	56                   	push   %esi
     915:	53                   	push   %ebx
     916:	83 ec 18             	sub    $0x18,%esp
     919:	e8 fc ff ff ff       	call   91a <__fsm_pending_expev+0xa>
     91e:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     924:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     92a:	0f 85 a5 00 00 00    	jne    9d5 <__fsm_pending_expev+0xc5>
     930:	e9 eb 00 00 00       	jmp    a20 <__fsm_pending_expev+0x110>
     935:	8d 76 00             	lea    0x0(%esi),%esi
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     938:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     93d:	e8 fc ff ff ff       	call   93e <__fsm_pending_expev+0x2e>
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     942:	8b 4b 1c             	mov    0x1c(%ebx),%ecx
     945:	8b 53 14             	mov    0x14(%ebx),%edx
		if(spin_is_locked(&fsm_core.lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
//			return;
		}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     948:	89 45 ec             	mov    %eax,-0x14(%ebp)
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
     94b:	8b 43 18             	mov    0x18(%ebx),%eax
     94e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
     955:	00 
     956:	8b 7b 28             	mov    0x28(%ebx),%edi
     959:	89 7c 24 08          	mov    %edi,0x8(%esp)
     95d:	8b 7b 20             	mov    0x20(%ebx),%edi
     960:	89 7c 24 04          	mov    %edi,0x4(%esp)
     964:	8b 7b 24             	mov    0x24(%ebx),%edi
     967:	89 3c 24             	mov    %edi,(%esp)
     96a:	e8 c1 fa ff ff       	call   430 <__fsm_core_self_drive>
     96f:	8b 55 ec             	mov    -0x14(%ebp),%edx
     972:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     977:	e8 fc ff ff ff       	call   978 <__fsm_pending_expev+0x68>

#if defined(CONFIG_SMP) && defined(CONFIG_PARAVIRT_SPINLOCKS)

static inline int arch_spin_is_locked(struct arch_spinlock *lock)
{
	return PVOP_CALL1(int, pv_lock_ops.spin_is_locked, lock);
     97c:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     981:	ff 15 00 00 00 00    	call   *0x0
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
     987:	85 c0                	test   %eax,%eax
     989:	75 7d                	jne    a08 <__fsm_pending_expev+0xf8>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
//			return;
		} 
		spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
     98b:	b8 e6 02 00 00       	mov    $0x2e6,%eax
     990:	e8 fc ff ff ff       	call   991 <__fsm_pending_expev+0x81>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
     995:	8b 4e 04             	mov    0x4(%esi),%ecx
     998:	8b 3e                	mov    (%esi),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
     99a:	89 4f 04             	mov    %ecx,0x4(%edi)
     99d:	89 c2                	mov    %eax,%edx
     99f:	b8 e6 02 00 00       	mov    $0x2e6,%eax
	prev->next = next;
     9a4:	89 39                	mov    %edi,(%ecx)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
     9a6:	c7 06 00 01 10 00    	movl   $0x100100,(%esi)
	entry->prev = LIST_POISON2;
     9ac:	c7 46 04 00 02 20 00 	movl   $0x200200,0x4(%esi)
     9b3:	e8 fc ff ff ff       	call   9b4 <__fsm_pending_expev+0xa4>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     9b8:	89 d8                	mov    %ebx,%eax
     9ba:	e8 fc ff ff ff       	call   9bb <__fsm_pending_expev+0xab>
     9bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9c2:	e8 fc ff ff ff       	call   9c3 <__fsm_pending_expev+0xb3>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
     9c7:	8b 35 dc 02 00 00    	mov    0x2dc,%esi
static void __fsm_pending_expev(unsigned long data)
{
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
     9cd:	81 fe dc 02 00 00    	cmp    $0x2dc,%esi
     9d3:	74 4b                	je     a20 <__fsm_pending_expev+0x110>
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9d5:	8d 46 fc             	lea    -0x4(%esi),%eax
		pE = tmev_ptr->pE;
     9d8:	8b 5e fc             	mov    -0x4(%esi),%ebx
	struct tmev* tmev_ptr;
	__tmEvent* pE;
	unsigned long flags, flags2;
	while(!list_empty(&fsm_core.exp_ev_list))
	{
		tmev_ptr = list_first_entry(&fsm_core.exp_ev_list, struct tmev, list_node);
     9db:	89 45 f0             	mov    %eax,-0x10(%ebp)
     9de:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     9e3:	ff 15 00 00 00 00    	call   *0x0
		pE = tmev_ptr->pE;
		if(spin_is_locked(&fsm_core.lock))
     9e9:	85 c0                	test   %eax,%eax
     9eb:	0f 84 47 ff ff ff    	je     938 <__fsm_pending_expev+0x28>
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.lock\n");
     9f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     9f8:	e8 fc ff ff ff       	call   9f9 <__fsm_pending_expev+0xe9>
     9fd:	e9 36 ff ff ff       	jmp    938 <__fsm_pending_expev+0x28>
     a02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(pE->type,pE->code,pE->pkptr,pE->src_id,pE->dst_id,pE->buffer,INVALIDE); 
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		if(spin_is_locked(&fsm_core.expev_list_lock))
		{
			fsm_printf("dead lock-_fsm_pending_expev fsm_core.expev_list_lock\n");
     a08:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
     a0f:	e8 fc ff ff ff       	call   a10 <__fsm_pending_expev+0x100>
     a14:	e9 72 ff ff ff       	jmp    98b <__fsm_pending_expev+0x7b>
     a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		list_del(&tmev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
		fsm_mem_free(pE);
		fsm_mem_free(tmev_ptr);
	}
}
     a20:	83 c4 18             	add    $0x18,%esp
     a23:	5b                   	pop    %ebx
     a24:	5e                   	pop    %esi
     a25:	5f                   	pop    %edi
     a26:	5d                   	pop    %ebp
     a27:	c3                   	ret    
     a28:	90                   	nop
     a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00000a30 <__fsm_tm_expire>:
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
}

static enum hrtimer_restart __fsm_tm_expire(struct hrtimer *timer)
{
     a30:	55                   	push   %ebp
     a31:	89 e5                	mov    %esp,%ebp
     a33:	57                   	push   %edi
     a34:	56                   	push   %esi
     a35:	53                   	push   %ebx
     a36:	83 ec 08             	sub    $0x8,%esp
     a39:	e8 fc ff ff ff       	call   a3a <__fsm_tm_expire+0xa>
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a3e:	e8 fc ff ff ff       	call   a3f <__fsm_tm_expire+0xf>
	pB->tm_state = FSM_TM_EXPIRE;
     a43:	c7 05 44 02 00 00 02 	movl   $0x2,0x244
     a4a:	00 00 00 
	struct tmev* tmev_ptr;
	unsigned long flags;
//	fsm_printf("fsm_tm_expire\n");

	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
     a4d:	89 c6                	mov    %eax,%esi
     a4f:	89 d7                	mov    %edx,%edi
     a51:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a56:	ff 15 00 00 00 00    	call   *0x0
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
     a5c:	85 c0                	test   %eax,%eax
     a5e:	0f 85 9c 00 00 00    	jne    b00 <__fsm_tm_expire+0xd0>
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a64:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a69:	e8 fc ff ff ff       	call   a6a <__fsm_tm_expire+0x3a>
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a6e:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     a74:	85 db                	test   %ebx,%ebx
		return HRTIMER_NORESTART;
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     a79:	74 15                	je     a90 <__fsm_tm_expire+0x60>
     a7b:	8b 43 08             	mov    0x8(%ebx),%eax
     a7e:	8b 53 0c             	mov    0xc(%ebx),%edx
     a81:	29 f0                	sub    %esi,%eax
     a83:	19 fa                	sbb    %edi,%edx
     a85:	83 fa 00             	cmp    $0x0,%edx
     a88:	0f 8e a2 00 00 00    	jle    b30 <__fsm_tm_expire+0x100>
     a8e:	66 90                	xchg   %ax,%ax
     a90:	8b 55 f0             	mov    -0x10(%ebp),%edx
     a93:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     a98:	e8 fc ff ff ff       	call   a99 <__fsm_tm_expire+0x69>
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
			tmev_ptr->pE = pE;
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);		
		tasklet_schedule(fsm_core.exp_ev_tsklt);
     a9d:	a1 cc 02 00 00       	mov    0x2cc,%eax
     aa2:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     aa8:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     aaa:	85 d2                	test   %edx,%edx
     aac:	74 42                	je     af0 <__fsm_tm_expire+0xc0>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     aae:	a1 88 02 00 00       	mov    0x288,%eax
     ab3:	85 c0                	test   %eax,%eax
     ab5:	74 61                	je     b18 <__fsm_tm_expire+0xe8>
     ab7:	8b 50 0c             	mov    0xc(%eax),%edx
     aba:	8b 40 08             	mov    0x8(%eax),%eax
        {	
		hrtimer_set_expires(&pB->timer, pB->evQ->expire);
		pB->tm_state = FSM_TM_RUN;	
     abd:	c7 05 44 02 00 00 01 	movl   $0x1,0x244
     ac4:	00 00 00 
	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
};

static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
{
	timer->node.expires = time;
     ac7:	89 15 58 02 00 00    	mov    %edx,0x258
     acd:	a3 54 02 00 00       	mov    %eax,0x254
	timer->_softexpires = time;
     ad2:	a3 5c 02 00 00       	mov    %eax,0x25c
		return HRTIMER_RESTART;
     ad7:	b8 01 00 00 00       	mov    $0x1,%eax
     adc:	89 15 60 02 00 00    	mov    %edx,0x260
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     ae2:	83 c4 08             	add    $0x8,%esp
     ae5:	5b                   	pop    %ebx
     ae6:	5e                   	pop    %esi
     ae7:	5f                   	pop    %edi
     ae8:	5d                   	pop    %ebp
     ae9:	c3                   	ret    
     aea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		__tasklet_schedule(t);
     af0:	e8 fc ff ff ff       	call   af1 <__fsm_tm_expire+0xc1>
//	fsm_printf("ready to unlock\n");
		spin_unlock_bh(&fsm_core.lock);
//	fsm_printf("unlock_bh\n");
	}
*/
	if(pB->evQ)
     af5:	a1 88 02 00 00       	mov    0x288,%eax
     afa:	85 c0                	test   %eax,%eax
     afc:	75 b9                	jne    ab7 <__fsm_tm_expire+0x87>
     afe:	eb 18                	jmp    b18 <__fsm_tm_expire+0xe8>
	pB = TMBLOCK_PTR;
	cur_time = ktime_get();
	pB->tm_state = FSM_TM_EXPIRE;
	if(spin_is_locked(&fsm_core.tmev_list_lock))	
	{
		fsm_printf("dead lock\n");
     b00:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     b07:	e8 fc ff ff ff       	call   b08 <__fsm_tm_expire+0xd8>
		return HRTIMER_NORESTART;
     b0c:	31 c0                	xor    %eax,%eax
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
	}
	
}
     b0e:	83 c4 08             	add    $0x8,%esp
     b11:	5b                   	pop    %ebx
     b12:	5e                   	pop    %esi
     b13:	5f                   	pop    %edi
     b14:	5d                   	pop    %ebp
     b15:	c3                   	ret    
     b16:	66 90                	xchg   %ax,%ax
		pB->tm_state = FSM_TM_RUN;	
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
     b18:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     b1f:	00 00 00 
		return HRTIMER_NORESTART;	
	}
	
}
     b22:	83 c4 08             	add    $0x8,%esp
		return HRTIMER_RESTART;
	}
	else
	{
		pB->tm_state = FSM_TM_STOP;
		return HRTIMER_NORESTART;	
     b25:	31 c0                	xor    %eax,%eax
	}
	
}
     b27:	5b                   	pop    %ebx
     b28:	5e                   	pop    %esi
     b29:	5f                   	pop    %edi
     b2a:	5d                   	pop    %ebp
     b2b:	c3                   	ret    
     b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b30:	7c 0f                	jl     b41 <__fsm_tm_expire+0x111>
     b32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b38:	83 f8 00             	cmp    $0x0,%eax
     b3b:	0f 87 4f ff ff ff    	ja     a90 <__fsm_tm_expire+0x60>
		{
			pE = pB->evQ;
			pB->evQ = pE->pNext;
     b41:	8b 03                	mov    (%ebx),%eax
     b43:	a3 88 02 00 00       	mov    %eax,0x288
			tmev_ptr = (struct tmev*)fsm_mem_alloc(sizeof(struct tmev));
     b48:	b8 0c 00 00 00       	mov    $0xc,%eax
     b4d:	e8 fc ff ff ff       	call   b4e <__fsm_tm_expire+0x11e>
			tmev_ptr->pE = pE;
     b52:	89 18                	mov    %ebx,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     b54:	8b 15 e0 02 00 00    	mov    0x2e0,%edx
			list_add_tail(&tmev_ptr->list_node, &fsm_core.exp_ev_list);
     b5a:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     b5d:	89 0d e0 02 00 00    	mov    %ecx,0x2e0
	new->next = next;
     b63:	c7 40 04 dc 02 00 00 	movl   $0x2dc,0x4(%eax)
	new->prev = prev;
     b6a:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
     b6d:	89 0a                	mov    %ecx,(%edx)
	}	
	/* No matter whether core is busy or idle, the expired timing event is pended to prevent the possible nested interruption. */
//	if(spin_is_locked(&fsm_core.lock))
//	{
		spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
		while(pB->evQ && !LATE_TIME(cur_time, pB->evQ->expire))
     b6f:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     b75:	85 db                	test   %ebx,%ebx
     b77:	0f 84 13 ff ff ff    	je     a90 <__fsm_tm_expire+0x60>
     b7d:	8b 43 08             	mov    0x8(%ebx),%eax
     b80:	8b 53 0c             	mov    0xc(%ebx),%edx
     b83:	29 f0                	sub    %esi,%eax
     b85:	19 fa                	sbb    %edi,%edx
     b87:	83 fa 00             	cmp    $0x0,%edx
     b8a:	7c b5                	jl     b41 <__fsm_tm_expire+0x111>
     b8c:	0f 8f fe fe ff ff    	jg     a90 <__fsm_tm_expire+0x60>
     b92:	eb a4                	jmp    b38 <__fsm_tm_expire+0x108>
     b94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     b9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00000ba0 <fsm_octets_print>:
	
	return 0;
}

size_t fsm_octets_print(void* data_ptr, size_t num)
{
     ba0:	55                   	push   %ebp
     ba1:	89 e5                	mov    %esp,%ebp
     ba3:	e8 fc ff ff ff       	call   ba4 <fsm_octets_print+0x4>
		}
	}
	fsm_printf("\n");
	fsm_printf("=====================================================\n");
	return num;
}
     ba8:	31 c0                	xor    %eax,%eax
     baa:	5d                   	pop    %ebp
     bab:	c3                   	ret    
     bac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bb0 <fsm_htons>:

/* Endianness */
u16 fsm_htons(u16 val)
{
     bb0:	55                   	push   %ebp
     bb1:	89 e5                	mov    %esp,%ebp
     bb3:	e8 fc ff ff ff       	call   bb4 <fsm_htons+0x4>
	return HTONS(val);
}
     bb8:	5d                   	pop    %ebp
static inline __attribute_const__ __u16 __fswab16(__u16 val)
{
#ifdef __arch_swab16
	return __arch_swab16(val);
#else
	return ___constant_swab16(val);
     bb9:	66 c1 c0 08          	rol    $0x8,%ax
     bbd:	c3                   	ret    
     bbe:	66 90                	xchg   %ax,%ax

00000bc0 <fsm_htonl>:

u32 fsm_htonl(u32 val)
{
     bc0:	55                   	push   %ebp
     bc1:	89 e5                	mov    %esp,%ebp
     bc3:	e8 fc ff ff ff       	call   bc4 <fsm_htonl+0x4>

static inline __attribute_const__ __u32 __arch_swab32(__u32 val)
{
#ifdef __i386__
# ifdef CONFIG_X86_BSWAP
	asm("bswap %0" : "=r" (val) : "0" (val));
     bc8:	0f c8                	bswap  %eax
	return HTONL(val);
}
     bca:	5d                   	pop    %ebp
     bcb:	c3                   	ret    
     bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bd0 <fsm_ntohs>:

u16 fsm_ntohs(u16 val)
{
     bd0:	55                   	push   %ebp
     bd1:	89 e5                	mov    %esp,%ebp
     bd3:	e8 fc ff ff ff       	call   bd4 <fsm_ntohs+0x4>
	return NTOHS(val);
}
     bd8:	5d                   	pop    %ebp
     bd9:	66 c1 c0 08          	rol    $0x8,%ax
     bdd:	c3                   	ret    
     bde:	66 90                	xchg   %ax,%ax

00000be0 <fsm_ntohl>:

u32 fsm_ntohl(u32 val)
{
     be0:	55                   	push   %ebp
     be1:	89 e5                	mov    %esp,%ebp
     be3:	e8 fc ff ff ff       	call   be4 <fsm_ntohl+0x4>
     be8:	0f c8                	bswap  %eax
	return NTOHL(val);
}
     bea:	5d                   	pop    %ebp
     beb:	c3                   	ret    
     bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00000bf0 <fsm_schedule_self>:

/*  Event scheduling operation */
evHandle fsm_schedule_self(unsigned int delay, u32 code)
{
     bf0:	55                   	push   %ebp
     bf1:	89 e5                	mov    %esp,%ebp
     bf3:	53                   	push   %ebx
     bf4:	83 ec 0c             	sub    $0xc,%esp
     bf7:	e8 fc ff ff ff       	call   bf8 <fsm_schedule_self+0x8>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_SELF, code, NULL, fsm_core.current_fsm, fsm_core.current_fsm, NULL);
     bfc:	8b 1d 20 00 00 00    	mov    0x20,%ebx
     c02:	89 d1                	mov    %edx,%ecx
     c04:	ba 03 00 00 00       	mov    $0x3,%edx
     c09:	89 5c 24 04          	mov    %ebx,0x4(%esp)
     c0d:	89 1c 24             	mov    %ebx,(%esp)
     c10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c17:	00 
     c18:	e8 23 fb ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c1d:	83 c4 0c             	add    $0xc,%esp
     c20:	5b                   	pop    %ebx
     c21:	5d                   	pop    %ebp
     c22:	c3                   	ret    
     c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
     c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000c30 <fsm_schedule_exfsm>:

evHandle fsm_schedule_exfsm(unsigned int delay, u32 code, int dst_id)
{
     c30:	55                   	push   %ebp
     c31:	89 e5                	mov    %esp,%ebp
     c33:	83 ec 0c             	sub    $0xc,%esp
     c36:	e8 fc ff ff ff       	call   c37 <fsm_schedule_exfsm+0x7>
	return 	__fsm_tm_ev_add(delay, FSM_EV_TYPE_EXFSM, code, NULL, fsm_core.current_fsm, dst_id, NULL);
     c3b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
     c3f:	8b 0d 20 00 00 00    	mov    0x20,%ecx
     c45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     c4c:	00 
     c4d:	89 0c 24             	mov    %ecx,(%esp)
     c50:	89 d1                	mov    %edx,%ecx
     c52:	ba 04 00 00 00       	mov    $0x4,%edx
     c57:	e8 e4 fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     c5c:	c9                   	leave  
     c5d:	c3                   	ret    
     c5e:	66 90                	xchg   %ax,%ax

00000c60 <fsm_post_msg>:

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
     c60:	55                   	push   %ebp
     c61:	89 e5                	mov    %esp,%ebp
     c63:	83 ec 20             	sub    $0x20,%esp
     c66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     c69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     c6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     c6f:	e8 fc ff ff ff       	call   c70 <fsm_post_msg+0x10>
     c74:	89 cf                	mov    %ecx,%edi
     c76:	8b 4d 08             	mov    0x8(%ebp),%ecx
     c79:	89 d6                	mov    %edx,%esi
     c7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c7e:	89 c8                	mov    %ecx,%eax
     c80:	89 4d ec             	mov    %ecx,-0x14(%ebp)
     c83:	e8 fc ff ff ff       	call   c84 <fsm_post_msg+0x24>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     c8b:	89 f2                	mov    %esi,%edx
}

evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
     c8d:	89 c3                	mov    %eax,%ebx
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     c8f:	e8 fc ff ff ff       	call   c90 <fsm_post_msg+0x30>
evHandle fsm_post_msg(u32 code , void* msg_ptr, int dst_id, size_t size)
{
	void* buffer;
	buffer = fsm_mem_alloc(size);
	fsm_mem_cpy(buffer, msg_ptr, size);
	return	__fsm_tm_ev_add(0, FSM_EV_TYPE_MSG, code, NULL, fsm_core.current_fsm, dst_id, buffer);
     c94:	a1 20 00 00 00       	mov    0x20,%eax
     c99:	ba 06 00 00 00       	mov    $0x6,%edx
     c9e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
     ca1:	89 04 24             	mov    %eax,(%esp)
     ca4:	31 c0                	xor    %eax,%eax
     ca6:	89 5c 24 08          	mov    %ebx,0x8(%esp)
     caa:	89 7c 24 04          	mov    %edi,0x4(%esp)
     cae:	e8 8d fa ff ff       	call   740 <__fsm_tm_ev_add.constprop.7>
}
     cb3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     cb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
     cb9:	8b 7d fc             	mov    -0x4(%ebp),%edi
     cbc:	89 ec                	mov    %ebp,%esp
     cbe:	5d                   	pop    %ebp
     cbf:	c3                   	ret    

00000cc0 <fsm_schedule_cancel>:

int fsm_schedule_cancel(evHandle eh)
{
     cc0:	55                   	push   %ebp
     cc1:	89 e5                	mov    %esp,%ebp
     cc3:	56                   	push   %esi
     cc4:	53                   	push   %ebx
     cc5:	e8 fc ff ff ff       	call   cc6 <fsm_schedule_cancel+0x6>
     cca:	89 c3                	mov    %eax,%ebx
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
     ccc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
	__tmEvent* p0;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	if(pE->evmask != EVMASK)
     cd1:	81 7b 04 d6 96 0f 04 	cmpl   $0x40f96d6,0x4(%ebx)
     cd8:	75 43                	jne    d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
     cda:	8b 35 88 02 00 00    	mov    0x288,%esi
     ce0:	85 f6                	test   %esi,%esi
     ce2:	74 39                	je     d1d <fsm_schedule_cancel+0x5d>
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     ce4:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     ce9:	e8 fc ff ff ff       	call   cea <fsm_schedule_cancel+0x2a>
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cee:	8b 15 88 02 00 00    	mov    0x288,%edx
     cf4:	39 d3                	cmp    %edx,%ebx
	unsigned long flags;
	if(pE->evmask != EVMASK)
		return FSM_EXEC_FAIL;
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
     cf6:	89 c6                	mov    %eax,%esi
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
     cf8:	75 0c                	jne    d06 <fsm_schedule_cancel+0x46>
     cfa:	eb 49                	jmp    d45 <fsm_schedule_cancel+0x85>
     cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
     d00:	39 c3                	cmp    %eax,%ebx
     d02:	74 24                	je     d28 <fsm_schedule_cancel+0x68>
     d04:	89 c2                	mov    %eax,%edx
     d06:	8b 02                	mov    (%edx),%eax
     d08:	85 c0                	test   %eax,%eax
     d0a:	75 f4                	jne    d00 <fsm_schedule_cancel+0x40>
     d0c:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d11:	89 f2                	mov    %esi,%edx
     d13:	e8 fc ff ff ff       	call   d14 <fsm_schedule_cancel+0x54>
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
	}
	spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
	return FSM_EXEC_FAIL;
     d18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d1d:	5b                   	pop    %ebx
     d1e:	5e                   	pop    %esi
     d1f:	5d                   	pop    %ebp
     d20:	c3                   	ret    
     d21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	p0= pB->evQ;
	while(p0->pNext && (EVHANDLE(pE) != EVHANDLE(p0->pNext)))
		p0 = p0->pNext;
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
     d28:	8b 03                	mov    (%ebx),%eax
     d2a:	89 02                	mov    %eax,(%edx)
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d2c:	89 d8                	mov    %ebx,%eax
     d2e:	e8 fc ff ff ff       	call   d2f <fsm_schedule_cancel+0x6f>
     d33:	89 f2                	mov    %esi,%edx
     d35:	b8 e8 02 00 00       	mov    $0x2e8,%eax
     d3a:	e8 fc ff ff ff       	call   d3b <fsm_schedule_cancel+0x7b>
	if(p0->pNext)
	{
		p0->pNext = pE->pNext;
		fsm_mem_free(pE);
		spin_unlock_irqrestore(&fsm_core.tmev_list_lock, flags);
		return FSM_EXEC_SUCC;
     d3f:	31 c0                	xor    %eax,%eax
}

int fsm_schedule_cancel(evHandle eh)
{
	return __fsm_tm_ev_rmv((__tmEvent*)eh);
}
     d41:	5b                   	pop    %ebx
     d42:	5e                   	pop    %esi
     d43:	5d                   	pop    %ebp
     d44:	c3                   	ret    
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d45:	8b 03                	mov    (%ebx),%eax
		if(pB->tm_state != FSM_TM_EXPIRE)
     d47:	83 3d 44 02 00 00 02 	cmpl   $0x2,0x244
	if(!pB->evQ)
		return FSM_EXEC_FAIL;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	if(EVHANDLE(pE) == EVHANDLE(pB->evQ))
	{
		pB->evQ = pB->evQ->pNext;
     d4e:	a3 88 02 00 00       	mov    %eax,0x288
		if(pB->tm_state != FSM_TM_EXPIRE)
     d53:	74 05                	je     d5a <fsm_schedule_cancel+0x9a>
		{
			__fsm_tm_restart();
     d55:	e8 d6 f3 ff ff       	call   130 <__fsm_tm_restart>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
     d5a:	89 d8                	mov    %ebx,%eax
     d5c:	e8 fc ff ff ff       	call   d5d <fsm_schedule_cancel+0x9d>
		if(pB->tm_state != FSM_TM_EXPIRE)
		{
			__fsm_tm_restart();
		}
		fsm_mem_free(pE);
		if(!pB->evQ)
     d61:	8b 1d 88 02 00 00    	mov    0x288,%ebx
     d67:	85 db                	test   %ebx,%ebx
     d69:	75 c8                	jne    d33 <fsm_schedule_cancel+0x73>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
     d6b:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
     d70:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
     d77:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
     d7a:	e8 fc ff ff ff       	call   d7b <fsm_schedule_cancel+0xbb>
     d7f:	eb b2                	jmp    d33 <fsm_schedule_cancel+0x73>
     d81:	eb 0d                	jmp    d90 <fsm_do_ioctrl>
     d83:	90                   	nop
     d84:	90                   	nop
     d85:	90                   	nop
     d86:	90                   	nop
     d87:	90                   	nop
     d88:	90                   	nop
     d89:	90                   	nop
     d8a:	90                   	nop
     d8b:	90                   	nop
     d8c:	90                   	nop
     d8d:	90                   	nop
     d8e:	90                   	nop
     d8f:	90                   	nop

00000d90 <fsm_do_ioctrl>:
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     d90:	55                   	push   %ebp
     d91:	89 e5                	mov    %esp,%ebp
     d93:	83 ec 14             	sub    $0x14,%esp
     d96:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     d99:	89 75 f8             	mov    %esi,-0x8(%ebp)
     d9c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     d9f:	e8 fc ff ff ff       	call   da0 <fsm_do_ioctrl+0x10>
     da4:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     da7:	c1 e0 04             	shl    $0x4,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     daa:	89 d6                	mov    %edx,%esi
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
     dac:	8b 90 4c 00 00 00    	mov    0x4c(%eax),%edx
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     db2:	b8 18 00 00 00       	mov    $0x18,%eax
	fsm_mem_free(ifr_ptr);
	return result;
}*/

int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
     db7:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dba:	89 55 ec             	mov    %edx,-0x14(%ebp)
     dbd:	e8 fc ff ff ff       	call   dbe <fsm_do_ioctrl+0x2e>
	ev_ptr->dev =dev;
     dc2:	8b 55 ec             	mov    -0x14(%ebp),%edx
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     dc5:	85 ff                	test   %edi,%edi
int fsm_do_ioctrl(int strm_id, u32 cmd, void* data_ptr, size_t size)
{
	NETDEV*	 dev;
	struct evioctl* ev_ptr;
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
     dc7:	89 c3                	mov    %eax,%ebx
	ev_ptr->dev =dev;
     dc9:	89 10                	mov    %edx,(%eax)
	ev_ptr->ifr.cmd = cmd;
     dcb:	89 70 04             	mov    %esi,0x4(%eax)
	ev_ptr->ifr.size = size;
     dce:	89 78 08             	mov    %edi,0x8(%eax)
	if(data_ptr != NULL && size > 0)
     dd1:	75 65                	jne    e38 <fsm_do_ioctrl+0xa8>
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
		fsm_mem_cpy(ev_ptr->ifr.buffer, data_ptr, size);
		}
	else
		{
		ev_ptr->ifr.buffer = NULL;
     dd3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
	raw_spin_lock_init(&(_lock)->rlock);		\
} while (0)

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
     dda:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     ddf:	e8 fc ff ff ff       	call   de0 <fsm_do_ioctrl+0x50>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
     de4:	a1 d8 02 00 00       	mov    0x2d8,%eax
		}
	spin_lock(&fsm_core.ioctl_list_lock);
	list_add_tail(&ev_ptr->list_node, &fsm_core.do_ioctl_list);
     de9:	8d 53 10             	lea    0x10(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
     dec:	89 15 d8 02 00 00    	mov    %edx,0x2d8
	new->next = next;
     df2:	c7 43 10 d4 02 00 00 	movl   $0x2d4,0x10(%ebx)
	new->prev = prev;
     df9:	89 43 14             	mov    %eax,0x14(%ebx)
	prev->next = new;
     dfc:	89 10                	mov    %edx,(%eax)
	return PVOP_CALL1(int, pv_lock_ops.spin_trylock, lock);
}

static __always_inline void arch_spin_unlock(struct arch_spinlock *lock)
{
	PVOP_VCALL1(pv_lock_ops.spin_unlock, lock);
     dfe:	b8 e4 02 00 00       	mov    $0x2e4,%eax
     e03:	ff 15 14 00 00 00    	call   *0x14
	spin_unlock(&fsm_core.ioctl_list_lock);
	tasklet_schedule(fsm_core.do_ioctl_tsklt);
     e09:	a1 c8 02 00 00       	mov    0x2c8,%eax
     e0e:	f0 0f ba 68 04 00    	lock btsl $0x0,0x4(%eax)
     e14:	19 d2                	sbb    %edx,%edx

extern void __tasklet_schedule(struct tasklet_struct *t);

static inline void tasklet_schedule(struct tasklet_struct *t)
{
	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
     e16:	85 d2                	test   %edx,%edx
     e18:	75 05                	jne    e1f <fsm_do_ioctrl+0x8f>
		__tasklet_schedule(t);
     e1a:	e8 fc ff ff ff       	call   e1b <fsm_do_ioctrl+0x8b>
	return 1;
}
     e1f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e22:	b8 01 00 00 00       	mov    $0x1,%eax
     e27:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e2a:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e2d:	89 ec                	mov    %ebp,%esp
     e2f:	5d                   	pop    %ebp
     e30:	c3                   	ret    
     e31:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	dev = fsm_core.__intf[strm_id].dev;
	ev_ptr = (struct evioctl*)fsm_mem_alloc(sizeof(struct evioctl));
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
     e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
     e3b:	85 c0                	test   %eax,%eax
     e3d:	74 94                	je     dd3 <fsm_do_ioctrl+0x43>
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e3f:	89 f8                	mov    %edi,%eax
     e41:	e8 fc ff ff ff       	call   e42 <fsm_do_ioctrl+0xb2>
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e46:	8b 55 f0             	mov    -0x10(%ebp),%edx
     e49:	89 f9                	mov    %edi,%ecx
	ev_ptr->dev =dev;
	ev_ptr->ifr.cmd = cmd;
	ev_ptr->ifr.size = size;
	if(data_ptr != NULL && size > 0)
		{
		ev_ptr->ifr.buffer = fsm_mem_alloc(size);
     e4b:	89 43 0c             	mov    %eax,0xc(%ebx)
	FSM_MEM_FREE(ptr);
}

void* fsm_mem_cpy(void* dst_ptr, const void* src_ptr, size_t size)
{
	return FSM_MEM_CPY(dst_ptr,src_ptr,size);
     e4e:	e8 fc ff ff ff       	call   e4f <fsm_do_ioctrl+0xbf>
     e53:	eb 85                	jmp    dda <fsm_do_ioctrl+0x4a>
     e55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     e59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000e60 <fsm_ioctrl_arrival>:
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e60:	55                   	push   %ebp
     e61:	89 e5                	mov    %esp,%ebp
     e63:	83 ec 28             	sub    $0x28,%esp
     e66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
     e69:	89 75 f8             	mov    %esi,-0x8(%ebp)
     e6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
     e6f:	e8 fc ff ff ff       	call   e70 <fsm_ioctrl_arrival+0x10>
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e74:	81 fa f0 89 00 00    	cmp    $0x89f0,%edx
	return 1;
}


int fsm_ioctrl_arrival(struct ifreq *ifr, int cmd)
{ 
     e7a:	89 c3                	mov    %eax,%ebx
	struct kifreq* kifr_ptr;	
	struct ifreq* uifr_ptr; 
	struct kifreq kifr;
	void* buffer = NULL;
	unsigned long flags2;
	if(cmd == IOCKERNEL)	
     e7c:	0f 84 b6 00 00 00    	je     f38 <fsm_ioctrl_arrival+0xd8>
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
		spin_unlock_irqrestore(&fsm_core.lock, flags2);
		}	
	else if(cmd == IOCUSER)	
     e82:	81 fa f1 89 00 00    	cmp    $0x89f1,%edx
     e88:	74 16                	je     ea0 <fsm_ioctrl_arrival+0x40>
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
		}
	
	return 1;
}
     e8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
     e8d:	b8 01 00 00 00       	mov    $0x1,%eax
     e92:	8b 75 f8             	mov    -0x8(%ebp),%esi
     e95:	8b 7d fc             	mov    -0x4(%ebp),%edi
     e98:	89 ec                	mov    %ebp,%esp
     e9a:	5d                   	pop    %ebp
     e9b:	c3                   	ret    
     e9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					  unsigned long n)
{
	int sz = __compiletime_object_size(to);

	if (likely(sz == -1 || sz >= n))
		n = _copy_from_user(to, from, n);
     ea0:	8b 50 10             	mov    0x10(%eax),%edx
     ea3:	b9 0c 00 00 00       	mov    $0xc,%ecx
     ea8:	8d 45 e8             	lea    -0x18(%ebp),%eax
     eab:	e8 fc ff ff ff       	call   eac <fsm_ioctrl_arrival+0x4c>
	else if(cmd == IOCUSER)	
		{		
		uifr_ptr = ifr;		
		copy_from_user(&kifr, uifr_ptr->ifr_ifru.ifru_data, sizeof(struct kifreq)); 	
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
     eb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     eb3:	85 c0                	test   %eax,%eax
     eb5:	0f 84 cd 00 00 00    	je     f88 <fsm_ioctrl_arrival+0x128>
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
     ebb:	8b 45 ec             	mov    -0x14(%ebp),%eax
     ebe:	e8 fc ff ff ff       	call   ebf <fsm_ioctrl_arrival+0x5f>
     ec3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     ec6:	8b 55 f0             	mov    -0x10(%ebp),%edx
     ec9:	89 c6                	mov    %eax,%esi
     ecb:	e8 fc ff ff ff       	call   ecc <fsm_ioctrl_arrival+0x6c>
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ed0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     ed5:	e8 fc ff ff ff       	call   ed6 <fsm_ioctrl_arrival+0x76>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     eda:	31 c9                	xor    %ecx,%ecx
     edc:	ba 02 00 00 00       	mov    $0x2,%edx
		kifr_ptr = &kifr;		
		if(kifr_ptr->buffer)		
			{			
			buffer = fsm_mem_alloc(kifr_ptr->size); 		
			copy_from_user(buffer, kifr_ptr->buffer, kifr_ptr->size);	
			spin_lock_irqsave(&fsm_core.lock, flags2);
     ee1:	89 c7                	mov    %eax,%edi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,buffer,kifr_ptr->cmd);
     ee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
     ee6:	89 74 24 08          	mov    %esi,0x8(%esp)
     eea:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     ef1:	89 44 24 0c          	mov    %eax,0xc(%esp)
     ef5:	a1 8c 02 00 00       	mov    0x28c,%eax
     efa:	89 44 24 04          	mov    %eax,0x4(%esp)
     efe:	b8 05 00 00 00       	mov    $0x5,%eax
     f03:	e8 28 f5 ff ff       	call   430 <__fsm_core_self_drive>
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     f08:	89 fa                	mov    %edi,%edx
     f0a:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f0f:	e8 fc ff ff ff       	call   f10 <fsm_ioctrl_arrival+0xb0>
			spin_unlock_irqrestore(&fsm_core.lock, flags2);
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
     f14:	8b 4d ec             	mov    -0x14(%ebp),%ecx
     f17:	89 f2                	mov    %esi,%edx
     f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f1c:	e8 fc ff ff ff       	call   f1d <fsm_ioctrl_arrival+0xbd>
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
			spin_unlock_irqrestore(&fsm_core.lock, flags2);		
			}		
		copy_to_user(uifr_ptr->ifr_ifru.ifru_data, kifr_ptr, sizeof(struct kifreq));
     f21:	8b 43 10             	mov    0x10(%ebx),%eax
     f24:	b9 0c 00 00 00       	mov    $0xc,%ecx
     f29:	8d 55 e8             	lea    -0x18(%ebp),%edx
     f2c:	e8 fc ff ff ff       	call   f2d <fsm_ioctrl_arrival+0xcd>
     f31:	e9 54 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f36:	66 90                	xchg   %ax,%ax
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f38:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f3d:	e8 fc ff ff ff       	call   f3e <fsm_ioctrl_arrival+0xde>
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f42:	31 c9                	xor    %ecx,%ecx
     f44:	ba 02 00 00 00       	mov    $0x2,%edx
//		if(kifr_ptr->buffer)
//			{
//			buffer = fsm_mem_alloc(kifr_ptr->size);
//			fsm_mem_cpy(buffer, kifr_ptr->buffer, kifr_ptr->size);
//			}
		spin_lock_irqsave(&fsm_core.lock, flags2);
     f49:	89 c6                	mov    %eax,%esi
		__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, KERNEL_MODULE,MAIN_PORT,kifr_ptr->buffer,kifr_ptr->cmd);
     f4b:	8b 03                	mov    (%ebx),%eax
     f4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
     f54:	89 44 24 0c          	mov    %eax,0xc(%esp)
     f58:	8b 43 08             	mov    0x8(%ebx),%eax
     f5b:	89 44 24 08          	mov    %eax,0x8(%esp)
     f5f:	a1 8c 02 00 00       	mov    0x28c,%eax
     f64:	89 44 24 04          	mov    %eax,0x4(%esp)
     f68:	b8 05 00 00 00       	mov    $0x5,%eax
     f6d:	e8 be f4 ff ff       	call   430 <__fsm_core_self_drive>
     f72:	89 f2                	mov    %esi,%edx
     f74:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f79:	e8 fc ff ff ff       	call   f7a <fsm_ioctrl_arrival+0x11a>
     f7e:	e9 07 ff ff ff       	jmp    e8a <fsm_ioctrl_arrival+0x2a>
     f83:	90                   	nop
     f84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f88:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     f8d:	e8 fc ff ff ff       	call   f8e <fsm_ioctrl_arrival+0x12e>
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f92:	31 c9                	xor    %ecx,%ecx
     f94:	ba 02 00 00 00       	mov    $0x2,%edx
			copy_to_user(kifr_ptr->buffer, buffer, kifr_ptr->size); 		
//			fsm_mem_free(buffer);		
			}		
		else		
			{
			spin_lock_irqsave(&fsm_core.lock, flags2);			
     f99:	89 c6                	mov    %eax,%esi
			__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_IOCTRL,NULL, USER_SPACE, MAIN_PORT,NULL,kifr_ptr->cmd);
     f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     f9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
     fa5:	00 
     fa6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
     fad:	89 44 24 0c          	mov    %eax,0xc(%esp)
     fb1:	a1 8c 02 00 00       	mov    0x28c,%eax
     fb6:	89 44 24 04          	mov    %eax,0x4(%esp)
     fba:	b8 05 00 00 00       	mov    $0x5,%eax
     fbf:	e8 6c f4 ff ff       	call   430 <__fsm_core_self_drive>
     fc4:	89 f2                	mov    %esi,%edx
     fc6:	b8 b4 02 00 00       	mov    $0x2b4,%eax
     fcb:	e8 fc ff ff ff       	call   fcc <fsm_ioctrl_arrival+0x16c>
     fd0:	e9 4c ff ff ff       	jmp    f21 <fsm_ioctrl_arrival+0xc1>
     fd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
     fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00000fe0 <fsm_get_curtime>:



/* Time get */
u32 fsm_get_curtime()
{
     fe0:	55                   	push   %ebp
     fe1:	89 e5                	mov    %esp,%ebp
     fe3:	e8 fc ff ff ff       	call   fe4 <fsm_get_curtime+0x4>
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
     fe8:	e8 fc ff ff ff       	call   fe9 <fsm_get_curtime+0x9>
	cur_time = ktime_to_timeval(ktime);
     fed:	e8 fc ff ff ff       	call   fee <fsm_get_curtime+0xe>
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
	ctm = ctm/10;
     ff2:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
	return ctm;
}
     ff7:	5d                   	pop    %ebp
	ktime_t	ktime;
	struct timeval cur_time;
	u32 ctm;
	ktime = ktime_get();
	cur_time = ktime_to_timeval(ktime);
	ctm = cur_time.tv_sec * 1000000 + cur_time.tv_usec;
     ff8:	69 c0 40 42 0f 00    	imul   $0xf4240,%eax,%eax
     ffe:	01 c2                	add    %eax,%edx
	ctm = ctm/10;
    1000:	89 d0                	mov    %edx,%eax
    1002:	f7 e1                	mul    %ecx
    1004:	c1 ea 03             	shr    $0x3,%edx
	return ctm;
}
    1007:	89 d0                	mov    %edx,%eax
    1009:	c3                   	ret    
    100a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00001010 <fsm_get_random_bytes>:


/* Random bytes get*/
void fsm_get_random_bytes(void *buf, int nbytes)
{
    1010:	55                   	push   %ebp
    1011:	89 e5                	mov    %esp,%ebp
    1013:	e8 fc ff ff ff       	call   1014 <fsm_get_random_bytes+0x4>
	GET_RANDOM_BYTES(buf, nbytes);
    1018:	e8 fc ff ff ff       	call   1019 <fsm_get_random_bytes+0x9>
}
    101d:	5d                   	pop    %ebp
    101e:	c3                   	ret    
    101f:	90                   	nop

00001020 <fsm_core_create>:


/* FSM core operations */

void fsm_core_create(void* dev)
{
    1020:	55                   	push   %ebp
    1021:	89 e5                	mov    %esp,%ebp
    1023:	e8 fc ff ff ff       	call   1024 <fsm_core_create+0x4>
	int i;
	fsm_core.current_fsm = -1;
    1028:	c7 05 20 00 00 00 ff 	movl   $0xffffffff,0x20
    102f:	ff ff ff 
	fsm_core.current_state_ptr = NULL;
    1032:	c7 05 24 00 00 00 00 	movl   $0x0,0x24
    1039:	00 00 00 
	fsm_core.state = CORE_CLOSED;
    103c:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    1043:	00 00 00 
	fsm_core.pkptr = 0;
    1046:	c7 05 2c 00 00 00 00 	movl   $0x0,0x2c
    104d:	00 00 00 
	fsm_core.evtype = 0;
    1050:	c7 05 30 00 00 00 00 	movl   $0x0,0x30
    1057:	00 00 00 
	fsm_core.code = 0;
	fsm_core.src = 0;
	fsm_core.dev = dev;
    105a:	a3 a8 02 00 00       	mov    %eax,0x2a8
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
    105f:	b8 44 00 00 00       	mov    $0x44,%eax
	fsm_core.current_fsm = -1;
	fsm_core.current_state_ptr = NULL;
	fsm_core.state = CORE_CLOSED;
	fsm_core.pkptr = 0;
	fsm_core.evtype = 0;
	fsm_core.code = 0;
    1064:	c7 05 34 00 00 00 00 	movl   $0x0,0x34
    106b:	00 00 00 
	fsm_core.src = 0;
    106e:	c7 05 38 00 00 00 00 	movl   $0x0,0x38
    1075:	00 00 00 
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
    1078:	c7 05 3c 00 00 00 00 	movl   $0x0,0x3c
    107f:	00 00 00 
	fsm_core.fsm_drive = NULL;
    1082:	c7 05 40 00 00 00 00 	movl   $0x0,0x40
    1089:	00 00 00 
	MAIN_PORT = -1;
    108c:	c7 05 8c 02 00 00 ff 	movl   $0xffffffff,0x28c
    1093:	ff ff ff 
    1096:	66 90                	xchg   %ax,%ax
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    1098:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    109e:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    10a4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    10ab:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    10b2:	83 c0 10             	add    $0x10,%eax
	fsm_core.src = 0;
	fsm_core.dev = dev;
	FSM_SV_PTR = NULL;
	fsm_core.fsm_drive = NULL;
	MAIN_PORT = -1;
	for(i = 0; i < MAX_INTF; i++)
    10b5:	3d 44 02 00 00       	cmp    $0x244,%eax
    10ba:	75 dc                	jne    1098 <fsm_core_create+0x78>
		FSM[i] = NULL;
	}
	fsm_core.buffer = NULL;
	fsm_core.ioctrl_cmd = 0;
	spin_lock_init(&fsm_core.lock);
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    10bc:	b8 10 00 00 00       	mov    $0x10,%eax
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	for(i = 0; i < MAX_FSM; ++i)
	{
		FSM[i] = NULL;
    10c1:	c7 05 90 02 00 00 00 	movl   $0x0,0x290
    10c8:	00 00 00 
    10cb:	c7 05 94 02 00 00 00 	movl   $0x0,0x294
    10d2:	00 00 00 
    10d5:	c7 05 98 02 00 00 00 	movl   $0x0,0x298
    10dc:	00 00 00 
    10df:	c7 05 9c 02 00 00 00 	movl   $0x0,0x29c
    10e6:	00 00 00 
    10e9:	c7 05 a0 02 00 00 00 	movl   $0x0,0x2a0
    10f0:	00 00 00 
    10f3:	c7 05 a4 02 00 00 00 	movl   $0x0,0x2a4
    10fa:	00 00 00 
	}
	fsm_core.buffer = NULL;
    10fd:	c7 05 ac 02 00 00 00 	movl   $0x0,0x2ac
    1104:	00 00 00 
	fsm_core.ioctrl_cmd = 0;
    1107:	c7 05 b0 02 00 00 00 	movl   $0x0,0x2b0
    110e:	00 00 00 
	spin_lock_init(&fsm_core.lock);
    1111:	66 c7 05 b4 02 00 00 	movw   $0x0,0x2b4
    1118:	00 00 
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    111a:	e8 fc ff ff ff       	call   111b <fsm_core_create+0xfb>
    111f:	a3 b8 02 00 00       	mov    %eax,0x2b8
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
    1124:	b8 10 00 00 00       	mov    $0x10,%eax
    1129:	e8 fc ff ff ff       	call   112a <fsm_core_create+0x10a>
    112e:	a3 bc 02 00 00       	mov    %eax,0x2bc
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1133:	b8 14 00 00 00       	mov    $0x14,%eax
    1138:	e8 fc ff ff ff       	call   1139 <fsm_core_create+0x119>
    113d:	a3 c0 02 00 00       	mov    %eax,0x2c0
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1142:	b8 14 00 00 00       	mov    $0x14,%eax
    1147:	e8 fc ff ff ff       	call   1148 <fsm_core_create+0x128>
    114c:	a3 c4 02 00 00       	mov    %eax,0x2c4
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1151:	b8 14 00 00 00       	mov    $0x14,%eax
    1156:	e8 fc ff ff ff       	call   1157 <fsm_core_create+0x137>
    115b:	a3 c8 02 00 00       	mov    %eax,0x2c8
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    1160:	b8 14 00 00 00       	mov    $0x14,%eax
    1165:	e8 fc ff ff ff       	call   1166 <fsm_core_create+0x146>
	return; 
}
    116a:	5d                   	pop    %ebp
	fsm_core.tx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.rx_queue = (struct sk_buff_head*)fsm_mem_alloc(sizeof(struct sk_buff_head));
	fsm_core.tx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.rx_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.do_ioctl_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
	fsm_core.exp_ev_tsklt = (struct tasklet_struct*)fsm_mem_alloc(sizeof(struct tasklet_struct));
    116b:	a3 cc 02 00 00       	mov    %eax,0x2cc
	return; 
}
    1170:	c3                   	ret    
    1171:	eb 0d                	jmp    1180 <fsm_core_intf_set>
    1173:	90                   	nop
    1174:	90                   	nop
    1175:	90                   	nop
    1176:	90                   	nop
    1177:	90                   	nop
    1178:	90                   	nop
    1179:	90                   	nop
    117a:	90                   	nop
    117b:	90                   	nop
    117c:	90                   	nop
    117d:	90                   	nop
    117e:	90                   	nop
    117f:	90                   	nop

00001180 <fsm_core_intf_set>:
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    1180:	55                   	push   %ebp
    1181:	89 e5                	mov    %esp,%ebp
    1183:	83 ec 10             	sub    $0x10,%esp
    1186:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1189:	89 75 f8             	mov    %esi,-0x8(%ebp)
    118c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    118f:	e8 fc ff ff ff       	call   1190 <fsm_core_intf_set+0x10>
    1194:	8b 7d 08             	mov    0x8(%ebp),%edi
	NETDEV *dev = NULL;
	switch(type)
    1197:	83 fa 01             	cmp    $0x1,%edx
}

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
    119a:	89 c3                	mov    %eax,%ebx
    119c:	89 ce                	mov    %ecx,%esi
	NETDEV *dev = NULL;
	switch(type)
    119e:	0f 84 bc 00 00 00    	je     1260 <fsm_core_intf_set+0xe0>
    11a4:	72 3a                	jb     11e0 <fsm_core_intf_set+0x60>
    11a6:	83 fa 02             	cmp    $0x2,%edx
    11a9:	74 55                	je     1200 <fsm_core_intf_set+0x80>
		INTF[index].proto = htons(proto);
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_xmit;
		break;
	}
	if(proto == 0 && dev_name == 0)
    11ab:	85 ff                	test   %edi,%edi
    11ad:	8d 76 00             	lea    0x0(%esi),%esi
    11b0:	75 1c                	jne    11ce <fsm_core_intf_set+0x4e>
    11b2:	66 85 f6             	test   %si,%si
    11b5:	75 17                	jne    11ce <fsm_core_intf_set+0x4e>
		{
		INTF[index].valid = DEV_INTF_NULL;
    11b7:	c1 e3 04             	shl    $0x4,%ebx
    11ba:	c7 83 44 00 00 00 00 	movl   $0x0,0x44(%ebx)
    11c1:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11c4:	c7 83 50 00 00 00 20 	movl   $0x120,0x50(%ebx)
    11cb:	01 00 00 
		}
	return;
}
    11ce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    11d1:	8b 75 f8             	mov    -0x8(%ebp),%esi
    11d4:	8b 7d fc             	mov    -0x4(%ebp),%edi
    11d7:	89 ec                	mov    %ebp,%esp
    11d9:	5d                   	pop    %ebp
    11da:	c3                   	ret    
    11db:	90                   	nop
    11dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	NETDEV *dev = NULL;
	switch(type)
	{
	case DEV_INTF_NULL:
		INTF[index].valid = DEV_INTF_NULL;
    11e0:	c1 e0 04             	shl    $0x4,%eax
    11e3:	c7 80 44 00 00 00 00 	movl   $0x0,0x44(%eax)
    11ea:	00 00 00 
		INTF[index].send = __fsm_skb_send_null;
    11ed:	c7 80 50 00 00 00 20 	movl   $0x120,0x50(%eax)
    11f4:	01 00 00 
		break;
    11f7:	eb b2                	jmp    11ab <fsm_core_intf_set+0x2b>
    11f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	case DEV_INTF_IND:
		if(dev_name)
    1200:	85 ff                	test   %edi,%edi
    1202:	0f 84 b8 00 00 00    	je     12c0 <fsm_core_intf_set+0x140>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1208:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].valid = DEV_INTF_NULL;
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    120d:	89 fa                	mov    %edi,%edx
    120f:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1215:	e8 fc ff ff ff       	call   1216 <fsm_core_intf_set+0x96>
		INTF[index].valid = DEV_INTF_IND;
    121a:	8d 53 02             	lea    0x2(%ebx),%edx
    121d:	89 d1                	mov    %edx,%ecx
    121f:	c1 e1 04             	shl    $0x4,%ecx
    1222:	c7 81 24 00 00 00 02 	movl   $0x2,0x24(%ecx)
    1229:	00 00 00 
		INTF[index].proto = htons(proto);
    122c:	0f b7 ce             	movzwl %si,%ecx
    122f:	c1 e1 08             	shl    $0x8,%ecx
    1232:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1235:	89 f1                	mov    %esi,%ecx
    1237:	66 c1 e9 08          	shr    $0x8,%cx
    123b:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    123f:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    1242:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    1248:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_netrx;
    124f:	c7 82 30 00 00 00 30 	movl   $0x230,0x30(%edx)
    1256:	02 00 00 
		break;
    1259:	e9 4d ff ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    125e:	66 90                	xchg   %ax,%ax
	case DEV_INTF_REQ:
		if(dev_name)
    1260:	85 ff                	test   %edi,%edi
    1262:	74 7c                	je     12e0 <fsm_core_intf_set+0x160>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    1264:	a1 a8 02 00 00       	mov    0x2a8,%eax
		INTF[index].dev = dev;
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
    1269:	89 fa                	mov    %edi,%edx
    126b:	8b 80 c0 02 00 00    	mov    0x2c0(%eax),%eax
    1271:	e8 fc ff ff ff       	call   1272 <fsm_core_intf_set+0xf2>
		INTF[index].valid = DEV_INTF_REQ;
    1276:	8d 53 02             	lea    0x2(%ebx),%edx
    1279:	89 d1                	mov    %edx,%ecx
    127b:	c1 e1 04             	shl    $0x4,%ecx
    127e:	c7 81 24 00 00 00 01 	movl   $0x1,0x24(%ecx)
    1285:	00 00 00 
		INTF[index].proto = htons(proto);
    1288:	0f b7 ce             	movzwl %si,%ecx
    128b:	c1 e1 08             	shl    $0x8,%ecx
    128e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1291:	89 f1                	mov    %esi,%ecx
    1293:	66 c1 e9 08          	shr    $0x8,%cx
    1297:	66 0b 4d f0          	or     -0x10(%ebp),%cx
    129b:	c1 e2 04             	shl    $0x4,%edx
		INTF[index].dev = dev;
    129e:	89 82 2c 00 00 00    	mov    %eax,0x2c(%edx)
    12a4:	66 89 8a 28 00 00 00 	mov    %cx,0x28(%edx)
		INTF[index].send = __fsm_skb_pending_xmit;
    12ab:	c7 82 30 00 00 00 d0 	movl   $0x1d0,0x30(%edx)
    12b2:	01 00 00 
		break;
    12b5:	e9 f1 fe ff ff       	jmp    11ab <fsm_core_intf_set+0x2b>
    12ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12c3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_send_null;
		break;
	case DEV_INTF_IND:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_IND;
    12c6:	89 d0                	mov    %edx,%eax
    12c8:	c1 e0 04             	shl    $0x4,%eax
    12cb:	c7 80 24 00 00 00 02 	movl   $0x2,0x24(%eax)
    12d2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12d5:	31 c0                	xor    %eax,%eax
    12d7:	e9 53 ff ff ff       	jmp    122f <fsm_core_intf_set+0xaf>
    12dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e0:	8d 50 02             	lea    0x2(%eax),%edx
		INTF[index].proto = htons(proto);
    12e3:	0f b7 c9             	movzwl %cx,%ecx
		INTF[index].send = __fsm_skb_pending_netrx;
		break;
	case DEV_INTF_REQ:
		if(dev_name)
			dev = DEV_GET_BY_NAME(dev_name);
		INTF[index].valid = DEV_INTF_REQ;
    12e6:	89 d0                	mov    %edx,%eax
    12e8:	c1 e0 04             	shl    $0x4,%eax
    12eb:	c7 80 24 00 00 00 01 	movl   $0x1,0x24(%eax)
    12f2:	00 00 00 

//proto is the protocol of upperlayer of the data stream 
//dev name is the destination of the data stream
void fsm_core_intf_set(int index, u32 type, u16 proto, const char* dev_name)
{
	NETDEV *dev = NULL;
    12f5:	31 c0                	xor    %eax,%eax
    12f7:	eb 92                	jmp    128b <fsm_core_intf_set+0x10b>
    12f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00001300 <fsm_core_open>:
	return;
}


int fsm_core_open()
{
    1300:	55                   	push   %ebp
    1301:	89 e5                	mov    %esp,%ebp
    1303:	53                   	push   %ebx
    1304:	83 ec 10             	sub    $0x10,%esp
    1307:	e8 fc ff ff ff       	call   1308 <fsm_core_open+0x8>
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
    130c:	a1 28 00 00 00       	mov    0x28,%eax
    1311:	85 c0                	test   %eax,%eax
    1313:	0f 85 54 01 00 00    	jne    146d <fsm_core_open+0x16d>
	{
	fsm_printf("core is opening.\n");
    1319:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    1320:	e8 fc ff ff ff       	call   1321 <fsm_core_open+0x21>
	spin_lock_irqsave(&fsm_core.lock, flags);
    1325:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    132a:	e8 fc ff ff ff       	call   132b <fsm_core_open+0x2b>
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    132f:	31 c9                	xor    %ecx,%ecx
    1331:	ba 50 00 00 00       	mov    $0x50,%edx
{
	unsigned long flags;
	if(fsm_core.state == CORE_CLOSED)
	{
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
    1336:	89 c3                	mov    %eax,%ebx
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
    1338:	a1 b8 02 00 00       	mov    0x2b8,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    133d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    1343:	89 00                	mov    %eax,(%eax)
    1345:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    1348:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	skb_queue_head_init(fsm_core.rx_queue);
    134f:	a1 bc 02 00 00       	mov    0x2bc,%eax
 * network layer or drivers should need annotation to consolidate the
 * main types of usage into 3 classes.
 */
static inline void skb_queue_head_init(struct sk_buff_head *list)
{
	spin_lock_init(&list->lock);
    1354:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
 *	the spinlock.  It can also be used for on-stack sk_buff_head
 *	objects where the spinlock is known to not be used.
 */
static inline void __skb_queue_head_init(struct sk_buff_head *list)
{
	list->prev = list->next = (struct sk_buff *)list;
    135a:	89 00                	mov    %eax,(%eax)
    135c:	89 40 04             	mov    %eax,0x4(%eax)
	list->qlen = 0;
    135f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    1366:	a1 c0 02 00 00       	mov    0x2c0,%eax
	fsm_printf("core is opening.\n");
	spin_lock_irqsave(&fsm_core.lock, flags);
	//Initialize queues
	skb_queue_head_init(fsm_core.tx_queue);
	skb_queue_head_init(fsm_core.rx_queue);
	spin_lock_init(&fsm_core.tx_queue_lock);
    136b:	66 c7 05 d0 02 00 00 	movw   $0x0,0x2d0
    1372:	00 00 
	spin_lock_init(&fsm_core.rx_queue_lock);
    1374:	66 c7 05 d2 02 00 00 	movw   $0x0,0x2d2
    137b:	00 00 
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
    137d:	e8 fc ff ff ff       	call   137e <fsm_core_open+0x7e>
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
    1382:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1387:	31 c9                	xor    %ecx,%ecx
    1389:	ba 00 00 00 00       	mov    $0x0,%edx
    138e:	e8 fc ff ff ff       	call   138f <fsm_core_open+0x8f>
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    1393:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1398:	31 c9                	xor    %ecx,%ecx
    139a:	ba a0 00 00 00       	mov    $0xa0,%edx
	spin_lock_init(&fsm_core.tx_queue_lock);
	spin_lock_init(&fsm_core.rx_queue_lock);
	//Initialize tasklets
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
    139f:	66 c7 05 e4 02 00 00 	movw   $0x0,0x2e4
    13a6:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13a8:	c7 05 d4 02 00 00 d4 	movl   $0x2d4,0x2d4
    13af:	02 00 00 
	list->prev = list;
    13b2:	c7 05 d8 02 00 00 d4 	movl   $0x2d4,0x2d8
    13b9:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
    13bc:	e8 fc ff ff ff       	call   13bd <fsm_core_open+0xbd>
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13c1:	a1 cc 02 00 00       	mov    0x2cc,%eax
    13c6:	31 c9                	xor    %ecx,%ecx
    13c8:	ba 10 09 00 00       	mov    $0x910,%edx
	tasklet_init(fsm_core.tx_tsklt, __fsm_skb_xmit, 0);
	tasklet_init(fsm_core.rx_tsklt, __fsm_skb_netrx, 0);
	spin_lock_init(&fsm_core.ioctl_list_lock);
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
    13cd:	66 c7 05 e6 02 00 00 	movw   $0x0,0x2e6
    13d4:	00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    13d6:	c7 05 dc 02 00 00 dc 	movl   $0x2dc,0x2dc
    13dd:	02 00 00 
	list->prev = list;
    13e0:	c7 05 e0 02 00 00 dc 	movl   $0x2dc,0x2e0
    13e7:	02 00 00 
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
    13ea:	e8 fc ff ff ff       	call   13eb <fsm_core_open+0xeb>
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	pB->evQ = 0;
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    13ef:	31 c9                	xor    %ecx,%ecx
    13f1:	ba 01 00 00 00       	mov    $0x1,%edx
    13f6:	b8 48 02 00 00       	mov    $0x248,%eax
	INIT_LIST_HEAD(&fsm_core.do_ioctl_list);
	tasklet_init(fsm_core.do_ioctl_tsklt, __fsm_do_ioctl, 0);
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
    13fb:	66 c7 05 e8 02 00 00 	movw   $0x0,0x2e8
    1402:	00 00 

static void __fsm_tm_init()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    1404:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    140b:	00 00 00 
	pB->evQ = 0;
    140e:	c7 05 88 02 00 00 00 	movl   $0x0,0x288
    1415:	00 00 00 
	hrtimer_init(&pB->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS); 
    1418:	e8 fc ff ff ff       	call   1419 <fsm_core_open+0x119>
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    141d:	a1 8c 02 00 00       	mov    0x28c,%eax
    1422:	31 c9                	xor    %ecx,%ecx
    1424:	31 d2                	xor    %edx,%edx
	spin_lock_init(&fsm_core.expev_list_lock);
	INIT_LIST_HEAD(&fsm_core.exp_ev_list);
	tasklet_init(fsm_core.exp_ev_tsklt, __fsm_pending_expev, 0);
	spin_lock_init(&fsm_core.tmev_list_lock);
	__fsm_tm_init();
	fsm_core.state = CORE_OPENED;
    1426:	c7 05 28 00 00 00 01 	movl   $0x1,0x28
    142d:	00 00 00 
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_OPEN,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1430:	89 44 24 04          	mov    %eax,0x4(%esp)
    1434:	b8 05 00 00 00       	mov    $0x5,%eax
    1439:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1440:	00 
    1441:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1448:	00 
    1449:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1450:	e8 db ef ff ff       	call   430 <__fsm_core_self_drive>
    1455:	89 da                	mov    %ebx,%edx
    1457:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    145c:	e8 fc ff ff ff       	call   145d <fsm_core_open+0x15d>
	spin_unlock_irqrestore(&fsm_core.lock, flags);
	fsm_printf("core has opened.\n");
    1461:	c7 04 24 1d 00 00 00 	movl   $0x1d,(%esp)
    1468:	e8 fc ff ff ff       	call   1469 <fsm_core_open+0x169>
	}
	return FSM_EXEC_SUCC;
}
    146d:	83 c4 10             	add    $0x10,%esp
    1470:	31 c0                	xor    %eax,%eax
    1472:	5b                   	pop    %ebx
    1473:	5d                   	pop    %ebp
    1474:	c3                   	ret    
    1475:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001480 <fsm_core_close>:

int fsm_core_close()
{
    1480:	55                   	push   %ebp
    1481:	89 e5                	mov    %esp,%ebp
    1483:	57                   	push   %edi
    1484:	56                   	push   %esi
    1485:	53                   	push   %ebx
    1486:	83 ec 10             	sub    $0x10,%esp
    1489:	e8 fc ff ff ff       	call   148a <fsm_core_close+0xa>
	struct evioctl *ev_ptr, *tmp_ptr;
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
    148e:	a1 28 00 00 00       	mov    0x28,%eax
    1493:	85 c0                	test   %eax,%eax
    1495:	75 11                	jne    14a8 <fsm_core_close+0x28>
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    1497:	83 c4 10             	add    $0x10,%esp
    149a:	31 c0                	xor    %eax,%eax
    149c:	5b                   	pop    %ebx
    149d:	5e                   	pop    %esi
    149e:	5f                   	pop    %edi
    149f:	5d                   	pop    %ebp
    14a0:	c3                   	ret    
    14a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	struct tmev *tmev_ptr, *tmev_tmp_ptr;
	int i;
	unsigned long flags, flags2;
	if(fsm_core.state == CORE_CLOSED)
		return FSM_EXEC_SUCC;
	spin_lock_irqsave(&fsm_core.lock, flags2);
    14a8:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    14ad:	e8 fc ff ff ff       	call   14ae <fsm_core_close+0x2e>
    14b2:	89 c7                	mov    %eax,%edi
	fsm_printf("core is closing.\n");
    14b4:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
    14bb:	e8 fc ff ff ff       	call   14bc <fsm_core_close+0x3c>
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    14c0:	a1 8c 02 00 00       	mov    0x28c,%eax
    14c5:	31 c9                	xor    %ecx,%ecx
    14c7:	ba 01 00 00 00       	mov    $0x1,%edx
    14cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    14d0:	b8 05 00 00 00       	mov    $0x5,%eax
    14d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    14dc:	00 
    14dd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    14e4:	00 
    14e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    14ec:	e8 3f ef ff ff       	call   430 <__fsm_core_self_drive>
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
	hrtimer_try_to_cancel(&pB->timer);
    14f1:	b8 48 02 00 00       	mov    $0x248,%eax
}
static void __fsm_tm_stop()
{
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	pB->tm_state = FSM_TM_STOP;
    14f6:	c7 05 44 02 00 00 00 	movl   $0x0,0x244
    14fd:	00 00 00 
	hrtimer_try_to_cancel(&pB->timer);
    1500:	e8 fc ff ff ff       	call   1501 <fsm_core_close+0x81>
{
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
    1505:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    150a:	e8 fc ff ff ff       	call   150b <fsm_core_close+0x8b>
    150f:	89 c3                	mov    %eax,%ebx
	while(pB->evQ)
    1511:	a1 88 02 00 00       	mov    0x288,%eax
    1516:	85 c0                	test   %eax,%eax
    1518:	74 1c                	je     1536 <fsm_core_close+0xb6>
    151a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		pE = pB->evQ;
		pB->evQ = pE->pNext;
    1520:	8b 10                	mov    (%eax),%edx
    1522:	89 15 88 02 00 00    	mov    %edx,0x288
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1528:	e8 fc ff ff ff       	call   1529 <fsm_core_close+0xa9>
	__tmEvent* pE;
	__tmBlock* pB;
	pB = TMBLOCK_PTR;
	unsigned long flags;
	spin_lock_irqsave(&fsm_core.tmev_list_lock, flags);
	while(pB->evQ)
    152d:	a1 88 02 00 00       	mov    0x288,%eax
    1532:	85 c0                	test   %eax,%eax
    1534:	75 ea                	jne    1520 <fsm_core_close+0xa0>
    1536:	89 da                	mov    %ebx,%edx
    1538:	b8 e8 02 00 00       	mov    $0x2e8,%eax
    153d:	e8 fc ff ff ff       	call   153e <fsm_core_close+0xbe>
	fsm_printf("core is closing.\n");
	__fsm_core_self_drive(FSM_EV_TYPE_CORE,FSM_EV_CORE_CLOSE,NULL,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
	__fsm_tm_stop();
	__fsm_tm_flush();
	//Cancel tasklets
	tasklet_kill(fsm_core.tx_tsklt);
    1542:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1547:	e8 fc ff ff ff       	call   1548 <fsm_core_close+0xc8>
	tasklet_kill(fsm_core.rx_tsklt);
    154c:	a1 c4 02 00 00       	mov    0x2c4,%eax
    1551:	e8 fc ff ff ff       	call   1552 <fsm_core_close+0xd2>
	tasklet_kill(fsm_core.do_ioctl_tsklt);
    1556:	a1 c8 02 00 00       	mov    0x2c8,%eax
    155b:	e8 fc ff ff ff       	call   155c <fsm_core_close+0xdc>
	tasklet_kill(fsm_core.exp_ev_tsklt);	
    1560:	a1 cc 02 00 00       	mov    0x2cc,%eax
    1565:	e8 fc ff ff ff       	call   1566 <fsm_core_close+0xe6>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    156a:	a1 b8 02 00 00       	mov    0x2b8,%eax
    156f:	3b 00                	cmp    (%eax),%eax
    1571:	74 2f                	je     15a2 <fsm_core_close+0x122>
    1573:	90                   	nop
    1574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
    1578:	e8 fc ff ff ff       	call   1579 <fsm_core_close+0xf9>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    157d:	e8 fc ff ff ff       	call   157e <fsm_core_close+0xfe>
	tasklet_kill(fsm_core.tx_tsklt);
	tasklet_kill(fsm_core.rx_tsklt);
	tasklet_kill(fsm_core.do_ioctl_tsklt);
	tasklet_kill(fsm_core.exp_ev_tsklt);	
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
    1582:	a1 b8 02 00 00       	mov    0x2b8,%eax
    1587:	3b 00                	cmp    (%eax),%eax
    1589:	75 ed                	jne    1578 <fsm_core_close+0xf8>
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    158b:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1590:	3b 00                	cmp    (%eax),%eax
    1592:	74 17                	je     15ab <fsm_core_close+0x12b>
    1594:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
    1598:	e8 fc ff ff ff       	call   1599 <fsm_core_close+0x119>
	return pkptr_new;
}

void fsm_pkt_destroy(FSM_PKT* pkptr)
{
	KFREE_SKB(pkptr);
    159d:	e8 fc ff ff ff       	call   159e <fsm_core_close+0x11e>
	//Flush queues;
	while(!skb_queue_empty(fsm_core.tx_queue))
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.tx_queue));
	}
	while(!skb_queue_empty(fsm_core.rx_queue))
    15a2:	a1 bc 02 00 00       	mov    0x2bc,%eax
    15a7:	3b 00                	cmp    (%eax),%eax
    15a9:	75 ed                	jne    1598 <fsm_core_close+0x118>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    15ab:	8b 1d d4 02 00 00    	mov    0x2d4,%ebx
	{
	fsm_pkt_destroy(skb_dequeue(fsm_core.rx_queue));
	}
	if(!list_empty(&fsm_core.do_ioctl_list))
    15b1:	81 fb d4 02 00 00    	cmp    $0x2d4,%ebx
    15b7:	74 6b                	je     1624 <fsm_core_close+0x1a4>
	{
		list_for_each_entry_safe(ev_ptr, tmp_ptr, &fsm_core.do_ioctl_list, list_node)
    15b9:	8b 33                	mov    (%ebx),%esi
    15bb:	83 eb 10             	sub    $0x10,%ebx
    15be:	83 ee 10             	sub    $0x10,%esi
    15c1:	eb 17                	jmp    15da <fsm_core_close+0x15a>
    15c3:	90                   	nop
    15c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    15c8:	8b 46 10             	mov    0x10(%esi),%eax
    15cb:	83 e8 10             	sub    $0x10,%eax
    15ce:	81 fe c4 02 00 00    	cmp    $0x2c4,%esi
    15d4:	74 4e                	je     1624 <fsm_core_close+0x1a4>
    15d6:	89 f3                	mov    %esi,%ebx
    15d8:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
    15da:	b8 e4 02 00 00       	mov    $0x2e4,%eax
    15df:	e8 fc ff ff ff       	call   15e0 <fsm_core_close+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    15e4:	8b 4b 14             	mov    0x14(%ebx),%ecx
    15e7:	89 c2                	mov    %eax,%edx
    15e9:	8b 43 10             	mov    0x10(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    15ec:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    15ef:	89 01                	mov    %eax,(%ecx)
    15f1:	b8 e4 02 00 00       	mov    $0x2e4,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    15f6:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    15fd:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    1604:	e8 fc ff ff ff       	call   1605 <fsm_core_close+0x185>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1609:	8b 43 0c             	mov    0xc(%ebx),%eax
    160c:	e8 fc ff ff ff       	call   160d <fsm_core_close+0x18d>
    1611:	89 d8                	mov    %ebx,%eax
    1613:	e8 fc ff ff ff       	call   1614 <fsm_core_close+0x194>
			spin_lock_irqsave(&fsm_core.ioctl_list_lock, flags);
			list_del(&ev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
			fsm_mem_free(ev_ptr->ifr.buffer);
			fsm_mem_free(ev_ptr);
			if(list_empty(&fsm_core.do_ioctl_list))
    1618:	81 3d d4 02 00 00 d4 	cmpl   $0x2d4,0x2d4
    161f:	02 00 00 
    1622:	75 a4                	jne    15c8 <fsm_core_close+0x148>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1624:	8b 1d dc 02 00 00    	mov    0x2dc,%ebx
				break;
		}
	}
	if(!list_empty(&fsm_core.exp_ev_list))
    162a:	81 fb dc 02 00 00    	cmp    $0x2dc,%ebx
    1630:	74 69                	je     169b <fsm_core_close+0x21b>
	{
		list_for_each_entry_safe(tmev_ptr, tmev_tmp_ptr, &fsm_core.exp_ev_list, list_node)
    1632:	8b 33                	mov    (%ebx),%esi
    1634:	83 eb 04             	sub    $0x4,%ebx
    1637:	83 ee 04             	sub    $0x4,%esi
    163a:	eb 16                	jmp    1652 <fsm_core_close+0x1d2>
    163c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1640:	8b 46 04             	mov    0x4(%esi),%eax
    1643:	83 e8 04             	sub    $0x4,%eax
    1646:	81 fe d8 02 00 00    	cmp    $0x2d8,%esi
    164c:	74 4d                	je     169b <fsm_core_close+0x21b>
    164e:	89 f3                	mov    %esi,%ebx
    1650:	89 c6                	mov    %eax,%esi
		{
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
    1652:	b8 e6 02 00 00       	mov    $0x2e6,%eax
    1657:	e8 fc ff ff ff       	call   1658 <fsm_core_close+0x1d8>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    165c:	8b 4b 08             	mov    0x8(%ebx),%ecx
    165f:	89 c2                	mov    %eax,%edx
    1661:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1664:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = next;
    1667:	89 01                	mov    %eax,(%ecx)
    1669:	b8 e6 02 00 00       	mov    $0x2e6,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    166e:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    1675:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    167c:	e8 fc ff ff ff       	call   167d <fsm_core_close+0x1fd>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1681:	8b 03                	mov    (%ebx),%eax
    1683:	e8 fc ff ff ff       	call   1684 <fsm_core_close+0x204>
    1688:	89 d8                	mov    %ebx,%eax
    168a:	e8 fc ff ff ff       	call   168b <fsm_core_close+0x20b>
			spin_lock_irqsave(&fsm_core.expev_list_lock, flags);
			list_del(&tmev_ptr->list_node);
			spin_unlock_irqrestore(&fsm_core.expev_list_lock, flags);
			fsm_mem_free(tmev_ptr->pE);
			fsm_mem_free(tmev_ptr);
			if(list_empty(&fsm_core.exp_ev_list))
    168f:	81 3d dc 02 00 00 dc 	cmpl   $0x2dc,0x2dc
    1696:	02 00 00 
    1699:	75 a5                	jne    1640 <fsm_core_close+0x1c0>
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
    169b:	c7 05 28 00 00 00 00 	movl   $0x0,0x28
    16a2:	00 00 00 
    16a5:	b8 4c 00 00 00       	mov    $0x4c,%eax
    16aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	for(i = 0; i < MAX_INTF; i++)
	{
		if(INTF[i].dev)
    16b0:	8b 10                	mov    (%eax),%edx
    16b2:	85 d2                	test   %edx,%edx
    16b4:	74 09                	je     16bf <fsm_core_close+0x23f>
		list_del(&ev_ptr->list_node);
		spin_unlock_irqrestore(&fsm_core.ioctl_list_lock, flags);
		//fsm_mem_free(ev_ptr->ifr.buffer);
		fsm_mem_free(ev_ptr);
	}
}
    16b6:	8b 92 98 02 00 00    	mov    0x298(%edx),%edx
 *
 * Release reference to device to allow it to be freed.
 */
static inline void dev_put(struct net_device *dev)
{
	this_cpu_dec(*dev->pcpu_refcnt);
    16bc:	64 ff 0a             	decl   %fs:(%edx)
    16bf:	83 c0 10             	add    $0x10,%eax
			if(list_empty(&fsm_core.exp_ev_list))
				break;
		}
	}	
	fsm_core.state = CORE_CLOSED;
	for(i = 0; i < MAX_INTF; i++)
    16c2:	3d 4c 02 00 00       	cmp    $0x24c,%eax
    16c7:	75 e7                	jne    16b0 <fsm_core_close+0x230>
    16c9:	b8 44 00 00 00       	mov    $0x44,%eax
    16ce:	66 90                	xchg   %ax,%ax
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
	{
		INTF[i].valid = 0;
    16d0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		INTF[i].proto = 0;
    16d6:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
		INTF[i].dev	= 0;
    16dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		INTF[i].send = __fsm_skb_send_null;
    16e3:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
    16ea:	83 c0 10             	add    $0x10,%eax
		if(INTF[i].dev)
		{
			dev_put(INTF[i].dev);
		}	
	}
	for(i = 0; i < MAX_INTF; i++)
    16ed:	3d 44 02 00 00       	cmp    $0x244,%eax
    16f2:	75 dc                	jne    16d0 <fsm_core_close+0x250>
		INTF[i].valid = 0;
		INTF[i].proto = 0;
		INTF[i].dev	= 0;
		INTF[i].send = __fsm_skb_send_null;
	}
	fsm_printf("core has closed.\n");
    16f4:	c7 04 24 41 00 00 00 	movl   $0x41,(%esp)
    16fb:	e8 fc ff ff ff       	call   16fc <fsm_core_close+0x27c>
    1700:	89 fa                	mov    %edi,%edx
    1702:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1707:	e8 fc ff ff ff       	call   1708 <fsm_core_close+0x288>
	spin_unlock_irqrestore(&fsm_core.lock , flags2);
	return FSM_EXEC_SUCC;
}
    170c:	31 c0                	xor    %eax,%eax
    170e:	83 c4 10             	add    $0x10,%esp
    1711:	5b                   	pop    %ebx
    1712:	5e                   	pop    %esi
    1713:	5f                   	pop    %edi
    1714:	5d                   	pop    %ebp
    1715:	c3                   	ret    
    1716:	8d 76 00             	lea    0x0(%esi),%esi
    1719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001720 <fsm_core_pkt_drive>:



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1720:	55                   	push   %ebp
    1721:	89 e5                	mov    %esp,%ebp
    1723:	83 ec 18             	sub    $0x18,%esp
    1726:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    1729:	89 75 fc             	mov    %esi,-0x4(%ebp)
    172c:	e8 fc ff ff ff       	call   172d <fsm_core_pkt_drive+0xd>
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1731:	83 fa 01             	cmp    $0x1,%edx
}



int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
    1734:	89 c6                	mov    %eax,%esi
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
    1736:	74 68                	je     17a0 <fsm_core_pkt_drive+0x80>
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock ,flags2);
	}
	if(type == RXTX_PKT_REQ)
    1738:	85 d2                	test   %edx,%edx
    173a:	74 0c                	je     1748 <fsm_core_pkt_drive+0x28>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    173c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    173f:	31 c0                	xor    %eax,%eax
    1741:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1744:	89 ec                	mov    %ebp,%esp
    1746:	5d                   	pop    %ebp
    1747:	c3                   	ret    
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1748:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    174d:	e8 fc ff ff ff       	call   174e <fsm_core_pkt_drive+0x2e>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1752:	89 f1                	mov    %esi,%ecx
    1754:	31 d2                	xor    %edx,%edx
		if(irqs_disabled())
		{
		fsm_printf("irq is disabled!\n");
		}
		fsm_printf("send packet\n");*/
		spin_lock_irqsave(&fsm_core.lock, flags2);
    1756:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    1758:	a1 8c 02 00 00       	mov    0x28c,%eax
    175d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    1764:	00 
    1765:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    176c:	00 
    176d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    1774:	89 44 24 04          	mov    %eax,0x4(%esp)
    1778:	b8 01 00 00 00       	mov    $0x1,%eax
    177d:	e8 ae ec ff ff       	call   430 <__fsm_core_self_drive>
    1782:	89 da                	mov    %ebx,%edx
    1784:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    1789:	e8 fc ff ff ff       	call   178a <fsm_core_pkt_drive+0x6a>
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    178e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    1791:	31 c0                	xor    %eax,%eax
    1793:	8b 75 fc             	mov    -0x4(%ebp),%esi
    1796:	89 ec                	mov    %ebp,%esp
    1798:	5d                   	pop    %ebp
    1799:	c3                   	ret    
    179a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17a0:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17a5:	e8 fc ff ff ff       	call   17a6 <fsm_core_pkt_drive+0x86>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17aa:	89 f1                	mov    %esi,%ecx
    17ac:	31 d2                	xor    %edx,%edx
int fsm_core_pkt_drive(FSM_PKT* pkptr, u32 type)
{ 
	unsigned long flags2;
	if(type == RXTX_PKT_IND)
	{
		spin_lock_irqsave(&fsm_core.lock, flags2);
    17ae:	89 c3                	mov    %eax,%ebx
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_IND,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
    17b0:	a1 8c 02 00 00       	mov    0x28c,%eax
    17b5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    17bc:	00 
    17bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    17c4:	00 
    17c5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    17cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    17d0:	b8 02 00 00 00       	mov    $0x2,%eax
    17d5:	e8 56 ec ff ff       	call   430 <__fsm_core_self_drive>
    17da:	89 da                	mov    %ebx,%edx
    17dc:	b8 b4 02 00 00       	mov    $0x2b4,%eax
    17e1:	e8 fc ff ff ff       	call   17e2 <fsm_core_pkt_drive+0xc2>
		__fsm_core_self_drive(FSM_EV_TYPE_PKT_REQ,INVALIDE,pkptr,KERNEL_MODULE,MAIN_PORT,NULL,INVALIDE);
		spin_unlock_irqrestore(&fsm_core.lock , flags2);

	}
	return FSM_EXEC_SUCC;
}
    17e6:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    17e9:	31 c0                	xor    %eax,%eax
    17eb:	8b 75 fc             	mov    -0x4(%ebp),%esi
    17ee:	89 ec                	mov    %ebp,%esp
    17f0:	5d                   	pop    %ebp
    17f1:	c3                   	ret    
    17f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    17f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001800 <fsm_create_register>:

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1800:	55                   	push   %ebp
    1801:	89 e5                	mov    %esp,%ebp
    1803:	83 ec 14             	sub    $0x14,%esp
    1806:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    1809:	89 75 f8             	mov    %esi,-0x8(%ebp)
    180c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    180f:	e8 fc ff ff ff       	call   1810 <fsm_create_register+0x10>
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1814:	31 db                	xor    %ebx,%ebx
	return FSM_EXEC_SUCC;
}

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
    1816:	89 c7                	mov    %eax,%edi
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
    1818:	8b 04 9d 90 02 00 00 	mov    0x290(,%ebx,4),%eax
    181f:	85 c0                	test   %eax,%eax
    1821:	74 1d                	je     1840 <fsm_create_register+0x40>

/* FSM operations */
int fsm_create_register(const char* name, void (*fsm_main), void* fsm_sv_ptr)
{
	int i;
	for(i=0; i < MAX_FSM; ++i)
    1823:	83 c3 01             	add    $0x1,%ebx
    1826:	83 fb 06             	cmp    $0x6,%ebx
    1829:	75 ed                	jne    1818 <fsm_create_register+0x18>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
			FSM[i]->_fsm_current_block = 0;
			return i;
			}
		}
	return -1;
    182b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
    1830:	8b 75 f8             	mov    -0x8(%ebp),%esi
    1833:	89 d8                	mov    %ebx,%eax
    1835:	8b 7d fc             	mov    -0x4(%ebp),%edi
    1838:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    183b:	89 ec                	mov    %ebp,%esp
    183d:	5d                   	pop    %ebp
    183e:	c3                   	ret    
    183f:	90                   	nop
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1840:	b8 90 00 00 00       	mov    $0x90,%eax
    1845:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    1848:	8d b3 9c 00 00 00    	lea    0x9c(%ebx),%esi
    184e:	89 55 ec             	mov    %edx,-0x14(%ebp)
    1851:	e8 fc ff ff ff       	call   1852 <fsm_create_register+0x52>
			FSM[i]->fsm_main = fsm_main;
    1856:	8b 55 ec             	mov    -0x14(%ebp),%edx
	int i;
	for(i=0; i < MAX_FSM; ++i)
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
    1859:	89 04 b5 20 00 00 00 	mov    %eax,0x20(,%esi,4)
			FSM[i]->fsm_main = fsm_main;
    1860:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
			FSM[i]->id = i;
    1866:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
			strcpy(FSM[i]->name, name);
    186d:	89 fa                	mov    %edi,%edx
		{
		if(FSM[i] == NULL)
			{
			FSM[i] = (FSM_SPEC*)fsm_mem_alloc(sizeof(FSM_SPEC));
			FSM[i]->fsm_main = fsm_main;
			FSM[i]->id = i;
    186f:	89 98 80 00 00 00    	mov    %ebx,0x80(%eax)
			strcpy(FSM[i]->name, name);
    1875:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    187c:	e8 fc ff ff ff       	call   187d <fsm_create_register+0x7d>
			FSM[i]->fsm_sv_ptr = fsm_sv_ptr;
    1881:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1888:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    188b:	89 88 88 00 00 00    	mov    %ecx,0x88(%eax)
			FSM[i]->_fsm_current_block = 0;
    1891:	8b 04 b5 20 00 00 00 	mov    0x20(,%esi,4),%eax
    1898:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
    189f:	00 00 00 
			return i;
			}
		}
	return -1;
}
    18a2:	89 d8                	mov    %ebx,%eax
    18a4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    18a7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    18aa:	8b 7d fc             	mov    -0x4(%ebp),%edi
    18ad:	89 ec                	mov    %ebp,%esp
    18af:	5d                   	pop    %ebp
    18b0:	c3                   	ret    
    18b1:	eb 0d                	jmp    18c0 <fsm_unregister_destroy>
    18b3:	90                   	nop
    18b4:	90                   	nop
    18b5:	90                   	nop
    18b6:	90                   	nop
    18b7:	90                   	nop
    18b8:	90                   	nop
    18b9:	90                   	nop
    18ba:	90                   	nop
    18bb:	90                   	nop
    18bc:	90                   	nop
    18bd:	90                   	nop
    18be:	90                   	nop
    18bf:	90                   	nop

000018c0 <fsm_unregister_destroy>:

void fsm_unregister_destroy(int id)
{
    18c0:	55                   	push   %ebp
    18c1:	89 e5                	mov    %esp,%ebp
    18c3:	53                   	push   %ebx
    18c4:	e8 fc ff ff ff       	call   18c5 <fsm_unregister_destroy+0x5>
	if(FSM[id]!=NULL)
    18c9:	8d 98 9c 00 00 00    	lea    0x9c(%eax),%ebx
    18cf:	8b 04 9d 20 00 00 00 	mov    0x20(,%ebx,4),%eax
    18d6:	85 c0                	test   %eax,%eax
    18d8:	74 10                	je     18ea <fsm_unregister_destroy+0x2a>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    18da:	e8 fc ff ff ff       	call   18db <fsm_unregister_destroy+0x1b>
void fsm_unregister_destroy(int id)
{
	if(FSM[id]!=NULL)
	{
		fsm_mem_free(FSM[id]);
		FSM[id] = NULL;
    18df:	c7 04 9d 20 00 00 00 	movl   $0x0,0x20(,%ebx,4)
    18e6:	00 00 00 00 
	}
}
    18ea:	5b                   	pop    %ebx
    18eb:	5d                   	pop    %ebp
    18ec:	c3                   	ret    
    18ed:	8d 76 00             	lea    0x0(%esi),%esi

000018f0 <fsm_core_destroy>:
	return; 
}

		
void fsm_core_destroy()
{
    18f0:	55                   	push   %ebp
    18f1:	89 e5                	mov    %esp,%ebp
    18f3:	53                   	push   %ebx
    18f4:	e8 fc ff ff ff       	call   18f5 <fsm_core_destroy+0x5>
	int i;
	if(fsm_core.state != CORE_CLOSED)
    18f9:	a1 28 00 00 00       	mov    0x28,%eax
    18fe:	85 c0                	test   %eax,%eax
    1900:	75 56                	jne    1958 <fsm_core_destroy+0x68>
	return; 
}

		
void fsm_core_destroy()
{
    1902:	31 db                	xor    %ebx,%ebx
    1904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
	{
		fsm_unregister_destroy(i);
    1908:	89 d8                	mov    %ebx,%eax
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    190a:	83 c3 01             	add    $0x1,%ebx
	{
		fsm_unregister_destroy(i);
    190d:	e8 fc ff ff ff       	call   190e <fsm_core_destroy+0x1e>
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
	for(i = 0; i < MAX_FSM; i++)
    1912:	83 fb 06             	cmp    $0x6,%ebx
    1915:	75 f1                	jne    1908 <fsm_core_destroy+0x18>
	return ptr;
}

void fsm_mem_free(void* ptr)
{
	FSM_MEM_FREE(ptr);
    1917:	a1 b8 02 00 00       	mov    0x2b8,%eax
    191c:	e8 fc ff ff ff       	call   191d <fsm_core_destroy+0x2d>
    1921:	a1 bc 02 00 00       	mov    0x2bc,%eax
    1926:	e8 fc ff ff ff       	call   1927 <fsm_core_destroy+0x37>
    192b:	a1 c0 02 00 00       	mov    0x2c0,%eax
    1930:	e8 fc ff ff ff       	call   1931 <fsm_core_destroy+0x41>
    1935:	a1 c4 02 00 00       	mov    0x2c4,%eax
    193a:	e8 fc ff ff ff       	call   193b <fsm_core_destroy+0x4b>
    193f:	a1 c8 02 00 00       	mov    0x2c8,%eax
    1944:	e8 fc ff ff ff       	call   1945 <fsm_core_destroy+0x55>
    1949:	a1 cc 02 00 00       	mov    0x2cc,%eax
    194e:	e8 fc ff ff ff       	call   194f <fsm_core_destroy+0x5f>
	fsm_mem_free(fsm_core.tx_tsklt);
	fsm_mem_free(fsm_core.rx_tsklt);
	fsm_mem_free(fsm_core.do_ioctl_tsklt);
	fsm_mem_free(fsm_core.exp_ev_tsklt);
	return;
}
    1953:	5b                   	pop    %ebx
    1954:	5d                   	pop    %ebp
    1955:	c3                   	ret    
    1956:	66 90                	xchg   %ax,%ax
		
void fsm_core_destroy()
{
	int i;
	if(fsm_core.state != CORE_CLOSED)
		fsm_core_close();
    1958:	e8 fc ff ff ff       	call   1959 <fsm_core_destroy+0x69>
    195d:	8d 76 00             	lea    0x0(%esi),%esi
    1960:	eb a0                	jmp    1902 <fsm_core_destroy+0x12>
    1962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1969:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001970 <fsm_mainport_bind>:
		FSM[id] = NULL;
	}
}

void fsm_mainport_bind(int id)
{
    1970:	55                   	push   %ebp
    1971:	89 e5                	mov    %esp,%ebp
    1973:	e8 fc ff ff ff       	call   1974 <fsm_mainport_bind+0x4>
	fsm_core.main_port = id;
}
    1978:	5d                   	pop    %ebp
	}
}

void fsm_mainport_bind(int id)
{
	fsm_core.main_port = id;
    1979:	a3 8c 02 00 00       	mov    %eax,0x28c
}
    197e:	c3                   	ret    
    197f:	90                   	nop

00001980 <__fsm_dev_set_config>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_set_config(struct net_device *dev, struct ifmap *p_ifmap)
{
    1980:	55                   	push   %ebp
    1981:	89 e5                	mov    %esp,%ebp
    1983:	e8 fc ff ff ff       	call   1984 <__fsm_dev_set_config+0x4>
    	return 0;
}
    1988:	31 c0                	xor    %eax,%eax
    198a:	5d                   	pop    %ebp
    198b:	c3                   	ret    
    198c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001990 <__fsm_dev_get_stats>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    1990:	55                   	push   %ebp
    1991:	89 e5                	mov    %esp,%ebp
    1993:	e8 fc ff ff ff       	call   1994 <__fsm_dev_get_stats+0x4>
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
}
    1998:	5d                   	pop    %ebp
 ******************************************************************************/
struct net_device_stats* __fsm_dev_get_stats(struct net_device *dev)
{
    fsm_priv* priv;
    priv = (fsm_priv*)netdev_priv(dev);
    return &(priv->stats);            
    1999:	05 c0 04 00 00       	add    $0x4c0,%eax
}
    199e:	c3                   	ret    
    199f:	90                   	nop

000019a0 <__fsm_dev_tx_timeout>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_tx_timeout(struct net_device *dev)
{  
    19a0:	55                   	push   %ebp
    19a1:	89 e5                	mov    %esp,%ebp
    19a3:	e8 fc ff ff ff       	call   19a4 <__fsm_dev_tx_timeout+0x4>
    return;   
}
    19a8:	5d                   	pop    %ebp
    19a9:	c3                   	ret    
    19aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

000019b0 <__fsm_dev_ioctl>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	e8 fc ff ff ff       	call   19b4 <__fsm_dev_ioctl+0x4>
    19b8:	89 d0                	mov    %edx,%eax
    19ba:	89 ca                	mov    %ecx,%edx
	fsm_ioctrl_arrival(ifr,cmd);
    19bc:	e8 fc ff ff ff       	call   19bd <__fsm_dev_ioctl+0xd>
	return 0;
}
    19c1:	31 c0                	xor    %eax,%eax
    19c3:	5d                   	pop    %ebp
    19c4:	c3                   	ret    
    19c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    19c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019d0 <__fsm_dev_tx>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_tx(struct sk_buff *skb, struct net_device *dev)
{ 
    19d0:	55                   	push   %ebp
    19d1:	89 e5                	mov    %esp,%ebp
    19d3:	e8 fc ff ff ff       	call   19d4 <__fsm_dev_tx+0x4>
	fsm_core_pkt_drive(skb, RXTX_PKT_REQ);	
    19d8:	31 d2                	xor    %edx,%edx
    19da:	e8 fc ff ff ff       	call   19db <__fsm_dev_tx+0xb>
   	return 0;    
}	
    19df:	31 c0                	xor    %eax,%eax
    19e1:	5d                   	pop    %ebp
    19e2:	c3                   	ret    
    19e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    19e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000019f0 <__fsm_dev_recv>:
 **-------------------------------------- ------system--------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_recv(struct sk_buff *skb ,struct net_device *dev1, struct packet_type *pktype, struct net_device *dev2)
{  
    19f0:	55                   	push   %ebp
    19f1:	89 e5                	mov    %esp,%ebp
    19f3:	e8 fc ff ff ff       	call   19f4 <__fsm_dev_recv+0x4>
    	fsm_core_pkt_drive(skb, RXTX_PKT_IND);
    19f8:	ba 01 00 00 00       	mov    $0x1,%edx
    19fd:	e8 fc ff ff ff       	call   19fe <__fsm_dev_recv+0xe>
    	return 0;            
}
    1a02:	31 c0                	xor    %eax,%eax
    1a04:	5d                   	pop    %ebp
    1a05:	c3                   	ret    
    1a06:	8d 76 00             	lea    0x0(%esi),%esi
    1a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00001a10 <__fsm_dev_open>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a10:	55                   	push   %ebp
    1a11:	89 e5                	mov    %esp,%ebp
    1a13:	53                   	push   %ebx
    1a14:	83 ec 04             	sub    $0x4,%esp
    1a17:	e8 fc ff ff ff       	call   1a18 <__fsm_dev_open+0x8>
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a1c:	b9 f3 f4 00 00       	mov    $0xf4f3,%ecx
    1a21:	ba 02 00 00 00       	mov    $0x2,%edx
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_open(struct net_device *dev)
{
    1a26:	89 c3                	mov    %eax,%ebx
    /*-----------------now we need to register the special protocol_type */
	fsm_core_intf_set(STRM_TO_RRC, DEV_INTF_IND, DEV_PROTO_RRC, "LTE_RRC0");
    1a28:	b8 05 00 00 00       	mov    $0x5,%eax
    1a2d:	c7 04 24 53 00 00 00 	movl   $0x53,(%esp)
    1a34:	e8 fc ff ff ff       	call   1a35 <__fsm_dev_open+0x25>
	fsm_core_intf_set(STRM_TO_IPADP, DEV_INTF_IND, DEV_PROTO_IPADP, "LTE_IPADP0");
    1a39:	b9 f0 f4 00 00       	mov    $0xf4f0,%ecx
    1a3e:	ba 02 00 00 00       	mov    $0x2,%edx
    1a43:	b8 07 00 00 00       	mov    $0x7,%eax
    1a48:	c7 04 24 5c 00 00 00 	movl   $0x5c,(%esp)
    1a4f:	e8 fc ff ff ff       	call   1a50 <__fsm_dev_open+0x40>
	fsm_core_intf_set(STRM_TO_PDCP, DEV_INTF_IND, DEV_PROTO_PDCP, "LTE_PDCP0");
    1a54:	b9 f1 f4 00 00       	mov    $0xf4f1,%ecx
    1a59:	ba 02 00 00 00       	mov    $0x2,%edx
    1a5e:	b8 06 00 00 00       	mov    $0x6,%eax
    1a63:	c7 04 24 67 00 00 00 	movl   $0x67,(%esp)
    1a6a:	e8 fc ff ff ff       	call   1a6b <__fsm_dev_open+0x5b>
	//fsm_core_intf_set(STRM_TO_RLC, DEV_INTF_IND, DEV_PROTO_RLC, "LTE_RLC0");
	fsm_core_intf_set(STRM_TO_SRIO, DEV_INTF_REQ, DEV_PROTO_RLC_MAC, "LTE_SRIO0");
    1a6f:	b9 f8 f4 00 00       	mov    $0xf4f8,%ecx
    1a74:	ba 01 00 00 00       	mov    $0x1,%edx
    1a79:	b8 03 00 00 00       	mov    $0x3,%eax
    1a7e:	c7 04 24 71 00 00 00 	movl   $0x71,(%esp)
    1a85:	e8 fc ff ff ff       	call   1a86 <__fsm_dev_open+0x76>
    	dev_add_pack(&pk_t); 
    1a8a:	b8 00 00 00 00       	mov    $0x0,%eax
    1a8f:	e8 fc ff ff ff       	call   1a90 <__fsm_dev_open+0x80>
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
			: CONST_MASK_ADDR(nr, addr)
    1a94:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
 */
static __always_inline void
clear_bit(int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "andb %1,%0"
    1a9a:	f0 80 60 50 fe       	lock andb $0xfe,0x50(%eax)
	netif_start_queue(dev);   
    	fsm_core_open();	 
    1a9f:	e8 fc ff ff ff       	call   1aa0 <__fsm_dev_open+0x90>
    	return 0;    
}
    1aa4:	31 c0                	xor    %eax,%eax
    1aa6:	83 c4 04             	add    $0x4,%esp
    1aa9:	5b                   	pop    %ebx
    1aaa:	5d                   	pop    %ebp
    1aab:	c3                   	ret    
    1aac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001ab0 <dev_init>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1ab0:	55                   	push   %ebp
    1ab1:	89 e5                	mov    %esp,%ebp
    1ab3:	53                   	push   %ebx
    1ab4:	83 ec 08             	sub    $0x8,%esp
    1ab7:	e8 fc ff ff ff       	call   1ab8 <dev_init+0x8>
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1abc:	85 c0                	test   %eax,%eax
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
    1abe:	89 c3                	mov    %eax,%ebx
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1ac0:	0f 84 af 00 00 00    	je     1b75 <dev_init+0xc5>
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ac6:	83 88 a4 00 00 00 04 	orl    $0x4,0xa4(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1acd:	b9 60 00 00 00       	mov    $0x60,%ecx
    	dev->addr_len = 0;
    	dev->hard_header_len = 0;
	dev->netdev_ops = &fsm_netdev_ops;
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    1ad2:	83 88 a8 00 00 00 00 	orl    $0x0,0xa8(%eax)
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1ad9:	31 d2                	xor    %edx,%edx
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    	dev->tx_queue_len = 128;   	/* the queue length */   
    1adb:	c7 80 50 02 00 00 80 	movl   $0x80,0x250(%eax)
    1ae2:	00 00 00 
    	dev->mtu = MTU;		/* now we do not fragmentate the packet */
    1ae5:	c7 80 50 01 00 00 dc 	movl   $0x5dc,0x150(%eax)
    1aec:	05 00 00 
   	dev->header_ops = NULL;   	/* cancle eth_header function for not building ethnet mac header */ 
    1aef:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%eax)
    1af6:	00 00 00 
    	dev->addr_len = 0;
    1af9:	c6 80 7d 01 00 00 00 	movb   $0x0,0x17d(%eax)
    	dev->hard_header_len = 0;
    1b00:	66 c7 80 56 01 00 00 	movw   $0x0,0x156(%eax)
    1b07:	00 00 
	dev->netdev_ops = &fsm_netdev_ops;
    1b09:	c7 80 34 01 00 00 20 	movl   $0x20,0x134(%eax)
    1b10:	00 00 00 
   	dev->watchdog_timeo = 1000;  				/* the time unit is jiffy */
    1b13:	c7 80 60 02 00 00 e8 	movl   $0x3e8,0x260(%eax)
    1b1a:	03 00 00 
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    1b1d:	c7 80 40 01 00 00 82 	movl   $0x1082,0x140(%eax)
    1b24:	10 00 00 
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
    1b27:	8d 80 c0 04 00 00    	lea    0x4c0(%eax),%eax
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
    1b2d:	e8 fc ff ff ff       	call   1b2e <dev_init+0x7e>
	fsm_core_create(dev);
    1b32:	89 d8                	mov    %ebx,%eax
    1b34:	e8 fc ff ff ff       	call   1b35 <dev_init+0x85>
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b39:	b8 ac 5a 00 00       	mov    $0x5aac,%eax
    1b3e:	e8 fc ff ff ff       	call   1b3f <dev_init+0x8f>
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b43:	b9 ac 5a 00 00       	mov    $0x5aac,%ecx
    1b48:	31 d2                	xor    %edx,%edx
   	dev->flags = IFF_BROADCAST | IFF_MULTICAST | IFF_NOARP;
    	dev->features |= 4;//NETIF_F_NO_CSUM;
    	priv = (fsm_priv*)netdev_priv(dev);
   	fsm_mem_set(priv,0,sizeof(fsm_priv));
	fsm_core_create(dev);
	priv->sv_ptr = fsm_mem_alloc(sizeof(SV_TYPE_NAME));
    1b4a:	89 83 1c 05 00 00    	mov    %eax,0x51c(%ebx)
	fsm_mem_set(priv->sv_ptr, 0, sizeof(SV_TYPE_NAME));
    1b50:	e8 fc ff ff ff       	call   1b51 <dev_init+0xa1>
/*-----------------------------------FSM creation---------------------------*/
	fsm_id = fsm_create_register("lte_rlc_mac_fsm", rlc_mac_main, priv->sv_ptr);
    1b55:	8b 8b 1c 05 00 00    	mov    0x51c(%ebx),%ecx
    1b5b:	ba 00 00 00 00       	mov    $0x0,%edx
    1b60:	b8 7b 00 00 00       	mov    $0x7b,%eax
    1b65:	e8 fc ff ff ff       	call   1b66 <dev_init+0xb6>
	fsm_mainport_bind(fsm_id);
    1b6a:	e8 fc ff ff ff       	call   1b6b <dev_init+0xbb>
/*--------------------------------------------------------------------------*/
    return;
}
    1b6f:	83 c4 08             	add    $0x8,%esp
    1b72:	5b                   	pop    %ebx
    1b73:	5d                   	pop    %ebp
    1b74:	c3                   	ret    
 ******************************************************************************/
void dev_init(struct net_device *dev)
{
   	fsm_priv* priv;
	int fsm_id;
   	ASSERT(dev);
    1b75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1b7c:	00 
    1b7d:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
    1b84:	e8 fc ff ff ff       	call   1b85 <dev_init+0xd5>
    1b89:	e8 fc ff ff ff       	call   1b8a <dev_init+0xda>
    1b8e:	eb df                	jmp    1b6f <dev_init+0xbf>

00001b90 <__fsm_dev_stop>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_stop(struct net_device *dev)
{  
    1b90:	55                   	push   %ebp
    1b91:	89 e5                	mov    %esp,%ebp
    1b93:	53                   	push   %ebx
    1b94:	83 ec 04             	sub    $0x4,%esp
    1b97:	e8 fc ff ff ff       	call   1b98 <__fsm_dev_stop+0x8>
    1b9c:	89 c3                	mov    %eax,%ebx
         
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    1b9e:	e8 fc ff ff ff       	call   1b9f <__fsm_dev_stop+0xf>
    	dev_remove_pack(&pk_t);
    1ba3:	b8 00 00 00 00       	mov    $0x0,%eax
    1ba8:	e8 fc ff ff ff       	call   1ba9 <__fsm_dev_stop+0x19>
{  
    return;   
}

module_init(__fsm_dev_create);
module_exit(__fsm_dev_destroy);
    1bad:	8b 83 40 02 00 00    	mov    0x240(%ebx),%eax
	}
}

static inline void netif_tx_stop_queue(struct netdev_queue *dev_queue)
{
	if (WARN_ON(!dev_queue)) {
    1bb3:	85 c0                	test   %eax,%eax
    1bb5:	74 0d                	je     1bc4 <__fsm_dev_stop+0x34>
 */
static __always_inline void
set_bit(unsigned int nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX "orb %1,%0"
    1bb7:	f0 80 48 50 01       	lock orb $0x1,0x50(%eax)
    /*-----------------now we need to register the special protocol_type */
	fsm_core_close();
    	dev_remove_pack(&pk_t);
    	netif_stop_queue(dev);
     	return 0;    
}
    1bbc:	83 c4 04             	add    $0x4,%esp
    1bbf:	31 c0                	xor    %eax,%eax
    1bc1:	5b                   	pop    %ebx
    1bc2:	5d                   	pop    %ebp
    1bc3:	c3                   	ret    
    1bc4:	ba 50 07 00 00       	mov    $0x750,%edx
    1bc9:	b8 8b 00 00 00       	mov    $0x8b,%eax
    1bce:	e8 fc ff ff ff       	call   1bcf <__fsm_dev_stop+0x3f>
		pr_info("netif_stop_queue() cannot be called before register_netdev()\n");
    1bd3:	c7 04 24 8c 00 00 00 	movl   $0x8c,(%esp)
    1bda:	e8 fc ff ff ff       	call   1bdb <__fsm_dev_stop+0x4b>
    1bdf:	eb db                	jmp    1bbc <__fsm_dev_stop+0x2c>
    1be1:	eb 0d                	jmp    1bf0 <__fsm_dev_create>
    1be3:	90                   	nop
    1be4:	90                   	nop
    1be5:	90                   	nop
    1be6:	90                   	nop
    1be7:	90                   	nop
    1be8:	90                   	nop
    1be9:	90                   	nop
    1bea:	90                   	nop
    1beb:	90                   	nop
    1bec:	90                   	nop
    1bed:	90                   	nop
    1bee:	90                   	nop
    1bef:	90                   	nop

00001bf0 <__fsm_dev_create>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
int __fsm_dev_create(void)
{   
    1bf0:	55                   	push   %ebp
    1bf1:	89 e5                	mov    %esp,%ebp
    1bf3:	53                   	push   %ebx
    1bf4:	83 ec 08             	sub    $0x8,%esp
    1bf7:	e8 fc ff ff ff       	call   1bf8 <__fsm_dev_create+0x8>
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1bfc:	b9 00 00 00 00       	mov    $0x0,%ecx
    1c01:	ba a5 00 00 00       	mov    $0xa5,%edx
    1c06:	b8 60 00 00 00       	mov    $0x60,%eax
    1c0b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
    1c12:	00 
    1c13:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    1c1a:	e8 fc ff ff ff       	call   1c1b <__fsm_dev_create+0x2b>
    if (dev == NULL)   /* allocation error */
    1c1f:	85 c0                	test   %eax,%eax
{   
   	fsm_priv *priv;
	const char  *name = "LTE_RLC_MAC%d";
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    1c21:	89 c3                	mov    %eax,%ebx
    if (dev == NULL)   /* allocation error */
    1c23:	74 41                	je     1c66 <__fsm_dev_create+0x76>
		{
		return -2;
		}
	memcpy(dev->dev_addr, &dev_addr, 6);       
    1c25:	8b 80 d0 01 00 00    	mov    0x1d0(%eax),%eax
    1c2b:	c6 00 00             	movb   $0x0,(%eax)
    1c2e:	c6 40 01 11          	movb   $0x11,0x1(%eax)
    1c32:	c6 40 02 1a          	movb   $0x1a,0x2(%eax)
    1c36:	c6 40 03 1a          	movb   $0x1a,0x3(%eax)
    1c3a:	c6 40 04 8a          	movb   $0x8a,0x4(%eax)
    1c3e:	c6 40 05 42          	movb   $0x42,0x5(%eax)
    if (priv == NULL)
    	{                
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
    1c42:	89 d8                	mov    %ebx,%eax
    1c44:	e8 fc ff ff ff       	call   1c45 <__fsm_dev_create+0x55>
    1c49:	85 c0                	test   %eax,%eax
    1c4b:	75 0b                	jne    1c58 <__fsm_dev_create+0x68>
		{
        free_netdev(dev);   /* release the struct net_device */
        dev = NULL;               
        return -1;
		}
 	return 0;       
    1c4d:	31 c0                	xor    %eax,%eax
}
    1c4f:	83 c4 08             	add    $0x8,%esp
    1c52:	5b                   	pop    %ebx
    1c53:	5d                   	pop    %ebp
    1c54:	c3                   	ret    
    1c55:	8d 76 00             	lea    0x0(%esi),%esi
        return -2;                   
    	}
   	 /* register the net device */    
   	if (register_netdev(dev))    /* register error */
		{
        free_netdev(dev);   /* release the struct net_device */
    1c58:	89 d8                	mov    %ebx,%eax
    1c5a:	e8 fc ff ff ff       	call   1c5b <__fsm_dev_create+0x6b>
        dev = NULL;               
        return -1;
    1c5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1c64:	eb e9                	jmp    1c4f <__fsm_dev_create+0x5f>
	char dev_addr[6] = RLC_MAC_ADDR;
	NETDEV *dev = NULL;
	dev = alloc_netdev(sizeof(fsm_priv), name, dev_init);
    if (dev == NULL)   /* allocation error */
		{
		return -2;
    1c66:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    1c6b:	eb e2                	jmp    1c4f <__fsm_dev_create+0x5f>
    1c6d:	8d 76 00             	lea    0x0(%esi),%esi

00001c70 <__fsm_dev_destroy>:
 **-------------------------------------- --------------------
 ** Modified by:
 ** Modified Date: 
 ******************************************************************************/
void __fsm_dev_destroy(void)
{
    1c70:	55                   	push   %ebp
    1c71:	89 e5                	mov    %esp,%ebp
    1c73:	53                   	push   %ebx
    1c74:	e8 fc ff ff ff       	call   1c75 <__fsm_dev_destroy+0x5>
	NETDEV* dev;
	fsm_priv* priv;
	dev = (NETDEV*)fsm_dev_get();
    1c79:	e8 fc ff ff ff       	call   1c7a <__fsm_dev_destroy+0xa>
    1c7e:	89 c3                	mov    %eax,%ebx
	fsm_core_destroy();
    1c80:	e8 fc ff ff ff       	call   1c81 <__fsm_dev_destroy+0x11>
	priv = netdev_priv(dev);
	fsm_mem_free(priv->sv_ptr);
    1c85:	8b 83 1c 05 00 00    	mov    0x51c(%ebx),%eax
    1c8b:	e8 fc ff ff ff       	call   1c8c <__fsm_dev_destroy+0x1c>
    	unregister_netdev(dev);
    1c90:	89 d8                	mov    %ebx,%eax
    1c92:	e8 fc ff ff ff       	call   1c93 <__fsm_dev_destroy+0x23>
    	free_netdev(dev);
    1c97:	89 d8                	mov    %ebx,%eax
    1c99:	e8 fc ff ff ff       	call   1c9a <__fsm_dev_destroy+0x2a>
}   
    1c9e:	5b                   	pop    %ebx
    1c9f:	5d                   	pop    %ebp
    1ca0:	c3                   	ret    
    1ca1:	90                   	nop
    1ca2:	90                   	nop
    1ca3:	90                   	nop
    1ca4:	90                   	nop
    1ca5:	90                   	nop
    1ca6:	90                   	nop
    1ca7:	90                   	nop
    1ca8:	90                   	nop
    1ca9:	90                   	nop
    1caa:	90                   	nop
    1cab:	90                   	nop
    1cac:	90                   	nop
    1cad:	90                   	nop
    1cae:	90                   	nop
    1caf:	90                   	nop

00001cb0 <findInsByCode>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void * findInsByCode(long code, RlcTimerType * timer)
{
    1cb0:	55                   	push   %ebp
    1cb1:	89 e5                	mov    %esp,%ebp
    1cb3:	57                   	push   %edi
    1cb4:	56                   	push   %esi
    1cb5:	53                   	push   %ebx
    1cb6:	e8 fc ff ff ff       	call   1cb7 <findInsByCode+0x7>
    1cbb:	89 d6                	mov    %edx,%esi
    1cbd:	89 c3                	mov    %eax,%ebx
	struct list_head* pos;
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	
	FIN(findInsByCode());
	SV_PTR_GET(rlc_mac_sv);
    1cbf:	e8 fc ff ff ff       	call   1cc0 <findInsByCode+0x10>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1cc4:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
	/*if( SV(bufferReqTimerCode) == code )
	{
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    1cca:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    1cd0:	39 d1                	cmp    %edx,%ecx
    1cd2:	74 28                	je     1cfc <findInsByCode+0x4c>
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
    1cd4:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cda:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1ce0:	75 14                	jne    1cf6 <findInsByCode+0x46>
    1ce2:	eb 64                	jmp    1d48 <findInsByCode+0x98>
    1ce4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1ce8:	39 9a 48 ef ff ff    	cmp    %ebx,-0x10b8(%edx)
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    1cee:	8d ba 3c ef ff ff    	lea    -0x10c4(%edx),%edi
			if(umRxIns->reorderTimerCode == code)
    1cf4:	74 52                	je     1d48 <findInsByCode+0x98>
		*timer = BUFFER_REQ;
		return NULL;
	}*/
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    1cf6:	8b 12                	mov    (%edx),%edx
    1cf8:	39 d1                	cmp    %edx,%ecx
    1cfa:	75 ec                	jne    1ce8 <findInsByCode+0x38>
    1cfc:	8b 90 f4 25 00 00    	mov    0x25f4(%eax),%edx
				*timer = UM_REORDER;
				return (void*)umRxIns;
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
    1d02:	8d 88 f4 25 00 00    	lea    0x25f4(%eax),%ecx
    1d08:	39 d1                	cmp    %edx,%ecx
    1d0a:	75 1a                	jne    1d26 <findInsByCode+0x76>
    1d0c:	eb 5a                	jmp    1d68 <findInsByCode+0xb8>
    1d0e:	66 90                	xchg   %ax,%ax
			if(amIns->pollRetxTimerCode == code)
			{
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
    1d10:	39 9a 14 dd ff ff    	cmp    %ebx,-0x22ec(%edx)
    1d16:	74 40                	je     1d58 <findInsByCode+0xa8>
			{
				*timer = AM_REORDER;
				return (void*)amIns;
			}
			if(amIns->statProhTimerCode == code)
    1d18:	39 9a 20 dd ff ff    	cmp    %ebx,-0x22e0(%edx)
    1d1e:	74 40                	je     1d60 <findInsByCode+0xb0>
			}
		}
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    1d20:	8b 12                	mov    (%edx),%edx
    1d22:	39 d1                	cmp    %edx,%ecx
    1d24:	74 2a                	je     1d50 <findInsByCode+0xa0>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->pollRetxTimerCode == code)
    1d26:	39 9a 08 dd ff ff    	cmp    %ebx,-0x22f8(%edx)
	}
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    1d2c:	8d ba fc dc ff ff    	lea    -0x2304(%edx),%edi
			if(amIns->pollRetxTimerCode == code)
    1d32:	75 dc                	jne    1d10 <findInsByCode+0x60>
			{
				*timer = POLL_RETX;
    1d34:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
    1d3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	else
	{
		return NULL;
	}
}
    1d40:	5b                   	pop    %ebx
    1d41:	89 f8                	mov    %edi,%eax
    1d43:	5e                   	pop    %esi
    1d44:	5f                   	pop    %edi
    1d45:	5d                   	pop    %ebp
    1d46:	c3                   	ret    
    1d47:	90                   	nop
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->reorderTimerCode == code)
			{
				*timer = UM_REORDER;
    1d48:	c7 06 04 00 00 00    	movl   $0x4,(%esi)
				return (void*)umRxIns;
    1d4e:	eb f0                	jmp    1d40 <findInsByCode+0x90>
	}
	else
	{
		return NULL;
	}
}
    1d50:	5b                   	pop    %ebx
    1d51:	5e                   	pop    %esi
    1d52:	5f                   	pop    %edi
    1d53:	5d                   	pop    %ebp
    1d54:	c3                   	ret    
    1d55:	8d 76 00             	lea    0x0(%esi),%esi
				*timer = POLL_RETX;
				return (void*)amIns;
			}
			if(amIns->reorderTimerCode == code)
			{
				*timer = AM_REORDER;
    1d58:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				return (void*)amIns;
    1d5e:	eb e0                	jmp    1d40 <findInsByCode+0x90>
			}
			if(amIns->statProhTimerCode == code)
			{
				*timer = STAT_PRO;
    1d60:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
				return (void*)amIns;
    1d66:	eb d8                	jmp    1d40 <findInsByCode+0x90>
			}
		}
	}
	else
	{
		return NULL;
    1d68:	31 ff                	xor    %edi,%edi
    1d6a:	eb d4                	jmp    1d40 <findInsByCode+0x90>
    1d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00001d70 <rlc_close>:
**--------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
***********************************************************************************/
static void rlc_close()
{
    1d70:	55                   	push   %ebp
    1d71:	89 e5                	mov    %esp,%ebp
    1d73:	57                   	push   %edi
    1d74:	56                   	push   %esi
    1d75:	53                   	push   %ebx
    1d76:	83 ec 20             	sub    $0x20,%esp
    1d79:	e8 fc ff ff ff       	call   1d7a <rlc_close+0xa>
	struct AmBuffer *amBuffer, *tempAmBuffer;
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
    1d7e:	e8 fc ff ff ff       	call   1d7f <rlc_close+0xf>
    1d83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
//AM
	if(!list_empty(&SV(vAm_ins).amList))
    1d86:	05 f4 25 00 00       	add    $0x25f4,%eax
    1d8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1d91:	8b b0 f4 25 00 00    	mov    0x25f4(%eax),%esi
    1d97:	39 75 e0             	cmp    %esi,-0x20(%ebp)
    1d9a:	0f 84 6f 04 00 00    	je     220f <rlc_close+0x49f>
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    1da0:	8b 06                	mov    (%esi),%eax
    1da2:	81 ee 04 23 00 00    	sub    $0x2304,%esi
    1da8:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    1dae:	89 55 e8             	mov    %edx,-0x18(%ebp)
    1db1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1db8:	8b 96 08 23 00 00    	mov    0x2308(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1dbe:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1dc1:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1dc3:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
    1dc9:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1dcf:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    1dd6:	01 10 00 
	entry->prev = LIST_POISON2;
    1dd9:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    1de0:	02 20 00 
    1de3:	39 c2                	cmp    %eax,%edx
    1de5:	0f 84 8d 08 00 00    	je     2678 <rlc_close+0x908>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    1deb:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1df1:	8b 00                	mov    (%eax),%eax
    1df3:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1df6:	89 d6                	mov    %edx,%esi
    1df8:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1dfe:	eb 1e                	jmp    1e1e <rlc_close+0xae>
    1e00:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1e06:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1e0c:	39 ce                	cmp    %ecx,%esi
    1e0e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1e14:	0f 84 ae 03 00 00    	je     21c8 <rlc_close+0x458>
    1e1a:	89 fb                	mov    %edi,%ebx
    1e1c:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1e1e:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1e24:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1e27:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1e29:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1e2b:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1e32:	01 10 00 
	entry->prev = LIST_POISON2;
    1e35:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1e3c:	02 20 00 
    1e3f:	85 c0                	test   %eax,%eax
    1e41:	74 0b                	je     1e4e <rlc_close+0xde>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1e43:	e8 fc ff ff ff       	call   1e44 <rlc_close+0xd4>
						amBuffer->pkt = NULL;
    1e48:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1e4e:	85 db                	test   %ebx,%ebx
    1e50:	74 07                	je     1e59 <rlc_close+0xe9>
					{
						fsm_mem_free(amBuffer);
    1e52:	89 d8                	mov    %ebx,%eax
    1e54:	e8 fc ff ff ff       	call   1e55 <rlc_close+0xe5>
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
    1e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e5c:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    1e62:	75 9c                	jne    1e00 <rlc_close+0x90>
    1e64:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
						break;
    1e66:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}					
					
					if(list_empty(&amIns->amRetxBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:retx buffer is realeasing\n");
    1e68:	c7 04 24 d0 00 00 00 	movl   $0xd0,(%esp)
    1e6f:	e8 fc ff ff ff       	call   1e70 <rlc_close+0x100>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1e74:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    1e7a:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    1e80:	39 c2                	cmp    %eax,%edx
    1e82:	0f 84 59 03 00 00    	je     21e1 <rlc_close+0x471>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    1e88:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    1e8e:	8b 00                	mov    (%eax),%eax
    1e90:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1e93:	89 d6                	mov    %edx,%esi
    1e95:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    1e9b:	eb 21                	jmp    1ebe <rlc_close+0x14e>
    1e9d:	8d 76 00             	lea    0x0(%esi),%esi
    1ea0:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    1ea6:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    1eac:	39 ce                	cmp    %ecx,%esi
    1eae:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    1eb4:	0f 84 e6 02 00 00    	je     21a0 <rlc_close+0x430>
    1eba:	89 fb                	mov    %edi,%ebx
    1ebc:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ebe:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1ec4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1ec7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    1ec9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1ecb:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    1ed2:	01 10 00 
	entry->prev = LIST_POISON2;
    1ed5:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    1edc:	02 20 00 
    1edf:	85 c0                	test   %eax,%eax
    1ee1:	74 0b                	je     1eee <rlc_close+0x17e>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    1ee3:	e8 fc ff ff ff       	call   1ee4 <rlc_close+0x174>
						amBuffer->pkt = NULL;
    1ee8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    1eee:	85 db                	test   %ebx,%ebx
    1ef0:	74 07                	je     1ef9 <rlc_close+0x189>
					{
						fsm_mem_free(amBuffer);
    1ef2:	89 d8                	mov    %ebx,%eax
    1ef4:	e8 fc ff ff ff       	call   1ef5 <rlc_close+0x185>
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
    1ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1efc:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    1f02:	75 9c                	jne    1ea0 <rlc_close+0x130>
    1f04:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
						break;
    1f06:	31 db                	xor    %ebx,%ebx
						amBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amTransmittedBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:transmited buffer is realeasing\n");
    1f08:	c7 04 24 2c 01 00 00 	movl   $0x12c,(%esp)
    1f0f:	e8 fc ff ff ff       	call   1f10 <rlc_close+0x1a0>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    1f14:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    1f17:	8d 4e 44             	lea    0x44(%esi),%ecx
    1f1a:	39 f9                	cmp    %edi,%ecx
    1f1c:	0f 84 91 02 00 00    	je     21b3 <rlc_close+0x443>
			{
				list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    1f22:	8b 07                	mov    (%edi),%eax
    1f24:	83 ef 0c             	sub    $0xc,%edi
    1f27:	89 75 ec             	mov    %esi,-0x14(%ebp)
    1f2a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
    1f2d:	89 cb                	mov    %ecx,%ebx
    1f2f:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f32:	89 d6                	mov    %edx,%esi
    1f34:	eb 17                	jmp    1f4d <rlc_close+0x1dd>
    1f36:	66 90                	xchg   %ax,%ax
    1f38:	8b 46 0c             	mov    0xc(%esi),%eax
    1f3b:	8d 4e 0c             	lea    0xc(%esi),%ecx
    1f3e:	39 cb                	cmp    %ecx,%ebx
    1f40:	8d 50 f4             	lea    -0xc(%eax),%edx
    1f43:	0f 84 07 02 00 00    	je     2150 <rlc_close+0x3e0>
    1f49:	89 f7                	mov    %esi,%edi
    1f4b:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1f4d:	8b 57 10             	mov    0x10(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    1f50:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    1f53:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amsBuffer->list);
					if(amBuffer->pkt != NULL)
    1f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    1f58:	c7 47 0c 00 01 10 00 	movl   $0x100100,0xc(%edi)
	entry->prev = LIST_POISON2;
    1f5f:	c7 47 10 00 02 20 00 	movl   $0x200200,0x10(%edi)
    1f66:	8b 00                	mov    (%eax),%eax
    1f68:	85 c0                	test   %eax,%eax
    1f6a:	74 10                	je     1f7c <rlc_close+0x20c>
					{
						fsm_pkt_destroy(amsBuffer->pkt);
    1f6c:	8b 07                	mov    (%edi),%eax
    1f6e:	e8 fc ff ff ff       	call   1f6f <rlc_close+0x1ff>
						amBuffer->pkt = NULL;
    1f73:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
					}
					if(amsBuffer != NULL)
    1f7c:	85 ff                	test   %edi,%edi
    1f7e:	74 07                	je     1f87 <rlc_close+0x217>
					{
						fsm_mem_free(amsBuffer);
    1f80:	89 f8                	mov    %edi,%eax
    1f82:	e8 fc ff ff ff       	call   1f83 <rlc_close+0x213>
						amsBuffer = NULL;
					}				
					
					if(list_empty(&amIns->amSduBuffer.list))
    1f87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f8a:	3b 58 44             	cmp    0x44(%eax),%ebx
    1f8d:	75 a9                	jne    1f38 <rlc_close+0x1c8>
    1f8f:	89 c6                	mov    %eax,%esi
    1f91:	8b 5d f0             	mov    -0x10(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:sdu buffer is realeasing\n");
    1f94:	c7 04 24 94 01 00 00 	movl   $0x194,(%esp)
    1f9b:	e8 fc ff ff ff       	call   1f9c <rlc_close+0x22c>
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    1fa0:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    1fa6:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    1fac:	0f 84 b6 01 00 00    	je     2168 <rlc_close+0x3f8>
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is not empty\n");
    1fb2:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    1fb5:	c7 04 24 f0 01 00 00 	movl   $0x1f0,(%esp)
    1fbc:	e8 fc ff ff ff       	call   1fbd <rlc_close+0x24d>
				list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    1fc1:	8b 96 b0 01 00 00    	mov    0x1b0(%esi),%edx
    1fc7:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    1fca:	8b 02                	mov    (%edx),%eax
    1fcc:	8d 7a fc             	lea    -0x4(%edx),%edi
    1fcf:	39 d1                	cmp    %edx,%ecx
    1fd1:	74 78                	je     204b <rlc_close+0x2db>
    1fd3:	8d 50 fc             	lea    -0x4(%eax),%edx
    1fd6:	89 75 f0             	mov    %esi,-0x10(%ebp)
    1fd9:	89 ce                	mov    %ecx,%esi
    1fdb:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    1fde:	89 d3                	mov    %edx,%ebx
    1fe0:	eb 1b                	jmp    1ffd <rlc_close+0x28d>
    1fe2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    1fe8:	8b 43 04             	mov    0x4(%ebx),%eax
    1feb:	8d 4b 04             	lea    0x4(%ebx),%ecx
    1fee:	39 ce                	cmp    %ecx,%esi
    1ff0:	8d 50 fc             	lea    -0x4(%eax),%edx
    1ff3:	0f 84 ff 01 00 00    	je     21f8 <rlc_close+0x488>
    1ff9:	89 df                	mov    %ebx,%edi
    1ffb:	89 d3                	mov    %edx,%ebx
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    1ffd:	8b 57 08             	mov    0x8(%edi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2000:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2003:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    2005:	8b 07                	mov    (%edi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2007:	c7 47 04 00 01 10 00 	movl   $0x100100,0x4(%edi)
	entry->prev = LIST_POISON2;
    200e:	c7 47 08 00 02 20 00 	movl   $0x200200,0x8(%edi)
    2015:	85 c0                	test   %eax,%eax
    2017:	74 0b                	je     2024 <rlc_close+0x2b4>
					{
						fsm_pkt_destroy(buffer->pkt);
    2019:	e8 fc ff ff ff       	call   201a <rlc_close+0x2aa>
						buffer->pkt = NULL;
    201e:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
					}
					if(buffer != NULL)
    2024:	85 ff                	test   %edi,%edi
    2026:	74 07                	je     202f <rlc_close+0x2bf>
					{
						fsm_mem_free(buffer);
    2028:	89 f8                	mov    %edi,%eax
    202a:	e8 fc ff ff ff       	call   202b <rlc_close+0x2bb>
						buffer = NULL;
					}					
					if(list_empty(&amIns->ctrlPduBuffer.list))
    202f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2032:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    2038:	75 ae                	jne    1fe8 <rlc_close+0x278>
    203a:	89 c6                	mov    %eax,%esi
    203c:	8b 5d ec             	mov    -0x14(%ebp),%ebx
					{
						fsm_printf("[RLC][rlc_close] am:ctrl buffer is realeasing\n");
    203f:	c7 04 24 20 02 00 00 	movl   $0x220,(%esp)
    2046:	e8 fc ff ff ff       	call   2047 <rlc_close+0x2d7>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    204b:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    2051:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2057:	39 c2                	cmp    %eax,%edx
    2059:	0f 84 29 01 00 00    	je     2188 <rlc_close+0x418>
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    205f:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
    2065:	8b 00                	mov    (%eax),%eax
    2067:	89 75 f0             	mov    %esi,-0x10(%ebp)
    206a:	89 d6                	mov    %edx,%esi
    206c:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    2072:	eb 22                	jmp    2096 <rlc_close+0x326>
    2074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2078:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    207e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    2084:	39 ce                	cmp    %ecx,%esi
    2086:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    208c:	0f 84 b6 00 00 00    	je     2148 <rlc_close+0x3d8>
    2092:	89 fb                	mov    %edi,%ebx
    2094:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2096:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    209c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    209f:	89 02                	mov    %eax,(%edx)
				{
					list_del(&amBuffer->list);
					if(amBuffer->pkt != NULL)
    20a1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    20a3:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    20aa:	01 10 00 
	entry->prev = LIST_POISON2;
    20ad:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    20b4:	02 20 00 
    20b7:	85 c0                	test   %eax,%eax
    20b9:	74 0b                	je     20c6 <rlc_close+0x356>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    20bb:	e8 fc ff ff ff       	call   20bc <rlc_close+0x34c>
						amBuffer->pkt = NULL;
    20c0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    20c6:	85 db                	test   %ebx,%ebx
    20c8:	74 07                	je     20d1 <rlc_close+0x361>
					{
						fsm_mem_free(amBuffer);
    20ca:	89 d8                	mov    %ebx,%eax
    20cc:	e8 fc ff ff ff       	call   20cd <rlc_close+0x35d>
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
    20d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    20d4:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    20da:	75 9c                	jne    2078 <rlc_close+0x308>
    20dc:	89 c6                	mov    %eax,%esi
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
						break;
    20de:	31 db                	xor    %ebx,%ebx
						fsm_mem_free(amBuffer);
						amBuffer = NULL;
					}								
					if(list_empty(&amIns->amRecvBuffer.list))
					{
						fsm_printf("[RLC][rlc_close] am:recv buffer is realeasing\n");
    20e0:	c7 04 24 7c 02 00 00 	movl   $0x27c,(%esp)
    20e7:	e8 fc ff ff ff       	call   20e8 <rlc_close+0x378>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] am instance  has released(rbid is%d)\n", amIns->rbId);
    20ec:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    20f0:	c7 04 24 d8 02 00 00 	movl   $0x2d8,(%esp)
    20f7:	89 44 24 04          	mov    %eax,0x4(%esp)
    20fb:	e8 fc ff ff ff       	call   20fc <rlc_close+0x38c>
			if(amIns != NULL)
    2100:	85 f6                	test   %esi,%esi
    2102:	74 07                	je     210b <rlc_close+0x39b>
			{
				fsm_mem_free(amIns);
    2104:	89 f0                	mov    %esi,%eax
    2106:	e8 fc ff ff ff       	call   2107 <rlc_close+0x397>
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
    210b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    210e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    2111:	3b 90 f4 25 00 00    	cmp    0x25f4(%eax),%edx
    2117:	0f 84 e6 00 00 00    	je     2203 <rlc_close+0x493>
	FIN(rlc_close());
	SV_PTR_GET(rlc_mac_sv);
//AM
	if(!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each_entry_safe(amIns,tempAmIns, &SV(vAm_ins).amList,amList)
    211d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    2120:	8b 81 04 23 00 00    	mov    0x2304(%ecx),%eax
    2126:	81 c1 04 23 00 00    	add    $0x2304,%ecx
    212c:	39 4d e0             	cmp    %ecx,-0x20(%ebp)
    212f:	8d 90 fc dc ff ff    	lea    -0x2304(%eax),%edx
    2135:	0f 84 d4 00 00 00    	je     220f <rlc_close+0x49f>
    213b:	8b 75 e8             	mov    -0x18(%ebp),%esi
    213e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    2141:	e9 72 fc ff ff       	jmp    1db8 <rlc_close+0x48>
    2146:	66 90                	xchg   %ax,%ax
    2148:	8b 75 f0             	mov    -0x10(%ebp),%esi
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    214b:	89 fb                	mov    %edi,%ebx
    214d:	eb 9d                	jmp    20ec <rlc_close+0x37c>
    214f:	90                   	nop
    2150:	8b 75 ec             	mov    -0x14(%ebp),%esi
    2153:	8b 5d f0             	mov    -0x10(%ebp),%ebx
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
			}
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    2156:	8d 8e b0 01 00 00    	lea    0x1b0(%esi),%ecx
    215c:	3b 8e b0 01 00 00    	cmp    0x1b0(%esi),%ecx
    2162:	0f 85 4a fe ff ff    	jne    1fb2 <rlc_close+0x242>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:ctrl buffer is empty\n");
    2168:	c7 04 24 50 02 00 00 	movl   $0x250,(%esp)
    216f:	e8 fc ff ff ff       	call   2170 <rlc_close+0x400>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2174:	8b 86 5c 02 00 00    	mov    0x25c(%esi),%eax
			}
			if(!list_empty(&amIns->amRecvBuffer.list))
    217a:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    2180:	39 c2                	cmp    %eax,%edx
    2182:	0f 85 d7 fe ff ff    	jne    205f <rlc_close+0x2ef>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:recv buffer is empty\n");
    2188:	c7 04 24 ac 02 00 00 	movl   $0x2ac,(%esp)
    218f:	e8 fc ff ff ff       	call   2190 <rlc_close+0x420>
    2194:	e9 53 ff ff ff       	jmp    20ec <rlc_close+0x37c>
    2199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    21a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    21a3:	89 fb                	mov    %edi,%ebx
    21a5:	8b 7e 44             	mov    0x44(%esi),%edi
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amSduBuffer.list))
    21a8:	8d 4e 44             	lea    0x44(%esi),%ecx
    21ab:	39 f9                	cmp    %edi,%ecx
    21ad:	0f 85 6f fd ff ff    	jne    1f22 <rlc_close+0x1b2>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:sdu buffer is empty\n");
    21b3:	c7 04 24 c4 01 00 00 	movl   $0x1c4,(%esp)
    21ba:	e8 fc ff ff ff       	call   21bb <rlc_close+0x44b>
    21bf:	e9 dc fd ff ff       	jmp    1fa0 <rlc_close+0x230>
    21c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    21c8:	8b 75 f0             	mov    -0x10(%ebp),%esi
		{
			list_del(&amIns->amList);
			//
			if(!list_empty(&amIns->amRetxBuffer.list))
			{
				list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    21cb:	89 fb                	mov    %edi,%ebx
    21cd:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
			}
			//
			if(!list_empty(&amIns->amTransmittedBuffer.list))
    21d3:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    21d9:	39 c2                	cmp    %eax,%edx
    21db:	0f 85 a7 fc ff ff    	jne    1e88 <rlc_close+0x118>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:transmited buffer is empty\n");
    21e1:	c7 04 24 64 01 00 00 	movl   $0x164,(%esp)
    21e8:	e8 fc ff ff ff       	call   21e9 <rlc_close+0x479>
    21ed:	e9 22 fd ff ff       	jmp    1f14 <rlc_close+0x1a4>
    21f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    21f8:	8b 75 f0             	mov    -0x10(%ebp),%esi
    21fb:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    21fe:	e9 48 fe ff ff       	jmp    204b <rlc_close+0x2db>
				fsm_mem_free(amIns);
				amIns = NULL;
			}		
			if(list_empty(&SV(vAm_ins).amList))
			{
				fsm_printf("[RLC][rlc_close] amInsList is empty\n");
    2203:	c7 04 24 10 03 00 00 	movl   $0x310,(%esp)
    220a:	e8 fc ff ff ff       	call   220b <rlc_close+0x49b>
				break;
			}
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    220f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2212:	05 c0 36 00 00       	add    $0x36c0,%eax
    2217:	89 45 e8             	mov    %eax,-0x18(%ebp)
    221a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    221d:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
    2223:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2226:	0f 84 13 01 00 00    	je     233f <rlc_close+0x5cf>
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    222c:	8b 02                	mov    (%edx),%eax
    222e:	81 ea c4 10 00 00    	sub    $0x10c4,%edx
    2234:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2237:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    223d:	89 55 ec             	mov    %edx,-0x14(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2240:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2243:	8b 91 c8 10 00 00    	mov    0x10c8(%ecx),%edx
		{
			list_del(&umRxIns->umRxList);
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    2249:	89 cf                	mov    %ecx,%edi
    224b:	83 c7 30             	add    $0x30,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    224e:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2251:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2253:	8b 59 30             	mov    0x30(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2256:	c7 81 c4 10 00 00 00 	movl   $0x100100,0x10c4(%ecx)
    225d:	01 10 00 
	entry->prev = LIST_POISON2;
    2260:	c7 81 c8 10 00 00 00 	movl   $0x200200,0x10c8(%ecx)
    2267:	02 20 00 
    226a:	39 df                	cmp    %ebx,%edi
    226c:	0f 84 f5 03 00 00    	je     2667 <rlc_close+0x8f7>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    2272:	8b 03                	mov    (%ebx),%eax
    2274:	83 eb 10             	sub    $0x10,%ebx
    2277:	8d 70 f0             	lea    -0x10(%eax),%esi
    227a:	eb 15                	jmp    2291 <rlc_close+0x521>
    227c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    2280:	8b 46 10             	mov    0x10(%esi),%eax
    2283:	8d 4e 10             	lea    0x10(%esi),%ecx
    2286:	39 cf                	cmp    %ecx,%edi
    2288:	8d 50 f0             	lea    -0x10(%eax),%edx
    228b:	74 4a                	je     22d7 <rlc_close+0x567>
    228d:	89 f3                	mov    %esi,%ebx
    228f:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2291:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    2294:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    2297:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    2299:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    229b:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    22a2:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    22a9:	85 c0                	test   %eax,%eax
    22ab:	74 0b                	je     22b8 <rlc_close+0x548>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    22ad:	e8 fc ff ff ff       	call   22ae <rlc_close+0x53e>
						umBuffer->pkt = NULL;
    22b2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    22b8:	85 db                	test   %ebx,%ebx
    22ba:	74 07                	je     22c3 <rlc_close+0x553>
					{
						fsm_mem_free(umBuffer);
    22bc:	89 d8                	mov    %ebx,%eax
    22be:	e8 fc ff ff ff       	call   22bf <rlc_close+0x54f>
						umBuffer = NULL;
					}				
					
					if(list_empty(&umRxIns->umRecvBuffer.list))
    22c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22c6:	3b 78 30             	cmp    0x30(%eax),%edi
    22c9:	75 b5                	jne    2280 <rlc_close+0x510>
					{
						fsm_printf("[RLC][rlc_close] um recv:recv buffer is realeasing\n");
    22cb:	c7 04 24 38 03 00 00 	movl   $0x338,(%esp)
    22d2:	e8 fc ff ff ff       	call   22d3 <rlc_close+0x563>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umRxIns->rbId);
    22d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    22da:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    22de:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    22e5:	89 44 24 04          	mov    %eax,0x4(%esp)
    22e9:	e8 fc ff ff ff       	call   22ea <rlc_close+0x57a>
			if(umRxIns != NULL)
    22ee:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    22f1:	85 c9                	test   %ecx,%ecx
    22f3:	74 08                	je     22fd <rlc_close+0x58d>
			{
				fsm_mem_free(umRxIns);
    22f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22f8:	e8 fc ff ff ff       	call   22f9 <rlc_close+0x589>
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
    22fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2300:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2303:	3b 90 c0 36 00 00    	cmp    0x36c0(%eax),%edx
    2309:	74 28                	je     2333 <rlc_close+0x5c3>
		}
	}
	//UM
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each_entry_safe(umRxIns,tempUrIns, &SV(vUm_rx_ins).umRxList,umRxList)
    230b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    230e:	8b 81 c4 10 00 00    	mov    0x10c4(%ecx),%eax
    2314:	81 c1 c4 10 00 00    	add    $0x10c4,%ecx
    231a:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    231d:	8d 90 3c ef ff ff    	lea    -0x10c4(%eax),%edx
    2323:	74 1a                	je     233f <rlc_close+0x5cf>
    2325:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2328:	89 55 ec             	mov    %edx,-0x14(%ebp)
    232b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    232e:	e9 0d ff ff ff       	jmp    2240 <rlc_close+0x4d0>
				fsm_mem_free(umRxIns);
				umRxIns = NULL;
			}			
			if(list_empty(&SV(vUm_rx_ins).umRxList))
			{
				fsm_printf("[RLC][rlc_close] umRxInsList is empty\n");
    2333:	c7 04 24 d4 03 00 00 	movl   $0x3d4,(%esp)
    233a:	e8 fc ff ff ff       	call   233b <rlc_close+0x5cb>
				break;
			}
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
    233f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2342:	05 f8 36 00 00       	add    $0x36f8,%eax
    2347:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    234a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    234d:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
    2353:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2356:	0f 84 02 01 00 00    	je     245e <rlc_close+0x6ee>
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    235c:	8b 02                	mov    (%edx),%eax
    235e:	83 ea 30             	sub    $0x30,%edx
    2361:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2364:	8d 50 d0             	lea    -0x30(%eax),%edx
    2367:	89 55 ec             	mov    %edx,-0x14(%ebp)
    236a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2370:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2373:	8b 51 34             	mov    0x34(%ecx),%edx
		{
			list_del(&umTxIns->umTxList);
			if(!list_empty(&umTxIns->umSduBuffer.list))
    2376:	89 cf                	mov    %ecx,%edi
    2378:	83 c7 18             	add    $0x18,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    237b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    237e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2380:	8b 59 18             	mov    0x18(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2383:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    238a:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    2391:	39 df                	cmp    %ebx,%edi
    2393:	0f 84 bd 02 00 00    	je     2656 <rlc_close+0x8e6>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    2399:	8b 03                	mov    (%ebx),%eax
    239b:	83 eb 10             	sub    $0x10,%ebx
    239e:	8d 70 f0             	lea    -0x10(%eax),%esi
    23a1:	eb 16                	jmp    23b9 <rlc_close+0x649>
    23a3:	90                   	nop
    23a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    23a8:	8b 46 10             	mov    0x10(%esi),%eax
    23ab:	8d 4e 10             	lea    0x10(%esi),%ecx
    23ae:	39 cf                	cmp    %ecx,%edi
    23b0:	8d 50 f0             	lea    -0x10(%eax),%edx
    23b3:	74 4a                	je     23ff <rlc_close+0x68f>
    23b5:	89 f3                	mov    %esi,%ebx
    23b7:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    23b9:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    23bc:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    23bf:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					if(umBuffer->pkt != NULL)
    23c1:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    23c3:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    23ca:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    23d1:	85 c0                	test   %eax,%eax
    23d3:	74 0b                	je     23e0 <rlc_close+0x670>
					{
						fsm_pkt_destroy(umBuffer->pkt);
    23d5:	e8 fc ff ff ff       	call   23d6 <rlc_close+0x666>
						umBuffer->pkt = NULL;
    23da:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(umBuffer != NULL)
    23e0:	85 db                	test   %ebx,%ebx
    23e2:	74 07                	je     23eb <rlc_close+0x67b>
					{
						fsm_mem_free(umBuffer);
    23e4:	89 d8                	mov    %ebx,%eax
    23e6:	e8 fc ff ff ff       	call   23e7 <rlc_close+0x677>
						umBuffer = NULL;
					}					
					
					if(list_empty(&umTxIns->umSduBuffer.list))
    23eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23ee:	3b 78 18             	cmp    0x18(%eax),%edi
    23f1:	75 b5                	jne    23a8 <rlc_close+0x638>
					{
						fsm_printf("[RLC][rlc_close] um tran:sdu buffer is realeasing\n");
    23f3:	c7 04 24 fc 03 00 00 	movl   $0x3fc,(%esp)
    23fa:	e8 fc ff ff ff       	call   23fb <rlc_close+0x68b>
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
			}
			fsm_printf("[RLC][rlc_close] um instance  has released(rbid is %d)\n",umTxIns->rbid);
    23ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2402:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    2406:	c7 04 24 9c 03 00 00 	movl   $0x39c,(%esp)
    240d:	89 44 24 04          	mov    %eax,0x4(%esp)
    2411:	e8 fc ff ff ff       	call   2412 <rlc_close+0x6a2>
			if(umTxIns != NULL)
    2416:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2419:	85 d2                	test   %edx,%edx
    241b:	74 08                	je     2425 <rlc_close+0x6b5>
			{
				fsm_mem_free(umTxIns);
    241d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2420:	e8 fc ff ff ff       	call   2421 <rlc_close+0x6b1>
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
    2425:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2428:	8b 55 e8             	mov    -0x18(%ebp),%edx
    242b:	3b 90 f8 36 00 00    	cmp    0x36f8(%eax),%edx
    2431:	74 1f                	je     2452 <rlc_close+0x6e2>
		}
	}
//UM
	if(!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each_entry_safe(umTxIns,tempUtIns, &SV(vUm_tx_ins).umTxList,umTxList)
    2433:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2436:	8b 41 30             	mov    0x30(%ecx),%eax
    2439:	83 c1 30             	add    $0x30,%ecx
    243c:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    243f:	8d 50 d0             	lea    -0x30(%eax),%edx
    2442:	74 1a                	je     245e <rlc_close+0x6ee>
    2444:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2447:	89 55 ec             	mov    %edx,-0x14(%ebp)
    244a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    244d:	e9 1e ff ff ff       	jmp    2370 <rlc_close+0x600>
				fsm_mem_free(umTxIns);
				umTxIns = NULL;
			}		
			if(list_empty(&SV(vUm_tx_ins).umTxList))
			{
				fsm_printf("[RLC][rlc_close] umTxInsList is empty\n");
    2452:	c7 04 24 60 04 00 00 	movl   $0x460,(%esp)
    2459:	e8 fc ff ff ff       	call   245a <rlc_close+0x6ea>
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
    245e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2461:	05 2c 37 00 00       	add    $0x372c,%eax
    2466:	89 45 e8             	mov    %eax,-0x18(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    2469:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    246c:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
    2472:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    2475:	0f 84 1f 01 00 00    	je     259a <rlc_close+0x82a>
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    247b:	8b 02                	mov    (%edx),%eax
    247d:	83 ea 1c             	sub    $0x1c,%edx
    2480:	89 55 f0             	mov    %edx,-0x10(%ebp)
    2483:	8d 50 e4             	lea    -0x1c(%eax),%edx
    2486:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    2490:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    2493:	8b 51 20             	mov    0x20(%ecx),%edx
		{
			list_del(&tmTxIns->tmTxList);
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    2496:	89 cf                	mov    %ecx,%edi
    2498:	83 c7 0c             	add    $0xc,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    249b:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    249e:	89 02                	mov    %eax,(%edx)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    24a0:	8b 59 0c             	mov    0xc(%ecx),%ebx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24a3:	c7 41 1c 00 01 10 00 	movl   $0x100100,0x1c(%ecx)
	entry->prev = LIST_POISON2;
    24aa:	c7 41 20 00 02 20 00 	movl   $0x200200,0x20(%ecx)
    24b1:	39 df                	cmp    %ebx,%edi
    24b3:	74 56                	je     250b <rlc_close+0x79b>
			{
				list_for_each_entry_safe(buffer,tempBuffer, &tmTxIns->tmSduBuffer.list,list)
    24b5:	8b 03                	mov    (%ebx),%eax
    24b7:	83 eb 04             	sub    $0x4,%ebx
    24ba:	8d 70 fc             	lea    -0x4(%eax),%esi
    24bd:	eb 12                	jmp    24d1 <rlc_close+0x761>
    24bf:	90                   	nop
    24c0:	8b 46 04             	mov    0x4(%esi),%eax
    24c3:	8d 4e 04             	lea    0x4(%esi),%ecx
    24c6:	39 cf                	cmp    %ecx,%edi
    24c8:	8d 50 fc             	lea    -0x4(%eax),%edx
    24cb:	74 4a                	je     2517 <rlc_close+0x7a7>
    24cd:	89 f3                	mov    %esi,%ebx
    24cf:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    24d1:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    24d4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    24d7:	89 02                	mov    %eax,(%edx)
				{
					list_del(&buffer->list);
					if(buffer->pkt != NULL)
    24d9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    24db:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    24e2:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    24e9:	85 c0                	test   %eax,%eax
    24eb:	74 0b                	je     24f8 <rlc_close+0x788>
					{
						fsm_pkt_destroy(buffer->pkt);
    24ed:	e8 fc ff ff ff       	call   24ee <rlc_close+0x77e>
						buffer->pkt = NULL;
    24f2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(buffer != NULL)
    24f8:	85 db                	test   %ebx,%ebx
    24fa:	74 07                	je     2503 <rlc_close+0x793>
					{
						fsm_mem_free(buffer);
    24fc:	89 d8                	mov    %ebx,%eax
    24fe:	e8 fc ff ff ff       	call   24ff <rlc_close+0x78f>
						buffer = NULL;
					}					
					
					if(list_empty(&tmTxIns->tmSduBuffer.list))
    2503:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2506:	3b 78 0c             	cmp    0xc(%eax),%edi
    2509:	75 b5                	jne    24c0 <rlc_close+0x750>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
    250b:	c7 04 24 88 04 00 00 	movl   $0x488,(%esp)
    2512:	e8 fc ff ff ff       	call   2513 <rlc_close+0x7a3>
			}
			if( tmTxIns->pbCh == 0)
    2517:	8b 55 f0             	mov    -0x10(%ebp),%edx
    251a:	0f b6 42 04          	movzbl 0x4(%edx),%eax
    251e:	84 c0                	test   %al,%al
    2520:	74 4e                	je     2570 <rlc_close+0x800>
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
			}
			else if(tmTxIns->pbCh == 1)
    2522:	3c 01                	cmp    $0x1,%al
    2524:	74 5a                	je     2580 <rlc_close+0x810>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    2526:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    252d:	e8 fc ff ff ff       	call   252e <rlc_close+0x7be>
			}
			if(tmTxIns != NULL)
    2532:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2535:	85 c0                	test   %eax,%eax
    2537:	74 08                	je     2541 <rlc_close+0x7d1>
			{
				fsm_mem_free(tmTxIns);
    2539:	8b 45 f0             	mov    -0x10(%ebp),%eax
    253c:	e8 fc ff ff ff       	call   253d <rlc_close+0x7cd>
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
    2541:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2544:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2547:	3b 90 2c 37 00 00    	cmp    0x372c(%eax),%edx
    254d:	74 3f                	je     258e <rlc_close+0x81e>
		}
	}
//TM
	if(!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each_entry_safe(tmTxIns,tempTtIns, &SV(vTm_tx_ins).tmTxList,tmTxList)
    254f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2552:	8b 41 1c             	mov    0x1c(%ecx),%eax
    2555:	83 c1 1c             	add    $0x1c,%ecx
    2558:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    255b:	8d 50 e4             	lea    -0x1c(%eax),%edx
    255e:	74 3a                	je     259a <rlc_close+0x82a>
    2560:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    2563:	89 55 ec             	mov    %edx,-0x14(%ebp)
    2566:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    2569:	e9 22 ff ff ff       	jmp    2490 <rlc_close+0x720>
    256e:	66 90                	xchg   %ax,%ax
			{
				fsm_printf("[RLC][rlc_close] tm:sdu buffer is empty\n");
			}
			if( tmTxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH recv has released\n");
    2570:	c7 04 24 b4 04 00 00 	movl   $0x4b4,(%esp)
    2577:	e8 fc ff ff ff       	call   2578 <rlc_close+0x808>
    257c:	eb b4                	jmp    2532 <rlc_close+0x7c2>
    257e:	66 90                	xchg   %ax,%ax
			}
			else if(tmTxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2580:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    2587:	e8 fc ff ff ff       	call   2588 <rlc_close+0x818>
    258c:	eb a4                	jmp    2532 <rlc_close+0x7c2>
				fsm_mem_free(tmTxIns);
				tmTxIns = NULL;
			}		
			if(list_empty(&SV(vTm_tx_ins).tmTxList))
			{
				fsm_printf("[RLC][rlc_close] tmTxInsList is empty\n");
    258e:	c7 04 24 28 05 00 00 	movl   $0x528,(%esp)
    2595:	e8 fc ff ff ff       	call   2596 <rlc_close+0x826>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    259a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				break;
			}
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
    259d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    25a0:	8b 98 08 37 00 00    	mov    0x3708(%eax),%ebx
    25a6:	81 c7 08 37 00 00    	add    $0x3708,%edi
    25ac:	39 df                	cmp    %ebx,%edi
    25ae:	0f 84 8e 00 00 00    	je     2642 <rlc_close+0x8d2>
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25b4:	8b 03                	mov    (%ebx),%eax
    25b6:	83 eb 08             	sub    $0x8,%ebx
    25b9:	8d 70 f8             	lea    -0x8(%eax),%esi
    25bc:	eb 39                	jmp    25f7 <rlc_close+0x887>
    25be:	66 90                	xchg   %ax,%ax
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
			}
			else if(tmRxIns->pbCh == 1)
    25c0:	3c 01                	cmp    $0x1,%al
    25c2:	74 64                	je     2628 <rlc_close+0x8b8>
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
			}
			else
			{
				fsm_printf("[RLC][rlc_close] BCCH has released\n");
    25c4:	c7 04 24 04 05 00 00 	movl   $0x504,(%esp)
    25cb:	e8 fc ff ff ff       	call   25cc <rlc_close+0x85c>
			}
			if(tmRxIns != NULL)
    25d0:	85 db                	test   %ebx,%ebx
    25d2:	74 07                	je     25db <rlc_close+0x86b>
			{
				fsm_mem_free(tmRxIns);
    25d4:	89 d8                	mov    %ebx,%eax
    25d6:	e8 fc ff ff ff       	call   25d7 <rlc_close+0x867>
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
    25db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25de:	3b b8 08 37 00 00    	cmp    0x3708(%eax),%edi
    25e4:	74 50                	je     2636 <rlc_close+0x8c6>
		}
	}
//TM
	if(!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each_entry_safe(tmRxIns,tempTrIns, &SV(vTm_rx_ins).tmRxList,tmRxList)
    25e6:	8b 46 08             	mov    0x8(%esi),%eax
    25e9:	8d 4e 08             	lea    0x8(%esi),%ecx
    25ec:	39 cf                	cmp    %ecx,%edi
    25ee:	8d 50 f8             	lea    -0x8(%eax),%edx
    25f1:	74 4f                	je     2642 <rlc_close+0x8d2>
    25f3:	89 f3                	mov    %esi,%ebx
    25f5:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    25f7:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    25fa:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    25fd:	89 02                	mov    %eax,(%edx)
		{
			list_del(&tmRxIns->tmRxList);
			if( tmRxIns->pbCh == 0)
    25ff:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    2603:	c7 43 08 00 01 10 00 	movl   $0x100100,0x8(%ebx)
	entry->prev = LIST_POISON2;
    260a:	c7 43 0c 00 02 20 00 	movl   $0x200200,0xc(%ebx)
    2611:	84 c0                	test   %al,%al
    2613:	75 ab                	jne    25c0 <rlc_close+0x850>
			{
				fsm_printf("[RLC][rlc_close] CCCH tran has released\n");
    2615:	c7 04 24 50 05 00 00 	movl   $0x550,(%esp)
    261c:	e8 fc ff ff ff       	call   261d <rlc_close+0x8ad>
    2621:	eb ad                	jmp    25d0 <rlc_close+0x860>
    2623:	90                   	nop
    2624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			else if(tmRxIns->pbCh == 1)
			{
				fsm_printf("[RLC][rlc_close] PCCH has released\n");
    2628:	c7 04 24 e0 04 00 00 	movl   $0x4e0,(%esp)
    262f:	e8 fc ff ff ff       	call   2630 <rlc_close+0x8c0>
    2634:	eb 9a                	jmp    25d0 <rlc_close+0x860>
				fsm_mem_free(tmRxIns);
				tmRxIns = NULL;
			}			
			if(list_empty(&SV(vTm_rx_ins).tmRxList))
			{
				fsm_printf("[RLC][rlc_close] tmRxInsList is empty\n");
    2636:	c7 04 24 7c 05 00 00 	movl   $0x57c,(%esp)
    263d:	e8 fc ff ff ff       	call   263e <rlc_close+0x8ce>
				break;
			}
		}
	}
	fsm_printf("[RLC][rlc_close] rlc has closed \n");
    2642:	c7 04 24 a4 05 00 00 	movl   $0x5a4,(%esp)
    2649:	e8 fc ff ff ff       	call   264a <rlc_close+0x8da>
	FOUT;
}
    264e:	83 c4 20             	add    $0x20,%esp
    2651:	5b                   	pop    %ebx
    2652:	5e                   	pop    %esi
    2653:	5f                   	pop    %edi
    2654:	5d                   	pop    %ebp
    2655:	c3                   	ret    
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um tran:sdu buffer is empty\n");
    2656:	c7 04 24 30 04 00 00 	movl   $0x430,(%esp)
    265d:	e8 fc ff ff ff       	call   265e <rlc_close+0x8ee>
    2662:	e9 98 fd ff ff       	jmp    23ff <rlc_close+0x68f>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] um recv:recv buffer is empty\n");
    2667:	c7 04 24 6c 03 00 00 	movl   $0x36c,(%esp)
    266e:	e8 fc ff ff ff       	call   266f <rlc_close+0x8ff>
    2673:	e9 5f fc ff ff       	jmp    22d7 <rlc_close+0x567>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_close] am:retx buffer is empty\n");
    2678:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
    267f:	e8 fc ff ff ff       	call   2680 <rlc_close+0x910>
    2684:	e9 eb f7 ff ff       	jmp    1e74 <rlc_close+0x104>
    2689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00002690 <StartWaitingForRaResponse>:
->output:
->Special:
*******************************
*/
static void StartWaitingForRaResponse()
{
    2690:	55                   	push   %ebp
    2691:	89 e5                	mov    %esp,%ebp
    2693:	53                   	push   %ebx
    2694:	83 ec 04             	sub    $0x4,%esp
    2697:	e8 fc ff ff ff       	call   2698 <StartWaitingForRaResponse+0x8>
	FIN(StartWaitingForRaResponse());
	SV_PTR_GET(rlc_mac_sv);
    269c:	e8 fc ff ff ff       	call   269d <StartWaitingForRaResponse+0xd>
    26a1:	89 c3                	mov    %eax,%ebx
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
    26a3:	8b 80 cc 00 00 00    	mov    0xcc(%eax),%eax
    26a9:	89 83 90 01 00 00    	mov    %eax,0x190(%ebx)
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
    26af:	c7 04 24 c8 05 00 00 	movl   $0x5c8,(%esp)
    26b6:	e8 fc ff ff ff       	call   26b7 <StartWaitingForRaResponse+0x27>
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26bb:	ba 18 00 00 00       	mov    $0x18,%edx
    26c0:	6b 83 90 01 00 00 64 	imul   $0x64,0x190(%ebx),%eax
    26c7:	e8 fc ff ff ff       	call   26c8 <StartWaitingForRaResponse+0x38>
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
    26cc:	c6 83 98 01 00 00 01 	movb   $0x1,0x198(%ebx)
	SV_PTR_GET(rlc_mac_sv);
	//modified by HQ
	SV(WaitforRAresponseTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize);
	// 1subframe=1ms=100 (10us)
	fsm_printf("[UEMAC][wait_raresponse]run here,start WRAtimer\n");//testing code
	SV(WaitforRAresponseTimer.timer_sign) = fsm_schedule_self(SV(WaitforRAresponseTimer.time_value)*100, WaitforRAresponse_Expire );
    26d3:	89 83 94 01 00 00    	mov    %eax,0x194(%ebx)
	//set up waitRaResponse_timer // //fsm_schdule_self()int *  timer // 
	SV(WaitforRAresponseTimer.flag)=true;
	FOUT;
}
    26d9:	83 c4 04             	add    $0x4,%esp
    26dc:	5b                   	pop    %ebx
    26dd:	5d                   	pop    %ebp
    26de:	c3                   	ret    
    26df:	90                   	nop

000026e0 <send_SR>:
->output:
->Special:
*******************************
*/
static void send_SR()
{
    26e0:	55                   	push   %ebp
    26e1:	89 e5                	mov    %esp,%ebp
    26e3:	53                   	push   %ebx
    26e4:	83 ec 04             	sub    $0x4,%esp
    26e7:	e8 fc ff ff ff       	call   26e8 <send_SR+0x8>
	FIN(send_SR());
	SV_PTR_GET(rlc_mac_sv);
    26ec:	e8 fc ff ff ff       	call   26ed <send_SR+0xd>
    26f1:	89 c3                	mov    %eax,%ebx
	fsm_printf("[UE MAC]send_SR\n");
    26f3:	c7 04 24 b3 00 00 00 	movl   $0xb3,(%esp)
    26fa:	e8 fc ff ff ff       	call   26fb <send_SR+0x1b>
	fsm_schedule_self(0,SR_Fail);//SR
    26ff:	ba 07 00 00 00       	mov    $0x7,%edx
    2704:	31 c0                	xor    %eax,%eax
    2706:	e8 fc ff ff ff       	call   2707 <send_SR+0x27>
	SV(ratype.ra_type)=2;
    270b:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    2712:	00 00 00 
	FOUT;
}
    2715:	83 c4 04             	add    $0x4,%esp
    2718:	5b                   	pop    %ebx
    2719:	5d                   	pop    %ebp
    271a:	c3                   	ret    
    271b:	90                   	nop
    271c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00002720 <rlc_init_enter>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void rlc_init_enter(void)
{
    2720:	55                   	push   %ebp
    2721:	89 e5                	mov    %esp,%ebp
    2723:	57                   	push   %edi
    2724:	56                   	push   %esi
    2725:	53                   	push   %ebx
    2726:	83 ec 04             	sub    $0x4,%esp
    2729:	e8 fc ff ff ff       	call   272a <rlc_init_enter+0xa>
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
    272e:	e8 fc ff ff ff       	call   272f <rlc_init_enter+0xf>
    2733:	89 c3                	mov    %eax,%ebx
	if(RLC_OPEN)
    2735:	e8 fc ff ff ff       	call   2736 <rlc_init_enter+0x16>
    273a:	83 f8 05             	cmp    $0x5,%eax
    273d:	74 09                	je     2748 <rlc_init_enter+0x28>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    273f:	83 c4 04             	add    $0x4,%esp
    2742:	5b                   	pop    %ebx
    2743:	5e                   	pop    %esi
    2744:	5f                   	pop    %edi
    2745:	5d                   	pop    %ebp
    2746:	c3                   	ret    
    2747:	90                   	nop
	TM_TX_Instance *tmTxIns;
	int i;
	
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
    2748:	e8 fc ff ff ff       	call   2749 <rlc_init_enter+0x29>
    274d:	85 c0                	test   %eax,%eax
    274f:	75 ee                	jne    273f <rlc_init_enter+0x1f>
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
    2751:	8d 83 f4 25 00 00    	lea    0x25f4(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2757:	89 83 f4 25 00 00    	mov    %eax,0x25f4(%ebx)
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
    275d:	8d b3 08 37 00 00    	lea    0x3708(%ebx),%esi
	list->prev = list;
    2763:	89 83 f8 25 00 00    	mov    %eax,0x25f8(%ebx)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
    2769:	8d 83 c0 36 00 00    	lea    0x36c0(%ebx),%eax
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
		INIT_LIST_HEAD(&SV(vTm_rx_ins).tmRxList);
		INIT_LIST_HEAD(&SV(vTm_tx_ins).tmTxList);
    276f:	8d bb 2c 37 00 00    	lea    0x372c(%ebx),%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2775:	89 83 c0 36 00 00    	mov    %eax,0x36c0(%ebx)
	list->prev = list;
    277b:	89 83 c4 36 00 00    	mov    %eax,0x36c4(%ebx)
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
		SV(packetType) = -1;
		INIT_LIST_HEAD(&SV(vAm_ins).amList);
		INIT_LIST_HEAD(&SV(vUm_rx_ins).umRxList);
		INIT_LIST_HEAD(&SV(vUm_tx_ins).umTxList);
    2781:	8d 83 f8 36 00 00    	lea    0x36f8(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    2787:	89 83 f8 36 00 00    	mov    %eax,0x36f8(%ebx)
	list->prev = list;
    278d:	89 83 fc 36 00 00    	mov    %eax,0x36fc(%ebx)
		SV(countDropPacket)=0;
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2793:	31 c0                	xor    %eax,%eax
	FIN(rlc_init_enter());
	SV_PTR_GET(rlc_mac_sv);
	if(RLC_OPEN)
	{
		// SV(ins_mode) = TM_MODE;
		SV(isBufferReq) = 0;
    2795:	c6 83 24 02 00 00 00 	movb   $0x0,0x224(%ebx)
		SV(packetType) = -1;
    279c:	c7 83 20 02 00 00 ff 	movl   $0xffffffff,0x220(%ebx)
    27a3:	ff ff ff 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27a6:	89 b3 08 37 00 00    	mov    %esi,0x3708(%ebx)
	list->prev = list;
    27ac:	89 b3 0c 37 00 00    	mov    %esi,0x370c(%ebx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    27b2:	89 bb 2c 37 00 00    	mov    %edi,0x372c(%ebx)
	list->prev = list;
    27b8:	89 bb 30 37 00 00    	mov    %edi,0x3730(%ebx)
		//mallocnum=0;
		//freenum=0;
	//	SV(pduLft).SN_Left = -1;
	//	SV(pduLft).sduLeft = NULL;
		//for test
		SV(countRecvFromUpper)=0;
    27be:	c7 83 8c 5a 00 00 00 	movl   $0x0,0x5a8c(%ebx)
    27c5:	00 00 00 
		SV(countSendToUpper)=0;
    27c8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    27cf:	00 00 00 
		SV(countRecvFromLower)=0;
    27d2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    27d9:	00 00 00 
		SV(countSentToLower)=0;
    27dc:	c7 83 98 5a 00 00 00 	movl   $0x0,0x5a98(%ebx)
    27e3:	00 00 00 
		SV(countDropPacket)=0;
    27e6:	c7 83 9c 5a 00 00 00 	movl   $0x0,0x5a9c(%ebx)
    27ed:	00 00 00 
		SV(countSendCtrlPdu)=0;
    27f0:	c7 83 a0 5a 00 00 00 	movl   $0x0,0x5aa0(%ebx)
    27f7:	00 00 00 
		SV(countRecvCtrlPdu)=0;
    27fa:	c7 83 a4 5a 00 00 00 	movl   $0x0,0x5aa4(%ebx)
    2801:	00 00 00 
		SV(max_queue_num)=0;
    2804:	c7 83 a8 5a 00 00 00 	movl   $0x0,0x5aa8(%ebx)
    280b:	00 00 00 
    280e:	66 90                	xchg   %ax,%ax
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
    2810:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
    2817:	83 c0 01             	add    $0x1,%eax
    281a:	83 f8 32             	cmp    $0x32,%eax
    281d:	75 f1                	jne    2810 <rlc_init_enter+0xf0>
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    281f:	c7 83 e8 02 00 00 ff 	movl   $0xffffffff,0x2e8(%ebx)
    2826:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2829:	b0 10                	mov    $0x10,%al
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
							SV(allocCode[0x29]) = SV(allocCode[0x30]) = -1;//0x30bufferReq
    282b:	c7 83 cc 02 00 00 ff 	movl   $0xffffffff,0x2cc(%ebx)
    2832:	ff ff ff 
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
							SV(allocCode[0x24]) = SV(allocCode[0x25]) = SV(allocCode[0x26]) = SV(allocCode[0x27]) = SV(allocCode[0x28]) = \
    2835:	c7 83 c8 02 00 00 ff 	movl   $0xffffffff,0x2c8(%ebx)
    283c:	ff ff ff 
    283f:	c7 83 c4 02 00 00 ff 	movl   $0xffffffff,0x2c4(%ebx)
    2846:	ff ff ff 
    2849:	c7 83 c0 02 00 00 ff 	movl   $0xffffffff,0x2c0(%ebx)
    2850:	ff ff ff 
    2853:	c7 83 bc 02 00 00 ff 	movl   $0xffffffff,0x2bc(%ebx)
    285a:	ff ff ff 
    285d:	c7 83 b8 02 00 00 ff 	movl   $0xffffffff,0x2b8(%ebx)
    2864:	ff ff ff 
		SV(countSendCtrlPdu)=0;
		SV(countRecvCtrlPdu)=0;
		SV(max_queue_num)=0;
		//
		for(i = 0; i<MAX_CODE; i++) SV(allocCode[i]) = i;
		SV(allocCode[0]) =  SV(allocCode[0x0B]) =  SV(allocCode[0x21])  = SV(allocCode[0x22]) = SV(allocCode[0x23]) =\
    2867:	c7 83 b4 02 00 00 ff 	movl   $0xffffffff,0x2b4(%ebx)
    286e:	ff ff ff 
    2871:	c7 83 b0 02 00 00 ff 	movl   $0xffffffff,0x2b0(%ebx)
    2878:	ff ff ff 
    287b:	c7 83 ac 02 00 00 ff 	movl   $0xffffffff,0x2ac(%ebx)
    2882:	ff ff ff 
    2885:	c7 83 54 02 00 00 ff 	movl   $0xffffffff,0x254(%ebx)
    288c:	ff ff ff 
    288f:	c7 83 28 02 00 00 ff 	movl   $0xffffffff,0x228(%ebx)
    2896:	ff ff ff 
		//SV(bufferReqTimerValue) = 10*100;  //
		//SV(bufferReqTimerCode) = 0x30;
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2899:	e8 fc ff ff ff       	call   289a <rlc_init_enter+0x17a>
		tmRxIns->pbCh = 1;            //PCCH
    289e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28a2:	8d 48 08             	lea    0x8(%eax),%ecx
		//SV(bufferReqTimer) = 0;
		//fsm_printf("rlc init is called");
		/* TM receiving instance estabilshment corresponding to PCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 1;            //PCCH
		tmRxIns->rnti = 0;
    28a5:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28aa:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;
    28ae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28b2:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28b8:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28be:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28c1:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    28c4:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");
    28c6:	c7 04 24 fc 05 00 00 	movl   $0x5fc,(%esp)
    28cd:	e8 fc ff ff ff       	call   28ce <rlc_init_enter+0x1ae>

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    28d2:	b8 10 00 00 00       	mov    $0x10,%eax
    28d7:	e8 fc ff ff ff       	call   28d8 <rlc_init_enter+0x1b8>
		tmRxIns->pbCh = 2;            //BCCH
    28dc:	c6 40 04 02          	movb   $0x2,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //BCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    28e0:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] PCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to BCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 2;            //BCCH
		tmRxIns->rnti = 0;
    28e3:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    28e8:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //BCCH
    28ec:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    28f0:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    28f6:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    28fc:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    28ff:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2902:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");
    2904:	c7 04 24 30 06 00 00 	movl   $0x630,(%esp)
    290b:	e8 fc ff ff ff       	call   290c <rlc_init_enter+0x1ec>

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
    2910:	b8 10 00 00 00       	mov    $0x10,%eax
    2915:	e8 fc ff ff ff       	call   2916 <rlc_init_enter+0x1f6>
		tmRxIns->pbCh = 0;            //CCCH
    291a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmRxIns->rnti = 0;
		tmRxIns->rbId = 0;
		tmRxIns->lcId = 0;       //CCCH
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
    291e:	8d 48 08             	lea    0x8(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] BCCH instance has bulided\n");

		/* TM receiving instance estabilshment corresponding to CCCH  */
		tmRxIns = instance_create(TM_RX_Instance) ;
		tmRxIns->pbCh = 0;            //CCCH
		tmRxIns->rnti = 0;
    2921:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmRxIns->rbId = 0;
    2926:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmRxIns->lcId = 0;       //CCCH
    292a:	c6 40 03 00          	movb   $0x0,0x3(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    292e:	8b 93 0c 37 00 00    	mov    0x370c(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2934:	89 8b 0c 37 00 00    	mov    %ecx,0x370c(%ebx)
	new->next = next;
    293a:	89 70 08             	mov    %esi,0x8(%eax)
	new->prev = prev;
    293d:	89 50 0c             	mov    %edx,0xc(%eax)
	prev->next = new;
    2940:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");
    2942:	c7 04 24 64 06 00 00 	movl   $0x664,(%esp)
    2949:	e8 fc ff ff ff       	call   294a <rlc_init_enter+0x22a>

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
    294e:	b8 24 00 00 00       	mov    $0x24,%eax
    2953:	e8 fc ff ff ff       	call   2954 <rlc_init_enter+0x234>
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
    2958:	8d 50 0c             	lea    0xc(%eax),%edx
		list_add_tail(&tmRxIns->tmRxList, &SV(vTm_rx_ins).tmRxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
    295b:	c6 40 04 00          	movb   $0x0,0x4(%eax)
		tmTxIns->rbId = 0;
		tmTxIns->lcId = 0;       //CCCH
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
		tmTxIns->tmSduBufferSize = 0;
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
    295f:	8d 48 1c             	lea    0x1c(%eax),%ecx
		fsm_printf("[RLC][rlc_init_enter] CCCH recv instance has bulided\n");

		/* TM transimitting instance estabilshment corresponding to CCCH  */
		tmTxIns = instance_create(TM_TX_Instance) ;
		tmTxIns->pbCh = 0;            //CCCH
		tmTxIns->rnti = 0;
    2962:	66 c7 00 00 00       	movw   $0x0,(%eax)
		tmTxIns->rbId = 0;
    2967:	c6 40 02 00          	movb   $0x0,0x2(%eax)
		tmTxIns->lcId = 0;       //CCCH
    296b:	c6 40 03 00          	movb   $0x0,0x3(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    296f:	89 50 0c             	mov    %edx,0xc(%eax)
	list->prev = list;
    2972:	89 50 10             	mov    %edx,0x10(%eax)
		INIT_LIST_HEAD(&tmTxIns->tmSduBuffer.list);
		tmTxIns->tmSduBufferNum = 0;
    2975:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		tmTxIns->tmSduBufferSize = 0;
    297c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    2983:	8b 93 30 37 00 00    	mov    0x3730(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    2989:	89 8b 30 37 00 00    	mov    %ecx,0x3730(%ebx)
	new->next = next;
    298f:	89 78 1c             	mov    %edi,0x1c(%eax)
	new->prev = prev;
    2992:	89 50 20             	mov    %edx,0x20(%eax)
	prev->next = new;
    2995:	89 0a                	mov    %ecx,(%edx)
		list_add_tail(&tmTxIns->tmTxList, &SV(vTm_tx_ins).tmTxList);
		fsm_printf("[RLC][rlc_init_enter] CCCH tran instance has bulided\n");
    2997:	c7 04 24 9c 06 00 00 	movl   $0x69c,(%esp)
    299e:	e8 fc ff ff ff       	call   299f <rlc_init_enter+0x27f>
		//fsm_schedule_self(0, _START_WORK);

	}

	FOUT;
}
    29a3:	83 c4 04             	add    $0x4,%esp
    29a6:	5b                   	pop    %ebx
    29a7:	5e                   	pop    %esi
    29a8:	5f                   	pop    %edi
    29a9:	5d                   	pop    %ebp
    29aa:	c3                   	ret    
    29ab:	90                   	nop
    29ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000029b0 <ue_mac_sv_close>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_close()
{
    29b0:	55                   	push   %ebp
    29b1:	89 e5                	mov    %esp,%ebp
    29b3:	53                   	push   %ebx
    29b4:	e8 fc ff ff ff       	call   29b5 <ue_mac_sv_close+0x5>
	FIN(ue_mac_sv_close());
	SV_PTR_GET(rlc_mac_sv);
    29b9:	e8 fc ff ff ff       	call   29ba <ue_mac_sv_close+0xa>
    29be:	89 c3                	mov    %eax,%ebx
	if(SV(m_temp_cr) != NULL)
    29c0:	8b 80 a0 01 00 00    	mov    0x1a0(%eax),%eax
    29c6:	85 c0                	test   %eax,%eax
    29c8:	74 0f                	je     29d9 <ue_mac_sv_close+0x29>
	{
		fsm_mem_free(SV(m_temp_cr));
    29ca:	e8 fc ff ff ff       	call   29cb <ue_mac_sv_close+0x1b>
		SV(m_temp_cr) = NULL;
    29cf:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    29d6:	00 00 00 
	}
	Free_Uemac_Scheduler_Resource();
    29d9:	e8 fc ff ff ff       	call   29da <ue_mac_sv_close+0x2a>
	if(SV(msg3_buf_ptr)!=NULL)
    29de:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    29e4:	85 c0                	test   %eax,%eax
    29e6:	74 0f                	je     29f7 <ue_mac_sv_close+0x47>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));
    29e8:	e8 fc ff ff ff       	call   29e9 <ue_mac_sv_close+0x39>
		SV(msg3_buf_ptr)=NULL;
    29ed:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    29f4:	00 00 00 
	}
	FOUT;
}
    29f7:	5b                   	pop    %ebx
    29f8:	5d                   	pop    %ebp
    29f9:	c3                   	ret    
    29fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00002a00 <SendRaPreamble>:
->output:
->Special:
*******************************
*/
static void SendRaPreamble(RACH_ConfigDedicated *randomaccess_info)
{
    2a00:	55                   	push   %ebp
    2a01:	89 e5                	mov    %esp,%ebp
    2a03:	53                   	push   %ebx
    2a04:	83 ec 04             	sub    $0x4,%esp
    2a07:	e8 fc ff ff ff       	call   2a08 <SendRaPreamble+0x8>
    2a0c:	89 c3                	mov    %eax,%ebx
	FIN(SendRaPreamble());
	//modified by HQ
	fsm_printf("[UEMAC][sendrapreamble]run here,start send RAP \n");//testing code
    2a0e:	c7 04 24 d4 06 00 00 	movl   $0x6d4,(%esp)
    2a15:	e8 fc ff ff ff       	call   2a16 <SendRaPreamble+0x16>
	//fsm_octets_print(randomaccess_info,sizeof(RACH_ConfigDedicated));// for test
	fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_Preamble_Indicate, (void*)randomaccess_info , sizeof(randomaccess_info));
    2a1a:	89 d9                	mov    %ebx,%ecx
    2a1c:	ba 25 00 00 00       	mov    $0x25,%edx
    2a21:	b8 03 00 00 00       	mov    $0x3,%eax
    2a26:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    2a2d:	e8 fc ff ff ff       	call   2a2e <SendRaPreamble+0x2e>
	//send the information of random access to PHYadapter
	fsm_mem_free(randomaccess_info);//20140722 modified by lhl IOCTL
    2a32:	89 d8                	mov    %ebx,%eax
    2a34:	e8 fc ff ff ff       	call   2a35 <SendRaPreamble+0x35>
	FOUT;
 }
    2a39:	83 c4 04             	add    $0x4,%esp
    2a3c:	5b                   	pop    %ebx
    2a3d:	5d                   	pop    %ebp
    2a3e:	c3                   	ret    
    2a3f:	90                   	nop

00002a40 <ioctrl_handler>:
->output:
->Special:
*******************************
*/
static void ioctrl_handler()
{
    2a40:	55                   	push   %ebp
    2a41:	89 e5                	mov    %esp,%ebp
    2a43:	83 ec 18             	sub    $0x18,%esp
    2a46:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    2a49:	89 75 f8             	mov    %esi,-0x8(%ebp)
    2a4c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    2a4f:	e8 fc ff ff ff       	call   2a50 <ioctrl_handler+0x10>
	UEPHY_TO_MAC_ULgrant *tempulgrant;
	u32 rar_failed_times;//201501
	u32 contention_failed_times;//201501
	FIN(ioctrl_handler());

	SV_PTR_GET(rlc_mac_sv);
    2a54:	e8 fc ff ff ff       	call   2a55 <ioctrl_handler+0x15>
    2a59:	89 c6                	mov    %eax,%esi

	int cmd_value=fsm_ev_ioctrl_cmd();
    2a5b:	e8 fc ff ff ff       	call   2a5c <ioctrl_handler+0x1c>

	switch(cmd_value)
    2a60:	3d 87 00 00 00       	cmp    $0x87,%eax
    2a65:	76 21                	jbe    2a88 <ioctrl_handler+0x48>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
			
			
			break;
		default:
			fsm_printf("[RLC_MAC] unidentified ioctrl command!\n");
    2a67:	c7 04 24 c8 0a 00 00 	movl   $0xac8,(%esp)
    2a6e:	e8 fc ff ff ff       	call   2a6f <ioctrl_handler+0x2f>
    2a73:	90                   	nop
    2a74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		
/**/
	}	
	FOUT;
}
    2a78:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    2a7b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    2a7e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    2a81:	89 ec                	mov    %ebp,%esp
    2a83:	5d                   	pop    %ebp
    2a84:	c3                   	ret    
    2a85:	8d 76 00             	lea    0x0(%esi),%esi

	SV_PTR_GET(rlc_mac_sv);

	int cmd_value=fsm_ev_ioctrl_cmd();

	switch(cmd_value)
    2a88:	ff 24 85 e0 00 00 00 	jmp    *0xe0(,%eax,4)
    2a8f:	90                   	nop
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
		break;
		case TEST_RECV_SYS :  
			fsm_printf("[MAC][RECVSYS]\n");
    2a90:	c7 04 24 c4 00 00 00 	movl   $0xc4,(%esp)
    2a97:	e8 fc ff ff ff       	call   2a98 <ioctrl_handler+0x58>
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
    2a9c:	31 c9                	xor    %ecx,%ecx
    2a9e:	ba 26 00 00 00       	mov    $0x26,%edx
    2aa3:	b8 03 00 00 00       	mov    $0x3,%eax
    2aa8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2aaf:	e8 fc ff ff ff       	call   2ab0 <ioctrl_handler+0x70>
		//ioctrlRNTI
		break;
    2ab4:	eb c2                	jmp    2a78 <ioctrl_handler+0x38>
    2ab6:	66 90                	xchg   %ax,%ax
			test_print_pkt_num();
		break;

		/***************** RLC ioctl_handler ******************/
		case CRLC_CONFIG_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
    2ab8:	c7 04 24 a0 09 00 00 	movl   $0x9a0,(%esp)
    2abf:	e8 fc ff ff ff       	call   2ac0 <ioctrl_handler+0x80>
			PCRLC_CONFIG_REQ();
    2ac4:	e8 fc ff ff ff       	call   2ac5 <ioctrl_handler+0x85>
			FOUT;
    2ac9:	eb ad                	jmp    2a78 <ioctrl_handler+0x38>
    2acb:	90                   	nop
    2acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
		//ioctrlRNTI
		break;
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
    2ad0:	c7 04 24 d4 00 00 00 	movl   $0xd4,(%esp)
    2ad7:	e8 fc ff ff ff       	call   2ad8 <ioctrl_handler+0x98>
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
    2adc:	31 c9                	xor    %ecx,%ecx
    2ade:	ba 46 00 00 00       	mov    $0x46,%edx
    2ae3:	b8 03 00 00 00       	mov    $0x3,%eax
    2ae8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2aef:	e8 fc ff ff ff       	call   2af0 <ioctrl_handler+0xb0>
		break;
    2af4:	eb 82                	jmp    2a78 <ioctrl_handler+0x38>
    2af6:	66 90                	xchg   %ax,%ax
			SV(RetxBSRTimer.time_value)	= SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer);
			SV(RetxBSRTimer.timer_sign) = fsm_schedule_self(SV(RetxBSRTimer.time_value), RexBSRTimer_Expire);
			SV(RetxBSRTimer.flag)= true;*/ 	//noted in 20151228
		break;
		case IOCCMD_TEST_lostUL : //
			fsm_schedule_self(100,TimeAlignmentTimer_Expire);
    2af8:	ba 0b 00 00 00       	mov    $0xb,%edx
    2afd:	b8 64 00 00 00       	mov    $0x64,%eax
    2b02:	e8 fc ff ff ff       	call   2b03 <ioctrl_handler+0xc3>
		break;
    2b07:	e9 6c ff ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
*/
static void handle_HARQ_feedback()
{
	void *tmpdata_ptr;	
	FIN(handle_HARQ_feedback());
	SV_PTR_GET(rlc_mac_sv);
    2b10:	e8 fc ff ff ff       	call   2b11 <ioctrl_handler+0xd1>
    2b15:	89 c6                	mov    %eax,%esi
	HARQ_statu_parameters ACK_statu={0,true,0};
	tmpdata_ptr = fsm_data_get();
    2b17:	e8 fc ff ff ff       	call   2b18 <ioctrl_handler+0xd8>
	if( ((struct HARQ_feedback*)tmpdata_ptr)->HARQ_FEEDBACK == true )
    2b1c:	80 78 04 00          	cmpb   $0x0,0x4(%eax)
    2b20:	74 31                	je     2b53 <ioctrl_handler+0x113>
	{
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].avaiable_flag = true;
    2b22:	8b 10                	mov    (%eax),%edx
    2b24:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b27:	c6 44 96 38 01       	movb   $0x1,0x38(%esi,%edx,4)
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].HARQ_buffer_pointer = NULL;
    2b2c:	8b 10                	mov    (%eax),%edx
    2b2e:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b31:	c7 44 96 44 00 00 00 	movl   $0x0,0x44(%esi,%edx,4)
    2b38:	00 
		SV(ULHARQ_status)[((HARQ_feedback*)tmpdata_ptr)->processID].statu=ACK_statu;
    2b39:	8b 10                	mov    (%eax),%edx
    2b3b:	8d 14 92             	lea    (%edx,%edx,4),%edx
    2b3e:	8d 4c 96 30          	lea    0x30(%esi,%edx,4),%ecx
    2b42:	66 c7 41 0c 00 00    	movw   $0x0,0xc(%ecx)
    2b48:	c6 41 0e 01          	movb   $0x1,0xe(%ecx)
    2b4c:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
    2b53:	e8 fc ff ff ff       	call   2b54 <ioctrl_handler+0x114>
		break;
    2b58:	e9 1b ff ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b5d:	8d 76 00             	lea    0x0(%esi),%esi
*/
static void ue_mac_lc_release()
{
	void *tmpdata_ptr;
	FIN(ue_mac_lc_release());
	tmpdata_ptr = fsm_data_get();
    2b60:	e8 fc ff ff ff       	call   2b61 <ioctrl_handler+0x121>
    2b65:	89 c6                	mov    %eax,%esi
	Delete_LogicalChannel_ConfigInfo(*((unsigned char *)tmpdata_ptr));
    2b67:	0f b6 00             	movzbl (%eax),%eax
    2b6a:	e8 fc ff ff ff       	call   2b6b <ioctrl_handler+0x12b>
	fsm_data_destroy(tmpdata_ptr);
    2b6f:	89 f0                	mov    %esi,%eax
    2b71:	e8 fc ff ff ff       	call   2b72 <ioctrl_handler+0x132>
    2b76:	e9 fd fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2b7b:	90                   	nop
    2b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
			ue_mac_rach_config();
		break;
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
    2b80:	c7 04 24 c0 07 00 00 	movl   $0x7c0,(%esp)
    2b87:	e8 fc ff ff ff       	call   2b88 <ioctrl_handler+0x148>
*/
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    2b8c:	b8 15 00 00 00       	mov    $0x15,%eax
    2b91:	e8 fc ff ff ff       	call   2b92 <ioctrl_handler+0x152>
    2b96:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2b98:	e8 fc ff ff ff       	call   2b99 <ioctrl_handler+0x159>
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2b9d:	b9 15 00 00 00       	mov    $0x15,%ecx
    2ba2:	89 c2                	mov    %eax,%edx
static void ue_mac_logCh_config() //modified by HQ 20120506
{
	void *tmpdata_ptr;
	FIN(ue_mac_logCh_config());
	MAC_LogicalChannelConfig_IoctrlMsg *lc_configinfo=(MAC_LogicalChannelConfig_IoctrlMsg*)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	tmpdata_ptr = fsm_data_get();	
    2ba4:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(lc_configinfo, tmpdata_ptr, sizeof(MAC_LogicalChannelConfig_IoctrlMsg));// 
    2ba6:	89 f0                	mov    %esi,%eax
    2ba8:	e8 fc ff ff ff       	call   2ba9 <ioctrl_handler+0x169>
	fsm_data_destroy(tmpdata_ptr);//
    2bad:	89 f8                	mov    %edi,%eax
    2baf:	e8 fc ff ff ff       	call   2bb0 <ioctrl_handler+0x170>
	Init_LogicalChannel_ConfigInfo(lc_configinfo);//lc_configinfo 20140506
    2bb4:	89 f0                	mov    %esi,%eax
    2bb6:	e8 fc ff ff ff       	call   2bb7 <ioctrl_handler+0x177>
	//fsm_printf("[UEMAC][logch_config]LCID:%d, ",lc_configinfo->logicalChannelIdentity);
	//fsm_printf("[UEMAC][logch_config]RRC TO MAC:LCGROUP:%d\n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup);
	//fsm_printf("[UEMAC][logch_config]prioritisedBitRate: %d \n",lc_configinfo->logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate);
	fsm_mem_free(lc_configinfo);	
    2bbb:	89 f0                	mov    %esi,%eax
    2bbd:	e8 fc ff ff ff       	call   2bbe <ioctrl_handler+0x17e>
    2bc2:	e9 b1 fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2bc7:	90                   	nop
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
			ue_mac_PCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_SPS  : 
			fsm_printf("[UEMAC][RRCTOMAC_spsconfig]rrctomac_spsconfig\n");
    2bc8:	c7 04 24 58 08 00 00 	movl   $0x858,(%esp)
    2bcf:	e8 fc ff ff ff       	call   2bd0 <ioctrl_handler+0x190>
*/
static void ue_mac_SPS_Config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_SPS_Config());
	SV_PTR_GET(rlc_mac_sv);
    2bd4:	e8 fc ff ff ff       	call   2bd5 <ioctrl_handler+0x195>
    2bd9:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();
    2bdb:	e8 fc ff ff ff       	call   2bdc <ioctrl_handler+0x19c>
	SV(systemconfigInfo.SPSConfigInfo)= *((struct SPS_Config*)tmpdata_ptr); //ioctrl //
    2be0:	81 c7 e4 00 00 00    	add    $0xe4,%edi
    2be6:	b9 11 00 00 00       	mov    $0x11,%ecx
    2beb:	89 c6                	mov    %eax,%esi
    2bed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2bef:	e8 fc ff ff ff       	call   2bf0 <ioctrl_handler+0x1b0>
    2bf4:	e9 7f fe ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		break;
		case IOCCMD_PDCCHtoMAC_ULGRANT : //PHYPDCCHUL_grantDCI,MAC
		//MACul_grant 
		//MSG4
			
			tempdata_ptr = fsm_data_get();
    2c00:	e8 fc ff ff ff       	call   2c01 <ioctrl_handler+0x1c1>
    2c05:	89 c7                	mov    %eax,%edi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
    2c07:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    2c0b:	66 89 46 0a          	mov    %ax,0xa(%esi)
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
    2c0f:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    2c13:	66 89 46 0c          	mov    %ax,0xc(%esi)
			if(tempulgrant->m_rnti == SV(C_RNTI))
    2c17:	0f b7 06             	movzwl (%esi),%eax
    2c1a:	66 39 07             	cmp    %ax,(%edi)
    2c1d:	0f 84 ed 03 00 00    	je     3010 <ioctrl_handler+0x5d0>
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
    2c23:	66 85 c0             	test   %ax,%ax
    2c26:	74 28                	je     2c50 <ioctrl_handler+0x210>
    2c28:	8b 86 ec 01 00 00    	mov    0x1ec(%esi),%eax
    2c2e:	85 c0                	test   %eax,%eax
    2c30:	74 1e                	je     2c50 <ioctrl_handler+0x210>
    2c32:	8b 86 f0 01 00 00    	mov    0x1f0(%esi),%eax
    2c38:	85 c0                	test   %eax,%eax
    2c3a:	0f 84 df 03 00 00    	je     301f <ioctrl_handler+0x5df>
    2c40:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    2c47:	0f 84 fc 03 00 00    	je     3049 <ioctrl_handler+0x609>
    2c4d:	8d 76 00             	lea    0x0(%esi),%esi
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2c50:	8b 47 06             	mov    0x6(%edi),%eax
    2c53:	e8 fc ff ff ff       	call   2c54 <ioctrl_handler+0x214>
			//fsm_printf("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d\n",SV(UL_resource_info.m_tbsize));
			//printk("[MAC][ioctrl_handler]SV(UL_resource_info.m_tbsize):%d, ul_sched_count:%d\n",SV(UL_resource_info.m_tbsize),++ul_sched_count);
			//SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(*((int *)tempdata_ptr)); //UL_grant 
			// ul_grant retxBSR-Timer 36321-80c 5.4.5
			SV(UL_resource_info.resource_flag) = true;
    2c58:	c6 46 28 01          	movb   $0x1,0x28(%esi)

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    2c5c:	89 c2                	mov    %eax,%edx
    2c5e:	c1 ea 03             	shr    $0x3,%edx
    2c61:	89 96 f4 01 00 00    	mov    %edx,0x1f4(%esi)
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2c67:	8b 96 48 01 00 00    	mov    0x148(%esi),%edx
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
				fsm_schedule_self(0, ContentionResolution_Fail );
			}
			//fsm_printf("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			//printk("[UEMAC][ioctl_handler]UE MAC RECV ULGRANT\n");
			SV(UL_resource_info.m_tbsize) = DoReceiveULgrant_Tbsize(tempulgrant->ulgrant);
    2c6d:	89 46 2c             	mov    %eax,0x2c(%esi)
			SV(UL_resource_info.resource_flag) = true;

			if(SV(UL_resource_info.resource_flag) == true)
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    2c70:	8d 4a 05             	lea    0x5(%edx),%ecx
    2c73:	39 4a 05             	cmp    %ecx,0x5(%edx)
    2c76:	74 0a                	je     2c82 <ioctrl_handler+0x242>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    2c78:	e8 fc ff ff ff       	call   2c79 <ioctrl_handler+0x239>
    2c7d:	e8 fc ff ff ff       	call   2c7e <ioctrl_handler+0x23e>
				SV(UL_resource_info.resource_flag)=false;
    2c82:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    2c86:	e9 ed fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2c8b:	90                   	nop
    2c8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
			TATimer_config();//RRCTA 
		break;
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
    2c90:	c7 04 24 58 07 00 00 	movl   $0x758,(%esp)
    2c97:	e8 fc ff ff ff       	call   2c98 <ioctrl_handler+0x258>
*/
static void ue_mac_main_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_main_config());
	SV_PTR_GET(rlc_mac_sv);
    2c9c:	e8 fc ff ff ff       	call   2c9d <ioctrl_handler+0x25d>
    2ca1:	89 c7                	mov    %eax,%edi
	tmpdata_ptr = fsm_data_get();	
    2ca3:	e8 fc ff ff ff       	call   2ca4 <ioctrl_handler+0x264>
	SV(systemconfigInfo.MACMainConfigInfo) = *((struct MAC_MainConfig*)tmpdata_ptr); //ioctrl
    2ca8:	83 c7 5c             	add    $0x5c,%edi
    2cab:	b9 14 00 00 00       	mov    $0x14,%ecx
    2cb0:	89 c6                	mov    %eax,%esi
    2cb2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	fsm_data_destroy(tmpdata_ptr);//
    2cb4:	e8 fc ff ff ff       	call   2cb5 <ioctrl_handler+0x275>
    2cb9:	e9 ba fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2cbe:	66 90                	xchg   %ax,%ax
}

static void test_print_pkt_num()
{
	FIN(test_print_pkt_num());
	SV_PTR_GET(rlc_mac_sv);
    2cc0:	e8 fc ff ff ff       	call   2cc1 <ioctrl_handler+0x281>
    2cc5:	89 c6                	mov    %eax,%esi
	printk("[UEMAC]uplink lost pkt num:%d\n",SV(lost_pkt_num_uplink));
    2cc7:	8b 80 04 02 00 00    	mov    0x204(%eax),%eax
    2ccd:	c7 04 24 18 09 00 00 	movl   $0x918,(%esp)
    2cd4:	89 44 24 04          	mov    %eax,0x4(%esp)
    2cd8:	e8 fc ff ff ff       	call   2cd9 <ioctrl_handler+0x299>
	printk("[UEMAC]uplink total pkt num:%d\n",SV(pkt_num_uplink));
    2cdd:	8b 86 08 02 00 00    	mov    0x208(%esi),%eax
    2ce3:	c7 04 24 38 09 00 00 	movl   $0x938,(%esp)
    2cea:	89 44 24 04          	mov    %eax,0x4(%esp)
    2cee:	e8 fc ff ff ff       	call   2cef <ioctrl_handler+0x2af>
	printk("[UEMAC]downlink lost pkt num:%d\n",SV(lost_pkt_num_downlink));
    2cf3:	8b 86 0c 02 00 00    	mov    0x20c(%esi),%eax
    2cf9:	c7 04 24 58 09 00 00 	movl   $0x958,(%esp)
    2d00:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d04:	e8 fc ff ff ff       	call   2d05 <ioctrl_handler+0x2c5>
	printk("[UEMAC]downlink total pkt num:%d\n",SV(pkt_num_downlink));
    2d09:	8b 86 10 02 00 00    	mov    0x210(%esi),%eax
    2d0f:	c7 04 24 7c 09 00 00 	movl   $0x97c,(%esp)
    2d16:	89 44 24 04          	mov    %eax,0x4(%esp)
    2d1a:	e8 fc ff ff ff       	call   2d1b <ioctrl_handler+0x2db>
    2d1f:	e9 54 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			rar_failed_times=*((u32 *)tempdata_ptr);
			SV(rar_failed_num)=rar_failed_times;
			fsm_data_destroy(tempdata_ptr);
		break;
		case _IOCTLtoUEMAC_Contention_Failed:
			tempdata_ptr = fsm_data_get();
    2d28:	e8 fc ff ff ff       	call   2d29 <ioctrl_handler+0x2e9>
			contention_failed_times=*((u32 *)tempdata_ptr);
    2d2d:	8b 10                	mov    (%eax),%edx
			SV(contention_failed_num)=contention_failed_times;
    2d2f:	89 96 00 02 00 00    	mov    %edx,0x200(%esi)
			fsm_data_destroy(tempdata_ptr);
    2d35:	e8 fc ff ff ff       	call   2d36 <ioctrl_handler+0x2f6>
		break;
    2d3a:	e9 39 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d3f:	90                   	nop
		case TEST_RECV_PADING://test code recv pading
			fsm_printf("[MAC][RECVPAG]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, TEST_MACtoPHY_PADING , NULL, 0);
		break;
		case _IOCTLtoUEMAC_RAR_Failed:
			tempdata_ptr = fsm_data_get();
    2d40:	e8 fc ff ff ff       	call   2d41 <ioctrl_handler+0x301>
			rar_failed_times=*((u32 *)tempdata_ptr);
    2d45:	8b 10                	mov    (%eax),%edx
			SV(rar_failed_num)=rar_failed_times;
    2d47:	89 96 fc 01 00 00    	mov    %edx,0x1fc(%esi)
    2d4d:	e9 01 fe ff ff       	jmp    2b53 <ioctrl_handler+0x113>
    2d52:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
			PCRLC_RESUME_REQ();
			FOUT;
			break;
		case  PRLC_DISC_REQ:
			PPRLC_DISC_REQ();
    2d58:	e8 fc ff ff ff       	call   2d59 <ioctrl_handler+0x319>
			FOUT;
    2d5d:	e9 16 fd ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_CONFIG_REQ has received\n");
			PCRLC_CONFIG_REQ();
			FOUT;
			break;
		case CRLC_BULID_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
    2d68:	c7 04 24 dc 09 00 00 	movl   $0x9dc,(%esp)
    2d6f:	e8 fc ff ff ff       	call   2d70 <ioctrl_handler+0x330>
			PCRLC_BULID_REQ();
    2d74:	e8 fc ff ff ff       	call   2d75 <ioctrl_handler+0x335>
			FOUT;
    2d79:	e9 fa fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d7e:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
			PCRLC_SUSPEND_REQ();
			FOUT;
			break;
		case CRLC_RESUME_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_RESUME_REQ has received\n");
    2d80:	c7 04 24 8c 0a 00 00 	movl   $0xa8c,(%esp)
    2d87:	e8 fc ff ff ff       	call   2d88 <ioctrl_handler+0x348>
			PCRLC_RESUME_REQ();
    2d8c:	e8 fc ff ff ff       	call   2d8d <ioctrl_handler+0x34d>
			FOUT;
    2d91:	e9 e2 fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2d96:	66 90                	xchg   %ax,%ax
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
			PCRLC_DEACT_REQ();
			FOUT;
			break;
		case CRLC_SUSPEND_REQ:
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_SUSPEND_REQ has received\n");
    2d98:	c7 04 24 50 0a 00 00 	movl   $0xa50,(%esp)
    2d9f:	e8 fc ff ff ff       	call   2da0 <ioctrl_handler+0x360>
			PCRLC_SUSPEND_REQ();
    2da4:	e8 fc ff ff ff       	call   2da5 <ioctrl_handler+0x365>
			FOUT;
    2da9:	e9 ca fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2dae:	66 90                	xchg   %ax,%ax
			fsm_printf("\n[RLC][rlc_ioctrl_handler] CRLC_BULID_REQ has received\n");
			PCRLC_BULID_REQ();
			FOUT;
			break;
		case CRLC_DEACT_REQ:
			fsm_printf(" \n[RLC][rlc_ioctrl_handler] CRLC_DEACT_REQ has received\n");
    2db0:	c7 04 24 14 0a 00 00 	movl   $0xa14,(%esp)
    2db7:	e8 fc ff ff ff       	call   2db8 <ioctrl_handler+0x378>
			PCRLC_DEACT_REQ();
    2dbc:	e8 fc ff ff ff       	call   2dbd <ioctrl_handler+0x37d>
			FOUT;
    2dc1:	e9 b2 fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2dc6:	66 90                	xchg   %ax,%ax
		case IOCCMD_RRCtoMAC_mainconfig :
			fsm_printf("[UEMAC][RRCTOMAC_mainconfig]rrctomac_mainconfig\n");
			ue_mac_main_config(); 
		break;
		case IOCCMD_RRCtoMAC_RACHcommonconfig : 
			fsm_printf("[UEMAC][RRCTOMAC_rachconfig]rrctomac_rachconfig\n");
    2dc8:	c7 04 24 8c 07 00 00 	movl   $0x78c,(%esp)
    2dcf:	e8 fc ff ff ff       	call   2dd0 <ioctrl_handler+0x390>
*/
static void ue_mac_rach_config()
{
	void *tmpdata_ptr;	
	FIN(ue_mac_rach_config());
	SV_PTR_GET(rlc_mac_sv);
    2dd4:	e8 fc ff ff ff       	call   2dd5 <ioctrl_handler+0x395>
    2dd9:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();
    2ddb:	e8 fc ff ff ff       	call   2ddc <ioctrl_handler+0x39c>
	//ioctrl
	SV(systemconfigInfo.RACHCommonConfigInfo) = *((struct RachConfigCommon*)tmpdata_ptr); 
    2de0:	8b 10                	mov    (%eax),%edx
    2de2:	89 96 ac 00 00 00    	mov    %edx,0xac(%esi)
    2de8:	8b 50 04             	mov    0x4(%eax),%edx
    2deb:	89 96 b0 00 00 00    	mov    %edx,0xb0(%esi)
    2df1:	8b 50 08             	mov    0x8(%eax),%edx
    2df4:	89 96 b4 00 00 00    	mov    %edx,0xb4(%esi)
    2dfa:	8b 50 0c             	mov    0xc(%eax),%edx
    2dfd:	89 96 b8 00 00 00    	mov    %edx,0xb8(%esi)
    2e03:	8b 50 10             	mov    0x10(%eax),%edx
    2e06:	89 96 bc 00 00 00    	mov    %edx,0xbc(%esi)
    2e0c:	8b 50 14             	mov    0x14(%eax),%edx
    2e0f:	89 96 c0 00 00 00    	mov    %edx,0xc0(%esi)
    2e15:	8b 50 18             	mov    0x18(%eax),%edx
    2e18:	89 96 c4 00 00 00    	mov    %edx,0xc4(%esi)
    2e1e:	8b 50 1c             	mov    0x1c(%eax),%edx
    2e21:	89 96 c8 00 00 00    	mov    %edx,0xc8(%esi)
    2e27:	8b 50 20             	mov    0x20(%eax),%edx
    2e2a:	89 96 cc 00 00 00    	mov    %edx,0xcc(%esi)
    2e30:	8b 50 24             	mov    0x24(%eax),%edx
    2e33:	89 96 d0 00 00 00    	mov    %edx,0xd0(%esi)
    2e39:	8b 50 28             	mov    0x28(%eax),%edx
    2e3c:	89 96 d4 00 00 00    	mov    %edx,0xd4(%esi)
	//fsm_mem_cpy(&(SV(systemconfigInfo.RACHCommonConfigInfo)), tmpdata_ptr, sizeof(struct RachConfigCommon));
	//fsm_printf("[UEMAC][rach_config]maxHARQ_Msg3Tx :%d ",	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx) );//testing code
	//fsm_printf("[UEMAC][rach_config]mac_ContentionResolutionTimer : %d \n",SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer));
	fsm_data_destroy(tmpdata_ptr);//
    2e42:	e8 fc ff ff ff       	call   2e43 <ioctrl_handler+0x403>
    2e47:	e9 2c fc ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2e4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
			//ioctrl
		break ;
		case IOCCMD_RRCTOMAC_CONFIG_TAT : 
			fsm_printf("[UEMAC][RRCTOMAC_TA]rrctomac_taconfig\n");
    2e50:	c7 04 24 08 07 00 00 	movl   $0x708,(%esp)
    2e57:	e8 fc ff ff ff       	call   2e58 <ioctrl_handler+0x418>
*/
static void TATimer_config() 
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
    2e5c:	e8 fc ff ff ff       	call   2e5d <ioctrl_handler+0x41d>
    2e61:	89 c6                	mov    %eax,%esi
	int time;
	tmpdata_ptr = fsm_data_get();
    2e63:	e8 fc ff ff ff       	call   2e64 <ioctrl_handler+0x424>
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2e68:	b9 04 00 00 00       	mov    $0x4,%ecx
    2e6d:	89 c2                	mov    %eax,%edx
{
	void *tmpdata_ptr;
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
    2e6f:	89 c7                	mov    %eax,%edi
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
    2e71:	8d 45 f0             	lea    -0x10(%ebp),%eax
    2e74:	e8 fc ff ff ff       	call   2e75 <ioctrl_handler+0x435>
	SV(TA_Periodic_time)=time;//LHL 20141021
    2e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2e7c:	80 be 68 01 00 00 00 	cmpb   $0x0,0x168(%esi)
	FIN(TATimer_config());
	SV_PTR_GET(rlc_mac_sv);
	int time;
	tmpdata_ptr = fsm_data_get();
	fsm_mem_cpy(&time,tmpdata_ptr, sizeof( struct TimeAlignmentTimer));
	SV(TA_Periodic_time)=time;//LHL 20141021
    2e83:	89 46 24             	mov    %eax,0x24(%esi)
	//SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	//SV(TATimer.flag)=true;
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
    2e86:	74 3a                	je     2ec2 <ioctrl_handler+0x482>
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
    2e88:	c7 04 24 30 07 00 00 	movl   $0x730,(%esp)
    2e8f:	e8 fc ff ff ff       	call   2e90 <ioctrl_handler+0x450>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    2e94:	8b 86 64 01 00 00    	mov    0x164(%esi),%eax
    2e9a:	e8 fc ff ff ff       	call   2e9b <ioctrl_handler+0x45b>
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2e9f:	8b 46 24             	mov    0x24(%esi),%eax
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2ea2:	ba 0b 00 00 00       	mov    $0xb,%edx
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
		SV(TATimer.flag)=true;
    2ea7:	c6 86 68 01 00 00 01 	movb   $0x1,0x168(%esi)
	//SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
	if(SV(TATimer.flag)==true)
	{//LHL 20141021TA
		fsm_printf("[UE MAC][TATimer_config]TATimer_config\n");//LHL for test 20141021
		fsm_schedule_cancel(SV(TATimer.timer_sign));
		SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    2eae:	89 86 60 01 00 00    	mov    %eax,0x160(%esi)
		SV(TATimer.flag)=true;
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100, TimeAlignmentTimer_Expire );
    2eb4:	6b c0 64             	imul   $0x64,%eax,%eax
    2eb7:	e8 fc ff ff ff       	call   2eb8 <ioctrl_handler+0x478>
    2ebc:	89 86 64 01 00 00    	mov    %eax,0x164(%esi)
		//SV(TA_timer_flag)=0;
	}//  
	fsm_data_destroy(tmpdata_ptr);
    2ec2:	89 f8                	mov    %edi,%eax
    2ec4:	e8 fc ff ff ff       	call   2ec5 <ioctrl_handler+0x485>
    2ec9:	e9 aa fb ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2ece:	66 90                	xchg   %ax,%ax
			fsm_printf("[MAC][RECVSYS]\n");
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_recv_sysinfo  , NULL, 0);
			//ioctrlRNTI
		break;
		case IOCCMD_RRCtoMAC_stop_recv_sysinfo : 
			fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_stop_recv_sysinfo , NULL, 0); 
    2ed0:	31 c9                	xor    %ecx,%ecx
    2ed2:	ba 27 00 00 00       	mov    $0x27,%edx
    2ed7:	b8 03 00 00 00       	mov    $0x3,%eax
    2edc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    2ee3:	e8 fc ff ff ff       	call   2ee4 <ioctrl_handler+0x4a4>
			//ioctrl
		break ;
    2ee8:	e9 8b fb ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2eed:	8d 76 00             	lea    0x0(%esi),%esi
			fsm_printf("\n[RLC][rlc_ioctrl_handler] MRLC_TRANSOP_IND  has received\n");
			PMRLC_TRANSOP_IND();
			FOUT;
			break;*/ //noted in 20150804
		case PRINTRLC:
			printk("\ncountRecvFromUpper =%d\n",SV(countRecvFromUpper));
    2ef0:	8b 86 8c 5a 00 00    	mov    0x5a8c(%esi),%eax
    2ef6:	c7 04 24 e4 00 00 00 	movl   $0xe4,(%esp)
    2efd:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f01:	e8 fc ff ff ff       	call   2f02 <ioctrl_handler+0x4c2>
			printk("countSentToLower =%d\n",SV(countSentToLower));
    2f06:	8b 86 98 5a 00 00    	mov    0x5a98(%esi),%eax
    2f0c:	c7 04 24 fd 00 00 00 	movl   $0xfd,(%esp)
    2f13:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f17:	e8 fc ff ff ff       	call   2f18 <ioctrl_handler+0x4d8>
			printk("countSendToUpper =%d\n",SV(countSendToUpper));
    2f1c:	8b 86 90 5a 00 00    	mov    0x5a90(%esi),%eax
    2f22:	c7 04 24 13 01 00 00 	movl   $0x113,(%esp)
    2f29:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f2d:	e8 fc ff ff ff       	call   2f2e <ioctrl_handler+0x4ee>
			printk("countRecvFromLower =%d\n",SV(countRecvFromLower));
    2f32:	8b 86 94 5a 00 00    	mov    0x5a94(%esi),%eax
    2f38:	c7 04 24 29 01 00 00 	movl   $0x129,(%esp)
    2f3f:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f43:	e8 fc ff ff ff       	call   2f44 <ioctrl_handler+0x504>
			printk("countSendCtrlPdu =%d\n",SV(countSendCtrlPdu));
    2f48:	8b 86 a0 5a 00 00    	mov    0x5aa0(%esi),%eax
    2f4e:	c7 04 24 41 01 00 00 	movl   $0x141,(%esp)
    2f55:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f59:	e8 fc ff ff ff       	call   2f5a <ioctrl_handler+0x51a>
			printk("countRecvCtrlPdu =%d\n",SV(countRecvCtrlPdu));
    2f5e:	8b 86 a4 5a 00 00    	mov    0x5aa4(%esi),%eax
    2f64:	c7 04 24 57 01 00 00 	movl   $0x157,(%esp)
    2f6b:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f6f:	e8 fc ff ff ff       	call   2f70 <ioctrl_handler+0x530>
			printk("countDropPacket =%d\n\n",SV(countDropPacket));
    2f74:	8b 86 9c 5a 00 00    	mov    0x5a9c(%esi),%eax
    2f7a:	c7 04 24 6d 01 00 00 	movl   $0x16d,(%esp)
    2f81:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f85:	e8 fc ff ff ff       	call   2f86 <ioctrl_handler+0x546>
			printk("maxQueueNum =%d\n\n",SV(max_queue_num));
    2f8a:	8b 86 a8 5a 00 00    	mov    0x5aa8(%esi),%eax
    2f90:	c7 04 24 83 01 00 00 	movl   $0x183,(%esp)
    2f97:	89 44 24 04          	mov    %eax,0x4(%esp)
    2f9b:	e8 fc ff ff ff       	call   2f9c <ioctrl_handler+0x55c>
			
			
			break;
    2fa0:	e9 d3 fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2fa5:	8d 76 00             	lea    0x0(%esi),%esi
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
			ue_mac_BCCH_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_PCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_pcchconfig]rrctomac_pcchconfig\n");
    2fa8:	c7 04 24 24 08 00 00 	movl   $0x824,(%esp)
    2faf:	e8 fc ff ff ff       	call   2fb0 <ioctrl_handler+0x570>
*/
static void ue_mac_PCCH_config()
{
	void *tmpdata_ptr;	
	FIN( ue_mac_PCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    2fb4:	e8 fc ff ff ff       	call   2fb5 <ioctrl_handler+0x575>
    2fb9:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();		
    2fbb:	e8 fc ff ff ff       	call   2fbc <ioctrl_handler+0x57c>
	SV(systemconfigInfo.PCCHConfigInfo) = *((struct PCCH_Config*)tmpdata_ptr);  //ioctrl
    2fc0:	8b 08                	mov    (%eax),%ecx
    2fc2:	8b 58 04             	mov    0x4(%eax),%ebx
    2fc5:	89 8e d8 00 00 00    	mov    %ecx,0xd8(%esi)
    2fcb:	89 9e dc 00 00 00    	mov    %ebx,0xdc(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    2fd1:	e8 fc ff ff ff       	call   2fd2 <ioctrl_handler+0x592>
    2fd6:	e9 9d fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    2fdb:	90                   	nop
    2fdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		case IOCCMD_RRCtoMAC_LCconfig   : 
			fsm_printf("[UEMAC][RRCTOMAC_lcconfig]rrctomac_lcconfig\n");
			ue_mac_logCh_config();
		break;
		case IOCCMD_RRCTOMAC_CONFIG_BCCH : 
			fsm_printf("[UEMAC][RRCTOMAC_bcchconfig]rrctomac_bcchconfig\n");
    2fe0:	c7 04 24 f0 07 00 00 	movl   $0x7f0,(%esp)
    2fe7:	e8 fc ff ff ff       	call   2fe8 <ioctrl_handler+0x5a8>
*/
static void ue_mac_BCCH_config()
{
	void *tmpdata_ptr;
	FIN(ue_mac_BCCH_config());
	SV_PTR_GET(rlc_mac_sv);
    2fec:	e8 fc ff ff ff       	call   2fed <ioctrl_handler+0x5ad>
    2ff1:	89 c6                	mov    %eax,%esi
	tmpdata_ptr = fsm_data_get();	
    2ff3:	e8 fc ff ff ff       	call   2ff4 <ioctrl_handler+0x5b4>
	SV(systemconfigInfo.BCCHConfigInfo)= *((struct BCCH_Config*)tmpdata_ptr);  //ioctrl 
    2ff8:	8b 10                	mov    (%eax),%edx
    2ffa:	89 96 e0 00 00 00    	mov    %edx,0xe0(%esi)
	fsm_data_destroy(tmpdata_ptr);//
    3000:	e8 fc ff ff ff       	call   3001 <ioctrl_handler+0x5c1>
    3005:	e9 6e fa ff ff       	jmp    2a78 <ioctrl_handler+0x38>
    300a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			tempulgrant=(UEPHY_TO_MAC_ULgrant *)tempdata_ptr;
			//fsm_printf("[LHL]TEMP ULGRANT:%d\n",tempulgrant->ulgrant.RIV);
			SV(recv_frame).frameNo=tempulgrant->frameNo;
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
    3010:	c7 86 f0 01 00 00 01 	movl   $0x1,0x1f0(%esi)
    3017:	00 00 00 
    301a:	e9 04 fc ff ff       	jmp    2c23 <ioctrl_handler+0x1e3>
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
				fsm_schedule_self(0, Contention_Success );
			}
			else if(SV(C_RNTI) && SV(sendmsg3) && !SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )
    301f:	83 be e8 01 00 00 02 	cmpl   $0x2,0x1e8(%esi)
    3026:	0f 85 24 fc ff ff    	jne    2c50 <ioctrl_handler+0x210>
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution fail\n");
    302c:	c7 04 24 d4 08 00 00 	movl   $0x8d4,(%esp)
    3033:	e8 fc ff ff ff       	call   3034 <ioctrl_handler+0x5f4>
				fsm_schedule_self(0, ContentionResolution_Fail );
    3038:	ba 05 00 00 00       	mov    $0x5,%edx
    303d:	31 c0                	xor    %eax,%eax
    303f:	e8 fc ff ff ff       	call   3040 <ioctrl_handler+0x600>
    3044:	e9 07 fc ff ff       	jmp    2c50 <ioctrl_handler+0x210>
			SV(recv_frame).subframeNo=tempulgrant->subframeNo;
			if(tempulgrant->m_rnti == SV(C_RNTI))
				 SV(pdcch_rnti)=1;//PDCCHm_RNTI
			if(SV(C_RNTI) && SV(sendmsg3) && SV(pdcch_rnti) && (SV(ratype.ra_type)==2) )//3//3GPPP121
			{
				fsm_printf("[UEMAC][ioctl_handler]UE MAC ULGRANT:Contention Resolution successfully\n");
    3049:	c7 04 24 88 08 00 00 	movl   $0x888,(%esp)
    3050:	e8 fc ff ff ff       	call   3051 <ioctrl_handler+0x611>
				fsm_schedule_self(0, Contention_Success );
    3055:	ba 06 00 00 00       	mov    $0x6,%edx
    305a:	31 c0                	xor    %eax,%eax
    305c:	e8 fc ff ff ff       	call   305d <ioctrl_handler+0x61d>
    3061:	e9 ea fb ff ff       	jmp    2c50 <ioctrl_handler+0x210>
    3066:	8d 76 00             	lea    0x0(%esi),%esi
    3069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003070 <doStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
static void doStartContentionBasedRandomAccessProcedure() //modified by HQ  20140419
{
    3070:	55                   	push   %ebp
    3071:	89 e5                	mov    %esp,%ebp
    3073:	83 ec 18             	sub    $0x18,%esp
    3076:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    3079:	89 75 f8             	mov    %esi,-0x8(%ebp)
    307c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    307f:	e8 fc ff ff ff       	call   3080 <doStartContentionBasedRandomAccessProcedure+0x10>
	FIN(doStartContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    3084:	e8 fc ff ff ff       	call   3085 <doStartContentionBasedRandomAccessProcedure+0x15>
    3089:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated));
    308b:	b8 02 00 00 00       	mov    $0x2,%eax
    3090:	e8 fc ff ff ff       	call   3091 <doStartContentionBasedRandomAccessProcedure+0x21>
    3095:	89 c6                	mov    %eax,%esi
	int mg3_buffer;
	//print_tran_info("[UEMAC][contention_ra]startCRA IDLE -> CRA");//testing code
	if(SV(PREAMBLE_TRANSMISSION_COUNTER )== 0)   //
    3097:	8b 43 14             	mov    0x14(%ebx),%eax
    309a:	85 c0                	test   %eax,%eax
    309c:	75 10                	jne    30ae <doStartContentionBasedRandomAccessProcedure+0x3e>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
    309e:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    30a5:	b0 01                	mov    $0x1,%al
    30a7:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    30ae:	89 44 24 04          	mov    %eax,0x4(%esp)
    30b2:	c7 04 24 f0 0a 00 00 	movl   $0xaf0,(%esp)
    30b9:	e8 fc ff ff ff       	call   30ba <doStartContentionBasedRandomAccessProcedure+0x4a>
*******************************
*/
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
    30be:	e8 fc ff ff ff       	call   30bf <doStartContentionBasedRandomAccessProcedure+0x4f>
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    30c3:	ba 01 00 00 00       	mov    $0x1,%edx
static u8 RandomlySelectRaPreamble()
{
	FIN(RandomlySelectRaPreamble());
	SV_PTR_GET(rlc_mac_sv);
	u8 raPreambleID;
	u8 NumberOfRA_Preambles=(SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles));
    30c8:	0f b6 b8 ac 00 00 00 	movzbl 0xac(%eax),%edi
	fsm_get_random_bytes(&raPreambleID , sizeof(char));
    30cf:	8d 45 f3             	lea    -0xd(%ebp),%eax
    30d2:	e8 fc ff ff ff       	call   30d3 <doStartContentionBasedRandomAccessProcedure+0x63>
	raPreambleID = raPreambleID%NumberOfRA_Preambles;
    30d7:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    30db:	89 fa                	mov    %edi,%edx
    30dd:	f6 f2                	div    %dl
    30df:	0f b6 c4             	movzbl %ah,%eax
    30e2:	88 45 f3             	mov    %al,-0xd(%ebp)
		SV(PREAMBLE_TRANSMISSION_COUNTER )=1; //PREAMBLE_TRANSMISSION_COUNTER1 
		SV(backoff_index) = 0;  //UEbackoff0ms    
		mg3_buffer=0;   //MSG3//
	}
	fsm_printf("[UEMAC][contention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
	randomaccess_info->ra_PreambleIndex=RandomlySelectRaPreamble();//rapreamble
    30e5:	88 06                	mov    %al,(%esi)
	SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//rapid,RAR //HQ 20140506 
    30e7:	88 43 04             	mov    %al,0x4(%ebx)
	
	/*for test*/
	//randomaccess_info->ra_PreambleIndex=2;//for test 20141103
	//SV(RA_info.ra_PreambleIndex)=randomaccess_info->ra_PreambleIndex;//for test20141103
	/*for test*/
	fsm_printf("[UEMAC][contention_ra]MAC ra_PreambleIndex:%d\n",SV(RA_info.ra_PreambleIndex));//test code
    30ea:	0f b6 c0             	movzbl %al,%eax
    30ed:	89 44 24 04          	mov    %eax,0x4(%esp)
    30f1:	c7 04 24 18 0b 00 00 	movl   $0xb18,(%esp)
    30f8:	e8 fc ff ff ff       	call   30f9 <doStartContentionBasedRandomAccessProcedure+0x89>
	/*randomaccess_info->ra_PRACHMaskIndex=0;
	SV(RA_info.ra_PRACHMaskIndex)=randomaccess_info->ra_PRACHMaskIndex;*/
	SendRaPreamble(randomaccess_info);//
    30fd:	89 f0                	mov    %esi,%eax
    30ff:	e8 fc f8 ff ff       	call   2a00 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    3104:	e8 87 f5 ff ff       	call   2690 <StartWaitingForRaResponse>
	FOUT;
}
    3109:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    310c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    310f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    3112:	89 ec                	mov    %ebp,%esp
    3114:	5d                   	pop    %ebp
    3115:	c3                   	ret    
    3116:	8d 76 00             	lea    0x0(%esi),%esi
    3119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003120 <reports_handler>:
->output:
->Special:
*******************************
*/
static void reports_handler()
{
    3120:	55                   	push   %ebp
    3121:	89 e5                	mov    %esp,%ebp
    3123:	53                   	push   %ebx
    3124:	83 ec 04             	sub    $0x4,%esp
    3127:	e8 fc ff ff ff       	call   3128 <reports_handler+0x8>
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    312c:	e8 fc ff ff ff       	call   312d <reports_handler+0xd>
    3131:	83 f8 03             	cmp    $0x3,%eax
    3134:	74 4a                	je     3180 <reports_handler+0x60>
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    3136:	e8 fc ff ff ff       	call   3137 <reports_handler+0x17>
    313b:	83 f8 03             	cmp    $0x3,%eax
    313e:	66 90                	xchg   %ax,%ax
    3140:	74 06                	je     3148 <reports_handler+0x28>
		handle_RetxBSRTimerExpire();
	//PHR 
FOUT;
}
    3142:	83 c4 04             	add    $0x4,%esp
    3145:	5b                   	pop    %ebx
    3146:	5d                   	pop    %ebp
    3147:	c3                   	ret    
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
		handle_PeriodicBSRTimerExpire();
	if(RexBSRTimerExpire)
    3148:	e8 fc ff ff ff       	call   3149 <reports_handler+0x29>
    314d:	83 f8 0d             	cmp    $0xd,%eax
    3150:	75 f0                	jne    3142 <reports_handler+0x22>
->Special:
*******************************
*/
static void handle_RetxBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    3152:	e8 fc ff ff ff       	call   3153 <reports_handler+0x33>
    3157:	89 c3                	mov    %eax,%ebx
	FIN(handle_RetxBSRTimerExpire());
	DoProduceBsr_RetxBSRTimer();
    3159:	e8 fc ff ff ff       	call   315a <reports_handler+0x3a>
	SV(RetxBSRTimer.timer_sign) = NULL;
    315e:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3165:	00 00 00 
	SV(RetxBSRTimer.flag) = false;	
    3168:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	fsm_printf("[UEMAC][handle_retxbsrtimer]handle RetxBSRTimer expire\n");//testing code 
    316f:	c7 04 24 88 0b 00 00 	movl   $0xb88,(%esp)
    3176:	e8 fc ff ff ff       	call   3177 <reports_handler+0x57>
    317b:	eb c5                	jmp    3142 <reports_handler+0x22>
    317d:	8d 76 00             	lea    0x0(%esi),%esi
*******************************
*/
static void reports_handler()
{
	FIN(reports_handler());
	if(PeriodicBSRTimerExpire)
    3180:	e8 fc ff ff ff       	call   3181 <reports_handler+0x61>
    3185:	83 f8 0c             	cmp    $0xc,%eax
    3188:	75 ac                	jne    3136 <reports_handler+0x16>
->Special:
*******************************
*/
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
    318a:	e8 fc ff ff ff       	call   318b <reports_handler+0x6b>
    318f:	89 c3                	mov    %eax,%ebx
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
    3191:	e8 fc ff ff ff       	call   3192 <reports_handler+0x72>
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    3196:	ba 0c 00 00 00       	mov    $0xc,%edx
static void handle_PeriodicBSRTimerExpire()
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
    319b:	6b 43 64 64          	imul   $0x64,0x64(%ebx),%eax
    319f:	89 83 84 01 00 00    	mov    %eax,0x184(%ebx)
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    31a5:	e8 fc ff ff ff       	call   31a6 <reports_handler+0x86>
	SV(PeriodicBSRTimer).flag = true;
    31aa:	c6 83 8c 01 00 00 01 	movb   $0x1,0x18c(%ebx)
{
	SV_PTR_GET(rlc_mac_sv);
	FIN(handle_PeriodicBSRTimerExpire());
	DoProduceBsr_PeriodicBSRTimer();//periodic BSR
	SV(PeriodicBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)*100;
	SV(PeriodicBSRTimer).timer_sign = fsm_schedule_self(SV(PeriodicBSRTimer).time_value,PeriodicBSRTimer_Expire);
    31b1:	89 83 88 01 00 00    	mov    %eax,0x188(%ebx)
	SV(PeriodicBSRTimer).flag = true;
	fsm_printf("[UEMAC][handle_periodicbsrtimer]handle PeriodicBSRTimer expire\n");//testing code 
    31b7:	c7 04 24 48 0b 00 00 	movl   $0xb48,(%esp)
    31be:	e8 fc ff ff ff       	call   31bf <reports_handler+0x9f>
    31c3:	e9 6e ff ff ff       	jmp    3136 <reports_handler+0x16>
    31c8:	90                   	nop
    31c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000031d0 <send_msg3>:
->output:
->Special:
*******************************
*/
void send_msg3(FSM_PKT *skb) //defined by HQ 20140430  
{
    31d0:	55                   	push   %ebp
    31d1:	89 e5                	mov    %esp,%ebp
    31d3:	56                   	push   %esi
    31d4:	53                   	push   %ebx
    31d5:	83 ec 08             	sub    $0x8,%esp
    31d8:	e8 fc ff ff ff       	call   31d9 <send_msg3+0x9>
    31dd:	89 c6                	mov    %eax,%esi
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	//FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    31df:	e8 fc ff ff ff       	call   31e0 <send_msg3+0x10>
    31e4:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    31e6:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    31ec:	c7 04 24 c0 0b 00 00 	movl   $0xbc0,(%esp)
    31f3:	89 44 24 04          	mov    %eax,0x4(%esp)
    31f7:	e8 fc ff ff ff       	call   31f8 <send_msg3+0x28>
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    31fc:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    3202:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC][send_msg3]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    3208:	83 fa 01             	cmp    $0x1,%edx
    320b:	74 3b                	je     3248 <send_msg3+0x78>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    320d:	85 c0                	test   %eax,%eax
    320f:	74 09                	je     321a <send_msg3+0x4a>
    3211:	83 fa 02             	cmp    $0x2,%edx
    3214:	0f 84 a6 00 00 00    	je     32c0 <send_msg3+0xf0>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    321a:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    3220:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    3225:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    322b:	6b c0 64             	imul   $0x64,%eax,%eax
    322e:	e8 fc ff ff ff       	call   322f <send_msg3+0x5f>
	SV(CRTimer.flag)=true;
    3233:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    323a:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	SV(CRTimer.flag)=true;
	FOUT;
}
    3240:	83 c4 08             	add    $0x8,%esp
    3243:	5b                   	pop    %ebx
    3244:	5e                   	pop    %esi
    3245:	5d                   	pop    %ebp
    3246:	c3                   	ret    
    3247:	90                   	nop
		fsm_skb_reserve(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    3248:	85 c0                	test   %eax,%eax
    324a:	74 05                	je     3251 <send_msg3+0x81>
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    324c:	e8 fc ff ff ff       	call   324d <send_msg3+0x7d>
		SV(msg3_buf_ptr)=skb;//3
    3251:	89 b3 e4 01 00 00    	mov    %esi,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3257:	89 f0                	mov    %esi,%eax
    3259:	e8 fc ff ff ff       	call   325a <send_msg3+0x8a>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    325e:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    3263:	89 c6                	mov    %eax,%esi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    3265:	e8 fc ff ff ff       	call   3266 <send_msg3+0x96>
    326a:	85 c0                	test   %eax,%eax
    326c:	74 1a                	je     3288 <send_msg3+0xb8>
    326e:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    3272:	74 14                	je     3288 <send_msg3+0xb8>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3274:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    327b:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3282:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
		complexUeMacPdu(skb);
    3288:	89 f0                	mov    %esi,%eax
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    328a:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    3291:	00 00 00 
		complexUeMacPdu(skb);
    3294:	e8 fc ff ff ff       	call   3295 <send_msg3+0xc5>
		
	
		if(SV(Tbsize_Complex)!=0)
    3299:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    329f:	85 c0                	test   %eax,%eax
    32a1:	74 0a                	je     32ad <send_msg3+0xdd>
			SV(Tbsize_Complex)=0;//TBSIZE
    32a3:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    32aa:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    32ad:	c7 04 24 ec 0b 00 00 	movl   $0xbec,(%esp)
    32b4:	e8 fc ff ff ff       	call   32b5 <send_msg3+0xe5>
    32b9:	e9 5c ff ff ff       	jmp    321a <send_msg3+0x4a>
    32be:	66 90                	xchg   %ax,%ax
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32c0:	e8 fc ff ff ff       	call   32c1 <send_msg3+0xf1>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32c5:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    32ca:	89 c6                	mov    %eax,%esi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    32cc:	e8 fc ff ff ff       	call   32cd <send_msg3+0xfd>
    32d1:	85 c0                	test   %eax,%eax
    32d3:	74 06                	je     32db <send_msg3+0x10b>
    32d5:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    32d9:	75 3d                	jne    3318 <send_msg3+0x148>
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
		complexUeMacPdu(skb); 	
    32db:	89 f0                	mov    %esi,%eax
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
		}
		SV(sendmsg3)=1;	
    32dd:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    32e4:	00 00 00 
		complexUeMacPdu(skb); 	
    32e7:	e8 fc ff ff ff       	call   32e8 <send_msg3+0x118>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    32ec:	8b 83 f4 01 00 00    	mov    0x1f4(%ebx),%eax
    32f2:	85 c0                	test   %eax,%eax
    32f4:	74 0a                	je     3300 <send_msg3+0x130>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    32f6:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    32fd:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    3300:	c7 04 24 24 0c 00 00 	movl   $0xc24,(%esp)
    3307:	e8 fc ff ff ff       	call   3308 <send_msg3+0x138>
    330c:	e9 09 ff ff ff       	jmp    321a <send_msg3+0x4a>
    3311:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    3318:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    331f:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    3326:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
    332c:	eb ad                	jmp    32db <send_msg3+0x10b>
    332e:	66 90                	xchg   %ax,%ax

00003330 <print_tran_info>:
->output:
->Special:
*******************************
*/
void print_tran_info( const char *str)
{
    3330:	55                   	push   %ebp
    3331:	89 e5                	mov    %esp,%ebp
    3333:	53                   	push   %ebx
    3334:	83 ec 04             	sub    $0x4,%esp
    3337:	e8 fc ff ff ff       	call   3338 <print_tran_info+0x8>
    333c:	89 c3                	mov    %eax,%ebx
	FIN( print_tran_info());
	int curtime=0;
	curtime=fsm_get_curtime();
    333e:	e8 fc ff ff ff       	call   333f <print_tran_info+0xf>
	//fsm_printf("[UEMAC][print_info]%d ",curtime);
	fsm_printf(str);
    3343:	89 1c 24             	mov    %ebx,(%esp)
    3346:	e8 fc ff ff ff       	call   3347 <print_tran_info+0x17>
	fsm_printf("\n");
    334b:	c7 04 24 95 01 00 00 	movl   $0x195,(%esp)
    3352:	e8 fc ff ff ff       	call   3353 <print_tran_info+0x23>
	FOUT;
}
    3357:	83 c4 04             	add    $0x4,%esp
    335a:	5b                   	pop    %ebx
    335b:	5d                   	pop    %ebp
    335c:	c3                   	ret    
    335d:	8d 76 00             	lea    0x0(%esi),%esi

00003360 <handle_timeAlignmentTimerExpire>:
->output:
->Special:
*******************************
*/
static void handle_timeAlignmentTimerExpire()
{
    3360:	55                   	push   %ebp
    3361:	89 e5                	mov    %esp,%ebp
    3363:	e8 fc ff ff ff       	call   3364 <handle_timeAlignmentTimerExpire+0x4>
	FIN(handle_timeAlignmentTimerExpire());  
	SV_PTR_GET(rlc_mac_sv);
    3368:	e8 fc ff ff ff       	call   3369 <handle_timeAlignmentTimerExpire+0x9>
	SV(TATimer.time_value)=0;
    336d:	c7 80 60 01 00 00 00 	movl   $0x0,0x160(%eax)
    3374:	00 00 00 
	SV(TATimer.flag)=false;//
    3377:	c6 80 68 01 00 00 00 	movb   $0x0,0x168(%eax)
	SV(TATimer.timer_sign)=NULL;
    337e:	c7 80 64 01 00 00 00 	movl   $0x0,0x164(%eax)
    3385:	00 00 00 
	cleanharqBuff(); //HARQ
	//fsm_do_ioctrl(STRM_TO_IP, IOCCMD_MACtoRRC_PUCCHSRS_release  , NULL , 0);  //RRCPUCCH/SRS
	//
	SV(UL_resource_info.resource_flag)=false;//
    3388:	c6 40 28 00          	movb   $0x0,0x28(%eax)
	SV(UL_resource_info.m_tbsize)=0;
    338c:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
											//??? 
	print_tran_info("[UEMAC][handle_tatimer]LostUL"); //testing code 
    3393:	b8 97 01 00 00       	mov    $0x197,%eax
    3398:	e8 fc ff ff ff       	call   3399 <handle_timeAlignmentTimerExpire+0x39>
	FOUT;
}
    339d:	5d                   	pop    %ebp
    339e:	c3                   	ret    
    339f:	90                   	nop

000033a0 <random_test>:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
{
    33a0:	55                   	push   %ebp
    33a1:	89 e5                	mov    %esp,%ebp
    33a3:	56                   	push   %esi
    33a4:	53                   	push   %ebx
    33a5:	83 ec 18             	sub    $0x18,%esp
    33a8:	e8 fc ff ff ff       	call   33a9 <random_test+0x9>
    33ad:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    33b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    33b6:	31 c0                	xor    %eax,%eax
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    33b8:	8d 5d ea             	lea    -0x16(%ebp),%ebx
void random_test()   //HQ 20140410 0-63
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    33bb:	c7 04 24 5c 0c 00 00 	movl   $0xc5c,(%esp)
->input:
->output:
->Special:
*******************************
*/
void random_test()   //HQ 20140410 0-63
    33c2:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");
    33c5:	e8 fc ff ff ff       	call   33c6 <random_test+0x26>
    33ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	for (i=0; i<10; i++)
	{
		fsm_get_random_bytes(&randNum[i], sizeof(char));
    33d0:	89 d8                	mov    %ebx,%eax
    33d2:	ba 01 00 00 00       	mov    $0x1,%edx
    33d7:	e8 fc ff ff ff       	call   33d8 <random_test+0x38>
		randNum[i]=randNum[i]%64;
    33dc:	0f b6 03             	movzbl (%ebx),%eax
    33df:	83 e0 3f             	and    $0x3f,%eax
    33e2:	88 03                	mov    %al,(%ebx)
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
    33e4:	0f b6 c0             	movzbl %al,%eax
    33e7:	83 c3 01             	add    $0x1,%ebx
    33ea:	89 44 24 04          	mov    %eax,0x4(%esp)
    33ee:	c7 04 24 8c 0c 00 00 	movl   $0xc8c,(%esp)
    33f5:	e8 fc ff ff ff       	call   33f6 <random_test+0x56>
	FIN(random_test());
	u8 randNum[10];
	u32 i = 0;
	fsm_printf( "[UEMAC][ra_test]:Get some real random number.\n");

	for (i=0; i<10; i++)
    33fa:	39 f3                	cmp    %esi,%ebx
    33fc:	75 d2                	jne    33d0 <random_test+0x30>
		fsm_get_random_bytes(&randNum[i], sizeof(char));
		randNum[i]=randNum[i]%64;
		fsm_printf("[UEMAC][ra_test]:We get random number: %d\n", randNum[i]);//testing code
	} 
	FOUT;
}
    33fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3401:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
    3408:	75 07                	jne    3411 <random_test+0x71>
    340a:	83 c4 18             	add    $0x18,%esp
    340d:	5b                   	pop    %ebx
    340e:	5e                   	pop    %esi
    340f:	5d                   	pop    %ebp
    3410:	c3                   	ret    
    3411:	e8 fc ff ff ff       	call   3412 <random_test+0x72>
    3416:	8d 76 00             	lea    0x0(%esi),%esi
    3419:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003420 <RA_RRCconfig_testingfun>:
->output:
->Special:
*******************************
*/
void RA_RRCconfig_testingfun() // RRC HQ 20140428 
{
    3420:	55                   	push   %ebp
    3421:	89 e5                	mov    %esp,%ebp
    3423:	83 ec 04             	sub    $0x4,%esp
    3426:	e8 fc ff ff ff       	call   3427 <RA_RRCconfig_testingfun+0x7>
	FIN(RA_RRCconfig_testingfun());
	SV_PTR_GET(rlc_mac_sv);
    342b:	e8 fc ff ff ff       	call   342c <RA_RRCconfig_testingfun+0xc>
	SV(systemconfigInfo.RACHCommonConfigInfo.preambleInfo.numberOfRA_Preambles)= 64;
    3430:	c7 80 ac 00 00 00 40 	movl   $0x40,0xac(%eax)
    3437:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax)=8;
    343a:	c7 80 c8 00 00 00 08 	movl   $0x8,0xc8(%eax)
    3441:	00 00 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.raResponseWindowSize)=800000;//8; 800s
    3444:	c7 80 cc 00 00 00 00 	movl   $0xc3500,0xcc(%eax)
    344b:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer)=800000;// 800s;
    344e:	c7 80 d0 00 00 00 00 	movl   $0xc3500,0xd0(%eax)
    3455:	35 0c 00 
	SV(systemconfigInfo.RACHCommonConfigInfo.maxHARQ_Msg3Tx)=5;
    3458:	c7 80 d4 00 00 00 05 	movl   $0x5,0xd4(%eax)
    345f:	00 00 00 
	SV(backoff_index)= 2 ; 
    3462:	c7 40 1c 02 00 00 00 	movl   $0x2,0x1c(%eax)
	fsm_printf("[UEMAC][ra_rrcconfig]:RACH config have done \n");//testing code
    3469:	c7 04 24 b8 0c 00 00 	movl   $0xcb8,(%esp)
    3470:	e8 fc ff ff ff       	call   3471 <RA_RRCconfig_testingfun+0x51>
	FOUT;
}
    3475:	c9                   	leave  
    3476:	c3                   	ret    
    3477:	89 f6                	mov    %esi,%esi
    3479:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003480 <ue_mac_sv_init>:
->output:
->Special:
*******************************
*/
static void ue_mac_sv_init()
{
    3480:	55                   	push   %ebp
    3481:	89 e5                	mov    %esp,%ebp
    3483:	57                   	push   %edi
    3484:	56                   	push   %esi
    3485:	53                   	push   %ebx
    3486:	83 ec 08             	sub    $0x8,%esp
    3489:	e8 fc ff ff ff       	call   348a <ue_mac_sv_init+0xa>
	FIN(ue_mac_sv_init());
	int len;
	
	SV_PTR_GET(rlc_mac_sv);
    348e:	e8 fc ff ff ff       	call   348f <ue_mac_sv_init+0xf>
    3493:	89 c3                	mov    %eax,%ebx
	print_tran_info("FSM INIT-init SV");//testing code
    3495:	b8 b5 01 00 00       	mov    $0x1b5,%eax
    349a:	e8 fc ff ff ff       	call   349b <ue_mac_sv_init+0x1b>
	SV(TA_Periodic_time)=800000000;//testing code ,
    349f:	c7 43 24 00 08 af 2f 	movl   $0x2faf0800,0x24(%ebx)
	Init_Uemac_Scheduler();
    34a6:	e8 fc ff ff ff       	call   34a7 <ue_mac_sv_init+0x27>
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    34ab:	b8 06 00 00 00       	mov    $0x6,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("FSM INIT-init SV");//testing code
	SV(TA_Periodic_time)=800000000;//testing code ,
	Init_Uemac_Scheduler();
	SV(sys_frame.frameNo)=0;//modified LHL 20141105
    34b0:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
	SV(sys_frame.subframeNo)=0;
    34b6:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
	SV(recv_frame).subframeNo=0;//
    34bc:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	SV(recv_frame).frameNo=0;
    34c2:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
	SV(ue_schedule_frame.frameNo)=0;
    34c8:	66 c7 43 0e 00 00    	movw   $0x0,0xe(%ebx)
	SV(ue_schedule_frame.subframeNo)=0;
    34ce:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
    34d4:	66 c7 43 22 00 00    	movw   $0x0,0x22(%ebx)
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    34da:	e8 fc ff ff ff       	call   34db <ue_mac_sv_init+0x5b>
	//
	
	SV(TATimer.time_value) = 0;
    34df:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    34e6:	00 00 00 
	SV(TATimer.timer_sign) = NULL;
    34e9:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    34f0:	00 00 00 
	SV(TATimer.flag) = false;
    34f3:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
	SV(CRTimer.time_value) = 0;
    34fa:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    3501:	00 00 00 
	SV(CRTimer.timer_sign) = NULL;
    3504:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    350b:	00 00 00 
	SV(ue_schedule_frame.frameNo)=0;
	SV(ue_schedule_frame.subframeNo)=0;
	//SV(flag123)=0;//LHL test 0924
	//SV(TA_fromRAR)=0;
	SV(TA_value)=0;//LHL 20141021
	SV(m_temp_cr)=(temp_contention_resolution*)fsm_mem_alloc(sizeof(temp_contention_resolution));
    350e:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	SV(TATimer.time_value) = 0;
	SV(TATimer.timer_sign) = NULL;
	SV(TATimer.flag) = false;
	SV(CRTimer.time_value) = 0;
	SV(CRTimer.timer_sign) = NULL;
	SV(CRTimer.flag) = false;
    3514:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
	SV(RetxBSRTimer.time_value) = 0;
    351b:	c7 83 78 01 00 00 00 	movl   $0x0,0x178(%ebx)
    3522:	00 00 00 
	SV(RetxBSRTimer.timer_sign) = NULL;
    3525:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    352c:	00 00 00 
	SV(RetxBSRTimer.flag) = false;
    352f:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
	SV(PeriodicBSRTimer.time_value) = 0;
    3536:	c7 83 84 01 00 00 00 	movl   $0x0,0x184(%ebx)
    353d:	00 00 00 
	SV(PeriodicBSRTimer.timer_sign) = NULL;
    3540:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    3547:	00 00 00 
	SV(PeriodicBSRTimer.flag) = false;	
    354a:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
	SV(WaitforRAresponseTimer.time_value) = 0;
    3551:	c7 83 90 01 00 00 00 	movl   $0x0,0x190(%ebx)
    3558:	00 00 00 
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
    355b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    3562:	00 00 00 
	SV(WaitforRAresponseTimer.flag) = false;
    3565:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
	SV(msg3_buf_ptr) = NULL;	
    356c:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    3573:	00 00 00 
	SV(ra_allocation_res)=0;
    3576:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    357d:	00 00 00 
*******************************
*/
static void macmain_defaultconfig()
{
	FIN(macmain_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    3580:	e8 fc ff ff ff       	call   3581 <ue_mac_sv_init+0x101>
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx) = maxHARQ_Tx_n5;
    3585:	c7 40 60 05 00 00 00 	movl   $0x5,0x60(%eax)
	//fsm_printf("test maxHARQTX:%d \n ",SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.maxHARQ_Tx));//testing code
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.periodicBSR_Timer)= periodicBSR_Timer_infinity;//
    358c:	c7 40 64 ff ff ff ff 	movl   $0xffffffff,0x64(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)= retxBSR_Timer_sf2560 ;
    3593:	c7 40 68 00 0a 00 00 	movl   $0xa00,0x68(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.ttiBundling)= false ;
    359a:	c6 40 6c 00          	movb   $0x0,0x6c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.drx_Config.choice.setup.haveShortDRX)= false ;//means release
    359e:	c6 80 8c 00 00 00 00 	movb   $0x0,0x8c(%eax)
	SV(systemconfigInfo.MACMainConfigInfo.type)= 1 ; //means phr-Config release ??  
    35a5:	c7 80 9c 00 00 00 01 	movl   $0x1,0x9c(%eax)
    35ac:	00 00 00 
*******************************
*/
static void sps_defaultconfig()
{
	FIN(sps_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    35af:	e8 fc ff ff ff       	call   35b0 <ue_mac_sv_init+0x130>
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigDL)=false;
    35b4:	c6 80 e8 00 00 00 00 	movb   $0x0,0xe8(%eax)
	SV(systemconfigInfo.SPSConfigInfo.haveSPS_ConfigUL)=false; 
    35bb:	c6 80 08 01 00 00 00 	movb   $0x0,0x108(%eax)
*******************************
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
    35c2:	e8 fc ff ff ff       	call   35c3 <ue_mac_sv_init+0x143>
    35c7:	89 c7                	mov    %eax,%edi
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    35c9:	b8 15 00 00 00       	mov    $0x15,%eax
    35ce:	e8 fc ff ff ff       	call   35cf <ue_mac_sv_init+0x14f>
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    35d3:	8d 97 28 01 00 00    	lea    0x128(%edi),%edx
    35d9:	b9 15 00 00 00       	mov    $0x15,%ecx
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
    35de:	c7 87 28 01 00 00 00 	movl   $0x0,0x128(%edi)
    35e5:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
    35e8:	c6 87 2c 01 00 00 01 	movb   $0x1,0x12c(%edi)
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
    35ef:	c7 87 2d 01 00 00 01 	movl   $0x1,0x12d(%edi)
    35f6:	00 00 00 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
    35f9:	c7 87 31 01 00 00 ff 	movl   $0xffffffff,0x131(%edi)
    3600:	ff ff ff 
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
    3603:	c7 87 39 01 00 00 00 	movl   $0x0,0x139(%edi)
    360a:	00 00 00 
*/
static void CCCH_defaultconfig()
{
	FIN(CCCH_defaultconfig());
	SV_PTR_GET(rlc_mac_sv);
	MAC_LogicalChannelConfig_IoctrlMsg *ccch_info=(MAC_LogicalChannelConfig_IoctrlMsg *)fsm_mem_alloc(sizeof(MAC_LogicalChannelConfig_IoctrlMsg));
    360d:	89 c6                	mov    %eax,%esi
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelIdentity)=0;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.haveUl_SpecificParameters)=true;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.priority)=1;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.prioritisedBitRate)= infinity;
	SV(systemconfigInfo.CCCHConfigInfo.logicalChannelConfig.ul_SpecificParameters.logicalChannelGroup)= 0;
	fsm_mem_cpy(ccch_info, &SV(systemconfigInfo.CCCHConfigInfo),sizeof(MAC_LogicalChannelConfig_IoctrlMsg));  
    360f:	e8 fc ff ff ff       	call   3610 <ue_mac_sv_init+0x190>
	Init_LogicalChannel_ConfigInfo(ccch_info); 
    3614:	89 f0                	mov    %esi,%eax
    3616:	e8 fc ff ff ff       	call   3617 <ue_mac_sv_init+0x197>
	fsm_mem_free(ccch_info);//
    361b:	89 f0                	mov    %esi,%eax
    361d:	e8 fc ff ff ff       	call   361e <ue_mac_sv_init+0x19e>
	fsm_printf("[UEMAC][init]CCCH_defaultconfig completed\n");
    3622:	c7 04 24 e8 0c 00 00 	movl   $0xce8,(%esp)
    3629:	e8 fc ff ff ff       	call   362a <ue_mac_sv_init+0x1aa>
	SV(WaitforRAresponseTimer.timer_sign) = NULL;
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
    362e:	e8 fc ff ff ff       	call   362f <ue_mac_sv_init+0x1af>
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    3633:	b9 04 00 00 00       	mov    $0x4,%ecx
    3638:	31 d2                	xor    %edx,%edx
	SV(WaitforRAresponseTimer.flag) = false;
	SV(msg3_buf_ptr) = NULL;	
	SV(ra_allocation_res)=0;
	defaultconfig();//
	RA_RRCconfig_testingfun(); // RRC
	SV(UL_resource_info.resource_flag)= false; //testing code
    363a:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
    363e:	8d 83 e8 01 00 00    	lea    0x1e8(%ebx),%eax
    3644:	e8 fc ff ff ff       	call   3645 <ue_mac_sv_init+0x1c5>
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    3649:	b8 0c 00 00 00       	mov    $0xc,%eax
	SV(UL_resource_info.resource_flag)= false; //testing code
	//SV(UL_resource_info.m_tbsize)= 2400;//bit//testing code 
	//SV(C_RNTI) = 11;
	//
	fsm_mem_set(&SV(ratype),0,sizeof(RA_Type));
	SV(sendmsg3)=0;//0:MSG31:MSG3
    364e:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    3655:	00 00 00 
	SV(pdcch_rnti)=0;//0:PDCCHC_RNTI1:C_RNTI
    3658:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    365f:	00 00 00 
	SV(Tbsize_Complex)=0;//modified by lhl ,20140718,to 
    3662:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    3669:	00 00 00 
	//test_init_logicalchannel(1);//TEST 20141103
	//test_init_logicalchannel(3);//TEST 20141103
	SV(contention_failed_num)=0;
    366c:	c7 83 00 02 00 00 00 	movl   $0x0,0x200(%ebx)
    3673:	00 00 00 
	SV(rar_failed_num)=0;
    3676:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
    367d:	00 00 00 
	
	SV(lost_pkt_num_uplink)=0;
    3680:	c7 83 04 02 00 00 00 	movl   $0x0,0x204(%ebx)
    3687:	00 00 00 
	SV(pkt_num_uplink)=0;
    368a:	c7 83 08 02 00 00 00 	movl   $0x0,0x208(%ebx)
    3691:	00 00 00 
	SV(lost_pkt_num_downlink)=0;
    3694:	c7 83 0c 02 00 00 00 	movl   $0x0,0x20c(%ebx)
    369b:	00 00 00 
	SV(pkt_num_downlink)=0;
    369e:	c7 83 10 02 00 00 00 	movl   $0x0,0x210(%ebx)
    36a5:	00 00 00 
	
	SV(countSendToUpper)=0;
    36a8:	c7 83 90 5a 00 00 00 	movl   $0x0,0x5a90(%ebx)
    36af:	00 00 00 
	SV(countRecvFromLower)=0;
    36b2:	c7 83 94 5a 00 00 00 	movl   $0x0,0x5a94(%ebx)
    36b9:	00 00 00 
	SV(countreceive_from_mac)=0;
    36bc:	c7 83 88 5a 00 00 00 	movl   $0x0,0x5a88(%ebx)
    36c3:	00 00 00 
	FSM_EXIT(0)
}

static void InitQueue(CraQueuePtr *Q)
{
	*Q = (CraQueue *)fsm_mem_alloc(sizeof(CraQueue));
    36c6:	e8 fc ff ff ff       	call   36c7 <ue_mac_sv_init+0x247>
    36cb:	89 c6                	mov    %eax,%esi
    36cd:	89 83 14 02 00 00    	mov    %eax,0x214(%ebx)
	(*Q)->front = (*Q)->rear = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    36d3:	b8 08 00 00 00       	mov    $0x8,%eax
    36d8:	e8 fc ff ff ff       	call   36d9 <ue_mac_sv_init+0x259>
    36dd:	89 46 04             	mov    %eax,0x4(%esi)
    36e0:	89 06                	mov    %eax,(%esi)
	// Q->front = NULL;
	// Q->rear = NULL;
	(*Q)->pkt_count = 0;
    36e2:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    36e8:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
	fsm_printf("[InitQueue]Q point: %p\n", *Q);
    36ee:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    36f4:	c7 04 24 c6 01 00 00 	movl   $0x1c6,(%esp)
    36fb:	89 44 24 04          	mov    %eax,0x4(%esp)
    36ff:	e8 fc ff ff ff       	call   3700 <ue_mac_sv_init+0x280>
	SV(countSendToUpper)=0;
	SV(countRecvFromLower)=0;
	SV(countreceive_from_mac)=0;

	InitQueue(&SV(CraQueue));	//add cra queue initialization by LXR in 20151020
	fsm_printf("[ue_mac_sv_init]SV(CraQueue): %p\n", SV(CraQueue));
    3704:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    370a:	c7 04 24 14 0d 00 00 	movl   $0xd14,(%esp)
    3711:	89 44 24 04          	mov    %eax,0x4(%esp)
    3715:	e8 fc ff ff ff       	call   3716 <ue_mac_sv_init+0x296>
	
	FOUT;
}
    371a:	83 c4 08             	add    $0x8,%esp
    371d:	5b                   	pop    %ebx
    371e:	5e                   	pop    %esi
    371f:	5f                   	pop    %edi
    3720:	5d                   	pop    %ebp
    3721:	c3                   	ret    
    3722:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    3729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00003730 <testdoStartContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartContentionBasedRandomAccessProcedure()
{
    3730:	55                   	push   %ebp
    3731:	89 e5                	mov    %esp,%ebp
    3733:	e8 fc ff ff ff       	call   3734 <testdoStartContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> CRA");
    3738:	b8 de 01 00 00       	mov    $0x1de,%eax
    373d:	e8 fc ff ff ff       	call   373e <testdoStartContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	//fsm_schedule_self(100000, RandomAcc_Fail );//testing code
	FOUT;
}
    3742:	5d                   	pop    %ebp
    3743:	c3                   	ret    
    3744:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    374a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003750 <testdoStartNonContentionBasedRandomAccessProcedure>:
->output:
->Special:
*******************************
*/
void testdoStartNonContentionBasedRandomAccessProcedure() // 
{
    3750:	55                   	push   %ebp
    3751:	89 e5                	mov    %esp,%ebp
    3753:	e8 fc ff ff ff       	call   3754 <testdoStartNonContentionBasedRandomAccessProcedure+0x4>
	FIN(testdoStartNonContentionBasedRandomAccessProcedure());
	print_tran_info("IDLE -> NCRA");
    3758:	b8 ea 01 00 00       	mov    $0x1ea,%eax
    375d:	e8 fc ff ff ff       	call   375e <testdoStartNonContentionBasedRandomAccessProcedure+0xe>
	//fsm_schedule_self(400,RARrev_Success);//testing code //4ms,WAPTimer 
	FOUT;
}
    3762:	5d                   	pop    %ebp
    3763:	c3                   	ret    
    3764:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    376a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00003770 <stop_WRAP_timer>:
->output:
->Special:
*******************************
*/
void stop_WRAP_timer()
{
    3770:	55                   	push   %ebp
    3771:	89 e5                	mov    %esp,%ebp
    3773:	53                   	push   %ebx
    3774:	e8 fc ff ff ff       	call   3775 <stop_WRAP_timer+0x5>
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3779:	e8 fc ff ff ff       	call   377a <stop_WRAP_timer+0xa>
	if(SV(WaitforRAresponseTimer.flag)==true)
    377e:	80 b8 98 01 00 00 00 	cmpb   $0x0,0x198(%eax)
*******************************
*/
void stop_WRAP_timer()
{
	FIN(stop_WRAP_timer());
	SV_PTR_GET(rlc_mac_sv);
    3785:	89 c3                	mov    %eax,%ebx
	if(SV(WaitforRAresponseTimer.flag)==true)
    3787:	74 1c                	je     37a5 <stop_WRAP_timer+0x35>
	{
		fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    3789:	8b 80 94 01 00 00    	mov    0x194(%eax),%eax
    378f:	e8 fc ff ff ff       	call   3790 <stop_WRAP_timer+0x20>
		SV(WaitforRAresponseTimer.flag)=false;
    3794:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)=NULL;
    379b:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    37a2:	00 00 00 
	}
	FOUT;
}
    37a5:	5b                   	pop    %ebx
    37a6:	5d                   	pop    %ebp
    37a7:	c3                   	ret    
    37a8:	90                   	nop
    37a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000037b0 <NCRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void NCRAtoCON_testingfun() 
{
    37b0:	55                   	push   %ebp
    37b1:	89 e5                	mov    %esp,%ebp
    37b3:	e8 fc ff ff ff       	call   37b4 <NCRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("NCRA -> CON");
    37b8:	b8 f7 01 00 00       	mov    $0x1f7,%eax
    37bd:	e8 fc ff ff ff       	call   37be <NCRAtoCON_testingfun+0xe>
	stop_WRAP_timer(); //RAR
    37c2:	e8 fc ff ff ff       	call   37c3 <NCRAtoCON_testingfun+0x13>
	FOUT;
}
    37c7:	5d                   	pop    %ebp
    37c8:	c3                   	ret    
    37c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000037d0 <stop_CR_timer>:
->output:
->Special:
*******************************
*/
void stop_CR_timer()
{
    37d0:	55                   	push   %ebp
    37d1:	89 e5                	mov    %esp,%ebp
    37d3:	53                   	push   %ebx
    37d4:	e8 fc ff ff ff       	call   37d5 <stop_CR_timer+0x5>
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    37d9:	e8 fc ff ff ff       	call   37da <stop_CR_timer+0xa>
	if(SV(CRTimer.flag)==true)
    37de:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
*******************************
*/
void stop_CR_timer()
{
	FIN(stop_CR_timer());
	SV_PTR_GET(rlc_mac_sv);
    37e5:	89 c3                	mov    %eax,%ebx
	if(SV(CRTimer.flag)==true)
    37e7:	74 1c                	je     3805 <stop_CR_timer+0x35>
	{
		fsm_schedule_cancel(SV(CRTimer.timer_sign));
    37e9:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    37ef:	e8 fc ff ff ff       	call   37f0 <stop_CR_timer+0x20>
		SV(CRTimer.flag)=false;
    37f4:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
		SV(CRTimer.timer_sign)=NULL;
    37fb:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    3802:	00 00 00 
	}
	FOUT;
}
    3805:	5b                   	pop    %ebx
    3806:	5d                   	pop    %ebp
    3807:	c3                   	ret    
    3808:	90                   	nop
    3809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003810 <stop_TA_timer>:
->output:
->Special:
*******************************
*/
void stop_TA_timer()
{
    3810:	55                   	push   %ebp
    3811:	89 e5                	mov    %esp,%ebp
    3813:	53                   	push   %ebx
    3814:	e8 fc ff ff ff       	call   3815 <stop_TA_timer+0x5>
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    3819:	e8 fc ff ff ff       	call   381a <stop_TA_timer+0xa>
	if(SV(TATimer.flag)==true)
    381e:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
void stop_TA_timer()
{
	FIN(stop_TA_timer());
	SV_PTR_GET(rlc_mac_sv);
    3825:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true)
    3827:	74 1c                	je     3845 <stop_TA_timer+0x35>
	{
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    3829:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    382f:	e8 fc ff ff ff       	call   3830 <stop_TA_timer+0x20>
		SV(TATimer.flag)=false;
    3834:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.timer_sign)=NULL;
    383b:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    3842:	00 00 00 
	}
	FOUT;
}
    3845:	5b                   	pop    %ebx
    3846:	5d                   	pop    %ebp
    3847:	c3                   	ret    
    3848:	90                   	nop
    3849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003850 <stop_RetxBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_RetxBSR_timer()
{
    3850:	55                   	push   %ebp
    3851:	89 e5                	mov    %esp,%ebp
    3853:	53                   	push   %ebx
    3854:	e8 fc ff ff ff       	call   3855 <stop_RetxBSR_timer+0x5>
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3859:	e8 fc ff ff ff       	call   385a <stop_RetxBSR_timer+0xa>
	if(SV(RetxBSRTimer.flag)==true)
    385e:	80 b8 80 01 00 00 00 	cmpb   $0x0,0x180(%eax)
*******************************
*/
void stop_RetxBSR_timer()
{
	FIN(stop_RetxBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3865:	89 c3                	mov    %eax,%ebx
	if(SV(RetxBSRTimer.flag)==true)
    3867:	74 1c                	je     3885 <stop_RetxBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(RetxBSRTimer.timer_sign));
    3869:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    386f:	e8 fc ff ff ff       	call   3870 <stop_RetxBSR_timer+0x20>
		SV(RetxBSRTimer.flag)=false;
    3874:	c6 83 80 01 00 00 00 	movb   $0x0,0x180(%ebx)
		SV(RetxBSRTimer.timer_sign)=NULL;
    387b:	c7 83 7c 01 00 00 00 	movl   $0x0,0x17c(%ebx)
    3882:	00 00 00 
	}
	FOUT;
}
    3885:	5b                   	pop    %ebx
    3886:	5d                   	pop    %ebp
    3887:	c3                   	ret    
    3888:	90                   	nop
    3889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003890 <stop_PeriodicBSR_timer>:
->output:
->Special:
*******************************
*/
void stop_PeriodicBSR_timer()
{
    3890:	55                   	push   %ebp
    3891:	89 e5                	mov    %esp,%ebp
    3893:	53                   	push   %ebx
    3894:	e8 fc ff ff ff       	call   3895 <stop_PeriodicBSR_timer+0x5>
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    3899:	e8 fc ff ff ff       	call   389a <stop_PeriodicBSR_timer+0xa>
	if(SV(PeriodicBSRTimer.flag)==true)
    389e:	80 b8 8c 01 00 00 00 	cmpb   $0x0,0x18c(%eax)
*******************************
*/
void stop_PeriodicBSR_timer()
{
	FIN(stop_PeriodicBSR_timer());
	SV_PTR_GET(rlc_mac_sv);
    38a5:	89 c3                	mov    %eax,%ebx
	if(SV(PeriodicBSRTimer.flag)==true)
    38a7:	74 1c                	je     38c5 <stop_PeriodicBSR_timer+0x35>
	{
		fsm_schedule_cancel(SV(PeriodicBSRTimer.timer_sign));
    38a9:	8b 80 88 01 00 00    	mov    0x188(%eax),%eax
    38af:	e8 fc ff ff ff       	call   38b0 <stop_PeriodicBSR_timer+0x20>
		SV(PeriodicBSRTimer.flag)=false;
    38b4:	c6 83 8c 01 00 00 00 	movb   $0x0,0x18c(%ebx)
		SV(PeriodicBSRTimer.timer_sign)=NULL;
    38bb:	c7 83 88 01 00 00 00 	movl   $0x0,0x188(%ebx)
    38c2:	00 00 00 
	}
	FOUT;
}
    38c5:	5b                   	pop    %ebx
    38c6:	5d                   	pop    %ebp
    38c7:	c3                   	ret    
    38c8:	90                   	nop
    38c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

000038d0 <ue_mac_reset>:
->output:
->Special:
*******************************
*/
static void ue_mac_reset()//modified by LHL 20140717
{
    38d0:	55                   	push   %ebp
    38d1:	89 e5                	mov    %esp,%ebp
    38d3:	53                   	push   %ebx
    38d4:	e8 fc ff ff ff       	call   38d5 <ue_mac_reset+0x5>
	FIN( ue_mac_reset());
	SV_PTR_GET(rlc_mac_sv);
    38d9:	e8 fc ff ff ff       	call   38da <ue_mac_reset+0xa>
    38de:	89 c3                	mov    %eax,%ebx
	//initialize Bj for each logical channel to zero;BJ0 
	Zero_LogicalChannel_Bj_Reset();
    38e0:	e8 fc ff ff ff       	call   38e1 <ue_mac_reset+0x11>
	//stop (if running) all timers; 
	stop_WRAP_timer();//WaitforRAresponseTimer
    38e5:	e8 fc ff ff ff       	call   38e6 <ue_mac_reset+0x16>
	stop_CR_timer();//CR
    38ea:	e8 fc ff ff ff       	call   38eb <ue_mac_reset+0x1b>
    38ef:	90                   	nop
	stop_RetxBSR_timer();
    38f0:	e8 fc ff ff ff       	call   38f1 <ue_mac_reset+0x21>
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
    38f5:	e8 fc ff ff ff       	call   38f6 <ue_mac_reset+0x26>
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    38fa:	8b 83 e8 01 00 00    	mov    0x1e8(%ebx),%eax
	//stop_TA_timer();
	stop_PeriodicBSR_timer();
	//	consider timeAlignmentTimer as expired and perform the corresponding actions in subclause 5.2;
	
	//	set the NDIs for all uplink HARQ processes to the value 0;
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
    3900:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
	SV(SR_COUNTER)= 0; 
    3907:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
    390e:	83 f8 03             	cmp    $0x3,%eax
    3911:	74 4d                	je     3960 <ue_mac_reset+0x90>
    3913:	83 f8 01             	cmp    $0x1,%eax
    3916:	74 48                	je     3960 <ue_mac_reset+0x90>
	{
		SV(RA_info.ra_PreambleIndex)=0;//
		SV(RA_info.ra_PRACHMaskIndex)=0;
	}
	//	flush Msg3 buffer;
	if(SV(msg3_buf_ptr)!=NULL)
    3918:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
    391e:	85 c0                	test   %eax,%eax
    3920:	74 0f                	je     3931 <ue_mac_reset+0x61>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));	
    3922:	e8 fc ff ff ff       	call   3923 <ue_mac_reset+0x53>
		SV(msg3_buf_ptr) = NULL; 
    3927:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    392e:	00 00 00 
	}
	//	cancel, if any, triggered Scheduling Request procedure;
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
    3931:	e8 fc ff ff ff       	call   3932 <ue_mac_reset+0x62>
	Empty_MACBuffer_Rlc();//RLC 
    3936:	e8 fc ff ff ff       	call   3937 <ue_mac_reset+0x67>
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
	if(SV(m_temp_cr) != NULL)
    393b:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
	Free_Bsr_Info();//	cancel, if any, triggered Buffer Status Reporting procedure;
	Empty_MACBuffer_Rlc();//RLC 
	//	cancel, if any, triggered Power Headroom Reporting procedure;
	//	flush the soft buffers for all DL HARQ processes;
	//	for each DL HARQ process, consider the next received transmission for a TB as the very first transmission;
	SV(T_C_RNTI) = 0; //	release, if any, Temporary C-RNTI.
    3941:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	if(SV(m_temp_cr) != NULL)
    3947:	85 c0                	test   %eax,%eax
    3949:	74 0f                	je     395a <ue_mac_reset+0x8a>
	{
		fsm_mem_free(SV(m_temp_cr));
    394b:	e8 fc ff ff ff       	call   394c <ue_mac_reset+0x7c>
		SV(m_temp_cr) = NULL;
    3950:	c7 83 a0 01 00 00 00 	movl   $0x0,0x1a0(%ebx)
    3957:	00 00 00 
	}
	FOUT;
}
    395a:	5b                   	pop    %ebx
    395b:	5d                   	pop    %ebp
    395c:	c3                   	ret    
    395d:	8d 76 00             	lea    0x0(%esi),%esi
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//	stop, if any, ongoing RACH procedure;
	SV(SR_COUNTER)= 0; 
	//	discard explicitly signalled ra-PreambleIndex and ra-PRACH-MaskIndex, if any;
	if(SV(ratype.ra_type)==1 ||SV(ratype.ra_type)==3)//RRCPDCCH
	{
		SV(RA_info.ra_PreambleIndex)=0;//
    3960:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0;
    3964:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    3968:	eb ae                	jmp    3918 <ue_mac_reset+0x48>
    396a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00003970 <CRAtoCON_testingfun>:
->output:
->Special:
*******************************
*/
void CRAtoCON_testingfun()
{
    3970:	55                   	push   %ebp
    3971:	89 e5                	mov    %esp,%ebp
    3973:	e8 fc ff ff ff       	call   3974 <CRAtoCON_testingfun+0x4>
	FIN(NCRAtoCON_testingfun());
	print_tran_info("CRA -> CON");
    3978:	b8 03 02 00 00       	mov    $0x203,%eax
    397d:	e8 fc ff ff ff       	call   397e <CRAtoCON_testingfun+0xe>
	stop_CR_timer(); //
    3982:	e8 fc ff ff ff       	call   3983 <CRAtoCON_testingfun+0x13>
	FOUT;
}
    3987:	5d                   	pop    %ebp
    3988:	c3                   	ret    
    3989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003990 <test1_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test1_idle_default_handler()
{
    3990:	55                   	push   %ebp
    3991:	89 e5                	mov    %esp,%ebp
    3993:	83 ec 10             	sub    $0x10,%esp
    3996:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    3999:	89 75 fc             	mov    %esi,-0x4(%ebp)
    399c:	e8 fc ff ff ff       	call   399d <test1_idle_default_handler+0xd>
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    39a1:	e8 fc ff ff ff       	call   39a2 <test1_idle_default_handler+0x12>
    39a6:	89 c3                	mov    %eax,%ebx
	print_tran_info("MAC:idle_default_handler");
    39a8:	b8 0e 02 00 00       	mov    $0x20e,%eax
    39ad:	e8 fc ff ff ff       	call   39ae <test1_idle_default_handler+0x1e>
	if(MAC_CLOSE)
    39b2:	e8 fc ff ff ff       	call   39b3 <test1_idle_default_handler+0x23>
    39b7:	83 f8 05             	cmp    $0x5,%eax
    39ba:	74 5c                	je     3a18 <test1_idle_default_handler+0x88>
    39bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    39c0:	e8 fc ff ff ff       	call   39c1 <test1_idle_default_handler+0x31>
    39c5:	83 f8 02             	cmp    $0x2,%eax
    39c8:	74 76                	je     3a40 <test1_idle_default_handler+0xb0>
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    39ca:	e8 fc ff ff ff       	call   39cb <test1_idle_default_handler+0x3b>
    39cf:	83 f8 05             	cmp    $0x5,%eax
    39d2:	74 0c                	je     39e0 <test1_idle_default_handler+0x50>
			ioctrl_handler();  	
		break;
		}
	}
FOUT;
}
    39d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    39d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
    39da:	89 ec                	mov    %ebp,%esp
    39dc:	5d                   	pop    %ebp
    39dd:	c3                   	ret    
    39de:	66 90                	xchg   %ax,%ax
		print_tran_info("MAC:IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		SV(ratype.ra_type)=2;
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    39e0:	e8 fc ff ff ff       	call   39e1 <test1_idle_default_handler+0x51>
    39e5:	83 f8 02             	cmp    $0x2,%eax
    39e8:	75 ea                	jne    39d4 <test1_idle_default_handler+0x44>
	{//IOCTL
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
    39ea:	b8 3a 02 00 00       	mov    $0x23a,%eax
    39ef:	e8 fc ff ff ff       	call   39f0 <test1_idle_default_handler+0x60>
		switch(fsm_ev_ioctrl_cmd())
    39f4:	e8 fc ff ff ff       	call   39f5 <test1_idle_default_handler+0x65>
    39f9:	83 f8 0b             	cmp    $0xb,%eax
    39fc:	0f 84 be 00 00 00    	je     3ac0 <test1_idle_default_handler+0x130>
    3a02:	83 f8 0c             	cmp    $0xc,%eax
    3a05:	74 6d                	je     3a74 <test1_idle_default_handler+0xe4>
    3a07:	83 f8 04             	cmp    $0x4,%eax
    3a0a:	74 4d                	je     3a59 <test1_idle_default_handler+0xc9>
    3a0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

		*/

		//
		default:
			ioctrl_handler();  	
    3a10:	e8 2b f0 ff ff       	call   2a40 <ioctrl_handler>
		break;
    3a15:	eb bd                	jmp    39d4 <test1_idle_default_handler+0x44>
    3a17:	90                   	nop
    3a18:	90                   	nop
    3a19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
{
	void *tmpdata_ptr;
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("MAC:idle_default_handler");
	if(MAC_CLOSE)
    3a20:	e8 fc ff ff ff       	call   3a21 <test1_idle_default_handler+0x91>
    3a25:	83 f8 01             	cmp    $0x1,%eax
    3a28:	75 92                	jne    39bc <test1_idle_default_handler+0x2c>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3a2a:	b8 27 02 00 00       	mov    $0x227,%eax
    3a2f:	e8 fc ff ff ff       	call   3a30 <test1_idle_default_handler+0xa0>
		ue_mac_sv_close();
    3a34:	e8 77 ef ff ff       	call   29b0 <ue_mac_sv_close>
    3a39:	eb 81                	jmp    39bc <test1_idle_default_handler+0x2c>
    3a3b:	90                   	nop
    3a3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("MAC:IDLE receive a data packet from PHYadapter"); //testing code
    3a40:	b8 38 0d 00 00       	mov    $0xd38,%eax
    3a45:	e8 fc ff ff ff       	call   3a46 <test1_idle_default_handler+0xb6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3a4a:	e8 fc ff ff ff       	call   3a4b <test1_idle_default_handler+0xbb>
    3a4f:	e8 fc ff ff ff       	call   3a50 <test1_idle_default_handler+0xc0>
    3a54:	e9 71 ff ff ff       	jmp    39ca <test1_idle_default_handler+0x3a>
				fsm_data_destroy(tmpdata_ptr);//
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("MAC:IDLE receive a cra order ");
    3a59:	b8 9d 02 00 00       	mov    $0x29d,%eax
    3a5e:	e8 fc ff ff ff       	call   3a5f <test1_idle_default_handler+0xcf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//		
    3a63:	ba 02 00 00 00       	mov    $0x2,%edx
    3a68:	31 c0                	xor    %eax,%eax
    3a6a:	e8 fc ff ff ff       	call   3a6b <test1_idle_default_handler+0xdb>
		break;
    3a6f:	e9 60 ff ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;

		//PHYRA
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				tmpdata_ptr = fsm_data_get();
    3a74:	e8 fc ff ff ff       	call   3a75 <test1_idle_default_handler+0xe5>
    3a79:	89 c6                	mov    %eax,%esi
				print_tran_info("IDLE receive a ncra order ");
    3a7b:	b8 76 02 00 00       	mov    $0x276,%eax
    3a80:	e8 fc ff ff ff       	call   3a81 <test1_idle_default_handler+0xf1>
				fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    3a85:	b9 02 00 00 00       	mov    $0x2,%ecx
    3a8a:	89 f2                	mov    %esi,%edx
    3a8c:	8d 43 04             	lea    0x4(%ebx),%eax
    3a8f:	e8 fc ff ff ff       	call   3a90 <test1_idle_default_handler+0x100>
				fsm_printf("RAPID: %d \n",SV(RA_info.ra_PreambleIndex));		
    3a94:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    3a98:	c7 04 24 91 02 00 00 	movl   $0x291,(%esp)
    3a9f:	89 44 24 04          	mov    %eax,0x4(%esp)
    3aa3:	e8 fc ff ff ff       	call   3aa4 <test1_idle_default_handler+0x114>
				if(tmpdata_ptr != NULL)
    3aa8:	85 f6                	test   %esi,%esi
    3aaa:	0f 84 24 ff ff ff    	je     39d4 <test1_idle_default_handler+0x44>
				fsm_data_destroy(tmpdata_ptr);//
    3ab0:	89 f0                	mov    %esi,%eax
    3ab2:	e8 fc ff ff ff       	call   3ab3 <test1_idle_default_handler+0x123>
    3ab7:	e9 18 ff ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
    3abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("MAC:IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3ac0:	e8 fc ff ff ff       	call   3ac1 <test1_idle_default_handler+0x131>
    3ac5:	89 c3                	mov    %eax,%ebx
			print_tran_info("MAC:IDLE receive a RLCdatareq");
    3ac7:	b8 58 02 00 00       	mov    $0x258,%eax
    3acc:	e8 fc ff ff ff       	call   3acd <test1_idle_default_handler+0x13d>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3ad1:	89 d8                	mov    %ebx,%eax
    3ad3:	e8 fc ff ff ff       	call   3ad4 <test1_idle_default_handler+0x144>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3ad8:	ba 02 00 00 00       	mov    $0x2,%edx
    3add:	31 c0                	xor    %eax,%eax
    3adf:	e8 fc ff ff ff       	call   3ae0 <test1_idle_default_handler+0x150>
		break;
    3ae4:	e9 eb fe ff ff       	jmp    39d4 <test1_idle_default_handler+0x44>
    3ae9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00003af0 <test2_idle_default_handler>:
->output:
->Special:
*******************************
*/
void test2_idle_default_handler()
{
    3af0:	55                   	push   %ebp
    3af1:	89 e5                	mov    %esp,%ebp
    3af3:	53                   	push   %ebx
    3af4:	e8 fc ff ff ff       	call   3af5 <test2_idle_default_handler+0x5>
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
    3af9:	e8 fc ff ff ff       	call   3afa <test2_idle_default_handler+0xa>
	print_tran_info("idle_default_handler");
    3afe:	b8 bb 02 00 00       	mov    $0x2bb,%eax
    3b03:	e8 fc ff ff ff       	call   3b04 <test2_idle_default_handler+0x14>
	if(MAC_CLOSE)
    3b08:	e8 fc ff ff ff       	call   3b09 <test2_idle_default_handler+0x19>
    3b0d:	83 f8 05             	cmp    $0x5,%eax
    3b10:	74 56                	je     3b68 <test2_idle_default_handler+0x78>
	{
		print_tran_info("MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    3b12:	e8 fc ff ff ff       	call   3b13 <test2_idle_default_handler+0x23>
    3b17:	83 f8 02             	cmp    $0x2,%eax
    3b1a:	74 74                	je     3b90 <test2_idle_default_handler+0xa0>
    3b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3b20:	e8 fc ff ff ff       	call   3b21 <test2_idle_default_handler+0x31>
    3b25:	83 f8 05             	cmp    $0x5,%eax
    3b28:	74 06                	je     3b30 <test2_idle_default_handler+0x40>
			ioctrl_handler();
		break;
		}
	}
	FOUT;
}
    3b2a:	5b                   	pop    %ebx
    3b2b:	5d                   	pop    %ebp
    3b2c:	c3                   	ret    
    3b2d:	8d 76 00             	lea    0x0(%esi),%esi
	{//IDLE,
		print_tran_info("IDLE receive a data packet from RLC, error, and then start CRA");//testing code 
		fsm_schedule_self(0, Start_ContentionBase_RandomAcc);
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
    3b30:	e8 fc ff ff ff       	call   3b31 <test2_idle_default_handler+0x41>
    3b35:	83 f8 02             	cmp    $0x2,%eax
    3b38:	75 f0                	jne    3b2a <test2_idle_default_handler+0x3a>
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
    3b3a:	b8 d0 02 00 00       	mov    $0x2d0,%eax
    3b3f:	e8 fc ff ff ff       	call   3b40 <test2_idle_default_handler+0x50>
		switch(fsm_ev_ioctrl_cmd())
    3b44:	e8 fc ff ff ff       	call   3b45 <test2_idle_default_handler+0x55>
    3b49:	83 f8 0b             	cmp    $0xb,%eax
    3b4c:	0f 84 96 00 00 00    	je     3be8 <test2_idle_default_handler+0xf8>
    3b52:	77 5c                	ja     3bb0 <test2_idle_default_handler+0xc0>
    3b54:	83 f8 04             	cmp    $0x4,%eax
    3b57:	74 70                	je     3bc9 <test2_idle_default_handler+0xd9>
    3b59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
		break;
		//do_ioctl
		//
		default:
			ioctrl_handler();
    3b60:	e8 db ee ff ff       	call   2a40 <ioctrl_handler>
		break;
    3b65:	eb c3                	jmp    3b2a <test2_idle_default_handler+0x3a>
    3b67:	90                   	nop
    3b68:	90                   	nop
    3b69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	void *tmpdata_ptr;
	FIN(idle_default_handler());

	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("idle_default_handler");
	if(MAC_CLOSE)
    3b70:	e8 fc ff ff ff       	call   3b71 <test2_idle_default_handler+0x81>
    3b75:	83 f8 01             	cmp    $0x1,%eax
    3b78:	75 98                	jne    3b12 <test2_idle_default_handler+0x22>
	{
		print_tran_info("MAC FSM is closed "); //testing code
    3b7a:	b8 27 02 00 00       	mov    $0x227,%eax
    3b7f:	e8 fc ff ff ff       	call   3b80 <test2_idle_default_handler+0x90>
		ue_mac_sv_close();
    3b84:	e8 27 ee ff ff       	call   29b0 <ue_mac_sv_close>
    3b89:	eb 87                	jmp    3b12 <test2_idle_default_handler+0x22>
    3b8b:	90                   	nop
    3b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	if(MAC_PK_FROM_LOWER)
	{	//ICIRLC
		print_tran_info("IDLE receive a data packet from PHYadapter"); //testing code
    3b90:	b8 68 0d 00 00       	mov    $0xd68,%eax
    3b95:	e8 fc ff ff ff       	call   3b96 <test2_idle_default_handler+0xa6>
		//decomplexUeDataPdu(fsm_pkt_get());
		fsm_pkt_destroy(fsm_pkt_get());//testing code
    3b9a:	e8 fc ff ff ff       	call   3b9b <test2_idle_default_handler+0xab>
    3b9f:	e8 fc ff ff ff       	call   3ba0 <test2_idle_default_handler+0xb0>
    3ba4:	e9 73 ff ff ff       	jmp    3b1c <test2_idle_default_handler+0x2c>
    3ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		fsm_pkt_destroy(fsm_pkt_get());//testing code
	}*/
	if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
    3bb0:	83 f8 0c             	cmp    $0xc,%eax
    3bb3:	74 5c                	je     3c11 <test2_idle_default_handler+0x121>
    3bb5:	83 f8 31             	cmp    $0x31,%eax
    3bb8:	75 9f                	jne    3b59 <test2_idle_default_handler+0x69>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
		break;
		//
		//PHYRA
		case NCRATEST:
				print_tran_info("IDLE receive a ncra test ");
    3bba:	b8 04 03 00 00       	mov    $0x304,%eax
    3bbf:	e8 fc ff ff ff       	call   3bc0 <test2_idle_default_handler+0xd0>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
    3bc4:	e9 61 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>
				print_tran_info("IDLE receive a ncra order ");
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
		//RRCRA
		case IOCCMD_RRCtoMAC_RandomAcc_Req :
				print_tran_info("IDLE receive a cra order ");
    3bc9:	b8 1e 03 00 00       	mov    $0x31e,%eax
    3bce:	e8 fc ff ff ff       	call   3bcf <test2_idle_default_handler+0xdf>
				fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    3bd3:	ba 02 00 00 00       	mov    $0x2,%edx
    3bd8:	31 c0                	xor    %eax,%eax
    3bda:	e8 fc ff ff ff       	call   3bdb <test2_idle_default_handler+0xeb>
		break;
    3bdf:	e9 46 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>
    3be4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		print_tran_info("IDLE default ioctl hander");//testing code
		switch(fsm_ev_ioctrl_cmd())
		{
		//RLC
		case IOCCMD_RLCtoMAC_datasend_Req :
			tmpdata_ptr = fsm_data_get();
    3be8:	e8 fc ff ff ff       	call   3be9 <test2_idle_default_handler+0xf9>
    3bed:	89 c3                	mov    %eax,%ebx
			print_tran_info("IDLE receive a RLCdatareq");
    3bef:	b8 ea 02 00 00       	mov    $0x2ea,%eax
    3bf4:	e8 fc ff ff ff       	call   3bf5 <test2_idle_default_handler+0x105>
			//DoRefreshRLCBuffserRequest((RlcBufferRequest *) tmpdata_ptr);//
			fsm_data_destroy(tmpdata_ptr);
    3bf9:	89 d8                	mov    %ebx,%eax
    3bfb:	e8 fc ff ff ff       	call   3bfc <test2_idle_default_handler+0x10c>
			fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
    3c00:	ba 02 00 00 00       	mov    $0x2,%edx
    3c05:	31 c0                	xor    %eax,%eax
    3c07:	e8 fc ff ff ff       	call   3c08 <test2_idle_default_handler+0x118>
		break;
    3c0c:	e9 19 ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>


				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// 
		break;
		case IOCCMD_PDCCHtoMAC_RandomAcc_Req : 	
				print_tran_info("IDLE receive a ncra order ");
    3c11:	b8 76 02 00 00       	mov    $0x276,%eax
    3c16:	e8 fc ff ff ff       	call   3c17 <test2_idle_default_handler+0x127>
				//fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );//
		break; 
    3c1b:	e9 0a ff ff ff       	jmp    3b2a <test2_idle_default_handler+0x3a>

00003c20 <findInsByRbid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsByRbid(u8 rbid,void **up, void **down , RlcMode *mode)
{
    3c20:	55                   	push   %ebp
    3c21:	89 e5                	mov    %esp,%ebp
    3c23:	57                   	push   %edi
    3c24:	56                   	push   %esi
    3c25:	53                   	push   %ebx
    3c26:	83 ec 10             	sub    $0x10,%esp
    3c29:	e8 fc ff ff ff       	call   3c2a <findInsByRbid+0xa>
    3c2e:	8b 75 08             	mov    0x8(%ebp),%esi
    3c31:	89 55 ec             	mov    %edx,-0x14(%ebp)
    3c34:	89 c3                	mov    %eax,%ebx
    3c36:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsByRbid());
	SV_PTR_GET(rlc_mac_sv);
    3c39:	e8 fc ff ff ff       	call   3c3a <findInsByRbid+0x1a>
	*up = *down = NULL;
    3c3e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3c41:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3c44:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    3c4a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    3c50:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    3c56:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    3c5c:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    3c62:	39 d1                	cmp    %edx,%ecx
    3c64:	74 29                	je     3c8f <findInsByRbid+0x6f>
    3c66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3c69:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3c6c:	eb 08                	jmp    3c76 <findInsByRbid+0x56>
    3c6e:	66 90                	xchg   %ax,%ax
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3c70:	8b 12                	mov    (%edx),%edx
    3c72:	39 d1                	cmp    %edx,%ecx
    3c74:	74 16                	je     3c8c <findInsByRbid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->rbId == rbid)
    3c76:	38 5a e6             	cmp    %bl,-0x1a(%edx)
    3c79:	75 f5                	jne    3c70 <findInsByRbid+0x50>
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    3c7b:	8d 42 e4             	lea    -0x1c(%edx),%eax
    3c7e:	89 07                	mov    %eax,(%edi)
			if(tmTxIns->rbId == rbid)
			{
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
    3c80:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    3c86:	8b 12                	mov    (%edx),%edx
    3c88:	39 d1                	cmp    %edx,%ecx
    3c8a:	75 ea                	jne    3c76 <findInsByRbid+0x56>
    3c8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3c8f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up = (void*)tmTxIns;
				*mode = TM_MODE;
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    3c95:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    3c9b:	39 d1                	cmp    %edx,%ecx
    3c9d:	74 28                	je     3cc7 <findInsByRbid+0xa7>
    3c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3ca2:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3ca5:	eb 07                	jmp    3cae <findInsByRbid+0x8e>
    3ca7:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3ca8:	8b 12                	mov    (%edx),%edx
    3caa:	39 d1                	cmp    %edx,%ecx
    3cac:	74 16                	je     3cc4 <findInsByRbid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->rbId == rbid)
    3cae:	38 5a fa             	cmp    %bl,-0x6(%edx)
    3cb1:	75 f5                	jne    3ca8 <findInsByRbid+0x88>
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    3cb3:	8d 42 f8             	lea    -0x8(%edx),%eax
    3cb6:	89 07                	mov    %eax,(%edi)
			if(tmRxIns->rbId == rbid)
			{
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
    3cb8:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]tmRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    3cbe:	8b 12                	mov    (%edx),%edx
    3cc0:	39 d1                	cmp    %edx,%ecx
    3cc2:	75 ea                	jne    3cae <findInsByRbid+0x8e>
    3cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)tmRxIns;
				*mode = TM_MODE;
			}
		}
	}
	if(*mode == TM_MODE)
    3cc7:	83 3e 01             	cmpl   $0x1,(%esi)
    3cca:	0f 84 c8 00 00 00    	je     3d98 <findInsByRbid+0x178>
    3cd0:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    3cd6:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    3cdc:	39 d1                	cmp    %edx,%ecx
    3cde:	74 27                	je     3d07 <findInsByRbid+0xe7>
    3ce0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3ce3:	8b 7d ec             	mov    -0x14(%ebp),%edi
    3ce6:	eb 06                	jmp    3cee <findInsByRbid+0xce>
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3ce8:	8b 12                	mov    (%edx),%edx
    3cea:	39 d1                	cmp    %edx,%ecx
    3cec:	74 16                	je     3d04 <findInsByRbid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->rbid == rbid)
    3cee:	38 5a d2             	cmp    %bl,-0x2e(%edx)
    3cf1:	75 f5                	jne    3ce8 <findInsByRbid+0xc8>
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    3cf3:	8d 42 d0             	lea    -0x30(%edx),%eax
    3cf6:	89 07                	mov    %eax,(%edi)
			if(umTxIns->rbid == rbid)
			{
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
    3cf8:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umTxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    3cfe:	8b 12                	mov    (%edx),%edx
    3d00:	39 d1                	cmp    %edx,%ecx
    3d02:	75 ea                	jne    3cee <findInsByRbid+0xce>
    3d04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3d07:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*up =  (void*)umTxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    3d0d:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    3d13:	39 d1                	cmp    %edx,%ecx
    3d15:	74 2e                	je     3d45 <findInsByRbid+0x125>
    3d17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    3d1a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d1d:	eb 07                	jmp    3d26 <findInsByRbid+0x106>
    3d1f:	90                   	nop
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3d20:	8b 12                	mov    (%edx),%edx
    3d22:	39 d1                	cmp    %edx,%ecx
    3d24:	74 1c                	je     3d42 <findInsByRbid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->rbId == rbid)
    3d26:	38 9a 3e ef ff ff    	cmp    %bl,-0x10c2(%edx)
    3d2c:	75 f2                	jne    3d20 <findInsByRbid+0x100>
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    3d2e:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
    3d34:	89 07                	mov    %eax,(%edi)
			if(umRxIns->rbId == rbid)
			{
				*down = (void*)umRxIns;
				*mode = UM_MODE;
    3d36:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]umRxList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    3d3c:	8b 12                	mov    (%edx),%edx
    3d3e:	39 d1                	cmp    %edx,%ecx
    3d40:	75 e4                	jne    3d26 <findInsByRbid+0x106>
    3d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down = (void*)umRxIns;
				*mode = UM_MODE;
			}
		}
	}
	if(*mode == UM_MODE)
    3d45:	83 3e 02             	cmpl   $0x2,(%esi)
    3d48:	74 4e                	je     3d98 <findInsByRbid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    3d4a:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    3d50:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    3d56:	39 c2                	cmp    %eax,%edx
    3d58:	74 3e                	je     3d98 <findInsByRbid+0x178>
    3d5a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    3d5d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    3d60:	eb 0c                	jmp    3d6e <findInsByRbid+0x14e>
    3d62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3d68:	8b 00                	mov    (%eax),%eax
    3d6a:	39 c2                	cmp    %eax,%edx
    3d6c:	74 2a                	je     3d98 <findInsByRbid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->rbId == rbid)
    3d6e:	38 98 fe dc ff ff    	cmp    %bl,-0x2302(%eax)
    3d74:	75 f2                	jne    3d68 <findInsByRbid+0x148>
			{
				*mode = AM_MODE;
    3d76:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    3d79:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->rbId == rbid)
			{
				*mode = AM_MODE;
    3d7f:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    3d85:	8b 75 ec             	mov    -0x14(%ebp),%esi
    3d88:	89 0f                	mov    %ecx,(%edi)
    3d8a:	89 0e                	mov    %ecx,(%esi)
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		//fsm_printf("[RLC_MAC][findInsByRbid]amList is unempty!\n");	//add for debug 20150911
		list_for_each(pos,&SV(vAm_ins).amList)
    3d8c:	8b 00                	mov    (%eax),%eax
    3d8e:	39 c2                	cmp    %eax,%edx
    3d90:	75 dc                	jne    3d6e <findInsByRbid+0x14e>
    3d92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				*up = *down =  (void*)amIns;
			}
		}
	}
	FOUT;
}
    3d98:	83 c4 10             	add    $0x10,%esp
    3d9b:	5b                   	pop    %ebx
    3d9c:	5e                   	pop    %esi
    3d9d:	5f                   	pop    %edi
    3d9e:	5d                   	pop    %ebp
    3d9f:	c3                   	ret    

00003da0 <rlc_pkt_receive_from_upper>:
**--------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
static void rlc_pkt_receive_from_upper(void)
{
    3da0:	55                   	push   %ebp
    3da1:	89 e5                	mov    %esp,%ebp
    3da3:	57                   	push   %edi
    3da4:	56                   	push   %esi
    3da5:	53                   	push   %ebx
    3da6:	83 ec 24             	sub    $0x24,%esp
    3da9:	e8 fc ff ff ff       	call   3daa <rlc_pkt_receive_from_upper+0xa>
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	
    3dae:	e8 fc ff ff ff       	call   3daf <rlc_pkt_receive_from_upper+0xf>
    3db3:	89 c3                	mov    %eax,%ebx

	skb = (FSM_PKT *)fsm_pkt_get();
    3db5:	e8 fc ff ff ff       	call   3db6 <rlc_pkt_receive_from_upper+0x16>
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
    3dba:	8b b8 a8 00 00 00    	mov    0xa8(%eax),%edi
	//int i=0;
	
	FIN(rlc_pkt_receive_from_upper());
	SV_PTR_GET(rlc_mac_sv);	

	skb = (FSM_PKT *)fsm_pkt_get();
    3dc0:	89 c6                	mov    %eax,%esi
	//fsm_printf("\n[RLC][rlc_pkt_receive_from_upper] entering rlc_pkt_receive_from_upper()\n");
	
	iciMsg = (URLC_IciMsg*)skb->head;
	fsm_printf("[RLC][rlc_pkt_receive_from_upper][-->] receive from upper, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
    3dc2:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    3dc6:	89 44 24 08          	mov    %eax,0x8(%esp)
    3dca:	0f b6 07             	movzbl (%edi),%eax
    3dcd:	c7 04 24 94 0d 00 00 	movl   $0xd94,(%esp)
    3dd4:	89 44 24 04          	mov    %eax,0x4(%esp)
    3dd8:	e8 fc ff ff ff       	call   3dd9 <rlc_pkt_receive_from_upper+0x39>
	fsm_octets_print(skb->data,64);
    3ddd:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    3de3:	ba 40 00 00 00       	mov    $0x40,%edx
    3de8:	e8 fc ff ff ff       	call   3de9 <rlc_pkt_receive_from_upper+0x49>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    3ded:	80 3f 00             	cmpb   $0x0,(%edi)
    3df0:	0f 85 13 02 00 00    	jne    4009 <rlc_pkt_receive_from_upper+0x269>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    3df6:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    3dfa:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    3e00:	89 14 24             	mov    %edx,(%esp)
    3e03:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    3e06:	8d 55 ec             	lea    -0x14(%ebp),%edx
    3e09:	e8 fc ff ff ff       	call   3e0a <rlc_pkt_receive_from_upper+0x6a>
		fsm_printf("[RLC_MAC][rlc_pkt_receive_from_upper]ins_mode is: %d\n", SV(ins_mode));
    3e0e:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    3e14:	c7 04 24 e4 0d 00 00 	movl   $0xde4,(%esp)
    3e1b:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e1f:	e8 fc ff ff ff       	call   3e20 <rlc_pkt_receive_from_upper+0x80>
		switch(SV(ins_mode))
    3e24:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    3e2a:	83 f8 02             	cmp    $0x2,%eax
    3e2d:	0f 84 35 01 00 00    	je     3f68 <rlc_pkt_receive_from_upper+0x1c8>
    3e33:	83 f8 03             	cmp    $0x3,%eax
    3e36:	0f 84 8c 00 00 00    	je     3ec8 <rlc_pkt_receive_from_upper+0x128>
    3e3c:	83 f8 01             	cmp    $0x1,%eax
    3e3f:	74 47                	je     3e88 <rlc_pkt_receive_from_upper+0xe8>
				//fsm_printf("[RLC][rlc_pkt_receive_from_upper][TM] bufferReqTimer is runing\n");
			}*/
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    3e41:	83 83 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%ebx)
			printk("[RLC][rlc_pkt_receive_from_upper] cannot distinfuish this %d\n", SV(ins_mode));
    3e48:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e4c:	c7 04 24 10 10 00 00 	movl   $0x1010,(%esp)
    3e53:	e8 fc ff ff ff       	call   3e54 <rlc_pkt_receive_from_upper+0xb4>
			printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    3e58:	8b 83 9c 5a 00 00    	mov    0x5a9c(%ebx),%eax
    3e5e:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    3e65:	89 44 24 04          	mov    %eax,0x4(%esp)
    3e69:	e8 fc ff ff ff       	call   3e6a <rlc_pkt_receive_from_upper+0xca>
			
			break;
		}
		
		if(skb != NULL)
    3e6e:	85 f6                	test   %esi,%esi
    3e70:	74 07                	je     3e79 <rlc_pkt_receive_from_upper+0xd9>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    3e72:	89 f0                	mov    %esi,%eax
    3e74:	e8 fc ff ff ff       	call   3e75 <rlc_pkt_receive_from_upper+0xd5>
		skb = NULL;
		FOUT;
	}
}
    3e79:	83 c4 24             	add    $0x24,%esp
    3e7c:	5b                   	pop    %ebx
    3e7d:	5e                   	pop    %esi
    3e7e:	5f                   	pop    %edi
    3e7f:	5d                   	pop    %ebp
    3e80:	c3                   	ret    
    3e81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}*/
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    3e88:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    3e8b:	85 db                	test   %ebx,%ebx
    3e8d:	0f 84 a4 01 00 00    	je     4037 <rlc_pkt_receive_from_upper+0x297>
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    3e93:	b8 0c 00 00 00       	mov    $0xc,%eax
    3e98:	e8 fc ff ff ff       	call   3e99 <rlc_pkt_receive_from_upper+0xf9>
			tmElm->pkt = skb;
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    3e9d:	8d 7b 0c             	lea    0xc(%ebx),%edi
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
			tmElm->pkt = skb;
    3ea0:	89 30                	mov    %esi,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3ea2:	8b 53 10             	mov    0x10(%ebx),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    3ea5:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3ea8:	89 4b 10             	mov    %ecx,0x10(%ebx)
    3eab:	89 78 04             	mov    %edi,0x4(%eax)
	new->next = next;
	new->prev = prev;
    3eae:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    3eb1:	89 0a                	mov    %ecx,(%edx)
			tmTxIns->tmSduBufferNum++;
    3eb3:	83 43 18 01          	addl   $0x1,0x18(%ebx)
			tmTxIns->tmSduBufferSize += skb->len;
    3eb7:	8b 46 50             	mov    0x50(%esi),%eax
    3eba:	01 43 14             	add    %eax,0x14(%ebx)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    3ebd:	83 c4 24             	add    $0x24,%esp
    3ec0:	5b                   	pop    %ebx
    3ec1:	5e                   	pop    %esi
    3ec2:	5f                   	pop    %edi
    3ec3:	5d                   	pop    %ebp
    3ec4:	c3                   	ret    
    3ec5:	8d 76 00             	lea    0x0(%esi),%esi
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][rlc_pkt_receive_from_upper]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    3ec8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    3ecb:	85 c0                	test   %eax,%eax
    3ecd:	0f 84 7d 01 00 00    	je     4050 <rlc_pkt_receive_from_upper+0x2b0>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    3ed3:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    3ed7:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    3eda:	66 83 fa 0b          	cmp    $0xb,%dx
    3ede:	0f 84 85 01 00 00    	je     4069 <rlc_pkt_receive_from_upper+0x2c9>
    3ee4:	66 83 fa 09          	cmp    $0x9,%dx
    3ee8:	0f 84 7b 01 00 00    	je     4069 <rlc_pkt_receive_from_upper+0x2c9>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    3eee:	b8 14 00 00 00       	mov    $0x14,%eax
    3ef3:	e8 fc ff ff ff       	call   3ef4 <rlc_pkt_receive_from_upper+0x154>
			/*mallocnum++;
			if(mallocnum%25==0)
			{
				printk("RLC ALLOC: %d\n", mallocnum);
			}*/
			amElm->pkt = skb;
    3ef8:	89 30                	mov    %esi,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    3efa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3efd:	8d 58 0c             	lea    0xc(%eax),%ebx
			if(mallocnum%25==0)
			{
				printk("RLC ALLOC: %d\n", mallocnum);
			}*/
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    3f00:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    3f07:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3f0e:	8b 4a 48             	mov    0x48(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3f11:	89 5a 48             	mov    %ebx,0x48(%edx)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    3f14:	83 c2 44             	add    $0x44,%edx
    3f17:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    3f1a:	89 48 10             	mov    %ecx,0x10(%eax)
	prev->next = new;
    3f1d:	89 19                	mov    %ebx,(%ecx)
			fsm_printf("[RLC][rlc_pkt_receive_from_upper]AM_MODE list_add done!\n");
    3f1f:	c7 04 24 ac 0e 00 00 	movl   $0xeac,(%esp)
    3f26:	e8 fc ff ff ff       	call   3f27 <rlc_pkt_receive_from_upper+0x187>
			fsm_printf("[RLC][rlc_pkt_receive_from_upper] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    3f2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3f2e:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    3f32:	89 54 24 0c          	mov    %edx,0xc(%esp)
    3f36:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    3f3a:	c7 04 24 e8 0e 00 00 	movl   $0xee8,(%esp)
    3f41:	89 44 24 08          	mov    %eax,0x8(%esp)
    3f45:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3f48:	89 44 24 04          	mov    %eax,0x4(%esp)
    3f4c:	e8 fc ff ff ff       	call   3f4d <rlc_pkt_receive_from_upper+0x1ad>
			amIns->amSduBufferSize += skb->len;
    3f51:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3f54:	8b 56 50             	mov    0x50(%esi),%edx
    3f57:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    3f5a:	83 40 50 01          	addl   $0x1,0x50(%eax)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    3f5e:	83 c4 24             	add    $0x24,%esp
    3f61:	5b                   	pop    %ebx
    3f62:	5e                   	pop    %esi
    3f63:	5f                   	pop    %edi
    3f64:	5d                   	pop    %ebp
    3f65:	c3                   	ret    
    3f66:	66 90                	xchg   %ax,%ax
			}*/
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    3f68:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3f6b:	85 d2                	test   %edx,%edx
    3f6d:	0f 84 c4 00 00 00    	je     4037 <rlc_pkt_receive_from_upper+0x297>
			{
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    3f73:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    3f77:	3c 0b                	cmp    $0xb,%al
    3f79:	74 04                	je     3f7f <rlc_pkt_receive_from_upper+0x1df>
    3f7b:	3c 09                	cmp    $0x9,%al
    3f7d:	75 19                	jne    3f98 <rlc_pkt_receive_from_upper+0x1f8>
			{
				fsm_printf("[RLC][rlc_pkt_receive_from_upper][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    3f7f:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    3f83:	c7 04 24 88 0f 00 00 	movl   $0xf88,(%esp)
    3f8a:	89 44 24 04          	mov    %eax,0x4(%esp)
    3f8e:	e8 fc ff ff ff       	call   3f8f <rlc_pkt_receive_from_upper+0x1ef>
				break;
    3f93:	e9 d6 fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    3f98:	b8 18 00 00 00       	mov    $0x18,%eax
    3f9d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    3fa0:	e8 fc ff ff ff       	call   3fa1 <rlc_pkt_receive_from_upper+0x201>
			umElm->pkt = skb;
    3fa5:	89 30                	mov    %esi,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    3fa7:	8d 78 10             	lea    0x10(%eax),%edi
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    3faa:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    3fb1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3fb8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3fbb:	8b 4a 1c             	mov    0x1c(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    3fbe:	89 7a 1c             	mov    %edi,0x1c(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3fc1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    3fc4:	8d 4a 18             	lea    0x18(%edx),%ecx
    3fc7:	89 48 10             	mov    %ecx,0x10(%eax)
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    3fca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    3fcd:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    3fd0:	89 39                	mov    %edi,(%ecx)
			fsm_printf("[RLC][rlc_pkt_receive_from_upper]UM_MODE list_add done!\n");
    3fd2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    3fd5:	c7 04 24 d4 0f 00 00 	movl   $0xfd4,(%esp)
    3fdc:	e8 fc ff ff ff       	call   3fdd <rlc_pkt_receive_from_upper+0x23d>
			
			umTxIns->umSduBufferNum++;
    3fe1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    3fe4:	8b 42 24             	mov    0x24(%edx),%eax
    3fe7:	83 c0 01             	add    $0x1,%eax
    3fea:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    3fed:	3b 83 a8 5a 00 00    	cmp    0x5aa8(%ebx),%eax
    3ff3:	76 06                	jbe    3ffb <rlc_pkt_receive_from_upper+0x25b>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    3ff5:	89 83 a8 5a 00 00    	mov    %eax,0x5aa8(%ebx)
			}
			umTxIns->umSduBufferSize += skb->len;
    3ffb:	8b 46 50             	mov    0x50(%esi),%eax
    3ffe:	01 42 20             	add    %eax,0x20(%edx)
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
		skb = NULL;
		FOUT;
	}
}
    4001:	83 c4 24             	add    $0x24,%esp
    4004:	5b                   	pop    %ebx
    4005:	5e                   	pop    %esi
    4006:	5f                   	pop    %edi
    4007:	5d                   	pop    %ebp
    4008:	c3                   	ret    
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    4009:	83 83 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%ebx)
		fsm_printf("[RLC][rlc_pkt_receive_from_upper] no logic channel to transimmit this message\n");
    4010:	c7 04 24 9c 10 00 00 	movl   $0x109c,(%esp)
    4017:	e8 fc ff ff ff       	call   4018 <rlc_pkt_receive_from_upper+0x278>
		printk("[RLC][rlc_pkt_receive_from_upper] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    401c:	8b 83 9c 5a 00 00    	mov    0x5a9c(%ebx),%eax
    4022:	c7 04 24 50 10 00 00 	movl   $0x1050,(%esp)
    4029:	89 44 24 04          	mov    %eax,0x4(%esp)
    402d:	e8 fc ff ff ff       	call   402e <rlc_pkt_receive_from_upper+0x28e>
    4032:	e9 3b fe ff ff       	jmp    3e72 <rlc_pkt_receive_from_upper+0xd2>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    4037:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    403b:	c7 04 24 3c 0f 00 00 	movl   $0xf3c,(%esp)
    4042:	89 44 24 04          	mov    %eax,0x4(%esp)
    4046:	e8 fc ff ff ff       	call   4047 <rlc_pkt_receive_from_upper+0x2a7>
				break;
    404b:	e9 1e fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    4050:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    4054:	c7 04 24 1c 0e 00 00 	movl   $0xe1c,(%esp)
    405b:	89 44 24 04          	mov    %eax,0x4(%esp)
    405f:	e8 fc ff ff ff       	call   4060 <rlc_pkt_receive_from_upper+0x2c0>
				break;
    4064:	e9 05 fe ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_upper][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    4069:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    406d:	c7 04 24 60 0e 00 00 	movl   $0xe60,(%esp)
    4074:	89 44 24 04          	mov    %eax,0x4(%esp)
    4078:	e8 fc ff ff ff       	call   4079 <rlc_pkt_receive_from_upper+0x2d9>
				break;
    407d:	e9 ec fd ff ff       	jmp    3e6e <rlc_pkt_receive_from_upper+0xce>
    4082:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    4089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00004090 <rlc_mac_main>:
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
    4090:	55                   	push   %ebp
    4091:	89 e5                	mov    %esp,%ebp
    4093:	83 ec 38             	sub    $0x38,%esp
    4096:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    4099:	89 75 f8             	mov    %esi,-0x8(%ebp)
    409c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    409f:	e8 fc ff ff ff       	call   40a0 <rlc_mac_main+0x10>
	FSM_ENTER(rlc_mac_main);
    40a4:	e8 fc ff ff ff       	call   40a5 <rlc_mac_main+0x15>
	FSM_BLOCK_SWITCH
    40a9:	83 38 19             	cmpl   $0x19,(%eax)
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
    40ac:	89 c6                	mov    %eax,%esi
	FSM_BLOCK_SWITCH
    40ae:	76 18                	jbe    40c8 <rlc_mac_main+0x38>
		FSM_STATE_FORCED(ST_NULL_IDLE, "NULL_IDLE", , )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
    40b0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
}
    40b6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    40b9:	8b 75 f8             	mov    -0x8(%ebp),%esi
    40bc:	8b 7d fc             	mov    -0x4(%ebp),%edi
    40bf:	89 ec                	mov    %ebp,%esp
    40c1:	5d                   	pop    %ebp
    40c2:	c3                   	ret    
    40c3:	90                   	nop
    40c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
    40c8:	8b 00                	mov    (%eax),%eax
    40ca:	ff 24 85 00 03 00 00 	jmp    *0x300(,%eax,4)
    40d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    40d8:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    40df:	03 00 00 
		{
			FSM_COND_TEST_IN("IDLE")				
    40e2:	31 db                	xor    %ebx,%ebx
    40e4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    40e9:	e8 fc ff ff ff       	call   40ea <rlc_mac_main+0x5a>
    40ee:	83 f8 03             	cmp    $0x3,%eax
    40f1:	0f 84 94 0f 00 00    	je     508b <rlc_mac_main+0xffb>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    40f7:	e8 fc ff ff ff       	call   40f8 <rlc_mac_main+0x68>
    40fc:	83 f8 03             	cmp    $0x3,%eax
    40ff:	90                   	nop
    4100:	0f 84 6a 0f 00 00    	je     5070 <rlc_mac_main+0xfe0>
				FSM_TEST_COND(MAC_RESET)
    4106:	e8 fc ff ff ff       	call   4107 <rlc_mac_main+0x77>
    410b:	83 f8 05             	cmp    $0x5,%eax
    410e:	66 90                	xchg   %ax,%ax
    4110:	0f 84 2d 0f 00 00    	je     5043 <rlc_mac_main+0xfb3>
				
				FSM_TEST_COND(RLC_SUSPEND)
    4116:	e8 fc ff ff ff       	call   4117 <rlc_mac_main+0x87>
    411b:	83 f8 03             	cmp    $0x3,%eax
    411e:	66 90                	xchg   %ax,%ax
    4120:	0f 84 02 0f 00 00    	je     5028 <rlc_mac_main+0xf98>
				FSM_TEST_COND(RLC_DEACT)
    4126:	e8 fc ff ff ff       	call   4127 <rlc_mac_main+0x97>
    412b:	83 f8 03             	cmp    $0x3,%eax
    412e:	66 90                	xchg   %ax,%ax
    4130:	0f 84 79 0e 00 00    	je     4faf <rlc_mac_main+0xf1f>
				FSM_TEST_COND(RLC_RESUME)
    4136:	e8 fc ff ff ff       	call   4137 <rlc_mac_main+0xa7>
    413b:	83 f8 03             	cmp    $0x3,%eax
    413e:	66 90                	xchg   %ax,%ax
    4140:	0f 84 4e 0e 00 00    	je     4f94 <rlc_mac_main+0xf04>
			FSM_COND_TEST_OUT("IDLE")
    4146:	83 fb 01             	cmp    $0x1,%ebx
    4149:	0f 8e f1 07 00 00    	jle    4940 <rlc_mac_main+0x8b0>
    414f:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    4156:	00 
    4157:	c7 44 24 04 4f 03 00 	movl   $0x34f,0x4(%esp)
    415e:	00 
    415f:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    4166:	e8 fc ff ff ff       	call   4167 <rlc_mac_main+0xd7>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    416b:	c7 05 30 00 00 00 86 	movl   $0x386,0x30
    4172:	03 00 00 
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4175:	e8 fc ff ff ff       	call   4176 <rlc_mac_main+0xe6>
    417a:	89 c7                	mov    %eax,%edi
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code
    417c:	b8 48 11 00 00       	mov    $0x1148,%eax
    4181:	e8 fc ff ff ff       	call   4182 <rlc_mac_main+0xf2>

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    4186:	e8 fc ff ff ff       	call   4187 <rlc_mac_main+0xf7>
    418b:	83 f8 05             	cmp    $0x5,%eax
    418e:	0f 84 86 13 00 00    	je     551a <rlc_mac_main+0x148a>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    4194:	e8 fc ff ff ff       	call   4195 <rlc_mac_main+0x105>
    4199:	83 f8 05             	cmp    $0x5,%eax
    419c:	0f 84 11 14 00 00    	je     55b3 <rlc_mac_main+0x1523>
	{
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
    41a2:	e8 fc ff ff ff       	call   41a3 <rlc_mac_main+0x113>
    41a7:	83 f8 02             	cmp    $0x2,%eax
    41aa:	0f 84 ca 13 00 00    	je     557a <rlc_mac_main+0x14ea>
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    41b0:	e8 fc ff ff ff       	call   41b1 <rlc_mac_main+0x121>
    41b5:	83 f8 01             	cmp    $0x1,%eax
    41b8:	0f 84 c2 14 00 00    	je     5680 <rlc_mac_main+0x15f0>
    41be:	66 90                	xchg   %ax,%ax
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    41c0:	e8 fc ff ff ff       	call   41c1 <rlc_mac_main+0x131>
    41c5:	83 f8 03             	cmp    $0x3,%eax
    41c8:	0f 84 6c 16 00 00    	je     583a <rlc_mac_main+0x17aa>
    41ce:	66 90                	xchg   %ax,%ax
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    41d0:	e8 fc ff ff ff       	call   41d1 <rlc_mac_main+0x141>
    41d5:	83 f8 03             	cmp    $0x3,%eax
    41d8:	0f 84 76 18 00 00    	je     5a54 <rlc_mac_main+0x19c4>
    41de:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
    41e0:	e8 fc ff ff ff       	call   41e1 <rlc_mac_main+0x151>
    41e5:	83 f8 03             	cmp    $0x3,%eax
    41e8:	0f 84 25 18 00 00    	je     5a13 <rlc_mac_main+0x1983>
    41ee:	66 90                	xchg   %ax,%ax
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
		FOUT;
	}
	else if(IOCTRL_ARRIVAL)
    41f0:	e8 fc ff ff ff       	call   41f1 <rlc_mac_main+0x161>
    41f5:	83 f8 05             	cmp    $0x5,%eax
    41f8:	0f 85 29 20 00 00    	jne    6227 <rlc_mac_main+0x2197>
    41fe:	66 90                	xchg   %ax,%ax
    4200:	e8 fc ff ff ff       	call   4201 <rlc_mac_main+0x171>
    4205:	83 f8 02             	cmp    $0x2,%eax
    4208:	0f 85 19 20 00 00    	jne    6227 <rlc_mac_main+0x2197>
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
    420e:	b8 50 13 00 00       	mov    $0x1350,%eax
    4213:	e8 fc ff ff ff       	call   4214 <rlc_mac_main+0x184>
		u32 cmd1=fsm_ev_ioctrl_cmd();
    4218:	e8 fc ff ff ff       	call   4219 <rlc_mac_main+0x189>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
    421d:	89 44 24 04          	mov    %eax,0x4(%esp)
    4221:	c7 04 24 91 03 00 00 	movl   $0x391,(%esp)
    4228:	e8 fc ff ff ff       	call   4229 <rlc_mac_main+0x199>
		switch(fsm_ev_ioctrl_cmd())
    422d:	e8 fc ff ff ff       	call   422e <rlc_mac_main+0x19e>
    4232:	83 f8 0b             	cmp    $0xb,%eax
    4235:	0f 84 3d 1a 00 00    	je     5c78 <rlc_mac_main+0x1be8>
    423b:	90                   	nop
    423c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4240:	0f 87 37 17 00 00    	ja     597d <rlc_mac_main+0x18ed>
    4246:	83 f8 04             	cmp    $0x4,%eax
    4249:	0f 84 a9 1a 00 00    	je     5cf8 <rlc_mac_main+0x1c68>
    424f:	90                   	nop
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
				fsm_data_destroy(tmpdata_ptr);
			break;
			default:
				ioctrl_handler();
    4250:	e8 eb e7 ff ff       	call   2a40 <ioctrl_handler>
			break;
		}
		reports_handler();//BSR PHR 
    4255:	e8 c6 ee ff ff       	call   3120 <reports_handler>
    425a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    4260:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4266:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4269:	8b 75 f8             	mov    -0x8(%ebp),%esi
    426c:	8b 7d fc             	mov    -0x4(%ebp),%edi
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
    426f:	c7 05 30 00 00 00 4f 	movl   $0x34f,0x30
    4276:	03 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4279:	89 ec                	mov    %ebp,%esp
    427b:	5d                   	pop    %ebp
    427c:	c3                   	ret    
    427d:	8b 75 e0             	mov    -0x20(%ebp),%esi
			do_bsr_and_resource_alloc();	//this function should in while loop or not? this a question
		}
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
    4280:	e8 fc ff ff ff       	call   4281 <rlc_mac_main+0x1f1>
    4285:	83 f8 02             	cmp    $0x2,%eax
    4288:	0f 84 f7 1e 00 00    	je     6185 <rlc_mac_main+0x20f5>
		printk("UE RLC_MAC RECV FROM LOER=%d\n",SV(countRecvFromLower));
		decomplexUeDataPdu(fsm_pkt_get());
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
    428e:	e8 fc ff ff ff       	call   428f <rlc_mac_main+0x1ff>
    4293:	83 f8 01             	cmp    $0x1,%eax
    4296:	0f 84 2f 13 00 00    	je     55cb <rlc_mac_main+0x153b>
    429c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    42a0:	e8 fc ff ff ff       	call   42a1 <rlc_mac_main+0x211>
    42a5:	83 f8 03             	cmp    $0x3,%eax
    42a8:	0f 84 0d 15 00 00    	je     57bb <rlc_mac_main+0x172b>
    42ae:	66 90                	xchg   %ax,%ax
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
    42b0:	e8 fc ff ff ff       	call   42b1 <rlc_mac_main+0x221>
    42b5:	83 f8 03             	cmp    $0x3,%eax
    42b8:	0f 84 b4 14 00 00    	je     5772 <rlc_mac_main+0x16e2>
    42be:	66 90                	xchg   %ax,%ax
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
			break;
		}
	}
	else if(IOCTRL_ARRIVAL)
    42c0:	e8 fc ff ff ff       	call   42c1 <rlc_mac_main+0x231>
    42c5:	83 f8 05             	cmp    $0x5,%eax
    42c8:	0f 85 19 20 00 00    	jne    62e7 <rlc_mac_main+0x2257>
    42ce:	66 90                	xchg   %ax,%ax
    42d0:	e8 fc ff ff ff       	call   42d1 <rlc_mac_main+0x241>
    42d5:	83 f8 02             	cmp    $0x2,%eax
    42d8:	0f 85 09 20 00 00    	jne    62e7 <rlc_mac_main+0x2257>
    42de:	66 90                	xchg   %ax,%ax
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
    42e0:	e8 fc ff ff ff       	call   42e1 <rlc_mac_main+0x251>
    42e5:	83 f8 0b             	cmp    $0xb,%eax
    42e8:	0f 84 c0 16 00 00    	je     59ae <rlc_mac_main+0x191e>
    42ee:	66 90                	xchg   %ax,%ax
			//RLCdatareqMAC reqregularBSR 
			//SR RLCreq
			//MACSR  
		}
		else 
			ioctrl_handler();  //ioctrl		
    42f0:	e8 4b e7 ff ff       	call   2a40 <ioctrl_handler>
		print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
    42f5:	b8 e8 1d 00 00       	mov    $0x1de8,%eax
    42fa:	e8 fc ff ff ff       	call   42fb <rlc_mac_main+0x26b>
		reports_handler();//BSR PHR cut to this domian 20150910
    42ff:	e8 1c ee ff ff       	call   3120 <reports_handler>
    4304:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    4308:	c7 06 09 00 00 00    	movl   $0x9,(%esi)
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    430e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    4311:	8b 75 f8             	mov    -0x8(%ebp),%esi
    4314:	8b 7d fc             	mov    -0x4(%ebp),%edi
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    4317:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    431e:	04 00 00 
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "NULL_IDLE -> IDLE");
		}
	}
	FSM_EXIT(0)
}
    4321:	89 ec                	mov    %ebp,%esp
    4323:	5d                   	pop    %ebp
    4324:	c3                   	ret    
    4325:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    4328:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    432f:	03 00 00 
		{
			FSM_COND_TEST_IN("CRA")
    4332:	31 db                	xor    %ebx,%ebx
    4334:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4339:	e8 fc ff ff ff       	call   433a <rlc_mac_main+0x2aa>
    433e:	83 f8 03             	cmp    $0x3,%eax
    4341:	0f 84 ba 0b 00 00    	je     4f01 <rlc_mac_main+0xe71>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4347:	e8 fc ff ff ff       	call   4348 <rlc_mac_main+0x2b8>
    434c:	83 f8 03             	cmp    $0x3,%eax
    434f:	90                   	nop
    4350:	0f 84 3a 0a 00 00    	je     4d90 <rlc_mac_main+0xd00>
    4356:	e8 fc ff ff ff       	call   4357 <rlc_mac_main+0x2c7>
    435b:	83 f8 03             	cmp    $0x3,%eax
    435e:	66 90                	xchg   %ax,%ax
    4360:	0f 84 6a 0a 00 00    	je     4dd0 <rlc_mac_main+0xd40>
    4366:	e8 fc ff ff ff       	call   4367 <rlc_mac_main+0x2d7>
    436b:	83 f8 05             	cmp    $0x5,%eax
    436e:	66 90                	xchg   %ax,%ax
    4370:	0f 84 02 0f 00 00    	je     5278 <rlc_mac_main+0x11e8>
				FSM_TEST_COND(RARREV_SUCCESS)
    4376:	e8 fc ff ff ff       	call   4377 <rlc_mac_main+0x2e7>
    437b:	83 f8 03             	cmp    $0x3,%eax
    437e:	66 90                	xchg   %ax,%ax
    4380:	0f 84 ea 09 00 00    	je     4d70 <rlc_mac_main+0xce0>
    4386:	e8 fc ff ff ff       	call   4387 <rlc_mac_main+0x2f7>
    438b:	83 f8 05             	cmp    $0x5,%eax
    438e:	66 90                	xchg   %ax,%ax
    4390:	0f 84 82 0d 00 00    	je     5118 <rlc_mac_main+0x1088>
				FSM_TEST_COND(CONTENTION_FAIL )
    4396:	e8 fc ff ff ff       	call   4397 <rlc_mac_main+0x307>
    439b:	83 f8 03             	cmp    $0x3,%eax
    439e:	66 90                	xchg   %ax,%ax
    43a0:	0f 84 aa 09 00 00    	je     4d50 <rlc_mac_main+0xcc0>
    43a6:	e8 fc ff ff ff       	call   43a7 <rlc_mac_main+0x317>
    43ab:	83 f8 03             	cmp    $0x3,%eax
    43ae:	66 90                	xchg   %ax,%ax
    43b0:	0f 84 52 0a 00 00    	je     4e08 <rlc_mac_main+0xd78>
    43b6:	e8 fc ff ff ff       	call   43b7 <rlc_mac_main+0x327>
    43bb:	83 f8 05             	cmp    $0x5,%eax
    43be:	66 90                	xchg   %ax,%ax
    43c0:	0f 84 90 0e 00 00    	je     5256 <rlc_mac_main+0x11c6>
				FSM_TEST_COND(CONTENTION_SUCCESS)
    43c6:	e8 fc ff ff ff       	call   43c7 <rlc_mac_main+0x337>
    43cb:	83 f8 03             	cmp    $0x3,%eax
    43ce:	66 90                	xchg   %ax,%ax
    43d0:	0f 84 5a 09 00 00    	je     4d30 <rlc_mac_main+0xca0>
    43d6:	e8 fc ff ff ff       	call   43d7 <rlc_mac_main+0x347>
    43db:	83 f8 05             	cmp    $0x5,%eax
    43de:	66 90                	xchg   %ax,%ax
    43e0:	0f 84 0d 0d 00 00    	je     50f3 <rlc_mac_main+0x1063>
				FSM_TEST_COND(MAC_RESET)
    43e6:	e8 fc ff ff ff       	call   43e7 <rlc_mac_main+0x357>
    43eb:	83 f8 05             	cmp    $0x5,%eax
    43ee:	66 90                	xchg   %ax,%ax
    43f0:	0f 84 02 0c 00 00    	je     4ff8 <rlc_mac_main+0xf68>
			FSM_COND_TEST_OUT("CRA")
    43f6:	83 fb 01             	cmp    $0x1,%ebx
    43f9:	0f 8e f9 05 00 00    	jle    49f8 <rlc_mac_main+0x968>
    43ff:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    4406:	00 
    4407:	c7 44 24 04 a7 03 00 	movl   $0x3a7,0x4(%esp)
    440e:	00 
    440f:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    4416:	e8 fc ff ff ff       	call   4417 <rlc_mac_main+0x387>
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
				FSM_CASE_DEFAULT(ST_CRA,cra_default_handler() , "CRA->CRA")	//transit to CRA state	by default.
    441b:	c7 05 30 00 00 00 cd 	movl   $0x3cd,0x30
    4422:	03 00 00 
static void cra_default_handler()
{
	void *tmpdata_ptr;
	u32 tmpdata;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4425:	e8 fc ff ff ff       	call   4426 <rlc_mac_main+0x396>
	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    442a:	83 b8 ec 01 00 00 01 	cmpl   $0x1,0x1ec(%eax)
static void cra_default_handler()
{
	void *tmpdata_ptr;
	u32 tmpdata;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    4431:	89 c3                	mov    %eax,%ebx
	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    4433:	0f 84 03 11 00 00    	je     553c <rlc_mac_main+0x14ac>
		fsm_schedule_self(0, Contention_Success );//TEST  	
	if(MAC_CLOSE)
    4439:	e8 fc ff ff ff       	call   443a <rlc_mac_main+0x3aa>
    443e:	83 f8 05             	cmp    $0x5,%eax
    4441:	0f 84 ce 13 00 00    	je     5815 <rlc_mac_main+0x1785>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    4447:	e8 fc ff ff ff       	call   4448 <rlc_mac_main+0x3b8>
    444c:	83 f8 02             	cmp    $0x2,%eax
    444f:	90                   	nop
    4450:	0f 84 ae 13 00 00    	je     5804 <rlc_mac_main+0x1774>
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_pkt_destroy(fsm_pkt_get());
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
    4456:	e8 fc ff ff ff       	call   4457 <rlc_mac_main+0x3c7>
    445b:	83 f8 01             	cmp    $0x1,%eax
    445e:	66 90                	xchg   %ax,%ax
    4460:	0f 84 43 14 00 00    	je     58a9 <rlc_mac_main+0x1819>
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
	}
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4466:	e8 fc ff ff ff       	call   4467 <rlc_mac_main+0x3d7>
    446b:	83 f8 03             	cmp    $0x3,%eax
    446e:	66 90                	xchg   %ax,%ax
    4470:	0f 84 0c 14 00 00    	je     5882 <rlc_mac_main+0x17f2>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
	}
	if(IOCTRL_ARRIVAL)
    4476:	e8 fc ff ff ff       	call   4477 <rlc_mac_main+0x3e7>
    447b:	83 f8 05             	cmp    $0x5,%eax
    447e:	66 90                	xchg   %ax,%ax
    4480:	75 26                	jne    44a8 <rlc_mac_main+0x418>
    4482:	e8 fc ff ff ff       	call   4483 <rlc_mac_main+0x3f3>
    4487:	83 f8 02             	cmp    $0x2,%eax
    448a:	75 1c                	jne    44a8 <rlc_mac_main+0x418>
    448c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		switch(fsm_ev_ioctrl_cmd())
    4490:	e8 fc ff ff ff       	call   4491 <rlc_mac_main+0x401>
    4495:	83 f8 0b             	cmp    $0xb,%eax
    4498:	0f 84 7a 1c 00 00    	je     6118 <rlc_mac_main+0x2088>
    449e:	66 90                	xchg   %ax,%ax
					tmpdata_ptr = (char *)fsm_data_get();
					fsm_data_destroy((void *)tmpdata_ptr);//
				}				
			break;
			default:
				ioctrl_handler();//ioctrl
    44a0:	e8 9b e5 ff ff       	call   2a40 <ioctrl_handler>
    44a5:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
    44a8:	c7 05 30 00 00 00 a7 	movl   $0x3a7,0x30
    44af:	03 00 00 
    44b2:	c7 06 05 00 00 00    	movl   $0x5,(%esi)
    44b8:	e9 f9 fb ff ff       	jmp    40b6 <rlc_mac_main+0x26>
    44bd:	8d 76 00             	lea    0x0(%esi),%esi
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    44c0:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    44c7:	03 00 00 
		{
			FSM_COND_TEST_IN("NCRA")
    44ca:	31 db                	xor    %ebx,%ebx
    44cc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    44d1:	e8 fc ff ff ff       	call   44d2 <rlc_mac_main+0x442>
    44d6:	83 f8 03             	cmp    $0x3,%eax
    44d9:	0f 84 c5 0b 00 00    	je     50a4 <rlc_mac_main+0x1014>
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    44df:	e8 fc ff ff ff       	call   44e0 <rlc_mac_main+0x450>
    44e4:	83 f8 03             	cmp    $0x3,%eax
    44e7:	0f 84 c3 08 00 00    	je     4db0 <rlc_mac_main+0xd20>
    44ed:	8d 76 00             	lea    0x0(%esi),%esi
    44f0:	e8 fc ff ff ff       	call   44f1 <rlc_mac_main+0x461>
    44f5:	83 f8 03             	cmp    $0x3,%eax
    44f8:	0f 84 ea 08 00 00    	je     4de8 <rlc_mac_main+0xd58>
    44fe:	66 90                	xchg   %ax,%ax
    4500:	e8 fc ff ff ff       	call   4501 <rlc_mac_main+0x471>
    4505:	83 f8 05             	cmp    $0x5,%eax
    4508:	0f 84 9a 0d 00 00    	je     52a8 <rlc_mac_main+0x1218>
    450e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RARREV_SUCCESS)
    4510:	e8 fc ff ff ff       	call   4511 <rlc_mac_main+0x481>
    4515:	83 f8 03             	cmp    $0x3,%eax
    4518:	0f 84 f2 07 00 00    	je     4d10 <rlc_mac_main+0xc80>
    451e:	66 90                	xchg   %ax,%ax
    4520:	e8 fc ff ff ff       	call   4521 <rlc_mac_main+0x491>
    4525:	83 f8 05             	cmp    $0x5,%eax
    4528:	0f 84 1a 0c 00 00    	je     5148 <rlc_mac_main+0x10b8>
    452e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(MAC_RESET)
    4530:	e8 fc ff ff ff       	call   4531 <rlc_mac_main+0x4a1>
    4535:	83 f8 05             	cmp    $0x5,%eax
    4538:	0f 84 8c 0a 00 00    	je     4fca <rlc_mac_main+0xf3a>
			FSM_COND_TEST_OUT("NCRA")
    453e:	83 fb 01             	cmp    $0x1,%ebx
    4541:	0f 8e 81 07 00 00    	jle    4cc8 <rlc_mac_main+0xc38>
    4547:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    454e:	00 
    454f:	c7 44 24 04 d6 03 00 	movl   $0x3d6,0x4(%esp)
    4556:	00 
    4557:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    455e:	e8 fc ff ff ff       	call   455f <rlc_mac_main+0x4cf>
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4563:	b8 fc 18 00 00       	mov    $0x18fc,%eax
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
    4568:	c7 05 30 00 00 00 f4 	movl   $0x3f4,0x30
    456f:	03 00 00 
*******************************
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
    4572:	e8 fc ff ff ff       	call   4573 <rlc_mac_main+0x4e3>
	if(MAC_CLOSE)
    4577:	e8 fc ff ff ff       	call   4578 <rlc_mac_main+0x4e8>
    457c:	83 f8 05             	cmp    $0x5,%eax
    457f:	0f 84 c5 11 00 00    	je     574a <rlc_mac_main+0x16ba>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
    4585:	e8 fc ff ff ff       	call   4586 <rlc_mac_main+0x4f6>
    458a:	83 f8 02             	cmp    $0x2,%eax
    458d:	0f 84 a6 11 00 00    	je     5739 <rlc_mac_main+0x16a9>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    4593:	e8 fc ff ff ff       	call   4594 <rlc_mac_main+0x504>
    4598:	83 f8 03             	cmp    $0x3,%eax
    459b:	0f 84 6e 11 00 00    	je     570f <rlc_mac_main+0x167f>
	{
		FlushBj();
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
	}
	if(IOCTRL_ARRIVAL)
    45a1:	e8 fc ff ff ff       	call   45a2 <rlc_mac_main+0x512>
    45a6:	83 f8 05             	cmp    $0x5,%eax
    45a9:	75 15                	jne    45c0 <rlc_mac_main+0x530>
    45ab:	90                   	nop
    45ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    45b0:	e8 fc ff ff ff       	call   45b1 <rlc_mac_main+0x521>
    45b5:	83 f8 02             	cmp    $0x2,%eax
    45b8:	75 06                	jne    45c0 <rlc_mac_main+0x530>
		ioctrl_handler();//ioctrl
    45ba:	e8 81 e4 ff ff       	call   2a40 <ioctrl_handler>
    45bf:	90                   	nop
				//FSM_CASE_TRANSIT(1, ST_IDLE, print_tran_info("reset SENDMSG3 -> IDLE"), "SENDMSG3 -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "SENDMSG3 -> IDLE")
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
    45c0:	c7 05 30 00 00 00 d6 	movl   $0x3d6,0x30
    45c7:	03 00 00 
    45ca:	c7 06 07 00 00 00    	movl   $0x7,(%esi)
    45d0:	e9 e1 fa ff ff       	jmp    40b6 <rlc_mac_main+0x26>
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
    45d5:	c7 06 0c 00 00 00    	movl   $0xc,(%esi)
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
		}
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
    45db:	c7 05 30 00 00 00 3d 	movl   $0x33d,0x30
    45e2:	03 00 00 
    45e5:	e8 36 e1 ff ff       	call   2720 <rlc_init_enter>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
    45ea:	e9 71 fc ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    45ef:	90                   	nop
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
    45f0:	c7 05 30 00 00 00 01 	movl   $0x401,0x30
    45f7:	04 00 00 
		{
			FSM_COND_TEST_IN("CON")
    45fa:	31 db                	xor    %ebx,%ebx
    45fc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4601:	e8 fc ff ff ff       	call   4602 <rlc_mac_main+0x572>
    4606:	83 f8 03             	cmp    $0x3,%eax
    4609:	0f 84 6c 09 00 00    	je     4f7b <rlc_mac_main+0xeeb>
				FSM_TEST_COND(SR_FAIL)
    460f:	e8 fc ff ff ff       	call   4610 <rlc_mac_main+0x580>
    4614:	83 f8 03             	cmp    $0x3,%eax
    4617:	0f 84 43 09 00 00    	je     4f60 <rlc_mac_main+0xed0>
    461d:	8d 76 00             	lea    0x0(%esi),%esi
				FSM_TEST_COND(MAC_RESET)
    4620:	e8 fc ff ff ff       	call   4621 <rlc_mac_main+0x591>
    4625:	83 f8 05             	cmp    $0x5,%eax
    4628:	0f 84 07 09 00 00    	je     4f35 <rlc_mac_main+0xea5>
    462e:	66 90                	xchg   %ax,%ax

				FSM_TEST_COND(RLC_SUSPEND)
    4630:	e8 fc ff ff ff       	call   4631 <rlc_mac_main+0x5a1>
    4635:	83 f8 03             	cmp    $0x3,%eax
    4638:	0f 84 9a 0a 00 00    	je     50d8 <rlc_mac_main+0x1048>
    463e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_DEACT)
    4640:	e8 fc ff ff ff       	call   4641 <rlc_mac_main+0x5b1>
    4645:	83 f8 03             	cmp    $0x3,%eax
    4648:	0f 84 6f 0a 00 00    	je     50bd <rlc_mac_main+0x102d>
    464e:	66 90                	xchg   %ax,%ax
				FSM_TEST_COND(RLC_RESUME)
    4650:	e8 fc ff ff ff       	call   4651 <rlc_mac_main+0x5c1>
    4655:	83 f8 03             	cmp    $0x3,%eax
    4658:	0f 84 bc 08 00 00    	je     4f1a <rlc_mac_main+0xe8a>
			FSM_COND_TEST_OUT("CON")
    465e:	83 fb 01             	cmp    $0x1,%ebx
    4661:	0f 8e 79 02 00 00    	jle    48e0 <rlc_mac_main+0x850>
    4667:	c7 44 24 08 54 03 00 	movl   $0x354,0x8(%esp)
    466e:	00 
    466f:	c7 44 24 04 01 04 00 	movl   $0x401,0x4(%esp)
    4676:	00 
    4677:	c7 04 24 68 03 00 00 	movl   $0x368,(%esp)
    467e:	e8 fc ff ff ff       	call   467f <rlc_mac_main+0x5ef>
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_CON,con_default_handler() , "CON -> CON")	//transit to CON state	by default.
    4683:	c7 05 30 00 00 00 1c 	movl   $0x41c,0x30
    468a:	04 00 00 
	struct  UM_RX_Instance *umRxIns;
	void *insPtr;
	int i;

	FIN(con_default_handler());
	SV_PTR_GET(rlc_mac_sv);
    468d:	e8 fc ff ff ff       	call   468e <rlc_mac_main+0x5fe>
    4692:	89 c3                	mov    %eax,%ebx

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    4694:	e8 fc ff ff ff       	call   4695 <rlc_mac_main+0x605>
    4699:	83 f8 05             	cmp    $0x5,%eax
    469c:	0f 84 b5 0e 00 00    	je     5557 <rlc_mac_main+0x14c7>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    46a2:	e8 fc ff ff ff       	call   46a3 <rlc_mac_main+0x613>
    46a7:	83 f8 05             	cmp    $0x5,%eax
    46aa:	0f 84 94 12 00 00    	je     5944 <rlc_mac_main+0x18b4>
		rlc_close();
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
		FOUT;
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
    46b0:	80 bb 5a 01 00 00 00 	cmpb   $0x0,0x15a(%ebx)
    46b7:	74 0a                	je     46c3 <rlc_mac_main+0x633>
    46b9:	80 7b 28 00          	cmpb   $0x0,0x28(%ebx)
    46bd:	0f 85 92 11 00 00    	jne    5855 <rlc_mac_main+0x17c5>
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
    46c3:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    46c9:	66 83 7a 08 00       	cmpw   $0x0,0x8(%edx)
    46ce:	0f 84 ac fb ff ff    	je     4280 <rlc_mac_main+0x1f0>
	fsm_octets_print(skb->data,64);
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    46d4:	89 75 e0             	mov    %esi,-0x20(%ebp)
    46d7:	e9 c8 00 00 00       	jmp    47a4 <rlc_mac_main+0x714>
    46dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
    46e0:	83 f8 03             	cmp    $0x3,%eax
    46e3:	0f 84 d2 0a 00 00    	je     51bb <rlc_mac_main+0x112b>
    46e9:	83 f8 01             	cmp    $0x1,%eax
    46ec:	0f 84 86 0a 00 00    	je     5178 <rlc_mac_main+0x10e8>
			tmTxIns->tmSduBufferSize += skb->len;
			
			FOUT;
			break;
		default:
			SV(countDropPacket)++;
    46f2:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
			printk("[RLC][skb_from_cra_to_con] cannot distinfuish this %d\n", SV(ins_mode));
    46f9:	89 44 24 04          	mov    %eax,0x4(%esp)
    46fd:	c7 04 24 f8 1b 00 00 	movl   $0x1bf8,(%esp)
    4704:	e8 fc ff ff ff       	call   4705 <rlc_mac_main+0x675>
			printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    4709:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    470f:	c7 04 24 30 1c 00 00 	movl   $0x1c30,(%esp)
    4716:	89 44 24 04          	mov    %eax,0x4(%esp)
    471a:	e8 fc ff ff ff       	call   471b <rlc_mac_main+0x68b>
	else
	{
		SV(countDropPacket)++;
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
		fsm_pkt_destroy(skb);
    471f:	89 f0                	mov    %esi,%eax
    4721:	e8 fc ff ff ff       	call   4722 <rlc_mac_main+0x692>
{
	char *tmpdata_ptr;
	int tmpdata;

	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);
    4726:	e8 fc ff ff ff       	call   4727 <rlc_mac_main+0x697>
    472b:	89 c6                	mov    %eax,%esi

	if( PMRLC_BUFFERREP_REQ() == NULL )
    472d:	e8 fc ff ff ff       	call   472e <rlc_mac_main+0x69e>
    4732:	85 c0                	test   %eax,%eax
    4734:	0f 84 a0 0c 00 00    	je     53da <rlc_mac_main+0x134a>
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    473a:	e8 fc ff ff ff       	call   473b <rlc_mac_main+0x6ab>
		tmpdata = *((u32*)tmpdata_ptr);//	
    473f:	8b 10                	mov    (%eax),%edx
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		FOUT;
	}		
	else{
		tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    4741:	89 c7                	mov    %eax,%edi
		tmpdata = *((u32*)tmpdata_ptr);//	
		if( tmpdata > 0 )
    4743:	85 d2                	test   %edx,%edx
    4745:	7e 21                	jle    4768 <rlc_mac_main+0x6d8>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    4747:	8d 40 04             	lea    0x4(%eax),%eax
    474a:	e8 fc ff ff ff       	call   474b <rlc_mac_main+0x6bb>
    474f:	e8 fc ff ff ff       	call   4750 <rlc_mac_main+0x6c0>
			fsm_data_destroy((void *)tmpdata_ptr);//
    4754:	89 f8                	mov    %edi,%eax
    4756:	e8 fc ff ff ff       	call   4757 <rlc_mac_main+0x6c7>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    475b:	80 be 58 01 00 00 00 	cmpb   $0x0,0x158(%esi)
    4762:	0f 85 c9 0b 00 00    	jne    5331 <rlc_mac_main+0x12a1>
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    4768:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
		}
	}

	SV(UL_resource_info.resource_flag) = true;
    476e:	c6 46 28 01          	movb   $0x1,0x28(%esi)
		/********for test 20150916 *********/
	if(SV(UL_resource_info.resource_flag) == true)
	{
		//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
		SV(UL_resource_info.m_tbsize)=1470*8;//for test
    4772:	c7 46 2c f0 2d 00 00 	movl   $0x2df0,0x2c(%esi)
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4779:	c7 86 f4 01 00 00 be 	movl   $0x5be,0x1f4(%esi)
    4780:	05 00 00 
		//fsm_printf("ready resource \n");
		if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    4783:	8d 50 05             	lea    0x5(%eax),%edx
    4786:	39 50 05             	cmp    %edx,0x5(%eax)
    4789:	74 0f                	je     479a <rlc_mac_main+0x70a>
			DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    478b:	b8 f0 2d 00 00       	mov    $0x2df0,%eax
    4790:	e8 fc ff ff ff       	call   4791 <rlc_mac_main+0x701>
    4795:	e8 fc ff ff ff       	call   4796 <rlc_mac_main+0x706>
		SV(UL_resource_info.resource_flag)=false;
    479a:	c6 46 28 00          	movb   $0x0,0x28(%esi)
    479e:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    47a4:	8b 0a                	mov    (%edx),%ecx
    47a6:	8b 7a 04             	mov    0x4(%edx),%edi
		SV(UL_resource_info.resource_flag)=false;
	}
	if(GetCountOfQueue(SV(CraQueue)) > 0)
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
    47a9:	39 f9                	cmp    %edi,%ecx
    47ab:	0f 84 cc fa ff ff    	je     427d <rlc_mac_main+0x1ed>
//the first node is head node, so always take the second node out.
static FSM_PKT * DeQueue(CraQueuePtr *Q)
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
    47b1:	3b 93 18 02 00 00    	cmp    0x218(%ebx),%edx
    47b7:	0f 84 2e 0c 00 00    	je     53eb <rlc_mac_main+0x135b>
	// p = (*Q)->front;
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
    47bd:	8b 41 04             	mov    0x4(%ecx),%eax
	pktptr = p->pkt;
	if((*Q)->rear == p)
    47c0:	39 f8                	cmp    %edi,%eax
	// pktptr = p->pkt;
	// (*Q)->front = p->next;
	// if((*Q)->rear == p)
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
    47c2:	8b 30                	mov    (%eax),%esi
	if((*Q)->rear == p)
    47c4:	0f 84 0e 0b 00 00    	je     52d8 <rlc_mac_main+0x1248>
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
		(*Q)->front->next = NULL;
	}
	else
		(*Q)->front->next = p->next;	//more than 2 pkt in the queue.
    47ca:	8b 50 04             	mov    0x4(%eax),%edx
    47cd:	89 51 04             	mov    %edx,0x4(%ecx)

	fsm_mem_free(p);
    47d0:	e8 fc ff ff ff       	call   47d1 <rlc_mac_main+0x741>
	(*Q)->pkt_count--;
    47d5:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    47db:	66 83 68 08 01       	subw   $0x1,0x8(%eax)
	fsm_printf("[DeQueue]DeQueue successfully!\n");
    47e0:	c7 04 24 a8 19 00 00 	movl   $0x19a8,(%esp)
    47e7:	e8 fc ff ff ff       	call   47e8 <rlc_mac_main+0x758>
	{
		//fsm_printf("[RLC_MAC][con_default_handler]there are pkt in CraQueue!\n");
		while(!QueueEmpty(SV(CraQueue)))
		{
			pkptr = DeQueue(&SV(CraQueue));
			if(pkptr == NULL)
    47ec:	85 f6                	test   %esi,%esi
    47ee:	74 ae                	je     479e <rlc_mac_main+0x70e>
				continue;

			fsm_printf("[con_default_handler]SV(CraQueue): %p, pkptr: %p\n", SV(CraQueue), pkptr);
    47f0:	89 74 24 08          	mov    %esi,0x8(%esp)
    47f4:	8b 83 14 02 00 00    	mov    0x214(%ebx),%eax
    47fa:	c7 04 24 c8 19 00 00 	movl   $0x19c8,(%esp)
    4801:	89 44 24 04          	mov    %eax,0x4(%esp)
    4805:	e8 fc ff ff ff       	call   4806 <rlc_mac_main+0x776>
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    480a:	e8 fc ff ff ff       	call   480b <rlc_mac_main+0x77b>

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    480f:	8b 8e a8 00 00 00    	mov    0xa8(%esi),%ecx
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    4815:	ba 40 00 00 00       	mov    $0x40,%edx
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
    481a:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	struct  UM_TX_Instance *umTxIns;
	struct  TM_TX_Instance *tmTxIns;
	void *insptru, *insptrd;
	
	FIN(skb_from_cra_to_con());
	SV_PTR_GET(rlc_mac_sv);	
    481d:	89 c7                	mov    %eax,%edi

	//skb = (FSM_PKT *)fsm_pkt_get();
	iciMsg = (URLC_IciMsg*)skb->head;
	//fsm_printf("[RLC][skb_from_cra_to_con]receive from cra list, pbch=%d, rbid=%d\n",iciMsg->pbCh,iciMsg->rbId);
	//fsm_printf("[skb_from_cra_to_con]skb->data: %p\n", skb->data);
	fsm_octets_print(skb->data,64);
    481f:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    4825:	e8 fc ff ff ff       	call   4826 <rlc_mac_main+0x796>
	//fsm_printf("the icimsg are %d, %d, %d\n",iciMsg->pbCh, iciMsg->rbId,iciMsg->rnti);
	//fsm_printf("[RLC] pbch is %d\n",iciMsg->pbCh);
	if(iciMsg->pbCh == 0)
    482a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    482d:	80 38 00             	cmpb   $0x0,(%eax)
    4830:	0f 85 c2 1a 00 00    	jne    62f8 <rlc_mac_main+0x2268>
	{
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
    4836:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    483a:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    4840:	89 14 24             	mov    %edx,(%esp)
    4843:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    4846:	8d 55 ec             	lea    -0x14(%ebp),%edx
    4849:	e8 fc ff ff ff       	call   484a <rlc_mac_main+0x7ba>
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
    484e:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    4854:	c7 04 24 fc 19 00 00 	movl   $0x19fc,(%esp)
    485b:	89 44 24 04          	mov    %eax,0x4(%esp)
    485f:	e8 fc ff ff ff       	call   4860 <rlc_mac_main+0x7d0>
		switch(SV(ins_mode))
    4864:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    486a:	83 f8 02             	cmp    $0x2,%eax
    486d:	0f 85 6d fe ff ff    	jne    46e0 <rlc_mac_main+0x650>
			
			FOUT;
			break;

		case UM_MODE:
			if(insptru == NULL)
    4873:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4876:	85 d2                	test   %edx,%edx
    4878:	0f 84 f9 1a 00 00    	je     6377 <rlc_mac_main+0x22e7>
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if((umTxIns->CurrentStatVar == ST_SUSPEND) || (umTxIns->CurrentStatVar == ST_SUSPEND_IDLE))
    487e:	0f b6 42 2c          	movzbl 0x2c(%edx),%eax
    4882:	3c 0b                	cmp    $0xb,%al
    4884:	74 08                	je     488e <rlc_mac_main+0x7fe>
    4886:	3c 09                	cmp    $0x9,%al
    4888:	0f 85 ad 0a 00 00    	jne    533b <rlc_mac_main+0x12ab>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
    488e:	0f b6 42 02          	movzbl 0x2(%edx),%eax
    4892:	c7 04 24 7c 1b 00 00 	movl   $0x1b7c,(%esp)
    4899:	89 44 24 04          	mov    %eax,0x4(%esp)
    489d:	e8 fc ff ff ff       	call   489e <rlc_mac_main+0x80e>
    48a2:	e9 78 fe ff ff       	jmp    471f <rlc_mac_main+0x68f>
    48a7:	90                   	nop
void rlc_mac_main(void)
{
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
    48a8:	c7 05 30 00 00 00 38 	movl   $0x338,0x30
    48af:	03 00 00 
}

static void init_enter()
{
	FIN(init_enter());
	ue_mac_sv_init();
    48b2:	e8 c9 eb ff ff       	call   3480 <ue_mac_sv_init>
	rlc_init_enter();
    48b7:	e8 64 de ff ff       	call   2720 <rlc_init_enter>
	FSM_ENTER(rlc_mac_main);
	FSM_BLOCK_SWITCH
	{
		FSM_STATE_FORCED(ST_INIT, "INIT", init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "INIT -> IDLE");
    48bc:	e9 9f f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    48c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_FORCED(ST_RLC_INIT, "RLC_INIT", rlc_init_enter(), )
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "RLC_INIT -> IDLE"); 
			//add RLC_INTI state, transmit to IDLE, 20150803
		}
		FSM_STATE_FORCED(ST_MAC_INIT, "MAC_INIT", ue_mac_sv_init(), )
    48c8:	c7 05 30 00 00 00 46 	movl   $0x346,0x30
    48cf:	03 00 00 
    48d2:	e8 a9 eb ff ff       	call   3480 <ue_mac_sv_init>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
    48d7:	e9 84 f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    48dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
    48e0:	85 db                	test   %ebx,%ebx
    48e2:	0f 84 9b fd ff ff    	je     4683 <rlc_mac_main+0x5f3>
			FSM_TRANSIT_SWITCH
    48e8:	83 ff 05             	cmp    $0x5,%edi
    48eb:	90                   	nop
    48ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    48f0:	0f 87 8d fd ff ff    	ja     4683 <rlc_mac_main+0x5f3>
    48f6:	ff 24 bd 68 03 00 00 	jmp    *0x368(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset CON -> IDLE"), "CON -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")
    48fd:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    4904:	04 00 00 
    4907:	e8 c4 ef ff ff       	call   38d0 <ue_mac_reset>
    490c:	e9 4f f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
				FSM_CASE_TRANSIT(1, ST_CRA, doStartContentionBasedRandomAccessProcedure() , "CON -> CRA")
    4911:	c7 05 30 00 00 00 11 	movl   $0x411,0x30
    4918:	04 00 00 
    491b:	e8 50 e7 ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
    4920:	e9 83 fb ff ff       	jmp    44a8 <rlc_mac_main+0x418>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("CON")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CON -> IDLE")//handle_timeAlignmentTimerExpire()
    4925:	c7 05 30 00 00 00 05 	movl   $0x405,0x30
    492c:	04 00 00 
    492f:	e8 2c ea ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    4934:	e9 27 f9 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4939:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
    4940:	85 db                	test   %ebx,%ebx
    4942:	0f 84 23 f8 ff ff    	je     416b <rlc_mac_main+0xdb>
			FSM_TRANSIT_SWITCH
    4948:	83 ff 05             	cmp    $0x5,%edi
    494b:	90                   	nop
    494c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4950:	0f 87 15 f8 ff ff    	ja     416b <rlc_mac_main+0xdb>
    4956:	ff 24 bd 80 03 00 00 	jmp    *0x380(,%edi,4)
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
    495d:	c7 05 30 00 00 00 79 	movl   $0x379,0x30
    4964:	03 00 00 
    4967:	e8 64 ef ff ff       	call   38d0 <ue_mac_reset>
    496c:	e9 ef f8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    4971:	c7 05 30 00 00 00 ea 	movl   $0x1ea,0x30
    4978:	01 00 00 
*******************************
*/
static void doStartNonContentionBasedRandomAccessProcedure() //modified by HQ  20140413
{
	FIN(doStartNonContentionBasedRandomAccessProcedure());
	SV_PTR_GET(rlc_mac_sv);
    497b:	e8 fc ff ff ff       	call   497c <rlc_mac_main+0x8ec>
    4980:	89 c3                	mov    %eax,%ebx
	RACH_ConfigDedicated *randomaccess_info=(RACH_ConfigDedicated *)fsm_mem_alloc(sizeof(RACH_ConfigDedicated ));
    4982:	b8 02 00 00 00       	mov    $0x2,%eax
    4987:	e8 fc ff ff ff       	call   4988 <rlc_mac_main+0x8f8>
    498c:	89 c7                	mov    %eax,%edi
	int mg3_buffer;
	print_tran_info("[UEMAC][noncontention_ra]startNCRA IDLE -> NCRA");//testing code
    498e:	b8 ec 10 00 00       	mov    $0x10ec,%eax
    4993:	e8 fc ff ff ff       	call   4994 <rlc_mac_main+0x904>
	if(SV(PREAMBLE_TRANSMISSION_COUNTER ) == 0)   //
    4998:	8b 43 14             	mov    0x14(%ebx),%eax
    499b:	85 c0                	test   %eax,%eax
    499d:	75 10                	jne    49af <rlc_mac_main+0x91f>
	{ 
		SV(PREAMBLE_TRANSMISSION_COUNTER ) = 1; //PREAMBLE_TRANSMISSION_COUNTER1 
    499f:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		SV(backoff_index) = 0;  //UEbackoff0ms    
    49a6:	b0 01                	mov    $0x1,%al
    49a8:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		mg3_buffer = 0;   //MSG3//
	}
	fsm_printf("[UEMAC][noncontention_ra]RA counter :%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER ));//testing code
    49af:	89 44 24 04          	mov    %eax,0x4(%esp)
    49b3:	c7 04 24 1c 11 00 00 	movl   $0x111c,(%esp)
    49ba:	e8 fc ff ff ff       	call   49bb <rlc_mac_main+0x92b>
	//
	randomaccess_info->ra_PreambleIndex=SV(RA_info.ra_PreambleIndex);
    49bf:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
    49c3:	88 07                	mov    %al,(%edi)
	//fsm_printf("[HEXI]PREAMBLE INDEX IN MACFSM:%d\n",SV(RA_info.ra_PreambleIndex));
	
	randomaccess_info->ra_PRACHMaskIndex= SV(RA_info.ra_PRACHMaskIndex);
    49c5:	0f b6 43 05          	movzbl 0x5(%ebx),%eax
    49c9:	88 47 01             	mov    %al,0x1(%edi)
	SendRaPreamble(randomaccess_info);//
    49cc:	89 f8                	mov    %edi,%eax
    49ce:	e8 2d e0 ff ff       	call   2a00 <SendRaPreamble>
	StartWaitingForRaResponse();//start waiting for the RAR
    49d3:	e8 b8 dc ff ff       	call   2690 <StartWaitingForRaResponse>
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
				FSM_CASE_TRANSIT(1, ST_NCRA, doStartNonContentionBasedRandomAccessProcedure(), "IDLE -> NCRA")
    49d8:	e9 e3 fb ff ff       	jmp    45c0 <rlc_mac_main+0x530>
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
			FSM_COND_TEST_OUT("IDLE")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_CRA, doStartContentionBasedRandomAccessProcedure(), "IDLE -> CRA")
    49dd:	c7 05 30 00 00 00 de 	movl   $0x1de,0x30
    49e4:	01 00 00 
    49e7:	e8 84 e6 ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
    49ec:	e9 b7 fa ff ff       	jmp    44a8 <rlc_mac_main+0x418>
    49f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
    49f8:	85 db                	test   %ebx,%ebx
    49fa:	0f 84 1b fa ff ff    	je     441b <rlc_mac_main+0x38b>
			FSM_TRANSIT_SWITCH
    4a00:	83 ff 05             	cmp    $0x5,%edi
    4a03:	0f 87 12 fa ff ff    	ja     441b <rlc_mac_main+0x38b>
    4a09:	ff 24 bd 98 03 00 00 	jmp    *0x398(,%edi,4)
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4a10:	c7 05 30 00 00 00 03 	movl   $0x203,0x30
    4a17:	02 00 00 
*/
static void cra_success()
{
	RNTI_indication *data_ptr;
	FIN(cra_success());
	SV_PTR_GET(rlc_mac_sv);
    4a1a:	e8 fc ff ff ff       	call   4a1b <rlc_mac_main+0x98b>
    4a1f:	89 c7                	mov    %eax,%edi
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4a21:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4a25:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4a29:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	cleanharqBuff();//HARQmsg3
	SV(ra_allocation_res)=0;
    4a30:	c7 80 f8 01 00 00 00 	movl   $0x0,0x1f8(%eax)
    4a37:	00 00 00 
	if(SV(msg3_buf_ptr) != NULL)
    4a3a:	8b 80 e4 01 00 00    	mov    0x1e4(%eax),%eax
    4a40:	85 c0                	test   %eax,%eax
    4a42:	74 0f                	je     4a53 <rlc_mac_main+0x9c3>
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    4a44:	e8 fc ff ff ff       	call   4a45 <rlc_mac_main+0x9b5>
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    4a49:	c7 87 e4 01 00 00 00 	movl   $0x0,0x1e4(%edi)
    4a50:	00 00 00 
	}
	if(SV(C_RNTI) == 0)
    4a53:	66 83 3f 00          	cmpw   $0x0,(%edi)
    4a57:	0f 85 92 08 00 00    	jne    52ef <rlc_mac_main+0x125f>
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    4a5d:	0f b7 47 02          	movzwl 0x2(%edi),%eax
	SV(T_C_RNTI) = 0;//T_C_RNTI
    4a61:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
    4a67:	66 85 c0             	test   %ax,%ax
	{
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
    4a6a:	66 89 07             	mov    %ax,(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
    4a6d:	0f 85 82 08 00 00    	jne    52f5 <rlc_mac_main+0x1265>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
		fsm_mem_free(data_ptr);//LHL20141018
	}
	if(SV(CRTimer.flag)==true) //CR
    4a73:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    4a7a:	74 1b                	je     4a97 <rlc_mac_main+0xa07>
	{
		SV(CRTimer.timer_sign)= NULL;
    4a7c:	c7 87 70 01 00 00 00 	movl   $0x0,0x170(%edi)
    4a83:	00 00 00 
		SV(CRTimer.flag)= false;
    4a86:	c6 87 74 01 00 00 00 	movb   $0x0,0x174(%edi)
		SV(CRTimer.time_value)=0;
    4a8d:	c7 87 6c 01 00 00 00 	movl   $0x0,0x16c(%edi)
    4a94:	00 00 00 
	}
	SV(sendmsg3)=0;//MSG30
    4a97:	c7 87 ec 01 00 00 00 	movl   $0x0,0x1ec(%edi)
    4a9e:	00 00 00 
	SV(ratype.ra_type)=0;//0 
    4aa1:	c7 87 e8 01 00 00 00 	movl   $0x0,0x1e8(%edi)
    4aa8:	00 00 00 
	SV(pdcch_rnti)=0;
    4aab:	c7 87 f0 01 00 00 00 	movl   $0x0,0x1f0(%edi)
    4ab2:	00 00 00 
	fsm_printf("[UEMAC][cra_success]:contention based random access success \n");//testing code 
    4ab5:	c7 04 24 00 17 00 00 	movl   $0x1700,(%esp)
    4abc:	e8 fc ff ff ff       	call   4abd <rlc_mac_main+0xa2d>
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
    4ac1:	e9 42 f8 ff ff       	jmp    4308 <rlc_mac_main+0x278>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4ac6:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4acd:	03 00 00 
*******************************
*/
static void ContentionFailed() 
{
	FIN(ContentionFailed());
	SV_PTR_GET(rlc_mac_sv);
    4ad0:	e8 fc ff ff ff       	call   4ad1 <rlc_mac_main+0xa41>
    4ad5:	89 c3                	mov    %eax,%ebx
	int result=1;//TEST
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4ad7:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	u32 backoff_time=0,backoff_param=0;//ms backoff_index
    4add:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
    4ae4:	c7 04 24 a4 16 00 00 	movl   $0x16a4,(%esp)
    4aeb:	e8 fc ff ff ff       	call   4aec <rlc_mac_main+0xa5c>
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
    4af0:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
    4af7:	0f 85 fb 09 00 00    	jne    54f8 <rlc_mac_main+0x1468>
		SV(CRTimer.timer_sign)= NULL;
		SV(CRTimer.flag)= false;
	}
	//if(SV(TATimer.time_value)== SV(TA_fromRAR) && SV(TATimer.flag)==true) //TATimer MAC5.1.6
	
	if(SV(TATimer.flag)==true) 
    4afd:	80 bb 68 01 00 00 00 	cmpb   $0x0,0x168(%ebx)
    4b04:	74 2a                	je     4b30 <rlc_mac_main+0xaa0>
	{//HQ 20140428 
		//fsm_printf("[UEMAC][con_failed]CR fail,stop TAtimer\n");//testing code 
		if(SV(TATimer.timer_sign) != NULL)
    4b06:	8b 83 64 01 00 00    	mov    0x164(%ebx),%eax
    4b0c:	85 c0                	test   %eax,%eax
    4b0e:	74 05                	je     4b15 <rlc_mac_main+0xa85>
		{
			result=fsm_schedule_cancel (SV(TATimer.timer_sign));
    4b10:	e8 fc ff ff ff       	call   4b11 <rlc_mac_main+0xa81>
		}
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
    4b15:	c7 83 64 01 00 00 00 	movl   $0x0,0x164(%ebx)
    4b1c:	00 00 00 
		SV(TATimer.flag)=false;
    4b1f:	c6 83 68 01 00 00 00 	movb   $0x0,0x168(%ebx)
		SV(TATimer.time_value)=0;
    4b26:	c7 83 60 01 00 00 00 	movl   $0x0,0x160(%ebx)
    4b2d:	00 00 00 
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b30:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b33:	83 c7 01             	add    $0x1,%edi
		//fsm_printf("[UEMAC][contentionfailed]result:%d\n",result);//TEST
		SV(TATimer.timer_sign)= NULL;
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
    4b36:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b3c:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b3f:	39 f8                	cmp    %edi,%eax
		SV(TATimer.flag)=false;
		SV(TATimer.time_value)=0;
	}
	SV(T_C_RNTI)=0;
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
    4b41:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
    4b44:	0f 84 46 0f 00 00    	je     5a90 <rlc_mac_main+0x1a00>
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    4b4a:	8b 43 1c             	mov    0x1c(%ebx),%eax
	}
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
    4b4d:	c7 83 f8 01 00 00 01 	movl   $0x1,0x1f8(%ebx)
    4b54:	00 00 00 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4b57:	8b 55 e8             	mov    -0x18(%ebp),%edx
	
	//modified by HQ
	else
	{
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
    4b5a:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4b61:	00 
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4b62:	85 db                	test   %ebx,%ebx
    4b64:	0f 85 a4 0a 00 00    	jne    560e <rlc_mac_main+0x157e>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			//fsm_printf("[UEMAC][con_failed]:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4b6a:	6b c2 64             	imul   $0x64,%edx,%eax
    4b6d:	ba 02 00 00 00       	mov    $0x2,%edx
    4b72:	e8 fc ff ff ff       	call   4b73 <rlc_mac_main+0xae3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
    4b77:	e9 e4 f6 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    4b7c:	c7 05 30 00 00 00 c2 	movl   $0x3c2,0x30
    4b83:	03 00 00 
*/
static void waitsending_msg3() //defined by HQ 20140430 
{
	RNTI_indication *data_ptr;
	FIN(waitsending_msg3());   
	SV_PTR_GET(rlc_mac_sv);
    4b86:	e8 fc ff ff ff       	call   4b87 <rlc_mac_main+0xaf7>
    4b8b:	89 c7                	mov    %eax,%edi
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4b8d:	e8 fc ff ff ff       	call   4b8e <rlc_mac_main+0xafe>
	if(SV(TATimer.flag)==false)
    4b92:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
static void RARTA_handleB()  
{
	FIN(RARTA_handleB());
	/**delete for test**/
	
	SV_PTR_GET(rlc_mac_sv);
    4b99:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==false)
    4b9b:	0f 84 98 08 00 00    	je     5439 <rlc_mac_main+0x13a9>
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		//T_C_RNTI
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
    4ba1:	66 83 7f 02 00       	cmpw   $0x0,0x2(%edi)
    4ba6:	0f 85 50 08 00 00    	jne    53fc <rlc_mac_main+0x136c>
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
		fsm_mem_free(data_ptr);
	}
	//HQ HQ modified end 20140717
	fsm_printf("[UEMAC][waitsend_msg3]MAC SV(PREAMBLE_TRANSMISSION_COUNTER):%d\n",SV(PREAMBLE_TRANSMISSION_COUNTER));
    4bac:	8b 47 14             	mov    0x14(%edi),%eax
    4baf:	c7 04 24 98 15 00 00 	movl   $0x1598,(%esp)
    4bb6:	89 44 24 04          	mov    %eax,0x4(%esp)
    4bba:	e8 fc ff ff ff       	call   4bbb <rlc_mac_main+0xb2b>
	{  	
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte,    	
  		fsm_printf("MAC SEND MSG3:this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
	}*/ //modified by lhl 20140725

	if(SV(ra_allocation_res)==0)
    4bbf:	8b 87 f8 01 00 00    	mov    0x1f8(%edi),%eax
    4bc5:	85 c0                	test   %eax,%eax
    4bc7:	0f 85 9f 08 00 00    	jne    546c <rlc_mac_main+0x13dc>
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
    4bcd:	80 bf 5a 01 00 00 00 	cmpb   $0x0,0x15a(%edi)
    4bd4:	0f 84 f1 07 00 00    	je     53cb <rlc_mac_main+0x133b>
    4bda:	80 7f 28 00          	cmpb   $0x0,0x28(%edi)
    4bde:	0f 84 e7 07 00 00    	je     53cb <rlc_mac_main+0x133b>
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4be4:	8b 47 2c             	mov    0x2c(%edi),%eax
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    4be7:	66 83 3f 00          	cmpw   $0x0,(%edi)
	if(SV(ra_allocation_res)==0)
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
    4beb:	c7 87 f8 01 00 00 01 	movl   $0x1,0x1f8(%edi)
    4bf2:	00 00 00 
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4bf5:	89 c2                	mov    %eax,%edx
	{
		if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)//
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
    4bf7:	0f 84 eb 0b 00 00    	je     57e8 <rlc_mac_main+0x1758>
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4bfd:	c1 ea 03             	shr    $0x3,%edx
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    4c00:	83 e8 18             	sub    $0x18,%eax
		{
			//DoresourceAllocation()byteUL_resource_info.m_tbsizebit
			SV(ra_allocation_res)=1;
			if(SV(C_RNTI)!= 0 ) //C-RNTI )
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    4c03:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
    4c09:	e8 fc ff ff ff       	call   4c0a <rlc_mac_main+0xb7a>
    4c0e:	e8 fc ff ff ff       	call   4c0f <rlc_mac_main+0xb7f>
				SV(UL_resource_info.resource_flag)=false;
    4c13:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    4c17:	e9 8c f8 ff ff       	jmp    44a8 <rlc_mac_main+0x418>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4c1c:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4c23:	03 00 00 
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c26:	e8 fc ff ff ff       	call   4c27 <rlc_mac_main+0xb97>
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4c2b:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
*******************************
*/
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4c31:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    4c33:	b8 e0 14 00 00       	mov    $0x14e0,%eax
static void C_RaResponseFailed() 
{
	FIN(C_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
	u16 backoff_time=0,backoff_param=0;//ms backoff_index
    4c38:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	print_tran_info("[UEMAC][c_ra_failed]MAC:CRA -> IDLE RAR receive fail");//testing code
    4c3e:	e8 fc ff ff ff       	call   4c3f <rlc_mac_main+0xbaf>
	if(SV(WaitforRAresponseTimer.flag)==true)//
    4c43:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4c4a:	74 11                	je     4c5d <rlc_mac_main+0xbcd>
	{
		SV(WaitforRAresponseTimer.flag)= false;
    4c4c:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4c53:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4c5a:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c5d:	8b 43 14             	mov    0x14(%ebx),%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c60:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c63:	83 c0 01             	add    $0x1,%eax
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c66:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//
	{
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4c68:	89 43 14             	mov    %eax,0x14(%ebx)
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4c6b:	0f 84 0e 0e 00 00    	je     5a7f <rlc_mac_main+0x19ef>
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
		//fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
	//modified by HQ
	else
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
    4c71:	8b 43 1c             	mov    0x1c(%ebx),%eax
    4c74:	0f b7 9c 00 c0 03 00 	movzwl 0x3c0(%eax,%eax,1),%ebx
    4c7b:	00 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
    4c7c:	66 85 db             	test   %bx,%bx
    4c7f:	0f 85 c1 09 00 00    	jne    5646 <rlc_mac_main+0x15b6>
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
		}
		fsm_schedule_self(backoff_time*100,Start_ContentionBase_RandomAcc);//trigger a new random access procedure as backoff_param indicates
    4c85:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    4c89:	ba 02 00 00 00       	mov    $0x2,%edx
    4c8e:	6b c0 64             	imul   $0x64,%eax,%eax
    4c91:	e8 fc ff ff ff       	call   4c92 <rlc_mac_main+0xc02>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
    4c96:	e9 c5 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("CRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
    4c9b:	c7 05 30 00 00 00 ab 	movl   $0x3ab,0x30
    4ca2:	03 00 00 
    4ca5:	e8 b6 e6 ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    4caa:	e9 b1 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
				FSM_CASE_TRANSIT(3, ST_IDLE, ContentionFailed(), "CRA -> IDLE")
				FSM_CASE_TRANSIT(4, ST_CON , cra_success() , "CRA -> CON")
				//FSM_CASE_TRANSIT(4, ST_IDLE, print_tran_info("reset CRA -> IDLE"), "CRA -> IDLE")
				FSM_CASE_TRANSIT(5, ST_IDLE, ue_mac_reset(), "CRA -> IDLE")
    4caf:	c7 05 30 00 00 00 b6 	movl   $0x3b6,0x30
    4cb6:	03 00 00 
    4cb9:	e8 12 ec ff ff       	call   38d0 <ue_mac_reset>
    4cbe:	e9 9d f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4cc3:	90                   	nop
    4cc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
    4cc8:	85 db                	test   %ebx,%ebx
    4cca:	0f 84 93 f8 ff ff    	je     4563 <rlc_mac_main+0x4d3>
			FSM_TRANSIT_SWITCH
    4cd0:	83 ff 01             	cmp    $0x1,%edi
    4cd3:	0f 84 b9 01 00 00    	je     4e92 <rlc_mac_main+0xe02>
    4cd9:	0f 8e 4b 09 00 00    	jle    562a <rlc_mac_main+0x159a>
    4cdf:	83 ff 02             	cmp    $0x2,%edi
    4ce2:	0f 84 3d 01 00 00    	je     4e25 <rlc_mac_main+0xd95>
    4ce8:	83 ff 03             	cmp    $0x3,%edi
    4ceb:	90                   	nop
    4cec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    4cf0:	0f 85 6d f8 ff ff    	jne    4563 <rlc_mac_main+0x4d3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
				// FSM_CASE_TRANSIT(2, ST_IDLE,print_tran_info("reset NCRA -> IDLE"), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(3, ST_IDLE,ue_mac_reset(), "NCRA -> IDLE")
    4cf6:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4cfd:	03 00 00 
    4d00:	e8 cb eb ff ff       	call   38d0 <ue_mac_reset>
    4d05:	e9 56 f5 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    4d0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4d10:	e8 fc ff ff ff       	call   4d11 <rlc_mac_main+0xc81>
    4d15:	83 f8 04             	cmp    $0x4,%eax
    4d18:	0f 85 00 f8 ff ff    	jne    451e <rlc_mac_main+0x48e>
    4d1e:	83 c3 01             	add    $0x1,%ebx
    4d21:	bf 02 00 00 00       	mov    $0x2,%edi
    4d26:	e9 03 f8 ff ff       	jmp    452e <rlc_mac_main+0x49e>
    4d2b:	90                   	nop
    4d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
				FSM_TEST_COND(CONTENTION_SUCCESS)
    4d30:	e8 fc ff ff ff       	call   4d31 <rlc_mac_main+0xca1>
    4d35:	83 f8 06             	cmp    $0x6,%eax
    4d38:	0f 85 98 f6 ff ff    	jne    43d6 <rlc_mac_main+0x346>
    4d3e:	83 c3 01             	add    $0x1,%ebx
    4d41:	bf 04 00 00 00       	mov    $0x4,%edi
    4d46:	e9 9b f6 ff ff       	jmp    43e6 <rlc_mac_main+0x356>
    4d4b:	90                   	nop
    4d4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
    4d50:	e8 fc ff ff ff       	call   4d51 <rlc_mac_main+0xcc1>
    4d55:	83 f8 05             	cmp    $0x5,%eax
    4d58:	0f 85 48 f6 ff ff    	jne    43a6 <rlc_mac_main+0x316>
    4d5e:	83 c3 01             	add    $0x1,%ebx
    4d61:	bf 03 00 00 00       	mov    $0x3,%edi
    4d66:	e9 5b f6 ff ff       	jmp    43c6 <rlc_mac_main+0x336>
    4d6b:	90                   	nop
    4d6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    4d70:	e8 fc ff ff ff       	call   4d71 <rlc_mac_main+0xce1>
    4d75:	83 f8 04             	cmp    $0x4,%eax
    4d78:	0f 85 08 f6 ff ff    	jne    4386 <rlc_mac_main+0x2f6>
    4d7e:	83 c3 01             	add    $0x1,%ebx
    4d81:	bf 02 00 00 00       	mov    $0x2,%edi
    4d86:	e9 0b f6 ff ff       	jmp    4396 <rlc_mac_main+0x306>
    4d8b:	90                   	nop
    4d8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4d90:	e8 fc ff ff ff       	call   4d91 <rlc_mac_main+0xd01>
    4d95:	83 f8 03             	cmp    $0x3,%eax
    4d98:	0f 85 b8 f5 ff ff    	jne    4356 <rlc_mac_main+0x2c6>
    4d9e:	83 c3 01             	add    $0x1,%ebx
    4da1:	bf 01 00 00 00       	mov    $0x1,%edi
    4da6:	e9 cb f5 ff ff       	jmp    4376 <rlc_mac_main+0x2e6>
    4dab:	90                   	nop
    4dac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4db0:	e8 fc ff ff ff       	call   4db1 <rlc_mac_main+0xd21>
    4db5:	83 f8 03             	cmp    $0x3,%eax
    4db8:	0f 85 2f f7 ff ff    	jne    44ed <rlc_mac_main+0x45d>
    4dbe:	83 c3 01             	add    $0x1,%ebx
    4dc1:	bf 01 00 00 00       	mov    $0x1,%edi
    4dc6:	e9 43 f7 ff ff       	jmp    450e <rlc_mac_main+0x47e>
    4dcb:	90                   	nop
    4dcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4dd0:	e8 fc ff ff ff       	call   4dd1 <rlc_mac_main+0xd41>
    4dd5:	83 f8 18             	cmp    $0x18,%eax
    4dd8:	0f 85 88 f5 ff ff    	jne    4366 <rlc_mac_main+0x2d6>
    4dde:	66 90                	xchg   %ax,%ax
    4de0:	eb bc                	jmp    4d9e <rlc_mac_main+0xd0e>
    4de2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4de8:	90                   	nop
    4de9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    4df0:	e8 fc ff ff ff       	call   4df1 <rlc_mac_main+0xd61>
    4df5:	83 f8 18             	cmp    $0x18,%eax
    4df8:	0f 85 00 f7 ff ff    	jne    44fe <rlc_mac_main+0x46e>
    4dfe:	66 90                	xchg   %ax,%ax
    4e00:	eb bc                	jmp    4dbe <rlc_mac_main+0xd2e>
    4e02:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    4e08:	90                   	nop
    4e09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
    4e10:	e8 fc ff ff ff       	call   4e11 <rlc_mac_main+0xd81>
    4e15:	83 f8 0f             	cmp    $0xf,%eax
    4e18:	0f 85 98 f5 ff ff    	jne    43b6 <rlc_mac_main+0x326>
    4e1e:	66 90                	xchg   %ax,%ax
    4e20:	e9 39 ff ff ff       	jmp    4d5e <rlc_mac_main+0xcce>
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4e25:	c7 05 30 00 00 00 f7 	movl   $0x1f7,0x30
    4e2c:	01 00 00 
*******************************
*/
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
    4e2f:	e8 fc ff ff ff       	call   4e30 <rlc_mac_main+0xda0>
    4e34:	89 c7                	mov    %eax,%edi
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4e36:	e8 fc ff ff ff       	call   4e37 <rlc_mac_main+0xda7>
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4e3b:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
*******************************
*/
static void RARTA_handleA()  
{
	FIN(RARTA_handleA());	
	SV_PTR_GET(rlc_mac_sv);	
    4e42:	89 c3                	mov    %eax,%ebx
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
    4e44:	74 0f                	je     4e55 <rlc_mac_main+0xdc5>
    4e46:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    4e4c:	85 c0                	test   %eax,%eax
    4e4e:	74 05                	je     4e55 <rlc_mac_main+0xdc5>
		fsm_schedule_cancel(SV(TATimer.timer_sign));
    4e50:	e8 fc ff ff ff       	call   4e51 <rlc_mac_main+0xdc1>
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4e55:	8b 43 24             	mov    0x24(%ebx),%eax
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4e58:	ba 0b 00 00 00       	mov    $0xb,%edx
	SV_PTR_GET(rlc_mac_sv);	
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
    4e5d:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4e63:	6b c0 64             	imul   $0x64,%eax,%eax
    4e66:	e8 fc ff ff ff       	call   4e67 <rlc_mac_main+0xdd7>
	SV(TATimer.flag)=true;
    4e6b:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==true && SV(TATimer.timer_sign) != NULL)// 
		fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021
	
	SV(TATimer.time_value)=SV(TA_Periodic_time);//LHL 20141021
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    4e72:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
static void ncra_success()
{
	FIN(ncra_success);
	SV_PTR_GET(rlc_mac_sv);
	RARTA_handleA();//RAR  TA 
	SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    4e78:	c6 47 04 00          	movb   $0x0,0x4(%edi)
	SV(RA_info.ra_PRACHMaskIndex) = 0; 
    4e7c:	c6 47 05 00          	movb   $0x0,0x5(%edi)
	SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    4e80:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
	SV(T_C_RNTI) = 0;//T_C_RNTI 
    4e87:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
				FSM_CASE_TRANSIT(2, ST_CON, ncra_success(), "NCRA -> CON")
    4e8d:	e9 76 f4 ff ff       	jmp    4308 <rlc_mac_main+0x278>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4e92:	c7 05 30 00 00 00 e7 	movl   $0x3e7,0x30
    4e99:	03 00 00 
*******************************
*/
static void NC_RaResponseFailed() 
{
	FIN(NC_RaResponseFailed());
	SV_PTR_GET(rlc_mac_sv);
    4e9c:	e8 fc ff ff ff       	call   4e9d <rlc_mac_main+0xe0d>
    4ea1:	89 c3                	mov    %eax,%ebx
	u32 PreambleTransMax=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.preambleTransMax);
    4ea3:	8b b8 c8 00 00 00    	mov    0xc8(%eax),%edi
	print_tran_info("[UEMAC][nc_ra_failed]NCRA -> IDLE");//testing code
    4ea9:	b8 6c 18 00 00       	mov    $0x186c,%eax
    4eae:	e8 fc ff ff ff       	call   4eaf <rlc_mac_main+0xe1f>
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
    4eb3:	80 bb 98 01 00 00 00 	cmpb   $0x0,0x198(%ebx)
    4eba:	74 11                	je     4ecd <rlc_mac_main+0xe3d>
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
    4ebc:	c6 83 98 01 00 00 00 	movb   $0x0,0x198(%ebx)
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
    4ec3:	c7 83 94 01 00 00 00 	movl   $0x0,0x194(%ebx)
    4eca:	00 00 00 
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4ecd:	8b 43 14             	mov    0x14(%ebx),%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4ed0:	83 c7 01             	add    $0x1,%edi
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4ed3:	83 c0 01             	add    $0x1,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4ed6:	39 f8                	cmp    %edi,%eax
	if(SV(WaitforRAresponseTimer.flag)==true)//   false
	{ 
		SV(WaitforRAresponseTimer.flag)= false;
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
    4ed8:	89 43 14             	mov    %eax,0x14(%ebx)
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
    4edb:	0f 84 d1 04 00 00    	je     53b2 <rlc_mac_main+0x1322>
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
	}
	else
	{
		fsm_printf("[UEMAC][nc_ra_failed]MAC:start a new NCRA \n");//testing code 
    4ee1:	c7 04 24 d0 18 00 00 	movl   $0x18d0,(%esp)
    4ee8:	e8 fc ff ff ff       	call   4ee9 <rlc_mac_main+0xe59>
		fsm_schedule_self(100,Start_NonContentionBase_RandomAcc);//trigger a new random access procedure
    4eed:	ba 01 00 00 00       	mov    $0x1,%edx
    4ef2:	b8 64 00 00 00       	mov    $0x64,%eax
    4ef7:	e8 fc ff ff ff       	call   4ef8 <rlc_mac_main+0xe68>
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE,NC_RaResponseFailed(), "NCRA -> IDLE")
    4efc:	e9 5f f3 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4f01:	e8 fc ff ff ff       	call   4f02 <rlc_mac_main+0xe72>
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
    4f06:	83 f8 0b             	cmp    $0xb,%eax
    4f09:	0f 94 c3             	sete   %bl
    4f0c:	0f b6 fb             	movzbl %bl,%edi
    4f0f:	0f b6 db             	movzbl %bl,%ebx
    4f12:	83 ef 01             	sub    $0x1,%edi
    4f15:	e9 2d f4 ff ff       	jmp    4347 <rlc_mac_main+0x2b7>
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4f1a:	e8 fc ff ff ff       	call   4f1b <rlc_mac_main+0xe8b>
    4f1f:	83 f8 54             	cmp    $0x54,%eax
    4f22:	0f 85 36 f7 ff ff    	jne    465e <rlc_mac_main+0x5ce>
    4f28:	83 c3 01             	add    $0x1,%ebx
    4f2b:	bf 05 00 00 00       	mov    $0x5,%edi
    4f30:	e9 29 f7 ff ff       	jmp    465e <rlc_mac_main+0x5ce>
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)
    4f35:	e8 fc ff ff ff       	call   4f36 <rlc_mac_main+0xea6>
    4f3a:	83 f8 02             	cmp    $0x2,%eax
    4f3d:	0f 85 eb f6 ff ff    	jne    462e <rlc_mac_main+0x59e>
    4f43:	e8 fc ff ff ff       	call   4f44 <rlc_mac_main+0xeb4>
    4f48:	83 f8 03             	cmp    $0x3,%eax
    4f4b:	0f 85 dd f6 ff ff    	jne    462e <rlc_mac_main+0x59e>
    4f51:	83 c3 01             	add    $0x1,%ebx
    4f54:	bf 02 00 00 00       	mov    $0x2,%edi
    4f59:	e9 d0 f6 ff ff       	jmp    462e <rlc_mac_main+0x59e>
    4f5e:	66 90                	xchg   %ax,%ax
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
    4f60:	e8 fc ff ff ff       	call   4f61 <rlc_mac_main+0xed1>
    4f65:	83 f8 07             	cmp    $0x7,%eax
    4f68:	0f 85 af f6 ff ff    	jne    461d <rlc_mac_main+0x58d>
    4f6e:	83 c3 01             	add    $0x1,%ebx
    4f71:	bf 01 00 00 00       	mov    $0x1,%edi
    4f76:	e9 a2 f6 ff ff       	jmp    461d <rlc_mac_main+0x58d>
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    4f7b:	e8 fc ff ff ff       	call   4f7c <rlc_mac_main+0xeec>
				FSM_CASE_DEFAULT(ST_NCRA,ncra_default_handler() , "NCRA -> NCRA")	//transit to NCRA state	by default.
			}
		}
		FSM_STATE_UNFORCED(ST_CON,"CON", , )		//20140320
		{
			FSM_COND_TEST_IN("CON")
    4f80:	83 f8 0b             	cmp    $0xb,%eax
    4f83:	0f 94 c3             	sete   %bl
    4f86:	0f b6 fb             	movzbl %bl,%edi
    4f89:	0f b6 db             	movzbl %bl,%ebx
    4f8c:	83 ef 01             	sub    $0x1,%edi
    4f8f:	e9 7b f6 ff ff       	jmp    460f <rlc_mac_main+0x57f>
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
				FSM_TEST_COND(RLC_RESUME)
    4f94:	e8 fc ff ff ff       	call   4f95 <rlc_mac_main+0xf05>
    4f99:	83 f8 54             	cmp    $0x54,%eax
    4f9c:	0f 85 a4 f1 ff ff    	jne    4146 <rlc_mac_main+0xb6>
    4fa2:	83 c3 01             	add    $0x1,%ebx
    4fa5:	bf 05 00 00 00       	mov    $0x5,%edi
    4faa:	e9 97 f1 ff ff       	jmp    4146 <rlc_mac_main+0xb6>
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    4faf:	e8 fc ff ff ff       	call   4fb0 <rlc_mac_main+0xf20>
    4fb4:	83 f8 52             	cmp    $0x52,%eax
    4fb7:	0f 85 79 f1 ff ff    	jne    4136 <rlc_mac_main+0xa6>
    4fbd:	83 c3 01             	add    $0x1,%ebx
    4fc0:	bf 04 00 00 00       	mov    $0x4,%edi
    4fc5:	e9 6c f1 ff ff       	jmp    4136 <rlc_mac_main+0xa6>
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4fca:	e8 fc ff ff ff       	call   4fcb <rlc_mac_main+0xf3b>
    4fcf:	83 f8 02             	cmp    $0x2,%eax
    4fd2:	0f 85 66 f5 ff ff    	jne    453e <rlc_mac_main+0x4ae>
    4fd8:	e8 fc ff ff ff       	call   4fd9 <rlc_mac_main+0xf49>
    4fdd:	83 f8 03             	cmp    $0x3,%eax
    4fe0:	0f 85 58 f5 ff ff    	jne    453e <rlc_mac_main+0x4ae>
    4fe6:	83 c3 01             	add    $0x1,%ebx
    4fe9:	bf 03 00 00 00       	mov    $0x3,%edi
    4fee:	e9 4b f5 ff ff       	jmp    453e <rlc_mac_main+0x4ae>
    4ff3:	90                   	nop
    4ff4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
				FSM_TEST_COND(CONTENTION_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
    4ff8:	e8 fc ff ff ff       	call   4ff9 <rlc_mac_main+0xf69>
    4ffd:	83 f8 02             	cmp    $0x2,%eax
    5000:	0f 85 f0 f3 ff ff    	jne    43f6 <rlc_mac_main+0x366>
    5006:	e8 fc ff ff ff       	call   5007 <rlc_mac_main+0xf77>
    500b:	83 f8 03             	cmp    $0x3,%eax
    500e:	66 90                	xchg   %ax,%ax
    5010:	0f 85 e0 f3 ff ff    	jne    43f6 <rlc_mac_main+0x366>
    5016:	83 c3 01             	add    $0x1,%ebx
    5019:	bf 05 00 00 00       	mov    $0x5,%edi
    501e:	e9 d3 f3 ff ff       	jmp    43f6 <rlc_mac_main+0x366>
    5023:	90                   	nop
    5024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
				
				FSM_TEST_COND(RLC_SUSPEND)
    5028:	e8 fc ff ff ff       	call   5029 <rlc_mac_main+0xf99>
    502d:	83 f8 53             	cmp    $0x53,%eax
    5030:	0f 85 f0 f0 ff ff    	jne    4126 <rlc_mac_main+0x96>
    5036:	83 c3 01             	add    $0x1,%ebx
    5039:	bf 03 00 00 00       	mov    $0x3,%edi
    503e:	e9 e3 f0 ff ff       	jmp    4126 <rlc_mac_main+0x96>
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
				FSM_TEST_COND(MAC_RESET)
    5043:	e8 fc ff ff ff       	call   5044 <rlc_mac_main+0xfb4>
    5048:	83 f8 02             	cmp    $0x2,%eax
    504b:	0f 85 c5 f0 ff ff    	jne    4116 <rlc_mac_main+0x86>
    5051:	e8 fc ff ff ff       	call   5052 <rlc_mac_main+0xfc2>
    5056:	83 f8 03             	cmp    $0x3,%eax
    5059:	0f 85 b7 f0 ff ff    	jne    4116 <rlc_mac_main+0x86>
    505f:	83 c3 01             	add    $0x1,%ebx
    5062:	bf 02 00 00 00       	mov    $0x2,%edi
    5067:	e9 aa f0 ff ff       	jmp    4116 <rlc_mac_main+0x86>
    506c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
				FSM_TEST_COND(START_NC_RANDOM_ACCESS)
    5070:	e8 fc ff ff ff       	call   5071 <rlc_mac_main+0xfe1>
    5075:	83 f8 01             	cmp    $0x1,%eax
    5078:	0f 85 88 f0 ff ff    	jne    4106 <rlc_mac_main+0x76>
    507e:	83 c3 01             	add    $0x1,%ebx
    5081:	bf 01 00 00 00       	mov    $0x1,%edi
    5086:	e9 7b f0 ff ff       	jmp    4106 <rlc_mac_main+0x76>
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
				FSM_TEST_COND(START_C_RANDOM_ACCESS)
    508b:	e8 fc ff ff ff       	call   508c <rlc_mac_main+0xffc>
		{
			FSM_TRANSIT_FORCE(ST_IDLE, , "default", "", "MAC_INIT -> IDLE");
		}
		FSM_STATE_UNFORCED(ST_IDLE, "IDLE", , )
		{
			FSM_COND_TEST_IN("IDLE")				
    5090:	83 f8 02             	cmp    $0x2,%eax
    5093:	0f 94 c3             	sete   %bl
    5096:	0f b6 fb             	movzbl %bl,%edi
    5099:	0f b6 db             	movzbl %bl,%ebx
    509c:	83 ef 01             	sub    $0x1,%edi
    509f:	e9 53 f0 ff ff       	jmp    40f7 <rlc_mac_main+0x67>
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
    50a4:	e8 fc ff ff ff       	call   50a5 <rlc_mac_main+0x1015>
				FSM_CASE_DEFAULT(ST_SENDMSG3,sendmsg3_default_handler() , "SENDMSG3->SENDMSG3")	//transit to SENDMSG3 state	by default.
			}
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
    50a9:	83 f8 0b             	cmp    $0xb,%eax
    50ac:	0f 94 c3             	sete   %bl
    50af:	0f b6 fb             	movzbl %bl,%edi
    50b2:	0f b6 db             	movzbl %bl,%ebx
    50b5:	83 ef 01             	sub    $0x1,%edi
    50b8:	e9 22 f4 ff ff       	jmp    44df <rlc_mac_main+0x44f>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
				FSM_TEST_COND(RLC_DEACT)
    50bd:	e8 fc ff ff ff       	call   50be <rlc_mac_main+0x102e>
    50c2:	83 f8 52             	cmp    $0x52,%eax
    50c5:	0f 85 83 f5 ff ff    	jne    464e <rlc_mac_main+0x5be>
    50cb:	83 c3 01             	add    $0x1,%ebx
    50ce:	bf 04 00 00 00       	mov    $0x4,%edi
    50d3:	e9 76 f5 ff ff       	jmp    464e <rlc_mac_main+0x5be>
			FSM_COND_TEST_IN("CON")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(SR_FAIL)
				FSM_TEST_COND(MAC_RESET)

				FSM_TEST_COND(RLC_SUSPEND)
    50d8:	e8 fc ff ff ff       	call   50d9 <rlc_mac_main+0x1049>
    50dd:	83 f8 53             	cmp    $0x53,%eax
    50e0:	0f 85 58 f5 ff ff    	jne    463e <rlc_mac_main+0x5ae>
    50e6:	83 c3 01             	add    $0x1,%ebx
    50e9:	bf 03 00 00 00       	mov    $0x3,%edi
    50ee:	e9 4b f5 ff ff       	jmp    463e <rlc_mac_main+0x5ae>
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
				FSM_TEST_COND(CONTENTION_SUCCESS)
    50f3:	e8 fc ff ff ff       	call   50f4 <rlc_mac_main+0x1064>
    50f8:	83 f8 02             	cmp    $0x2,%eax
    50fb:	0f 85 e5 f2 ff ff    	jne    43e6 <rlc_mac_main+0x356>
    5101:	e8 fc ff ff ff       	call   5102 <rlc_mac_main+0x1072>
    5106:	83 f8 43             	cmp    $0x43,%eax
    5109:	0f 85 d7 f2 ff ff    	jne    43e6 <rlc_mac_main+0x356>
    510f:	90                   	nop
    5110:	e9 29 fc ff ff       	jmp    4d3e <rlc_mac_main+0xcae>
    5115:	8d 76 00             	lea    0x0(%esi),%esi
    5118:	90                   	nop
    5119:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    5120:	e8 fc ff ff ff       	call   5121 <rlc_mac_main+0x1091>
    5125:	83 f8 02             	cmp    $0x2,%eax
    5128:	0f 85 68 f2 ff ff    	jne    4396 <rlc_mac_main+0x306>
    512e:	66 90                	xchg   %ax,%ax
    5130:	e8 fc ff ff ff       	call   5131 <rlc_mac_main+0x10a1>
    5135:	83 f8 41             	cmp    $0x41,%eax
    5138:	0f 85 58 f2 ff ff    	jne    4396 <rlc_mac_main+0x306>
    513e:	66 90                	xchg   %ax,%ax
    5140:	e9 39 fc ff ff       	jmp    4d7e <rlc_mac_main+0xcee>
    5145:	8d 76 00             	lea    0x0(%esi),%esi
    5148:	90                   	nop
    5149:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
    5150:	e8 fc ff ff ff       	call   5151 <rlc_mac_main+0x10c1>
    5155:	83 f8 02             	cmp    $0x2,%eax
    5158:	0f 85 d0 f3 ff ff    	jne    452e <rlc_mac_main+0x49e>
    515e:	66 90                	xchg   %ax,%ax
    5160:	e8 fc ff ff ff       	call   5161 <rlc_mac_main+0x10d1>
    5165:	83 f8 41             	cmp    $0x41,%eax
    5168:	0f 85 c0 f3 ff ff    	jne    452e <rlc_mac_main+0x49e>
    516e:	66 90                	xchg   %ax,%ax
    5170:	e9 a9 fb ff ff       	jmp    4d1e <rlc_mac_main+0xc8e>
    5175:	8d 76 00             	lea    0x0(%esi),%esi
			
			FOUT;
			break;

		case TM_MODE:
			if(insptru == NULL)
    5178:	8b 7d ec             	mov    -0x14(%ebp),%edi
    517b:	85 ff                	test   %edi,%edi
    517d:	8d 76 00             	lea    0x0(%esi),%esi
    5180:	0f 84 a0 11 00 00    	je     6326 <rlc_mac_main+0x2296>
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			
			tmElm = (TmBuffer *) fsm_mem_alloc(sizeof(TmBuffer));
    5186:	b8 0c 00 00 00       	mov    $0xc,%eax
    518b:	e8 fc ff ff ff       	call   518c <rlc_mac_main+0x10fc>
			tmElm->pkt = skb;
    5190:	89 30                	mov    %esi,(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5192:	8b 57 10             	mov    0x10(%edi),%edx
			list_add_tail(&tmElm->list, &tmTxIns->tmSduBuffer.list);
    5195:	8d 48 04             	lea    0x4(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5198:	89 4f 10             	mov    %ecx,0x10(%edi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    519b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    519e:	8d 57 0c             	lea    0xc(%edi),%edx
    51a1:	89 50 04             	mov    %edx,0x4(%eax)
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    51a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    51a7:	89 50 08             	mov    %edx,0x8(%eax)
	prev->next = new;
    51aa:	89 0a                	mov    %ecx,(%edx)
			tmTxIns->tmSduBufferNum++;
    51ac:	83 47 18 01          	addl   $0x1,0x18(%edi)
			tmTxIns->tmSduBufferSize += skb->len;
    51b0:	8b 46 50             	mov    0x50(%esi),%eax
    51b3:	01 47 14             	add    %eax,0x14(%edi)
    51b6:	e9 6b f5 ff ff       	jmp    4726 <rlc_mac_main+0x696>
		findInsByRbid(iciMsg->rbId, &insptru, &insptrd ,&SV(ins_mode));
		fsm_printf("[RLC_MAC][skb_from_cra_to_con]ins_mode is: %d\n", SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    51bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    51be:	85 c0                	test   %eax,%eax
    51c0:	0f 84 95 11 00 00    	je     635b <rlc_mac_main+0x22cb>
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
				break;
			}
			amIns = (AM_Instance *)insptru;
    51c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    51c9:	0f b7 50 2c          	movzwl 0x2c(%eax),%edx
    51cd:	66 83 fa 0b          	cmp    $0xb,%dx
    51d1:	0f 84 6b 11 00 00    	je     6342 <rlc_mac_main+0x22b2>
    51d7:	66 83 fa 09          	cmp    $0x9,%dx
    51db:	0f 84 61 11 00 00    	je     6342 <rlc_mac_main+0x22b2>
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
				break;
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
    51e1:	b8 14 00 00 00       	mov    $0x14,%eax
    51e6:	e8 fc ff ff ff       	call   51e7 <rlc_mac_main+0x1157>
			
			amElm->pkt = skb;
    51eb:	89 30                	mov    %esi,(%eax)
			amElm->pktstatus = FULL_SDU;
			amElm->pos = 0;
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    51ed:	8d 48 0c             	lea    0xc(%eax),%ecx
			}
			
			amElm = (AmSduBuffer *)fsm_mem_alloc(sizeof(AmSduBuffer));
			
			amElm->pkt = skb;
			amElm->pktstatus = FULL_SDU;
    51f0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			amElm->pos = 0;
    51f7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
			list_add_tail(&amElm->list, &amIns->amSduBuffer.list);
    51fe:	8b 55 e8             	mov    -0x18(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    5201:	8b 7a 48             	mov    0x48(%edx),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5204:	89 4a 48             	mov    %ecx,0x48(%edx)
    5207:	83 c2 44             	add    $0x44,%edx
    520a:	89 50 0c             	mov    %edx,0xc(%eax)
	new->next = next;
	new->prev = prev;
    520d:	89 78 10             	mov    %edi,0x10(%eax)
	prev->next = new;
    5210:	89 0f                	mov    %ecx,(%edi)
			fsm_printf("[RLC][skb_from_cra_to_con]AM_MODE list_add done!\n");
    5212:	c7 04 24 b4 1a 00 00 	movl   $0x1ab4,(%esp)
    5219:	e8 fc ff ff ff       	call   521a <rlc_mac_main+0x118a>
			fsm_printf("[RLC][skb_from_cra_to_con] amIns addr is %p, amIns->rbid=%d, amIns->lcid=%d\n",&amIns,amIns->rbId,amIns->lcId);
    521e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5221:	0f b6 50 03          	movzbl 0x3(%eax),%edx
    5225:	89 54 24 0c          	mov    %edx,0xc(%esp)
    5229:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    522d:	c7 04 24 e8 1a 00 00 	movl   $0x1ae8,(%esp)
    5234:	89 44 24 08          	mov    %eax,0x8(%esp)
    5238:	8d 45 e8             	lea    -0x18(%ebp),%eax
    523b:	89 44 24 04          	mov    %eax,0x4(%esp)
    523f:	e8 fc ff ff ff       	call   5240 <rlc_mac_main+0x11b0>
			amIns->amSduBufferSize += skb->len;
    5244:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5247:	8b 56 50             	mov    0x50(%esi),%edx
    524a:	01 50 4c             	add    %edx,0x4c(%eax)
			amIns->amSduBufferNum++;
    524d:	83 40 50 01          	addl   $0x1,0x50(%eax)
    5251:	e9 d0 f4 ff ff       	jmp    4726 <rlc_mac_main+0x696>
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(CONTENTION_FAIL )
    5256:	e8 fc ff ff ff       	call   5257 <rlc_mac_main+0x11c7>
    525b:	83 f8 02             	cmp    $0x2,%eax
    525e:	0f 85 62 f1 ff ff    	jne    43c6 <rlc_mac_main+0x336>
    5264:	e8 fc ff ff ff       	call   5265 <rlc_mac_main+0x11d5>
    5269:	83 f8 42             	cmp    $0x42,%eax
    526c:	0f 85 54 f1 ff ff    	jne    43c6 <rlc_mac_main+0x336>
    5272:	e9 e7 fa ff ff       	jmp    4d5e <rlc_mac_main+0xcce>
    5277:	90                   	nop
    5278:	90                   	nop
    5279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		FSM_STATE_UNFORCED(ST_CRA,"CRA", ,)
		{
			FSM_COND_TEST_IN("CRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    5280:	e8 fc ff ff ff       	call   5281 <rlc_mac_main+0x11f1>
    5285:	83 f8 02             	cmp    $0x2,%eax
    5288:	0f 85 e8 f0 ff ff    	jne    4376 <rlc_mac_main+0x2e6>
    528e:	66 90                	xchg   %ax,%ax
    5290:	e8 fc ff ff ff       	call   5291 <rlc_mac_main+0x1201>
    5295:	83 f8 40             	cmp    $0x40,%eax
    5298:	0f 85 d8 f0 ff ff    	jne    4376 <rlc_mac_main+0x2e6>
    529e:	66 90                	xchg   %ax,%ax
    52a0:	e9 f9 fa ff ff       	jmp    4d9e <rlc_mac_main+0xd0e>
    52a5:	8d 76 00             	lea    0x0(%esi),%esi
    52a8:	90                   	nop
    52a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}*/		
		FSM_STATE_UNFORCED(ST_NCRA,"NCRA", , )
		{
			FSM_COND_TEST_IN("NCRA")
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
    52b0:	e8 fc ff ff ff       	call   52b1 <rlc_mac_main+0x1221>
    52b5:	83 f8 02             	cmp    $0x2,%eax
    52b8:	0f 85 50 f2 ff ff    	jne    450e <rlc_mac_main+0x47e>
    52be:	66 90                	xchg   %ax,%ax
    52c0:	e8 fc ff ff ff       	call   52c1 <rlc_mac_main+0x1231>
    52c5:	83 f8 40             	cmp    $0x40,%eax
    52c8:	0f 85 40 f2 ff ff    	jne    450e <rlc_mac_main+0x47e>
    52ce:	66 90                	xchg   %ax,%ax
    52d0:	e9 e9 fa ff ff       	jmp    4dbe <rlc_mac_main+0xd2e>
    52d5:	8d 76 00             	lea    0x0(%esi),%esi
	// 	(*Q)->rear = NULL;
	p = (*Q)->front->next;
	pktptr = p->pkt;
	if((*Q)->rear == p)
	{
		(*Q)->rear = (*Q)->front;	//there are one pkt in the queue, after dequeue, queue empty.
    52d8:	89 4a 04             	mov    %ecx,0x4(%edx)
		(*Q)->front->next = NULL;
    52db:	8b 93 14 02 00 00    	mov    0x214(%ebx),%edx
    52e1:	8b 12                	mov    (%edx),%edx
    52e3:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    52ea:	e9 e1 f4 ff ff       	jmp    47d0 <rlc_mac_main+0x740>
		fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
		SV(msg3_buf_ptr) = NULL; //msg3sk_buf
	}
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
    52ef:	66 c7 47 02 00 00    	movw   $0x0,0x2(%edi)
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    52f5:	b8 08 00 00 00       	mov    $0x8,%eax
    52fa:	e8 fc ff ff ff       	call   52fb <rlc_mac_main+0x126b>
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    52ff:	ba 24 00 00 00       	mov    $0x24,%edx
	if(SV(C_RNTI) == 0)
		SV(C_RNTI) = SV(T_C_RNTI); //T_C_RNTI 
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    5304:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 1; 
    5306:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		data_ptr->rnti_value = SV(C_RNTI);
    530c:	0f b7 07             	movzwl (%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    530f:	89 d9                	mov    %ebx,%ecx
	SV(T_C_RNTI) = 0;//T_C_RNTI
	if(SV(C_RNTI) > 0) //C_rnti 
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 1; 
		data_ptr->rnti_value = SV(C_RNTI);
    5311:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));//C_RNTI
    5314:	b8 03 00 00 00       	mov    $0x3,%eax
    5319:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    5320:	e8 fc ff ff ff       	call   5321 <rlc_mac_main+0x1291>
		fsm_mem_free(data_ptr);//LHL20141018
    5325:	89 d8                	mov    %ebx,%eax
    5327:	e8 fc ff ff ff       	call   5328 <rlc_mac_main+0x1298>
    532c:	e9 42 f7 ff ff       	jmp    4a73 <rlc_mac_main+0x9e3>
		{
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    5331:	e8 fc ff ff ff       	call   5332 <rlc_mac_main+0x12a2>
    5336:	e9 2d f4 ff ff       	jmp    4768 <rlc_mac_main+0x6d8>
			{
				fsm_printf("[RLC][skb_from_cra_to_con][UM] um instance is suspended(rbid is %d)\n",umTxIns->rbid);
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
    533b:	b8 18 00 00 00       	mov    $0x18,%eax
    5340:	89 55 dc             	mov    %edx,-0x24(%ebp)
    5343:	e8 fc ff ff ff       	call   5344 <rlc_mac_main+0x12b4>
			umElm->pkt = skb;
    5348:	89 30                	mov    %esi,(%eax)
			umElm->pktstatus = FULL_SDU;
			umElm->pos = 0;
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    534a:	8d 48 10             	lea    0x10(%eax),%ecx
				break;
			}

			umElm = (UmBuffer *)fsm_mem_alloc(sizeof(UmBuffer));
			umElm->pkt = skb;
			umElm->pktstatus = FULL_SDU;
    534d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
			umElm->pos = 0;
    5354:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    535b:	8b 55 dc             	mov    -0x24(%ebp),%edx
			list_add_tail(&umElm->list, &umTxIns->umSduBuffer.list);
    535e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    5361:	8b 4a 1c             	mov    0x1c(%edx),%ecx
    5364:	89 4d d8             	mov    %ecx,-0x28(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    5367:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    536a:	89 4a 1c             	mov    %ecx,0x1c(%edx)
    536d:	8d 4a 18             	lea    0x18(%edx),%ecx
    5370:	89 48 10             	mov    %ecx,0x10(%eax)
	new->next = next;
	new->prev = prev;
    5373:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    5376:	89 48 14             	mov    %ecx,0x14(%eax)
	prev->next = new;
    5379:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    537c:	89 01                	mov    %eax,(%ecx)
			fsm_printf("[RLC][skb_from_cra_to_con]UM_MODE list_add done!\n");
    537e:	89 55 dc             	mov    %edx,-0x24(%ebp)
    5381:	c7 04 24 c4 1b 00 00 	movl   $0x1bc4,(%esp)
    5388:	e8 fc ff ff ff       	call   5389 <rlc_mac_main+0x12f9>
			
			umTxIns->umSduBufferNum++;
    538d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5390:	8b 42 24             	mov    0x24(%edx),%eax
    5393:	83 c0 01             	add    $0x1,%eax
    5396:	89 42 24             	mov    %eax,0x24(%edx)
			if(SV(max_queue_num) < (umTxIns->umSduBufferNum)){
    5399:	3b 87 a8 5a 00 00    	cmp    0x5aa8(%edi),%eax
    539f:	76 06                	jbe    53a7 <rlc_mac_main+0x1317>
				SV(max_queue_num) = umTxIns->umSduBufferNum;
    53a1:	89 87 a8 5a 00 00    	mov    %eax,0x5aa8(%edi)
			}
			umTxIns->umSduBufferSize += skb->len;
    53a7:	8b 46 50             	mov    0x50(%esi),%eax
    53aa:	01 42 20             	add    %eax,0x20(%edx)
    53ad:	e9 74 f3 ff ff       	jmp    4726 <rlc_mac_main+0x696>
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
	{
		//modified by HQ    	
		fsm_printf("[UEMAC][nc_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    53b2:	c7 04 24 90 18 00 00 	movl   $0x1890,(%esp)
    53b9:	e8 fc ff ff ff       	call   53ba <rlc_mac_main+0x132a>
		// fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed
		//modified by HQ
		SV(RA_info.ra_PreambleIndex)=0;//HQ 20140506 //
    53be:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
		SV(RA_info.ra_PRACHMaskIndex)=0; //HQ 20140506 // 
    53c2:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
    53c6:	e9 95 ee ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
				SV(UL_resource_info.resource_flag)=false;
			}
			//fsm_printf("[UEMAC][waitsend_msg3]DoResourceAllocation \n");
		}
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
    53cb:	b8 d8 15 00 00       	mov    $0x15d8,%eax
    53d0:	e8 fc ff ff ff       	call   53d1 <rlc_mac_main+0x1341>
    53d5:	e9 ce f0 ff ff       	jmp    44a8 <rlc_mac_main+0x418>
	FIN(do_bsr_and_resource_alloc());
	SV_PTR_GET(rlc_mac_sv);

	if( PMRLC_BUFFERREP_REQ() == NULL )
	{
		fsm_printf("[RLC_MAC][do_bsr_and_resource_alloc]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    53da:	c7 04 24 c0 1c 00 00 	movl   $0x1cc0,(%esp)
    53e1:	e8 fc ff ff ff       	call   53e2 <rlc_mac_main+0x1352>
    53e6:	e9 b3 f3 ff ff       	jmp    479e <rlc_mac_main+0x70e>
{
	FSM_PKT *pktptr;
	QueueNode *p;
	if(QueueEmpty(Q))
	{
		fsm_printf("[DeQueue]Queue is empty!\n");
    53eb:	c7 04 24 44 04 00 00 	movl   $0x444,(%esp)
    53f2:	e8 fc ff ff ff       	call   53f3 <rlc_mac_main+0x1363>
    53f7:	e9 a2 f3 ff ff       	jmp    479e <rlc_mac_main+0x70e>
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    53fc:	b8 08 00 00 00       	mov    $0x8,%eax
    5401:	e8 fc ff ff ff       	call   5402 <rlc_mac_main+0x1372>
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    5406:	ba 24 00 00 00       	mov    $0x24,%edx
	}*/
	//HQ HQ modified end 20140709 
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
    540b:	89 c3                	mov    %eax,%ebx
		data_ptr->rnti_type = 2; 
    540d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
		data_ptr->rnti_value = SV(T_C_RNTI);
    5413:	0f b7 47 02          	movzwl 0x2(%edi),%eax
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    5417:	89 d9                	mov    %ebx,%ecx
	//LHL modified 20140717 msg3T_C_RNTI
	if( SV(T_C_RNTI)!=0)//
	{
		data_ptr = (RNTI_indication *)fsm_mem_alloc(sizeof(RNTI_indication));
		data_ptr->rnti_type = 2; 
		data_ptr->rnti_value = SV(T_C_RNTI);
    5419:	89 43 04             	mov    %eax,0x4(%ebx)
		fsm_do_ioctrl(STRM_TO_SRIO, IOCCMD_MACtoPHY_RNTI_Indicate, (void *)data_ptr, sizeof(RNTI_indication));
    541c:	b8 03 00 00 00       	mov    $0x3,%eax
    5421:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
    5428:	e8 fc ff ff ff       	call   5429 <rlc_mac_main+0x1399>
		fsm_mem_free(data_ptr);
    542d:	89 d8                	mov    %ebx,%eax
    542f:	e8 fc ff ff ff       	call   5430 <rlc_mac_main+0x13a0>
    5434:	e9 73 f7 ff ff       	jmp    4bac <rlc_mac_main+0xb1c>
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5439:	0f b7 40 20          	movzwl 0x20(%eax),%eax
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    543d:	ba 0b 00 00 00       	mov    $0xb,%edx
	
	SV_PTR_GET(rlc_mac_sv);
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
    5442:	c1 e0 04             	shl    $0x4,%eax
    5445:	66 89 43 22          	mov    %ax,0x22(%ebx)
		SV(TATimer.time_value)=SV(TA_Periodic_time);
    5449:	8b 43 24             	mov    0x24(%ebx),%eax
    544c:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5452:	6b c0 64             	imul   $0x64,%eax,%eax
    5455:	e8 fc ff ff ff       	call   5456 <rlc_mac_main+0x13c6>
		SV(TATimer.flag)=true;
    545a:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
	if(SV(TATimer.flag)==false)
	{ //TA,TA
		//SV(TATimer.time_value)=SV(TA_fromRAR);//LHL modified 20141021,TARRC
		SV(TA_value)=SV(TA_fromRAR)*16;//
		SV(TATimer.time_value)=SV(TA_Periodic_time);
		SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    5461:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
    5467:	e9 35 f7 ff ff       	jmp    4ba1 <rlc_mac_main+0xb11>
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    546c:	8b 47 2c             	mov    0x2c(%edi),%eax
		else 
			print_tran_info("[UEMAC][waitsend_msg3]no UL_Resource,error!");//testing code
	}
	else
	{
		SV(ra_allocation_res)=2;
    546f:	c7 87 f8 01 00 00 02 	movl   $0x2,0x1f8(%edi)
    5476:	00 00 00 
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
    5479:	c1 e8 03             	shr    $0x3,%eax
    547c:	89 87 f4 01 00 00    	mov    %eax,0x1f4(%edi)
	//: msg3CCCHSDU---->
	int	skb_len=0,len=0; 
	FSM_PKT *skb;
	FIN(send_msg3());

	SV_PTR_GET(rlc_mac_sv);
    5482:	e8 fc ff ff ff       	call   5483 <rlc_mac_main+0x13f3>
    5487:	89 c3                	mov    %eax,%ebx
	//MAC PDU 
	//fsm_printf("[UEMAC][send_msg3]send msg3,SENDMSG3->CRA \n");
	//skb = fsm_pkt_get();
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
    5489:	8b 80 f8 01 00 00    	mov    0x1f8(%eax),%eax
    548f:	c7 04 24 04 16 00 00 	movl   $0x1604,(%esp)
    5496:	89 44 24 04          	mov    %eax,0x4(%esp)
    549a:	e8 fc ff ff ff       	call   549b <rlc_mac_main+0x140b>
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    549f:	8b 93 f8 01 00 00    	mov    0x1f8(%ebx),%edx
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    54a5:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
	// fsm_pkt_destroy(fsm_pkt_get());
	// fsm_printf("in fact it was destroyed ");
	fsm_printf("[UE MAC]RA ALLOCATION RESULT:%d\n",SV(ra_allocation_res));
	
	//if won't excute. SV(ra_allocation_res)==2, time:20150901.
	if(SV(ra_allocation_res)==1)//modified by lhl 20140725
    54ab:	83 fa 01             	cmp    $0x1,%edx
    54ae:	0f 84 21 06 00 00    	je     5ad5 <rlc_mac_main+0x1a45>
	
		if(SV(Tbsize_Complex)!=0)
			SV(Tbsize_Complex)=0;//TBSIZE
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
    54b4:	85 c0                	test   %eax,%eax
    54b6:	74 09                	je     54c1 <rlc_mac_main+0x1431>
    54b8:	83 fa 02             	cmp    $0x2,%edx
    54bb:	0f 84 16 09 00 00    	je     5dd7 <rlc_mac_main+0x1d47>
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    54c1:	8b 83 d0 00 00 00    	mov    0xd0(%ebx),%eax
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    54c7:	ba 0f 00 00 00       	mov    $0xf,%edx
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
	}
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
    54cc:	89 83 6c 01 00 00    	mov    %eax,0x16c(%ebx)
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    54d2:	6b c0 64             	imul   $0x64,%eax,%eax
    54d5:	e8 fc ff ff ff       	call   54d6 <rlc_mac_main+0x1446>
	SV(CRTimer.flag)=true;
    54da:	c6 83 74 01 00 00 01 	movb   $0x1,0x174(%ebx)
	//testing code SRIO
	//  fsm_pkt_send(fsm_pkt_get(), STRM_TO_SRIO);
	//
	SV(CRTimer.time_value)=SV(systemconfigInfo.RACHCommonConfigInfo.raSupervisionInfo.mac_ContentionResolutionTimer); //ms
	//fsm_printf("[UEMAC][send_msg3]CRtimer value:%d\n",SV(CRTimer.time_value));
	SV(CRTimer.timer_sign)=fsm_schedule_self(SV(CRTimer.time_value)*100, CRTimer_Expire);//
    54e1:	89 83 70 01 00 00    	mov    %eax,0x170(%ebx)
	{
		SV(ra_allocation_res)=2;
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140721LHL byte, 
		//fsm_schedule_self(0, RA_Send_Msg3);//LHL 20140726 ,MSG3MAC
		retransmit_msg3(); 	//call static retransmit_msg3(void) function 20150901 
		fsm_printf("[UEMAC][waitsend_msg3]this isn't the first time to do contention based random access ,needn't to  DoResourceAllocation \n");
    54e7:	c7 04 24 28 16 00 00 	movl   $0x1628,(%esp)
    54ee:	e8 fc ff ff ff       	call   54ef <rlc_mac_main+0x145f>
			FSM_TRANSIT_SWITCH
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "CRA-> IDLE")
				FSM_CASE_TRANSIT(1, ST_IDLE, C_RaResponseFailed(), "CRA -> IDLE")
				//FSM_CASE_TRANSIT(2, ST_SENDMSG3 , waitsending_msg3(), "CRA -> SENDMSG3")
				FSM_CASE_TRANSIT(2, ST_CRA , waitsending_msg3(), "CRA -> CRA")	//cancel Sendmsg3 state.20150831
    54f3:	e9 b0 ef ff ff       	jmp    44a8 <rlc_mac_main+0x418>
	u32 backoff_time=0,backoff_param=0;//ms backoff_index

	fsm_printf("[UEMAC][con_failed]CRA -> IDLE contention fail ");//testing code 
	if(SV(CRTimer.flag)==true) //LHL 20140729 CR 
	{
		fsm_printf("[UEMAC][con_failed]because CRtimer expire \n");
    54f8:	c7 04 24 d4 16 00 00 	movl   $0x16d4,(%esp)
    54ff:	e8 fc ff ff ff       	call   5500 <rlc_mac_main+0x1470>
		SV(CRTimer.timer_sign)= NULL;
    5504:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    550b:	00 00 00 
		SV(CRTimer.flag)= false;
    550e:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
    5515:	e9 e3 f5 ff ff       	jmp    4afd <rlc_mac_main+0xa6d>
	FIN(idle_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	print_tran_info("[UEMAC][idle_default]MAC idle_default_handler");//testing code

	//fsm_printf("[RLC_MAC][idle_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());
	if(MAC_CLOSE)
    551a:	e8 fc ff ff ff       	call   551b <rlc_mac_main+0x148b>
    551f:	83 f8 01             	cmp    $0x1,%eax
    5522:	0f 85 6c ec ff ff    	jne    4194 <rlc_mac_main+0x104>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
    5528:	b8 78 11 00 00       	mov    $0x1178,%eax
    552d:	e8 fc ff ff ff       	call   552e <rlc_mac_main+0x149e>
		ue_mac_sv_close();
    5532:	e8 79 d4 ff ff       	call   29b0 <ue_mac_sv_close>
    5537:	e9 24 ed ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	void *tmpdata_ptr;
	u32 tmpdata;
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
    553c:	66 83 38 00          	cmpw   $0x0,(%eax)
    5540:	0f 84 f3 ee ff ff    	je     4439 <rlc_mac_main+0x3a9>
		fsm_schedule_self(0, Contention_Success );//TEST  	
    5546:	ba 06 00 00 00       	mov    $0x6,%edx
    554b:	31 c0                	xor    %eax,%eax
    554d:	e8 fc ff ff ff       	call   554e <rlc_mac_main+0x14be>
    5552:	e9 e2 ee ff ff       	jmp    4439 <rlc_mac_main+0x3a9>

	//fsm_printf("[con_default_handler]CraQueue:%p\n", SV(CraQueue));
	//int pktnum = GetCountOfQueue(SV(CraQueue));
	//fsm_printf("[RLC_MAC][con_default_handler][begin]fsm event type: %d, code: %x\n", fsm_ev_type(),fsm_ev_code());

	if(MAC_CLOSE)
    5557:	e8 fc ff ff ff       	call   5558 <rlc_mac_main+0x14c8>
    555c:	83 f8 01             	cmp    $0x1,%eax
    555f:	90                   	nop
    5560:	0f 85 3c f1 ff ff    	jne    46a2 <rlc_mac_main+0x612>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
    5566:	b8 48 19 00 00       	mov    $0x1948,%eax
    556b:	e8 fc ff ff ff       	call   556c <rlc_mac_main+0x14dc>
		ue_mac_sv_close();
    5570:	e8 3b d4 ff ff       	call   29b0 <ue_mac_sv_close>
    5575:	e9 8e ed ff ff       	jmp    4308 <rlc_mac_main+0x278>
		rlc_close();
		FOUT;
	}
	else if(MAC_PK_FROM_LOWER)
	{//ICIRLC
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
    557a:	b8 a0 11 00 00       	mov    $0x11a0,%eax
    557f:	e8 fc ff ff ff       	call   5580 <rlc_mac_main+0x14f0>
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
    5584:	80 bf 74 01 00 00 00 	cmpb   $0x0,0x174(%edi)
    558b:	0f 84 db 03 00 00    	je     596c <rlc_mac_main+0x18dc>
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
    5591:	c7 04 24 ec 11 00 00 	movl   $0x11ec,(%esp)
    5598:	e8 fc ff ff ff       	call   5599 <rlc_mac_main+0x1509>
		{
			//IDLE
			fsm_pkt_destroy(fsm_pkt_get());
		}
		else*/
		decomplexUeDataPdu(fsm_pkt_get()); //SRIO? 20140701
    559d:	e8 fc ff ff ff       	call   559e <rlc_mac_main+0x150e>
    55a2:	e8 fc ff ff ff       	call   55a3 <rlc_mac_main+0x1513>
		SV(countRecvFromLower)++;
    55a7:	83 87 94 5a 00 00 01 	addl   $0x1,0x5a94(%edi)
    55ae:	e9 ad ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	{
		print_tran_info("[UEMAC][idle_default]MAC FSM is closed ");//testing code
		ue_mac_sv_close();
		FOUT;
	}
	else if(RLC_CLOSE)                              //
    55b3:	e8 fc ff ff ff       	call   55b4 <rlc_mac_main+0x1524>
    55b8:	83 f8 01             	cmp    $0x1,%eax
    55bb:	0f 85 e1 eb ff ff    	jne    41a2 <rlc_mac_main+0x112>
	{
		rlc_close();
    55c1:	e8 aa c7 ff ff       	call   1d70 <rlc_close>
    55c6:	e9 95 ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		//printk("[RLC_MAC]countRecvFromLower: %d\n", SV(countRecvFromLower));
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    55cb:	83 83 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%ebx)
		rlc_pkt_receive_from_upper();
    55d2:	e8 c9 e7 ff ff       	call   3da0 <rlc_pkt_receive_from_upper>

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
    55d7:	e8 fc ff ff ff       	call   55d8 <rlc_mac_main+0x1548>
    55dc:	85 c0                	test   %eax,%eax
    55de:	0f 84 74 08 00 00    	je     5e58 <rlc_mac_main+0x1dc8>
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    55e4:	e8 fc ff ff ff       	call   55e5 <rlc_mac_main+0x1555>
			tmpdata = *((u32*)tmpdata_ptr);//	
    55e9:	8b 10                	mov    (%eax),%edx
		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    55eb:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    55ed:	85 d2                	test   %edx,%edx
    55ef:	0f 8e 13 ed ff ff    	jle    4308 <rlc_mac_main+0x278>
			{
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    55f5:	8d 40 04             	lea    0x4(%eax),%eax
    55f8:	e8 fc ff ff ff       	call   55f9 <rlc_mac_main+0x1569>
    55fd:	e8 fc ff ff ff       	call   55fe <rlc_mac_main+0x156e>
				fsm_data_destroy((void *)tmpdata_ptr);//
    5602:	89 d8                	mov    %ebx,%eax
    5604:	e8 fc ff ff ff       	call   5605 <rlc_mac_main+0x1575>
    5609:	e9 fa ec ff ff       	jmp    4308 <rlc_mac_main+0x278>
		SV(ra_allocation_res)=1;
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable  
		//fsm_printf("[UEMAC][con_failed]:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    560e:	ba 04 00 00 00       	mov    $0x4,%edx
    5613:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5616:	e8 fc ff ff ff       	call   5617 <rlc_mac_main+0x1587>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    561b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    561e:	31 d2                	xor    %edx,%edx
    5620:	f7 f3                	div    %ebx
    5622:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5625:	e9 40 f5 ff ff       	jmp    4b6a <rlc_mac_main+0xada>
				FSM_TEST_COND(TimeAlignmentTimerExpire)
				FSM_TEST_COND(RANDOM_ACCESS_FAIL)
				FSM_TEST_COND(RARREV_SUCCESS)
				FSM_TEST_COND(MAC_RESET)
			FSM_COND_TEST_OUT("NCRA")
			FSM_TRANSIT_SWITCH
    562a:	85 ff                	test   %edi,%edi
    562c:	0f 85 31 ef ff ff    	jne    4563 <rlc_mac_main+0x4d3>
			{
				FSM_CASE_TRANSIT(0, ST_IDLE,handle_timeAlignmentTimerExpire(), "NCRA-> IDLE")
    5632:	c7 05 30 00 00 00 db 	movl   $0x3db,0x30
    5639:	03 00 00 
    563c:	e8 1f dd ff ff       	call   3360 <handle_timeAlignmentTimerExpire>
    5641:	e9 1a ec ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	{ 
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
    5646:	8d 45 f0             	lea    -0x10(%ebp),%eax
    5649:	ba 02 00 00 00       	mov    $0x2,%edx
    564e:	e8 fc ff ff ff       	call   564f <rlc_mac_main+0x15bf>
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    5653:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    5657:	31 d2                	xor    %edx,%edx
    5659:	66 f7 f3             	div    %bx
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    565c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    5663:	00 
    5664:	c7 04 24 58 15 00 00 	movl   $0x1558,(%esp)
		backoff_param=BackoffTable[SV(backoff_index)]; //get the backoff parameter from BackoffTable 
		//fsm_printf("[UEMAC][c_ra_failed]MAC:back off parame : %d \n",backoff_param);//testing code
		if(backoff_param != 0)//
		{
			fsm_get_random_bytes(&backoff_time , sizeof(backoff_time)); //get a random number with 16bit.
			backoff_time=backoff_time % backoff_param;    //0-backoff_param
    566b:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
			fsm_printf("[UEMAC][c_ra_failed]MAC:with %d byte,get a random backoff:%d \n",sizeof(backoff_time),backoff_time);//testing code
    566f:	0f b7 d2             	movzwl %dx,%edx
    5672:	89 54 24 08          	mov    %edx,0x8(%esp)
    5676:	e8 fc ff ff ff       	call   5677 <rlc_mac_main+0x15e7>
    567b:	e9 05 f6 ff ff       	jmp    4c85 <rlc_mac_main+0xbf5>
		SV(countRecvFromLower)++;
		//FOUT;
	}
	else if(RLC_PKT_FROM_UPPER)		//
	{
		SV(countRecvFromUpper)++;
    5680:	83 87 8c 5a 00 00 01 	addl   $0x1,0x5a8c(%edi)
		rlc_pkt_receive_from_upper();
    5687:	e8 14 e7 ff ff       	call   3da0 <rlc_pkt_receive_from_upper>

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
    568c:	e8 fc ff ff ff       	call   568d <rlc_mac_main+0x15fd>
    5691:	85 c0                	test   %eax,%eax
    5693:	0f 84 6e 0a 00 00    	je     6107 <rlc_mac_main+0x2077>
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    5699:	e8 fc ff ff ff       	call   569a <rlc_mac_main+0x160a>
			tmpdata = *((u32*)tmpdata_ptr);//	
    569e:	8b 10                	mov    (%eax),%edx

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
		else{
			tmpdata_ptr = (char *)PMRLC_BUFFERREP_REQ();
    56a0:	89 c3                	mov    %eax,%ebx
			tmpdata = *((u32*)tmpdata_ptr);//	
			if( tmpdata > 0 )
    56a2:	85 d2                	test   %edx,%edx
    56a4:	0f 8e b6 eb ff ff    	jle    4260 <rlc_mac_main+0x1d0>
			{
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    56aa:	89 55 dc             	mov    %edx,-0x24(%ebp)
    56ad:	c7 04 24 88 12 00 00 	movl   $0x1288,(%esp)
    56b4:	e8 fc ff ff ff       	call   56b5 <rlc_mac_main+0x1625>
				//fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    56b9:	8b 43 07             	mov    0x7(%ebx),%eax
    56bc:	c7 04 24 bc 12 00 00 	movl   $0x12bc,(%esp)
    56c3:	89 44 24 04          	mov    %eax,0x4(%esp)
    56c7:	e8 fc ff ff ff       	call   56c8 <rlc_mac_main+0x1638>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    56cc:	8b 55 dc             	mov    -0x24(%ebp),%edx
    56cf:	8d 43 04             	lea    0x4(%ebx),%eax
    56d2:	e8 fc ff ff ff       	call   56d3 <rlc_mac_main+0x1643>
    56d7:	e8 fc ff ff ff       	call   56d8 <rlc_mac_main+0x1648>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    56dc:	89 d8                	mov    %ebx,%eax
    56de:	e8 fc ff ff ff       	call   56df <rlc_mac_main+0x164f>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    56e3:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    56ea:	74 05                	je     56f1 <rlc_mac_main+0x1661>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    56ec:	e8 fc ff ff ff       	call   56ed <rlc_mac_main+0x165d>
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    56f1:	ba 02 00 00 00       	mov    $0x2,%edx
    56f6:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    56fb:	e8 fc ff ff ff       	call   56fc <rlc_mac_main+0x166c>
				SV(ratype.ra_type)=2;
    5700:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5707:	00 00 00 
    570a:	e9 51 eb ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	}
	/*if(MAC_PK_FROM_UPPER)
	{
		fsm_printf("[UEMAC][nra_default]receive packet from RLC,error! \n");
	}*/
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    570f:	e8 fc ff ff ff       	call   5710 <rlc_mac_main+0x1680>
    5714:	83 f8 09             	cmp    $0x9,%eax
    5717:	0f 85 84 ee ff ff    	jne    45a1 <rlc_mac_main+0x511>
    571d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		FlushBj();
    5720:	e8 fc ff ff ff       	call   5721 <rlc_mac_main+0x1691>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    5725:	ba 09 00 00 00       	mov    $0x9,%edx
    572a:	b8 64 00 00 00       	mov    $0x64,%eax
    572f:	e8 fc ff ff ff       	call   5730 <rlc_mac_main+0x16a0>
    5734:	e9 68 ee ff ff       	jmp    45a1 <rlc_mac_main+0x511>
		ue_mac_sv_close();
	}
	if(MAC_PK_FROM_LOWER)
	{
		//decomplexUeDataPdu(fsm_pkt_get());
		decomplexUeRARPdu(fsm_pkt_get());	//modify by lxr 20160122
    5739:	e8 fc ff ff ff       	call   573a <rlc_mac_main+0x16aa>
    573e:	66 90                	xchg   %ax,%ax
    5740:	e8 fc ff ff ff       	call   5741 <rlc_mac_main+0x16b1>
    5745:	e9 49 ee ff ff       	jmp    4593 <rlc_mac_main+0x503>
    574a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
*/
static void ncra_default_handler()
{
	FIN(ncra_default_handler());
	print_tran_info("[UEMAC][nra_default]ncra default ");//testing code
	if(MAC_CLOSE)
    5750:	e8 fc ff ff ff       	call   5751 <rlc_mac_main+0x16c1>
    5755:	83 f8 01             	cmp    $0x1,%eax
    5758:	0f 85 27 ee ff ff    	jne    4585 <rlc_mac_main+0x4f5>
	{
		print_tran_info("[UEMAC][nra_default]MAC FSM is closed "); //testing code
    575e:	b8 20 19 00 00       	mov    $0x1920,%eax
    5763:	e8 fc ff ff ff       	call   5764 <rlc_mac_main+0x16d4>
		ue_mac_sv_close();
    5768:	e8 43 d2 ff ff       	call   29b0 <ue_mac_sv_close>
    576d:	e9 13 ee ff ff       	jmp    4585 <rlc_mac_main+0x4f5>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		//FOUT;
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    5772:	e8 fc ff ff ff       	call   5773 <rlc_mac_main+0x16e3>
    5777:	8d 93 1c 02 00 00    	lea    0x21c(%ebx),%edx
    577d:	e8 2e c5 ff ff       	call   1cb0 <findInsByCode>
    5782:	85 c0                	test   %eax,%eax
    5784:	89 c7                	mov    %eax,%edi
    5786:	0f 84 31 0a 00 00    	je     61bd <rlc_mac_main+0x212d>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    578c:	8b 83 1c 02 00 00    	mov    0x21c(%ebx),%eax
    5792:	83 f8 02             	cmp    $0x2,%eax
    5795:	0f 84 a0 06 00 00    	je     5e3b <rlc_mac_main+0x1dab>
    579b:	0f 87 b0 03 00 00    	ja     5b51 <rlc_mac_main+0x1ac1>
    57a1:	83 e8 01             	sub    $0x1,%eax
    57a4:	0f 84 bf 06 00 00    	je     5e69 <rlc_mac_main+0x1dd9>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    57aa:	c7 04 24 1c 13 00 00 	movl   $0x131c,(%esp)
    57b1:	e8 fc ff ff ff       	call   57b2 <rlc_mac_main+0x1722>
    57b6:	e9 4d eb ff ff       	jmp    4308 <rlc_mac_main+0x278>
		}
		else
			send_SR();*/
		//FOUT;
	}
  	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    57bb:	e8 fc ff ff ff       	call   57bc <rlc_mac_main+0x172c>
    57c0:	83 f8 09             	cmp    $0x9,%eax
    57c3:	0f 85 e5 ea ff ff    	jne    42ae <rlc_mac_main+0x21e>
	{
		FlushBj();
    57c9:	e8 fc ff ff ff       	call   57ca <rlc_mac_main+0x173a>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    57ce:	ba 09 00 00 00       	mov    $0x9,%edx
    57d3:	b8 64 00 00 00       	mov    $0x64,%eax
    57d8:	e8 fc ff ff ff       	call   57d9 <rlc_mac_main+0x1749>
    57dd:	e9 26 eb ff ff       	jmp    4308 <rlc_mac_main+0x278>
    57e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)-24));//20140531 ,20140718LHL:32MAC
				SV(UL_resource_info.resource_flag)=false;
			}
			else//RRCC_RNTI2010721 LHL
			{
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    57e8:	c1 ea 03             	shr    $0x3,%edx
    57eb:	89 97 f4 01 00 00    	mov    %edx,0x1f4(%edi)
				DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//20140531 ,20140718LHL:32MAC
    57f1:	e8 fc ff ff ff       	call   57f2 <rlc_mac_main+0x1762>
    57f6:	e8 fc ff ff ff       	call   57f7 <rlc_mac_main+0x1767>
				SV(UL_resource_info.resource_flag)=false;
    57fb:	c6 47 28 00          	movb   $0x0,0x28(%edi)
    57ff:	e9 a4 ec ff ff       	jmp    44a8 <rlc_mac_main+0x418>
	{
		//HQ make note 20140710
		//DL_SCH PDU
		//PHYRNTIUEC_RNTI()  		
		//decomplexUeDataPdu(fsm_pkt_get());
		decomplexUeRARPdu(fsm_pkt_get());	//modify by lxr in 20160122
    5804:	e8 fc ff ff ff       	call   5805 <rlc_mac_main+0x1775>
    5809:	e8 fc ff ff ff       	call   580a <rlc_mac_main+0x177a>
    580e:	66 90                	xchg   %ax,%ax
    5810:	e9 41 ec ff ff       	jmp    4456 <rlc_mac_main+0x3c6>
	FIN(cra_default_handler());
	SV_PTR_GET(rlc_mac_sv);
	//print_tran_info("[UEMAC][cra_default]cra default ");//testing code
	if(SV(sendmsg3)==1 && SV(C_RNTI)!=0)
		fsm_schedule_self(0, Contention_Success );//TEST  	
	if(MAC_CLOSE)
    5815:	e8 fc ff ff ff       	call   5816 <rlc_mac_main+0x1786>
    581a:	83 f8 01             	cmp    $0x1,%eax
    581d:	8d 76 00             	lea    0x0(%esi),%esi
    5820:	0f 85 21 ec ff ff    	jne    4447 <rlc_mac_main+0x3b7>
	{
		print_tran_info("[UEMAC][cra_default]MAC FSM is closed "); //testing code
    5826:	b8 40 17 00 00       	mov    $0x1740,%eax
    582b:	e8 fc ff ff ff       	call   582c <rlc_mac_main+0x179c>
		ue_mac_sv_close();
    5830:	e8 7b d1 ff ff       	call   29b0 <ue_mac_sv_close>
    5835:	e9 0d ec ff ff       	jmp    4447 <rlc_mac_main+0x3b7>
    583a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				SV(ratype.ra_type)=2;
			} 	
		}
		//FOUT;
	}
	else if(TimeAlignmentTimerExpire)
    5840:	e8 fc ff ff ff       	call   5841 <rlc_mac_main+0x17b1>
    5845:	83 f8 0b             	cmp    $0xb,%eax
    5848:	0f 85 80 e9 ff ff    	jne    41ce <rlc_mac_main+0x13e>
    584e:	66 90                	xchg   %ax,%ax
    5850:	e9 50 f4 ff ff       	jmp    4ca5 <rlc_mac_main+0xc15>
	}

	if(SV(DATA_WAIT_ALLOCATION)==true && SV(UL_resource_info.resource_flag)==true)
	{// 
		//DoResourceAllocation(SV(UL_resource_info.m_tbsize)); 
		fsm_printf("[RLC_MAC][con_default_handler]DoResourceAllocation!\n");
    5855:	c7 04 24 70 19 00 00 	movl   $0x1970,(%esp)
    585c:	e8 fc ff ff ff       	call   585d <rlc_mac_main+0x17cd>
		SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    5861:	8b 43 2c             	mov    0x2c(%ebx),%eax
    5864:	89 c2                	mov    %eax,%edx
    5866:	c1 ea 03             	shr    $0x3,%edx
    5869:	89 93 f4 01 00 00    	mov    %edx,0x1f4(%ebx)
		DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));//MAC
    586f:	e8 fc ff ff ff       	call   5870 <rlc_mac_main+0x17e0>
    5874:	e8 fc ff ff ff       	call   5875 <rlc_mac_main+0x17e5>
		SV(UL_resource_info.resource_flag)=false;
    5879:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    587d:	e9 41 ee ff ff       	jmp    46c3 <rlc_mac_main+0x633>
	if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
	}
	if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5882:	e8 fc ff ff ff       	call   5883 <rlc_mac_main+0x17f3>
    5887:	83 f8 09             	cmp    $0x9,%eax
    588a:	0f 85 e6 eb ff ff    	jne    4476 <rlc_mac_main+0x3e6>
	{
		FlushBj();
    5890:	e8 fc ff ff ff       	call   5891 <rlc_mac_main+0x1801>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    5895:	ba 09 00 00 00       	mov    $0x9,%edx
    589a:	b8 64 00 00 00       	mov    $0x64,%eax
    589f:	e8 fc ff ff ff       	call   58a0 <rlc_mac_main+0x1810>
    58a4:	e9 cd eb ff ff       	jmp    4476 <rlc_mac_main+0x3e6>
static void cra_pkt_recv_from_upper(void)
{
	FSM_PKT *skb;

	FIN(cra_pkt_recv_from_upper());
	SV_PTR_GET(rlc_mac_sv);
    58a9:	e8 fc ff ff ff       	call   58aa <rlc_mac_main+0x181a>
    58ae:	89 c7                	mov    %eax,%edi
	
	skb = (FSM_PKT *)fsm_pkt_get();
    58b0:	e8 fc ff ff ff       	call   58b1 <rlc_mac_main+0x1821>
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]recv from upper\n");
    58b5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    58b8:	c7 04 24 68 17 00 00 	movl   $0x1768,(%esp)
    58bf:	e8 fc ff ff ff       	call   58c0 <rlc_mac_main+0x1830>
	fsm_octets_print(skb->data, 64);
    58c4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    58c7:	ba 40 00 00 00       	mov    $0x40,%edx
    58cc:	8b 81 ac 00 00 00    	mov    0xac(%ecx),%eax
    58d2:	e8 fc ff ff ff       	call   58d3 <rlc_mac_main+0x1843>
	return Q->front == Q->rear;		//because of the head node existence, once front==rear represent the queue empty.
}

static void EnQueue(CraQueuePtr *Q, FSM_PKT *pktptr)
{
	QueueNode *p = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
    58d7:	b8 08 00 00 00       	mov    $0x8,%eax
    58dc:	e8 fc ff ff ff       	call   58dd <rlc_mac_main+0x184d>
	p->pkt = pktptr;
    58e1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
	p->next = NULL;
    58e4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
}

static void EnQueue(CraQueuePtr *Q, FSM_PKT *pktptr)
{
	QueueNode *p = (QueueNode *)fsm_mem_alloc(sizeof(QueueNode));
	p->pkt = pktptr;
    58eb:	89 08                	mov    %ecx,(%eax)
	// 	(*Q)->front = (*Q)->rear = p;		//insert node p into a empty queue
	// else{
	// 	(*Q)->rear->next = p;
	// 	(*Q)->rear = p;
	// }
	(*Q)->rear->next = p;
    58ed:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    58f3:	8b 52 04             	mov    0x4(%edx),%edx
    58f6:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->rear = p;
    58f9:	8b 97 14 02 00 00    	mov    0x214(%edi),%edx
    58ff:	89 42 04             	mov    %eax,0x4(%edx)
	(*Q)->pkt_count++;
    5902:	8b 87 14 02 00 00    	mov    0x214(%edi),%eax
    5908:	66 83 40 08 01       	addw   $0x1,0x8(%eax)
	fsm_printf("[EnQueue]EnQueue successfully!\n");
    590d:	c7 04 24 9c 17 00 00 	movl   $0x179c,(%esp)
    5914:	e8 fc ff ff ff       	call   5915 <rlc_mac_main+0x1885>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    5919:	8b 87 14 02 00 00    	mov    0x214(%edi),%eax
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    591f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    5923:	c7 04 24 bc 17 00 00 	movl   $0x17bc,(%esp)
	EnQueue(&SV(CraQueue), skb);
					
	//fsm_printf("[RLC][cra_pkt_recv_from_upper]add new element to CraQueue done!\n");
	//fsm_printf("[cra_pkt_recv_from_upper]SV(CraQueue): %p\n", SV(CraQueue));

	int pktnum = GetCountOfQueue(SV(CraQueue));
    592a:	89 44 24 04          	mov    %eax,0x4(%esp)
	fsm_printf("[RLC_MAC][cra_pkt_recv_from_upper]current num of pkt is %d\n", pktnum);
    592e:	e8 fc ff ff ff       	call   592f <rlc_mac_main+0x189f>
		fsm_printf("[UEMAC][cra_default]receive packet from RLC,error! \n");
	}*/	//noted in 20150908
	if(RLC_PKT_FROM_UPPER)	//add in 20151020 by LXR
	{
		cra_pkt_recv_from_upper();
		fsm_printf("[RLC_MAC][cra_default_handler]receive pkt from upper!\n");
    5933:	c7 04 24 f8 17 00 00 	movl   $0x17f8,(%esp)
    593a:	e8 fc ff ff ff       	call   593b <rlc_mac_main+0x18ab>
    593f:	e9 22 eb ff ff       	jmp    4466 <rlc_mac_main+0x3d6>
	{
		print_tran_info("[UEMAC][con_default]MAC FSM is closed!\n"); //testing code
		ue_mac_sv_close();
		FOUT;
	}
	if(RLC_CLOSE)                              //
    5944:	e8 fc ff ff ff       	call   5945 <rlc_mac_main+0x18b5>
    5949:	83 e8 01             	sub    $0x1,%eax
    594c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5950:	0f 85 5a ed ff ff    	jne    46b0 <rlc_mac_main+0x620>
	{
		rlc_close();
    5956:	e8 15 c4 ff ff       	call   1d70 <rlc_close>
		fsm_printf("[RLC_MAC]RLC FSM is closed!\n");
    595b:	c7 04 24 27 04 00 00 	movl   $0x427,(%esp)
    5962:	e8 fc ff ff ff       	call   5963 <rlc_mac_main+0x18d3>
    5967:	e9 9c e9 ff ff       	jmp    4308 <rlc_mac_main+0x278>
		print_tran_info("[UEMAC][idle_default][-->]MAC IDLE receive a data packet from PHYadapter\n"); //testing code
		//fsm_pkt_destroy(fsm_pkt_get());
		if(SV(CRTimer.flag)==true)
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=true\n");//testing code 
		else
			fsm_printf("[UEMAC][idle_default]SV(CRTimer.flag)=false\n");//testing code 	 
    596c:	c7 04 24 18 12 00 00 	movl   $0x1218,(%esp)
    5973:	e8 fc ff ff ff       	call   5974 <rlc_mac_main+0x18e4>
    5978:	e9 20 fc ff ff       	jmp    559d <rlc_mac_main+0x150d>
	else if(IOCTRL_ARRIVAL)
	{//IOCTL
		print_tran_info("[UEMAC][idle_default]MAC IDLE default ioctl hander,");//testing code
		u32 cmd1=fsm_ev_ioctrl_cmd();
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
    597d:	83 f8 0c             	cmp    $0xc,%eax
    5980:	0f 84 86 02 00 00    	je     5c0c <rlc_mac_main+0x1b7c>
    5986:	83 f8 0e             	cmp    $0xe,%eax
    5989:	0f 85 c0 e8 ff ff    	jne    424f <rlc_mac_main+0x1bf>
    598f:	90                   	nop
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//
			case IOCCMD_PHYtoMAC_SYSFRAME:
				tmpdata_ptr = fsm_data_get();
    5990:	e8 fc ff ff ff       	call   5991 <rlc_mac_main+0x1901>
				SV(sys_frame.frameNo)=((system_frame *)tmpdata_ptr)->frameNo;
    5995:	0f b7 10             	movzwl (%eax),%edx
    5998:	66 89 57 06          	mov    %dx,0x6(%edi)
				SV(sys_frame.subframeNo)=((system_frame *)tmpdata_ptr)->subframeNo;
    599c:	0f b7 50 02          	movzwl 0x2(%eax),%edx
    59a0:	66 89 57 08          	mov    %dx,0x8(%edi)
				fsm_data_destroy(tmpdata_ptr);
    59a4:	e8 fc ff ff ff       	call   59a5 <rlc_mac_main+0x1915>
    59a9:	e9 a7 e8 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
	else if(IOCTRL_ARRIVAL)
	{ //IOCTRL Command
		//this ioctrl will never been trigger, 20150915!!!
		if(fsm_ev_ioctrl_cmd()== IOCCMD_RLCtoMAC_datasend_Req)
		{
			tmpdata_ptr = (char *)fsm_data_get();
    59ae:	e8 fc ff ff ff       	call   59af <rlc_mac_main+0x191f>
    59b3:	89 c7                	mov    %eax,%edi
			tmpdata = *((u32*)tmpdata_ptr);//
			//print_tran_info("CON receive a RLCdatareq");//testing code
			//fsm_printf("tmpdata:%d \n",tmpdata);//testing code
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    59b5:	8b 17                	mov    (%edi),%edx
    59b7:	8d 40 04             	lea    0x4(%eax),%eax
    59ba:	e8 fc ff ff ff       	call   59bb <rlc_mac_main+0x192b>
    59bf:	e8 fc ff ff ff       	call   59c0 <rlc_mac_main+0x1930>
			fsm_data_destroy((void *)tmpdata_ptr);//
    59c4:	89 f8                	mov    %edi,%eax
    59c6:	e8 fc ff ff ff       	call   59c7 <rlc_mac_main+0x1937>
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    59cb:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    59d2:	0f 85 b2 05 00 00    	jne    5f8a <rlc_mac_main+0x1efa>
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    59d8:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
			
			/*******for test *********/
			SV(UL_resource_info.resource_flag) = true;
    59de:	c6 43 28 01          	movb   $0x1,0x28(%ebx)
			/********for test *********/
			if(SV(UL_resource_info.resource_flag) == true)
			{
				//GetTBsize_Allocation(SV(UL_resource_info.m_tbsize));//tbsize,byte,BSR
				SV(UL_resource_info.m_tbsize)=1400*8;//for test
    59e2:	c7 43 2c c0 2b 00 00 	movl   $0x2bc0,0x2c(%ebx)
				SV(Tbsize_Complex)=SV(UL_resource_info.m_tbsize)/8;//20140718LHL byte,
    59e9:	c7 83 f4 01 00 00 78 	movl   $0x578,0x1f4(%ebx)
    59f0:	05 00 00 
				//fsm_printf("ready resource \n");
				if(! (list_empty(&(SV(MacBuffer_RLC)->list))))
    59f3:	8d 50 05             	lea    0x5(%eax),%edx
    59f6:	39 50 05             	cmp    %edx,0x5(%eax)
    59f9:	74 0f                	je     5a0a <rlc_mac_main+0x197a>
					DoResourceAllocation(GetTBsize_Allocation(SV(UL_resource_info.m_tbsize)));  //
    59fb:	b8 c0 2b 00 00       	mov    $0x2bc0,%eax
    5a00:	e8 fc ff ff ff       	call   5a01 <rlc_mac_main+0x1971>
    5a05:	e8 fc ff ff ff       	call   5a06 <rlc_mac_main+0x1976>
				SV(UL_resource_info.resource_flag)=false;
    5a0a:	c6 43 28 00          	movb   $0x0,0x28(%ebx)
    5a0e:	e9 e2 e8 ff ff       	jmp    42f5 <rlc_mac_main+0x265>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
		FOUT;	//add in 20150910
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
    5a13:	e8 fc ff ff ff       	call   5a14 <rlc_mac_main+0x1984>
    5a18:	8d 97 1c 02 00 00    	lea    0x21c(%edi),%edx
    5a1e:	e8 8d c2 ff ff       	call   1cb0 <findInsByCode>
    5a23:	89 c3                	mov    %eax,%ebx
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5a25:	8b 87 1c 02 00 00    	mov    0x21c(%edi),%eax
    5a2b:	83 f8 02             	cmp    $0x2,%eax
    5a2e:	0f 84 39 05 00 00    	je     5f6d <rlc_mac_main+0x1edd>
    5a34:	0f 87 fc 02 00 00    	ja     5d36 <rlc_mac_main+0x1ca6>
    5a3a:	83 e8 01             	sub    $0x1,%eax
    5a3d:	0f 84 57 05 00 00    	je     5f9a <rlc_mac_main+0x1f0a>
			//}
			
			FOUT;
			break;*/
		default:
			printk("[RLC][rlc_interupt] cannot distinguish this code \n");
    5a43:	c7 04 24 1c 13 00 00 	movl   $0x131c,(%esp)
    5a4a:	e8 fc ff ff ff       	call   5a4b <rlc_mac_main+0x19bb>
    5a4f:	e9 0c e8 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	else if(TimeAlignmentTimerExpire)
	{
		handle_timeAlignmentTimerExpire();
		FOUT;	//add in 20150910
	}
	else if(LogicalChannel_BJ)//modified 20141105 LHL,BJ
    5a54:	e8 fc ff ff ff       	call   5a55 <rlc_mac_main+0x19c5>
    5a59:	83 f8 09             	cmp    $0x9,%eax
    5a5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    5a60:	0f 85 78 e7 ff ff    	jne    41de <rlc_mac_main+0x14e>
	{
		FlushBj();
    5a66:	e8 fc ff ff ff       	call   5a67 <rlc_mac_main+0x19d7>
		fsm_schedule_self(MAC_BJ_TIME, LC_BJ_CODE);
    5a6b:	ba 09 00 00 00       	mov    $0x9,%edx
    5a70:	b8 64 00 00 00       	mov    $0x64,%eax
    5a75:	e8 fc ff ff ff       	call   5a76 <rlc_mac_main+0x19e6>
    5a7a:	e9 e1 e7 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		SV(WaitforRAresponseTimer.timer_sign)= NULL;
	}
	SV(PREAMBLE_TRANSMISSION_COUNTER)++ ;
	if(SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)
		//modified by HQ
		fsm_printf("[UEMAC][c_ra_failed]MAC:notice RRC has try RA for max times\n");//testing code
    5a7f:	c7 04 24 18 15 00 00 	movl   $0x1518,(%esp)
    5a86:	e8 fc ff ff ff       	call   5a87 <rlc_mac_main+0x19f7>
    5a8b:	e9 d0 e7 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
	cleanharqBuff();
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
    5a90:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    5a97:	00 00 00 
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5a9a:	31 c9                	xor    %ecx,%ecx
    5a9c:	ba 22 00 00 00       	mov    $0x22,%edx
	SV(PREAMBLE_TRANSMISSION_COUNTER)++;
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
    5aa1:	c7 83 e8 01 00 00 00 	movl   $0x0,0x1e8(%ebx)
    5aa8:	00 00 00 
		SV(pdcch_rnti)=0;
		SV(ra_allocation_res)=0;
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5aab:	b8 05 00 00 00       	mov    $0x5,%eax
	if (SV(PREAMBLE_TRANSMISSION_COUNTER)==PreambleTransMax + 1)//modified by HQ
	{
		//fsm_printf("[UEMAC][con_failed]:notice RRC has try RA for max times\n");//testing code 
		SV(sendmsg3)=0;
		SV(ratype.ra_type)=0;
		SV(pdcch_rnti)=0;
    5ab0:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    5ab7:	00 00 00 
		SV(ra_allocation_res)=0;
    5aba:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    5ac1:	00 00 00 
		fsm_do_ioctrl(STRM_TO_RRC, IOCCMD_MACtoRRC_RandomAcc_Fail  , NULL , 0);//Notify RRC the random access failed//add on 20141208
    5ac4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    5acb:	e8 fc ff ff ff       	call   5acc <rlc_mac_main+0x1a3c>
    5ad0:	e9 8b e7 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		fsm_mem_cpy(SV(msg3_buf_ptr)->head,skb->head,skb_len);
		skb_len = skb->tail - skb->data;

		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
    5ad5:	85 c0                	test   %eax,%eax
    5ad7:	74 0c                	je     5ae5 <rlc_mac_main+0x1a55>
    5ad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			fsm_pkt_destroy(SV(msg3_buf_ptr));
    5ae0:	e8 fc ff ff ff       	call   5ae1 <rlc_mac_main+0x1a51>
		SV(msg3_buf_ptr)=skb;//3
    5ae5:	31 c0                	xor    %eax,%eax
    5ae7:	89 83 e4 01 00 00    	mov    %eax,0x1e4(%ebx)
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5aed:	e8 fc ff ff ff       	call   5aee <rlc_mac_main+0x1a5e>
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5af2:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_skb_put(SV(msg3_buf_ptr),skb_len);
		fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);*/
		if(SV(msg3_buf_ptr)!=NULL)
			fsm_pkt_destroy(SV(msg3_buf_ptr));
		SV(msg3_buf_ptr)=skb;//3
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5af7:	89 c7                	mov    %eax,%edi
	
		//20140709 adition end  by HQ 	

		len=sizeof(RLCtoMAC_IciMsg);
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5af9:	e8 fc ff ff ff       	call   5afa <rlc_mac_main+0x1a6a>
    5afe:	85 c0                	test   %eax,%eax
    5b00:	74 1a                	je     5b1c <rlc_mac_main+0x1a8c>
    5b02:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5b06:	74 14                	je     5b1c <rlc_mac_main+0x1a8c>
		{	
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n");
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5b08:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5b0f:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5b16:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
			
			//fsm_printf("[MAC FSM]RNTI IN SV:%d\n",SV(C_RNTI));
			
			
		}
		SV(sendmsg3)=1;
    5b1c:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5b23:	00 00 00 
		complexUeMacPdu(skb);
    5b26:	89 f8                	mov    %edi,%eax
    5b28:	e8 fc ff ff ff       	call   5b29 <rlc_mac_main+0x1a99>
		
	
		if(SV(Tbsize_Complex)!=0)
    5b2d:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5b34:	74 0a                	je     5b40 <rlc_mac_main+0x1ab0>
			SV(Tbsize_Complex)=0;//TBSIZE
    5b36:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5b3d:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
    5b40:	c7 04 24 ec 0b 00 00 	movl   $0xbec,(%esp)
    5b47:	e8 fc ff ff ff       	call   5b48 <rlc_mac_main+0x1ab8>
    5b4c:	e9 70 f9 ff ff       	jmp    54c1 <rlc_mac_main+0x1431>
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			FOUT;
		}
		switch(SV(timerType))
    5b51:	83 f8 03             	cmp    $0x3,%eax
    5b54:	0f 84 53 04 00 00    	je     5fad <rlc_mac_main+0x1f1d>
    5b5a:	83 f8 04             	cmp    $0x4,%eax
    5b5d:	8d 76 00             	lea    0x0(%esi),%esi
    5b60:	0f 85 44 fc ff ff    	jne    57aa <rlc_mac_main+0x171a>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5b66:	0f b6 47 02          	movzbl 0x2(%edi),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5b6a:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5b71:	c7 04 24 e4 12 00 00 	movl   $0x12e4,(%esp)
    5b78:	89 44 24 04          	mov    %eax,0x4(%esp)
    5b7c:	e8 fc ff ff ff       	call   5b7d <rlc_mac_main+0x1aed>
			if(umRxIns->snFiledLength == 5)
    5b81:	66 83 7f 06 05       	cmpw   $0x5,0x6(%edi)
    5b86:	0f 84 19 05 00 00    	je     60a5 <rlc_mac_main+0x2015>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5b8c:	66 83 7f 06 0a       	cmpw   $0xa,0x6(%edi)
    5b91:	0f 85 71 e7 ff ff    	jne    4308 <rlc_mac_main+0x278>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5b97:	0f b7 8f be 10 00 00 	movzwl 0x10be(%edi),%ecx
    5b9e:	bb 00 04 00 00       	mov    $0x400,%ebx
    5ba3:	89 ca                	mov    %ecx,%edx
    5ba5:	89 c8                	mov    %ecx,%eax
    5ba7:	66 c1 fa 0f          	sar    $0xf,%dx
    5bab:	66 f7 fb             	idiv   %bx
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5bae:	0f bf da             	movswl %dx,%ebx
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5bb1:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5bb8:	83 bc 9f b8 00 00 00 	cmpl   $0x0,0xb8(%edi,%ebx,4)
    5bbf:	00 
    5bc0:	74 3b                	je     5bfd <rlc_mac_main+0x1b6d>
    5bc2:	66 39 d1             	cmp    %dx,%cx
    5bc5:	7e 0e                	jle    5bd5 <rlc_mac_main+0x1b45>
    5bc7:	eb 34                	jmp    5bfd <rlc_mac_main+0x1b6d>
    5bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    5bd0:	66 39 c1             	cmp    %ax,%cx
    5bd3:	7f 21                	jg     5bf6 <rlc_mac_main+0x1b66>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5bd5:	8d 43 01             	lea    0x1(%ebx),%eax
    5bd8:	89 c2                	mov    %eax,%edx
    5bda:	c1 fa 1f             	sar    $0x1f,%edx
    5bdd:	c1 ea 16             	shr    $0x16,%edx
    5be0:	01 d0                	add    %edx,%eax
    5be2:	25 ff 03 00 00       	and    $0x3ff,%eax
    5be7:	29 d0                	sub    %edx,%eax
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5be9:	0f bf d8             	movswl %ax,%ebx
    5bec:	83 bc 9f b8 00 00 00 	cmpl   $0x0,0xb8(%edi,%ebx,4)
    5bf3:	00 
    5bf4:	75 da                	jne    5bd0 <rlc_mac_main+0x1b40>
    5bf6:	66 89 87 bc 10 00 00 	mov    %ax,0x10bc(%edi)
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5bfd:	8d 57 18             	lea    0x18(%edi),%edx
    5c00:	89 f8                	mov    %edi,%eax
    5c02:	e8 fc ff ff ff       	call   5c03 <rlc_mac_main+0x1b73>
    5c07:	e9 fc e6 ff ff       	jmp    4308 <rlc_mac_main+0x278>
				SV(ratype.ra_type)=2;
			break;
			//PHYRA
			case IOCCMD_PDCCHtoMAC_RandomAcc_Req: 	
			// break	  
				tmpdata_ptr = fsm_data_get();
    5c0c:	e8 fc ff ff ff       	call   5c0d <rlc_mac_main+0x1b7d>
    5c11:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5c13:	b8 a8 13 00 00       	mov    $0x13a8,%eax
    5c18:	e8 fc ff ff ff       	call   5c19 <rlc_mac_main+0x1b89>
				if(tmpdata_ptr > 0)//
    5c1d:	85 db                	test   %ebx,%ebx
    5c1f:	0f 84 2a 05 00 00    	je     614f <rlc_mac_main+0x20bf>
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
				if(tmpdata_ptr > 0)//
				{
					fsm_printf("[UEMAC][idle_default]IDLE receive a ncra order ");
    5c25:	c7 04 24 e8 13 00 00 	movl   $0x13e8,(%esp)
    5c2c:	e8 fc ff ff ff       	call   5c2d <rlc_mac_main+0x1b9d>
					fsm_mem_cpy(&(SV(RA_info)),tmpdata_ptr,sizeof(RACH_ConfigDedicated));
    5c31:	89 da                	mov    %ebx,%edx
    5c33:	b9 02 00 00 00       	mov    $0x2,%ecx
    5c38:	8d 47 04             	lea    0x4(%edi),%eax
    5c3b:	e8 fc ff ff ff       	call   5c3c <rlc_mac_main+0x1bac>
					fsm_printf("[UEMAC][idle_default]the RAPID is %d\n",SV(RA_info.ra_PreambleIndex));
    5c40:	0f b6 47 04          	movzbl 0x4(%edi),%eax
    5c44:	c7 04 24 18 14 00 00 	movl   $0x1418,(%esp)
    5c4b:	89 44 24 04          	mov    %eax,0x4(%esp)
    5c4f:	e8 fc ff ff ff       	call   5c50 <rlc_mac_main+0x1bc0>
					if(tmpdata_ptr != NULL)
					{
						fsm_data_destroy(tmpdata_ptr);//
    5c54:	89 d8                	mov    %ebx,%eax
    5c56:	e8 fc ff ff ff       	call   5c57 <rlc_mac_main+0x1bc7>
						fsm_printf("[UEMAC][idle_default]fsm_ev_data,then free the memory\n");
    5c5b:	c7 04 24 40 14 00 00 	movl   $0x1440,(%esp)
    5c62:	e8 fc ff ff ff       	call   5c63 <rlc_mac_main+0x1bd3>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
    5c67:	ba 01 00 00 00       	mov    $0x1,%edx
    5c6c:	31 c0                	xor    %eax,%eax
    5c6e:	e8 fc ff ff ff       	call   5c6f <rlc_mac_main+0x1bdf>
    5c73:	e9 dd e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5c78:	e8 fc ff ff ff       	call   5c79 <rlc_mac_main+0x1be9>
				tmpdata = *((u32*)tmpdata_ptr);//				
    5c7d:	8b 10                	mov    (%eax),%edx
		fsm_printf("[MAC][DEFAULT_CMD]%d\n",cmd1);
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
    5c7f:	89 c3                	mov    %eax,%ebx
				tmpdata = *((u32*)tmpdata_ptr);//				
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5c81:	c7 04 24 88 12 00 00 	movl   $0x1288,(%esp)
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req :
				tmpdata_ptr = (char *)fsm_data_get();
				tmpdata = *((u32*)tmpdata_ptr);//				
    5c88:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				fsm_printf("[UEMAC][idle_default]MAC IDLE receive a RLCdatareq,");//testing code
    5c8b:	e8 fc ff ff ff       	call   5c8c <rlc_mac_main+0x1bfc>
				fsm_printf("[UEMAC][idle_default]tmpdata:%d ",tmpdata);//testing code
    5c90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5c93:	c7 04 24 84 13 00 00 	movl   $0x1384,(%esp)
    5c9a:	89 54 24 04          	mov    %edx,0x4(%esp)
    5c9e:	e8 fc ff ff ff       	call   5c9f <rlc_mac_main+0x1c0f>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
    5ca3:	8b 43 07             	mov    0x7(%ebx),%eax
    5ca6:	c7 04 24 bc 12 00 00 	movl   $0x12bc,(%esp)
    5cad:	89 44 24 04          	mov    %eax,0x4(%esp)
    5cb1:	e8 fc ff ff ff       	call   5cb2 <rlc_mac_main+0x1c22>
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    5cb6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    5cb9:	8d 43 04             	lea    0x4(%ebx),%eax
    5cbc:	e8 fc ff ff ff       	call   5cbd <rlc_mac_main+0x1c2d>
    5cc1:	e8 fc ff ff ff       	call   5cc2 <rlc_mac_main+0x1c32>
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
    5cc6:	89 d8                	mov    %ebx,%eax
    5cc8:	e8 fc ff ff ff       	call   5cc9 <rlc_mac_main+0x1c39>
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    5ccd:	80 bf 58 01 00 00 00 	cmpb   $0x0,0x158(%edi)
    5cd4:	0f 85 9a 04 00 00    	jne    6174 <rlc_mac_main+0x20e4>
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
				//fsm_schedule_self(0,Start_ContentionBase_RandomAcc); // 10us 
				fsm_schedule_self(1000,Start_ContentionBase_RandomAcc); //1000 for test
    5cda:	ba 02 00 00 00       	mov    $0x2,%edx
    5cdf:	b8 e8 03 00 00       	mov    $0x3e8,%eax
    5ce4:	e8 fc ff ff ff       	call   5ce5 <rlc_mac_main+0x1c55>
				SV(ratype.ra_type)=2;
    5ce9:	c7 87 e8 01 00 00 02 	movl   $0x2,0x1e8(%edi)
    5cf0:	00 00 00 
    5cf3:	e9 5d e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
				}
			break;
			//RRCRA
			case IOCCMD_RRCtoMAC_RandomAcc_Req :
				tmpdata_ptr = fsm_data_get();
    5cf8:	e8 fc ff ff ff       	call   5cf9 <rlc_mac_main+0x1c69>
    5cfd:	89 c3                	mov    %eax,%ebx
				print_tran_info("[UEMAC][idle_default]IDLE receive a RA req from other layer,");
    5cff:	b8 a8 13 00 00       	mov    $0x13a8,%eax
    5d04:	e8 fc ff ff ff       	call   5d05 <rlc_mac_main+0x1c75>
				if(tmpdata_ptr > 0)//
    5d09:	85 db                	test   %ebx,%ebx
    5d0b:	0f 85 14 ff ff ff    	jne    5c25 <rlc_mac_main+0x1b95>
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    5d11:	b8 78 14 00 00       	mov    $0x1478,%eax
    5d16:	e8 fc ff ff ff       	call   5d17 <rlc_mac_main+0x1c87>
					SV(ratype.ra_type)=3;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5d1b:	ba 02 00 00 00       	mov    $0x2,%edx
    5d20:	31 c0                	xor    %eax,%eax
					//  20140531HQ 
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=3;
    5d22:	c7 87 e8 01 00 00 03 	movl   $0x3,0x1e8(%edi)
    5d29:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    5d2c:	e8 fc ff ff ff       	call   5d2d <rlc_mac_main+0x1c9d>
    5d31:	e9 1f e5 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
		{
			//fsm_printf("[RLC][rlc_interupt] the instance of this code is NULL\n");
			//fsm_printf("cannot find the instance of this code \n ");
			//FOUT;
		}
		switch(SV(timerType))
    5d36:	83 f8 03             	cmp    $0x3,%eax
    5d39:	0f 84 3d 01 00 00    	je     5e7c <rlc_mac_main+0x1dec>
    5d3f:	83 f8 04             	cmp    $0x4,%eax
    5d42:	0f 85 fb fc ff ff    	jne    5a43 <rlc_mac_main+0x19b3>
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5d48:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
			FOUT;
			break;

		case UM_REORDER:
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
    5d4c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
    5d53:	c7 04 24 e4 12 00 00 	movl   $0x12e4,(%esp)
    5d5a:	89 44 24 04          	mov    %eax,0x4(%esp)
    5d5e:	e8 fc ff ff ff       	call   5d5f <rlc_mac_main+0x1ccf>
			if(umRxIns->snFiledLength == 5)
    5d63:	66 83 7b 06 05       	cmpw   $0x5,0x6(%ebx)
    5d68:	0f 84 60 04 00 00    	je     61ce <rlc_mac_main+0x213e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
    5d6e:	66 83 7b 06 0a       	cmpw   $0xa,0x6(%ebx)
    5d73:	0f 85 e7 e4 ff ff    	jne    4260 <rlc_mac_main+0x1d0>
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5d79:	0f b7 8b be 10 00 00 	movzwl 0x10be(%ebx),%ecx
    5d80:	bf 00 04 00 00       	mov    $0x400,%edi
    5d85:	89 ca                	mov    %ecx,%edx
    5d87:	89 c8                	mov    %ecx,%eax
    5d89:	66 c1 fa 0f          	sar    $0xf,%dx
    5d8d:	66 f7 ff             	idiv   %di
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5d90:	bf 00 04 00 00       	mov    $0x400,%edi
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
    5d95:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    5d9c:	eb 16                	jmp    5db4 <rlc_mac_main+0x1d24>
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5d9e:	66 39 c1             	cmp    %ax,%cx
    5da1:	7f 25                	jg     5dc8 <rlc_mac_main+0x1d38>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
    5da3:	8d 42 01             	lea    0x1(%edx),%eax
    5da6:	89 c2                	mov    %eax,%edx
    5da8:	c1 fa 1f             	sar    $0x1f,%edx
    5dab:	f7 ff                	idiv   %edi
    5dad:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			}
			if(umRxIns->snFiledLength == 10)
			{
				//umRxIns->vr_ur = umRxIns->vr_ux - 1;
				umRxIns->vr_ur = umRxIns->vr_ux%(UM_WINDOW_SIZE10*2);
				while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur >= umRxIns->vr_ux))
    5db4:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    5dbb:	0f bf d0             	movswl %ax,%edx
    5dbe:	83 bc 93 b8 00 00 00 	cmpl   $0x0,0xb8(%ebx,%edx,4)
    5dc5:	00 
    5dc6:	75 d6                	jne    5d9e <rlc_mac_main+0x1d0e>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE10*2);
				}
				rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    5dc8:	8d 53 18             	lea    0x18(%ebx),%edx
    5dcb:	89 d8                	mov    %ebx,%eax
    5dcd:	e8 fc ff ff ff       	call   5dce <rlc_mac_main+0x1d3e>
    5dd2:	e9 89 e4 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5dd7:	e8 fc ff ff ff       	call   5dd8 <rlc_mac_main+0x1d48>
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5ddc:	ba 04 00 00 00       	mov    $0x4,%edx
		fsm_printf("[UEMAC][send_msg3]:this is the first time to do CRA \n");//testing code 
	}
	else if(SV(msg3_buf_ptr) != NULL && SV(ra_allocation_res)==2)  
	{
		len=sizeof(RLCtoMAC_IciMsg);
		skb=fsm_pkt_duplicate(SV(msg3_buf_ptr));//20140729 lhl
    5de1:	89 c7                	mov    %eax,%edi
		//lteMacCcchSend(skb,len)SDUccch0,SDU1	
		if(lteMacCcchSend(skb,len) && SV(C_RNTI)!= 0 ) //CCCH C_RNTI_MAC
    5de3:	e8 fc ff ff ff       	call   5de4 <rlc_mac_main+0x1d54>
    5de8:	85 c0                	test   %eax,%eax
    5dea:	74 1a                	je     5e06 <rlc_mac_main+0x1d76>
    5dec:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    5df0:	74 14                	je     5e06 <rlc_mac_main+0x1d76>
		{
			//fsm_printf("[LHL]C_RNTI CONTROL ELEMENT!\n",SV(ra_allocation_res));
			SV(MAC_CE_Tags)[CRNTI_CE].addinPDU_flag=true;
    5df2:	c6 83 ac 01 00 00 01 	movb   $0x1,0x1ac(%ebx)
			//SV(MAC_CE_Tags)[CRNTI_CE].LCID=CCCH_LCID;
			SV(MAC_CE_Tags)[CRNTI_CE].LCID=C_RNTI_LCID;
    5df9:	c6 83 ad 01 00 00 1b 	movb   $0x1b,0x1ad(%ebx)
			SV(MAC_CE_Tags)[CRNTI_CE].MAC_CE_ptr=(void *)&SV(C_RNTI);
    5e00:	89 9b b0 01 00 00    	mov    %ebx,0x1b0(%ebx)
		}
		SV(sendmsg3)=1;	
    5e06:	c7 83 ec 01 00 00 01 	movl   $0x1,0x1ec(%ebx)
    5e0d:	00 00 00 
		complexUeMacPdu(skb); 	
    5e10:	89 f8                	mov    %edi,%eax
    5e12:	e8 fc ff ff ff       	call   5e13 <rlc_mac_main+0x1d83>
		if(SV(Tbsize_Complex)!=0)//?????????????????????????????
    5e17:	83 bb f4 01 00 00 00 	cmpl   $0x0,0x1f4(%ebx)
    5e1e:	74 0a                	je     5e2a <rlc_mac_main+0x1d9a>
			SV(Tbsize_Complex)=0;//TBSIZE  ???
    5e20:	c7 83 f4 01 00 00 00 	movl   $0x0,0x1f4(%ebx)
    5e27:	00 00 00 
		fsm_printf("[UEMAC][send_msg3]:this isn't the first time to CRA \n");//testing code 
    5e2a:	c7 04 24 24 0c 00 00 	movl   $0xc24,(%esp)
    5e31:	e8 fc ff ff ff       	call   5e32 <rlc_mac_main+0x1da2>
    5e36:	e9 86 f6 ff ff       	jmp    54c1 <rlc_mac_main+0x1431>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5e3b:	80 7f 06 00          	cmpb   $0x0,0x6(%edi)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5e3f:	c7 47 20 00 00 00 00 	movl   $0x0,0x20(%edi)
			if(amIns->statFlag)
    5e46:	0f 84 bc e4 ff ff    	je     4308 <rlc_mac_main+0x278>
			{
				rlc_ctrl_pkt_trans(amIns);
    5e4c:	89 f8                	mov    %edi,%eax
    5e4e:	e8 fc ff ff ff       	call   5e4f <rlc_mac_main+0x1dbf>
    5e53:	e9 b0 e4 ff ff       	jmp    4308 <rlc_mac_main+0x278>
		rlc_pkt_receive_from_upper();

		//printk("[RLC_MAC]SV(countRecvFromUpper): %d\n", SV(countRecvFromUpper));
		//add following code in 20150915
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC][con_default_handler]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    5e58:	c7 04 24 5c 1d 00 00 	movl   $0x1d5c,(%esp)
    5e5f:	e8 fc ff ff ff       	call   5e60 <rlc_mac_main+0x1dd0>
    5e64:	e9 9f e4 ff ff       	jmp    4308 <rlc_mac_main+0x278>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5e69:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
			rlc_poll_retx(amIns);
    5e70:	89 f8                	mov    %edi,%eax
    5e72:	e8 fc ff ff ff       	call   5e73 <rlc_mac_main+0x1de3>
    5e77:	e9 8c e4 ff ff       	jmp    4308 <rlc_mac_main+0x278>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5e7c:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    5e83:	0f bf 93 f2 22 00 00 	movswl 0x22f2(%ebx),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5e8a:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5e91:	39 d0                	cmp    %edx,%eax
    5e93:	7d 29                	jge    5ebe <rlc_mac_main+0x1e2e>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5e95:	83 bc 83 6c 12 00 00 	cmpl   $0x0,0x126c(%ebx,%eax,4)
    5e9c:	00 
    5e9d:	0f 84 a3 02 00 00    	je     6146 <rlc_mac_main+0x20b6>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5ea3:	83 c0 01             	add    $0x1,%eax
    5ea6:	eb 12                	jmp    5eba <rlc_mac_main+0x1e2a>
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5ea8:	83 c0 01             	add    $0x1,%eax
    5eab:	8b 8c 83 68 12 00 00 	mov    0x1268(%ebx,%eax,4),%ecx
    5eb2:	85 c9                	test   %ecx,%ecx
    5eb4:	0f 84 8c 02 00 00    	je     6146 <rlc_mac_main+0x20b6>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5eba:	39 d0                	cmp    %edx,%eax
    5ebc:	75 ea                	jne    5ea8 <rlc_mac_main+0x1e18>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5ebe:	0f b7 8b f0 22 00 00 	movzwl 0x22f0(%ebx),%ecx
    5ec5:	bf 00 04 00 00       	mov    $0x400,%edi
    5eca:	89 ca                	mov    %ecx,%edx
    5ecc:	89 c8                	mov    %ecx,%eax
    5ece:	66 c1 fa 0f          	sar    $0xf,%dx
    5ed2:	66 f7 ff             	idiv   %di
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5ed5:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5ed8:	66 89 93 f2 22 00 00 	mov    %dx,0x22f2(%ebx)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5edf:	7e 2f                	jle    5f10 <rlc_mac_main+0x1e80>
    5ee1:	eb 3b                	jmp    5f1e <rlc_mac_main+0x1e8e>
    5ee3:	90                   	nop
    5ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    5ee8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    5eec:	74 30                	je     5f1e <rlc_mac_main+0x1e8e>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5eee:	8d 42 01             	lea    0x1(%edx),%eax
    5ef1:	89 c2                	mov    %eax,%edx
    5ef3:	c1 fa 1f             	sar    $0x1f,%edx
    5ef6:	c1 ea 16             	shr    $0x16,%edx
    5ef9:	01 d0                	add    %edx,%eax
    5efb:	25 ff 03 00 00       	and    $0x3ff,%eax
    5f00:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5f02:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    5f05:	89 c2                	mov    %eax,%edx
    5f07:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    5f0e:	7f 0e                	jg     5f1e <rlc_mac_main+0x1e8e>
    5f10:	0f bf d2             	movswl %dx,%edx
    5f13:	8b 84 93 6c 12 00 00 	mov    0x126c(%ebx,%edx,4),%eax
    5f1a:	85 c0                	test   %eax,%eax
    5f1c:	75 ca                	jne    5ee8 <rlc_mac_main+0x1e58>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    5f1e:	8d 53 30             	lea    0x30(%ebx),%edx
    5f21:	89 d8                	mov    %ebx,%eax
    5f23:	e8 fc ff ff ff       	call   5f24 <rlc_mac_main+0x1e94>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    5f28:	0f b7 93 ee 22 00 00 	movzwl 0x22ee(%ebx),%edx
    5f2f:	0f b7 83 f2 22 00 00 	movzwl 0x22f2(%ebx),%eax
    5f36:	66 39 c2             	cmp    %ax,%dx
    5f39:	7f 11                	jg     5f4c <rlc_mac_main+0x1ebc>
    5f3b:	98                   	cwtl   
    5f3c:	0f bf d2             	movswl %dx,%edx
    5f3f:	2d 00 02 00 00       	sub    $0x200,%eax
    5f44:	39 c2                	cmp    %eax,%edx
    5f46:	0f 8d 14 e3 ff ff    	jge    4260 <rlc_mac_main+0x1d0>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    5f4c:	8b 53 18             	mov    0x18(%ebx),%edx
    5f4f:	8b 43 1c             	mov    0x1c(%ebx),%eax
    5f52:	e8 fc ff ff ff       	call   5f53 <rlc_mac_main+0x1ec3>
    5f57:	89 43 14             	mov    %eax,0x14(%ebx)
				amIns->vr_x = amIns->vr_h;
    5f5a:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    5f61:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    5f68:	e9 f3 e2 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
			if(amIns->statFlag)
    5f6d:	80 7b 06 00          	cmpb   $0x0,0x6(%ebx)
			FOUT;
			break;

		case STAT_PRO:
			amIns = (AM_Instance *)insPtr;
			amIns->statProhTimer = 0;
    5f71:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
			if(amIns->statFlag)
    5f78:	0f 84 e2 e2 ff ff    	je     4260 <rlc_mac_main+0x1d0>
			{
				rlc_ctrl_pkt_trans(amIns);
    5f7e:	89 d8                	mov    %ebx,%eax
    5f80:	e8 fc ff ff ff       	call   5f81 <rlc_mac_main+0x1ef1>
    5f85:	e9 d6 e2 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
    5f8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			//fsm_printf("txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(int)))->txQueueSize);//testing code
			DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
			fsm_data_destroy((void *)tmpdata_ptr);//
			if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
				//RefreshBufferStatusForBSR();
				DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false
    5f90:	e8 fc ff ff ff       	call   5f91 <rlc_mac_main+0x1f01>
    5f95:	e9 3e fa ff ff       	jmp    59d8 <rlc_mac_main+0x1948>
		}
		switch(SV(timerType))
		{
		case POLL_RETX:
			amIns = (AM_Instance *)insPtr;
			amIns->pollRetxTimer = 0;
    5f9a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			rlc_poll_retx(amIns);
    5fa1:	89 d8                	mov    %ebx,%eax
    5fa3:	e8 fc ff ff ff       	call   5fa4 <rlc_mac_main+0x1f14>
    5fa8:	e9 b3 e2 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5fad:	0f bf 87 f4 22 00 00 	movswl 0x22f4(%edi),%eax
    5fb4:	0f bf 97 f2 22 00 00 	movswl 0x22f2(%edi),%edx
			FOUT;
			break;

		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
    5fbb:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5fc2:	39 d0                	cmp    %edx,%eax
    5fc4:	7d 30                	jge    5ff6 <rlc_mac_main+0x1f66>
			{
				if(amIns->amRecvWindow[i] == NULL)
    5fc6:	83 bc 87 6c 12 00 00 	cmpl   $0x0,0x126c(%edi,%eax,4)
    5fcd:	00 
    5fce:	0f 84 2a 01 00 00    	je     60fe <rlc_mac_main+0x206e>
**Created Date: 2015
**-----------------------------------------------------
**Modified by: 
**Modified Date: 
**********************************************************/
void rlc_mac_main(void)
    5fd4:	83 c0 01             	add    $0x1,%eax
    5fd7:	eb 19                	jmp    5ff2 <rlc_mac_main+0x1f62>
    5fd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
    5fe0:	83 c0 01             	add    $0x1,%eax
    5fe3:	8b 8c 87 68 12 00 00 	mov    0x1268(%edi,%eax,4),%ecx
    5fea:	85 c9                	test   %ecx,%ecx
    5fec:	0f 84 0c 01 00 00    	je     60fe <rlc_mac_main+0x206e>
		case AM_REORDER:
			amIns = (AM_Instance *)insPtr;
			amIns->reorderTimer = 0;
			//fsm_printf("[RLC][rlc_interupt] am reorder timeout\n");

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
    5ff2:	39 d0                	cmp    %edx,%eax
    5ff4:	75 ea                	jne    5fe0 <rlc_mac_main+0x1f50>
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    5ff6:	0f b7 8f f0 22 00 00 	movzwl 0x22f0(%edi),%ecx
    5ffd:	bb 00 04 00 00       	mov    $0x400,%ebx
    6002:	89 ca                	mov    %ecx,%edx
    6004:	89 c8                	mov    %ecx,%eax
    6006:	66 c1 fa 0f          	sar    $0xf,%dx
    600a:	66 f7 fb             	idiv   %bx
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    600d:	66 39 d1             	cmp    %dx,%cx
					}*/
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
    6010:	66 89 97 f2 22 00 00 	mov    %dx,0x22f2(%edi)
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    6017:	7e 2f                	jle    6048 <rlc_mac_main+0x1fb8>
    6019:	eb 3b                	jmp    6056 <rlc_mac_main+0x1fc6>
    601b:	90                   	nop
    601c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
    6020:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    6024:	74 30                	je     6056 <rlc_mac_main+0x1fc6>
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    6026:	8d 42 01             	lea    0x1(%edx),%eax
    6029:	89 c2                	mov    %eax,%edx
    602b:	c1 fa 1f             	sar    $0x1f,%edx
    602e:	c1 ea 16             	shr    $0x16,%edx
    6031:	01 d0                	add    %edx,%eax
    6033:	25 ff 03 00 00       	and    $0x3ff,%eax
    6038:	29 d0                	sub    %edx,%eax
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    603a:	66 39 c1             	cmp    %ax,%cx
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
    603d:	89 c2                	mov    %eax,%edx
    603f:	66 89 87 f2 22 00 00 	mov    %ax,0x22f2(%edi)
					break;
				}
			}
			//vr_msvr_xAMD PDU
			amIns->vr_ms = amIns->vr_x % 1024;
			while((amIns->vr_ms >= amIns->vr_x)&&((amIns->amRecvWindow[amIns->vr_ms] != NULL)\
    6046:	7f 0e                	jg     6056 <rlc_mac_main+0x1fc6>
    6048:	0f bf d2             	movswl %dx,%edx
    604b:	8b 84 97 6c 12 00 00 	mov    0x126c(%edi,%edx,4),%eax
    6052:	85 c0                	test   %eax,%eax
    6054:	75 ca                	jne    6020 <rlc_mac_main+0x1f90>
					&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus != FULL_SDU)))
			{
				amIns->vr_ms = (amIns->vr_ms+1)%1024;
			}
			//fsm_printf("[RLC][rlc_interupt] amIns->vr_ms is updated to %d\n",amIns->vr_ms);
			rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    6056:	8d 57 30             	lea    0x30(%edi),%edx
    6059:	89 f8                	mov    %edi,%eax
    605b:	e8 fc ff ff ff       	call   605c <rlc_mac_main+0x1fcc>
			if(amIns->vr_h > amIns->vr_ms || amIns->vr_h < amIns->vr_ms - AM_WINDOW_SIZE)
    6060:	0f b7 97 ee 22 00 00 	movzwl 0x22ee(%edi),%edx
    6067:	0f b7 87 f2 22 00 00 	movzwl 0x22f2(%edi),%eax
    606e:	66 39 c2             	cmp    %ax,%dx
    6071:	7f 11                	jg     6084 <rlc_mac_main+0x1ff4>
    6073:	98                   	cwtl   
    6074:	0f bf d2             	movswl %dx,%edx
    6077:	2d 00 02 00 00       	sub    $0x200,%eax
    607c:	39 c2                	cmp    %eax,%edx
    607e:	0f 8d 84 e2 ff ff    	jge    4308 <rlc_mac_main+0x278>
			{
				amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue, amIns->reorderTimerCode);
    6084:	8b 57 18             	mov    0x18(%edi),%edx
    6087:	8b 47 1c             	mov    0x1c(%edi),%eax
    608a:	e8 fc ff ff ff       	call   608b <rlc_mac_main+0x1ffb>
    608f:	89 47 14             	mov    %eax,0x14(%edi)
				amIns->vr_x = amIns->vr_h;
    6092:	0f b7 87 ee 22 00 00 	movzwl 0x22ee(%edi),%eax
    6099:	66 89 87 f0 22 00 00 	mov    %ax,0x22f0(%edi)
    60a0:	e9 63 e2 ff ff       	jmp    4308 <rlc_mac_main+0x278>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    60a5:	0f bf 87 bc 10 00 00 	movswl 0x10bc(%edi),%eax
    60ac:	b9 20 00 00 00       	mov    $0x20,%ecx
    60b1:	83 c0 01             	add    $0x1,%eax
    60b4:	89 c2                	mov    %eax,%edx
    60b6:	c1 fa 1f             	sar    $0x1f,%edx
    60b9:	f7 f9                	idiv   %ecx
    60bb:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
    60c2:	eb 1a                	jmp    60de <rlc_mac_main+0x204e>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    60c4:	66 3b 87 be 10 00 00 	cmp    0x10be(%edi),%ax
    60cb:	7f 22                	jg     60ef <rlc_mac_main+0x205f>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    60cd:	8d 42 01             	lea    0x1(%edx),%eax
    60d0:	89 c2                	mov    %eax,%edx
    60d2:	c1 fa 1f             	sar    $0x1f,%edx
    60d5:	f7 f9                	idiv   %ecx
    60d7:	66 89 97 bc 10 00 00 	mov    %dx,0x10bc(%edi)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    60de:	0f b7 87 bc 10 00 00 	movzwl 0x10bc(%edi),%eax
    60e5:	0f bf d0             	movswl %ax,%edx
    60e8:	83 7c 97 38 00       	cmpl   $0x0,0x38(%edi,%edx,4)
    60ed:	75 d5                	jne    60c4 <rlc_mac_main+0x2034>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    60ef:	8d 57 18             	lea    0x18(%edi),%edx
    60f2:	89 f8                	mov    %edi,%eax
    60f4:	e8 fc ff ff ff       	call   60f5 <rlc_mac_main+0x2065>
    60f9:	e9 8e fa ff ff       	jmp    5b8c <rlc_mac_main+0x1afc>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    60fe:	c6 47 06 01          	movb   $0x1,0x6(%edi)
    6102:	e9 ef fe ff ff       	jmp    5ff6 <rlc_mac_main+0x1f66>
		SV(countRecvFromUpper)++;
		rlc_pkt_receive_from_upper();

		//add in 20150908
		if( PMRLC_BUFFERREP_REQ() == NULL )
			fsm_printf("[RLC_MAC]: the return pointer of PMRLC_BUFFERREP_REQ is NULL!\n");
    6107:	c7 04 24 48 12 00 00 	movl   $0x1248,(%esp)
    610e:	e8 fc ff ff ff       	call   610f <rlc_mac_main+0x207f>
    6113:	e9 48 e1 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
		switch(fsm_ev_ioctrl_cmd())
		{
			//RLC
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
    6118:	c7 04 24 30 18 00 00 	movl   $0x1830,(%esp)
    611f:	e8 fc ff ff ff       	call   6120 <rlc_mac_main+0x2090>
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
    6124:	83 bb ec 01 00 00 00 	cmpl   $0x0,0x1ec(%ebx)
    612b:	74 0a                	je     6137 <rlc_mac_main+0x20a7>
    612d:	66 83 3b 00          	cmpw   $0x0,(%ebx)
    6131:	0f 85 01 01 00 00    	jne    6238 <rlc_mac_main+0x21a8>
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
					SV(ratype.ra_type)=2;
				}
				else//
				{
					tmpdata_ptr = (char *)fsm_data_get();
    6137:	e8 fc ff ff ff       	call   6138 <rlc_mac_main+0x20a8>
					fsm_data_destroy((void *)tmpdata_ptr);//
    613c:	e8 fc ff ff ff       	call   613d <rlc_mac_main+0x20ad>
    6141:	e9 62 e3 ff ff       	jmp    44a8 <rlc_mac_main+0x418>

			for(i = amIns->vr_r; i < amIns->vr_ms; i++)   //20141201
			{
				if(amIns->amRecvWindow[i] == NULL)
				{
					amIns->statFlag = true;  //true
    6146:	c6 43 06 01          	movb   $0x1,0x6(%ebx)
    614a:	e9 6f fd ff ff       	jmp    5ebe <rlc_mac_main+0x1e2e>
					}
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
    614f:	b8 78 14 00 00       	mov    $0x1478,%eax
    6154:	e8 fc ff ff ff       	call   6155 <rlc_mac_main+0x20c5>
					SV(ratype.ra_type)=1;
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    6159:	ba 02 00 00 00       	mov    $0x2,%edx
    615e:	31 c0                	xor    %eax,%eax
					fsm_schedule_self(0, Start_NonContentionBase_RandomAcc );// //
				}
				else //
				{
					print_tran_info("[UEMAC][idle_default]IDLE receive a cra order ");
					SV(ratype.ra_type)=1;
    6160:	c7 87 e8 01 00 00 01 	movl   $0x1,0x1e8(%edi)
    6167:	00 00 00 
					fsm_schedule_self(0, Start_ContentionBase_RandomAcc );//
    616a:	e8 fc ff ff ff       	call   616b <rlc_mac_main+0x20db>
    616f:	e9 e1 e0 ff ff       	jmp    4255 <rlc_mac_main+0x1c5>
				fsm_printf("[UEMAC][idle_default]txQueueSize:%d\n",((RLC_Request *)(tmpdata_ptr+sizeof(u32)))->txQueueSize);//testing code
				DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
				//tmpdata_ptr+sizeof(int)//4 
				fsm_data_destroy((void *)tmpdata_ptr);//
				if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
					DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    6174:	e8 fc ff ff ff       	call   6175 <rlc_mac_main+0x20e5>
    6179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    6180:	e9 55 fb ff ff       	jmp    5cda <rlc_mac_main+0x1c4a>
		//FOUT;
	}

	if(MAC_PK_FROM_LOWER)
	{//ICI  RLC
		print_tran_info("[UEMAC][con_default]CON receive a data packet from PHYadapter");//testing code
    6185:	b8 1c 1d 00 00       	mov    $0x1d1c,%eax
    618a:	e8 fc ff ff ff       	call   618b <rlc_mac_main+0x20fb>
		SV(countRecvFromLower)++;
    618f:	8b 83 94 5a 00 00    	mov    0x5a94(%ebx),%eax
    6195:	83 c0 01             	add    $0x1,%eax
    6198:	89 83 94 5a 00 00    	mov    %eax,0x5a94(%ebx)
		printk("UE RLC_MAC RECV FROM LOER=%d\n",SV(countRecvFromLower));
    619e:	89 44 24 04          	mov    %eax,0x4(%esp)
    61a2:	c7 04 24 5e 04 00 00 	movl   $0x45e,(%esp)
    61a9:	e8 fc ff ff ff       	call   61aa <rlc_mac_main+0x211a>
		decomplexUeDataPdu(fsm_pkt_get());
    61ae:	e8 fc ff ff ff       	call   61af <rlc_mac_main+0x211f>
    61b3:	e8 fc ff ff ff       	call   61b4 <rlc_mac_main+0x2124>
    61b8:	e9 4b e1 ff ff       	jmp    4308 <rlc_mac_main+0x278>
	}
	else if(RLC_EV_SELF)				// /
	{
		if(!(insPtr = findInsByCode(fsm_ev_code(), &SV(timerType))))
		{
			printk("[RLC][rlc_interupt] the instance of this code is NULL\n");
    61bd:	c7 04 24 b0 1d 00 00 	movl   $0x1db0,(%esp)
    61c4:	e8 fc ff ff ff       	call   61c5 <rlc_mac_main+0x2135>
    61c9:	e9 3a e1 ff ff       	jmp    4308 <rlc_mac_main+0x278>
			umRxIns = (UM_RX_Instance *) insPtr;
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    61ce:	0f bf 83 bc 10 00 00 	movswl 0x10bc(%ebx),%eax
    61d5:	b9 20 00 00 00       	mov    $0x20,%ecx
    61da:	83 c0 01             	add    $0x1,%eax
    61dd:	89 c2                	mov    %eax,%edx
    61df:	c1 fa 1f             	sar    $0x1f,%edx
    61e2:	f7 f9                	idiv   %ecx
    61e4:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
    61eb:	eb 1a                	jmp    6207 <rlc_mac_main+0x2177>
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    61ed:	66 3b 83 be 10 00 00 	cmp    0x10be(%ebx),%ax
    61f4:	7f 22                	jg     6218 <rlc_mac_main+0x2188>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
    61f6:	8d 42 01             	lea    0x1(%edx),%eax
    61f9:	89 c2                	mov    %eax,%edx
    61fb:	c1 fa 1f             	sar    $0x1f,%edx
    61fe:	f7 f9                	idiv   %ecx
    6200:	66 89 93 bc 10 00 00 	mov    %dx,0x10bc(%ebx)
			umRxIns->reorderTimer = 0;
			fsm_printf("[RLC][rlc_interupt] UM_REORDER timeout (rbid is %d)\n", umRxIns->rbId);
			if(umRxIns->snFiledLength == 5)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL) && (umRxIns->vr_ur <= umRxIns->vr_ux))
    6207:	0f b7 83 bc 10 00 00 	movzwl 0x10bc(%ebx),%eax
    620e:	0f bf d0             	movswl %ax,%edx
    6211:	83 7c 93 38 00       	cmpl   $0x0,0x38(%ebx,%edx,4)
    6216:	75 d5                	jne    61ed <rlc_mac_main+0x215d>
				{
					umRxIns->vr_ur = (umRxIns->vr_ur+1)%(UM_WINDOW_SIZE5*2);
				}
				rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    6218:	8d 53 18             	lea    0x18(%ebx),%edx
    621b:	89 d8                	mov    %ebx,%eax
    621d:	e8 fc ff ff ff       	call   621e <rlc_mac_main+0x218e>
    6222:	e9 47 fb ff ff       	jmp    5d6e <rlc_mac_main+0x1cde>
		}
		reports_handler();//BSR PHR 
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    6227:	c7 04 24 a8 14 00 00 	movl   $0x14a8,(%esp)
    622e:	e8 fc ff ff ff       	call   622f <rlc_mac_main+0x219f>
				//FSM_CASE_TRANSIT(2, ST_IDLE, print_tran_info("reset IDLE -> IDLE"), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(2, ST_IDLE, ue_mac_reset(), "IDLE -> IDLE")
				FSM_CASE_TRANSIT(3,ST_SUSPEND_IDLE,  ,"IDLE-> SUSPEND_IDLE")	//modify status in 20150826
				FSM_CASE_TRANSIT(4,ST_NULL_IDLE,  , "IDLE-> NULL_IDLE")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_IDLE,idle_default_handler() , "IDLE->IDLE")	//transit to idle state	by default.
    6233:	e9 28 e0 ff ff       	jmp    4260 <rlc_mac_main+0x1d0>
			case IOCCMD_RLCtoMAC_datasend_Req ://20150106MSG3MSG4
			//data request
				fsm_printf("[UE MAC]cra_default_handler:IOCCMD_RLCtoMAC_datasend_Req\n");
				if(SV(sendmsg3) && SV(C_RNTI) )//msg3 
				{
					tmpdata_ptr = (char *)fsm_data_get();
    6238:	e8 fc ff ff ff       	call   6239 <rlc_mac_main+0x21a9>
    623d:	89 c7                	mov    %eax,%edi
					tmpdata = *((u32*)tmpdata_ptr);//	
					DoRefreshRLCBuffserRequest(RlcRequest_arraytolist((RLC_Request *)(tmpdata_ptr+sizeof(u32)),tmpdata));//
    623f:	8b 17                	mov    (%edi),%edx
    6241:	8d 40 04             	lea    0x4(%eax),%eax
    6244:	e8 fc ff ff ff       	call   6245 <rlc_mac_main+0x21b5>
    6249:	e8 fc ff ff ff       	call   624a <rlc_mac_main+0x21ba>
					//tmpdata_ptr+sizeof(int)//4 
					fsm_data_destroy((void *)tmpdata_ptr);//
    624e:	89 f8                	mov    %edi,%eax
    6250:	e8 fc ff ff ff       	call   6251 <rlc_mac_main+0x21c1>
					if(SV(LCGZeroToData)== true)//HQ201407040 regularBSR
    6255:	80 bb 58 01 00 00 00 	cmpb   $0x0,0x158(%ebx)
    625c:	74 05                	je     6263 <rlc_mac_main+0x21d3>
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
    625e:	e8 fc ff ff ff       	call   625f <rlc_mac_main+0x21cf>
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    6263:	8b 83 e4 01 00 00    	mov    0x1e4(%ebx),%eax
						DoProduceBsr_LCGZeroToData();//SV(LCGZeroToData)false	 	 
					//cra_success();//
					//IOCTL

					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
    6269:	c6 43 04 00          	movb   $0x0,0x4(%ebx)
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
    626d:	c6 43 05 00          	movb   $0x0,0x5(%ebx)
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
    6271:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
					if(SV(msg3_buf_ptr) != NULL)
    6278:	85 c0                	test   %eax,%eax
					/*************/
					SV(RA_info.ra_PreambleIndex) = 0;	//ra_preamble index ra_prach_mask_index
					SV(RA_info.ra_PRACHMaskIndex) = 0; 
					SV(PREAMBLE_TRANSMISSION_COUNTER) = 0;//0
					cleanharqBuff();//HARQmsg3
					SV(ra_allocation_res)=0;
    627a:	c7 83 f8 01 00 00 00 	movl   $0x0,0x1f8(%ebx)
    6281:	00 00 00 
					if(SV(msg3_buf_ptr) != NULL)
    6284:	74 0f                	je     6295 <rlc_mac_main+0x2205>
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
    6286:	e8 fc ff ff ff       	call   6287 <rlc_mac_main+0x21f7>
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
    628b:	c7 83 e4 01 00 00 00 	movl   $0x0,0x1e4(%ebx)
    6292:	00 00 00 
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
					if(SV(CRTimer.flag)==true) //CR
    6295:	80 bb 74 01 00 00 00 	cmpb   $0x0,0x174(%ebx)
					if(SV(msg3_buf_ptr) != NULL)
					{
						fsm_pkt_destroy(SV(msg3_buf_ptr));//modified by lhl 20140717
						SV(msg3_buf_ptr) = NULL; //msg3sk_buf
					}
					SV(T_C_RNTI) = 0;//T_C_RNTI
    629c:	66 c7 43 02 00 00    	movw   $0x0,0x2(%ebx)
					if(SV(CRTimer.flag)==true) //CR
    62a2:	74 1b                	je     62bf <rlc_mac_main+0x222f>
					{
						SV(CRTimer.timer_sign)= NULL;
    62a4:	c7 83 70 01 00 00 00 	movl   $0x0,0x170(%ebx)
    62ab:	00 00 00 
						SV(CRTimer.flag)= false;
    62ae:	c6 83 74 01 00 00 00 	movb   $0x0,0x174(%ebx)
						SV(CRTimer.time_value)=0;
    62b5:	c7 83 6c 01 00 00 00 	movl   $0x0,0x16c(%ebx)
    62bc:	00 00 00 
					}
					SV(sendmsg3)=0;//MSG30
    62bf:	c7 83 ec 01 00 00 00 	movl   $0x0,0x1ec(%ebx)
    62c6:	00 00 00 
					//SV(ratype.ra_type)=0;//0 
					SV(pdcch_rnti)=0;
    62c9:	c7 83 f0 01 00 00 00 	movl   $0x0,0x1f0(%ebx)
    62d0:	00 00 00 
					/*************/
					doStartContentionBasedRandomAccessProcedure();//20150106LHL
    62d3:	e8 98 cd ff ff       	call   3070 <doStartContentionBasedRandomAccessProcedure>
					SV(ratype.ra_type)=2;
    62d8:	c7 83 e8 01 00 00 02 	movl   $0x2,0x1e8(%ebx)
    62df:	00 00 00 
    62e2:	e9 c1 e1 ff ff       	jmp    44a8 <rlc_mac_main+0x418>
		print_tran_info("[UEMAC][con_default]CON default ioctl hander");//testing codes
		reports_handler();//BSR PHR cut to this domian 20150910
	}
	else
	{
		printk("[RLC][rlc_interupt] cannot distinguish the interrupt\n");
    62e7:	c7 04 24 a8 14 00 00 	movl   $0x14a8,(%esp)
    62ee:	e8 fc ff ff ff       	call   62ef <rlc_mac_main+0x225f>
				FSM_CASE_TRANSIT(2, ST_IDLE,ue_mac_reset(), "CON -> IDLE")

				FSM_CASE_TRANSIT(3,ST_SUSPEND,  ,"IDLE-> SUSPEND")
				FSM_CASE_TRANSIT(4,ST_NULL,  , "IDLE-> NULL")
				FSM_CASE_TRANSIT(5,ST_RLC_INIT,  , "IDLE-> RLC_INIT")
				FSM_CASE_DEFAULT(ST_CON,con_default_handler() , "CON -> CON")	//transit to CON state	by default.
    62f3:	e9 10 e0 ff ff       	jmp    4308 <rlc_mac_main+0x278>
		}
		FOUT;
	}
	else
	{
		SV(countDropPacket)++;
    62f8:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		fsm_printf("[RLC][skb_from_cra_to_con] no logic channel to transimmit this message\n");
    62ff:	c7 04 24 78 1c 00 00 	movl   $0x1c78,(%esp)
    6306:	e8 fc ff ff ff       	call   6307 <rlc_mac_main+0x2277>
		printk("[RLC][skb_from_cra_to_con] A packet has dropped, %d packets dropped\n", SV(countDropPacket));
    630b:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    6311:	c7 04 24 30 1c 00 00 	movl   $0x1c30,(%esp)
    6318:	89 44 24 04          	mov    %eax,0x4(%esp)
    631c:	e8 fc ff ff ff       	call   631d <rlc_mac_main+0x228d>
    6321:	e9 f9 e3 ff ff       	jmp    471f <rlc_mac_main+0x68f>
			break;

		case TM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    6326:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    6329:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    632d:	c7 04 24 38 1b 00 00 	movl   $0x1b38,(%esp)
    6334:	89 44 24 04          	mov    %eax,0x4(%esp)
    6338:	e8 fc ff ff ff       	call   6339 <rlc_mac_main+0x22a9>
    633d:	e9 dd e3 ff ff       	jmp    471f <rlc_mac_main+0x68f>
				break;
			}
			amIns = (AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][skb_from_cra_to_con][AM] am instance is suspended(rbid is %d)\n",amIns->rbId);
    6342:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    6346:	c7 04 24 6c 1a 00 00 	movl   $0x1a6c,(%esp)
    634d:	89 44 24 04          	mov    %eax,0x4(%esp)
    6351:	e8 fc ff ff ff       	call   6352 <rlc_mac_main+0x22c2>
    6356:	e9 c4 e3 ff ff       	jmp    471f <rlc_mac_main+0x68f>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][AM] rbid(%d) has no am instance \n",iciMsg->rbId);
    635b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    635e:	0f b6 42 01          	movzbl 0x1(%edx),%eax
    6362:	c7 04 24 2c 1a 00 00 	movl   $0x1a2c,(%esp)
    6369:	89 44 24 04          	mov    %eax,0x4(%esp)
    636d:	e8 fc ff ff ff       	call   636e <rlc_mac_main+0x22de>
    6372:	e9 a8 e3 ff ff       	jmp    471f <rlc_mac_main+0x68f>
			break;

		case UM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][skb_from_cra_to_con][UM] rbid (%d )has no um tran instance \n",iciMsg->rbId);
    6377:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    637a:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
    637e:	c7 04 24 38 1b 00 00 	movl   $0x1b38,(%esp)
    6385:	89 44 24 04          	mov    %eax,0x4(%esp)
    6389:	e8 fc ff ff ff       	call   638a <rlc_mac_main+0x22fa>
    638e:	e9 8c e3 ff ff       	jmp    471f <rlc_mac_main+0x68f>
    6393:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    6399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000063a0 <findInsBylcid>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void  findInsBylcid(u8 lcid, void **up, void**down, RlcMode *mode)
{
    63a0:	55                   	push   %ebp
    63a1:	89 e5                	mov    %esp,%ebp
    63a3:	57                   	push   %edi
    63a4:	56                   	push   %esi
    63a5:	53                   	push   %ebx
    63a6:	83 ec 10             	sub    $0x10,%esp
    63a9:	e8 fc ff ff ff       	call   63aa <findInsBylcid+0xa>
    63ae:	8b 75 08             	mov    0x8(%ebp),%esi
    63b1:	89 55 ec             	mov    %edx,-0x14(%ebp)
    63b4:	89 c3                	mov    %eax,%ebx
    63b6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
	struct  UM_TX_Instance *umTxIns;
	TM_RX_Instance *tmRxIns;
	TM_TX_Instance *tmTxIns;
	
	FIN(findInsBylcid());
	SV_PTR_GET(rlc_mac_sv);
    63b9:	e8 fc ff ff ff       	call   63ba <findInsBylcid+0x1a>
	*up = *down = NULL;
    63be:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    63c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    63c4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
    63ca:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*mode = 0;
    63d0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    63d6:	8b 90 2c 37 00 00    	mov    0x372c(%eax),%edx
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    63dc:	8d 88 2c 37 00 00    	lea    0x372c(%eax),%ecx
    63e2:	39 d1                	cmp    %edx,%ecx
    63e4:	74 29                	je     640f <findInsBylcid+0x6f>
    63e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    63e9:	8b 7d ec             	mov    -0x14(%ebp),%edi
    63ec:	eb 08                	jmp    63f6 <findInsBylcid+0x56>
    63ee:	66 90                	xchg   %ax,%ax
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    63f0:	8b 12                	mov    (%edx),%edx
    63f2:	39 d1                	cmp    %edx,%ecx
    63f4:	74 16                	je     640c <findInsBylcid+0x6c>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->lcId == lcid)
    63f6:	38 5a e7             	cmp    %bl,-0x19(%edx)
    63f9:	75 f5                	jne    63f0 <findInsBylcid+0x50>
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    63fb:	8d 42 e4             	lea    -0x1c(%edx),%eax
			if(tmTxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    63fe:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
    6404:	89 07                	mov    %eax,(%edi)
	SV_PTR_GET(rlc_mac_sv);
	*up = *down = NULL;
	*mode = 0;
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    6406:	8b 12                	mov    (%edx),%edx
    6408:	39 d1                	cmp    %edx,%ecx
    640a:	75 ea                	jne    63f6 <findInsBylcid+0x56>
    640c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    640f:	8b 90 08 37 00 00    	mov    0x3708(%eax),%edx
				*up =  (void*)tmTxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
    6415:	8d 88 08 37 00 00    	lea    0x3708(%eax),%ecx
    641b:	39 d1                	cmp    %edx,%ecx
    641d:	74 28                	je     6447 <findInsBylcid+0xa7>
    641f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6422:	8b 7d e8             	mov    -0x18(%ebp),%edi
    6425:	eb 07                	jmp    642e <findInsBylcid+0x8e>
    6427:	90                   	nop
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    6428:	8b 12                	mov    (%edx),%edx
    642a:	39 d1                	cmp    %edx,%ecx
    642c:	74 16                	je     6444 <findInsBylcid+0xa4>
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
			if(tmRxIns->lcId == lcid)
    642e:	38 5a fb             	cmp    %bl,-0x5(%edx)
    6431:	75 f5                	jne    6428 <findInsBylcid+0x88>
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    6433:	8d 42 f8             	lea    -0x8(%edx),%eax
			if(tmRxIns->lcId == lcid)
			{
				*mode = TM_MODE;
    6436:	c7 06 01 00 00 00    	movl   $0x1,(%esi)
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
		{
			tmRxIns = list_entry(pos,struct  TM_RX_Instance,tmRxList);
    643c:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if (!list_empty(&SV(vTm_rx_ins).tmRxList))
	{
		list_for_each(pos,&SV(vTm_rx_ins).tmRxList)
    643e:	8b 12                	mov    (%edx),%edx
    6440:	39 d1                	cmp    %edx,%ecx
    6442:	75 ea                	jne    642e <findInsBylcid+0x8e>
    6444:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*down =  (void*)tmRxIns;
				//fsm_printf("tm instance\n");
			}
		}
	}
	if(*mode == TM_MODE)
    6447:	83 3e 01             	cmpl   $0x1,(%esi)
    644a:	0f 84 c8 00 00 00    	je     6518 <findInsBylcid+0x178>
    6450:	8b 90 f8 36 00 00    	mov    0x36f8(%eax),%edx
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    6456:	8d 88 f8 36 00 00    	lea    0x36f8(%eax),%ecx
    645c:	39 d1                	cmp    %edx,%ecx
    645e:	74 27                	je     6487 <findInsBylcid+0xe7>
    6460:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6463:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6466:	eb 06                	jmp    646e <findInsBylcid+0xce>
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    6468:	8b 12                	mov    (%edx),%edx
    646a:	39 d1                	cmp    %edx,%ecx
    646c:	74 16                	je     6484 <findInsBylcid+0xe4>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->lcid == lcid)
    646e:	38 5a d3             	cmp    %bl,-0x2d(%edx)
    6471:	75 f5                	jne    6468 <findInsBylcid+0xc8>
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    6473:	8d 42 d0             	lea    -0x30(%edx),%eax
			if(umTxIns->lcid == lcid)
			{
				*mode = UM_MODE;
    6476:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
    647c:	89 07                	mov    %eax,(%edi)
	}
	if(*mode == TM_MODE)
		FOUT;
	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    647e:	8b 12                	mov    (%edx),%edx
    6480:	39 d1                	cmp    %edx,%ecx
    6482:	75 ea                	jne    646e <findInsBylcid+0xce>
    6484:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6487:	8b 90 c0 36 00 00    	mov    0x36c0(%eax),%edx
				*mode = UM_MODE;
				*up =  (void*)umTxIns;
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
    648d:	8d 88 c0 36 00 00    	lea    0x36c0(%eax),%ecx
    6493:	39 d1                	cmp    %edx,%ecx
    6495:	74 2e                	je     64c5 <findInsBylcid+0x125>
    6497:	89 45 f0             	mov    %eax,-0x10(%ebp)
    649a:	8b 7d e8             	mov    -0x18(%ebp),%edi
    649d:	eb 07                	jmp    64a6 <findInsBylcid+0x106>
    649f:	90                   	nop
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    64a0:	8b 12                	mov    (%edx),%edx
    64a2:	39 d1                	cmp    %edx,%ecx
    64a4:	74 1c                	je     64c2 <findInsBylcid+0x122>
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
			if(umRxIns->lcId == lcid)
    64a6:	38 9a 3f ef ff ff    	cmp    %bl,-0x10c1(%edx)
    64ac:	75 f2                	jne    64a0 <findInsBylcid+0x100>
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    64ae:	8d 82 3c ef ff ff    	lea    -0x10c4(%edx),%eax
			if(umRxIns->lcId == lcid)
			{
				*mode = UM_MODE;
    64b4:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
		{
			umRxIns = list_entry(pos,struct  UM_RX_Instance,umRxList);
    64ba:	89 07                	mov    %eax,(%edi)
			}
		}
	}
	if(!list_empty(&SV(vUm_rx_ins).umRxList))
	{
		list_for_each(pos,&SV(vUm_rx_ins).umRxList)
    64bc:	8b 12                	mov    (%edx),%edx
    64be:	39 d1                	cmp    %edx,%ecx
    64c0:	75 e4                	jne    64a6 <findInsBylcid+0x106>
    64c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
				*mode = UM_MODE;
				*down =  (void*)umRxIns;
			}
		}
	}
	if(*mode == UM_MODE)
    64c5:	83 3e 02             	cmpl   $0x2,(%esi)
    64c8:	74 4e                	je     6518 <findInsBylcid+0x178>
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
    64ca:	8d 90 f4 25 00 00    	lea    0x25f4(%eax),%edx
    64d0:	8b 80 f4 25 00 00    	mov    0x25f4(%eax),%eax
    64d6:	39 c2                	cmp    %eax,%edx
    64d8:	74 3e                	je     6518 <findInsBylcid+0x178>
    64da:	8b 7d e8             	mov    -0x18(%ebp),%edi
    64dd:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    64e0:	eb 0c                	jmp    64ee <findInsBylcid+0x14e>
    64e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    64e8:	8b 00                	mov    (%eax),%eax
    64ea:	39 c2                	cmp    %eax,%edx
    64ec:	74 2a                	je     6518 <findInsBylcid+0x178>
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->lcId == lcid)
    64ee:	38 98 ff dc ff ff    	cmp    %bl,-0x2301(%eax)
    64f4:	75 f2                	jne    64e8 <findInsBylcid+0x148>
			{
				*mode = AM_MODE;
    64f6:	8b 75 e4             	mov    -0x1c(%ebp),%esi
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    64f9:	8d 88 fc dc ff ff    	lea    -0x2304(%eax),%ecx
			if(amIns->lcId == lcid)
			{
				*mode = AM_MODE;
    64ff:	c7 06 03 00 00 00    	movl   $0x3,(%esi)
				*up = *down =  (void*)amIns;
    6505:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6508:	89 0f                	mov    %ecx,(%edi)
    650a:	89 0e                	mov    %ecx,(%esi)
	}
	if(*mode == UM_MODE)
		FOUT;
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    650c:	8b 00                	mov    (%eax),%eax
    650e:	39 c2                	cmp    %eax,%edx
    6510:	75 dc                	jne    64ee <findInsBylcid+0x14e>
    6512:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				//      fsm_printf("am instance(lcid is %d)\n",lcid);
			}
		}
	}
	FOUT;
}
    6518:	83 c4 10             	add    $0x10,%esp
    651b:	5b                   	pop    %ebx
    651c:	5e                   	pop    %esi
    651d:	5f                   	pop    %edi
    651e:	5d                   	pop    %ebp
    651f:	c3                   	ret    

00006520 <isInsideTranWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideTranWin(struct AM_Instance *amIns, SequenceNumber SN)
{
    6520:	55                   	push   %ebp
    6521:	89 e5                	mov    %esp,%ebp
    6523:	53                   	push   %ebx
    6524:	e8 fc ff ff ff       	call   6525 <isInsideTranWin+0x5>
	//printk("[RLC][isInsideTranWin] vt_a=%d, vt_ms=%d, SN=%d\n",amIns->vt_a, amIns->vt_ms, SN);
	//return((amIns->vt_a <= SN)&&(SN < amIns->vt_ms));
	return (SN-amIns->vt_a+1024)%1024 < (amIns->vt_ms-amIns->vt_a+1024)%1024;
    6529:	0f bf 98 66 12 00 00 	movswl 0x1266(%eax),%ebx
    6530:	0f bf 80 68 12 00 00 	movswl 0x1268(%eax),%eax
    6537:	0f bf d2             	movswl %dx,%edx
    653a:	29 da                	sub    %ebx,%edx
    653c:	81 c2 00 04 00 00    	add    $0x400,%edx
    6542:	29 d8                	sub    %ebx,%eax
    6544:	89 d1                	mov    %edx,%ecx
    6546:	05 00 04 00 00       	add    $0x400,%eax
    654b:	c1 f9 1f             	sar    $0x1f,%ecx
    654e:	c1 e9 16             	shr    $0x16,%ecx
    6551:	01 ca                	add    %ecx,%edx
    6553:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6559:	29 ca                	sub    %ecx,%edx
    655b:	89 c1                	mov    %eax,%ecx
    655d:	c1 f9 1f             	sar    $0x1f,%ecx
    6560:	c1 e9 16             	shr    $0x16,%ecx
    6563:	01 c8                	add    %ecx,%eax
    6565:	25 ff 03 00 00       	and    $0x3ff,%eax
    656a:	29 c8                	sub    %ecx,%eax
    656c:	39 c2                	cmp    %eax,%edx
    656e:	0f 9c c0             	setl   %al
}
    6571:	5b                   	pop    %ebx
    6572:	5d                   	pop    %ebp
    6573:	c3                   	ret    
    6574:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    657a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00006580 <isInsideAmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    6580:	55                   	push   %ebp
    6581:	89 e5                	mov    %esp,%ebp
    6583:	56                   	push   %esi
    6584:	53                   	push   %ebx
    6585:	83 ec 14             	sub    $0x14,%esp
    6588:	e8 fc ff ff ff       	call   6589 <isInsideAmRecvWin+0x9>
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    658d:	0f bf 88 ec 22 00 00 	movswl 0x22ec(%eax),%ecx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideAmRecvWin(struct AM_Instance * amIns, SequenceNumber SN)
{
    6594:	89 c3                	mov    %eax,%ebx
	/*SequenceNumber upper,upperMode;
	upper = amIns->vr_r + 512;
	upperMode = upper % 1024;
	//fsm_printf("[RLC][isInsideAmRecvWin] the upper is %d, upperMode is %d\n",upper, upperMode);
	return(((amIns->vr_r <= SN)&&(SN < upper))||(((upperMode - 512) < SN )&&(SN < upperMode)));*/
	printk("[RLC][isInsideAmRecvWin] vr_r=%d, vr_mr=%d, SN=%d, mr-r = %d\n",amIns->vr_r, amIns->vr_mr, SN,amIns->vr_mr-amIns->vr_r);
    6596:	0f bf 80 f4 22 00 00 	movswl 0x22f4(%eax),%eax
    659d:	0f bf f2             	movswl %dx,%esi
    65a0:	89 ca                	mov    %ecx,%edx
    65a2:	89 74 24 0c          	mov    %esi,0xc(%esp)
    65a6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    65aa:	29 c2                	sub    %eax,%edx
    65ac:	89 54 24 10          	mov    %edx,0x10(%esp)
    65b0:	89 44 24 04          	mov    %eax,0x4(%esp)
    65b4:	c7 04 24 18 1e 00 00 	movl   $0x1e18,(%esp)
    65bb:	e8 fc ff ff ff       	call   65bc <isInsideAmRecvWin+0x3c>
	return (SN-amIns->vr_r+1024)%1024 < (amIns->vr_mr-amIns->vr_r+1024)%1024;
    65c0:	0f bf 93 f4 22 00 00 	movswl 0x22f4(%ebx),%edx
    65c7:	29 d6                	sub    %edx,%esi
    65c9:	81 c6 00 04 00 00    	add    $0x400,%esi
    65cf:	89 f0                	mov    %esi,%eax
    65d1:	c1 f8 1f             	sar    $0x1f,%eax
    65d4:	c1 e8 16             	shr    $0x16,%eax
    65d7:	01 c6                	add    %eax,%esi
    65d9:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    65df:	29 c6                	sub    %eax,%esi
    65e1:	0f bf 83 ec 22 00 00 	movswl 0x22ec(%ebx),%eax
    65e8:	29 d0                	sub    %edx,%eax
    65ea:	05 00 04 00 00       	add    $0x400,%eax
    65ef:	89 c2                	mov    %eax,%edx
    65f1:	c1 fa 1f             	sar    $0x1f,%edx
    65f4:	c1 ea 16             	shr    $0x16,%edx
    65f7:	01 d0                	add    %edx,%eax
    65f9:	25 ff 03 00 00       	and    $0x3ff,%eax
    65fe:	29 d0                	sub    %edx,%eax
    6600:	39 c6                	cmp    %eax,%esi
    6602:	0f 9c c0             	setl   %al
}
    6605:	83 c4 14             	add    $0x14,%esp
    6608:	5b                   	pop    %ebx
    6609:	5e                   	pop    %esi
    660a:	5d                   	pop    %ebp
    660b:	c3                   	ret    
    660c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006610 <isInsideUmRecvWin>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6610:	55                   	push   %ebp
    6611:	89 e5                	mov    %esp,%ebp
    6613:	e8 fc ff ff ff       	call   6614 <isInsideUmRecvWin+0x4>
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6618:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    661d:	0f bf 80 c0 10 00 00 	movswl 0x10c0(%eax),%eax
    6624:	0f bf d2             	movswl %dx,%edx
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    6627:	74 27                	je     6650 <isInsideUmRecvWin+0x40>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    6629:	29 c2                	sub    %eax,%edx
    662b:	81 c2 00 06 00 00    	add    $0x600,%edx
    6631:	89 d0                	mov    %edx,%eax
    6633:	c1 f8 1f             	sar    $0x1f,%eax
    6636:	c1 e8 16             	shr    $0x16,%eax
    6639:	01 c2                	add    %eax,%edx
    663b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    6641:	29 c2                	sub    %eax,%edx
    6643:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    6649:	0f 9e c0             	setle  %al
	}
}
    664c:	5d                   	pop    %ebp
    664d:	c3                   	ret    
    664e:	66 90                	xchg   %ax,%ax
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    6650:	29 c2                	sub    %eax,%edx
    6652:	83 c2 30             	add    $0x30,%edx
    6655:	89 d0                	mov    %edx,%eax
    6657:	c1 f8 1f             	sar    $0x1f,%eax
    665a:	c1 e8 1b             	shr    $0x1b,%eax
    665d:	01 c2                	add    %eax,%edx
    665f:	83 e2 1f             	and    $0x1f,%edx
    6662:	29 c2                	sub    %eax,%edx
    6664:	83 fa 0f             	cmp    $0xf,%edx
    6667:	0f 9e c0             	setle  %al
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
	}
}
    666a:	5d                   	pop    %ebp
    666b:	c3                   	ret    
    666c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00006670 <isOrderedUm>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
bool isOrderedUm(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
    6670:	55                   	push   %ebp
    6671:	89 e5                	mov    %esp,%ebp
    6673:	53                   	push   %ebx
    6674:	e8 fc ff ff ff       	call   6675 <isOrderedUm+0x5>
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6679:	66 83 78 06 05       	cmpw   $0x5,0x6(%eax)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    667e:	0f bf 98 c0 10 00 00 	movswl 0x10c0(%eax),%ebx
	{
		base = umRxIns->vr_uh - 512;
	}
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
    6685:	74 51                	je     66d8 <isOrderedUm+0x68>
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
	}
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
    6687:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    668e:	b9 00 02 00 00       	mov    $0x200,%ecx
    6693:	0f bf d2             	movswl %dx,%edx
    6696:	29 d9                	sub    %ebx,%ecx
    6698:	8d 94 11 00 04 00 00 	lea    0x400(%ecx,%edx,1),%edx
    669f:	89 d3                	mov    %edx,%ebx
    66a1:	8d 84 01 00 04 00 00 	lea    0x400(%ecx,%eax,1),%eax
    66a8:	89 c1                	mov    %eax,%ecx
    66aa:	c1 fb 1f             	sar    $0x1f,%ebx
    66ad:	c1 f9 1f             	sar    $0x1f,%ecx
    66b0:	c1 eb 16             	shr    $0x16,%ebx
    66b3:	c1 e9 16             	shr    $0x16,%ecx
    66b6:	01 da                	add    %ebx,%edx
    66b8:	01 c8                	add    %ecx,%eax
    66ba:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    66c0:	25 ff 03 00 00       	and    $0x3ff,%eax
    66c5:	29 da                	sub    %ebx,%edx
    66c7:	29 c8                	sub    %ecx,%eax
    66c9:	39 c2                	cmp    %eax,%edx
    66cb:	0f 9c c0             	setl   %al
	}
}
    66ce:	5b                   	pop    %ebx
    66cf:	5d                   	pop    %ebp
    66d0:	c3                   	ret    
    66d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    66d8:	0f bf 80 bc 10 00 00 	movswl 0x10bc(%eax),%eax
    66df:	b9 10 00 00 00       	mov    $0x10,%ecx
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    66e4:	0f bf d2             	movswl %dx,%edx
	return ((base <= SN )&&(SN < umRxIns->vr_uh));*/
	//printk("[RLC][isOrderedUm] SN = %d, vr_uh = %d, vr_ur = %d\n",SN,umRxIns->vr_uh,umRxIns->vr_ur);
	if(umRxIns->snFiledLength == 5)
	{
		//return ((umRxIns->vr_uh <= SN + 16 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-16)+32)%32 < (umRxIns->vr_ur-(umRxIns->vr_uh-16)+32)%32;
    66e7:	29 d9                	sub    %ebx,%ecx
    66e9:	8d 54 11 20          	lea    0x20(%ecx,%edx,1),%edx
    66ed:	89 d3                	mov    %edx,%ebx
    66ef:	8d 44 01 20          	lea    0x20(%ecx,%eax,1),%eax
    66f3:	89 c1                	mov    %eax,%ecx
    66f5:	c1 fb 1f             	sar    $0x1f,%ebx
    66f8:	c1 f9 1f             	sar    $0x1f,%ecx
    66fb:	c1 eb 1b             	shr    $0x1b,%ebx
    66fe:	c1 e9 1b             	shr    $0x1b,%ecx
    6701:	01 da                	add    %ebx,%edx
    6703:	01 c8                	add    %ecx,%eax
    6705:	83 e2 1f             	and    $0x1f,%edx
    6708:	83 e0 1f             	and    $0x1f,%eax
    670b:	29 da                	sub    %ebx,%edx
    670d:	29 c8                	sub    %ecx,%eax
    670f:	39 c2                	cmp    %eax,%edx
    6711:	0f 9c c0             	setl   %al
	else
	{
		//return ((umRxIns->vr_uh <= SN + 512 )&&(SN < umRxIns->vr_ur));
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < (umRxIns->vr_ur-(umRxIns->vr_uh-512)+1024)%1024;
	}
}
    6714:	5b                   	pop    %ebx
    6715:	5d                   	pop    %ebp
    6716:	c3                   	ret    
    6717:	89 f6                	mov    %esi,%esi
    6719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00006720 <countSegInd>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
    6720:	55                   	push   %ebp
    6721:	89 e5                	mov    %esp,%ebp
    6723:	e8 fc ff ff ff       	call   6724 <countSegInd+0x4>
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6728:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    672e:	31 c0                	xor    %eax,%eax
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    6730:	f6 42 01 04          	testb  $0x4,0x1(%edx)
    6734:	74 20                	je     6756 <countSegInd+0x36>
	{
		count++;
		while(1 == (ind++)->E)
    6736:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
    673a:	b0 01                	mov    $0x1,%al
    673c:	79 18                	jns    6756 <countSegInd+0x36>
    673e:	83 c2 06             	add    $0x6,%edx
    6741:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    6748:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
		{
			count++;
    674c:	83 c0 01             	add    $0x1,%eax
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    674f:	83 c2 02             	add    $0x2,%edx
    6752:	84 c9                	test   %cl,%cl
    6754:	78 f2                	js     6748 <countSegInd+0x28>
		{
			count++;
		}
	}
	return count;
}
    6756:	5d                   	pop    %ebp
    6757:	c3                   	ret    
    6758:	90                   	nop
    6759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006760 <assamble_segment>:
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6760:	55                   	push   %ebp
    6761:	89 e5                	mov    %esp,%ebp
    6763:	57                   	push   %edi
    6764:	56                   	push   %esi
    6765:	53                   	push   %ebx
    6766:	83 ec 20             	sub    $0x20,%esp
    6769:	e8 fc ff ff ff       	call   676a <assamble_segment+0xa>
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    676e:	8b 9a ac 00 00 00    	mov    0xac(%edx),%ebx
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6774:	89 c6                	mov    %eax,%esi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6776:	8b 00                	mov    (%eax),%eax
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
{
    6778:	89 55 ec             	mov    %edx,-0x14(%ebp)
	FSM_PKT *pkptr;
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
    677b:	89 5d f0             	mov    %ebx,-0x10(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    677e:	c7 45 e8 04 00 00 00 	movl   $0x4,-0x18(%ebp)
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    6785:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    678b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    678e:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    6792:	74 34                	je     67c8 <assamble_segment+0x68>
	{
		count++;
		while(1 == (ind++)->E)
    6794:	c7 45 e8 06 00 00 00 	movl   $0x6,-0x18(%ebp)
    679b:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    679f:	79 27                	jns    67c8 <assamble_segment+0x68>
    67a1:	83 c0 06             	add    $0x6,%eax
    67a4:	ba 01 00 00 00       	mov    $0x1,%edx
    67a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    67b0:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    67b4:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    67b7:	83 c0 02             	add    $0x2,%eax
    67ba:	84 c9                	test   %cl,%cl
    67bc:	78 f2                	js     67b0 <assamble_segment+0x50>
    67be:	8d 54 12 04          	lea    0x4(%edx,%edx,1),%edx
    67c2:	0f b7 d2             	movzwl %dx,%edx
    67c5:	89 55 e8             	mov    %edx,-0x18(%ebp)
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    67c8:	8b 7d f0             	mov    -0x10(%ebp),%edi
	u32 posEnd = posStart + pkt->len - headLen;
    67cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    67ce:	0f b6 5f 03          	movzbl 0x3(%edi),%ebx
    67d2:	0f b6 47 02          	movzbl 0x2(%edi),%eax
	u32 posEnd = posStart + pkt->len - headLen;
    67d6:	8b 4a 50             	mov    0x50(%edx),%ecx
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    67d9:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
	struct RLC_AMPDU_fixhead *fixhead;
	fixhead=(RLC_AMPDU_fixhead* )pkt->data;
	RLC_AMPDU_seg_exthead* exthead = (RLC_AMPDU_seg_exthead* )(pkt->data+sizeof(RLC_AMPDU_fixhead));
	// fsm_printf("the count of this segment is %d\n", countSegInd(pkt));
	u16 headLen = 4 + 2*countSegInd(ambuf->pkt);
	u32 posStart  =  exthead->SO;
    67df:	83 e3 7f             	and    $0x7f,%ebx
    67e2:	c1 e3 08             	shl    $0x8,%ebx
    67e5:	09 c3                	or     %eax,%ebx
	u32 posEnd = posStart + pkt->len - headLen;
    67e7:	8d 3c 0b             	lea    (%ebx,%ecx,1),%edi
    67ea:	89 7d e0             	mov    %edi,-0x20(%ebp)
    67ed:	2b 7d e8             	sub    -0x18(%ebp),%edi
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    67f0:	85 d2                	test   %edx,%edx
    67f2:	74 1b                	je     680f <assamble_segment+0xaf>
    67f4:	31 c0                	xor    %eax,%eax
    67f6:	66 90                	xchg   %ax,%ax
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
    67f8:	3b 5c 86 10          	cmp    0x10(%esi,%eax,4),%ebx
    67fc:	72 0a                	jb     6808 <assamble_segment+0xa8>
    67fe:	3b 7c 86 50          	cmp    0x50(%esi,%eax,4),%edi
    6802:	0f 86 50 01 00 00    	jbe    6958 <assamble_segment+0x1f8>
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
	//fsm_printf("[RLC][assamble_segment] the buffer data is %s\n", posbuf);

	for(i = 0; i < ambuf->segnum; i++)
    6808:	83 c0 01             	add    $0x1,%eax
    680b:	39 d0                	cmp    %edx,%eax
    680d:	75 e9                	jne    67f8 <assamble_segment+0x98>
	char *posbuf = (char*)ambuf->pkt->data;
	int i, j,datalen = 0;
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
    680f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6812:	03 45 e8             	add    -0x18(%ebp),%eax
    6815:	89 45 d8             	mov    %eax,-0x28(%ebp)
	}
	//fsm_printf("[RLC][assamble_segment] ambuf->datalen is %d\n",ambuf->datalen);
	//fsm_printf("[RLC][assamble_segment] ambuf->segEnd[ambuf->segnum - 1] is %d\n",ambuf->segEnd[ambuf->segnum - 1]);
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
    6818:	8d 42 ff             	lea    -0x1(%edx),%eax
    681b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    681e:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6822:	39 c7                	cmp    %eax,%edi
    6824:	0f 82 3e 01 00 00    	jb     6968 <assamble_segment+0x208>
	//
	else
	{
		//fsm_printf("[RLC][assamble_segment] have not received the last segment\n");
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
    682a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    682d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6831:	78 6d                	js     68a0 <assamble_segment+0x140>
    6833:	39 c7                	cmp    %eax,%edi
    6835:	77 69                	ja     68a0 <assamble_segment+0x140>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
		ambuf->datalen = datalen;
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6837:	39 c3                	cmp    %eax,%ebx
    6839:	0f 87 f9 00 00 00    	ja     6938 <assamble_segment+0x1d8>
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    683f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6842:	85 d2                	test   %edx,%edx
    6844:	7e 3b                	jle    6881 <assamble_segment+0x121>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6846:	8d 44 96 10          	lea    0x10(%esi,%edx,4),%eax
    684a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
			{
				//10:
				if((ambuf->segStart[i] <= posStart)&&(posStart <= ambuf->segEnd[i]))
    6850:	8b 08                	mov    (%eax),%ecx
    6852:	39 cb                	cmp    %ecx,%ebx
    6854:	72 09                	jb     685f <assamble_segment+0xff>
    6856:	3b 58 40             	cmp    0x40(%eax),%ebx
    6859:	0f 86 5f 02 00 00    	jbe    6abe <assamble_segment+0x35e>
					ambuf->segEnd[i] = posEnd;
					ambuf->segnum = i + 1;
					FOUT;
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
    685f:	3b 58 3c             	cmp    0x3c(%eax),%ebx
    6862:	76 08                	jbe    686c <assamble_segment+0x10c>
    6864:	39 cb                	cmp    %ecx,%ebx
    6866:	0f 86 4e 02 00 00    	jbe    6aba <assamble_segment+0x35a>
					ambuf->segnum = i + 1;
					FOUT;
				}
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
    686c:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
    6873:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
			ambuf->segnum++;
			FOUT;
		}
		else
		{
			for(i = ambuf->segnum - 1; i >0 ; --i)
    6879:	83 e8 04             	sub    $0x4,%eax
    687c:	83 ea 01             	sub    $0x1,%edx
    687f:	75 cf                	jne    6850 <assamble_segment+0xf0>
				else
				{
					ambuf->segStart[i] = ambuf->segEnd[i] = -1;
				}
			}
			if(posStart > ambuf->segStart[0])
    6881:	3b 5e 10             	cmp    0x10(%esi),%ebx
    6884:	77 03                	ja     6889 <assamble_segment+0x129>
				ambuf->segnum = 1;
				FOUT;
			}
            else
            {
	            ambuf->segStart[0]  = posStart;
    6886:	89 5e 10             	mov    %ebx,0x10(%esi)
	            ambuf->segEnd[0] = posEnd;
    6889:	89 7e 50             	mov    %edi,0x50(%esi)
	            ambuf->segnum = 1;
    688c:	c7 86 90 00 00 00 01 	movl   $0x1,0x90(%esi)
    6893:	00 00 00 
	            FOUT;
			}
		}
	}
}
    6896:	83 c4 20             	add    $0x20,%esp
    6899:	5b                   	pop    %ebx
    689a:	5e                   	pop    %esi
    689b:	5f                   	pop    %edi
    689c:	5d                   	pop    %ebp
    689d:	c3                   	ret    
    689e:	66 90                	xchg   %ax,%ax
		//
		if((exthead->LSF == 1)||(ambuf->segEnd[ambuf->segnum - 1] < posEnd))
		{
			//pdu
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    68a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    68a3:	e8 fc ff ff ff       	call   68a4 <assamble_segment+0x144>
    68a8:	03 45 e0             	add    -0x20(%ebp),%eax
    68ab:	e8 fc ff ff ff       	call   68ac <assamble_segment+0x14c>
    68b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
    68b3:	8b 06                	mov    (%esi),%eax
    68b5:	8b 48 50             	mov    0x50(%eax),%ecx
    68b8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    68be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    68c1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    68c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    68ca:	e8 fc ff ff ff       	call   68cb <assamble_segment+0x16b>
			fsm_skb_put(pkptr, datalen);
    68cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
    68d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    68d5:	e8 fc ff ff ff       	call   68d6 <assamble_segment+0x176>
			fsm_pkt_destroy(ambuf->pkt);
    68da:	8b 06                	mov    (%esi),%eax
    68dc:	e8 fc ff ff ff       	call   68dd <assamble_segment+0x17d>
			ambuf->pkt = pkptr;
    68e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    68e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
			datalen = pkt->len + exthead->SO;
			pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
			fsm_mem_cpy(pkptr->data, ambuf->pkt->data, ambuf->pkt->len);
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
    68e7:	89 06                	mov    %eax,(%esi)
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    68e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    68ec:	8b 4a 50             	mov    0x50(%edx),%ecx
			fsm_skb_put(pkptr, datalen);
			fsm_pkt_destroy(ambuf->pkt);
			ambuf->pkt = pkptr;
			//pdupdu
			posbuf = (char*)pkptr->data;
			posbuf = posbuf + headLen + posStart;
    68ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    68f2:	01 d8                	add    %ebx,%eax
    68f4:	03 82 ac 00 00 00    	add    0xac(%edx),%eax
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
    68fa:	8b 55 d8             	mov    -0x28(%ebp),%edx
    68fd:	e8 fc ff ff ff       	call   68fe <assamble_segment+0x19e>
			fsm_pkt_destroy(pkt);
    6902:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6905:	e8 fc ff ff ff       	call   6906 <assamble_segment+0x1a6>
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    690a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    690d:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    6911:	0f 89 bc 01 00 00    	jns    6ad3 <assamble_segment+0x373>
		ambuf->datalen = datalen;
    6917:	8b 55 e0             	mov    -0x20(%ebp),%edx
    691a:	89 96 98 00 00 00    	mov    %edx,0x98(%esi)
    6920:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6926:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    692a:	8d 4a ff             	lea    -0x1(%edx),%ecx
    692d:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		//
		if(ambuf->segEnd[ambuf->segnum -1] < posStart)
    6930:	39 c3                	cmp    %eax,%ebx
    6932:	0f 86 07 ff ff ff    	jbe    683f <assamble_segment+0xdf>
		{
			ambuf->segEnd[ambuf->segnum] = posEnd;
    6938:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
			ambuf->segStart[ambuf->segnum]  = posStart;
    693c:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
			ambuf->segnum++;
    6940:	83 c2 01             	add    $0x1,%edx
    6943:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6949:	83 c4 20             	add    $0x20,%esp
    694c:	5b                   	pop    %ebx
    694d:	5e                   	pop    %esi
    694e:	5f                   	pop    %edi
    694f:	5d                   	pop    %ebp
    6950:	c3                   	ret    
    6951:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		//
		if((ambuf->segStart[i] <= posStart) &&(posEnd <= ambuf->segEnd[i] ))
		{
			//fsm_printf("[RLC][assamble_segment] this segment has been received\n");
			fsm_pkt_destroy(pkt);
    6958:	8b 45 ec             	mov    -0x14(%ebp),%eax
    695b:	e8 fc ff ff ff       	call   695c <assamble_segment+0x1fc>
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6960:	83 c4 20             	add    $0x20,%esp
    6963:	5b                   	pop    %ebx
    6964:	5e                   	pop    %esi
    6965:	5f                   	pop    %edi
    6966:	5d                   	pop    %ebp
    6967:	c3                   	ret    
	u16 flag = 0;
	
	
	pospkt = pospkt + headLen;
	//fsm_printf("[RLC][assamble_segment] the packet data is %s\n", pospkt);
	posbuf = posbuf + headLen;
    6968:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    696b:	03 45 e8             	add    -0x18(%ebp),%eax
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    696e:	8b 55 d8             	mov    -0x28(%ebp),%edx
	//fsm_printf("[RLC][assamble_segment] posEnd is %d\n",posEnd);
	//if((ambuf->datalen)||(ambuf->segEnd[ambuf->segnum - 1] > posEnd))
	if(ambuf->segEnd[ambuf->segnum - 1] > posEnd)
	{
		//buffer
		posbuf = posbuf + posStart;
    6971:	01 d8                	add    %ebx,%eax
		fsm_mem_cpy(posbuf, pospkt, pkt->len);
    6973:	e8 fc ff ff ff       	call   6974 <assamble_segment+0x214>
		fsm_pkt_destroy(pkt);
    6978:	8b 45 ec             	mov    -0x14(%ebp),%eax
    697b:	e8 fc ff ff ff       	call   697c <assamble_segment+0x21c>
		pkt = NULL;
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
    6980:	8b 46 10             	mov    0x10(%esi),%eax
    6983:	85 c0                	test   %eax,%eax
    6985:	7e 29                	jle    69b0 <assamble_segment+0x250>
    6987:	3b 7e 14             	cmp    0x14(%esi),%edi
    698a:	73 24                	jae    69b0 <assamble_segment+0x250>
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    698c:	39 c3                	cmp    %eax,%ebx
    698e:	0f 82 54 01 00 00    	jb     6ae8 <assamble_segment+0x388>
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    6994:	77 1a                	ja     69b0 <assamble_segment+0x250>
    6996:	39 c7                	cmp    %eax,%edi
    6998:	76 16                	jbe    69b0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    699a:	8b 46 50             	mov    0x50(%esi),%eax
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
				FOUT;
			}
			//3:
			if(( posStart <= ambuf->segStart[0])&&(ambuf->segStart[0] < posEnd)&&\
    699d:	39 c3                	cmp    %eax,%ebx
    699f:	90                   	nop
    69a0:	73 0e                	jae    69b0 <assamble_segment+0x250>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
    69a2:	39 c7                	cmp    %eax,%edi
    69a4:	76 0a                	jbe    69b0 <assamble_segment+0x250>
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
    69a6:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    69a9:	89 7e 50             	mov    %edi,0x50(%esi)
				FOUT;
    69ac:	eb b2                	jmp    6960 <assamble_segment+0x200>
    69ae:	66 90                	xchg   %ax,%ax
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    69b0:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    69b6:	89 ca                	mov    %ecx,%edx
    69b8:	83 ea 01             	sub    $0x1,%edx
    69bb:	89 55 dc             	mov    %edx,-0x24(%ebp)
    69be:	74 a0                	je     6960 <assamble_segment+0x200>
				(posStart < ambuf->segEnd[0])&&(ambuf->segEnd[0] < posEnd)&&(posEnd < ambuf->segStart[1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 3\n");
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				FOUT;
    69c0:	89 75 ec             	mov    %esi,-0x14(%ebp)
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    69c3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    69ca:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    69cd:	89 75 e0             	mov    %esi,-0x20(%ebp)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    69d0:	8b 75 ec             	mov    -0x14(%ebp),%esi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69d3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    69d6:	8b 46 50             	mov    0x50(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69d9:	83 eb 01             	sub    $0x1,%ebx
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    69dc:	39 45 e8             	cmp    %eax,-0x18(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    69df:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
		{
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
    69e2:	76 14                	jbe    69f8 <assamble_segment+0x298>
    69e4:	8b 56 14             	mov    0x14(%esi),%edx
    69e7:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    69ea:	73 0c                	jae    69f8 <assamble_segment+0x298>
    69ec:	39 c7                	cmp    %eax,%edi
    69ee:	76 08                	jbe    69f8 <assamble_segment+0x298>
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
    69f0:	39 d7                	cmp    %edx,%edi
    69f2:	0f 82 5d 03 00 00    	jb     6d55 <assamble_segment+0x5f5>
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
    69f8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    69fb:	8b 75 e8             	mov    -0x18(%ebp),%esi
    69fe:	3b 73 10             	cmp    0x10(%ebx),%esi
    6a01:	72 5d                	jb     6a60 <assamble_segment+0x300>
    6a03:	39 c6                	cmp    %eax,%esi
    6a05:	77 5e                	ja     6a65 <assamble_segment+0x305>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a07:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    6a0a:	76 34                	jbe    6a40 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a0c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a0f:	8b 5d e0             	mov    -0x20(%ebp),%ebx
    6a12:	8d 44 93 10          	lea    0x10(%ebx,%edx,4),%eax
    6a16:	66 90                	xchg   %ax,%ax
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6a18:	8b 18                	mov    (%eax),%ebx
    6a1a:	39 df                	cmp    %ebx,%edi
    6a1c:	72 0b                	jb     6a29 <assamble_segment+0x2c9>
    6a1e:	8b 70 40             	mov    0x40(%eax),%esi
    6a21:	39 f7                	cmp    %esi,%edi
    6a23:	0f 86 09 01 00 00    	jbe    6b32 <assamble_segment+0x3d2>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6a29:	3b 78 3c             	cmp    0x3c(%eax),%edi
    6a2c:	72 08                	jb     6a36 <assamble_segment+0x2d6>
    6a2e:	39 df                	cmp    %ebx,%edi
    6a30:	0f 82 76 01 00 00    	jb     6bac <assamble_segment+0x44c>
				FOUT;
			}
			//
			else if((ambuf->segStart[i] <=  posStart) &&(posStart <= ambuf->segEnd[i]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a36:	83 c2 01             	add    $0x1,%edx
    6a39:	83 c0 04             	add    $0x4,%eax
    6a3c:	39 d1                	cmp    %edx,%ecx
    6a3e:	77 d8                	ja     6a18 <assamble_segment+0x2b8>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a40:	8b 45 f0             	mov    -0x10(%ebp),%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6a43:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a46:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
    6a4a:	83 c0 01             	add    $0x1,%eax
				ambuf->segEnd[0] = posEnd;
				FOUT;
			}
		}
		//
		for(i = 0; i < ambuf->segnum - 1; i++)
    6a4d:	39 55 dc             	cmp    %edx,-0x24(%ebp)
    6a50:	0f 86 0a ff ff ff    	jbe    6960 <assamble_segment+0x200>
    6a56:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6a59:	e9 72 ff ff ff       	jmp    69d0 <assamble_segment+0x270>
    6a5e:	66 90                	xchg   %ax,%ax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6a60:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6a63:	72 db                	jb     6a40 <assamble_segment+0x2e0>
    6a65:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a68:	8b 55 e0             	mov    -0x20(%ebp),%edx
    6a6b:	83 c0 04             	add    $0x4,%eax
    6a6e:	8b 1c 82             	mov    (%edx,%eax,4),%ebx
    6a71:	39 5d e8             	cmp    %ebx,-0x18(%ebp)
    6a74:	89 45 d8             	mov    %eax,-0x28(%ebp)
    6a77:	77 c7                	ja     6a40 <assamble_segment+0x2e0>
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a79:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
    6a7c:	76 c2                	jbe    6a40 <assamble_segment+0x2e0>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6a7e:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6a81:	8d 44 b2 14          	lea    0x14(%edx,%esi,4),%eax
					}
				}
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
    6a85:	89 f2                	mov    %esi,%edx
    6a87:	eb 0c                	jmp    6a95 <assamble_segment+0x335>
    6a89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6a90:	8b 18                	mov    (%eax),%ebx
    6a92:	83 c0 04             	add    $0x4,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
    6a95:	39 df                	cmp    %ebx,%edi
    6a97:	72 0b                	jb     6aa4 <assamble_segment+0x344>
    6a99:	8b 70 3c             	mov    0x3c(%eax),%esi
    6a9c:	39 f7                	cmp    %esi,%edi
    6a9e:	0f 86 08 02 00 00    	jbe    6cac <assamble_segment+0x54c>
						}
						ambuf->segnum  -= j - i;
						FOUT;
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
    6aa4:	3b 78 38             	cmp    0x38(%eax),%edi
    6aa7:	72 08                	jb     6ab1 <assamble_segment+0x351>
    6aa9:	39 df                	cmp    %ebx,%edi
    6aab:	0f 82 73 01 00 00    	jb     6c24 <assamble_segment+0x4c4>
			}

			//
			else if((ambuf->segEnd[i] <=  posStart) &&(posStart <= ambuf->segStart[i + 1]))
			{
				for(j = i + 1; j < ambuf->segnum; j++)
    6ab1:	83 c2 01             	add    $0x1,%edx
    6ab4:	39 d1                	cmp    %edx,%ecx
    6ab6:	77 d8                	ja     6a90 <assamble_segment+0x330>
    6ab8:	eb 86                	jmp    6a40 <assamble_segment+0x2e0>
				}
				//11:
				else if((ambuf->segEnd[i - 1] < posStart)&&(posStart <= ambuf->segStart[i]))
				{
					//fsm_printf("[RLC][assamble_segment] condition 11\n");
					ambuf->segStart[i] = posStart;
    6aba:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
					ambuf->segEnd[i] = posEnd;
    6abe:	89 7c 96 50          	mov    %edi,0x50(%esi,%edx,4)
					ambuf->segnum = i + 1;
    6ac2:	83 c2 01             	add    $0x1,%edx
    6ac5:	89 96 90 00 00 00    	mov    %edx,0x90(%esi)
	            ambuf->segnum = 1;
	            FOUT;
			}
		}
	}
}
    6acb:	83 c4 20             	add    $0x20,%esp
    6ace:	5b                   	pop    %ebx
    6acf:	5e                   	pop    %esi
    6ad0:	5f                   	pop    %edi
    6ad1:	5d                   	pop    %ebp
    6ad2:	c3                   	ret    
			posbuf = posbuf + headLen + posStart;
			fsm_mem_cpy(posbuf, pospkt, pkt->len);
			fsm_pkt_destroy(pkt);
			pkt = NULL;
		}
		if(exthead->LSF == 1)
    6ad3:	8b 96 90 00 00 00    	mov    0x90(%esi),%edx
    6ad9:	8d 42 ff             	lea    -0x1(%edx),%eax
    6adc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    6adf:	8b 44 96 4c          	mov    0x4c(%esi,%edx,4),%eax
    6ae3:	e9 4f fd ff ff       	jmp    6837 <assamble_segment+0xd7>
		//buffer()

		if((ambuf->segStart[0] > 0)&&(posEnd < ambuf->segStart[1]))
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
    6ae8:	39 c7                	cmp    %eax,%edi
    6aea:	0f 83 4c 02 00 00    	jae    6d3c <assamble_segment+0x5dc>
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6af0:	8b 8e 90 00 00 00    	mov    0x90(%esi),%ecx
    6af6:	89 ca                	mov    %ecx,%edx
    6af8:	83 ea 01             	sub    $0x1,%edx
    6afb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
    6afe:	78 1b                	js     6b1b <assamble_segment+0x3bb>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b00:	8d 44 8e 4c          	lea    0x4c(%esi,%ecx,4),%eax
    6b04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
    6b08:	8b 08                	mov    (%eax),%ecx
    6b0a:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[i+1] = ambuf->segStart[i];
    6b0d:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6b10:	89 48 c4             	mov    %ecx,-0x3c(%eax)
		{
			//1:seg[0]
			if((ambuf->segStart[0] > posStart)&&(ambuf->segStart[0] > posEnd))
			{
				//fsm_printf("[RLC][assamble_segment] condition 1\n");
				for(i = ambuf->segnum - 1; i >= 0; --i)
    6b13:	83 e8 04             	sub    $0x4,%eax
    6b16:	83 ea 01             	sub    $0x1,%edx
    6b19:	79 ed                	jns    6b08 <assamble_segment+0x3a8>
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
    6b1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
				for(i = ambuf->segnum - 1; i >= 0; --i)
				{
				ambuf->segEnd[i+1] = ambuf->segEnd[i];
				ambuf->segStart[i+1] = ambuf->segStart[i];
				}
				ambuf->segStart[0] = posStart;
    6b1e:	89 5e 10             	mov    %ebx,0x10(%esi)
				ambuf->segEnd[0] = posEnd;
    6b21:	89 7e 50             	mov    %edi,0x50(%esi)
				ambuf->segnum++;
    6b24:	83 c0 01             	add    $0x1,%eax
    6b27:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
				FOUT;
    6b2d:	e9 2e fe ff ff       	jmp    6960 <assamble_segment+0x200>
    6b32:	89 f0                	mov    %esi,%eax
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6b34:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6b37:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;j++;
    6b3a:	8d 5a 01             	lea    0x1(%edx),%ebx
						for(; i < ambuf->segnum; j++, i++)
    6b3d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
				{
					//5:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6b40:	89 44 be 50          	mov    %eax,0x50(%esi,%edi,4)
						i++;j++;
    6b44:	8b 7d f0             	mov    -0x10(%ebp),%edi
						for(; i < ambuf->segnum; j++, i++)
    6b47:	39 f9                	cmp    %edi,%ecx
    6b49:	76 4f                	jbe    6b9a <assamble_segment+0x43a>
    6b4b:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b51:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
    6b55:	89 75 f0             	mov    %esi,-0x10(%ebp)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b58:	89 45 ec             	mov    %eax,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6b5b:	8d 44 be 50          	lea    0x50(%esi,%edi,4),%eax
    6b5f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6b62:	eb 20                	jmp    6b84 <assamble_segment+0x424>
    6b64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6b68:	8b 0a                	mov    (%edx),%ecx
    6b6a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6b6c:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6b6f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 5\n");
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6b72:	83 c7 01             	add    $0x1,%edi
    6b75:	83 c3 01             	add    $0x1,%ebx
    6b78:	83 c2 04             	add    $0x4,%edx
    6b7b:	83 c0 04             	add    $0x4,%eax
    6b7e:	39 f7                	cmp    %esi,%edi
    6b80:	73 15                	jae    6b97 <assamble_segment+0x437>
    6b82:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6b84:	39 cb                	cmp    %ecx,%ebx
    6b86:	72 e0                	jb     6b68 <assamble_segment+0x408>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6b88:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6b8e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6b95:	eb db                	jmp    6b72 <assamble_segment+0x412>
    6b97:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6b9d:	29 df                	sub    %ebx,%edi
    6b9f:	01 f8                	add    %edi,%eax
    6ba1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6ba7:	e9 b4 fd ff ff       	jmp    6960 <assamble_segment+0x200>
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6bac:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6baf:	8b 75 e0             	mov    -0x20(%ebp),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6bb2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
					}
					//6:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
    6bb5:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6bb9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						for(; i < ambuf->segnum; j++, i++)
    6bbc:	39 d9                	cmp    %ebx,%ecx
    6bbe:	76 52                	jbe    6c12 <assamble_segment+0x4b2>
    6bc0:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6bc6:	8d 44 9e 50          	lea    0x50(%esi,%ebx,4),%eax
    6bca:	89 75 f0             	mov    %esi,-0x10(%ebp)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6bcd:	89 7d ec             	mov    %edi,-0x14(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6bd0:	8d 7c 96 50          	lea    0x50(%esi,%edx,4),%edi
    6bd4:	8b 75 ec             	mov    -0x14(%ebp),%esi
    6bd7:	eb 23                	jmp    6bfc <assamble_segment+0x49c>
    6bd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6be0:	8b 0f                	mov    (%edi),%ecx
    6be2:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6be4:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6be7:	89 48 c0             	mov    %ecx,-0x40(%eax)
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 6\n");
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6bea:	83 c3 01             	add    $0x1,%ebx
    6bed:	83 c2 01             	add    $0x1,%edx
    6bf0:	83 c7 04             	add    $0x4,%edi
    6bf3:	83 c0 04             	add    $0x4,%eax
    6bf6:	39 de                	cmp    %ebx,%esi
    6bf8:	76 15                	jbe    6c0f <assamble_segment+0x4af>
    6bfa:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6bfc:	39 d1                	cmp    %edx,%ecx
    6bfe:	77 e0                	ja     6be0 <assamble_segment+0x480>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6c00:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6c06:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6c0d:	eb db                	jmp    6bea <assamble_segment+0x48a>
    6c0f:	8b 75 f0             	mov    -0x10(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6c12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6c15:	29 d3                	sub    %edx,%ebx
    6c17:	01 d8                	add    %ebx,%eax
    6c19:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6c1f:	e9 3c fd ff ff       	jmp    6960 <assamble_segment+0x200>
    6c24:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6c27:	8b 75 e0             	mov    -0x20(%ebp),%esi
					}
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
    6c2a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    6c2d:	89 1c 86             	mov    %ebx,(%esi,%eax,4)
						ambuf->segEnd[i] = posEnd;
    6c30:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6c33:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//8:
					else if((ambuf->segEnd[j - 1] <= posEnd)&&(posEnd < ambuf->segStart[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
    6c36:	89 7c 9e 50          	mov    %edi,0x50(%esi,%ebx,4)
						i++;
    6c3a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6c3d:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6c40:	39 d9                	cmp    %ebx,%ecx
    6c42:	76 56                	jbe    6c9a <assamble_segment+0x53a>
    6c44:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c4a:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6c4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6c51:	89 7d f0             	mov    %edi,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6c54:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    6c57:	8d 44 be 58          	lea    0x58(%esi,%edi,4),%eax
    6c5b:	8b 7d ec             	mov    -0x14(%ebp),%edi
    6c5e:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6c61:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6c64:	eb 1e                	jmp    6c84 <assamble_segment+0x524>
    6c66:	66 90                	xchg   %ax,%ax
						i++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6c68:	8b 0f                	mov    (%edi),%ecx
    6c6a:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6c6c:	8b 4f c0             	mov    -0x40(%edi),%ecx
    6c6f:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 8\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = posEnd;
						i++;
						for(; i < ambuf->segnum; j++, i++)
    6c72:	83 c3 01             	add    $0x1,%ebx
    6c75:	83 c2 01             	add    $0x1,%edx
    6c78:	83 c7 04             	add    $0x4,%edi
    6c7b:	83 c0 04             	add    $0x4,%eax
    6c7e:	39 de                	cmp    %ebx,%esi
    6c80:	76 15                	jbe    6c97 <assamble_segment+0x537>
    6c82:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6c84:	39 ca                	cmp    %ecx,%edx
    6c86:	72 e0                	jb     6c68 <assamble_segment+0x508>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6c88:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6c8e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6c95:	eb db                	jmp    6c72 <assamble_segment+0x512>
    6c97:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6c9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c9d:	29 d3                	sub    %edx,%ebx
    6c9f:	01 d8                	add    %ebx,%eax
    6ca1:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6ca7:	e9 b4 fc ff ff       	jmp    6960 <assamble_segment+0x200>
    6cac:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6caf:	89 f0                	mov    %esi,%eax
				{
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
    6cb1:	8b 7d d8             	mov    -0x28(%ebp),%edi
    6cb4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6cb7:	89 1c be             	mov    %ebx,(%esi,%edi,4)
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6cba:	8b 5d f0             	mov    -0x10(%ebp),%ebx
						i++;j++;
    6cbd:	8d 7a 01             	lea    0x1(%edx),%edi
						for(; i < ambuf->segnum; j++, i++)
    6cc0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
					//7:
					if((ambuf->segStart[j] <= posEnd )&&(posEnd <= ambuf->segEnd[j]))
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
    6cc3:	89 44 9e 50          	mov    %eax,0x50(%esi,%ebx,4)
						i++;j++;
    6cc7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    6cca:	83 c3 02             	add    $0x2,%ebx
						for(; i < ambuf->segnum; j++, i++)
    6ccd:	39 d9                	cmp    %ebx,%ecx
    6ccf:	76 59                	jbe    6d2a <assamble_segment+0x5ca>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6cd1:	8d 54 96 54          	lea    0x54(%esi,%edx,4),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6cd5:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6cdb:	89 55 ec             	mov    %edx,-0x14(%ebp)
    6cde:	8b 55 e4             	mov    -0x1c(%ebp),%edx
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6ce1:	89 45 f0             	mov    %eax,-0x10(%ebp)
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6ce4:	8d 44 96 58          	lea    0x58(%esi,%edx,4),%eax
    6ce8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6ceb:	89 75 ec             	mov    %esi,-0x14(%ebp)
    6cee:	8b 75 f0             	mov    -0x10(%ebp),%esi
    6cf1:	eb 21                	jmp    6d14 <assamble_segment+0x5b4>
    6cf3:	90                   	nop
    6cf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
						{
							if(j < ambuf->segnum)
							{
								ambuf->segEnd[i] = ambuf->segEnd[j];
    6cf8:	8b 0a                	mov    (%edx),%ecx
    6cfa:	89 08                	mov    %ecx,(%eax)
								ambuf->segStart[i] = ambuf->segStart[j];
    6cfc:	8b 4a c0             	mov    -0x40(%edx),%ecx
    6cff:	89 48 c0             	mov    %ecx,-0x40(%eax)
					{
						//fsm_printf("[RLC][assamble_segment] condition 7\n");
						ambuf->segStart[++i] = posStart;
						ambuf->segEnd[i] = ambuf->segEnd[j];
						i++;j++;
						for(; i < ambuf->segnum; j++, i++)
    6d02:	83 c3 01             	add    $0x1,%ebx
    6d05:	83 c7 01             	add    $0x1,%edi
    6d08:	83 c2 04             	add    $0x4,%edx
    6d0b:	83 c0 04             	add    $0x4,%eax
    6d0e:	39 de                	cmp    %ebx,%esi
    6d10:	76 15                	jbe    6d27 <assamble_segment+0x5c7>
    6d12:	89 f1                	mov    %esi,%ecx
						{
							if(j < ambuf->segnum)
    6d14:	39 cf                	cmp    %ecx,%edi
    6d16:	72 e0                	jb     6cf8 <assamble_segment+0x598>
								ambuf->segEnd[i] = ambuf->segEnd[j];
								ambuf->segStart[i] = ambuf->segStart[j];
							}
							else
							{
								ambuf->segEnd[i] = -1;
    6d18:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
								ambuf->segStart[i] = -1;
    6d1e:	c7 40 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%eax)
    6d25:	eb db                	jmp    6d02 <assamble_segment+0x5a2>
    6d27:	8b 75 ec             	mov    -0x14(%ebp),%esi
							}
						}
						ambuf->segnum  -= j - i;
    6d2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d2d:	29 fb                	sub    %edi,%ebx
    6d2f:	01 d8                	add    %ebx,%eax
    6d31:	89 86 90 00 00 00    	mov    %eax,0x90(%esi)
						FOUT;
    6d37:	e9 24 fc ff ff       	jmp    6960 <assamble_segment+0x200>
				ambuf->segEnd[0] = posEnd;
				ambuf->segnum++;
				FOUT;
			}
			//2:
			if((posStart < ambuf->segStart[0] )&&(ambuf->segStart[0] < posEnd)&&(posEnd <= ambuf->segEnd[0]))
    6d3c:	0f 86 6e fc ff ff    	jbe    69b0 <assamble_segment+0x250>
    6d42:	3b 7e 50             	cmp    0x50(%esi),%edi
    6d45:	0f 87 4f fc ff ff    	ja     699a <assamble_segment+0x23a>
			{
				//fsm_printf("[RLC][assamble_segment] condition 2\n");
				ambuf->segStart[0] = posStart;
    6d4b:	89 5e 10             	mov    %ebx,0x10(%esi)
    6d4e:	66 90                	xchg   %ax,%ax
				FOUT;
    6d50:	e9 0b fc ff ff       	jmp    6960 <assamble_segment+0x200>
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6d55:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6d58:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6d5b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6d5e:	8b 75 e0             	mov    -0x20(%ebp),%esi
    6d61:	7e 20                	jle    6d83 <assamble_segment+0x623>
**Created Date: 2013
**---------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
void assamble_segment(AmBuffer *ambuf, FSM_PKT *pkt)
    6d63:	8d 44 96 50          	lea    0x50(%esi,%edx,4),%eax
    6d67:	89 4d f0             	mov    %ecx,-0x10(%ebp)
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6d6a:	8b 08                	mov    (%eax),%ecx
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6d6c:	83 ea 01             	sub    $0x1,%edx
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
    6d6f:	89 48 04             	mov    %ecx,0x4(%eax)
				ambuf->segStart[j+1] = ambuf->segStart[j];
    6d72:	8b 48 c0             	mov    -0x40(%eax),%ecx
    6d75:	89 48 c4             	mov    %ecx,-0x3c(%eax)
			//4;
			if((ambuf->segEnd[i] < posStart)&&(posStart < ambuf->segStart[i + 1])&&\
				(ambuf->segEnd[i] < posEnd)&&(posEnd < ambuf->segStart[i + 1]))
			{
				//fsm_printf("[RLC][assamble_segment] condition 4\n");
				for(j = ambuf->segnum - 1; j > i; --j)
    6d78:	83 e8 04             	sub    $0x4,%eax
    6d7b:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
    6d7e:	7f ea                	jg     6d6a <assamble_segment+0x60a>
    6d80:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
				ambuf->segEnd[j+1] = posEnd;
				ambuf->segnum++;
    6d83:	83 c1 01             	add    $0x1,%ecx
				for(j = ambuf->segnum - 1; j > i; --j)
				{
				ambuf->segEnd[j+1] = ambuf->segEnd[j];
				ambuf->segStart[j+1] = ambuf->segStart[j];
				}
				ambuf->segStart[j+1] = posStart;
    6d86:	89 5c 96 14          	mov    %ebx,0x14(%esi,%edx,4)
				ambuf->segEnd[j+1] = posEnd;
    6d8a:	89 7c 96 54          	mov    %edi,0x54(%esi,%edx,4)
				ambuf->segnum++;
    6d8e:	89 8e 90 00 00 00    	mov    %ecx,0x90(%esi)
				FOUT;
    6d94:	e9 c7 fb ff ff       	jmp    6960 <assamble_segment+0x200>
    6d99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00006da0 <rlc_pkt_receive_from_mac>:
**-------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
******************************************************************************/
void rlc_pkt_receive_from_mac(FSM_PKT * skb)
{
    6da0:	55                   	push   %ebp
    6da1:	89 e5                	mov    %esp,%ebp
    6da3:	57                   	push   %edi
    6da4:	56                   	push   %esi
    6da5:	53                   	push   %ebx
    6da6:	83 ec 4c             	sub    $0x4c,%esp
    6da9:	e8 fc ff ff ff       	call   6daa <rlc_pkt_receive_from_mac+0xa>
    6dae:	89 c3                	mov    %eax,%ebx
	struct  UM_RX_Instance *umRxIns;
//   struct  TM_RX_Instance *tmRxIns;
	void *insptru, *insptrd;
	
	FIN(rlc_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6db0:	e8 fc ff ff ff       	call   6db1 <rlc_pkt_receive_from_mac+0x11>
    6db5:	89 c7                	mov    %eax,%edi
	SV(countreceive_from_mac)++;
    6db7:	8b 80 88 5a 00 00    	mov    0x5a88(%eax),%eax
    6dbd:	83 c0 01             	add    $0x1,%eax
    6dc0:	89 87 88 5a 00 00    	mov    %eax,0x5a88(%edi)
	printk("[rlc_pkt_receive_from_mac]UE RLC_MAC SEND TO UPPER=%d\n",SV(countreceive_from_mac));
    6dc6:	89 44 24 04          	mov    %eax,0x4(%esp)
    6dca:	c7 04 24 58 1e 00 00 	movl   $0x1e58,(%esp)
    6dd1:	e8 fc ff ff ff       	call   6dd2 <rlc_pkt_receive_from_mac+0x32>

	//skb = fsm_pkt_get();

	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from lower\n");
	//fsm_octets_print(skb->data,50);
	micimsg = (MRLC_fromMac_IciMsg*)skb->head;
    6dd6:	8b b3 a8 00 00 00    	mov    0xa8(%ebx),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
    6ddc:	8b 46 02             	mov    0x2(%esi),%eax
    6ddf:	89 44 24 08          	mov    %eax,0x8(%esp)
    6de3:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6de7:	c7 04 24 90 1e 00 00 	movl   $0x1e90,(%esp)
    6dee:	89 44 24 04          	mov    %eax,0x4(%esp)
    6df2:	e8 fc ff ff ff       	call   6df3 <rlc_pkt_receive_from_mac+0x53>
	fsm_octets_print(skb->data,64);
    6df7:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    6dfd:	ba 40 00 00 00       	mov    $0x40,%edx
    6e02:	e8 fc ff ff ff       	call   6e03 <rlc_pkt_receive_from_mac+0x63>
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
    6e07:	8b 46 02             	mov    0x2(%esi),%eax
    6e0a:	85 c0                	test   %eax,%eax
    6e0c:	75 08                	jne    6e16 <rlc_pkt_receive_from_mac+0x76>
    6e0e:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    6e12:	84 c0                	test   %al,%al
    6e14:	75 5a                	jne    6e70 <rlc_pkt_receive_from_mac+0xd0>
		}
		
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    6e16:	89 d8                	mov    %ebx,%eax
    6e18:	e8 fc ff ff ff       	call   6e19 <rlc_pkt_receive_from_mac+0x79>
    6e1d:	83 f8 01             	cmp    $0x1,%eax
    6e20:	0f 86 92 03 00 00    	jbe    71b8 <rlc_pkt_receive_from_mac+0x418>
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6e26:	8b 46 02             	mov    0x2(%esi),%eax
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6e29:	8d 55 f2             	lea    -0xe(%ebp),%edx
    6e2c:	b9 02 00 00 00       	mov    $0x2,%ecx
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
    6e31:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
		}
		icimsg.pbCh = micimsg->pbCh;
    6e35:	88 45 f2             	mov    %al,-0xe(%ebp)
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
    6e38:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    6e3e:	e8 fc ff ff ff       	call   6e3f <rlc_pkt_receive_from_mac+0x9f>
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
    6e43:	c7 04 24 a4 27 00 00 	movl   $0x27a4,(%esp)
    6e4a:	e8 fc ff ff ff       	call   6e4b <rlc_pkt_receive_from_mac+0xab>
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6e4f:	ba 05 00 00 00       	mov    $0x5,%edx
    6e54:	89 d8                	mov    %ebx,%eax
		icimsg.pbCh = micimsg->pbCh;
		icimsg.rbId = 0;
		fsm_mem_cpy(skb->head, &icimsg , sizeof(URLC_IciMsg));
		fsm_printf("[RLC][rlc_pkt_receive_from_mac][<--] send to RRC\n");
		//fsm_octets_print(skb->data, 100);
		SV(countSendToUpper)++;
    6e56:	83 87 90 5a 00 00 01 	addl   $0x1,0x5a90(%edi)
 		fsm_pkt_send(skb, STRM_TO_RRC);
    6e5d:	e8 fc ff ff ff       	call   6e5e <rlc_pkt_receive_from_mac+0xbe>
	}
	//printk("[RLC_MAC]SV(countDropPacket):%d\n", SV(countDropPacket));
	FOUT;
}
    6e62:	83 c4 4c             	add    $0x4c,%esp
    6e65:	5b                   	pop    %ebx
    6e66:	5e                   	pop    %esi
    6e67:	5f                   	pop    %edi
    6e68:	5d                   	pop    %ebp
    6e69:	c3                   	ret    
    6e6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	fsm_printf("\n[RLC][rlc_pkt_receive_from_mac] entering rlc_pkt_receive_from_mac(lcid is %d,pbch is %d)\n",micimsg->lcid,micimsg->pbCh);
	fsm_octets_print(skb->data,64);
	//fsm_printf("[RLC][rlc_pkt_receive_from_mac][-->] receive from mac\n");
	if(micimsg->pbCh ==0 && micimsg->lcid != 0 )
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
    6e70:	8d 97 18 02 00 00    	lea    0x218(%edi),%edx
    6e76:	0f b6 c0             	movzbl %al,%eax
    6e79:	89 14 24             	mov    %edx,(%esp)
    6e7c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    6e7f:	8d 55 e8             	lea    -0x18(%ebp),%edx
    6e82:	e8 fc ff ff ff       	call   6e83 <rlc_pkt_receive_from_mac+0xe3>
		switch(SV(ins_mode))
    6e87:	8b 87 18 02 00 00    	mov    0x218(%edi),%eax
    6e8d:	83 f8 02             	cmp    $0x2,%eax
    6e90:	74 3e                	je     6ed0 <rlc_pkt_receive_from_mac+0x130>
    6e92:	83 f8 03             	cmp    $0x3,%eax
    6e95:	0f 84 35 03 00 00    	je     71d0 <rlc_pkt_receive_from_mac+0x430>
			//printk("[RLC_MAC UM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		default:
			printk("[RLC][rlc_pkt_receive_from_mac] cannot distinfuish this  %d", SV(ins_mode));
    6e9b:	89 44 24 04          	mov    %eax,0x4(%esp)
    6e9f:	c7 04 24 30 27 00 00 	movl   $0x2730,(%esp)
    6ea6:	e8 fc ff ff ff       	call   6ea7 <rlc_pkt_receive_from_mac+0x107>
			break;
		}
		//fsm_printf("[RLC][rlc_pkt_receive_from_mac] cannot find the instance or the instance is suspended(rbid is %d)\n", micimsg->lcid);
		printk("[RLC][rlc_pkt_receive_from_mac] A packet has dropped\n");
    6eab:	c7 04 24 6c 27 00 00 	movl   $0x276c,(%esp)
    6eb2:	e8 fc ff ff ff       	call   6eb3 <rlc_pkt_receive_from_mac+0x113>
		SV(countDropPacket)++;
    6eb7:	83 87 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%edi)
		if(skb != NULL)
    6ebe:	85 db                	test   %ebx,%ebx
    6ec0:	74 a0                	je     6e62 <rlc_pkt_receive_from_mac+0xc2>
		{
			fsm_pkt_destroy(skb);
    6ec2:	89 d8                	mov    %ebx,%eax
    6ec4:	e8 fc ff ff ff       	call   6ec5 <rlc_pkt_receive_from_mac+0x125>
    6ec9:	eb 97                	jmp    6e62 <rlc_pkt_receive_from_mac+0xc2>
    6ecb:	90                   	nop
    6ecc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
			FOUT;
			break;

		case UM_MODE:
			if(insptrd == NULL)
    6ed0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    6ed3:	85 c9                	test   %ecx,%ecx
    6ed5:	0f 84 ab 0d 00 00    	je     7c86 <rlc_pkt_receive_from_mac+0xee6>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
    6edb:	0f b6 81 c2 10 00 00 	movzbl 0x10c2(%ecx),%eax
    6ee2:	3c 0b                	cmp    $0xb,%al
    6ee4:	0f 84 83 0d 00 00    	je     7c6d <rlc_pkt_receive_from_mac+0xecd>
    6eea:	3c 09                	cmp    $0x9,%al
    6eec:	0f 84 7b 0d 00 00    	je     7c6d <rlc_pkt_receive_from_mac+0xecd>
	u16 windows;
	//MRLC_fromMac_IciMsg *mac_ici;
	//URLC_IciMsg *icimsg;
	
	FIN(rlc_UM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    6ef2:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6ef5:	e8 fc ff ff ff       	call   6ef6 <rlc_pkt_receive_from_mac+0x156>
    6efa:	89 45 dc             	mov    %eax,-0x24(%ebp)
	fsm_printf("\n[RLC][rlc_UM_pkt_receive_from_mac] entering rlc_UM_pkt_receive_from_mac\n");
    6efd:	c7 04 24 60 23 00 00 	movl   $0x2360,(%esp)
    6f04:	e8 fc ff ff ff       	call   6f05 <rlc_pkt_receive_from_mac+0x165>
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
    6f09:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f0c:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6f10:	c7 04 24 ac 23 00 00 	movl   $0x23ac,(%esp)
    6f17:	89 44 24 04          	mov    %eax,0x4(%esp)
    6f1b:	e8 fc ff ff ff       	call   6f1c <rlc_pkt_receive_from_mac+0x17c>
	switch(umRxIns->snFiledLength)
    6f20:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f23:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6f27:	66 83 f8 05          	cmp    $0x5,%ax
    6f2b:	0f 84 3f 06 00 00    	je     7570 <rlc_pkt_receive_from_mac+0x7d0>
    6f31:	66 83 f8 0a          	cmp    $0xa,%ax
    6f35:	0f 84 7d 06 00 00    	je     75b8 <rlc_pkt_receive_from_mac+0x818>
			FOUT;
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size10 + 1));
		break;
	default:
		printk("[RLC][rlc_UM_pkt_receive_from_mac] cannot distinguish the %d",umRxIns->snFiledLength);
    6f3b:	0f b7 c0             	movzwl %ax,%eax
    6f3e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f41:	89 44 24 04          	mov    %eax,0x4(%esp)
    6f45:	c7 04 24 44 24 00 00 	movl   $0x2444,(%esp)
    6f4c:	e8 fc ff ff ff       	call   6f4d <rlc_pkt_receive_from_mac+0x1ad>
    6f51:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f54:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    6f5a:	0f bf 75 e4          	movswl -0x1c(%ebp),%esi
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6f5e:	b8 18 00 00 00       	mov    $0x18,%eax
    6f63:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f66:	e8 fc ff ff ff       	call   6f67 <rlc_pkt_receive_from_mac+0x1c7>
	umbuf->pkt = pkt;
    6f6b:	89 18                	mov    %ebx,(%eax)
	umbuf->SN = SN;
    6f6d:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6f71:	8d 50 10             	lea    0x10(%eax),%edx
	}
	//
	
	
	
	umbuf = (UmBuffer*)fsm_mem_alloc(sizeof(UmBuffer));
    6f74:	89 c7                	mov    %eax,%edi
	umbuf->pkt = pkt;
	umbuf->SN = SN;
    6f76:	66 89 58 0c          	mov    %bx,0xc(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    6f7a:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6f7d:	8b 41 34             	mov    0x34(%ecx),%eax
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
    6f80:	8d 59 30             	lea    0x30(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    6f83:	89 51 34             	mov    %edx,0x34(%ecx)
    6f86:	89 5f 10             	mov    %ebx,0x10(%edi)
	new->next = next;
	new->prev = prev;
    6f89:	89 47 14             	mov    %eax,0x14(%edi)
	prev->next = new;
    6f8c:	89 10                	mov    %edx,(%eax)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    6f8e:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6f91:	89 74 24 04          	mov    %esi,0x4(%esp)
    6f95:	c7 04 24 84 24 00 00 	movl   $0x2484,(%esp)
    6f9c:	e8 fc ff ff ff       	call   6f9d <rlc_pkt_receive_from_mac+0x1fd>
	if(umRxIns->snFiledLength == 5)
    6fa1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6fa4:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    6fa8:	66 83 f8 05          	cmp    $0x5,%ax
    6fac:	0f 84 1e 07 00 00    	je     76d0 <rlc_pkt_receive_from_mac+0x930>
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
	}
	if(umRxIns->snFiledLength == 10)
    6fb2:	66 83 f8 0a          	cmp    $0xa,%ax
    6fb6:	75 07                	jne    6fbf <rlc_pkt_receive_from_mac+0x21f>
	{
		umRxIns->umRecvWindow10[SN] = umbuf;
    6fb8:	89 bc b1 b8 00 00 00 	mov    %edi,0xb8(%ecx,%esi,4)
	}
	umRxIns->vr_uh %= windows;
    6fbf:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    6fc6:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    6fca:	89 c2                	mov    %eax,%edx
    6fcc:	c1 fa 1f             	sar    $0x1f,%edx
    6fcf:	f7 fb                	idiv   %ebx
    6fd1:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_uh is %d\n", umRxIns->vr_uh);
    6fd8:	0f bf d2             	movswl %dx,%edx
    6fdb:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    6fde:	89 54 24 04          	mov    %edx,0x4(%esp)
    6fe2:	c7 04 24 d0 24 00 00 	movl   $0x24d0,(%esp)
    6fe9:	e8 fc ff ff ff       	call   6fea <rlc_pkt_receive_from_mac+0x24a>
	//
	if((SN>=umRxIns->vr_uh)||(SN <= umRxIns->vr_uh - windows/2))
    6fee:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    6ff1:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
    6ff5:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    6ffc:	66 d1 ef             	shr    %di
    6fff:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
    7003:	0f b7 ff             	movzwl %di,%edi
    7006:	7d 07                	jge    700f <rlc_pkt_receive_from_mac+0x26f>
    7008:	98                   	cwtl   
    7009:	29 f8                	sub    %edi,%eax
    700b:	39 c6                	cmp    %eax,%esi
    700d:	7f 66                	jg     7075 <rlc_pkt_receive_from_mac+0x2d5>
	{
		//	fsm_printf("umbuf->SN  >=  umRxIns->vr_uh is %d\n",umRxIns->vr_uh);
		umRxIns->vr_uh = (SN + 1)%windows;
    700f:	8d 46 01             	lea    0x1(%esi),%eax
    7012:	89 c2                	mov    %eax,%edx
    7014:	c1 fa 1f             	sar    $0x1f,%edx
    7017:	f7 fb                	idiv   %ebx
    7019:	66 89 91 c0 10 00 00 	mov    %dx,0x10c0(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] outside the windows: umRxIns->vr_uh is updated to %d\n", umRxIns->vr_uh);
    7020:	89 54 24 04          	mov    %edx,0x4(%esp)
    7024:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7027:	c7 04 24 0c 25 00 00 	movl   $0x250c,(%esp)
    702e:	e8 fc ff ff ff       	call   702f <rlc_pkt_receive_from_mac+0x28f>
		//temp = umRxIns->vr_ur;
		if(umRxIns->vr_ur < umRxIns->vr_uh - windows/2 )
    7033:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7036:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    703d:	0f bf 91 bc 10 00 00 	movswl 0x10bc(%ecx),%edx
    7044:	89 c6                	mov    %eax,%esi
    7046:	29 fe                	sub    %edi,%esi
    7048:	39 f2                	cmp    %esi,%edx
    704a:	7d 13                	jge    705f <rlc_pkt_receive_from_mac+0x2bf>
		{
			umRxIns->vr_ur = (umRxIns->vr_uh + windows/2)%windows;
    704c:	01 f8                	add    %edi,%eax
    704e:	89 c2                	mov    %eax,%edx
    7050:	c1 fa 1f             	sar    $0x1f,%edx
    7053:	f7 fb                	idiv   %ebx
    7055:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
    705c:	0f bf d2             	movswl %dx,%edx
			}
			umRxIns->vr_ur =  temp;*/
			//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
		}		
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    705f:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7062:	89 54 24 04          	mov    %edx,0x4(%esp)
    7066:	c7 04 24 68 25 00 00 	movl   $0x2568,(%esp)
    706d:	e8 fc ff ff ff       	call   706e <rlc_pkt_receive_from_mac+0x2ce>
    7072:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		//	fsm_printf("umRxIns->vr_ur is %d\n",umRxIns->vr_ur);
		//	   fsm_pkt_send(rlc_UM_reassemble_deliver( umRxIns),STRM_TO_PDCP);
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
    7075:	0f b7 41 06          	movzwl 0x6(%ecx),%eax
    7079:	66 83 f8 05          	cmp    $0x5,%ax
    707d:	0f 84 f6 06 00 00    	je     7779 <rlc_pkt_receive_from_mac+0x9d9>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
		}
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
    7083:	66 83 f8 0a          	cmp    $0xa,%ax
    7087:	0f 84 92 07 00 00    	je     781f <rlc_pkt_receive_from_mac+0xa7f>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    708d:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    7094:	8b 71 08             	mov    0x8(%ecx),%esi
    7097:	85 f6                	test   %esi,%esi
    7099:	0f 84 a4 00 00 00    	je     7143 <rlc_pkt_receive_from_mac+0x3a3>
    709f:	0f b7 81 be 10 00 00 	movzwl 0x10be(%ecx),%eax
    70a6:	66 39 c7             	cmp    %ax,%di
    70a9:	7d 6d                	jge    7118 <rlc_pkt_receive_from_mac+0x378>
    70ab:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    70af:	0f bf d0             	movswl %ax,%edx
    70b2:	0f bf ff             	movswl %di,%edi
    70b5:	66 d1 ee             	shr    %si
    70b8:	0f b7 f6             	movzwl %si,%esi
    70bb:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    70be:	89 d6                	mov    %edx,%esi
    70c0:	2b 75 e4             	sub    -0x1c(%ebp),%esi
    70c3:	39 f7                	cmp    %esi,%edi
    70c5:	7e 51                	jle    7118 <rlc_pkt_receive_from_mac+0x378>
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    70c7:	66 83 79 06 05       	cmpw   $0x5,0x6(%ecx)
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    70cc:	0f bf b1 c0 10 00 00 	movswl 0x10c0(%ecx),%esi
************************************************************************/
bool isInsideUmRecvWin(struct UM_RX_Instance* umRxIns, SequenceNumber SN)
{
	short base,baseMode,temp;
	
	if(umRxIns->snFiledLength == 5)
    70d3:	0f 84 f4 08 00 00    	je     79cd <rlc_pkt_receive_from_mac+0xc2d>
			temp = -base;
		}
		baseMode = base % 1024;
		temp = SN;
		return (((base <= temp ) && (temp  < umRxIns->vr_uh))||((baseMode <= temp )&&(SN < baseMode + 512)));*/
		return (SN-(umRxIns->vr_uh-512)+1024)%1024 < 512;
    70d9:	29 f2                	sub    %esi,%edx
    70db:	81 c2 00 06 00 00    	add    $0x600,%edx
    70e1:	89 d6                	mov    %edx,%esi
    70e3:	c1 fe 1f             	sar    $0x1f,%esi
    70e6:	c1 ee 16             	shr    $0x16,%esi
    70e9:	01 f2                	add    %esi,%edx
    70eb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    70f1:	29 f2                	sub    %esi,%edx
    70f3:	81 fa ff 01 00 00    	cmp    $0x1ff,%edx
    70f9:	0f 9e c2             	setle  %dl
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] == NULL\n");
		}
		//rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}
	//vr_x<vr_ur,vr-xx != h
	if(umRxIns->reorderTimer &&((umRxIns->vr_ux <= umRxIns->vr_ur||umRxIns->vr_ur<=umRxIns->vr_ux-windows/2)|| \
    70fc:	84 d2                	test   %dl,%dl
    70fe:	0f 85 5e fd ff ff    	jne    6e62 <rlc_pkt_receive_from_mac+0xc2>
								((!isInsideUmRecvWin(umRxIns,umRxIns->vr_ux ))&&(umRxIns->vr_ux != umRxIns->vr_uh))))
    7104:	66 3b 81 c0 10 00 00 	cmp    0x10c0(%ecx),%ax
    710b:	0f 84 51 fd ff ff    	je     6e62 <rlc_pkt_receive_from_mac+0xc2>
    7111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is canceling\n\n");
    7118:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    711b:	c7 04 24 78 26 00 00 	movl   $0x2678,(%esp)
    7122:	e8 fc ff ff ff       	call   7123 <rlc_pkt_receive_from_mac+0x383>
		fsm_schedule_cancel(umRxIns->reorderTimer);
    7127:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    712a:	8b 41 08             	mov    0x8(%ecx),%eax
    712d:	e8 fc ff ff ff       	call   712e <rlc_pkt_receive_from_mac+0x38e>
		umRxIns->reorderTimer = 0;
    7132:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7135:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    713c:	c7 41 08 00 00 00 00 	movl   $0x0,0x8(%ecx)
	}
	//h>r(!=)
	//if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh != umRxIns->vr_ur))//??
	if((!umRxIns->reorderTimer )&&(umRxIns->vr_uh>umRxIns->vr_ur||umRxIns->vr_uh<umRxIns->vr_ur-windows/2))
    7143:	0f b7 81 c0 10 00 00 	movzwl 0x10c0(%ecx),%eax
    714a:	66 39 c7             	cmp    %ax,%di
    714d:	7c 18                	jl     7167 <rlc_pkt_receive_from_mac+0x3c7>
    714f:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    7153:	0f bf ff             	movswl %di,%edi
    7156:	98                   	cwtl   
    7157:	66 d1 ea             	shr    %dx
    715a:	0f b7 d2             	movzwl %dx,%edx
    715d:	29 d7                	sub    %edx,%edi
    715f:	39 f8                	cmp    %edi,%eax
    7161:	0f 8d fb fc ff ff    	jge    6e62 <rlc_pkt_receive_from_mac+0xc2>
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] timer is scheduling\n");
    7167:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    716a:	c7 04 24 b0 26 00 00 	movl   $0x26b0,(%esp)
    7171:	e8 fc ff ff ff       	call   7172 <rlc_pkt_receive_from_mac+0x3d2>
		umRxIns->reorderTimer = fsm_schedule_self(umRxIns->reorderTimerValue, umRxIns->reorderTimerCode);
    7176:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7179:	8b 51 0c             	mov    0xc(%ecx),%edx
    717c:	8b 41 10             	mov    0x10(%ecx),%eax
    717f:	e8 fc ff ff ff       	call   7180 <rlc_pkt_receive_from_mac+0x3e0>
    7184:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7187:	89 41 08             	mov    %eax,0x8(%ecx)
		umRxIns->vr_ux = umRxIns->vr_uh;
		umRxIns->vr_ux %= windows;
    718a:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    7191:	89 c2                	mov    %eax,%edx
    7193:	c1 fa 1f             	sar    $0x1f,%edx
    7196:	f7 fb                	idiv   %ebx
    7198:	66 89 91 be 10 00 00 	mov    %dx,0x10be(%ecx)
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ux is updated to %d\n\n", umRxIns->vr_ux);
    719f:	0f bf d2             	movswl %dx,%edx
    71a2:	89 54 24 04          	mov    %edx,0x4(%esp)
    71a6:	c7 04 24 e8 26 00 00 	movl   $0x26e8,(%esp)
    71ad:	e8 fc ff ff ff       	call   71ae <rlc_pkt_receive_from_mac+0x40e>
    71b2:	e9 ab fc ff ff       	jmp    6e62 <rlc_pkt_receive_from_mac+0xc2>
    71b7:	90                   	nop
	}
	else
	{
		if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
		{
			skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    71b8:	89 d8                	mov    %ebx,%eax
    71ba:	ba 02 00 00 00       	mov    $0x2,%edx
    71bf:	e8 fc ff ff ff       	call   71c0 <rlc_pkt_receive_from_mac+0x420>
    71c4:	89 c3                	mov    %eax,%ebx
    71c6:	e9 5b fc ff ff       	jmp    6e26 <rlc_pkt_receive_from_mac+0x86>
    71cb:	90                   	nop
    71cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(micimsg->lcid, &insptru, &insptrd,&SV(ins_mode));
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
    71d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71d3:	85 c0                	test   %eax,%eax
    71d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    71d8:	0f 84 76 0a 00 00    	je     7c54 <rlc_pkt_receive_from_mac+0xeb4>
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
    71de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    71e1:	0f b7 42 2c          	movzwl 0x2c(%edx),%eax
    71e5:	66 83 f8 0b          	cmp    $0xb,%ax
    71e9:	0f 84 4c 0a 00 00    	je     7c3b <rlc_pkt_receive_from_mac+0xe9b>
    71ef:	66 83 f8 09          	cmp    $0x9,%ax
    71f3:	0f 84 42 0a 00 00    	je     7c3b <rlc_pkt_receive_from_mac+0xe9b>
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    71f9:	e8 fc ff ff ff       	call   71fa <rlc_pkt_receive_from_mac+0x45a>
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
    71fe:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
    7204:	66 c1 06 08          	rolw   $0x8,(%esi)
	int datalen;
	SequenceNumber SN;
	struct list_head *pos;
	int i;	
	FIN(rlc_AM_pkt_receive_from_mac());
	SV_PTR_GET(rlc_mac_sv);
    7208:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	
	fixhead = ( RLC_AMPDU_fixhead *)pkt->data;
	*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
	fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the header is:\n");
    720b:	c7 04 24 7c 1f 00 00 	movl   $0x1f7c,(%esp)
    7212:	e8 fc ff ff ff       	call   7213 <rlc_pkt_receive_from_mac+0x473>
	fsm_octets_print(fixhead,2);
    7217:	ba 02 00 00 00       	mov    $0x2,%edx
    721c:	89 f0                	mov    %esi,%eax
    721e:	e8 fc ff ff ff       	call   721f <rlc_pkt_receive_from_mac+0x47f>
	//fsm_printf("\n[RLC][rlc_AM_pkt_receive_from_mac] entering rlc_AM_pkt_receive_from_mac\n");
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
    7223:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7227:	84 c0                	test   %al,%al
    7229:	0f 89 b1 04 00 00    	jns    76e0 <rlc_pkt_receive_from_mac+0x940>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    722f:	a8 40                	test   $0x40,%al
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7231:	0f b6 16             	movzbl (%esi),%edx
    7234:	0f b6 46 01          	movzbl 0x1(%esi),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is a data PDU\n");
	}
	
//AMD PDU
	if(fixhead->RF == 0)   //AMD PDU
    7238:	0f 84 3a 02 00 00    	je     7478 <rlc_pkt_receive_from_mac+0x6d8>
	}

//AMD PDU 
	else
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
    723e:	83 e0 03             	and    $0x3,%eax
    7241:	c1 e0 08             	shl    $0x8,%eax
    7244:	09 d0                	or     %edx,%eax
    7246:	89 44 24 04          	mov    %eax,0x4(%esp)
    724a:	c7 04 24 38 20 00 00 	movl   $0x2038,(%esp)
    7251:	e8 fc ff ff ff       	call   7252 <rlc_pkt_receive_from_mac+0x4b2>
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
    7256:	8b 8b ac 00 00 00    	mov    0xac(%ebx),%ecx
    725c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    725f:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    7263:	0f b6 16             	movzbl (%esi),%edx
    7266:	83 e0 03             	and    $0x3,%eax
    7269:	c1 e0 08             	shl    $0x8,%eax
    726c:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    726e:	0f bf d0             	movswl %ax,%edx
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU segment (SN is %d)\n", fixhead->SN);
		extseghead = ( RLC_AMPDU_fixhead *)(pkt->data+2);
		seghead = (RLC_AMPDU_seg_head *)fixhead;
		//eghead->head = seghead->head;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] fixhead->SN=%d\n",fixhead->SN);
		SN = fixhead->SN;
    7271:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
    7275:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7278:	89 55 e0             	mov    %edx,-0x20(%ebp)
    727b:	e8 fc ff ff ff       	call   727c <rlc_pkt_receive_from_mac+0x4dc>
    7280:	84 c0                	test   %al,%al
    7282:	0f 84 4b 09 00 00    	je     7bd3 <rlc_pkt_receive_from_mac+0xe33>
    7288:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    728b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    728e:	81 c1 98 04 00 00    	add    $0x498,%ecx
    7294:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
    7298:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    729b:	85 c0                	test   %eax,%eax
    729d:	0f 84 49 07 00 00    	je     79ec <rlc_pkt_receive_from_mac+0xc4c>
    72a3:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    72a7:	0f 84 26 09 00 00    	je     7bd3 <rlc_pkt_receive_from_mac+0xe33>
		//PDU
		else
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not received this PDU segment before(pos is %d)\n", extseghead->SO);
			//
			if(extseghead->LSF == 1)
    72ad:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    72b0:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    72b4:	79 3a                	jns    72f0 <rlc_pkt_receive_from_mac+0x550>
			{
				amIns->amRecvWindow[SN]->pktstatus = LAST_SEGMENT;
    72b6:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
    72bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    72c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72c3:	8b 44 82 0c          	mov    0xc(%edx,%eax,4),%eax
    72c7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    72ca:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    72ce:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    72d2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    72d5:	83 e0 7f             	and    $0x7f,%eax
    72d8:	c1 e0 08             	shl    $0x8,%eax
    72db:	09 d0                	or     %edx,%eax
    72dd:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    72e0:	03 43 50             	add    0x50(%ebx),%eax
    72e3:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
    72e9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    72ec:	8b 44 8a 0c          	mov    0xc(%edx,%ecx,4),%eax
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
    72f0:	89 da                	mov    %ebx,%edx
    72f2:	e8 fc ff ff ff       	call   72f3 <rlc_pkt_receive_from_mac+0x553>
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    72f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    72fa:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    72fd:	8b 44 9a 0c          	mov    0xc(%edx,%ebx,4),%eax
    7301:	8b 10                	mov    (%eax),%edx
    7303:	8b 4a 50             	mov    0x50(%edx),%ecx
    7306:	39 88 98 00 00 00    	cmp    %ecx,0x98(%eax)
    730c:	0f 84 d9 05 00 00    	je     78eb <rlc_pkt_receive_from_mac+0xb4b>
	}

//PDUSN

//vr_h
	if(SN >= amIns->vr_h || SN <= amIns->vr_h-AM_WINDOW_SIZE)
    7312:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7315:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    731c:	66 3b 45 da          	cmp    -0x26(%ebp),%ax
    7320:	7e 0b                	jle    732d <rlc_pkt_receive_from_mac+0x58d>
    7322:	98                   	cwtl   
    7323:	2d 00 02 00 00       	sub    $0x200,%eax
    7328:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    732b:	7f 31                	jg     735e <rlc_pkt_receive_from_mac+0x5be>
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN > amIns->vr_h\n");
    732d:	c7 04 24 f8 20 00 00 	movl   $0x20f8,(%esp)
    7334:	e8 fc ff ff ff       	call   7335 <rlc_pkt_receive_from_mac+0x595>
		amIns->vr_h = (SN + 1)%(AM_WINDOW_SIZE*2);
    7339:	8b 45 e0             	mov    -0x20(%ebp),%eax
    733c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    733f:	83 c0 01             	add    $0x1,%eax
    7342:	25 ff 03 00 00       	and    $0x3ff,%eax
    7347:	66 89 82 ee 22 00 00 	mov    %ax,0x22ee(%edx)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_h is updated to %d\n",amIns->vr_h);
    734e:	89 44 24 04          	mov    %eax,0x4(%esp)
    7352:	c7 04 24 30 21 00 00 	movl   $0x2130,(%esp)
    7359:	e8 fc ff ff ff       	call   735a <rlc_pkt_receive_from_mac+0x5ba>
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    735e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7361:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
    7368:	8b 84 90 6c 12 00 00 	mov    0x126c(%eax,%edx,4),%eax
    736f:	85 c0                	test   %eax,%eax
    7371:	74 0a                	je     737d <rlc_pkt_receive_from_mac+0x5dd>
    7373:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    7377:	0f 84 83 03 00 00    	je     7700 <rlc_pkt_receive_from_mac+0x960>
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    737d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7380:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7383:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    738a:	0f bf c2             	movswl %dx,%eax
    738d:	8b 84 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%eax
    7394:	85 c0                	test   %eax,%eax
    7396:	74 0a                	je     73a2 <rlc_pkt_receive_from_mac+0x602>
    7398:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    739c:	0f 84 6d 05 00 00    	je     790f <rlc_pkt_receive_from_mac+0xb6f>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
	}
	
//x>r,xmr
	if(amIns->reorderTimer &&((amIns->vr_x == amIns->vr_r)||(!isInsideAmRecvWin(amIns, SN)&&(amIns->vr_x != amIns->vr_mr))))
    73a2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    73a5:	8b 41 14             	mov    0x14(%ecx),%eax
    73a8:	85 c0                	test   %eax,%eax
    73aa:	74 4b                	je     73f7 <rlc_pkt_receive_from_mac+0x657>
    73ac:	66 3b 91 f0 22 00 00 	cmp    0x22f0(%ecx),%dx
    73b3:	74 2c                	je     73e1 <rlc_pkt_receive_from_mac+0x641>
    73b5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    73b8:	89 c8                	mov    %ecx,%eax
    73ba:	e8 fc ff ff ff       	call   73bb <rlc_pkt_receive_from_mac+0x61b>
    73bf:	84 c0                	test   %al,%al
    73c1:	0f 85 a1 02 00 00    	jne    7668 <rlc_pkt_receive_from_mac+0x8c8>
    73c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73ca:	0f b7 90 ec 22 00 00 	movzwl 0x22ec(%eax),%edx
    73d1:	66 39 90 f0 22 00 00 	cmp    %dx,0x22f0(%eax)
    73d8:	0f 84 8a 02 00 00    	je     7668 <rlc_pkt_receive_from_mac+0x8c8>
    73de:	8b 40 14             	mov    0x14(%eax),%eax
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
    73e1:	e8 fc ff ff ff       	call   73e2 <rlc_pkt_receive_from_mac+0x642>
		amIns->reorderTimer = 0;
    73e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73e9:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    73f0:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    73f7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    73fa:	0f b7 81 ee 22 00 00 	movzwl 0x22ee(%ecx),%eax
    7401:	66 39 c2             	cmp    %ax,%dx
    7404:	7c 0e                	jl     7414 <rlc_pkt_receive_from_mac+0x674>
    7406:	0f bf d2             	movswl %dx,%edx
    7409:	98                   	cwtl   
    740a:	81 ea 00 02 00 00    	sub    $0x200,%edx
    7410:	39 d0                	cmp    %edx,%eax
    7412:	7d 24                	jge    7438 <rlc_pkt_receive_from_mac+0x698>
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is scheduling\n");
		amIns->reorderTimer = fsm_schedule_self(amIns->reorderTimerValue ,amIns->reorderTimerCode);
    7414:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7417:	8b 50 18             	mov    0x18(%eax),%edx
    741a:	8b 40 1c             	mov    0x1c(%eax),%eax
    741d:	e8 fc ff ff ff       	call   741e <rlc_pkt_receive_from_mac+0x67e>
    7422:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7425:	89 43 14             	mov    %eax,0x14(%ebx)
		amIns->vr_x = amIns->vr_h;
    7428:	0f b7 83 ee 22 00 00 	movzwl 0x22ee(%ebx),%eax
    742f:	66 89 83 f0 22 00 00 	mov    %ax,0x22f0(%ebx)
    7436:	66 90                	xchg   %ax,%ax
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_x is updated to %d\n",amIns->vr_x);
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
    7438:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    743c:	c7 04 24 7c 04 00 00 	movl   $0x47c,(%esp)
    7443:	c0 e8 05             	shr    $0x5,%al
    7446:	83 e0 01             	and    $0x1,%eax
    7449:	89 44 24 04          	mov    %eax,0x4(%esp)
    744d:	e8 fc ff ff ff       	call   744e <rlc_pkt_receive_from_mac+0x6ae>
	if(fixhead->P == 1)
    7452:	f6 46 01 20          	testb  $0x20,0x1(%esi)
    7456:	0f 85 2c 02 00 00    	jne    7688 <rlc_pkt_receive_from_mac+0x8e8>
			//amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
			//fsm_printf("After am receive_from_mac pollRetxRimer is running\n");
			//addpkt_recvData(amIns);				
			rlc_AM_pkt_receive_from_mac(amIns,skb);
			//    fsm_printf("time for rlc_AM_pkt_receive_from_mac(amIns,skb)\n");
			printk("[RLC_MAC AM]SV(countDropPacket):%d\n", SV(countDropPacket));
    745c:	8b 87 9c 5a 00 00    	mov    0x5a9c(%edi),%eax
    7462:	c7 04 24 ac 22 00 00 	movl   $0x22ac,(%esp)
    7469:	89 44 24 04          	mov    %eax,0x4(%esp)
    746d:	e8 fc ff ff ff       	call   746e <rlc_pkt_receive_from_mac+0x6ce>
			FOUT;
    7472:	e9 eb f9 ff ff       	jmp    6e62 <rlc_pkt_receive_from_mac+0xc2>
    7477:	90                   	nop
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7478:	83 e0 03             	and    $0x3,%eax
    747b:	c1 e0 08             	shl    $0x8,%eax
    747e:	09 d0                	or     %edx,%eax
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7480:	0f bf d0             	movswl %ax,%edx
	if(fixhead->RF == 0)   //AMD PDU
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is an AMD PDU (SN is %d)\n", fixhead->SN);
		//head = (RLC_AMPDU_head*) fixhead;
		//head->head = head->head;
		SN = fixhead->SN;
    7483:	66 89 45 da          	mov    %ax,-0x26(%ebp)
		SN %= 1024;
		//SN %= 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the context is %s\n",(char*)(fixhead + 1));
//
		if(!isInsideAmRecvWin(amIns, SN))
    7487:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    748a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    748d:	e8 fc ff ff ff       	call   748e <rlc_pkt_receive_from_mac+0x6ee>
    7492:	84 c0                	test   %al,%al
    7494:	0f 84 45 07 00 00    	je     7bdf <rlc_pkt_receive_from_mac+0xe3f>
				pkt= NULL;
			}			
			FOUT;
		}
//,
		if(amIns->amRecvWindow[SN] != NULL)
    749a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    749d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    74a0:	81 c2 98 04 00 00    	add    $0x498,%edx
    74a6:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    74aa:	89 55 dc             	mov    %edx,-0x24(%ebp)
    74ad:	85 c0                	test   %eax,%eax
    74af:	74 42                	je     74f3 <rlc_pkt_receive_from_mac+0x753>
		{
			if(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)
    74b1:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
    74b5:	0f 84 24 07 00 00    	je     7bdf <rlc_pkt_receive_from_mac+0xe3f>
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received completly\n");
				FOUT;
			}
			else
			{
				if(amIns->amRecvWindow[SN]->pkt != NULL)
    74bb:	8b 10                	mov    (%eax),%edx
    74bd:	85 d2                	test   %edx,%edx
    74bf:	74 1f                	je     74e0 <rlc_pkt_receive_from_mac+0x740>
				{
					fsm_pkt_destroy(amIns->amRecvWindow[SN]->pkt);
    74c1:	89 d0                	mov    %edx,%eax
    74c3:	e8 fc ff ff ff       	call   74c4 <rlc_pkt_receive_from_mac+0x724>
					amIns->amRecvWindow[SN]->pkt = NULL;
    74c8:	8b 55 dc             	mov    -0x24(%ebp),%edx
    74cb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    74ce:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    74d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				}
				if(amIns->amRecvWindow[SN] != NULL)
    74d8:	8b 44 91 0c          	mov    0xc(%ecx,%edx,4),%eax
    74dc:	85 c0                	test   %eax,%eax
    74de:	74 13                	je     74f3 <rlc_pkt_receive_from_mac+0x753>
				{
					fsm_mem_free(amIns->amRecvWindow[SN]);
    74e0:	e8 fc ff ff ff       	call   74e1 <rlc_pkt_receive_from_mac+0x741>
					amIns->amRecvWindow[SN] = NULL;
    74e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    74e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    74eb:	c7 44 82 0c 00 00 00 	movl   $0x0,0xc(%edx,%eax,4)
    74f2:	00 
					//printk("RLC FREE: %d\n", freenum);
				}				
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the packet has been received but not completly\n");
			}
		}
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    74f3:	b8 a4 00 00 00       	mov    $0xa4,%eax
    74f8:	e8 fc ff ff ff       	call   74f9 <rlc_pkt_receive_from_mac+0x759>
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
    74fd:	89 18                	mov    %ebx,(%eax)
		ambuf->pktstatus = FULL_SDU;
		ambuf->pos = 0;
		ambuf->segnum = 0;
		ambuf->SN = SN;
    74ff:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7503:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
		ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
		//mallocnum++;
		//printk("RLC ALLOC: %d\n", mallocnum);
		
		ambuf->pkt = pkt;
		ambuf->pktstatus = FULL_SDU;
    7509:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
		ambuf->pos = 0;
    7510:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		ambuf->segnum = 0;
    7517:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    751e:	00 00 00 
		ambuf->SN = SN;
    7521:	66 89 98 94 00 00 00 	mov    %bx,0x94(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    7528:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    752b:	8b 93 60 02 00 00    	mov    0x260(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7531:	89 8b 60 02 00 00    	mov    %ecx,0x260(%ebx)
		list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7537:	81 c3 5c 02 00 00    	add    $0x25c,%ebx
    753d:	89 98 9c 00 00 00    	mov    %ebx,0x9c(%eax)
		amIns->amRecvWindow[SN] = ambuf;
    7543:	8b 5d dc             	mov    -0x24(%ebp),%ebx
	new->next = next;
	new->prev = prev;
    7546:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
    754c:	89 0a                	mov    %ecx,(%edx)
    754e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7551:	89 44 9a 0c          	mov    %eax,0xc(%edx,%ebx,4)
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
    7555:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7558:	c7 04 24 ec 1f 00 00 	movl   $0x1fec,(%esp)
    755f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7563:	e8 fc ff ff ff       	call   7564 <rlc_pkt_receive_from_mac+0x7c4>
    7568:	e9 a5 fd ff ff       	jmp    7312 <rlc_pkt_receive_from_mac+0x572>
    756d:	8d 76 00             	lea    0x0(%esi),%esi
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] um instance's snFiledLength is %d\n",umRxIns->snFiledLength);
	switch(umRxIns->snFiledLength)
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
    7570:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    7576:	0f b6 00             	movzbl (%eax),%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
    7579:	89 c6                	mov    %eax,%esi
    757b:	83 e6 1f             	and    $0x1f,%esi
    757e:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
    7582:	0f bf f6             	movswl %si,%esi
    7585:	8b 44 b1 38          	mov    0x38(%ecx,%esi,4),%eax
    7589:	85 c0                	test   %eax,%eax
    758b:	0f 85 78 06 00 00    	jne    7c09 <rlc_pkt_receive_from_mac+0xe69>
    7591:	89 c8                	mov    %ecx,%eax
    7593:	89 f2                	mov    %esi,%edx
    7595:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7598:	e8 fc ff ff ff       	call   7599 <rlc_pkt_receive_from_mac+0x7f9>
    759d:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    75a0:	84 c0                	test   %al,%al
    75a2:	0f 85 61 06 00 00    	jne    7c09 <rlc_pkt_receive_from_mac+0xe69>
	{
	case 5:
		head_size5 = (RLC_UM_size5_head *)pkt->data;
		SN = head_size5->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
    75a8:	66 c7 45 e0 20 00    	movw   $0x20,-0x20(%ebp)
    75ae:	e9 ab f9 ff ff       	jmp    6f5e <rlc_pkt_receive_from_mac+0x1be>
    75b3:	90                   	nop
    75b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
    75b8:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    75be:	ba 02 00 00 00       	mov    $0x2,%edx
    75c3:	66 c1 00 08          	rolw   $0x8,(%eax)
		//fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] the context is %s\n", (char*)(head_size5 + 1));
		break;
	case 10:
		//head_size10 = (RLC_UM_size10_head*)pkt->data;
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
    75c7:	8b b3 ac 00 00 00    	mov    0xac(%ebx),%esi
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
    75cd:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    75d0:	89 f0                	mov    %esi,%eax
    75d2:	e8 fc ff ff ff       	call   75d3 <rlc_pkt_receive_from_mac+0x833>
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    75d7:	0f b6 46 01          	movzbl 0x1(%esi),%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    75db:	8b 4d b8             	mov    -0x48(%ebp),%ecx
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    75de:	0f b6 16             	movzbl (%esi),%edx
    75e1:	83 e0 03             	and    $0x3,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    75e4:	0f bf b9 bc 10 00 00 	movswl 0x10bc(%ecx),%edi
		*(u16 *)pkt->data = ntohs(*(u16 *)pkt->data);
		head_subhead = (RLC_UM_size10_subhead *)pkt->data;
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
    75eb:	c1 e0 08             	shl    $0x8,%eax
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    75ee:	09 d0                	or     %edx,%eax
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    75f0:	0f bf f0             	movswl %ax,%esi
    75f3:	89 f2                	mov    %esi,%edx
    75f5:	29 fa                	sub    %edi,%edx
    75f7:	81 c2 00 04 00 00    	add    $0x400,%edx
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
		SN %= windows;
    75fd:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
		if((umRxIns->umRecvWindow10[SN] != NULL ))
		{
			printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received");
		}*/
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
    7601:	89 d0                	mov    %edx,%eax
    7603:	c1 f8 1f             	sar    $0x1f,%eax
    7606:	c1 e8 16             	shr    $0x16,%eax
    7609:	01 c2                	add    %eax,%edx
    760b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    7611:	29 c2                	sub    %eax,%edx
    7613:	0f bf 81 c0 10 00 00 	movswl 0x10c0(%ecx),%eax
    761a:	29 f8                	sub    %edi,%eax
    761c:	05 00 04 00 00       	add    $0x400,%eax
    7621:	89 c7                	mov    %eax,%edi
    7623:	c1 ff 1f             	sar    $0x1f,%edi
    7626:	c1 ef 16             	shr    $0x16,%edi
    7629:	01 f8                	add    %edi,%eax
    762b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7630:	29 f8                	sub    %edi,%eax
    7632:	39 c2                	cmp    %eax,%edx
    7634:	7d 0f                	jge    7645 <rlc_pkt_receive_from_mac+0x8a5>
    7636:	8b bc b1 b8 00 00 00 	mov    0xb8(%ecx,%esi,4),%edi
    763d:	85 ff                	test   %edi,%edi
    763f:	0f 85 6c 05 00 00    	jne    7bb1 <rlc_pkt_receive_from_mac+0xe11>
    7645:	89 c8                	mov    %ecx,%eax
    7647:	89 f2                	mov    %esi,%edx
    7649:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    764c:	e8 fc ff ff ff       	call   764d <rlc_pkt_receive_from_mac+0x8ad>
    7651:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7654:	84 c0                	test   %al,%al
    7656:	0f 85 55 05 00 00    	jne    7bb1 <rlc_pkt_receive_from_mac+0xe11>
		//*(u16 *)head_subhead = ntohs(*(u16 *)head_subhead);
		fsm_octets_print(head_subhead,2);
		//head_size10->head = fsm_ntohs(head_size10->head);
		SN = head_subhead->SN;		
		base = umRxIns->vr_uh - UM_WINDOW_SIZE10 ;
		windows = UM_WINDOW_SIZE10 *2;
    765c:	66 c7 45 e0 00 04    	movw   $0x400,-0x20(%ebp)
    7662:	e9 f7 f8 ff ff       	jmp    6f5e <rlc_pkt_receive_from_mac+0x1be>
    7667:	90                   	nop
	{
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] timer is canceling\n");
		fsm_schedule_cancel(amIns->reorderTimer);
		amIns->reorderTimer = 0;
	}
	if(!amIns->reorderTimer &&(amIns->vr_h > amIns->vr_r||amIns->vr_h < amIns->vr_r - AM_WINDOW_SIZE))
    7668:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    766b:	8b 50 14             	mov    0x14(%eax),%edx
    766e:	85 d2                	test   %edx,%edx
    7670:	0f 85 c2 fd ff ff    	jne    7438 <rlc_pkt_receive_from_mac+0x698>
    7676:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    767d:	e9 75 fd ff ff       	jmp    73f7 <rlc_pkt_receive_from_mac+0x657>
    7682:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
//
	fsm_printf("[RLC] fixhead->P = %d\n",fixhead->P);
	if(fixhead->P == 1)
	{
		fsm_printf("[RLC] amIns->statProhTimer = %d\n",amIns->statProhTimer);
    7688:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    768b:	8b 46 20             	mov    0x20(%esi),%eax
    768e:	c7 04 24 4c 22 00 00 	movl   $0x224c,(%esp)
    7695:	89 44 24 04          	mov    %eax,0x4(%esp)
    7699:	e8 fc ff ff ff       	call   769a <rlc_pkt_receive_from_mac+0x8fa>
		//
		if( !amIns->statProhTimer )
    769e:	8b 46 20             	mov    0x20(%esi),%eax
    76a1:	85 c0                	test   %eax,%eax
    76a3:	0f 85 b3 fd ff ff    	jne    745c <rlc_pkt_receive_from_mac+0x6bc>
		{
			amIns->statFlag = true;
    76a9:	c6 46 06 01          	movb   $0x1,0x6(%esi)
			fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] the statProhTimer start\n");
    76ad:	c7 04 24 70 22 00 00 	movl   $0x2270,(%esp)
    76b4:	e8 fc ff ff ff       	call   76b5 <rlc_pkt_receive_from_mac+0x915>
			amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    76b9:	8b 56 24             	mov    0x24(%esi),%edx
    76bc:	8b 46 28             	mov    0x28(%esi),%eax
    76bf:	e8 fc ff ff ff       	call   76c0 <rlc_pkt_receive_from_mac+0x920>
    76c4:	89 46 20             	mov    %eax,0x20(%esi)
    76c7:	e9 90 fd ff ff       	jmp    745c <rlc_pkt_receive_from_mac+0x6bc>
    76cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	umbuf->SN = SN;
	list_add_tail(&umbuf->list, &umRxIns->umRecvBuffer.list);
	fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] pkt has been put into buffer(SN is %d)\n", SN);
	if(umRxIns->snFiledLength == 5)
	{
		umRxIns->umRecvWindow5[SN] = umbuf;
    76d0:	89 7c b1 38          	mov    %edi,0x38(%ecx,%esi,4)
    76d4:	e9 e6 f8 ff ff       	jmp    6fbf <rlc_pkt_receive_from_mac+0x21f>
    76d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    76e0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
		rlc_ctrl_pkt_recv(amIns, pkt);
    76e3:	89 da                	mov    %ebx,%edx
	//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] data len = %d\n",pkt->len);
//PDU
	if(fixhead->DorC == 0)		 //cntrol pdu
	{
		//printk("[RLC][rlc_AM_pkt_receive_from_mac] this is a ctrl PDU\n");
		SV(countRecvCtrlPdu)++;
    76e5:	83 80 a4 5a 00 00 01 	addl   $0x1,0x5aa4(%eax)
		rlc_ctrl_pkt_recv(amIns, pkt);
    76ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    76ef:	e8 fc ff ff ff       	call   76f0 <rlc_pkt_receive_from_mac+0x950>
    76f4:	e9 63 fd ff ff       	jmp    745c <rlc_pkt_receive_from_mac+0x6bc>
    76f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    7700:	8d 42 01             	lea    0x1(%edx),%eax
    7703:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7706:	89 c1                	mov    %eax,%ecx
    7708:	c1 f9 1f             	sar    $0x1f,%ecx
    770b:	c1 e9 16             	shr    $0x16,%ecx
    770e:	01 c8                	add    %ecx,%eax
    7710:	25 ff 03 00 00       	and    $0x3ff,%eax
    7715:	29 c8                	sub    %ecx,%eax
    7717:	66 89 83 f2 22 00 00 	mov    %ax,0x22f2(%ebx)
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    771e:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7725:	85 d2                	test   %edx,%edx
    7727:	74 3b                	je     7764 <rlc_pkt_receive_from_mac+0x9c4>
    7729:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    772d:	75 35                	jne    7764 <rlc_pkt_receive_from_mac+0x9c4>
    772f:	89 d9                	mov    %ebx,%ecx
    7731:	eb 0b                	jmp    773e <rlc_pkt_receive_from_mac+0x99e>
    7733:	90                   	nop
    7734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    7738:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    773c:	75 26                	jne    7764 <rlc_pkt_receive_from_mac+0x9c4>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
    773e:	83 c0 01             	add    $0x1,%eax
    7741:	89 c2                	mov    %eax,%edx
    7743:	c1 fa 1f             	sar    $0x1f,%edx
    7746:	c1 ea 16             	shr    $0x16,%edx
    7749:	01 d0                	add    %edx,%eax
    774b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7750:	29 d0                	sub    %edx,%eax
    7752:	66 89 81 f2 22 00 00 	mov    %ax,0x22f2(%ecx)

//vr_ms
	if((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
	{
		amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		while((amIns->amRecvWindow[amIns->vr_ms] != NULL)&&(amIns->amRecvWindow[amIns->vr_ms]->pktstatus == FULL_SDU))
    7759:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7760:	85 d2                	test   %edx,%edx
    7762:	75 d4                	jne    7738 <rlc_pkt_receive_from_mac+0x998>
		{
			amIns->vr_ms = (amIns->vr_ms + 1)%1024;
		}
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
    7764:	89 44 24 04          	mov    %eax,0x4(%esp)
    7768:	c7 04 24 74 21 00 00 	movl   $0x2174,(%esp)
    776f:	e8 fc ff ff ff       	call   7770 <rlc_pkt_receive_from_mac+0x9d0>
    7774:	e9 04 fc ff ff       	jmp    737d <rlc_pkt_receive_from_mac+0x5dd>
	}
	
	//vr_ur
	if(umRxIns->snFiledLength == 5)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
    7779:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    777c:	c7 04 24 ac 25 00 00 	movl   $0x25ac,(%esp)
    7783:	e8 fc ff ff ff       	call   7784 <rlc_pkt_receive_from_mac+0x9e4>
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
    7788:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    778b:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    7792:	0f bf c7             	movswl %di,%eax
    7795:	8b 74 81 38          	mov    0x38(%ecx,%eax,4),%esi
    7799:	85 f6                	test   %esi,%esi
    779b:	0f 84 f3 f8 ff ff    	je     7094 <rlc_pkt_receive_from_mac+0x2f4>
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    77a1:	83 c0 01             	add    $0x1,%eax
    77a4:	89 c2                	mov    %eax,%edx
    77a6:	c1 fa 1f             	sar    $0x1f,%edx
    77a9:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    77ab:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 5\n");
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    77ae:	89 d7                	mov    %edx,%edi
    77b0:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    77b7:	8b 54 81 38          	mov    0x38(%ecx,%eax,4),%edx
    77bb:	85 d2                	test   %edx,%edx
    77bd:	74 31                	je     77f0 <rlc_pkt_receive_from_mac+0xa50>
    77bf:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    77c6:	66 39 fe             	cmp    %di,%si
    77c9:	7d 0a                	jge    77d5 <rlc_pkt_receive_from_mac+0xa35>
    77cb:	eb 23                	jmp    77f0 <rlc_pkt_receive_from_mac+0xa50>
    77cd:	8d 76 00             	lea    0x0(%esi),%esi
    77d0:	66 39 d6             	cmp    %dx,%si
    77d3:	7c 14                	jl     77e9 <rlc_pkt_receive_from_mac+0xa49>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    77d5:	83 c0 01             	add    $0x1,%eax
    77d8:	89 c2                	mov    %eax,%edx
    77da:	c1 fa 1f             	sar    $0x1f,%edx
    77dd:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)
		{
			//fsm_printf("umbuf->SN  ==  umRxIns->vr_ur is %d\n", umRxIns->vr_ur);
			//while((umRxIns->umRecvWindow5[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow5[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    77df:	0f bf c2             	movswl %dx,%eax
    77e2:	83 7c 81 38 00       	cmpl   $0x0,0x38(%ecx,%eax,4)
    77e7:	75 e7                	jne    77d0 <rlc_pkt_receive_from_mac+0xa30>
    77e9:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    77f0:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    77f3:	89 44 24 04          	mov    %eax,0x4(%esp)
    77f7:	c7 04 24 68 25 00 00 	movl   $0x2568,(%esp)
    77fe:	e8 fc ff ff ff       	call   77ff <rlc_pkt_receive_from_mac+0xa5f>
			rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    7803:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7806:	8d 51 18             	lea    0x18(%ecx),%edx
    7809:	89 c8                	mov    %ecx,%eax
    780b:	e8 fc ff ff ff       	call   780c <rlc_pkt_receive_from_mac+0xa6c>
    7810:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7813:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    781a:	e9 75 f8 ff ff       	jmp    7094 <rlc_pkt_receive_from_mac+0x2f4>
		//rlc_UM5_reassemble_deliver(umRxIns,&umRxIns->pduLft,icimsg);
	}

	else if(umRxIns->snFiledLength == 10)
	{
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
    781f:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    7826:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    7829:	c7 04 24 dc 25 00 00 	movl   $0x25dc,(%esp)
    7830:	89 44 24 04          	mov    %eax,0x4(%esp)
    7834:	e8 fc ff ff ff       	call   7835 <rlc_pkt_receive_from_mac+0xa95>
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
    7839:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    783c:	0f b7 b9 bc 10 00 00 	movzwl 0x10bc(%ecx),%edi
    7843:	0f bf c7             	movswl %di,%eax
    7846:	8b b4 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%esi
    784d:	85 f6                	test   %esi,%esi
    784f:	0f 84 3f f8 ff ff    	je     7094 <rlc_pkt_receive_from_mac+0x2f4>
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
    7855:	c7 04 24 24 26 00 00 	movl   $0x2624,(%esp)
    785c:	e8 fc ff ff ff       	call   785d <rlc_pkt_receive_from_mac+0xabd>
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7861:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    7864:	0f bf 81 bc 10 00 00 	movswl 0x10bc(%ecx),%eax
    786b:	83 c0 01             	add    $0x1,%eax
    786e:	89 c2                	mov    %eax,%edx
    7870:	c1 fa 1f             	sar    $0x1f,%edx
    7873:	f7 fb                	idiv   %ebx
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7875:	0f bf c2             	movswl %dx,%eax
		fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] entering 10, umRxIns->vr_ur = %d\n",umRxIns->vr_ur);
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    7878:	89 d7                	mov    %edx,%edi
    787a:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    7881:	8b 94 81 b8 00 00 00 	mov    0xb8(%ecx,%eax,4),%edx
    7888:	85 d2                	test   %edx,%edx
    788a:	74 37                	je     78c3 <rlc_pkt_receive_from_mac+0xb23>
    788c:	0f b7 b1 c0 10 00 00 	movzwl 0x10c0(%ecx),%esi
    7893:	66 39 f7             	cmp    %si,%di
    7896:	7e 0d                	jle    78a5 <rlc_pkt_receive_from_mac+0xb05>
    7898:	eb 29                	jmp    78c3 <rlc_pkt_receive_from_mac+0xb23>
    789a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    78a0:	66 39 f2             	cmp    %si,%dx
    78a3:	7f 17                	jg     78bc <rlc_pkt_receive_from_mac+0xb1c>
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
    78a5:	83 c0 01             	add    $0x1,%eax
    78a8:	89 c2                	mov    %eax,%edx
    78aa:	c1 fa 1f             	sar    $0x1f,%edx
    78ad:	f7 fb                	idiv   %ebx
		if(umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL\n");
			//fsm_printf("umbuw10[++umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ));
			umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			while((umRxIns->umRecvWindow10[umRxIns->vr_ur] != NULL)&&(umRxIns->vr_ur <= umRxIns->vr_uh ))
    78af:	0f bf c2             	movswl %dx,%eax
    78b2:	83 bc 81 b8 00 00 00 	cmpl   $0x0,0xb8(%ecx,%eax,4)
    78b9:	00 
    78ba:	75 e4                	jne    78a0 <rlc_pkt_receive_from_mac+0xb00>
    78bc:	66 89 91 bc 10 00 00 	mov    %dx,0x10bc(%ecx)
			{
				umRxIns->vr_ur = (umRxIns->vr_ur + 1) % windows;
			}
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] umRxIns->vr_ur is updated to %d\n", umRxIns->vr_ur);
    78c3:	89 4d b8             	mov    %ecx,-0x48(%ebp)
    78c6:	89 44 24 04          	mov    %eax,0x4(%esp)
    78ca:	c7 04 24 68 25 00 00 	movl   $0x2568,(%esp)
    78d1:	e8 fc ff ff ff       	call   78d2 <rlc_pkt_receive_from_mac+0xb32>
			//while((umRxIns->umRecvWindo
			rlc_UM_reassemble_deliver(umRxIns,&umRxIns->pduLft);
    78d6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    78d9:	8d 51 18             	lea    0x18(%ecx),%edx
    78dc:	89 c8                	mov    %ecx,%eax
    78de:	e8 fc ff ff ff       	call   78df <rlc_pkt_receive_from_mac+0xb3f>
    78e3:	8b 4d b8             	mov    -0x48(%ebp),%ecx
    78e6:	e9 a2 f7 ff ff       	jmp    708d <rlc_pkt_receive_from_mac+0x2ed>
				amIns->amRecvWindow[SN]->datalen = extseghead->SO + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", amIns->amRecvWindow[SN]->datalen );
			}
			assamble_segment(amIns->amRecvWindow[SN], pkt);
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been assambled into buffer(SN is %d)\n", SN);
			if((amIns->amRecvWindow[SN]->datalen == amIns->amRecvWindow[SN]->pkt->len)&&\
    78eb:	83 b8 90 00 00 00 01 	cmpl   $0x1,0x90(%eax)
    78f2:	0f 85 1a fa ff ff    	jne    7312 <rlc_pkt_receive_from_mac+0x572>
				(amIns->amRecvWindow[SN]->segnum == 1)&&(amIns->amRecvWindow[SN]->segStart[0] == 0))
    78f8:	8b 48 10             	mov    0x10(%eax),%ecx
    78fb:	85 c9                	test   %ecx,%ecx
    78fd:	0f 85 0f fa ff ff    	jne    7312 <rlc_pkt_receive_from_mac+0x572>
			{
				amIns->amRecvWindow[SN]->pktstatus = FULL_SDU;
    7903:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
    790a:	e9 03 fa ff ff       	jmp    7312 <rlc_pkt_receive_from_mac+0x572>
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_ms has received completly and updated to %d\n",amIns->vr_ms);
	}
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
    790f:	c7 04 24 d0 21 00 00 	movl   $0x21d0,(%esp)
    7916:	e8 fc ff ff ff       	call   7917 <rlc_pkt_receive_from_mac+0xb77>
		amIns->vr_r = (amIns->vr_r+1)%1024;
    791b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    791e:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
    7925:	83 c0 01             	add    $0x1,%eax
    7928:	89 c2                	mov    %eax,%edx
    792a:	c1 fa 1f             	sar    $0x1f,%edx
    792d:	c1 ea 16             	shr    $0x16,%edx
    7930:	01 d0                	add    %edx,%eax
    7932:	25 ff 03 00 00       	and    $0x3ff,%eax
    7937:	29 d0                	sub    %edx,%eax
    7939:	66 89 83 f4 22 00 00 	mov    %ax,0x22f4(%ebx)
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7940:	8b 94 83 6c 12 00 00 	mov    0x126c(%ebx,%eax,4),%edx
    7947:	85 d2                	test   %edx,%edx
    7949:	74 39                	je     7984 <rlc_pkt_receive_from_mac+0xbe4>
    794b:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    794f:	75 33                	jne    7984 <rlc_pkt_receive_from_mac+0xbe4>
    7951:	89 d9                	mov    %ebx,%ecx
    7953:	eb 09                	jmp    795e <rlc_pkt_receive_from_mac+0xbbe>
    7955:	8d 76 00             	lea    0x0(%esi),%esi
    7958:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
    795c:	75 26                	jne    7984 <rlc_pkt_receive_from_mac+0xbe4>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
    795e:	83 c0 01             	add    $0x1,%eax
    7961:	89 c2                	mov    %eax,%edx
    7963:	c1 fa 1f             	sar    $0x1f,%edx
    7966:	c1 ea 16             	shr    $0x16,%edx
    7969:	01 d0                	add    %edx,%eax
    796b:	25 ff 03 00 00       	and    $0x3ff,%eax
    7970:	29 d0                	sub    %edx,%eax
    7972:	66 89 81 f4 22 00 00 	mov    %ax,0x22f4(%ecx)
//vr_r
	if((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
	{
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] SN == amIns->vr_r\n");
		amIns->vr_r = (amIns->vr_r+1)%1024;
		while((amIns->amRecvWindow[amIns->vr_r] != NULL)&&(amIns->amRecvWindow[amIns->vr_r]->pktstatus == FULL_SDU))
    7979:	8b 94 81 6c 12 00 00 	mov    0x126c(%ecx,%eax,4),%edx
    7980:	85 d2                	test   %edx,%edx
    7982:	75 d4                	jne    7958 <rlc_pkt_receive_from_mac+0xbb8>
		{
			amIns->vr_r = (amIns->vr_r+1)%1024;
		}
		amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 1024;
    7984:	05 00 02 00 00       	add    $0x200,%eax
    7989:	89 c2                	mov    %eax,%edx
    798b:	c1 fa 1f             	sar    $0x1f,%edx
    798e:	c1 ea 16             	shr    $0x16,%edx
    7991:	01 d0                	add    %edx,%eax
    7993:	25 ff 03 00 00       	and    $0x3ff,%eax
    7998:	29 d0                	sub    %edx,%eax
    799a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    799d:	66 89 82 ec 22 00 00 	mov    %ax,0x22ec(%edx)
		//amIns->vr_mr = (amIns->vr_r + AM_WINDOW_SIZE) % 512;
		//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] amIns->vr_r is updated to %d, amIns->vr_mr is updated to %d\n",amIns->vr_r, amIns->vr_mr);
		fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] Enter rlc_AM_reassemble_deliver\n");
    79a4:	c7 04 24 08 22 00 00 	movl   $0x2208,(%esp)
    79ab:	e8 fc ff ff ff       	call   79ac <rlc_pkt_receive_from_mac+0xc0c>
		rlc_AM_reassemble_deliver(amIns,&(amIns->pduLft));
    79b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    79b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    79b6:	83 c2 30             	add    $0x30,%edx
    79b9:	e8 fc ff ff ff       	call   79ba <rlc_pkt_receive_from_mac+0xc1a>
    79be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    79c1:	0f b7 90 f4 22 00 00 	movzwl 0x22f4(%eax),%edx
    79c8:	e9 d5 f9 ff ff       	jmp    73a2 <rlc_pkt_receive_from_mac+0x602>
		}
		baseMode = temp % 32;
		fsm_printf("[RLC][isInsideUmRecvWin] baseMode is %d\n",baseMode);
		temp = SN;
		return (((base <= temp) && (temp  < umRxIns->vr_uh))||((baseMode <= temp)&&(temp < baseMode + 16)));*/
		return (SN-(umRxIns->vr_uh-16)+32)%32 < 16;
    79cd:	29 f2                	sub    %esi,%edx
    79cf:	83 c2 30             	add    $0x30,%edx
    79d2:	89 d6                	mov    %edx,%esi
    79d4:	c1 fe 1f             	sar    $0x1f,%esi
    79d7:	c1 ee 1b             	shr    $0x1b,%esi
    79da:	01 f2                	add    %esi,%edx
    79dc:	83 e2 1f             	and    $0x1f,%edx
    79df:	29 f2                	sub    %esi,%edx
    79e1:	83 fa 0f             	cmp    $0xf,%edx
    79e4:	0f 9e c2             	setle  %dl
    79e7:	e9 10 f7 ff ff       	jmp    70fc <rlc_pkt_receive_from_mac+0x35c>

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    79ec:	b8 a4 00 00 00       	mov    $0xa4,%eax
    79f1:	e8 fc ff ff ff       	call   79f2 <rlc_pkt_receive_from_mac+0xc52>
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    79f6:	8b 4d d0             	mov    -0x30(%ebp),%ecx

		//PDU
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
    79f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    79fc:	0f b6 41 03          	movzbl 0x3(%ecx),%eax
    7a00:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
    7a04:	83 e0 7f             	and    $0x7f,%eax
    7a07:	c1 e0 08             	shl    $0x8,%eax
    7a0a:	09 d0                	or     %edx,%eax
    7a0c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
			if(0 == ambuf->pos)
    7a0f:	85 c0                	test   %eax,%eax
		if(amIns->amRecvWindow[SN] == NULL)
		{
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] instance has not receive this PDU segment before(pos is %d)\n", extseghead->SO);
			ambuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer ));
			//ambuf->pkt = pkt;
			ambuf->pos = extseghead->SO;
    7a11:	89 42 08             	mov    %eax,0x8(%edx)
			if(0 == ambuf->pos)
    7a14:	0f 85 e6 00 00 00    	jne    7b00 <rlc_pkt_receive_from_mac+0xd60>
			{
				ambuf->pkt = pkt;
    7a1a:	89 1a                	mov    %ebx,(%edx)
    7a1c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7a23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a26:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
			ambuf->segnum = 1;
			ambuf->datalen = 0;
			if(extseghead->LSF == 1)
    7a2a:	8b 4d d0             	mov    -0x30(%ebp),%ecx
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
			ambuf->segnum = 1;
    7a2d:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    7a34:	00 00 00 
					fsm_pkt_destroy(pkt);
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
			}
			ambuf->SN = SN;
    7a37:	66 89 90 94 00 00 00 	mov    %dx,0x94(%eax)
			ambuf->segnum = 1;
			ambuf->datalen = 0;
    7a3e:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
    7a45:	00 00 00 
			if(extseghead->LSF == 1)
    7a48:	80 79 03 00          	cmpb   $0x0,0x3(%ecx)
    7a4c:	0f 89 9f 00 00 00    	jns    7af1 <rlc_pkt_receive_from_mac+0xd51>
			{
				ambuf->pktstatus = LAST_SEGMENT;
    7a52:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
				ambuf->datalen = ambuf->pos + pkt->len;
    7a59:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7a5c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7a5f:	03 43 50             	add    0x50(%ebx),%eax
    7a62:	89 82 98 00 00 00    	mov    %eax,0x98(%edx)
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
    7a68:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a6b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7a6e:	89 50 10             	mov    %edx,0x10(%eax)
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7a71:	8b 4b 50             	mov    0x50(%ebx),%ecx
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7a74:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7a7a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    7a7d:	31 c9                	xor    %ecx,%ecx
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7a7f:	f6 40 01 04          	testb  $0x4,0x1(%eax)
    7a83:	74 19                	je     7a9e <rlc_pkt_receive_from_mac+0xcfe>
	{
		count++;
		while(1 == (ind++)->E)
    7a85:	80 78 05 00          	cmpb   $0x0,0x5(%eax)
    7a89:	b1 01                	mov    $0x1,%cl
    7a8b:	79 11                	jns    7a9e <rlc_pkt_receive_from_mac+0xcfe>
    7a8d:	83 c0 06             	add    $0x6,%eax
    7a90:	0f b6 50 01          	movzbl 0x1(%eax),%edx
		{
			count++;
    7a94:	83 c1 01             	add    $0x1,%ecx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    7a97:	83 c0 02             	add    $0x2,%eax
    7a9a:	84 d2                	test   %dl,%dl
    7a9c:	78 f2                	js     7a90 <rlc_pkt_receive_from_mac+0xcf0>
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7a9e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7aa1:	8b 5d cc             	mov    -0x34(%ebp),%ebx
    7aa4:	8d 54 18 fc          	lea    -0x4(%eax,%ebx,1),%edx
    7aa8:	0f b7 c1             	movzwl %cx,%eax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    7aab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    7aae:	f7 d8                	neg    %eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7ab0:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
			}
			ambuf->segStart[0] = ambuf->pos;
			ambuf->segEnd[0] =ambuf->pos + pkt->len -4 -2*countSegInd(pkt);
    7ab3:	8d 04 42             	lea    (%edx,%eax,2),%eax
    7ab6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    7ab9:	89 42 50             	mov    %eax,0x50(%edx)
    7abc:	8b 81 60 02 00 00    	mov    0x260(%ecx),%eax
			list_add_tail(&ambuf->list, &amIns->amRecvBuffer.list);
    7ac2:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    7ac8:	89 91 60 02 00 00    	mov    %edx,0x260(%ecx)
    7ace:	81 c1 5c 02 00 00    	add    $0x25c,%ecx
    7ad4:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    7ada:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    7ae0:	89 10                	mov    %edx,(%eax)
			//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] pkt segment has been put into buffer(SN is %d)\n", SN);
			amIns->amRecvWindow[SN] = ambuf;
    7ae2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7ae5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    7ae8:	89 5c 82 0c          	mov    %ebx,0xc(%edx,%eax,4)
    7aec:	e9 21 f8 ff ff       	jmp    7312 <rlc_pkt_receive_from_mac+0x572>
				ambuf->datalen = ambuf->pos + pkt->len;
				//fsm_printf("[RLC][rlc_AM_pkt_receive_from_mac] this is the last segment, and the total len of original PDU is %d\n", ambuf->datalen );
			}
			else
			{
				ambuf->pktstatus = ANY_SEGMENT;
    7af1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7af4:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
    7afb:	e9 68 ff ff ff       	jmp    7a68 <rlc_pkt_receive_from_mac+0xcc8>
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7b00:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    7b03:	0f b6 51 03          	movzbl 0x3(%ecx),%edx
    7b07:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
    7b0b:	8b 4b 50             	mov    0x50(%ebx),%ecx
    7b0e:	83 e2 7f             	and    $0x7f,%edx
    7b11:	c1 e2 08             	shl    $0x8,%edx
    7b14:	09 c2                	or     %eax,%edx
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7b16:	89 d8                	mov    %ebx,%eax
				ambuf->pkt = pkt;
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
    7b18:	01 ca                	add    %ecx,%edx
    7b1a:	89 55 cc             	mov    %edx,-0x34(%ebp)
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7b1d:	e8 fc ff ff ff       	call   7b1e <rlc_pkt_receive_from_mac+0xd7e>
    7b22:	03 45 cc             	add    -0x34(%ebp),%eax
    7b25:	e8 fc ff ff ff       	call   7b26 <rlc_pkt_receive_from_mac+0xd86>
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
    7b2a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    7b30:	89 55 c8             	mov    %edx,-0x38(%ebp)
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7b33:	8b 4d c8             	mov    -0x38(%ebp),%ecx
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/
u16 countSegInd(FSM_PKT *pkt)
{
	u16 count = 0;
    7b36:	31 d2                	xor    %edx,%edx
			}
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
    7b38:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7b3b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    7b41:	89 45 c0             	mov    %eax,-0x40(%ebp)
{
	u16 count = 0;
	RLC_AMPDU_fixhead* head = (RLC_AMPDU_fixhead*)(pkt->data);
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
    7b44:	f6 41 01 04          	testb  $0x4,0x1(%ecx)
    7b48:	74 1b                	je     7b65 <rlc_pkt_receive_from_mac+0xdc5>
	{
		count++;
		while(1 == (ind++)->E)
    7b4a:	80 79 05 00          	cmpb   $0x0,0x5(%ecx)
    7b4e:	b2 01                	mov    $0x1,%dl
    7b50:	79 13                	jns    7b65 <rlc_pkt_receive_from_mac+0xdc5>
    7b52:	89 c8                	mov    %ecx,%eax
    7b54:	83 c0 06             	add    $0x6,%eax
    7b57:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
		{
			count++;
    7b5b:	83 c2 01             	add    $0x1,%edx
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind*)(head + 2);
	
	if(1 == head->E )
	{
		count++;
		while(1 == (ind++)->E)
    7b5e:	83 c0 02             	add    $0x2,%eax
    7b61:	84 c9                	test   %cl,%cl
    7b63:	78 f2                	js     7b57 <rlc_pkt_receive_from_mac+0xdb7>
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7b65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7b68:	8b 4b 50             	mov    0x50(%ebx),%ecx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7b6b:	8b 40 08             	mov    0x8(%eax),%eax
    7b6e:	89 45 bc             	mov    %eax,-0x44(%ebp)
    7b71:	0f b7 c2             	movzwl %dx,%eax
    7b74:	8b 55 bc             	mov    -0x44(%ebp),%edx
    7b77:	8d 44 42 04          	lea    0x4(%edx,%eax,2),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7b7b:	8b 55 c8             	mov    -0x38(%ebp),%edx
			else
			{
				//pdu
				datalen = pkt->len + extseghead->SO;
				pkptr = fsm_pkt_create(datalen + fsm_skb_headroom(pkt));
				bufptr =  pkptr->data + 4 + 2*countSegInd(pkt) + ambuf->pos;
    7b7e:	03 45 c0             	add    -0x40(%ebp),%eax
	//	fsm_printf("the count of this segment is %d\n", countSegInd(ambuf->pkt));
				fsm_mem_cpy(bufptr, pkt->data, pkt->len);
    7b81:	e8 fc ff ff ff       	call   7b82 <rlc_pkt_receive_from_mac+0xde2>
				fsm_skb_put(pkptr, datalen);
    7b86:	8b 55 cc             	mov    -0x34(%ebp),%edx
    7b89:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    7b8c:	e8 fc ff ff ff       	call   7b8d <rlc_pkt_receive_from_mac+0xded>
				if(pkt != NULL)
    7b91:	85 db                	test   %ebx,%ebx
    7b93:	74 07                	je     7b9c <rlc_pkt_receive_from_mac+0xdfc>
				{
					fsm_pkt_destroy(pkt);
    7b95:	89 d8                	mov    %ebx,%eax
    7b97:	e8 fc ff ff ff       	call   7b98 <rlc_pkt_receive_from_mac+0xdf8>
					pkt = NULL;
				}				
				ambuf->pkt = pkptr;
    7b9c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b9f:	31 db                	xor    %ebx,%ebx
    7ba1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7ba4:	8b 48 08             	mov    0x8(%eax),%ecx
    7ba7:	89 10                	mov    %edx,(%eax)
    7ba9:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    7bac:	e9 72 fe ff ff       	jmp    7a23 <rlc_pkt_receive_from_mac+0xc83>
		//if((umRxIns->umRecvWindow10[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		if((SN-umRxIns->vr_ur+1024)%1024<(umRxIns->vr_uh-umRxIns->vr_ur+1024)%1024&&(umRxIns->umRecvWindow10[SN]!=NULL) || isOrderedUm(umRxIns,SN))
		{
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7bb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7bb4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7bbb:	89 d8                	mov    %ebx,%eax
    7bbd:	e8 fc ff ff ff       	call   7bbe <rlc_pkt_receive_from_mac+0xe1e>
			printk("rlc_macfsm 4361\n");
    7bc2:	c7 04 24 a4 04 00 00 	movl   $0x4a4,(%esp)
    7bc9:	e8 fc ff ff ff       	call   7bca <rlc_pkt_receive_from_mac+0xe2a>
    7bce:	e9 8f f2 ff ff       	jmp    6e62 <rlc_pkt_receive_from_mac+0xc2>
		//SN %= 512;

		//,
		if((!isInsideAmRecvWin(amIns, SN) )||((amIns->amRecvWindow[SN] != NULL)&&(amIns->amRecvWindow[SN]->pktstatus == FULL_SDU)))
		{
			printk("[RLC][rlc_AM_pkt_receive_from_mac] PDU segment is outside the receiving window or the segment has been received\n");
    7bd3:	c7 04 24 84 20 00 00 	movl   $0x2084,(%esp)
    7bda:	e8 fc ff ff ff       	call   7bdb <rlc_pkt_receive_from_mac+0xe3b>
			printk("[RLC][rlc_AM_pkt_receive_from_mac] A packet has dropped\n");
    7bdf:	c7 04 24 b0 1f 00 00 	movl   $0x1fb0,(%esp)
    7be6:	e8 fc ff ff ff       	call   7be7 <rlc_pkt_receive_from_mac+0xe47>
			SV(countDropPacket)++;
    7beb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7bee:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			if(pkt != NULL)
    7bf5:	85 db                	test   %ebx,%ebx
    7bf7:	0f 84 5f f8 ff ff    	je     745c <rlc_pkt_receive_from_mac+0x6bc>
			{
				fsm_pkt_destroy(pkt);
    7bfd:	89 d8                	mov    %ebx,%eax
    7bff:	e8 fc ff ff ff       	call   7c00 <rlc_pkt_receive_from_mac+0xe60>
    7c04:	e9 53 f8 ff ff       	jmp    745c <rlc_pkt_receive_from_mac+0x6bc>
		base = umRxIns->vr_uh - UM_WINDOW_SIZE5 ;
		windows = UM_WINDOW_SIZE5 *2;
		SN %= windows;
		if((umRxIns->umRecvWindow5[SN] != NULL ) || isOrderedUm(umRxIns,SN))
		{
			fsm_printf("[RLC][rlc_UM_pkt_receive_from_mac] has been received or reordered(SN is %d)\n", SN);
    7c09:	89 74 24 04          	mov    %esi,0x4(%esp)
    7c0d:	c7 04 24 f4 23 00 00 	movl   $0x23f4,(%esp)
    7c14:	e8 fc ff ff ff       	call   7c15 <rlc_pkt_receive_from_mac+0xe75>
			//printk("[RLC][rlc_UM_pkt_receive_from_mac] A packet has dropped\n");
			SV(countDropPacket)++;
    7c19:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7c1c:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
			fsm_pkt_destroy(pkt);
    7c23:	89 d8                	mov    %ebx,%eax
    7c25:	e8 fc ff ff ff       	call   7c26 <rlc_pkt_receive_from_mac+0xe86>
			printk("rlc_macfsm 4328\n");
    7c2a:	c7 04 24 93 04 00 00 	movl   $0x493,(%esp)
    7c31:	e8 fc ff ff ff       	call   7c32 <rlc_pkt_receive_from_mac+0xe92>
    7c36:	e9 27 f2 ff ff       	jmp    6e62 <rlc_pkt_receive_from_mac+0xc2>
				break;
			}
			amIns = ( AM_Instance *)insptru;
			if((amIns->currentStatVar == ST_SUSPEND) || (amIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7c3b:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7c3f:	c7 04 24 30 1f 00 00 	movl   $0x1f30,(%esp)
    7c46:	89 44 24 04          	mov    %eax,0x4(%esp)
    7c4a:	e8 fc ff ff ff       	call   7c4b <rlc_pkt_receive_from_mac+0xeab>
				break;
    7c4f:	e9 57 f2 ff ff       	jmp    6eab <rlc_pkt_receive_from_mac+0x10b>
		switch(SV(ins_mode))
		{
		case AM_MODE:
			if(insptru == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][AM] lcid(%d) has no am instance \n",micimsg->lcid);
    7c54:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7c58:	c7 04 24 ec 1e 00 00 	movl   $0x1eec,(%esp)
    7c5f:	89 44 24 04          	mov    %eax,0x4(%esp)
    7c63:	e8 fc ff ff ff       	call   7c64 <rlc_pkt_receive_from_mac+0xec4>
				break;
    7c68:	e9 3e f2 ff ff       	jmp    6eab <rlc_pkt_receive_from_mac+0x10b>
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			if((umRxIns->currentStatVar == ST_SUSPEND) || (umRxIns->currentStatVar == ST_SUSPEND_IDLE))
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] am instance is suspended(rbid is %d)\n",micimsg->lcid);
    7c6d:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7c71:	c7 04 24 14 23 00 00 	movl   $0x2314,(%esp)
    7c78:	89 44 24 04          	mov    %eax,0x4(%esp)
    7c7c:	e8 fc ff ff ff       	call   7c7d <rlc_pkt_receive_from_mac+0xedd>
				break;
    7c81:	e9 25 f2 ff ff       	jmp    6eab <rlc_pkt_receive_from_mac+0x10b>
			break;

		case UM_MODE:
			if(insptrd == NULL)
			{
				printk("[RLC][rlc_pkt_receive_from_mac][UM] lcid(%d) has no am instance \n",micimsg->lcid);
    7c86:	0f b6 46 06          	movzbl 0x6(%esi),%eax
    7c8a:	c7 04 24 d0 22 00 00 	movl   $0x22d0,(%esp)
    7c91:	89 44 24 04          	mov    %eax,0x4(%esp)
    7c95:	e8 fc ff ff ff       	call   7c96 <rlc_pkt_receive_from_mac+0xef6>
				break;
    7c9a:	e9 0c f2 ff ff       	jmp    6eab <rlc_pkt_receive_from_mac+0x10b>
    7c9f:	90                   	nop

00007ca0 <MACCETA_handle>:
//HQ
/**
 * @function: deal with Timing Advance control element
 * @param ta_index: Timing Advance Command
 */
void MACCETA_handle(unsigned char ta_index) {   
    7ca0:	55                   	push   %ebp
    7ca1:	89 e5                	mov    %esp,%ebp
    7ca3:	56                   	push   %esi
    7ca4:	53                   	push   %ebx
    7ca5:	e8 fc ff ff ff       	call   7ca6 <MACCETA_handle+0x6>
    7caa:	89 c6                	mov    %eax,%esi
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7cac:	e8 fc ff ff ff       	call   7cad <MACCETA_handle+0xd>
    if(SV(TATimer.flag)==true)
    7cb1:	80 b8 68 01 00 00 00 	cmpb   $0x0,0x168(%eax)
 */
void MACCETA_handle(unsigned char ta_index) {   
	FIN(MACCETA_handle());
	//fsm_printf("[HEXI]RUN TA TIMER:%d\n",ta_index);

    SV_PTR_GET(rlc_mac_sv);
    7cb8:	89 c3                	mov    %eax,%ebx
    if(SV(TATimer.flag)==true)
    7cba:	74 0b                	je     7cc7 <MACCETA_handle+0x27>
        fsm_schedule_cancel(SV(TATimer.timer_sign));
    7cbc:	8b 80 64 01 00 00    	mov    0x164(%eax),%eax
    7cc2:	e8 fc ff ff ff       	call   7cc3 <MACCETA_handle+0x23>
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7cc7:	8b 43 24             	mov    0x24(%ebx),%eax
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7cca:	81 e6 ff 00 00 00    	and    $0xff,%esi
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7cd0:	ba 0b 00 00 00       	mov    $0xb,%edx
    SV_PTR_GET(rlc_mac_sv);
    if(SV(TATimer.flag)==true)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
    7cd5:	83 ee 1f             	sub    $0x1f,%esi
    7cd8:	c1 e6 04             	shl    $0x4,%esi
    7cdb:	66 01 73 22          	add    %si,0x22(%ebx)
	SV(TATimer.time_value)=SV(TA_Periodic_time);
    7cdf:	89 83 60 01 00 00    	mov    %eax,0x160(%ebx)
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7ce5:	6b c0 64             	imul   $0x64,%eax,%eax
    7ce8:	e8 fc ff ff ff       	call   7ce9 <MACCETA_handle+0x49>
	SV(TATimer.flag)=true;
    7ced:	c6 83 68 01 00 00 01 	movb   $0x1,0x168(%ebx)
        fsm_schedule_cancel(SV(TATimer.timer_sign));
	//SV(TATimer.time_value)=(ta_index-31)*16+SV(TATimer.time_value);//
	
	SV(TA_value)=(ta_index-31)*16+SV(TA_value);//LHL 20141021
	SV(TATimer.time_value)=SV(TA_Periodic_time);
	SV(TATimer.timer_sign)=fsm_schedule_self(SV(TATimer.time_value)*100,TimeAlignmentTimer_Expire);
    7cf4:	89 83 64 01 00 00    	mov    %eax,0x164(%ebx)
	SV(TATimer.flag)=true;
		
FOUT;
}
    7cfa:	5b                   	pop    %ebx
    7cfb:	5e                   	pop    %esi
    7cfc:	5d                   	pop    %ebp
    7cfd:	c3                   	ret    
    7cfe:	66 90                	xchg   %ax,%ax

00007d00 <decomplexRarPdu>:
/**
 * @function: decomplex the RAR PDU to get the MAC RAR that belongs to the user
 * @param skb: the sk_buff that contains the RAR PDU
 * @return: is there MAC RAR in the RAR PDU that belongs to the user
 */
bool decomplexRarPdu(FSM_PKT *skb){		//RAR SDU	//RAR
    7d00:	55                   	push   %ebp
    7d01:	89 e5                	mov    %esp,%ebp
    7d03:	57                   	push   %edi
    7d04:	56                   	push   %esi
    7d05:	53                   	push   %ebx
    7d06:	83 ec 3c             	sub    $0x3c,%esp
    7d09:	e8 fc ff ff ff       	call   7d0a <decomplexRarPdu+0xa>
    7d0e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
	MAC_RAR_subhead_withbi *bi_subhead=(MAC_RAR_subhead_withbi*)fsm_mem_alloc(sizeof(MAC_RAR_subhead_withbi));	//20140430
    7d11:	b8 01 00 00 00       	mov    $0x1,%eax
    7d16:	e8 fc ff ff ff       	call   7d17 <decomplexRarPdu+0x17>
    7d1b:	89 45 d0             	mov    %eax,-0x30(%ebp)
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
    7d1e:	b8 01 00 00 00       	mov    $0x1,%eax
    7d23:	e8 fc ff ff ff       	call   7d24 <decomplexRarPdu+0x24>
    7d28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
    7d2b:	b8 06 00 00 00       	mov    $0x6,%eax
    7d30:	e8 fc ff ff ff       	call   7d31 <decomplexRarPdu+0x31>
    7d35:	89 45 d8             	mov    %eax,-0x28(%ebp)
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
    7d38:	b8 04 00 00 00       	mov    $0x4,%eax
    7d3d:	e8 fc ff ff ff       	call   7d3e <decomplexRarPdu+0x3e>
    7d42:	89 45 cc             	mov    %eax,-0x34(%ebp)
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));
    7d45:	b8 07 00 00 00       	mov    $0x7,%eax
    7d4a:	e8 fc ff ff ff       	call   7d4b <decomplexRarPdu+0x4b>
    7d4f:	89 45 c8             	mov    %eax,-0x38(%ebp)

	SV_PTR_GET(rlc_mac_sv);
    7d52:	e8 fc ff ff ff       	call   7d53 <decomplexRarPdu+0x53>
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7d57:	31 d2                	xor    %edx,%edx
    7d59:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_RAR_subhead *rar_subhead=(MAC_RAR_subhead*)fsm_mem_alloc(sizeof(MAC_RAR_subhead));	//20140430
	MAC_RAR_sdu *rar_sdu=(MAC_RAR_sdu*)fsm_mem_alloc(sizeof(MAC_RAR_sdu));	//20140430
	RAR_ULgrant *rar_ulgrant=(RAR_ULgrant*)fsm_mem_alloc(sizeof(RAR_ULgrant));	//20141111modified
	PHYadaptertoMAC_IciMsg *phy_ici=(PHYadaptertoMAC_IciMsg*)fsm_mem_alloc(sizeof(PHYadaptertoMAC_IciMsg));

	SV_PTR_GET(rlc_mac_sv);
    7d5e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	
	fsm_mem_set(bi_subhead,0,sizeof(MAC_RAR_subhead_withbi));	//20140430
    7d61:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7d64:	e8 fc ff ff ff       	call   7d65 <decomplexRarPdu+0x65>
	fsm_mem_set(rar_subhead,0,sizeof(MAC_RAR_subhead));	//20140430
    7d69:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d6c:	31 d2                	xor    %edx,%edx
    7d6e:	b9 01 00 00 00       	mov    $0x1,%ecx
    7d73:	e8 fc ff ff ff       	call   7d74 <decomplexRarPdu+0x74>
	fsm_mem_set(rar_sdu,0,sizeof(MAC_RAR_sdu));	//20140430
    7d78:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7d7b:	31 d2                	xor    %edx,%edx
    7d7d:	b9 06 00 00 00       	mov    $0x6,%ecx
    7d82:	e8 fc ff ff ff       	call   7d83 <decomplexRarPdu+0x83>
	fsm_mem_set(rar_ulgrant,0,sizeof(RAR_ULgrant));	//20141111modified
    7d87:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7d8a:	31 d2                	xor    %edx,%edx
    7d8c:	b9 04 00 00 00       	mov    $0x4,%ecx
    7d91:	e8 fc ff ff ff       	call   7d92 <decomplexRarPdu+0x92>
	fsm_mem_set(phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    7d96:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7d99:	31 d2                	xor    %edx,%edx
    7d9b:	b9 07 00 00 00       	mov    $0x7,%ecx
    7da0:	e8 fc ff ff ff       	call   7da1 <decomplexRarPdu+0xa1>
		fsm_printf("%c,",*((char *)skb->data+offset));
	}
	fsm_printf("\n");*/
	//fsm_octets_print(newskb->data,4);
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
    7da5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7da8:	b9 01 00 00 00       	mov    $0x1,%ecx
    7dad:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    7db3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7db6:	e8 fc ff ff ff       	call   7db7 <decomplexRarPdu+0xb7>
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
    7dbb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7dbe:	0f b6 10             	movzbl (%eax),%edx
    7dc1:	89 d0                	mov    %edx,%eax
    7dc3:	c0 e8 06             	shr    $0x6,%al
    7dc6:	0f b6 c0             	movzbl %al,%eax
	if(typ_flag==0||typ_flag==2){		//BI
    7dc9:	83 f8 02             	cmp    $0x2,%eax
    7dcc:	0f 84 5e 01 00 00    	je     7f30 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7dd2:	31 ff                	xor    %edi,%edi
	
	fsm_mem_cpy(bi_subhead,skb->data+from_len,len);	//T//20140626datatype
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
    7dd4:	85 c0                	test   %eax,%eax
    7dd6:	0f 84 54 01 00 00    	je     7f30 <decomplexRarPdu+0x230>
	u32 ul_grant,bi;		//ULGRANT,BI
	u32 rapid_in_subhead;	//rapid
	
	u32 sdu_numb=0,m_cnt=0;	//RAR;
	//u32 from_len=sizeof(char);//
	u32 from_len=0, head_len=0;	//modify in 20160225
    7ddc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    7ddf:	8b 75 e0             	mov    -0x20(%ebp),%esi
    7de2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7de9:	89 7d ec             	mov    %edi,-0x14(%ebp)
    7dec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7df0:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    7df6:	b9 01 00 00 00       	mov    $0x1,%ecx
    7dfb:	89 d8                	mov    %ebx,%eax
	else{
		continue_flag=true;
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
    7dfd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7e01:	01 fa                	add    %edi,%edx
		from_len=from_len+sizeof(MAC_RAR_subhead);
    7e03:	83 c7 01             	add    $0x1,%edi
		//head_len=1;	//noted in 20160225
	}
	while (continue_flag){
		sdu_numb++;
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+from_len,len);	//
    7e06:	e8 fc ff ff ff       	call   7e07 <decomplexRarPdu+0x107>
		from_len=from_len+sizeof(MAC_RAR_subhead);
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
    7e0b:	80 3b 00             	cmpb   $0x0,(%ebx)
    7e0e:	78 e0                	js     7df0 <decomplexRarPdu+0xf0>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7e10:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7e13:	89 fe                	mov    %edi,%esi
    7e15:	89 74 24 08          	mov    %esi,0x8(%esp)
    7e19:	8b 7d ec             	mov    -0x14(%ebp),%edi
    7e1c:	c7 04 24 d8 27 00 00 	movl   $0x27d8,(%esp)
    7e23:	89 44 24 04          	mov    %eax,0x4(%esp)
    7e27:	e8 fc ff ff ff       	call   7e28 <decomplexRarPdu+0x128>

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7e2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7e2f:	85 c0                	test   %eax,%eax
    7e31:	0f 84 f3 00 00 00    	je     7f2a <decomplexRarPdu+0x22a>
    7e37:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    7e3e:	eb 4a                	jmp    7e8a <decomplexRarPdu+0x18a>
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7e40:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7e44:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7e48:	c7 04 24 d5 04 00 00 	movl   $0x4d5,(%esp)
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
		{
			//fsm_printf("[HEXI]SV(rar_failed_num)==0!\n");
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
    7e4f:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
			SV(rar_failed_num)=SV(rar_failed_num)-1;
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7e53:	e8 fc ff ff ff       	call   7e54 <decomplexRarPdu+0x154>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7e58:	0f bf 55 d6          	movswl -0x2a(%ebp),%edx
    7e5c:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    7e5f:	89 54 24 04          	mov    %edx,0x4(%esp)
    7e63:	c7 04 24 f0 04 00 00 	movl   $0x4f0,(%esp)
    7e6a:	e8 fc ff ff ff       	call   7e6b <decomplexRarPdu+0x16b>
		if(rapid_in_subhead==my_id){	//RAR
    7e6f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    7e72:	39 da                	cmp    %ebx,%edx
    7e74:	0f 84 1f 01 00 00    	je     7f99 <decomplexRarPdu+0x299>
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7e7a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7e7e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e81:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7e84:	0f 84 a0 00 00 00    	je     7f2a <decomplexRarPdu+0x22a>
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7e8a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7e8d:	89 fa                	mov    %edi,%edx
    7e8f:	b9 01 00 00 00       	mov    $0x1,%ecx
		head_len=head_len+len;
    7e94:	83 c7 01             	add    $0x1,%edi

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
    7e97:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7e9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ea0:	e8 fc ff ff ff       	call   7ea1 <decomplexRarPdu+0x1a1>
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7ea5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7ea8:	0f b6 18             	movzbl (%eax),%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7eab:	c7 04 24 c2 04 00 00 	movl   $0x4c2,(%esp)

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
		len=sizeof(MAC_RAR_subhead);
		fsm_mem_cpy(rar_subhead,skb->data+head_len,len);	//
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
    7eb2:	83 e3 3f             	and    $0x3f,%ebx
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);
    7eb5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7eb9:	e8 fc ff ff ff       	call   7eba <decomplexRarPdu+0x1ba>

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7ebe:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7ec1:	89 f2                	mov    %esi,%edx
    7ec3:	b9 06 00 00 00       	mov    $0x6,%ecx

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
    7ec8:	83 c6 06             	add    $0x6,%esi
		head_len=head_len+len;
		rapid_in_subhead=(rar_subhead->m_e_t_rapid)&63;
		fsm_printf("[MAC RAR]RAPID:%d\n",rapid_in_subhead);

		len=sizeof(MAC_RAR_sdu);
		fsm_mem_cpy(rar_sdu,skb->data+from_len,len);		//SDU
    7ecb:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    7ed1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7ed4:	e8 fc ff ff ff       	call   7ed5 <decomplexRarPdu+0x1d5>

		//fsm_printf("[HEXI]T_C_RNTI IN ALL RARS:%d\n",rar_sdu->m_tcrnti);
		
		from_len=from_len+len;
		/**************************/
		if(SV(rar_failed_num)==0)//
    7ed9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7edc:	8b 82 fc 01 00 00    	mov    0x1fc(%edx),%eax
    7ee2:	85 c0                	test   %eax,%eax
    7ee4:	0f 84 56 ff ff ff    	je     7e40 <decomplexRarPdu+0x140>
			my_id=SV(RA_info.ra_PreambleIndex);	//TEMPORY 
			
		}
		else
		{
			SV(rar_failed_num)=SV(rar_failed_num)-1;
    7eea:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7eed:	83 e8 01             	sub    $0x1,%eax
    7ef0:	89 82 fc 01 00 00    	mov    %eax,0x1fc(%edx)
			my_id=99;//
		}
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
    7ef6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    7efa:	c7 04 24 d5 04 00 00 	movl   $0x4d5,(%esp)
    7f01:	e8 fc ff ff ff       	call   7f02 <decomplexRarPdu+0x202>
		fsm_printf("[HEXI]my_id:%d\n",my_id);
    7f06:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
    7f0d:	00 
    7f0e:	c7 04 24 f0 04 00 00 	movl   $0x4f0,(%esp)
    7f15:	e8 fc ff ff ff       	call   7f16 <decomplexRarPdu+0x216>
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7f1a:	8b 55 e8             	mov    -0x18(%ebp),%edx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
    7f1d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);

	while(sdu_numb>m_cnt){//?????????????????????????????????????????????????????
    7f21:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    7f24:	0f 85 60 ff ff ff    	jne    7e8a <decomplexRarPdu+0x18a>
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7f2a:	31 db                	xor    %ebx,%ebx
    7f2c:	eb 2f                	jmp    7f5d <decomplexRarPdu+0x25d>
    7f2e:	66 90                	xchg   %ax,%ax
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7f30:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7f33:	89 d0                	mov    %edx,%eax
    7f35:	83 e0 0f             	and    $0xf,%eax
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7f38:	84 d2                	test   %dl,%dl
	//fsm_printf("[MAC RAR]BI SUBHEAD:%c:\n",bi_subhead->m_e_t_r_r_bi+65);
	
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
    7f3a:	89 41 1c             	mov    %eax,0x1c(%ecx)
		SV(backoff_index)=bi;
		from_len=from_len+len;
		head_len=from_len;
		if(c_flag==1){		//
    7f3d:	78 50                	js     7f8f <decomplexRarPdu+0x28f>
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7f3f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
    7f46:	00 
	u32 from_len=0, head_len=0;	//modify in 20160225
	bool continue_flag=false;	//
	u32 len=sizeof(MAC_RAR_subhead_withbi);	//
	u32 typ_flag=0;		//20140626
	u32 m_tb_size=0;	//TB SIZE
	bool return_value=false;	// RAR
    7f47:	31 db                	xor    %ebx,%ebx
		c_flag=rar_subhead->m_e_t_rapid>>7;
		if(c_flag!=1)
			continue_flag=false;
	}

	fsm_printf("[HEXI]RAR SDU NUMBER AND THE OFFSET:%d %d\n",sdu_numb,from_len);
    7f49:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    7f50:	00 
    7f51:	c7 04 24 d8 27 00 00 	movl   $0x27d8,(%esp)
    7f58:	e8 fc ff ff ff       	call   7f59 <decomplexRarPdu+0x259>
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
			break;
		}
		m_cnt++;
	}
	fsm_mem_free(bi_subhead);
    7f5d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f60:	e8 fc ff ff ff       	call   7f61 <decomplexRarPdu+0x261>
	fsm_mem_free(rar_subhead);
    7f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f68:	e8 fc ff ff ff       	call   7f69 <decomplexRarPdu+0x269>
	fsm_mem_free(rar_sdu);
    7f6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7f70:	e8 fc ff ff ff       	call   7f71 <decomplexRarPdu+0x271>
	fsm_mem_free(rar_ulgrant);	//20141111modified
    7f75:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7f78:	e8 fc ff ff ff       	call   7f79 <decomplexRarPdu+0x279>
	fsm_mem_free(phy_ici);
    7f7d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    7f80:	e8 fc ff ff ff       	call   7f81 <decomplexRarPdu+0x281>
	FRET(return_value);
}
    7f85:	89 d8                	mov    %ebx,%eax
    7f87:	83 c4 3c             	add    $0x3c,%esp
    7f8a:	5b                   	pop    %ebx
    7f8b:	5e                   	pop    %esi
    7f8c:	5f                   	pop    %edi
    7f8d:	5d                   	pop    %ebp
    7f8e:	c3                   	ret    
	typ_flag=bi_subhead->m_e_t_r_r_bi>>6;	//20140626
	if(typ_flag==0||typ_flag==2){		//BI
		c_flag=bi_subhead->m_e_t_r_r_bi>>7;
		bi=(bi_subhead->m_e_t_r_r_bi)&15;
		SV(backoff_index)=bi;
		from_len=from_len+len;
    7f8f:	bf 01 00 00 00       	mov    $0x1,%edi
    7f94:	e9 43 fe ff ff       	jmp    7ddc <decomplexRarPdu+0xdc>
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
    7f99:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7f9c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7f9f:	0f b7 41 04          	movzwl 0x4(%ecx),%eax
    7fa3:	66 89 42 02          	mov    %ax,0x2(%edx)
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
    7fa7:	89 44 24 04          	mov    %eax,0x4(%esp)
    7fab:	c7 04 24 00 05 00 00 	movl   $0x500,(%esp)
    7fb2:	e8 fc ff ff ff       	call   7fb3 <decomplexRarPdu+0x2b3>
			
			tadvance=(rar_sdu->m_r_ta)&127;
    7fb7:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    7fba:	0f b6 01             	movzbl (%ecx),%eax
			tadvance=tadvance<<4;
    7fbd:	89 c2                	mov    %eax,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7fbf:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			return_value=true;
			SV(T_C_RNTI)=rar_sdu->m_tcrnti;
			fsm_printf("[HEXI]T_C_RNTI IN RAR:%d\n",SV(T_C_RNTI));
			
			tadvance=(rar_sdu->m_r_ta)&127;
			tadvance=tadvance<<4;
    7fc3:	83 e2 7f             	and    $0x7f,%edx
    7fc6:	c1 e2 04             	shl    $0x4,%edx
			tadvance=tadvance+(rar_sdu->m_ta_ulgrant>>4);
    7fc9:	c0 e8 04             	shr    $0x4,%al
    7fcc:	0f b6 c0             	movzbl %al,%eax
    7fcf:	01 d0                	add    %edx,%eax
    7fd1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fd4:	66 89 42 20          	mov    %ax,0x20(%edx)
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
    7fd8:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			ul_grant=ul_grant<<12;
    7fdc:	c1 e0 10             	shl    $0x10,%eax
    7fdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7fe2:	0f b7 51 02          	movzwl 0x2(%ecx),%edx
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7fe6:	b9 04 00 00 00       	mov    $0x4,%ecx
			SV(TA_fromRAR)=tadvance;//modified by HQ 20140502			
			//SV(TA_value)=tadvance*16;//LHL 20141021,TA*16TS,TS
			//fsm_printf("TA_fromRAR is %d ms \n",SV(TA_value));//testing code 
			ul_grant=rar_sdu->m_ta_ulgrant<<4;
			ul_grant=ul_grant<<12;
			ul_grant=ul_grant+rar_sdu->m_ulgrant;
    7feb:	01 d0                	add    %edx,%eax
    7fed:	89 45 f0             	mov    %eax,-0x10(%ebp)
			//ul_grant=ul_grant<<12;
			fsm_mem_cpy(rar_ulgrant,&ul_grant,sizeof(u32));
    7ff0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7ff3:	8d 55 f0             	lea    -0x10(%ebp),%edx
    7ff6:	e8 fc ff ff ff       	call   7ff7 <decomplexRarPdu+0x2f7>
			//m_tb_size=DoReceiveRARULgrant_Tbsize(ul_grant);	//make		//20140428 

			SV(recv_frame).frameNo=phy_ici->frameNo;	//add on 11,17.2014
    7ffb:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    7ffe:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8001:	0f b7 41 03          	movzwl 0x3(%ecx),%eax
    8005:	66 89 42 0a          	mov    %ax,0xa(%edx)
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014
    8009:	0f b7 41 05          	movzwl 0x5(%ecx),%eax
    800d:	66 89 42 0c          	mov    %ax,0xc(%edx)

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
    8011:	8b 45 cc             	mov    -0x34(%ebp),%eax
    8014:	e8 fc ff ff ff       	call   8015 <decomplexRarPdu+0x315>
    8019:	89 c3                	mov    %eax,%ebx
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
    801b:	89 44 24 04          	mov    %eax,0x4(%esp)
    801f:	c7 04 24 1a 05 00 00 	movl   $0x51a,(%esp)
    8026:	e8 fc ff ff ff       	call   8027 <decomplexRarPdu+0x327>
			SV(UL_resource_info).m_tbsize=m_tb_size;		
    802b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    802e:	89 58 2c             	mov    %ebx,0x2c(%eax)
		/*********************************/
		//my_id=25;
		fsm_printf("[HEXI]rapid_in_subhead:%d\n",rapid_in_subhead);
		fsm_printf("[HEXI]my_id:%d\n",my_id);
		if(rapid_in_subhead==my_id){	//RAR
			return_value=true;
    8031:	bb 01 00 00 00       	mov    $0x1,%ebx
			SV(recv_frame).subframeNo=phy_ici->subframeNo;	//add on 11,17.2014

			m_tb_size=DoReceiveRARULgrant_Tbsize(rar_ulgrant);
			printk("[MAC][decomplex]m_tb_size:%d\n",m_tb_size);
			SV(UL_resource_info).m_tbsize=m_tb_size;		
			SV(UL_resource_info).resource_flag=true;		//the member is not addded yet
    8036:	c6 40 28 01          	movb   $0x1,0x28(%eax)
			break;
    803a:	e9 1e ff ff ff       	jmp    7f5d <decomplexRarPdu+0x25d>
    803f:	90                   	nop

00008040 <lteMacCEC_rntiSend>:
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    8040:	55                   	push   %ebp
    8041:	89 e5                	mov    %esp,%ebp
    8043:	83 ec 10             	sub    $0x10,%esp
    8046:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8049:	89 75 f8             	mov    %esi,-0x8(%ebp)
    804c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    804f:	e8 fc ff ff ff       	call   8050 <lteMacCEC_rntiSend+0x10>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    8054:	31 db                	xor    %ebx,%ebx
/**
 * @function: fill in the C_RNTI control element
 * @param m_crnti: the structure of C_RNTI control element
 * @return: is there C_RNTI control element to send
 */
bool lteMacCEC_rntiSend(MAC_CE_Crnti *m_crnti){	//c-rnti
    8056:	89 c7                	mov    %eax,%edi
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
    8058:	e8 fc ff ff ff       	call   8059 <lteMacCEC_rntiSend+0x19>
    805d:	89 c6                	mov    %eax,%esi
    805f:	90                   	nop
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
    8060:	80 bc de a5 01 00 00 	cmpb   $0x1b,0x1a5(%esi,%ebx,8)
    8067:	1b 
    8068:	74 1e                	je     8088 <lteMacCEC_rntiSend+0x48>
	FIN(lteMacCEC_rntiSend());

	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    806a:	83 c3 01             	add    $0x1,%ebx
    806d:	83 fb 08             	cmp    $0x8,%ebx
    8070:	75 ee                	jne    8060 <lteMacCEC_rntiSend+0x20>
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    8072:	8b 5d f4             	mov    -0xc(%ebp),%ebx
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
    8075:	31 c0                	xor    %eax,%eax
}
    8077:	8b 75 f8             	mov    -0x8(%ebp),%esi
    807a:	8b 7d fc             	mov    -0x4(%ebp),%edi
    807d:	89 ec                	mov    %ebp,%esp
    807f:	5d                   	pop    %ebp
    8080:	c3                   	ret    
    8081:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    8088:	83 c3 34             	add    $0x34,%ebx
	u32 tag_pos;
	SV_PTR_GET(rlc_mac_sv);
	
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==C_RNTI_LCID){
			fsm_printf("[HEXI]C_RNTI CONTROL ELEMENT FOUND!\n");
    808b:	c7 04 24 04 28 00 00 	movl   $0x2804,(%esp)
    8092:	e8 fc ff ff ff       	call   8093 <lteMacCEC_rntiSend+0x53>

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
    8097:	8b 44 de 08          	mov    0x8(%esi,%ebx,8),%eax
    809b:	0f b7 00             	movzwl (%eax),%eax
    809e:	66 89 07             	mov    %ax,(%edi)
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	
	FRET(false);
}
    80a1:	8b 7d fc             	mov    -0x4(%ebp),%edi

			m_crnti->m_crnti=*((u16*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr));
			
			//fsm_printf("[MAC CRNTI]RNTI IN SV:%d\n",SV(C_RNTI));
			
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    80a4:	0f b6 44 de 04       	movzbl 0x4(%esi,%ebx,8),%eax
		}
	}
	
	FRET(false);
}
    80a9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    80ac:	8b 75 f8             	mov    -0x8(%ebp),%esi
    80af:	89 ec                	mov    %ebp,%esp
    80b1:	5d                   	pop    %ebp
    80b2:	c3                   	ret    
    80b3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    80b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000080c0 <lteMacCEPhSend>:
/**
 * @function: fill in the Power Headroom control element
 * @param m_power_headroom: the structure of Power Headroom control element
 * @return: is there Power Headroom control element tfsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);o send
 */
bool lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom){		//
    80c0:	55                   	push   %ebp
    80c1:	89 e5                	mov    %esp,%ebp
    80c3:	e8 fc ff ff ff       	call   80c4 <lteMacCEPhSend+0x4>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
    80c8:	e8 fc ff ff ff       	call   80c9 <lteMacCEPhSend+0x9>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    80cd:	31 d2                	xor    %edx,%edx
    80cf:	90                   	nop
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
    80d0:	80 bc d0 a5 01 00 00 	cmpb   $0x1a,0x1a5(%eax,%edx,8)
    80d7:	1a 
    80d8:	74 0e                	je     80e8 <lteMacCEPhSend+0x28>
	FIN(lteMacCEPhSend(MAC_CE_power_headroom *m_power_headroom));
	
	u32 tag_pos;

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
    80da:	83 c2 01             	add    $0x1,%edx
    80dd:	83 fa 08             	cmp    $0x8,%edx
    80e0:	75 ee                	jne    80d0 <lteMacCEPhSend+0x10>
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
		}
	}
	FRET(false);
    80e2:	31 c0                	xor    %eax,%eax
}
    80e4:	5d                   	pop    %ebp
    80e5:	c3                   	ret    
    80e6:	66 90                	xchg   %ax,%ax

	SV_PTR_GET(rlc_mac_sv);
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){
		if(SV(MAC_CE_Tags[tag_pos]).LCID==PHR_LCID){
			m_power_headroom=(MAC_CE_power_headroom*)(SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr);
			FRET(SV(MAC_CE_Tags[tag_pos]).addinPDU_flag);
    80e8:	0f b6 84 d0 a4 01 00 	movzbl 0x1a4(%eax,%edx,8),%eax
    80ef:	00 
		}
	}
	FRET(false);
}
    80f0:	5d                   	pop    %ebp
    80f1:	c3                   	ret    
    80f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    80f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008100 <lteMacCcchSend>:
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    8100:	55                   	push   %ebp
    8101:	89 e5                	mov    %esp,%ebp
    8103:	57                   	push   %edi
    8104:	56                   	push   %esi
    8105:	53                   	push   %ebx
    8106:	83 ec 2c             	sub    $0x2c,%esp
    8109:	e8 fc ff ff ff       	call   810a <lteMacCcchSend+0xa>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    810e:	bf 1f 00 00 00       	mov    $0x1f,%edi
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    8113:	89 45 f0             	mov    %eax,-0x10(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    8116:	b8 0a 00 00 00       	mov    $0xa,%eax
 * @function: find the PDU transport in the CCCH and back it up
 * @param skb: the sk_buff contains MAC PDU from RLC layer
 * @param ici_len
 * @return
 */
u32 lteMacCcchSend(FSM_PKT *skb,u32 ici_len){		//CCCH//20140430
    811b:	89 55 ec             	mov    %edx,-0x14(%ebp)

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
    811e:	e8 fc ff ff ff       	call   811f <lteMacCcchSend+0x1f>
    8123:	89 45 e0             	mov    %eax,-0x20(%ebp)
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
    8126:	b8 01 00 00 00       	mov    $0x1,%eax
    812b:	e8 fc ff ff ff       	call   812c <lteMacCcchSend+0x2c>
    8130:	89 c3                	mov    %eax,%ebx
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    8132:	b8 03 00 00 00       	mov    $0x3,%eax
    8137:	e8 fc ff ff ff       	call   8138 <lteMacCcchSend+0x38>
    813c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    813f:	e8 fc ff ff ff       	call   8140 <lteMacCcchSend+0x40>
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    8144:	31 d2                	xor    %edx,%edx
    8146:	b9 0a 00 00 00       	mov    $0xa,%ecx
	RRCConnectionRequest *m_rrc_request=(RRCConnectionRequest *)fsm_mem_alloc(sizeof(RRCConnectionRequest));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(fsm_mem_alloc));	//20140430
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	//Ccch_Msg *m_ccch_msg=(UL_CCCH_Message*)fsm_mem_alloc(sizeof(UL_CCCH_Message));
	
	SV_PTR_GET(rlc_mac_sv);
    814b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	
	fsm_mem_set(m_rrc_request,0,sizeof(RRCConnectionRequest));	//20140430
    814e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8151:	e8 fc ff ff ff       	call   8152 <lteMacCcchSend+0x52>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8156:	31 d2                	xor    %edx,%edx
    8158:	b9 02 00 00 00       	mov    $0x2,%ecx
    815d:	89 d8                	mov    %ebx,%eax
    815f:	e8 fc ff ff ff       	call   8160 <lteMacCcchSend+0x60>
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
    8164:	8b 45 e8             	mov    -0x18(%ebp),%eax
    8167:	31 d2                	xor    %edx,%edx
    8169:	b9 03 00 00 00       	mov    $0x3,%ecx
    816e:	e8 fc ff ff ff       	call   816f <lteMacCcchSend+0x6f>
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    8173:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8176:	b9 02 00 00 00       	mov    $0x2,%ecx
    817b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    817e:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    8184:	89 d8                	mov    %ebx,%eax
    8186:	e8 fc ff ff ff       	call   8187 <lteMacCcchSend+0x87>
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    818b:	0f b6 13             	movzbl (%ebx),%edx
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    818e:	21 d7                	and    %edx,%edi
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8190:	89 d0                	mov    %edx,%eax
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    8192:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8196:	c0 e8 05             	shr    $0x5,%al
    8199:	0f b6 f0             	movzbl %al,%esi
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    819c:	89 7c 24 08          	mov    %edi,0x8(%esp)
	//fsm_mem_set(m_ccch_msg,0,sizeof(UL_CCCH_Message));
	len=sizeof(MAC_SDU_subhead_7bit);
	fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
	continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
	lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
	f_domain=m_7bit_subhead->m_f_l>>7;
    81a0:	c0 ea 07             	shr    $0x7,%dl
    81a3:	0f b6 d2             	movzbl %dl,%edx
	fsm_printf("[MAC CCCHSNED]CONTINUE FLAG:%d;LCID:%d;DATA TYPE FROM CCCH:%d\n",continue_flag,lcid,f_domain);
    81a6:	89 54 24 0c          	mov    %edx,0xc(%esp)
    81aa:	89 55 d8             	mov    %edx,-0x28(%ebp)
    81ad:	89 74 24 04          	mov    %esi,0x4(%esp)
    81b1:	c7 04 24 2c 28 00 00 	movl   $0x282c,(%esp)
    81b8:	e8 fc ff ff ff       	call   81b9 <lteMacCcchSend+0xb9>
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    81bd:	83 fe 01             	cmp    $0x1,%esi
    81c0:	8b 55 d8             	mov    -0x28(%ebp),%edx
	/*for(i=0;i<4;i++){
		fsm_printf("%c,",*(skb->data+i));
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
    81c3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	
	while(continue_flag==1){
    81ca:	0f 85 7d 00 00 00    	jne    824d <lteMacCcchSend+0x14d>
		if(lcid==0){								//ccch
    81d0:	85 ff                	test   %edi,%edi
    81d2:	0f 84 ab 00 00 00    	je     8283 <lteMacCcchSend+0x183>
    81d8:	66 31 f6             	xor    %si,%si
    81db:	31 ff                	xor    %edi,%edi
    81dd:	eb 44                	jmp    8223 <lteMacCcchSend+0x123>
    81df:	90                   	nop
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    81e0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
			offset=offset+sdu_len;

			}
			else{		//7bit		//20140430
				from_len=from_len+len;
    81e4:	83 c6 02             	add    $0x2,%esi
				sdu_len=(m_7bit_subhead->m_f_l)&127;
    81e7:	83 e0 7f             	and    $0x7f,%eax
				offset=offset+sdu_len;
    81ea:	01 c7                	add    %eax,%edi
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
    81ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
    81ef:	b9 02 00 00 00       	mov    $0x2,%ecx
    81f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    81f7:	01 f2                	add    %esi,%edx
    81f9:	03 90 a8 00 00 00    	add    0xa8(%eax),%edx
    81ff:	89 d8                	mov    %ebx,%eax
    8201:	e8 fc ff ff ff       	call   8202 <lteMacCcchSend+0x102>
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    8206:	0f b6 03             	movzbl (%ebx),%eax
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    8209:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    820d:	89 c1                	mov    %eax,%ecx
				sdu_len=(m_7bit_subhead->m_f_l)&127;
				offset=offset+sdu_len;
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
    820f:	c0 e8 05             	shr    $0x5,%al
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
    8212:	83 e1 1f             	and    $0x1f,%ecx
		f_domain=m_7bit_subhead->m_f_l>>7;
    8215:	c0 ea 07             	shr    $0x7,%dl
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    8218:	3c 01                	cmp    $0x1,%al
			}
		len=sizeof(MAC_SDU_subhead_7bit);
		fsm_mem_cpy(m_7bit_subhead,skb->head+ici_len+from_len,len);
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
    821a:	0f b6 d2             	movzbl %dl,%edx
	}
	fsm_printf("\n");*/
	//offset=sizeof(u32);	//I don't know why
	offset=0;
	
	while(continue_flag==1){
    821d:	75 29                	jne    8248 <lteMacCcchSend+0x148>
		if(lcid==0){								//ccch
    821f:	85 c9                	test   %ecx,%ecx
    8221:	74 5d                	je     8280 <lteMacCcchSend+0x180>
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
    8223:	83 fa 01             	cmp    $0x1,%edx
    8226:	75 b8                	jne    81e0 <lteMacCcchSend+0xe0>
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8228:	8b 4d e8             	mov    -0x18(%ebp),%ecx
			//20140708 adition end  by HEXI */
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
    822b:	83 c6 03             	add    $0x3,%esi
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    822e:	0f b6 41 01          	movzbl 0x1(%ecx),%eax
			sdu_len=sdu_len<<8;
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    8232:	0f b6 51 02          	movzbl 0x2(%ecx),%edx
			break;
		}
		if(f_domain==1){	//15bit		20140430
			len=sizeof(MAC_SDU_subhead_15bit);
			from_len=from_len+len;
			sdu_len=(m_15bit_subhead->m_f_l)&127;
    8236:	83 e0 7f             	and    $0x7f,%eax
			sdu_len=sdu_len<<8;
    8239:	c1 e0 08             	shl    $0x8,%eax
			sdu_len=sdu_len+m_15bit_subhead->m_l;
    823c:	01 d0                	add    %edx,%eax
			offset=offset+sdu_len;
    823e:	01 c7                	add    %eax,%edi
    8240:	eb aa                	jmp    81ec <lteMacCcchSend+0xec>
    8242:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8248:	89 7d dc             	mov    %edi,-0x24(%ebp)
    824b:	89 cf                	mov    %ecx,%edi
		continue_flag=m_7bit_subhead->m_lcid_e_r_r>>5;
		lcid=(m_7bit_subhead->m_lcid_e_r_r)&31;
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
    824d:	85 ff                	test   %edi,%edi
    824f:	0f 84 c3 01 00 00    	je     8418 <lteMacCcchSend+0x318>
	FIN(lteMacCcchSend());

	u32 len=0,lcid=-1,from_len=0,sdu_len=0,offset=0,f_domain=-1,skb_len=0;
	long contention_resolution;
	u32 continue_flag=1;
	u32 ccch_or_not = 1;//HQ modified 20140709 
    8255:	be 01 00 00 00       	mov    $0x1,%esi
			skb_len = skb->tail - skb->data;
			fsm_skb_put(SV(msg3_buf_ptr),skb_len);
			fsm_mem_cpy(SV(msg3_buf_ptr)->data,skb->data,skb_len);
			//20140708 adition end  by HEXI */
		}
	fsm_mem_free(m_rrc_request);
    825a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    825d:	e8 fc ff ff ff       	call   825e <lteMacCcchSend+0x15e>
	fsm_mem_free(m_7bit_subhead);
    8262:	89 d8                	mov    %ebx,%eax
    8264:	e8 fc ff ff ff       	call   8265 <lteMacCcchSend+0x165>
	fsm_mem_free(m_15bit_subhead);
    8269:	8b 45 e8             	mov    -0x18(%ebp),%eax
    826c:	e8 fc ff ff ff       	call   826d <lteMacCcchSend+0x16d>
	FRET(ccch_or_not);
		//FRET(0);
}
    8271:	89 f0                	mov    %esi,%eax
    8273:	83 c4 2c             	add    $0x2c,%esp
    8276:	5b                   	pop    %ebx
    8277:	5e                   	pop    %esi
    8278:	5f                   	pop    %edi
    8279:	5d                   	pop    %ebp
    827a:	c3                   	ret    
    827b:	90                   	nop
    827c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8280:	89 7d dc             	mov    %edi,-0x24(%ebp)
	while(continue_flag==1){
		if(lcid==0){								//ccch
		    //fsm_printf("There are two SDU from CCCH ,error \n");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8283:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8286:	b9 0a 00 00 00       	mov    $0xa,%ecx
    828b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    828e:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    8294:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8297:	e8 fc ff ff ff       	call   8298 <lteMacCcchSend+0x198>
			/*
			SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity)&0x0000ffff;
			SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity&0x000f0000)>>32;
			*/
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    829c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    829f:	b9 05 00 00 00       	mov    $0x5,%ecx
    82a4:	8b 75 e0             	mov    -0x20(%ebp),%esi
    82a7:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    82ad:	83 c6 01             	add    $0x1,%esi
    82b0:	89 f2                	mov    %esi,%edx
    82b2:	e8 fc ff ff ff       	call   82b3 <lteMacCcchSend+0x1b3>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    82b7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    82ba:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    82c0:	8b 00                	mov    (%eax),%eax
    82c2:	c7 04 24 6c 28 00 00 	movl   $0x286c,(%esp)
    82c9:	89 44 24 04          	mov    %eax,0x4(%esp)
    82cd:	e8 fc ff ff ff       	call   82ce <lteMacCcchSend+0x1ce>
			
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    82d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    82d5:	b9 01 00 00 00       	mov    $0x1,%ecx
    82da:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    82e0:	89 f2                	mov    %esi,%edx
    82e2:	83 c0 04             	add    $0x4,%eax
    82e5:	e8 fc ff ff ff       	call   82e6 <lteMacCcchSend+0x1e6>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    82ea:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    82ed:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    82f3:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    82f7:	c7 04 24 90 28 00 00 	movl   $0x2890,(%esp)
    82fe:	89 44 24 04          	mov    %eax,0x4(%esp)
    8302:	e8 fc ff ff ff       	call   8303 <lteMacCcchSend+0x203>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    8307:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    830a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    830d:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    8313:	8b 41 06             	mov    0x6(%ecx),%eax
    8316:	83 e0 0f             	and    $0xf,%eax
    8319:	66 03 42 04          	add    0x4(%edx),%ax
    831d:	c1 e0 08             	shl    $0x8,%eax
    8320:	66 89 42 04          	mov    %ax,0x4(%edx)
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    8324:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8327:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    832d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8331:	c7 04 24 90 28 00 00 	movl   $0x2890,(%esp)
    8338:	89 44 24 04          	mov    %eax,0x4(%esp)
    833c:	e8 fc ff ff ff       	call   833d <lteMacCcchSend+0x23d>
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
			len=sizeof(RRCConnectionRequest);
			fsm_mem_cpy(m_rrc_request,skb->data+offset,len);
    8341:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8344:	b9 0a 00 00 00       	mov    $0xa,%ecx
    8349:	8b 55 dc             	mov    -0x24(%ebp),%edx
    834c:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    8352:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8355:	e8 fc ff ff ff       	call   8356 <lteMacCcchSend+0x256>
			//fsm_printf("[HEXI]UE ID AND ESTABLUSHMENT CAUSE AND THE OFFSET:%d,%d,%d\n",(m_rrc_request->ue_Identity.s_TMSI.mmec+m_rrc_request->ue_Identity.s_TMSI.m_TMSI),m_rrc_request->establishmentCause,offset);

			//SV(m_temp_cr)->m_part_1=(m_rrc_request->ue_Identity.randomValue)&0x0000ffff;	//randomValue32
			//SV(m_temp_cr)->m_part_2=(m_rrc_request->ue_Identity.randomValue&0x000f0000)>>32;	//randomValue33~40
			len=sizeof(SV(m_temp_cr)->m_part_1);
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
    835a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    835d:	b9 05 00 00 00       	mov    $0x5,%ecx
    8362:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8368:	89 f2                	mov    %esi,%edx
    836a:	e8 fc ff ff ff       	call   836b <lteMacCcchSend+0x26b>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
    836f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    8372:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    8378:	8b 00                	mov    (%eax),%eax
    837a:	c7 04 24 6c 28 00 00 	movl   $0x286c,(%esp)
    8381:	89 44 24 04          	mov    %eax,0x4(%esp)
    8385:	e8 fc ff ff ff       	call   8386 <lteMacCcchSend+0x286>
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
    838a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    838d:	b9 02 00 00 00       	mov    $0x2,%ecx
    8392:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    8398:	31 d2                	xor    %edx,%edx
    839a:	83 c0 04             	add    $0x4,%eax
    839d:	e8 fc ff ff ff       	call   839e <lteMacCcchSend+0x29e>
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    83a2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    83a5:	89 f2                	mov    %esi,%edx
		f_domain=m_7bit_subhead->m_f_l>>7;
		
	}
		if(lcid==0){								//ccch
		    //fsm_printf("This SDU is from CCCH ");//testing code
		    ccch_or_not = 0;//CCCH 
    83a7:	31 f6                	xor    %esi,%esi
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_1),&(m_rrc_request->ue_Identity),len+1);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_1=%d\n",SV(m_temp_cr)->m_part_1);
			
			fsm_mem_set(&(SV(m_temp_cr)->m_part_2),0,sizeof(u16));
			fsm_mem_cpy(&(SV(m_temp_cr)->m_part_2),&(m_rrc_request->ue_Identity),1);
    83a9:	8b 81 a0 01 00 00    	mov    0x1a0(%ecx),%eax
    83af:	b9 01 00 00 00       	mov    $0x1,%ecx
    83b4:	83 c0 04             	add    $0x4,%eax
    83b7:	e8 fc ff ff ff       	call   83b8 <lteMacCcchSend+0x2b8>
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    83bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    83bf:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    83c5:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    83c9:	c7 04 24 90 28 00 00 	movl   $0x2890,(%esp)
    83d0:	89 44 24 04          	mov    %eax,0x4(%esp)
    83d4:	e8 fc ff ff ff       	call   83d5 <lteMacCcchSend+0x2d5>
			
			SV(m_temp_cr)->m_part_2=SV(m_temp_cr)->m_part_2+(m_rrc_request->establishmentCause&0x000f)<<8;	//establishmentCause8m_part_2
    83d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    83dc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    83df:	8b 90 a0 01 00 00    	mov    0x1a0(%eax),%edx
    83e5:	8b 41 06             	mov    0x6(%ecx),%eax
    83e8:	83 e0 0f             	and    $0xf,%eax
    83eb:	66 03 42 04          	add    0x4(%edx),%ax
    83ef:	c1 e0 08             	shl    $0x8,%eax
    83f2:	66 89 42 04          	mov    %ax,0x4(%edx)
			//fsm_printf("[MAC CCCHSEND]%d\n",m_rrc_request->establishmentCause);
			
			fsm_printf("[HEXI]SV(m_temp_cr)->m_part_2=%d\n",SV(m_temp_cr)->m_part_2);
    83f6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    83f9:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    83ff:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    8403:	c7 04 24 90 28 00 00 	movl   $0x2890,(%esp)
    840a:	89 44 24 04          	mov    %eax,0x4(%esp)
    840e:	e8 fc ff ff ff       	call   840f <lteMacCcchSend+0x30f>
    8413:	e9 42 fe ff ff       	jmp    825a <lteMacCcchSend+0x15a>
    8418:	8b 45 e0             	mov    -0x20(%ebp),%eax
    841b:	8d 70 01             	lea    0x1(%eax),%esi
    841e:	e9 1e ff ff ff       	jmp    8341 <lteMacCcchSend+0x241>
    8423:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    8429:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008430 <setMACtoRLC_IciMsg>:
 * @function: fill in the ICI from MAC to RLC
 * @param ici_msg: the structure of the ICI
 * @param pbch: the channel that carries the PDU
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
    8430:	55                   	push   %ebp
    8431:	89 e5                	mov    %esp,%ebp
    8433:	83 ec 0c             	sub    $0xc,%esp
    8436:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8439:	89 75 f8             	mov    %esi,-0x8(%ebp)
    843c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    843f:	e8 fc ff ff ff       	call   8440 <setMACtoRLC_IciMsg+0x10>
    8444:	89 c3                	mov    %eax,%ebx
    8446:	89 d6                	mov    %edx,%esi
    8448:	89 cf                	mov    %ecx,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    844a:	e8 fc ff ff ff       	call   844b <setMACtoRLC_IciMsg+0x1b>
	ici_msg->lcid=lcid;
    844f:	89 fa                	mov    %edi,%edx
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8451:	8b 7d fc             	mov    -0x4(%ebp),%edi
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
    8454:	89 73 02             	mov    %esi,0x2(%ebx)
	ici_msg->rnti=SV(C_RNTI);	
	FOUT;
}
    8457:	8b 75 f8             	mov    -0x8(%ebp),%esi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    845a:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    845d:	0f b7 00             	movzwl (%eax),%eax
    8460:	66 89 03             	mov    %ax,(%ebx)
	FOUT;
}
    8463:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    8466:	89 ec                	mov    %ebp,%esp
    8468:	5d                   	pop    %ebp
    8469:	c3                   	ret    
    846a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008470 <setMACtoPHY_IciMsg>:
	SV(sys_frame).subframeNo=0;
		
	//
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
    8470:	55                   	push   %ebp
    8471:	89 e5                	mov    %esp,%ebp
    8473:	83 ec 0c             	sub    $0xc,%esp
    8476:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    8479:	89 75 f8             	mov    %esi,-0x8(%ebp)
    847c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    847f:	e8 fc ff ff ff       	call   8480 <setMACtoPHY_IciMsg+0x10>
    8484:	89 d6                	mov    %edx,%esi
    8486:	89 cf                	mov    %ecx,%edi
    8488:	89 c3                	mov    %eax,%ebx
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
    848a:	e8 fc ff ff ff       	call   848b <setMACtoPHY_IciMsg+0x1b>
	ici_msg->tcid=tcid;
    848f:	89 f2                	mov    %esi,%edx
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    8491:	66 85 ff             	test   %di,%di
	FOUT;
}*/
void setMACtoPHY_IciMsg( MACtoPHYadapter_IciMsg *ici_msg,u32 tcid,u16 rnti){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());
	SV_PTR_GET(rlc_mac_sv);
	ici_msg->tcid=tcid;
    8494:	88 53 06             	mov    %dl,0x6(%ebx)
	ici_msg->rnti= rnti==0?(SV(C_RNTI)==0?SV(T_C_RNTI):SV(C_RNTI)):rnti;
    8497:	75 0c                	jne    84a5 <setMACtoPHY_IciMsg+0x35>
    8499:	0f b7 38             	movzwl (%eax),%edi
    849c:	66 85 ff             	test   %di,%di
    849f:	75 04                	jne    84a5 <setMACtoPHY_IciMsg+0x35>
    84a1:	0f b7 78 02          	movzwl 0x2(%eax),%edi
    84a5:	66 89 7b 04          	mov    %di,0x4(%ebx)

	ici_msg->frameNo=SV(sys_frame).frameNo;
    84a9:	0f b7 50 06          	movzwl 0x6(%eax),%edx
    84ad:	66 89 13             	mov    %dx,(%ebx)
	ici_msg->subframeNo=SV(sys_frame).subframeNo;
    84b0:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    84b4:	66 89 53 02          	mov    %dx,0x2(%ebx)
	SV(sys_frame).frameNo=0;
    84b8:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
	SV(sys_frame).subframeNo=0;
    84be:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		
	//
	FOUT;
}
    84c4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    84c7:	8b 75 f8             	mov    -0x8(%ebp),%esi
    84ca:	8b 7d fc             	mov    -0x4(%ebp),%edi
    84cd:	89 ec                	mov    %ebp,%esp
    84cf:	5d                   	pop    %ebp
    84d0:	c3                   	ret    
    84d1:	eb 0d                	jmp    84e0 <lteMacCEBSRSend>
    84d3:	90                   	nop
    84d4:	90                   	nop
    84d5:	90                   	nop
    84d6:	90                   	nop
    84d7:	90                   	nop
    84d8:	90                   	nop
    84d9:	90                   	nop
    84da:	90                   	nop
    84db:	90                   	nop
    84dc:	90                   	nop
    84dd:	90                   	nop
    84de:	90                   	nop
    84df:	90                   	nop

000084e0 <lteMacCEBSRSend>:
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    84e0:	55                   	push   %ebp
    84e1:	89 e5                	mov    %esp,%ebp
    84e3:	57                   	push   %edi
    84e4:	56                   	push   %esi
    84e5:	53                   	push   %ebx
    84e6:	83 ec 08             	sub    $0x8,%esp
    84e9:	e8 fc ff ff ff       	call   84ea <lteMacCEBSRSend+0xa>
    84ee:	89 c7                	mov    %eax,%edi
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    84f0:	b8 1a 00 00 00       	mov    $0x1a,%eax
 * @param shortbsr_buffer_size: indicate the buffer size if there is a short BSR control element to send
 * @param longbsr_buf_sizes: indicate each buffer size of the four logical channel groups if there is a long BSR control element to send
 * @param size_of_longbsr: total size of the long BSR
 * @return 0 if none BSR need be sent;1 if a short BSR needs to be sent;>1 if a long BSR need be sent
 */
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
    84f5:	89 55 f0             	mov    %edx,-0x10(%ebp)
    84f8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
    84fb:	e8 fc ff ff ff       	call   84fc <lteMacCEBSRSend+0x1c>
    8500:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
    8502:	e8 fc ff ff ff       	call   8503 <lteMacCEBSRSend+0x23>

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8507:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    850c:	31 d2                	xor    %edx,%edx
	
	u32 lcg_numb=0;
	u32 len=sizeof(MacCeListElement_s);  
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);
    850e:	89 c3                	mov    %eax,%ebx

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    8510:	89 f0                	mov    %esi,%eax
    8512:	e8 fc ff ff ff       	call   8513 <lteMacCEBSRSend+0x33>
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8517:	31 c0                	xor    %eax,%eax
    8519:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
    8520:	0f b6 94 c3 a5 01 00 	movzbl 0x1a5(%ebx,%eax,8),%edx
    8527:	00 
    8528:	80 fa 1d             	cmp    $0x1d,%dl
    852b:	74 2b                	je     8558 <lteMacCEBSRSend+0x78>
					*lcg_id=0;
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
    852d:	80 fa 1e             	cmp    $0x1e,%dl
    8530:	0f 84 92 00 00 00    	je     85c8 <lteMacCEBSRSend+0xe8>
	//unsigned char regular_flag=SEND_REGULAR_BSR,period_flag=SEND_PERIODIC_BSR;	//provided bt Liu Hanli.It is for judging which BSR is to send.However I can judge whiout them.I wonder if I'm right.
	MacCeListElement_s *m_bsr_infor=(MacCeListElement_s*)fsm_mem_alloc(sizeof(MacCeListElement_s));	//20140430
	SV_PTR_GET(rlc_mac_sv);

	fsm_mem_set(m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR
    8536:	83 c0 01             	add    $0x1,%eax
    8539:	83 f8 08             	cmp    $0x8,%eax
    853c:	75 e2                	jne    8520 <lteMacCEBSRSend+0x40>
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    853e:	89 f0                	mov    %esi,%eax
	FRET(0);
    8540:	31 db                	xor    %ebx,%ebx
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
    8542:	e8 fc ff ff ff       	call   8543 <lteMacCEBSRSend+0x63>
	FRET(0);
}
    8547:	89 d8                	mov    %ebx,%eax
    8549:	83 c4 08             	add    $0x8,%esp
    854c:	5b                   	pop    %ebx
    854d:	5e                   	pop    %esi
    854e:	5f                   	pop    %edi
    854f:	5d                   	pop    %ebp
    8550:	c3                   	ret    
    8551:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8558:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    855f:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    8564:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    8566:	31 db                	xor    %ebx,%ebx
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++){		//BSR

		//fsm_printf("[BSR_SEND]LCID IN BSR DETECT:%d\n",SV(MAC_CE_Tags[tag_pos]).LCID);

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    8568:	e8 fc ff ff ff       	call   8569 <lteMacCEBSRSend+0x89>
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    856d:	8b 46 06             	mov    0x6(%esi),%eax
    8570:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8573:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8575:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8578:	31 c0                	xor    %eax,%eax
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
    857a:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    857e:	85 c9                	test   %ecx,%ecx
    8580:	74 36                	je     85b8 <lteMacCEBSRSend+0xd8>
					lcg_numb++;
					*lcg_id=lcg_pos;
    8582:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    8584:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){	//ID
					lcg_numb++;
    8588:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    858b:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    858e:	83 fb 01             	cmp    $0x1,%ebx
    8591:	76 06                	jbe    8599 <lteMacCEBSRSend+0xb9>
					*lcg_id=0;
    8593:	c7 07 00 00 00 00    	movl   $0x0,(%edi)

		if(SV(MAC_CE_Tags[tag_pos]).LCID==SHORT_BSR){	//BSR
		    fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
		//	memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);//201405012 
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8599:	83 c0 01             	add    $0x1,%eax
    859c:	83 f8 04             	cmp    $0x4,%eax
    859f:	75 d9                	jne    857a <lteMacCEBSRSend+0x9a>
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
			fsm_mem_free(m_bsr_infor);
    85a1:	89 f0                	mov    %esi,%eax
    85a3:	e8 fc ff ff ff       	call   85a4 <lteMacCEBSRSend+0xc4>
			FRET(lcg_numb);
		}
	}
	fsm_mem_free(m_bsr_infor);
	FRET(0);
}
    85a8:	83 c4 08             	add    $0x8,%esp
    85ab:	89 d8                	mov    %ebx,%eax
    85ad:	5b                   	pop    %ebx
    85ae:	5e                   	pop    %esi
    85af:	5f                   	pop    %edi
    85b0:	5d                   	pop    %ebp
    85b1:	c3                   	ret    
    85b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    85b8:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    85bf:	eb cd                	jmp    858e <lteMacCEBSRSend+0xae>
    85c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    85c8:	8b 94 c3 a8 01 00 00 	mov    0x1a8(%ebx,%eax,8),%edx
    85cf:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    85d4:	89 f0                	mov    %esi,%eax
u32 lteMacCEBSRSend(u32 *lcg_id,u32 *shortbsr_buffer_size,u32 longbsr_buf_sizes[],u32 size_of_longbsr){//01BSR1BSR//BSR
        FIN(lteMacCEBSRSend());  
		//bool beak_flag=false;
	u32 tag_pos,lcg_pos;
	
	u32 lcg_numb=0;
    85d6:	31 db                	xor    %ebx,%ebx
			}
			fsm_mem_free(m_bsr_infor);
			FRET(lcg_numb);
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
    85d8:	e8 fc ff ff ff       	call   85d9 <lteMacCEBSRSend+0xf9>
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
    85dd:	8b 46 06             	mov    0x6(%esi),%eax
    85e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    85e3:	89 02                	mov    %eax,(%edx)
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    85e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    85e8:	31 c0                	xor    %eax,%eax
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
    85ea:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
    85ee:	85 c9                	test   %ecx,%ecx
    85f0:	74 36                	je     8628 <lteMacCEBSRSend+0x148>
					lcg_numb++;
					*lcg_id=lcg_pos;
    85f2:	89 07                	mov    %eax,(%edi)
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    85f4:	8b 4c 86 0a          	mov    0xa(%esi,%eax,4),%ecx
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
				//fsm_printf("[BSR_SEND]THE %dTH BUFFER STATUS is %d\n",lcg_pos,m_bsr_infor->m_bufferStatus[lcg_pos]);

				if(m_bsr_infor->m_bufferStatus[lcg_pos]!=0){
					lcg_numb++;
    85f8:	83 c3 01             	add    $0x1,%ebx
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
    85fb:	89 0c 82             	mov    %ecx,(%edx,%eax,4)
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
    85fe:	83 fb 01             	cmp    $0x1,%ebx
    8601:	76 06                	jbe    8609 <lteMacCEBSRSend+0x129>
					*lcg_id=0;
    8603:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
		}
		else if(SV(MAC_CE_Tags[tag_pos]).LCID==LONG_BSR){
			 fsm_mem_cpy(m_bsr_infor, SV(MAC_CE_Tags[tag_pos]).MAC_CE_ptr,len);
			//memcpy(m_bsr_infor,&SV(MAC_CE_Tags[i]),len);
			*shortbsr_buffer_size=m_bsr_infor->m_TotalLcgData;
			for(lcg_pos=0;lcg_pos<LCG_SIZE;lcg_pos++){
    8609:	83 c0 01             	add    $0x1,%eax
    860c:	83 f8 04             	cmp    $0x4,%eax
    860f:	75 d9                	jne    85ea <lteMacCEBSRSend+0x10a>
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8611:	8b 55 f0             	mov    -0x10(%ebp),%edx
			fsm_mem_free(m_bsr_infor);
    8614:	89 f0                	mov    %esi,%eax
				else
					longbsr_buf_sizes[lcg_pos]=0;
				if(lcg_numb>1)
					*lcg_id=0;
			}
			*shortbsr_buffer_size=0;		//BSR
    8616:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			fsm_mem_free(m_bsr_infor);
    861c:	e8 fc ff ff ff       	call   861d <lteMacCEBSRSend+0x13d>
    8621:	eb 85                	jmp    85a8 <lteMacCEBSRSend+0xc8>
    8623:	90                   	nop
    8624:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					lcg_numb++;
					*lcg_id=lcg_pos;
					longbsr_buf_sizes[lcg_pos]=m_bsr_infor->m_bufferStatus[lcg_pos];
				}
				else
					longbsr_buf_sizes[lcg_pos]=0;
    8628:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
    862f:	eb cd                	jmp    85fe <lteMacCEBSRSend+0x11e>
    8631:	eb 0d                	jmp    8640 <lteMacGetDlHeadLength>
    8633:	90                   	nop
    8634:	90                   	nop
    8635:	90                   	nop
    8636:	90                   	nop
    8637:	90                   	nop
    8638:	90                   	nop
    8639:	90                   	nop
    863a:	90                   	nop
    863b:	90                   	nop
    863c:	90                   	nop
    863d:	90                   	nop
    863e:	90                   	nop
    863f:	90                   	nop

00008640 <lteMacGetDlHeadLength>:
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8640:	55                   	push   %ebp
    8641:	89 e5                	mov    %esp,%ebp
    8643:	57                   	push   %edi
    8644:	56                   	push   %esi
    8645:	53                   	push   %ebx
    8646:	83 ec 1c             	sub    $0x1c,%esp
    8649:	e8 fc ff ff ff       	call   864a <lteMacGetDlHeadLength+0xa>
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
    864e:	31 db                	xor    %ebx,%ebx
/**
 * @function: calculate the length of the head of the downlink MAC PDU
 * @param skb: the sk_buff contains the PDU from SRIO layer
 * @return: the length of the head
 */
u32 lteMacGetDlHeadLength(FSM_PKT *skb){	//
    8650:	89 c6                	mov    %eax,%esi
	FIN(lteMacGetDlHeadLength());

	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
    8652:	b8 03 00 00 00       	mov    $0x3,%eax
    8657:	e8 fc ff ff ff       	call   8658 <lteMacGetDlHeadLength+0x18>
    865c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
    865f:	b8 01 00 00 00       	mov    $0x1,%eax
    8664:	e8 fc ff ff ff       	call   8665 <lteMacGetDlHeadLength+0x25>
    8669:	89 c7                	mov    %eax,%edi
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    866b:	b8 02 00 00 00       	mov    $0x2,%eax
    8670:	e8 fc ff ff ff       	call   8671 <lteMacGetDlHeadLength+0x31>

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8675:	31 d2                	xor    %edx,%edx
    8677:	b9 03 00 00 00       	mov    $0x3,%ecx
	u32 m_e,m_lcid,m_f;

	u32 last_len=0,subhead_7bit_len=0,subhead_15bit_len=0,from_len=0;	//20140626//type, modify from_len by lxr in 20160225 
	MAC_SDU_subhead_15bit *m_15bit_subhead=(MAC_SDU_subhead_15bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_15bit));	//20140430
	MAC_SDU_subhead_last *fixed_subhead=(MAC_SDU_subhead_last*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_last));	//20140430
	MAC_SDU_subhead_7bit *m_7bit_subhead=(MAC_SDU_subhead_7bit*)fsm_mem_alloc(sizeof(MAC_SDU_subhead_7bit));	//20140430
    867c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	fsm_mem_set(m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    867f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    8682:	e8 fc ff ff ff       	call   8683 <lteMacGetDlHeadLength+0x43>
	fsm_mem_set(fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8687:	31 d2                	xor    %edx,%edx
    8689:	b9 01 00 00 00       	mov    $0x1,%ecx
    868e:	89 f8                	mov    %edi,%eax
    8690:	e8 fc ff ff ff       	call   8691 <lteMacGetDlHeadLength+0x51>
	fsm_mem_set(m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8695:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8698:	31 d2                	xor    %edx,%edx
    869a:	b9 02 00 00 00       	mov    $0x2,%ecx
    869f:	e8 fc ff ff ff       	call   86a0 <lteMacGetDlHeadLength+0x60>
	
	last_len=sizeof(MAC_SDU_subhead_last);
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
    86a4:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    86aa:	b9 01 00 00 00       	mov    $0x1,%ecx
    86af:	89 f8                	mov    %edi,%eax
    86b1:	e8 fc ff ff ff       	call   86b2 <lteMacGetDlHeadLength+0x72>
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
    86b6:	0f b6 17             	movzbl (%edi),%edx
    86b9:	89 d0                	mov    %edx,%eax
    86bb:	c0 e8 05             	shr    $0x5,%al
	//20140626
	while(m_e==1){		//
    86be:	3c 01                	cmp    $0x1,%al
    86c0:	74 4e                	je     8710 <lteMacGetDlHeadLength+0xd0>
    86c2:	e9 89 00 00 00       	jmp    8750 <lteMacGetDlHeadLength+0x110>
    86c7:	90                   	nop
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
		switch(m_lcid){
    86c8:	83 fa 1c             	cmp    $0x1c,%edx
    86cb:	74 7b                	je     8748 <lteMacGetDlHeadLength+0x108>
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
			break;
		default:
			fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    86cd:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    86d3:	b9 02 00 00 00       	mov    $0x2,%ecx
    86d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    86db:	01 da                	add    %ebx,%edx
    86dd:	e8 fc ff ff ff       	call   86de <lteMacGetDlHeadLength+0x9e>
			m_f=m_7bit_subhead->m_f_l>>7;
			if(m_f==1){
				from_len=from_len+subhead_15bit_len;
    86e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    86e5:	8d 43 03             	lea    0x3(%ebx),%eax
    86e8:	83 c3 02             	add    $0x2,%ebx
    86eb:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
    86ef:	0f 48 d8             	cmovs  %eax,%ebx
				from_len=from_len+subhead_7bit_len;
			}
			break;
		}
		//fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
		fsm_mem_cpy(fixed_subhead,skb->data,last_len);	//modify by lxr 20160225
    86f2:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    86f8:	b9 01 00 00 00       	mov    $0x1,%ecx
    86fd:	89 f8                	mov    %edi,%eax
    86ff:	e8 fc ff ff ff       	call   8700 <lteMacGetDlHeadLength+0xc0>
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
    8704:	0f b6 17             	movzbl (%edi),%edx
    8707:	89 d0                	mov    %edx,%eax
    8709:	c0 e8 05             	shr    $0x5,%al
	subhead_7bit_len=sizeof(MAC_SDU_subhead_7bit);
	subhead_15bit_len=sizeof(MAC_SDU_subhead_15bit);
	fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);	//20140626//type
	m_e=fixed_subhead->m_lcid_e_r_r>>5;
	//20140626
	while(m_e==1){		//
    870c:	3c 01                	cmp    $0x1,%al
    870e:	75 40                	jne    8750 <lteMacGetDlHeadLength+0x110>
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8710:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8713:	89 54 24 04          	mov    %edx,0x4(%esp)
    8717:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    871a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    871e:	c7 04 24 b4 28 00 00 	movl   $0x28b4,(%esp)
    8725:	e8 fc ff ff ff       	call   8726 <lteMacGetDlHeadLength+0xe6>
		
		switch(m_lcid){
    872a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    872d:	83 fa 1d             	cmp    $0x1d,%edx
    8730:	74 16                	je     8748 <lteMacGetDlHeadLength+0x108>
    8732:	76 94                	jbe    86c8 <lteMacGetDlHeadLength+0x88>
    8734:	83 fa 1e             	cmp    $0x1e,%edx
    8737:	74 0f                	je     8748 <lteMacGetDlHeadLength+0x108>
    8739:	83 fa 1f             	cmp    $0x1f,%edx
    873c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8740:	75 8b                	jne    86cd <lteMacGetDlHeadLength+0x8d>
    8742:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			break;
		case TIMING_ADVANCE_LCID :
			from_len=from_len+last_len;
			break;
		case CONTENTION_RESOLUTION_LCID :
			from_len=from_len+last_len;
    8748:	83 c3 01             	add    $0x1,%ebx
			break;
    874b:	eb a5                	jmp    86f2 <lteMacGetDlHeadLength+0xb2>
    874d:	8d 76 00             	lea    0x0(%esi),%esi
		}
		//fsm_mem_cpy(fixed_subhead,skb->data+from_len,last_len);
		fsm_mem_cpy(fixed_subhead,skb->data,last_len);	//modify by lxr 20160225
		m_e=fixed_subhead->m_lcid_e_r_r>>5;		//20140626
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
    8750:	83 e2 1f             	and    $0x1f,%edx
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
    8753:	89 54 24 04          	mov    %edx,0x4(%esp)
    8757:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    875a:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    875e:	c7 04 24 b4 28 00 00 	movl   $0x28b4,(%esp)
    8765:	e8 fc ff ff ff       	call   8766 <lteMacGetDlHeadLength+0x126>
		
	switch(m_lcid){		//while
    876a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		break;
	case DRX_LCID :
		from_len=from_len+last_len;
		break;
	case TIMING_ADVANCE_LCID :
		from_len=from_len+last_len;
    876d:	8d 43 01             	lea    0x1(%ebx),%eax
    8770:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    8773:	83 fa 1d             	cmp    $0x1d,%edx
    8776:	74 10                	je     8788 <lteMacGetDlHeadLength+0x148>
    8778:	76 36                	jbe    87b0 <lteMacGetDlHeadLength+0x170>
    877a:	83 fa 1e             	cmp    $0x1e,%edx
    877d:	74 09                	je     8788 <lteMacGetDlHeadLength+0x148>
    877f:	83 fa 1f             	cmp    $0x1f,%edx
    8782:	75 31                	jne    87b5 <lteMacGetDlHeadLength+0x175>
    8784:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
			from_len=from_len+subhead_7bit_len;
		}
		break;
	}
	fsm_mem_free(m_15bit_subhead);
    8788:	8b 45 ec             	mov    -0x14(%ebp),%eax
    878b:	e8 fc ff ff ff       	call   878c <lteMacGetDlHeadLength+0x14c>
	fsm_mem_free(fixed_subhead);
    8790:	89 f8                	mov    %edi,%eax
    8792:	e8 fc ff ff ff       	call   8793 <lteMacGetDlHeadLength+0x153>
	fsm_mem_free(m_7bit_subhead);
    8797:	8b 45 f0             	mov    -0x10(%ebp),%eax
    879a:	e8 fc ff ff ff       	call   879b <lteMacGetDlHeadLength+0x15b>
	FRET(from_len);
}
    879f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    87a2:	83 c4 1c             	add    $0x1c,%esp
    87a5:	5b                   	pop    %ebx
    87a6:	5e                   	pop    %esi
    87a7:	5f                   	pop    %edi
    87a8:	5d                   	pop    %ebp
    87a9:	c3                   	ret    
    87aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
		m_lcid=(fixed_subhead->m_lcid_e_r_r)&31;
		
		fsm_printf("[HEXI]LCID IN GETTING HEAD LENGTH AND LENGTH OF HEAD:%d,%d\n",m_lcid,from_len);
		
	switch(m_lcid){		//while
    87b0:	83 fa 1c             	cmp    $0x1c,%edx
    87b3:	74 d3                	je     8788 <lteMacGetDlHeadLength+0x148>
		break;
	case CONTENTION_RESOLUTION_LCID :
		from_len=from_len+last_len;
		break;
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
    87b5:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    87bb:	b9 02 00 00 00       	mov    $0x2,%ecx
    87c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87c3:	01 da                	add    %ebx,%edx
    87c5:	e8 fc ff ff ff       	call   87c6 <lteMacGetDlHeadLength+0x186>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
    87ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
    87cd:	80 78 01 00          	cmpb   $0x0,0x1(%eax)
    87d1:	78 14                	js     87e7 <lteMacGetDlHeadLength+0x1a7>
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_7bit_len;
    87d3:	83 c3 02             	add    $0x2,%ebx
		
			from_len=from_len+subhead_15bit_len;
		}
		else{
			
			fsm_printf("[HEXI]COMPLEX 7 BIT SUBHEAD!\n");
    87d6:	c7 04 24 38 05 00 00 	movl   $0x538,(%esp)
    87dd:	e8 fc ff ff ff       	call   87de <lteMacGetDlHeadLength+0x19e>
		
			from_len=from_len+subhead_7bit_len;
    87e2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    87e5:	eb a1                	jmp    8788 <lteMacGetDlHeadLength+0x148>
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
		
			from_len=from_len+subhead_15bit_len;
    87e7:	83 c3 03             	add    $0x3,%ebx
	default:
		fsm_mem_cpy(m_7bit_subhead,skb->data+from_len,subhead_7bit_len);
		m_f=m_7bit_subhead->m_f_l>>7;
		if(m_f==1){
			
			fsm_printf("[HEXI]COMPLEX 15 BIT SUBHEAD!\n");
    87ea:	c7 04 24 f0 28 00 00 	movl   $0x28f0,(%esp)
    87f1:	e8 fc ff ff ff       	call   87f2 <lteMacGetDlHeadLength+0x1b2>
		
			from_len=from_len+subhead_15bit_len;
    87f6:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    87f9:	eb 8d                	jmp    8788 <lteMacGetDlHeadLength+0x148>
    87fb:	90                   	nop
    87fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00008800 <Pdcch_c_rnti>:
/**
 * @function: exclude the information in PCH, BCCH in the decomplexing to offer the result whether the MSG4 is successful
 * @param c_rnti: rnti in the PHY-T-MAC-ICI
 */

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
    8800:	55                   	push   %ebp
    8801:	89 e5                	mov    %esp,%ebp
    8803:	53                   	push   %ebx
    8804:	e8 fc ff ff ff       	call   8805 <Pdcch_c_rnti+0x5>
    8809:	89 c3                	mov    %eax,%ebx
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
    880b:	e8 fc ff ff ff       	call   880c <Pdcch_c_rnti+0xc>
	if(SV(sendmsg3)==1){//msg3
    8810:	83 b8 ec 01 00 00 01 	cmpl   $0x1,0x1ec(%eax)
    8817:	74 0f                	je     8828 <Pdcch_c_rnti+0x28>
			fsm_schedule_self(0, ContentionResolution_Fail );//3
			//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution fail\n");
		}
	}
	else
		SV(pdcch_rnti)=0;
    8819:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    8820:	00 00 00 
	FOUT;
}
    8823:	5b                   	pop    %ebx
    8824:	5d                   	pop    %ebp
    8825:	c3                   	ret    
    8826:	66 90                	xchg   %ax,%ax

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8828:	0f b7 10             	movzwl (%eax),%edx
    882b:	66 39 da             	cmp    %bx,%dx
    882e:	74 20                	je     8850 <Pdcch_c_rnti+0x50>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
				//fsm_printf("UE MAC Pdcch_c_rnti:Contention Resolution successfully\n");
			}				
		}
		else if ((c_rnti !=SV(C_RNTI)) && SV(C_RNTI)!=0){//PDCCHCRNTI
    8830:	66 85 d2             	test   %dx,%dx
    8833:	74 ee                	je     8823 <Pdcch_c_rnti+0x23>
			SV(pdcch_rnti)=0;//0
    8835:	c7 80 f0 01 00 00 00 	movl   $0x0,0x1f0(%eax)
    883c:	00 00 00 
			fsm_schedule_self(0, ContentionResolution_Fail );//3
    883f:	ba 05 00 00 00       	mov    $0x5,%edx
    8844:	31 c0                	xor    %eax,%eax
    8846:	e8 fc ff ff ff       	call   8847 <Pdcch_c_rnti+0x47>
    884b:	eb d6                	jmp    8823 <Pdcch_c_rnti+0x23>
    884d:	8d 76 00             	lea    0x0(%esi),%esi

void Pdcch_c_rnti(unsigned short c_rnti){//PCH,BCCHMSG4
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
    8850:	66 85 d2             	test   %dx,%dx
    8853:	74 ce                	je     8823 <Pdcch_c_rnti+0x23>
		{
			SV(pdcch_rnti)=1;//1
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8855:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
	FIN(Pdcch_c_rnti(unsigned short c_rnti));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(sendmsg3)==1){//msg3
		if((c_rnti==SV(C_RNTI)) && SV(C_RNTI)!=0)//PDCCHC_RNTI
		{
			SV(pdcch_rnti)=1;//1
    885c:	c7 80 f0 01 00 00 01 	movl   $0x1,0x1f0(%eax)
    8863:	00 00 00 
			//if((SV(RA_Type.ra_type)==1) &&SV(CRTimer.flag)==true)//PDCCH
			if(SV(CRTimer.flag)==true)	//test,for struct RA_Type in the last row is unkown
    8866:	74 bb                	je     8823 <Pdcch_c_rnti+0x23>
			{
				fsm_schedule_self(0, Contention_Success );//3//3GPPP121 	
    8868:	ba 06 00 00 00       	mov    $0x6,%edx
    886d:	31 c0                	xor    %eax,%eax
    886f:	e8 fc ff ff ff       	call   8870 <Pdcch_c_rnti+0x70>
    8874:	eb ad                	jmp    8823 <Pdcch_c_rnti+0x23>
    8876:	8d 76 00             	lea    0x0(%esi),%esi
    8879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00008880 <compare>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
    8880:	55                   	push   %ebp
    8881:	89 e5                	mov    %esp,%ebp
    8883:	e8 fc ff ff ff       	call   8884 <compare+0x4>
	u32 ret=first<second?0:1;
	return ret;
}
    8888:	5d                   	pop    %ebp
/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
u32 compare(u32 first,u32 second){
	u32 ret=first<second?0:1;
    8889:	39 d0                	cmp    %edx,%eax
    888b:	0f 93 c0             	setae  %al
    888e:	0f b6 c0             	movzbl %al,%eax
	return ret;
}
    8891:	c3                   	ret    
    8892:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    8899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000088a0 <decomplexUeRARPdu>:
/**
 * @function: decomplex RAR PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
 void decomplexUeRARPdu(FSM_PKT *skb)
{
    88a0:	55                   	push   %ebp
    88a1:	89 e5                	mov    %esp,%ebp
    88a3:	56                   	push   %esi
    88a4:	53                   	push   %ebx
    88a5:	83 ec 18             	sub    $0x18,%esp
    88a8:	e8 fc ff ff ff       	call   88a9 <decomplexUeRARPdu+0x9>
    88ad:	89 c3                	mov    %eax,%ebx
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    88af:	e8 fc ff ff ff       	call   88b0 <decomplexUeRARPdu+0x10>

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    88b4:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
{
	FIN(decomplexUeRARPdu());
	FSM_PKT *newskb;
	u32 len;
	u32 from_len=0,head_len;
	SV_PTR_GET(rlc_mac_sv);
    88ba:	89 c6                	mov    %eax,%esi

	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    88bc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    88c2:	29 d0                	sub    %edx,%eax
    88c4:	83 f8 06             	cmp    $0x6,%eax
    88c7:	0f 86 a0 01 00 00    	jbe    8a6d <decomplexUeRARPdu+0x1cd>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    88cd:	b9 07 00 00 00       	mov    $0x7,%ecx
    88d2:	8d 45 f1             	lea    -0xf(%ebp),%eax
    88d5:	e8 fc ff ff ff       	call   88d6 <decomplexUeRARPdu+0x36>
	if(m_phy_ici.tcid==BCH){
    88da:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    88de:	3c 01                	cmp    $0x1,%al
    88e0:	0f 84 d2 00 00 00    	je     89b8 <decomplexUeRARPdu+0x118>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    88e6:	84 c0                	test   %al,%al
    88e8:	74 0e                	je     88f8 <decomplexUeRARPdu+0x58>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    88ea:	3c 02                	cmp    $0x2,%al
    88ec:	74 72                	je     8960 <decomplexUeRARPdu+0xc0>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    88ee:	83 c4 18             	add    $0x18,%esp
    88f1:	5b                   	pop    %ebx
    88f2:	5e                   	pop    %esi
    88f3:	5d                   	pop    %ebp
    88f4:	c3                   	ret    
    88f5:	8d 76 00             	lea    0x0(%esi),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    88f8:	c7 04 24 9e 05 00 00 	movl   $0x59e,(%esp)
    88ff:	e8 fc ff ff ff       	call   8900 <decomplexUeRARPdu+0x60>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8904:	e8 fc ff ff ff       	call   8905 <decomplexUeRARPdu+0x65>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8909:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    890f:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    8913:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    891a:	0f b7 00             	movzwl (%eax),%eax
    891d:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8921:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8927:	29 c2                	sub    %eax,%edx
    8929:	83 fa 06             	cmp    $0x6,%edx
    892c:	0f 86 5a 01 00 00    	jbe    8a8c <decomplexUeRARPdu+0x1ec>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8932:	8d 55 ea             	lea    -0x16(%ebp),%edx
    8935:	b9 07 00 00 00       	mov    $0x7,%ecx
    893a:	e8 fc ff ff ff       	call   893b <decomplexUeRARPdu+0x9b>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    893f:	31 c0                	xor    %eax,%eax
    8941:	e8 fc ff ff ff       	call   8942 <decomplexUeRARPdu+0xa2>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8946:	8b 43 50             	mov    0x50(%ebx),%eax
    8949:	c7 04 24 10 29 00 00 	movl   $0x2910,(%esp)
    8950:	89 44 24 04          	mov    %eax,0x4(%esp)
    8954:	e8 fc ff ff ff       	call   8955 <decomplexUeRARPdu+0xb5>
		fsm_printf("decomplex for RAR function done\n");//testing code
			
		FOUT;
	}
		
}
    8959:	83 c4 18             	add    $0x18,%esp
    895c:	5b                   	pop    %ebx
    895d:	5e                   	pop    %esi
    895e:	5d                   	pop    %ebp
    895f:	c3                   	ret    
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8960:	c7 04 24 cf 05 00 00 	movl   $0x5cf,(%esp)
    8967:	e8 fc ff ff ff       	call   8968 <decomplexUeRARPdu+0xc8>
		len=sizeof(char);
		head_len=lteMacGetDlHeadLength(skb);	//SDU
    896c:	89 d8                	mov    %ebx,%eax
    896e:	e8 fc ff ff ff       	call   896f <decomplexUeRARPdu+0xcf>
		
		//fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX:%d\n",head_len);

		if(!compare(skb->tail-skb->data,len)){
    8973:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8979:	39 83 a0 00 00 00    	cmp    %eax,0xa0(%ebx)
    897f:	0f 84 26 01 00 00    	je     8aab <decomplexUeRARPdu+0x20b>
			printk("ue mac_pkthandler 767\n");
			FOUT;
		}
		
		from_len=len;	//()
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
    8985:	80 be 98 01 00 00 00 	cmpb   $0x0,0x198(%esi)
    898c:	0f 85 86 00 00 00    	jne    8a18 <decomplexUeRARPdu+0x178>
					fsm_schedule_self(0,RandomAcc_Fail);
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
				} 
		}
		else { //RAR
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test	
    8992:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		}
		fsm_pkt_destroy(skb);//
    8999:	89 d8                	mov    %ebx,%eax
    899b:	e8 fc ff ff ff       	call   899c <decomplexUeRARPdu+0xfc>
		//printk("ue mac_pkthandler 796\n");
		fsm_printf("decomplex for RAR function done\n");//testing code
    89a0:	c7 04 24 68 29 00 00 	movl   $0x2968,(%esp)
    89a7:	e8 fc ff ff ff       	call   89a8 <decomplexUeRARPdu+0x108>
			
		FOUT;
	}
		
}
    89ac:	83 c4 18             	add    $0x18,%esp
    89af:	5b                   	pop    %ebx
    89b0:	5e                   	pop    %esi
    89b1:	5d                   	pop    %ebp
    89b2:	c3                   	ret    
    89b3:	90                   	nop
    89b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    89b8:	c7 04 24 6d 05 00 00 	movl   $0x56d,(%esp)
    89bf:	e8 fc ff ff ff       	call   89c0 <decomplexUeRARPdu+0x120>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    89c4:	e8 fc ff ff ff       	call   89c5 <decomplexUeRARPdu+0x125>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    89c9:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    89cf:	c6 45 f0 00          	movb   $0x0,-0x10(%ebp)
	ici_msg->pbch=pbch;
    89d3:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    89da:	0f b7 00             	movzwl (%eax),%eax
    89dd:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    89e1:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    89e7:	29 c2                	sub    %eax,%edx
    89e9:	83 fa 06             	cmp    $0x6,%edx
    89ec:	0f 87 40 ff ff ff    	ja     8932 <decomplexUeRARPdu+0x92>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    89f2:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    89f9:	89 d8                	mov    %ebx,%eax
    89fb:	e8 fc ff ff ff       	call   89fc <decomplexUeRARPdu+0x15c>
			printk("ue mac_pkthandler 715\n");
    8a00:	c7 04 24 87 05 00 00 	movl   $0x587,(%esp)
    8a07:	e8 fc ff ff ff       	call   8a08 <decomplexUeRARPdu+0x168>
			FOUT;
    8a0c:	e9 dd fe ff ff       	jmp    88ee <decomplexUeRARPdu+0x4e>
    8a11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			FOUT;
		}
		
		from_len=len;	//()
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
    8a18:	8b 86 94 01 00 00    	mov    0x194(%esi),%eax
    8a1e:	e8 fc ff ff ff       	call   8a1f <decomplexUeRARPdu+0x17f>
				SV(WaitforRAresponseTimer.flag)=false;
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    8a23:	89 d8                	mov    %ebx,%eax
		}
		
		from_len=len;	//()
        if(true==SV(WaitforRAresponseTimer.flag)){ //RAR  RAR  
				fsm_schedule_cancel(SV(WaitforRAresponseTimer.timer_sign));
				SV(WaitforRAresponseTimer.flag)=false;
    8a25:	c6 86 98 01 00 00 00 	movb   $0x0,0x198(%esi)
				SV(WaitforRAresponseTimer.timer_sign)=NULL;	//20140626//timer_sign
    8a2c:	c7 86 94 01 00 00 00 	movl   $0x0,0x194(%esi)
    8a33:	00 00 00 
		    
				if(decomplexRarPdu(skb)==true ) //RAR
    8a36:	e8 fc ff ff ff       	call   8a37 <decomplexUeRARPdu+0x197>
    8a3b:	84 c0                	test   %al,%al
    8a3d:	74 11                	je     8a50 <decomplexUeRARPdu+0x1b0>
					fsm_schedule_self(0,RARrev_Success);
    8a3f:	ba 04 00 00 00       	mov    $0x4,%edx
    8a44:	31 c0                	xor    %eax,%eax
    8a46:	e8 fc ff ff ff       	call   8a47 <decomplexUeRARPdu+0x1a7>
    8a4b:	e9 49 ff ff ff       	jmp    8999 <decomplexUeRARPdu+0xf9>
				else{
					fsm_schedule_self(0,RandomAcc_Fail);
    8a50:	ba 03 00 00 00       	mov    $0x3,%edx
    8a55:	31 c0                	xor    %eax,%eax
    8a57:	e8 fc ff ff ff       	call   8a58 <decomplexUeRARPdu+0x1b8>
					fsm_printf("[RLC_MAC][decomplexUeRARPdu]decomplexRarPdu false!\n");
    8a5c:	c7 04 24 34 29 00 00 	movl   $0x2934,(%esp)
    8a63:	e8 fc ff ff ff       	call   8a64 <decomplexUeRARPdu+0x1c4>
    8a68:	e9 2c ff ff ff       	jmp    8999 <decomplexUeRARPdu+0xf9>
	MACtoRLC_IciMsg m_rlc_type2_icimsg;
	PHYadaptertoMAC_IciMsg m_phy_ici;
	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8a6d:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
		fsm_pkt_destroy(skb);
    8a74:	89 d8                	mov    %ebx,%eax
    8a76:	e8 fc ff ff ff       	call   8a77 <decomplexUeRARPdu+0x1d7>
		printk("ue mac_pkthandler 701\n");
    8a7b:	c7 04 24 56 05 00 00 	movl   $0x556,(%esp)
    8a82:	e8 fc ff ff ff       	call   8a83 <decomplexUeRARPdu+0x1e3>
		FOUT;
    8a87:	e9 62 fe ff ff       	jmp    88ee <decomplexUeRARPdu+0x4e>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8a8c:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8a93:	89 d8                	mov    %ebx,%eax
    8a95:	e8 fc ff ff ff       	call   8a96 <decomplexUeRARPdu+0x1f6>
			printk("ue mac_pkthandler 740\n");
    8a9a:	c7 04 24 b8 05 00 00 	movl   $0x5b8,(%esp)
    8aa1:	e8 fc ff ff ff       	call   8aa2 <decomplexUeRARPdu+0x202>
			FOUT;
    8aa6:	e9 43 fe ff ff       	jmp    88ee <decomplexUeRARPdu+0x4e>
		head_len=lteMacGetDlHeadLength(skb);	//SDU
		
		//fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX:%d\n",head_len);

		if(!compare(skb->tail-skb->data,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8aab:	83 86 0c 02 00 00 01 	addl   $0x1,0x20c(%esi)
			fsm_pkt_destroy(skb);
    8ab2:	89 d8                	mov    %ebx,%eax
    8ab4:	e8 fc ff ff ff       	call   8ab5 <decomplexUeRARPdu+0x215>
			printk("ue mac_pkthandler 767\n");
    8ab9:	c7 04 24 ec 05 00 00 	movl   $0x5ec,(%esp)
    8ac0:	e8 fc ff ff ff       	call   8ac1 <decomplexUeRARPdu+0x221>
			FOUT;
    8ac5:	e9 24 fe ff ff       	jmp    88ee <decomplexUeRARPdu+0x4e>
    8aca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00008ad0 <decomplexUeDataPdu>:

/**
 * @function: decomplex MAC SDU,along with MAC control elements, into MAC PDU
 * @param skb: the sk_buff contains the data of the SDU from RLC layer
 */
void decomplexUeDataPdu(FSM_PKT *skb){		//  
    8ad0:	55                   	push   %ebp
    8ad1:	89 e5                	mov    %esp,%ebp
    8ad3:	57                   	push   %edi
    8ad4:	56                   	push   %esi
    8ad5:	53                   	push   %ebx
    8ad6:	83 ec 54             	sub    $0x54,%esp
    8ad9:	e8 fc ff ff ff       	call   8ada <decomplexUeDataPdu+0xa>
    8ade:	89 c3                	mov    %eax,%ebx
	MAC_CE_content_resolution_identity m_content_resolution;	//20140430
	MAC_CE_time_advance m_time_advance;	//20140430
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	SV_PTR_GET(rlc_mac_sv);
    8ae0:	e8 fc ff ff ff       	call   8ae1 <decomplexUeDataPdu+0x11>

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8ae5:	31 d2                	xor    %edx,%edx
    8ae7:	b9 03 00 00 00       	mov    $0x3,%ecx
	MAC_CE_content_resolution_identity m_content_resolution;	//20140430
	MAC_CE_time_advance m_time_advance;	//20140430
	MACtoRLC_IciMsg m_rlc_type2_icimsg;		//20140430	//20140430
	PHYadaptertoMAC_IciMsg m_phy_ici;

	SV_PTR_GET(rlc_mac_sv);
    8aec:	89 45 b8             	mov    %eax,-0x48(%ebp)

	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));	//20140430
    8aef:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8af2:	e8 fc ff ff ff       	call   8af3 <decomplexUeDataPdu+0x23>
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    8af7:	31 d2                	xor    %edx,%edx
    8af9:	b9 01 00 00 00       	mov    $0x1,%ecx
    8afe:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8b01:	e8 fc ff ff ff       	call   8b02 <decomplexUeDataPdu+0x32>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));	//20140430
    8b06:	31 d2                	xor    %edx,%edx
    8b08:	b9 02 00 00 00       	mov    $0x2,%ecx
    8b0d:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8b10:	e8 fc ff ff ff       	call   8b11 <decomplexUeDataPdu+0x41>
	fsm_mem_set(&m_content_resolution,0,sizeof(MAC_CE_content_resolution_identity));	//20140430
    8b15:	31 d2                	xor    %edx,%edx
    8b17:	b9 06 00 00 00       	mov    $0x6,%ecx
    8b1c:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    8b1f:	e8 fc ff ff ff       	call   8b20 <decomplexUeDataPdu+0x50>
	fsm_mem_set(&m_time_advance,0,sizeof(MAC_CE_time_advance));	//20140430
    8b24:	31 d2                	xor    %edx,%edx
    8b26:	b9 01 00 00 00       	mov    $0x1,%ecx
    8b2b:	8d 45 f3             	lea    -0xd(%ebp),%eax
    8b2e:	e8 fc ff ff ff       	call   8b2f <decomplexUeDataPdu+0x5f>
	fsm_mem_set(&m_rlc_type2_icimsg,0,sizeof(MACtoRLC_IciMsg));	//20140430
    8b33:	31 d2                	xor    %edx,%edx
    8b35:	b9 07 00 00 00       	mov    $0x7,%ecx
    8b3a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    8b3d:	e8 fc ff ff ff       	call   8b3e <decomplexUeDataPdu+0x6e>
	fsm_mem_set(&m_padding_subhead,0,sizeof(MAC_SH_padding));	//20140430
    8b42:	31 d2                	xor    %edx,%edx
    8b44:	b9 01 00 00 00       	mov    $0x1,%ecx
    8b49:	8d 45 f2             	lea    -0xe(%ebp),%eax
    8b4c:	e8 fc ff ff ff       	call   8b4d <decomplexUeDataPdu+0x7d>
	fsm_mem_set(&m_phy_ici,0,sizeof(PHYadaptertoMAC_IciMsg));
    8b51:	31 d2                	xor    %edx,%edx
    8b53:	b9 07 00 00 00       	mov    $0x7,%ecx
    8b58:	8d 45 df             	lea    -0x21(%ebp),%eax
    8b5b:	e8 fc ff ff ff       	call   8b5c <decomplexUeDataPdu+0x8c>
    //PHYICI  HQ 20140502

	/*
	 * for test
	 */
	SV(pkt_num_downlink)=SV(pkt_num_downlink)+1;
    8b60:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8b63:	83 80 10 02 00 00 01 	addl   $0x1,0x210(%eax)


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    8b6a:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    8b70:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    8b76:	29 d0                	sub    %edx,%eax
    8b78:	83 f8 06             	cmp    $0x6,%eax
    8b7b:	0f 86 6c 06 00 00    	jbe    91ed <decomplexUeDataPdu+0x71d>
		fsm_pkt_destroy(skb);
		printk("ue mac_pkthandler 701\n");
		FOUT;
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
    8b81:	b9 07 00 00 00       	mov    $0x7,%ecx
    8b86:	8d 45 df             	lea    -0x21(%ebp),%eax
    8b89:	e8 fc ff ff ff       	call   8b8a <decomplexUeDataPdu+0xba>
	if(m_phy_ici.tcid==BCH){
    8b8e:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
    8b92:	3c 01                	cmp    $0x1,%al
    8b94:	0f 84 a6 00 00 00    	je     8c40 <decomplexUeDataPdu+0x170>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data,skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
    8b9a:	84 c0                	test   %al,%al
    8b9c:	74 32                	je     8bd0 <decomplexUeDataPdu+0x100>
		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
    8b9e:	3c 02                	cmp    $0x2,%al
    8ba0:	0f 84 f2 00 00 00    	je     8c98 <decomplexUeDataPdu+0x1c8>
	
	/*
	 * for test
	 */
	 else{
	 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    8ba6:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8ba9:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
	 }
	
   	fsm_pkt_destroy(skb);
    8bb0:	89 d8                	mov    %ebx,%eax
    8bb2:	e8 fc ff ff ff       	call   8bb3 <decomplexUeDataPdu+0xe3>
   	fsm_printf("decomplex function done\n");//testing code
    8bb7:	c7 04 24 47 07 00 00 	movl   $0x747,(%esp)
    8bbe:	e8 fc ff ff ff       	call   8bbf <decomplexUeDataPdu+0xef>
	FOUT;
}
    8bc3:	83 c4 54             	add    $0x54,%esp
    8bc6:	5b                   	pop    %ebx
    8bc7:	5e                   	pop    %esi
    8bc8:	5f                   	pop    %edi
    8bc9:	5d                   	pop    %ebp
    8bca:	c3                   	ret    
    8bcb:	90                   	nop
    8bcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		FOUT;
	}
	if(m_phy_ici.tcid==PCH){
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
    8bd0:	c7 04 24 9e 05 00 00 	movl   $0x59e,(%esp)
    8bd7:	e8 fc ff ff ff       	call   8bd8 <decomplexUeDataPdu+0x108>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8bdc:	e8 fc ff ff ff       	call   8bdd <decomplexUeDataPdu+0x10d>
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8be1:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8be7:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8beb:	c7 45 da 01 00 00 00 	movl   $0x1,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8bf2:	0f b7 00             	movzwl (%eax),%eax
    8bf5:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		// 
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8bf9:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8bff:	29 c2                	sub    %eax,%edx
    8c01:	83 fa 06             	cmp    $0x6,%edx
    8c04:	0f 86 99 06 00 00    	jbe    92a3 <decomplexUeDataPdu+0x7d3>
			printk("ue mac_pkthandler 740\n");
			FOUT;
		}


		fsm_mem_cpy(skb->head,&m_rlc_type2_icimsg,len);	//MAC TO RLCICISK_buff
    8c0a:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8c0d:	b9 07 00 00 00       	mov    $0x7,%ecx
    8c12:	e8 fc ff ff ff       	call   8c13 <decomplexUeDataPdu+0x143>
		//SK_BUFF 
		//fsm_pkt_send(skb,STRM_TO_RLC);

		rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8c17:	31 c0                	xor    %eax,%eax
    8c19:	e8 fc ff ff ff       	call   8c1a <decomplexUeDataPdu+0x14a>
		//fsm_pkt_send(skb,STRM_TO_IPADP);

		fsm_printf("[HEXI] packet sent to rlc:len:%d\n",skb->len);
    8c1e:	8b 43 50             	mov    0x50(%ebx),%eax
    8c21:	c7 04 24 10 29 00 00 	movl   $0x2910,(%esp)
    8c28:	89 44 24 04          	mov    %eax,0x4(%esp)
    8c2c:	e8 fc ff ff ff       	call   8c2d <decomplexUeDataPdu+0x15d>
	 }
	
   	fsm_pkt_destroy(skb);
   	fsm_printf("decomplex function done\n");//testing code
	FOUT;
}
    8c31:	83 c4 54             	add    $0x54,%esp
    8c34:	5b                   	pop    %ebx
    8c35:	5e                   	pop    %esi
    8c36:	5f                   	pop    %edi
    8c37:	5d                   	pop    %ebp
    8c38:	c3                   	ret    
    8c39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}

	fsm_mem_cpy(&m_phy_ici,skb->head,len);
	if(m_phy_ici.tcid==BCH){
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
    8c40:	c7 04 24 6d 05 00 00 	movl   $0x56d,(%esp)
    8c47:	e8 fc ff ff ff       	call   8c48 <decomplexUeDataPdu+0x178>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8c4c:	e8 fc ff ff ff       	call   8c4d <decomplexUeDataPdu+0x17d>
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8c51:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8c57:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8c5b:	c7 45 da 02 00 00 00 	movl   $0x2,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8c62:	0f b7 00             	movzwl (%eax),%eax
    8c65:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
		//PDU
		fsm_printf("recieve BCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,BCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
    8c69:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    8c6f:	29 c2                	sub    %eax,%edx
    8c71:	83 fa 06             	cmp    $0x6,%edx
    8c74:	77 94                	ja     8c0a <decomplexUeDataPdu+0x13a>
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8c76:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8c79:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    8c80:	89 d8                	mov    %ebx,%eax
    8c82:	e8 fc ff ff ff       	call   8c83 <decomplexUeDataPdu+0x1b3>
			printk("ue mac_pkthandler 715\n");
    8c87:	c7 04 24 87 05 00 00 	movl   $0x587,(%esp)
    8c8e:	e8 fc ff ff ff       	call   8c8f <decomplexUeDataPdu+0x1bf>
			FOUT;
    8c93:	e9 2b ff ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8c98:	c7 04 24 cf 05 00 00 	movl   $0x5cf,(%esp)


		//fsm_mem_cpy(&m_type,skb->data,len);//  HQ 20140502;delete m_type in 20160222
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
    8c9f:	31 f6                	xor    %esi,%esi
		//fsm_octets_print(skb->data, skb->len);
		
		FOUT;
	}
	if(m_phy_ici.tcid==DLSCH){
		fsm_printf("recieve DLSCH data packet, \n");//testing code
    8ca1:	e8 fc ff ff ff       	call   8ca2 <decomplexUeDataPdu+0x1d2>
		//len=sizeof(char);
		len=0;	//modify by lxr in 20160225
		head_len=lteMacGetDlHeadLength(skb);	//SDU
    8ca6:	89 d8                	mov    %ebx,%eax
    8ca8:	e8 fc ff ff ff       	call   8ca9 <decomplexUeDataPdu+0x1d9>
    8cad:	89 45 d0             	mov    %eax,-0x30(%ebp)
		//fsm_mem_cpy(&m_type,skb->data,len);//  HQ 20140502;delete m_type in 20160222
		//fsm_printf("[HEXI]TYPE IN DECOMPLEX:%c\n",(m_type+65));
		
		from_len=len;	//()
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122
			Pdcch_c_rnti(m_phy_ici.rnti);
    8cb0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
    8cb4:	e8 fc ff ff ff       	call   8cb5 <decomplexUeDataPdu+0x1e5>
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
    8cb9:	c7 04 24 03 06 00 00 	movl   $0x603,(%esp)
    8cc0:	e8 fc ff ff ff       	call   8cc1 <decomplexUeDataPdu+0x1f1>
    8cc5:	8d 76 00             	lea    0x0(%esi),%esi
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
    8cc8:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8cce:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8cd4:	29 d0                	sub    %edx,%eax
    8cd6:	39 c6                	cmp    %eax,%esi
    8cd8:	0f 84 65 04 00 00    	je     9143 <decomplexUeDataPdu+0x673>
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8cde:	01 f2                	add    %esi,%edx
    8ce0:	b9 01 00 00 00       	mov    $0x1,%ecx
    8ce5:	8d 45 f2             	lea    -0xe(%ebp),%eax
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8ce8:	bf 1f 00 00 00       	mov    $0x1f,%edi
					fsm_pkt_destroy(skb);
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
    8ced:	e8 fc ff ff ff       	call   8cee <decomplexUeDataPdu+0x21e>
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8cf2:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
    8cf6:	89 c2                	mov    %eax,%edx
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
    8cf8:	21 c7                	and    %eax,%edi
					printk("ue mac_pkthandler 814\n");
					FOUT;
				}

				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
    8cfa:	c0 ea 05             	shr    $0x5,%dl
    8cfd:	88 55 d4             	mov    %dl,-0x2c(%ebp)
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
    8d00:	89 7c 24 04          	mov    %edi,0x4(%esp)
    8d04:	c7 04 24 36 06 00 00 	movl   $0x636,(%esp)
    8d0b:	e8 fc ff ff ff       	call   8d0c <decomplexUeDataPdu+0x23c>
				switch(lcid){
    8d10:	83 ff 1d             	cmp    $0x1d,%edi
    8d13:	0f 84 67 03 00 00    	je     9080 <decomplexUeDataPdu+0x5b0>
    8d19:	0f 87 11 02 00 00    	ja     8f30 <decomplexUeDataPdu+0x460>
    8d1f:	83 ff 1c             	cmp    $0x1c,%edi
    8d22:	0f 84 28 02 00 00    	je     8f50 <decomplexUeDataPdu+0x480>
						break;
					
				}		
			}			
		
			if(lcid>=0&&lcid<11){
    8d28:	83 ff 0a             	cmp    $0xa,%edi
    8d2b:	90                   	nop
    8d2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    8d30:	0f 87 fb 04 00 00    	ja     9231 <decomplexUeDataPdu+0x761>
    8d36:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    8d39:	e9 ff 00 00 00       	jmp    8e3d <decomplexUeDataPdu+0x36d>
    8d3e:	66 90                	xchg   %ax,%ax
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8d40:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8d46:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8d4c:	29 d0                	sub    %edx,%eax
    8d4e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8d51:	83 f8 02             	cmp    $0x2,%eax
    8d54:	0f 86 2d 04 00 00    	jbe    9187 <decomplexUeDataPdu+0x6b7>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 954\n");
							FOUT;
						}

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
    8d5a:	03 55 d4             	add    -0x2c(%ebp),%edx
    8d5d:	b9 03 00 00 00       	mov    $0x3,%ecx
    8d62:	8d 45 ec             	lea    -0x14(%ebp),%eax
    8d65:	e8 fc ff ff ff       	call   8d66 <decomplexUeDataPdu+0x296>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8d6a:	e8 fc ff ff ff       	call   8d6b <decomplexUeDataPdu+0x29b>
	ici_msg->lcid=lcid;
    8d6f:	89 f2                	mov    %esi,%edx

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8d71:	0f b6 7d ee          	movzbl -0x12(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8d75:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8d78:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
	ici_msg->rnti=SV(C_RNTI);	
    8d7f:	0f b7 00             	movzwl (%eax),%eax
    8d82:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
    8d86:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    8d8a:	83 e0 7f             	and    $0x7f,%eax
						sdu_len=sdu_len<<8;
    8d8d:	c1 e0 08             	shl    $0x8,%eax
						sdu_len=sdu_len+m_15bit_subhead.m_l;
    8d90:	01 c7                	add    %eax,%edi
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8d92:	8d 47 11             	lea    0x11(%edi),%eax
    8d95:	e8 fc ff ff ff       	call   8d96 <decomplexUeDataPdu+0x2c6>
						fsm_skb_reserve(newskb,sdu_len);
    8d9a:	89 fa                	mov    %edi,%edx
						from_len=from_len+len;

						sdu_len=(m_15bit_subhead.m_f_l)&127;
						sdu_len=sdu_len<<8;
						sdu_len=sdu_len+m_15bit_subhead.m_l;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8d9c:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8d9e:	e8 fc ff ff ff       	call   8d9f <decomplexUeDataPdu+0x2cf>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
    8da3:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8da9:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    8daf:	29 c2                	sub    %eax,%edx
    8db1:	83 fa 06             	cmp    $0x6,%edx
    8db4:	0f 86 ab 03 00 00    	jbe    9165 <decomplexUeDataPdu+0x695>
							printk("ue mac_pkthandler 976\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
    8dba:	b9 07 00 00 00       	mov    $0x7,%ecx
    8dbf:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8dc2:	e8 fc ff ff ff       	call   8dc3 <decomplexUeDataPdu+0x2f3>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8dc7:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8dcd:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8dd3:	39 c7                	cmp    %eax,%edi
    8dd5:	0f 87 24 03 00 00    	ja     90ff <decomplexUeDataPdu+0x62f>
    8ddb:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8de1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8de7:	29 d0                	sub    %edx,%eax
    8de9:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8dec:	39 c7                	cmp    %eax,%edi
    8dee:	0f 87 0b 03 00 00    	ja     90ff <decomplexUeDataPdu+0x62f>

						fsm_mem_cpy(&m_15bit_subhead,skb->data+from_len,len);
					
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);	//ICI	

						from_len=from_len+len;
    8df4:	83 45 d4 03          	addl   $0x3,-0x2c(%ebp)
							printk("ue mac_pkthandler 1026\n");
							FOUT;
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
    8df8:	03 55 d0             	add    -0x30(%ebp),%edx
    8dfb:	89 f0                	mov    %esi,%eax
    8dfd:	89 55 bc             	mov    %edx,-0x44(%ebp)
    8e00:	89 fa                	mov    %edi,%edx
    8e02:	e8 fc ff ff ff       	call   8e03 <decomplexUeDataPdu+0x333>
    8e07:	8b 55 bc             	mov    -0x44(%ebp),%edx
    8e0a:	89 f9                	mov    %edi,%ecx
    8e0c:	e8 fc ff ff ff       	call   8e0d <decomplexUeDataPdu+0x33d>
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8e11:	89 f0                	mov    %esi,%eax
						}


						fsm_mem_cpy(fsm_skb_push(newskb,sdu_len),skb->data+head_len,sdu_len);
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);
						head_len=head_len+sdu_len;
    8e13:	01 7d d0             	add    %edi,-0x30(%ebp)
						//fsm_pkt_send(newskb,STRM_TO_RLC);
						
						rlc_pkt_receive_from_mac(newskb);  //add in 20150804
    8e16:	e8 fc ff ff ff       	call   8e17 <decomplexUeDataPdu+0x347>
						//fsm_pkt_send(newskb,STRM_TO_IPADP);

						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
    8e1b:	8b 46 50             	mov    0x50(%esi),%eax
    8e1e:	c7 04 24 10 29 00 00 	movl   $0x2910,(%esp)
    8e25:	89 44 24 04          	mov    %eax,0x4(%esp)
    8e29:	e8 fc ff ff ff       	call   8e2a <decomplexUeDataPdu+0x35a>
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8e2e:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
    8e32:	c0 e8 05             	shr    $0x5,%al
				}		
			}			
		
			if(lcid>=0&&lcid<11){
				continue_flag=1;
				while(continue_flag==1){
    8e35:	3c 01                	cmp    $0x1,%al
    8e37:	0f 85 73 fd ff ff    	jne    8bb0 <decomplexUeDataPdu+0xe0>
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
    8e3d:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8e43:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8e49:	29 d0                	sub    %edx,%eax
    8e4b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8e4e:	83 f8 01             	cmp    $0x1,%eax
    8e51:	0f 86 ca 02 00 00    	jbe    9121 <decomplexUeDataPdu+0x651>
						fsm_pkt_destroy(skb);
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
    8e57:	03 55 d4             	add    -0x2c(%ebp),%edx
    8e5a:	b9 02 00 00 00       	mov    $0x2,%ecx
    8e5f:	8d 45 ef             	lea    -0x11(%ebp),%eax
    8e62:	e8 fc ff ff ff       	call   8e63 <decomplexUeDataPdu+0x393>
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8e67:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8e6b:	89 d0                	mov    %edx,%eax
    8e6d:	83 e0 1f             	and    $0x1f,%eax
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8e70:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
    8e74:	89 c6                	mov    %eax,%esi
						printk("ue mac_pkthandler 940\n");
						FOUT;
					}

					fsm_mem_cpy(&m_7bit_subhead,skb->data+from_len,len);
					continue_flag=m_7bit_subhead.m_lcid_e_r_r>>5;
    8e76:	88 55 c0             	mov    %dl,-0x40(%ebp)
					lcid=(m_7bit_subhead.m_lcid_e_r_r)&31;
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
    8e79:	0f 88 c1 fe ff ff    	js     8d40 <decomplexUeDataPdu+0x270>
 * @param lcid: identity of the logical channel
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
    8e7f:	e8 fc ff ff ff       	call   8e80 <decomplexUeDataPdu+0x3b0>
	ici_msg->lcid=lcid;
    8e84:	89 f2                	mov    %esi,%edx
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8e86:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
 */
void setMACtoRLC_IciMsg(MACtoRLC_IciMsg *ici_msg,PBCH pbch,u32 lcid){	//20140430 MACtoRLC_IciMsg
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
    8e8a:	88 55 de             	mov    %dl,-0x22(%ebp)
	ici_msg->pbch=pbch;
    8e8d:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
						fsm_printf("[HEXI] packet sent to rlc:len:%d\n",newskb->len);
						//fsm_octets_print(newskb->data, newskb->len);
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
    8e94:	83 45 d4 02          	addl   $0x2,-0x2c(%ebp)
						sdu_len=(m_7bit_subhead.m_f_l)&127;
    8e98:	83 e7 7f             	and    $0x7f,%edi
	FIN(setMACtoRLC_IciMsg());

	SV_PTR_GET(rlc_mac_sv);
	ici_msg->lcid=lcid;
	ici_msg->pbch=pbch;
	ici_msg->rnti=SV(C_RNTI);	
    8e9b:	0f b7 00             	movzwl (%eax),%eax
    8e9e:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8ea2:	8d 47 11             	lea    0x11(%edi),%eax
    8ea5:	e8 fc ff ff ff       	call   8ea6 <decomplexUeDataPdu+0x3d6>
						fsm_skb_reserve(newskb,sdu_len);
    8eaa:	89 fa                	mov    %edi,%edx
					}
					else{		//7bit		//20140430
						setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,0,lcid);
						from_len=from_len+len;
						sdu_len=(m_7bit_subhead.m_f_l)&127;
						newskb=fsm_pkt_create(sdu_len+sizeof(MACtoRLC_IciMsg)+SKB_REDUN);	//20140626 //
    8eac:	89 c6                	mov    %eax,%esi
						fsm_skb_reserve(newskb,sdu_len);
    8eae:	e8 fc ff ff ff       	call   8eaf <decomplexUeDataPdu+0x3df>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
    8eb3:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8eb9:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    8ebf:	2b 45 d4             	sub    -0x2c(%ebp),%eax
    8ec2:	83 f8 06             	cmp    $0x6,%eax
    8ec5:	0f 86 de 02 00 00    	jbe    91a9 <decomplexUeDataPdu+0x6d9>
							printk("ue mac_pkthandler 1015\n");
							FOUT;
						}


						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);
    8ecb:	8b 86 a8 00 00 00    	mov    0xa8(%esi),%eax
    8ed1:	b9 07 00 00 00       	mov    $0x7,%ecx
    8ed6:	8d 55 d8             	lea    -0x28(%ebp),%edx
    8ed9:	e8 fc ff ff ff       	call   8eda <decomplexUeDataPdu+0x40a>


						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
    8ede:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    8ee4:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    8eea:	39 c7                	cmp    %eax,%edi
    8eec:	77 19                	ja     8f07 <decomplexUeDataPdu+0x437>
    8eee:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8ef4:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8efa:	29 d0                	sub    %edx,%eax
    8efc:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8eff:	39 c7                	cmp    %eax,%edi
    8f01:	0f 86 f1 fe ff ff    	jbe    8df8 <decomplexUeDataPdu+0x328>
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    8f07:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f0a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    8f11:	89 d8                	mov    %ebx,%eax
    8f13:	e8 fc ff ff ff       	call   8f14 <decomplexUeDataPdu+0x444>
							printk("ue mac_pkthandler 1026\n");
    8f18:	c7 04 24 17 07 00 00 	movl   $0x717,(%esp)
    8f1f:	e8 fc ff ff ff       	call   8f20 <decomplexUeDataPdu+0x450>
							FOUT;
    8f24:	e9 9a fc ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
    8f29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				fsm_mem_cpy(&m_padding_subhead,skb->data+from_len,len);	//m_padding_subhead
				continue_flag=m_padding_subhead.m_lcid_e_r_r>>5;
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
    8f30:	83 ff 1e             	cmp    $0x1e,%edi
    8f33:	74 09                	je     8f3e <decomplexUeDataPdu+0x46e>
    8f35:	83 ff 1f             	cmp    $0x1f,%edi
    8f38:	0f 85 ea fd ff ff    	jne    8d28 <decomplexUeDataPdu+0x258>
					case DRX_LCID:
						from_len=from_len+len;
						break;
					case PADDING_LCID:
						padding_flag=1;
						from_len=from_len+len;
    8f3e:	83 c6 01             	add    $0x1,%esi
		from_len=len;	//()
		//if(m_type==DL_PDU){	//TYPEDL_PDU, noted in 20160122
			Pdcch_c_rnti(m_phy_ici.rnti);
	   		
			fsm_printf("recieve DL_PDU data packet\n");//testing code
			while(continue_flag==1)
    8f41:	80 7d d4 01          	cmpb   $0x1,-0x2c(%ebp)
    8f45:	0f 84 7d fd ff ff    	je     8cc8 <decomplexUeDataPdu+0x1f8>
    8f4b:	e9 d8 fd ff ff       	jmp    8d28 <decomplexUeDataPdu+0x258>
				lcid=(m_padding_subhead.m_lcid_e_r_r)&31;
				numb++;
				fsm_printf("[UE MAC]lcid:%d\n",lcid);
				switch(lcid){
					case CONTENTION_RESOLUTION_LCID:	//20140428 
						if(SV(CRTimer.flag)==true){  // 	
    8f50:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f53:	80 b8 74 01 00 00 00 	cmpb   $0x0,0x174(%eax)
    8f5a:	74 e5                	je     8f41 <decomplexUeDataPdu+0x471>
							fsm_schedule_cancel(SV(CRTimer.timer_sign));  //CR  HQ 20140424
    8f5c:	8b 80 70 01 00 00    	mov    0x170(%eax),%eax
    8f62:	e8 fc ff ff ff       	call   8f63 <decomplexUeDataPdu+0x493>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
    8f67:	8b 45 b8             	mov    -0x48(%ebp),%eax
    8f6a:	c6 80 74 01 00 00 00 	movb   $0x0,0x174(%eax)
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
    8f71:	c7 80 70 01 00 00 00 	movl   $0x0,0x170(%eax)
    8f78:	00 00 00 
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
    8f7b:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8f81:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8f87:	29 d0                	sub    %edx,%eax
    8f89:	39 c6                	cmp    %eax,%esi
    8f8b:	0f 84 f0 02 00 00    	je     9281 <decomplexUeDataPdu+0x7b1>
								printk("ue mac_pkthandler 834\n");
								FOUT;
							}


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
    8f91:	01 f2                	add    %esi,%edx
    8f93:	b9 01 00 00 00       	mov    $0x1,%ecx
    8f98:	8d 45 f1             	lea    -0xf(%ebp),%eax
    8f9b:	e8 fc ff ff ff       	call   8f9c <decomplexUeDataPdu+0x4cc>
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);
    8fa0:	89 74 24 04          	mov    %esi,0x4(%esp)
    8fa4:	c7 04 24 8c 29 00 00 	movl   $0x298c,(%esp)
    8fab:	e8 fc ff ff ff       	call   8fac <decomplexUeDataPdu+0x4dc>

							from_len=from_len+len;
							len=sizeof(MAC_CE_content_resolution_identity);
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
    8fb0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8fb3:	c7 04 24 c0 29 00 00 	movl   $0x29c0,(%esp)
    8fba:	89 44 24 04          	mov    %eax,0x4(%esp)
    8fbe:	e8 fc ff ff ff       	call   8fbf <decomplexUeDataPdu+0x4ef>
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
    8fc3:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    8fc9:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    8fcf:	29 d0                	sub    %edx,%eax
    8fd1:	2b 45 d0             	sub    -0x30(%ebp),%eax
    8fd4:	83 f8 05             	cmp    $0x5,%eax
    8fd7:	0f 86 82 02 00 00    	jbe    925f <decomplexUeDataPdu+0x78f>
								fsm_pkt_destroy(skb);
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
    8fdd:	03 55 d0             	add    -0x30(%ebp),%edx
    8fe0:	b9 06 00 00 00       	mov    $0x6,%ecx
    8fe5:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    8fe8:	e8 fc ff ff ff       	call   8fe9 <decomplexUeDataPdu+0x519>
							part1=m_content_resolution.m_resolusion_identity_1;
							part2=m_content_resolution.m_resolusion_identity_2;
    8fed:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
								printk("ue mac_pkthandler 851\n");
								FOUT;
							}

							fsm_mem_cpy(&m_content_resolution,skb->data+head_len,len);	//SDU
							part1=m_content_resolution.m_resolusion_identity_1;
    8ff1:	8b 4d e6             	mov    -0x1a(%ebp),%ecx
							part2=m_content_resolution.m_resolusion_identity_2;
    8ff4:	66 89 55 c0          	mov    %dx,-0x40(%ebp)

							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);
    8ff8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    8ffb:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    9001:	0f b7 50 04          	movzwl 0x4(%eax),%edx
    9005:	89 54 24 10          	mov    %edx,0x10(%esp)
    9009:	8b 00                	mov    (%eax),%eax
    900b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    900f:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
    9012:	c7 04 24 f0 29 00 00 	movl   $0x29f0,(%esp)
    9019:	89 44 24 0c          	mov    %eax,0xc(%esp)
    901d:	0f bf 45 c0          	movswl -0x40(%ebp),%eax
    9021:	89 44 24 08          	mov    %eax,0x8(%esp)
    9025:	e8 fc ff ff ff       	call   9026 <decomplexUeDataPdu+0x556>

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
    902a:	8b 55 b8             	mov    -0x48(%ebp),%edx
    902d:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    9030:	8b 82 00 02 00 00    	mov    0x200(%edx),%eax
    9036:	85 c0                	test   %eax,%eax
    9038:	74 11                	je     904b <decomplexUeDataPdu+0x57b>
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    903a:	83 e8 01             	sub    $0x1,%eax
								part1=0;//
    903d:	31 c9                	xor    %ecx,%ecx
							fsm_printf("[MAC DECOMPLEX]PRAT1:%d,PART2:%d;ORIGINAL DATA:PART1:%d,PART2:%d\n",part1,part2,SV(m_temp_cr)->m_part_1,SV(m_temp_cr)->m_part_2);

							/**************************20150104*/
							if(SV(contention_failed_num)!=0)//
							{							
								SV(contention_failed_num)=SV(contention_failed_num)-1;
    903f:	89 82 00 02 00 00    	mov    %eax,0x200(%edx)
								part1=0;//
								part2=0;
    9045:	66 c7 45 c0 00 00    	movw   $0x0,-0x40(%ebp)
							}
							/*********************************/

							if(part1==SV(m_temp_cr)->m_part_1&&part2==SV(m_temp_cr)->m_part_2){
    904b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    904e:	8b 82 a0 01 00 00    	mov    0x1a0(%edx),%eax
    9054:	39 08                	cmp    %ecx,(%eax)
    9056:	0f 85 88 00 00 00    	jne    90e4 <decomplexUeDataPdu+0x614>
    905c:	0f bf 55 c0          	movswl -0x40(%ebp),%edx
    9060:	0f b7 40 04          	movzwl 0x4(%eax),%eax
    9064:	39 c2                	cmp    %eax,%edx
    9066:	75 7c                	jne    90e4 <decomplexUeDataPdu+0x614>
							//	SV(contention_resolution_flag)=true;	//flag
								fsm_schedule_self(0, Contention_Success);
    9068:	ba 06 00 00 00       	mov    $0x6,%edx
    906d:	31 c0                	xor    %eax,%eax
    906f:	e8 fc ff ff ff       	call   9070 <decomplexUeDataPdu+0x5a0>


							fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);	//
							fsm_printf("[HEXI]DECOMPLEX:OFFSET OF CONTENTIONRESOLUTION:%d\n",from_len);

							from_len=from_len+len;
    9074:	83 c6 01             	add    $0x1,%esi
								
								fsm_schedule_self(0, ContentionResolution_Fail);
								
								FOUT; 
							}
							head_len=head_len+len;
    9077:	83 45 d0 06          	addl   $0x6,-0x30(%ebp)
    907b:	e9 c1 fe ff ff       	jmp    8f41 <decomplexUeDataPdu+0x471>
						}
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
    9080:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9086:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    908c:	29 d0                	sub    %edx,%eax
    908e:	39 c6                	cmp    %eax,%esi
    9090:	0f 84 35 01 00 00    	je     91cb <decomplexUeDataPdu+0x6fb>
							printk("ue mac_pkthandler 896\n");
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
    9096:	01 f2                	add    %esi,%edx
    9098:	b9 01 00 00 00       	mov    $0x1,%ecx
    909d:	8d 45 f1             	lea    -0xf(%ebp),%eax
    90a0:	e8 fc ff ff ff       	call   90a1 <decomplexUeDataPdu+0x5d1>
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
    90a5:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    90ab:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    90b1:	29 d0                	sub    %edx,%eax
    90b3:	39 45 d0             	cmp    %eax,-0x30(%ebp)
    90b6:	0f 84 53 01 00 00    	je     920f <decomplexUeDataPdu+0x73f>
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    90bc:	03 55 d0             	add    -0x30(%ebp),%edx
    90bf:	b9 01 00 00 00       	mov    $0x1,%ecx
    90c4:	8d 45 f3             	lea    -0xd(%ebp),%eax
							FOUT;
						}


						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
    90c7:	83 c6 01             	add    $0x1,%esi
							fsm_pkt_destroy(skb);
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
    90ca:	e8 fc ff ff ff       	call   90cb <decomplexUeDataPdu+0x5fb>
						head_len=head_len+len;
						timing=(m_time_advance.m_r_r_command)&63;
    90cf:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							printk("ue mac_pkthandler 908\n");
							FOUT;
						}

						fsm_mem_cpy(&m_time_advance,skb->data+head_len,len);
						head_len=head_len+len;
    90d3:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
						timing=(m_time_advance.m_r_r_command)&63;

						MACCETA_handle(timing);
    90d7:	83 e0 3f             	and    $0x3f,%eax
    90da:	e8 fc ff ff ff       	call   90db <decomplexUeDataPdu+0x60b>
						break;
    90df:	e9 5d fe ff ff       	jmp    8f41 <decomplexUeDataPdu+0x471>
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    90e7:	ba 05 00 00 00       	mov    $0x5,%edx
							}
							else{
								// SV(contention_resolution_flag)=false; 
								
								
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90ec:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
				
								
								
								fsm_schedule_self(0, ContentionResolution_Fail);
    90f3:	31 c0                	xor    %eax,%eax
    90f5:	e8 fc ff ff ff       	call   90f6 <decomplexUeDataPdu+0x626>
								
								FOUT; 
    90fa:	e9 c4 fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>

						fsm_mem_cpy(newskb->head,&m_rlc_type2_icimsg,len);	//?
						//fsm_mem_cpy(newskb->data,skb->data+head_len,sdu_len);

						if(!compare(newskb->data-skb->head,sdu_len)||!compare(skb->tail-skb->data-head_len,sdu_len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    90ff:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9102:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9109:	89 d8                	mov    %ebx,%eax
    910b:	e8 fc ff ff ff       	call   910c <decomplexUeDataPdu+0x63c>
							printk("ue mac_pkthandler 987\n");
    9110:	c7 04 24 e8 06 00 00 	movl   $0x6e8,(%esp)
    9117:	e8 fc ff ff ff       	call   9118 <decomplexUeDataPdu+0x648>
							FOUT;
    911c:	e9 a2 fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
				continue_flag=1;
				while(continue_flag==1){
					len=sizeof(MAC_SDU_subhead_7bit);

					if(!compare(skb->tail-skb->data-from_len,len)){
						SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9121:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9124:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
						fsm_pkt_destroy(skb);
    912b:	89 d8                	mov    %ebx,%eax
    912d:	e8 fc ff ff ff       	call   912e <decomplexUeDataPdu+0x65e>
						printk("ue mac_pkthandler 940\n");
    9132:	c7 04 24 a3 06 00 00 	movl   $0x6a3,(%esp)
    9139:	e8 fc ff ff ff       	call   913a <decomplexUeDataPdu+0x66a>
						FOUT;
    913e:	e9 80 fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
			while(continue_flag==1)
			{
				len=sizeof(MAC_SH_padding);

				if(!compare(skb->tail-skb->data-from_len,len)){
					SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9143:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9146:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
					fsm_pkt_destroy(skb);
    914d:	89 d8                	mov    %ebx,%eax
    914f:	e8 fc ff ff ff       	call   9150 <decomplexUeDataPdu+0x680>
					printk("ue mac_pkthandler 814\n");
    9154:	c7 04 24 1f 06 00 00 	movl   $0x61f,(%esp)
    915b:	e8 fc ff ff ff       	call   915c <decomplexUeDataPdu+0x68c>
					FOUT;
    9160:	e9 5e fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(newskb->data-newskb->head,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9165:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9168:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    916f:	89 d8                	mov    %ebx,%eax
    9171:	e8 fc ff ff ff       	call   9172 <decomplexUeDataPdu+0x6a2>
							printk("ue mac_pkthandler 976\n");
    9176:	c7 04 24 d1 06 00 00 	movl   $0x6d1,(%esp)
    917d:	e8 fc ff ff ff       	call   917e <decomplexUeDataPdu+0x6ae>
							FOUT;
    9182:	e9 3c fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
					f_domain=m_7bit_subhead.m_f_l>>7;
					if(f_domain==1){	//15bit		20140430
						len=sizeof(MAC_SDU_subhead_15bit);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9187:	8b 45 b8             	mov    -0x48(%ebp),%eax
    918a:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9191:	89 d8                	mov    %ebx,%eax
    9193:	e8 fc ff ff ff       	call   9194 <decomplexUeDataPdu+0x6c4>
							printk("ue mac_pkthandler 954\n");
    9198:	c7 04 24 ba 06 00 00 	movl   $0x6ba,(%esp)
    919f:	e8 fc ff ff ff       	call   91a0 <decomplexUeDataPdu+0x6d0>
							FOUT;
    91a4:	e9 1a fa ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
						//fsm_skb_put(newskb,sdu_len+sizeof(MACtoRLC_IciMsg));

						len=sizeof(MACtoRLC_IciMsg);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    91a9:	8b 45 b8             	mov    -0x48(%ebp),%eax
    91ac:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    91b3:	89 d8                	mov    %ebx,%eax
    91b5:	e8 fc ff ff ff       	call   91b6 <decomplexUeDataPdu+0x6e6>
							printk("ue mac_pkthandler 1015\n");
    91ba:	c7 04 24 ff 06 00 00 	movl   $0x6ff,(%esp)
    91c1:	e8 fc ff ff ff       	call   91c2 <decomplexUeDataPdu+0x6f2>
							FOUT;
    91c6:	e9 f8 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
						break;
					case TIMING_ADVANCE_LCID:
						len=sizeof(MAC_SDU_subhead_last);

						if(!compare(skb->tail-skb->data-from_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    91cb:	8b 45 b8             	mov    -0x48(%ebp),%eax
    91ce:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    91d5:	89 d8                	mov    %ebx,%eax
    91d7:	e8 fc ff ff ff       	call   91d8 <decomplexUeDataPdu+0x708>
							printk("ue mac_pkthandler 896\n");
    91dc:	c7 04 24 75 06 00 00 	movl   $0x675,(%esp)
    91e3:	e8 fc ff ff ff       	call   91e4 <decomplexUeDataPdu+0x714>
							FOUT;
    91e8:	e9 d6 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>


	len=sizeof(PHYadaptertoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
		SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    91ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
    91f0:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
		fsm_pkt_destroy(skb);
    91f7:	89 d8                	mov    %ebx,%eax
    91f9:	e8 fc ff ff ff       	call   91fa <decomplexUeDataPdu+0x72a>
		printk("ue mac_pkthandler 701\n");
    91fe:	c7 04 24 56 05 00 00 	movl   $0x556,(%esp)
    9205:	e8 fc ff ff ff       	call   9206 <decomplexUeDataPdu+0x736>
		FOUT;
    920a:	e9 b4 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
						fsm_mem_cpy(&m_fixed_subhead,skb->data+from_len,len);
						from_len=from_len+len;
						len=sizeof(MAC_CE_time_advance);

						if(!compare(skb->tail-skb->data-head_len,len)){
							SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    920f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9212:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
							fsm_pkt_destroy(skb);
    9219:	89 d8                	mov    %ebx,%eax
    921b:	e8 fc ff ff ff       	call   921c <decomplexUeDataPdu+0x74c>
							printk("ue mac_pkthandler 908\n");
    9220:	c7 04 24 8c 06 00 00 	movl   $0x68c,(%esp)
    9227:	e8 fc ff ff ff       	call   9228 <decomplexUeDataPdu+0x758>
							FOUT;
    922c:	e9 92 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
			
			/*
			 * for test
			 */
			 else{
			 	SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;
    9231:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9234:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			 	
			 	fsm_pkt_destroy(skb);
    923b:	89 d8                	mov    %ebx,%eax
    923d:	e8 fc ff ff ff       	call   923e <decomplexUeDataPdu+0x76e>
			 	printk("ue mac_pkthandler 1052\n");
    9242:	c7 04 24 2f 07 00 00 	movl   $0x72f,(%esp)
    9249:	e8 fc ff ff ff       	call   924a <decomplexUeDataPdu+0x77a>
   				fsm_printf("decomplex function done\n");//testing code
    924e:	c7 04 24 47 07 00 00 	movl   $0x747,(%esp)
    9255:	e8 fc ff ff ff       	call   9256 <decomplexUeDataPdu+0x786>
				FOUT;
    925a:	e9 64 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
							
							fsm_printf("[HEXI]LENGTH OF HEAD IN DECOMPLEX DL_PDU:%d\n",head_len);
							
							
							if(!compare(skb->tail-skb->data-head_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    925f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9262:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    9269:	89 d8                	mov    %ebx,%eax
    926b:	e8 fc ff ff ff       	call   926c <decomplexUeDataPdu+0x79c>
								printk("ue mac_pkthandler 851\n");
    9270:	c7 04 24 5e 06 00 00 	movl   $0x65e,(%esp)
    9277:	e8 fc ff ff ff       	call   9278 <decomplexUeDataPdu+0x7a8>
								FOUT;
    927c:	e9 42 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
							SV(CRTimer.flag)=false;				//20140626 warning!!!!!
							SV(CRTimer.timer_sign)=NULL;		//20140626//timer_sign
							len=sizeof(MAC_SDU_subhead_last);

							if(!compare(skb->tail-skb->data-from_len,len)){
								SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    9281:	8b 45 b8             	mov    -0x48(%ebp),%eax
    9284:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
								fsm_pkt_destroy(skb);
    928b:	89 d8                	mov    %ebx,%eax
    928d:	e8 fc ff ff ff       	call   928e <decomplexUeDataPdu+0x7be>
								printk("ue mac_pkthandler 834\n");
    9292:	c7 04 24 47 06 00 00 	movl   $0x647,(%esp)
    9299:	e8 fc ff ff ff       	call   929a <decomplexUeDataPdu+0x7ca>
								FOUT;
    929e:	e9 20 f9 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
		fsm_printf("recieve PCCH data packet\n");//testing code
		setMACtoRLC_IciMsg(&m_rlc_type2_icimsg,PCCH,0);
		len=sizeof(MACtoRLC_IciMsg);

		if(!compare(skb->data-skb->head,len)){
			SV(lost_pkt_num_downlink)=SV(lost_pkt_num_downlink)+1;	//for test
    92a3:	8b 45 b8             	mov    -0x48(%ebp),%eax
    92a6:	83 80 0c 02 00 00 01 	addl   $0x1,0x20c(%eax)
			fsm_pkt_destroy(skb);
    92ad:	89 d8                	mov    %ebx,%eax
    92af:	e8 fc ff ff ff       	call   92b0 <decomplexUeDataPdu+0x7e0>
			printk("ue mac_pkthandler 740\n");
    92b4:	c7 04 24 b8 05 00 00 	movl   $0x5b8,(%esp)
    92bb:	e8 fc ff ff ff       	call   92bc <decomplexUeDataPdu+0x7ec>
			FOUT;
    92c0:	e9 fe f8 ff ff       	jmp    8bc3 <decomplexUeDataPdu+0xf3>
    92c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    92c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000092d0 <clean_CE_tags>:
}	//ICI()
	
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
    92d0:	55                   	push   %ebp
    92d1:	89 e5                	mov    %esp,%ebp
    92d3:	56                   	push   %esi
    92d4:	53                   	push   %ebx
    92d5:	e8 fc ff ff ff       	call   92d6 <clean_CE_tags+0x6>
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    92da:	31 db                	xor    %ebx,%ebx
/**
 * @function: reset the MAC control element tags
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
    92dc:	e8 fc ff ff ff       	call   92dd <clean_CE_tags+0xd>
    92e1:	89 c6                	mov    %eax,%esi
    92e3:	90                   	nop
    92e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    92e8:	8d 84 de a4 01 00 00 	lea    0x1a4(%esi,%ebx,8),%eax
    92ef:	31 d2                	xor    %edx,%edx
    92f1:	b9 08 00 00 00       	mov    $0x8,%ecx
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    92f6:	83 c3 01             	add    $0x1,%ebx
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
    92f9:	e8 fc ff ff ff       	call   92fa <clean_CE_tags+0x2a>
 */
void clean_CE_tags(){	//
	u32 tag_pos=0;
	SV_PTR_GET(rlc_mac_sv);
	FIN(clean_CE_tags());
	for(tag_pos=0;tag_pos<MACCE_ARRAY_size;tag_pos++)
    92fe:	83 fb 08             	cmp    $0x8,%ebx
    9301:	75 e5                	jne    92e8 <clean_CE_tags+0x18>
		fsm_mem_set(&SV(MAC_CE_Tags[tag_pos]),0, sizeof(MAC_controlelement_tag));
	FOUT;
}
    9303:	5b                   	pop    %ebx
    9304:	5e                   	pop    %esi
    9305:	5d                   	pop    %ebp
    9306:	c3                   	ret    
    9307:	89 f6                	mov    %esi,%esi
    9309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009310 <complexUeMacPdu>:

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9310:	55                   	push   %ebp
    9311:	89 e5                	mov    %esp,%ebp
    9313:	57                   	push   %edi
    9314:	56                   	push   %esi
    9315:	53                   	push   %ebx
    9316:	83 ec 70             	sub    $0x70,%esp
    9319:	e8 fc ff ff ff       	call   931a <complexUeMacPdu+0xa>
    931e:	89 c3                	mov    %eax,%ebx
	u32 bsr_flag;	//bsr
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
    9320:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    9327:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    932e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    9335:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    933c:	e8 fc ff ff ff       	call   933d <complexUeMacPdu+0x2d>

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    9341:	31 d2                	xor    %edx,%edx
    9343:	b9 01 00 00 00       	mov    $0x1,%ecx
	MAC_CE_longBSR m_long_bsr;	//20140430
	RLCtoMAC_IciMsg m_rlc_type1_ici;	//20140430	//20140430
	MACtoPHYadapter_IciMsg m_phy_ici;//20140506 HQ
	MacCeListElement_s m_bsr_infor;	//20140430
	void *head_backup;
	SV_PTR_GET(rlc_mac_sv);
    9348:	89 c6                	mov    %eax,%esi

	//lcg_id=(u32*)fsm_mem_alloc(sizeof(u32));
	//shortbsr_buf_size=(u32*)fsm_mem_alloc(sizeof(u32));
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    934a:	8d 45 f1             	lea    -0xf(%ebp),%eax
    934d:	e8 fc ff ff ff       	call   934e <complexUeMacPdu+0x3e>
	fsm_mem_set(&m_7bit_subhead,0,sizeof(MAC_SDU_subhead_7bit));		//20140430
    9352:	31 d2                	xor    %edx,%edx
    9354:	b9 02 00 00 00       	mov    $0x2,%ecx
    9359:	8d 45 ed             	lea    -0x13(%ebp),%eax
    935c:	e8 fc ff ff ff       	call   935d <complexUeMacPdu+0x4d>
	fsm_mem_set(&m_15bit_subhead,0,sizeof(MAC_SDU_subhead_15bit));		//20140430
    9361:	31 d2                	xor    %edx,%edx
    9363:	b9 03 00 00 00       	mov    $0x3,%ecx
    9368:	8d 45 e7             	lea    -0x19(%ebp),%eax
    936b:	e8 fc ff ff ff       	call   936c <complexUeMacPdu+0x5c>
	fsm_mem_set(&m_crnti,0,sizeof(MAC_CE_Crnti));		//20140430
    9370:	31 d2                	xor    %edx,%edx
    9372:	b9 02 00 00 00       	mov    $0x2,%ecx
    9377:	8d 45 ef             	lea    -0x11(%ebp),%eax
    937a:	e8 fc ff ff ff       	call   937b <complexUeMacPdu+0x6b>
	fsm_mem_set(&m_power_headroom,0,sizeof(MAC_CE_power_headroom));//20140430
    937f:	31 d2                	xor    %edx,%edx
    9381:	b9 01 00 00 00       	mov    $0x1,%ecx
    9386:	8d 45 f2             	lea    -0xe(%ebp),%eax
    9389:	e8 fc ff ff ff       	call   938a <complexUeMacPdu+0x7a>
	fsm_mem_set(&m_short_bsr,0,sizeof(MAC_CE_shortBSR));		//20140430
    938e:	31 d2                	xor    %edx,%edx
    9390:	b9 01 00 00 00       	mov    $0x1,%ecx
    9395:	8d 45 f3             	lea    -0xd(%ebp),%eax
    9398:	e8 fc ff ff ff       	call   9399 <complexUeMacPdu+0x89>
	fsm_mem_set(&m_long_bsr,0,sizeof(MAC_CE_longBSR));		//20140430
    939d:	31 d2                	xor    %edx,%edx
    939f:	b9 03 00 00 00       	mov    $0x3,%ecx
    93a4:	8d 45 ea             	lea    -0x16(%ebp),%eax
    93a7:	e8 fc ff ff ff       	call   93a8 <complexUeMacPdu+0x98>
	//fsm_mem_set(m_rlc_type2_ici,0,sizeof(RLC_MAC_IciMsgPB));		//20140430
	fsm_mem_set(&m_rlc_type1_ici,0,sizeof(RLCtoMAC_IciMsg));		//20140430
    93ac:	31 d2                	xor    %edx,%edx
    93ae:	b9 04 00 00 00       	mov    $0x4,%ecx
    93b3:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    93b6:	e8 fc ff ff ff       	call   93b7 <complexUeMacPdu+0xa7>
	fsm_mem_set(&m_bsr_infor,0,sizeof(MacCeListElement_s));	//20140430
    93bb:	31 d2                	xor    %edx,%edx
    93bd:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    93c2:	8d 45 a6             	lea    -0x5a(%ebp),%eax
    93c5:	e8 fc ff ff ff       	call   93c6 <complexUeMacPdu+0xb6>
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506
    93ca:	31 d2                	xor    %edx,%edx
    93cc:	b9 07 00 00 00       	mov    $0x7,%ecx
    93d1:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    93d4:	e8 fc ff ff ff       	call   93d5 <complexUeMacPdu+0xc5>
 *
 *	Return the number of bytes of free space at the head of an &sk_buff.
 */
static inline unsigned int skb_headroom(const struct sk_buff *skb)
{
	return skb->data - skb->head;
    93d9:	8b bb ac 00 00 00    	mov    0xac(%ebx),%edi
    93df:	2b bb a8 00 00 00    	sub    0xa8(%ebx),%edi



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    93e5:	8d 47 0a             	lea    0xa(%edi),%eax
    93e8:	e8 fc ff ff ff       	call   93e9 <complexUeMacPdu+0xd9>

	if(!compare(skb->data-skb->head,re_len)){
    93ed:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
	fsm_mem_set(&m_phy_ici,0,sizeof(MACtoPHYadapter_IciMsg)); //20140506



	re_len=skb_headroom(skb);
	head_backup=fsm_mem_alloc(SKB_REDUN+re_len);
    93f3:	89 45 a0             	mov    %eax,-0x60(%ebp)

	if(!compare(skb->data-skb->head,re_len)){
    93f6:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    93fc:	29 d0                	sub    %edx,%eax
    93fe:	39 f8                	cmp    %edi,%eax
    9400:	0f 82 ca 03 00 00    	jb     97d0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(head_backup,skb->head,re_len);
    9406:	8b 45 a0             	mov    -0x60(%ebp),%eax
    9409:	89 f9                	mov    %edi,%ecx
    940b:	e8 fc ff ff ff       	call   940c <complexUeMacPdu+0xfc>
	
	
	/*
	 * for test
	 */
	SV(pkt_num_uplink)=SV(pkt_num_uplink)+1;
    9410:	83 86 08 02 00 00 01 	addl   $0x1,0x208(%esi)

	len=sizeof(RLCtoMAC_IciMsg);

	if(!compare(skb->data-skb->head,len)){
    9417:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    941d:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9423:	29 d0                	sub    %edx,%eax
    9425:	83 f8 03             	cmp    $0x3,%eax
    9428:	0f 86 a2 03 00 00    	jbe    97d0 <complexUeMacPdu+0x4c0>
		fsm_pkt_destroy(skb);
		FOUT;
	}


	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
    942e:	b9 04 00 00 00       	mov    $0x4,%ecx
    9433:	8d 45 e3             	lea    -0x1d(%ebp),%eax
    9436:	e8 fc ff ff ff       	call   9437 <complexUeMacPdu+0x127>
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
    943b:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    943f:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
    9443:	0f b7 c0             	movzwl %ax,%eax
    9446:	89 44 24 04          	mov    %eax,0x4(%esp)
    944a:	c7 04 24 34 2a 00 00 	movl   $0x2a34,(%esp)
    9451:	e8 fc ff ff ff       	call   9452 <complexUeMacPdu+0x142>
	if(skb->data==skb->tail){	//SDU,
    9456:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    945c:	89 45 98             	mov    %eax,-0x68(%ebp)
    945f:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9465:	89 45 94             	mov    %eax,-0x6c(%ebp)
	}
	else
		e=1;	//20131110modified

	total_len=SV(Tbsize_Complex);
	fsm_printf("[COMPLEX]TBSIZE:%d\n",SV(Tbsize_Complex));	
    9468:	8b 86 f4 01 00 00    	mov    0x1f4(%esi),%eax
    946e:	c7 04 24 60 07 00 00 	movl   $0x760,(%esp)
    9475:	89 44 24 04          	mov    %eax,0x4(%esp)
    9479:	e8 fc ff ff ff       	call   947a <complexUeMacPdu+0x16a>
		len=sizeof(RLCtoMAC_IciMsg);
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
    947e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
    9484:	0f b7 55 e5          	movzwl -0x1b(%ebp),%edx
    9488:	2b 83 ac 00 00 00    	sub    0xac(%ebx),%eax
    948e:	01 d0                	add    %edx,%eax
    9490:	3d fa 05 00 00       	cmp    $0x5fa,%eax
    9495:	0f 87 5d 03 00 00    	ja     97f8 <complexUeMacPdu+0x4e8>
		fsm_pkt_destroy(skb);
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
    949b:	8d 45 ef             	lea    -0x11(%ebp),%eax
    949e:	e8 fc ff ff ff       	call   949f <complexUeMacPdu+0x18f>
    94a3:	88 45 9c             	mov    %al,-0x64(%ebp)
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    94a6:	8d 45 f2             	lea    -0xe(%ebp),%eax
    94a9:	e8 fc ff ff ff       	call   94aa <complexUeMacPdu+0x19a>
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    94ae:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    94b1:	8d 55 dc             	lea    -0x24(%ebp),%edx
		FOUT;
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
    94b4:	88 45 9d             	mov    %al,-0x63(%ebp)
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    94b7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    94ba:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    94c1:	e8 fc ff ff ff       	call   94c2 <complexUeMacPdu+0x1b2>
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    94c6:	83 f8 01             	cmp    $0x1,%eax
	}
	

	crnti_flag=lteMacCEC_rntiSend(&m_crnti); 	//for test
	ph_flag=lteMacCEPhSend(&m_power_headroom);
	bsr_flag=lteMacCEBSRSend(&lcg_id,&shortbsr_buf_size,longbsr_buf_sizes,LONG_BSR_SIZE);//bsr_flag bsr bsr
    94c9:	89 c7                	mov    %eax,%edi
		//re_len=re_len+sizeof(MAC_CE_shortBSR)+sizeof(MAC_SDU_subhead_last);
	}

	//fsm_printf("[COMPLEX]LEFT LENGTH BEFORE LONG BSR:%d\n",left_len);

	if(bsr_flag>1){
    94cb:	76 0c                	jbe    94d9 <complexUeMacPdu+0x1c9>
	
		test_len++;
	
		if(con_flag)
			fsm_printf("[COMPLEX]LONG BSR CONTROL ELEMENT FOUND!\n");
    94cd:	c7 04 24 7c 2a 00 00 	movl   $0x2a7c,(%esp)
    94d4:	e8 fc ff ff ff       	call   94d5 <complexUeMacPdu+0x1c5>
	test_rnti=test_ici.rnti;
	fsm_printf("[HEXI]LCID AND RNTI OF CCCH AFTER REALLOC:%d %d\n",test_lcid,test_rnti);*/

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
    94d9:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    94dd:	74 2f                	je     950e <complexUeMacPdu+0x1fe>
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST

		if(!compare(skb->data-skb->head,len)){
    94df:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    94e5:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)

	//fsm_printf("[COMPLEX]THE LENGTH SHOULD BE RESERVED:%d,HEADROOM OF SK_BUFF:%d,DATAROOM OF SK_BUFF:%d\n",re_len,skb->data-skb->head,skb->tail-skb->data);
     // HQ 20140502		
	if(ph_flag){	//
		len=sizeof(MAC_CE_power_headroom);
		m_power_headroom.m_r_r_ph=1;	//FOR TEST
    94eb:	c6 45 f2 01          	movb   $0x1,-0xe(%ebp)

		if(!compare(skb->data-skb->head,len)){
    94ef:	0f 84 db 02 00 00    	je     97d0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_power_headroom,len);	//NEWSDU
    94f5:	ba 01 00 00 00       	mov    $0x1,%edx
    94fa:	89 d8                	mov    %ebx,%eax
    94fc:	e8 fc ff ff ff       	call   94fd <complexUeMacPdu+0x1ed>
    9501:	b9 01 00 00 00       	mov    $0x1,%ecx
    9506:	8d 55 f2             	lea    -0xe(%ebp),%edx
    9509:	e8 fc ff ff ff       	call   950a <complexUeMacPdu+0x1fa>
		
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti->m_crnti);
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR
    950e:	85 ff                	test   %edi,%edi
    9510:	0f 85 6a 02 00 00    	jne    9780 <complexUeMacPdu+0x470>
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL SUBHEAD:%d\n",(skb->tail-skb->data));
	
	if(crnti_flag){
    9516:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    951a:	74 4a                	je     9566 <complexUeMacPdu+0x256>
		len=sizeof(MAC_CE_Crnti);

		if(!compare(skb->data-skb->head,len)){
    951c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    9522:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    9528:	83 f8 01             	cmp    $0x1,%eax
    952b:	0f 86 9f 02 00 00    	jbe    97d0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_crnti,len);	//NEWSDU
    9531:	ba 02 00 00 00       	mov    $0x2,%edx
    9536:	89 d8                	mov    %ebx,%eax
    9538:	e8 fc ff ff ff       	call   9539 <complexUeMacPdu+0x229>
    953d:	b9 02 00 00 00       	mov    $0x2,%ecx
    9542:	8d 55 ef             	lea    -0x11(%ebp),%edx
    9545:	e8 fc ff ff ff       	call   9546 <complexUeMacPdu+0x236>
		rnti_to_ici=SV(T_C_RNTI);
    954a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
    954e:	66 89 45 9e          	mov    %ax,-0x62(%ebp)
		fsm_printf("[MAC COMPLEX]CRNTI IN COMPLEX:%d\n",m_crnti.m_crnti);
    9552:	0f b7 45 ef          	movzwl -0x11(%ebp),%eax
    9556:	c7 04 24 a8 2a 00 00 	movl   $0x2aa8,(%esp)
    955d:	89 44 24 04          	mov    %eax,0x4(%esp)
    9561:	e8 fc ff ff ff       	call   9562 <complexUeMacPdu+0x252>
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9566:	8b 93 a8 00 00 00    	mov    0xa8(%ebx),%edx
    956c:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9572:	0f b7 4d e5          	movzwl -0x1b(%ebp),%ecx
	
	if(!compare(skb->data-skb->head-len,sizeof(MAC_SDU_subhead_7bit))){
    9576:	29 d0                	sub    %edx,%eax
    9578:	83 e8 04             	sub    $0x4,%eax
    957b:	83 f8 01             	cmp    $0x1,%eax
    957e:	0f 86 4c 02 00 00    	jbe    97d0 <complexUeMacPdu+0x4c0>
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    9584:	0f b7 c9             	movzwl %cx,%ecx
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    9587:	83 c2 04             	add    $0x4,%edx
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}

	len=sizeof(RLCtoMAC_IciMsg);
	head_len=m_rlc_type1_ici.len;
    958a:	89 4d 90             	mov    %ecx,-0x70(%ebp)
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_mem_cpy(&m_7bit_subhead,skb->head+len,sizeof(MAC_SDU_subhead_7bit));
    958d:	8d 45 ed             	lea    -0x13(%ebp),%eax
    9590:	b9 02 00 00 00       	mov    $0x2,%ecx
    9595:	e8 fc ff ff ff       	call   9596 <complexUeMacPdu+0x286>
	m_7bit_subhead.m_f_l=m_7bit_subhead.m_f_l>>7;
    959a:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    959e:	c0 e8 07             	shr    $0x7,%al
    95a1:	88 45 ee             	mov    %al,-0x12(%ebp)
	fsm_printf("THE TYPE OF SDU:%d\n",m_7bit_subhead.m_f_l);
    95a4:	0f b6 c0             	movzbl %al,%eax
    95a7:	89 44 24 04          	mov    %eax,0x4(%esp)
    95ab:	c7 04 24 74 07 00 00 	movl   $0x774,(%esp)
    95b2:	e8 fc ff ff ff       	call   95b3 <complexUeMacPdu+0x2a3>
	
	
	test_len+=head_len;
	//fsm_printf("[COMPLEX]THE ORIGINAL LENGTH AND LENGTH OF THE HEADS:%d,%d\n",m_rlc_type1_ici->len,head_len);
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING SDU SUBHEAD:%d\n",(skb->tail-skb->data));
	if(!compare(skb->data-skb->head-len,head_len)){
    95b7:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    95bd:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    95c3:	83 e8 04             	sub    $0x4,%eax
    95c6:	39 45 90             	cmp    %eax,-0x70(%ebp)
    95c9:	0f 87 01 02 00 00    	ja     97d0 <complexUeMacPdu+0x4c0>
		clean_CE_tags();
		fsm_pkt_destroy(skb);
		FOUT;
	}

	fsm_skb_push(skb,head_len);		
    95cf:	8b 55 90             	mov    -0x70(%ebp),%edx
    95d2:	89 d8                	mov    %ebx,%eax
    95d4:	e8 fc ff ff ff       	call   95d5 <complexUeMacPdu+0x2c5>
	fsm_mem_cpy(skb->data,(u8*)head_backup+len,head_len);	//SDUdata 	//for test
    95d9:	8b 55 a0             	mov    -0x60(%ebp),%edx
    95dc:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    95e2:	8b 4d 90             	mov    -0x70(%ebp),%ecx
    95e5:	83 c2 04             	add    $0x4,%edx
    95e8:	e8 fc ff ff ff       	call   95e9 <complexUeMacPdu+0x2d9>

	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
    95ed:	85 ff                	test   %edi,%edi
    95ef:	0f 84 bb 02 00 00    	je     98b0 <complexUeMacPdu+0x5a0>

	fsm_mem_cpy(&m_rlc_type1_ici,skb->head,len);
	rnti_to_ici=m_rlc_type1_ici.rnti;	//20150120 hexi
	fsm_printf("[RLC_MAC]m_rlc_type1_ici.rnti: %d\n", rnti_to_ici);
	if(skb->data==skb->tail){	//SDU,
		e=0;
    95f5:	8b 45 94             	mov    -0x6c(%ebp),%eax
    95f8:	39 45 98             	cmp    %eax,-0x68(%ebp)
    95fb:	0f 95 c0             	setne  %al
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
    95fe:	c1 e0 05             	shl    $0x5,%eax
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
    9601:	83 ff 01             	cmp    $0x1,%edi
    9604:	0f 84 46 02 00 00    	je     9850 <complexUeMacPdu+0x540>
			//fsm_printf("PUT IN THE LONG BSR HEAD!\n");


			lcid=LONG_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    960a:	83 c0 1e             	add    $0x1e,%eax
    960d:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9610:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9616:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    961c:	0f 84 ae 01 00 00    	je     97d0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9622:	ba 01 00 00 00       	mov    $0x1,%edx
    9627:	89 d8                	mov    %ebx,%eax
    9629:	e8 fc ff ff ff       	call   962a <complexUeMacPdu+0x31a>
    962e:	b9 01 00 00 00       	mov    $0x1,%ecx
	/*fsm_mem_cpy(m_fixed_subhead,skb->data,sizeof(MAC_SDU_subhead_last));
	test_lcid=m_fixed_subhead->m_lcid_e_r_r&31;
	fsm_printf("[HEXI]LCID OF CCCH:%d\n",test_lcid);*/
	
	if(bsr_flag!=0){
		first_flag=false;	//
    9633:	31 ff                	xor    %edi,%edi
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9635:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9638:	e8 fc ff ff ff       	call   9639 <complexUeMacPdu+0x329>
			head_len=head_len+len;
		}
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    963d:	31 d2                	xor    %edx,%edx
    963f:	b9 01 00 00 00       	mov    $0x1,%ecx
    9644:	8d 45 f1             	lea    -0xf(%ebp),%eax
    9647:	e8 fc ff ff ff       	call   9648 <complexUeMacPdu+0x338>
	if(crnti_flag){
    964c:	80 7d 9c 00          	cmpb   $0x0,-0x64(%ebp)
    9650:	74 39                	je     968b <complexUeMacPdu+0x37b>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    9652:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=e<<5;
    9655:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9658:	8d 47 1b             	lea    0x1b(%edi),%eax
    965b:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    965e:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9664:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    966a:	0f 84 60 01 00 00    	je     97d0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    9670:	ba 01 00 00 00       	mov    $0x1,%edx
    9675:	89 d8                	mov    %ebx,%eax
    9677:	e8 fc ff ff ff       	call   9678 <complexUeMacPdu+0x368>
    967c:	b9 01 00 00 00       	mov    $0x1,%ecx
    9681:	31 ff                	xor    %edi,%edi
    9683:	8d 55 f1             	lea    -0xf(%ebp),%edx
    9686:	e8 fc ff ff ff       	call   9687 <complexUeMacPdu+0x377>
		head_len=head_len+len;
	}
	fsm_mem_set(&m_fixed_subhead,0,sizeof(MAC_SDU_subhead_last));	//20140430
    968b:	31 d2                	xor    %edx,%edx
    968d:	b9 01 00 00 00       	mov    $0x1,%ecx
    9692:	8d 45 f1             	lea    -0xf(%ebp),%eax
    9695:	e8 fc ff ff ff       	call   9696 <complexUeMacPdu+0x386>
	if(ph_flag){
    969a:	80 7d 9d 00          	cmpb   $0x0,-0x63(%ebp)
    969e:	74 37                	je     96d7 <complexUeMacPdu+0x3c7>

/**
 * @functoin: complex MAC PDU into MAC SDU and MAC control elements, and deal with them
 * @param skb: the sk_buff contains MAC PDU from SRIO layer
 */
void complexUeMacPdu(FSM_PKT *skb){  //
    96a0:	83 f7 01             	xor    $0x1,%edi
		}
		else{
			e=0;
			first_flag=false;
		}
		m_fixed_subhead.m_lcid_e_r_r=(e<<5);
    96a3:	c1 e7 05             	shl    $0x5,%edi
		m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    96a6:	8d 47 1a             	lea    0x1a(%edi),%eax
    96a9:	88 45 f1             	mov    %al,-0xf(%ebp)
		len=sizeof(MAC_SDU_subhead_last);

		if(!compare(skb->data-skb->head,len)){
    96ac:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    96b2:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    96b8:	0f 84 12 01 00 00    	je     97d0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

		fsm_mem_cpy(fsm_skb_push(skb,len),&m_fixed_subhead,len);		//
    96be:	ba 01 00 00 00       	mov    $0x1,%edx
    96c3:	89 d8                	mov    %ebx,%eax
    96c5:	e8 fc ff ff ff       	call   96c6 <complexUeMacPdu+0x3b6>
    96ca:	b9 01 00 00 00       	mov    $0x1,%ecx
    96cf:	8d 55 f1             	lea    -0xf(%ebp),%edx
    96d2:	e8 fc ff ff ff       	call   96d3 <complexUeMacPdu+0x3c3>
		
		//fsm_printf("[COMPLEX]PH SUBHED:%c\n",m_fixed_subhead->m_lcid_e_r_r+10);
	}
	//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING CONTROL ELEMENTS:%d\n",(skb->tail-skb->data));
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    96d7:	0f b7 4d 9e          	movzwl -0x62(%ebp),%ecx
    96db:	ba 02 00 00 00       	mov    $0x2,%edx
    96e0:	8d 45 d1             	lea    -0x2f(%ebp),%eax
    96e3:	e8 fc ff ff ff       	call   96e4 <complexUeMacPdu+0x3d4>
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 
    96e8:	0f b7 45 e3          	movzwl -0x1d(%ebp),%eax
    96ec:	89 44 24 08          	mov    %eax,0x8(%esp)
    96f0:	0f b7 45 d5          	movzwl -0x2b(%ebp),%eax
    96f4:	c7 04 24 cc 2a 00 00 	movl   $0x2acc,(%esp)
    96fb:	89 44 24 04          	mov    %eax,0x4(%esp)
    96ff:	e8 fc ff ff ff       	call   9700 <complexUeMacPdu+0x3f0>

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
    9704:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    970a:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    9710:	29 c2                	sub    %eax,%edx
    9712:	83 fa 06             	cmp    $0x6,%edx
    9715:	0f 86 b5 00 00 00    	jbe    97d0 <complexUeMacPdu+0x4c0>
			clean_CE_tags();
			fsm_pkt_destroy(skb);
			FOUT;
		}

    	fsm_mem_cpy(skb->head,&m_phy_ici,sizeof(MACtoPHYadapter_IciMsg));//ICIsk_buf//20140506 HQ
    971b:	b9 07 00 00 00       	mov    $0x7,%ecx
    9720:	8d 55 d1             	lea    -0x2f(%ebp),%edx
    9723:	e8 fc ff ff ff       	call   9724 <complexUeMacPdu+0x414>
    		fsm_printf("%c ",*(skb->data+i)+65);
    	}*/
    	
    	//fsm_octets_print(skb->data,7);
    	
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
    9728:	ba 03 00 00 00       	mov    $0x3,%edx
    972d:	89 d8                	mov    %ebx,%eax
    972f:	e8 fc ff ff ff       	call   9730 <complexUeMacPdu+0x420>
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
    9734:	8b 43 50             	mov    0x50(%ebx),%eax
    9737:	c7 04 24 f8 2a 00 00 	movl   $0x2af8,(%esp)
    973e:	89 44 24 04          	mov    %eax,0x4(%esp)
    9742:	e8 fc ff ff ff       	call   9743 <complexUeMacPdu+0x433>
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping
    9747:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    974d:	ba 50 00 00 00       	mov    $0x50,%edx
    9752:	e8 fc ff ff ff       	call   9753 <complexUeMacPdu+0x443>
	SV(Tbsize_Complex)=0;

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9757:	8b 45 a0             	mov    -0x60(%ebp),%eax
	fsm_pkt_send(skb,STRM_TO_SRIO);		//20140428 
	fsm_printf("[HEXI] packet sent to srio:len:%d\n",skb->len);
	//fsm_octets_print(skb->data, skb->len);
	fsm_octets_print(skb->data, 80);	//for test datagram-dropping

	SV(Tbsize_Complex)=0;
    975a:	c7 86 f4 01 00 00 00 	movl   $0x0,0x1f4(%esi)
    9761:	00 00 00 

	//fsm_mem_free(lcg_id);
	//fsm_mem_free(shortbsr_buf_size);
	
	fsm_mem_free(head_backup);
    9764:	e8 fc ff ff ff       	call   9765 <complexUeMacPdu+0x455>
	clean_CE_tags();// modified by HQ 20140512 
    9769:	e8 fc ff ff ff       	call   976a <complexUeMacPdu+0x45a>
	fsm_printf("complex function done\n");//testing code 
    976e:	c7 04 24 88 07 00 00 	movl   $0x788,(%esp)
    9775:	e8 fc ff ff ff       	call   9776 <complexUeMacPdu+0x466>
	fsm_printf("%c,\n",*(skb->data+from_len));
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
    977a:	eb 6f                	jmp    97eb <complexUeMacPdu+0x4db>
    977c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
    9780:	83 ff 01             	cmp    $0x1,%edi
    9783:	0f 84 e7 00 00 00    	je     9870 <complexUeMacPdu+0x560>

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    9789:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		else{
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
    978c:	8b 45 c0             	mov    -0x40(%ebp),%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    978f:	89 ca                	mov    %ecx,%edx
			//20140626

			//fsm_printf("PUT IN THE LONG BSR CE!\n");

			m_long_bsr.m_buffersize1=longbsr_buf_sizes[0];
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1<<2;
    9791:	c1 e0 02             	shl    $0x2,%eax
			m_long_bsr.m_buffersize1=m_long_bsr.m_buffersize1+(longbsr_buf_sizes[1]&48)>>4;	//buffersize255
    9794:	83 e2 30             	and    $0x30,%edx
    9797:	0f b6 c0             	movzbl %al,%eax
    979a:	01 d0                	add    %edx,%eax
    979c:	c1 e8 04             	shr    $0x4,%eax
    979f:	88 45 ea             	mov    %al,-0x16(%ebp)
			m_long_bsr.m_buffersize2=(longbsr_buf_sizes[1]&15);
    97a2:	89 c8                	mov    %ecx,%eax
    97a4:	83 e0 0f             	and    $0xf,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    97a7:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[2];
    97aa:	66 03 45 c8          	add    -0x38(%ebp),%ax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2<<6;
    97ae:	c1 e0 06             	shl    $0x6,%eax
			m_long_bsr.m_buffersize2=m_long_bsr.m_buffersize2+longbsr_buf_sizes[3];
    97b1:	66 03 45 cc          	add    -0x34(%ebp),%ax
    97b5:	66 89 45 eb          	mov    %ax,-0x15(%ebp)
			//
			//fsm_printf("[COMPLEX]BSR VALUE:%c,%d\n",m_long_bsr->m_buffersize1+65,m_long_bsr->m_buffersize2);

			len=sizeof(MAC_CE_longBSR);

			if(!compare(skb->data-skb->head,len)){
    97b9:	8b 83 ac 00 00 00    	mov    0xac(%ebx),%eax
    97bf:	2b 83 a8 00 00 00    	sub    0xa8(%ebx),%eax
    97c5:	83 f8 02             	cmp    $0x2,%eax
    97c8:	77 5e                	ja     9828 <complexUeMacPdu+0x518>
    97ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
			fsm_mem_free(head_backup);
    97d0:	8b 45 a0             	mov    -0x60(%ebp),%eax
	
    	setMACtoPHY_IciMsg(&m_phy_ici, DLSCH, rnti_to_ici);//MACtoPHYICI //20140506 HQ
    	fsm_printf("\n[COMPLEX]RNTI TO PHY:%d;RNTI IN RLC:%d\n",m_phy_ici.rnti,m_rlc_type1_ici.rnti);//testing code 

		if(!compare(skb->data-skb->head,sizeof(MACtoPHYadapter_IciMsg))){
			SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    97d3:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
			fsm_mem_free(head_backup);
    97da:	e8 fc ff ff ff       	call   97db <complexUeMacPdu+0x4cb>
			clean_CE_tags();
    97df:	e8 fc ff ff ff       	call   97e0 <complexUeMacPdu+0x4d0>
			fsm_pkt_destroy(skb);
    97e4:	89 d8                	mov    %ebx,%eax
    97e6:	e8 fc ff ff ff       	call   97e7 <complexUeMacPdu+0x4d7>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    97eb:	83 c4 70             	add    $0x70,%esp
    97ee:	5b                   	pop    %ebx
    97ef:	5e                   	pop    %esi
    97f0:	5f                   	pop    %edi
    97f1:	5d                   	pop    %ebp
    97f2:	c3                   	ret    
    97f3:	90                   	nop
    97f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    97f8:	8b 45 a0             	mov    -0x60(%ebp),%eax
		lteMacCcchSend(skb,len);//ccch	20140430
	}
*/       
	
	if((skb->tail-skb->data)+m_rlc_type1_ici.len>left_len){
		SV(lost_pkt_num_uplink)=SV(lost_pkt_num_uplink)+1;
    97fb:	83 86 04 02 00 00 01 	addl   $0x1,0x204(%esi)
		//fsm_mem_free(lcg_id);
		//fsm_mem_free(shortbsr_buf_size);
		fsm_mem_free(head_backup);
    9802:	e8 fc ff ff ff       	call   9803 <complexUeMacPdu+0x4f3>
		clean_CE_tags();// modified by HQ 20140512 
    9807:	e8 fc ff ff ff       	call   9808 <complexUeMacPdu+0x4f8>
		fsm_printf("complex function done by error!\n");//testing code 
    980c:	c7 04 24 58 2a 00 00 	movl   $0x2a58,(%esp)
    9813:	e8 fc ff ff ff       	call   9814 <complexUeMacPdu+0x504>
		fsm_pkt_destroy(skb);
    9818:	89 d8                	mov    %ebx,%eax
    981a:	e8 fc ff ff ff       	call   981b <complexUeMacPdu+0x50b>
	from_len++;
}
fsm_printf("\n");*/

	FOUT;
}	//ICI()
    981f:	83 c4 70             	add    $0x70,%esp
    9822:	5b                   	pop    %ebx
    9823:	5e                   	pop    %esi
    9824:	5f                   	pop    %edi
    9825:	5d                   	pop    %ebp
    9826:	c3                   	ret    
    9827:	90                   	nop
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_long_bsr,len);	//BSR
    9828:	ba 03 00 00 00       	mov    $0x3,%edx
    982d:	89 d8                	mov    %ebx,%eax
    982f:	e8 fc ff ff ff       	call   9830 <complexUeMacPdu+0x520>
    9834:	b9 03 00 00 00       	mov    $0x3,%ecx
    9839:	8d 55 ea             	lea    -0x16(%ebp),%edx
    983c:	e8 fc ff ff ff       	call   983d <complexUeMacPdu+0x52d>
			}
			SV(RetxBSRTimer).time_value = SV(systemconfigInfo.MACMainConfigInfo.ul_SCH_Config.retxBSR_Timer)*100;
			SV(RetxBSRTimer).timer_sign = fsm_schedule_self(SV(RetxBSRTimer).time_value,RexBSRTimer_Expire );
			SV(RetxBSRTimer).flag = true; */			
		}
		Free_Bsr_Info();		//20140428  //LHLBSR
    9841:	e8 fc ff ff ff       	call   9842 <complexUeMacPdu+0x532>
    9846:	e9 cb fc ff ff       	jmp    9516 <complexUeMacPdu+0x206>
    984b:	90                   	nop
    984c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	if(bsr_flag!=0){
		first_flag=false;	//
		if(bsr_flag==1){
			lcid=SHORT_BSR;
			m_fixed_subhead.m_lcid_e_r_r=e<<5;
			m_fixed_subhead.m_lcid_e_r_r=m_fixed_subhead.m_lcid_e_r_r+lcid;
    9850:	83 c0 1d             	add    $0x1d,%eax
    9853:	88 45 f1             	mov    %al,-0xf(%ebp)
			len=sizeof(MAC_SDU_subhead_last);

			if(!compare(skb->data-skb->head,len)){
    9856:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    985c:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9862:	0f 85 ba fd ff ff    	jne    9622 <complexUeMacPdu+0x312>
    9868:	e9 63 ff ff ff       	jmp    97d0 <complexUeMacPdu+0x4c0>
    986d:	8d 76 00             	lea    0x0(%esi),%esi
		//fsm_printf("[HEXI]LENGTH OF THE DATAROOM AFTER ADDING C-RNTI:%d\n",(skb->tail-skb->data));
	}*/
	if(bsr_flag!=0){	//BSR

		if(bsr_flag==1){
			m_short_bsr.m_lcgid_buffersize=lcg_id;
    9870:	8b 45 d8             	mov    -0x28(%ebp),%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize<<6;
    9873:	c1 e0 06             	shl    $0x6,%eax
			m_short_bsr.m_lcgid_buffersize=m_short_bsr.m_lcgid_buffersize+(shortbsr_buf_size);
    9876:	02 45 dc             	add    -0x24(%ebp),%al
    9879:	88 45 f3             	mov    %al,-0xd(%ebp)
			len=sizeof(MAC_CE_shortBSR);

			if(!compare(skb->data-skb->head,len)){
    987c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    9882:	39 83 ac 00 00 00    	cmp    %eax,0xac(%ebx)
    9888:	0f 84 42 ff ff ff    	je     97d0 <complexUeMacPdu+0x4c0>
				clean_CE_tags();
				fsm_pkt_destroy(skb);
				FOUT;
			}

			fsm_mem_cpy(fsm_skb_push(skb,len),&m_short_bsr,len);	//BSR
    988e:	ba 01 00 00 00       	mov    $0x1,%edx
    9893:	89 d8                	mov    %ebx,%eax
    9895:	e8 fc ff ff ff       	call   9896 <complexUeMacPdu+0x586>
    989a:	b9 01 00 00 00       	mov    $0x1,%ecx
    989f:	8d 55 f3             	lea    -0xd(%ebp),%edx
    98a2:	e8 fc ff ff ff       	call   98a3 <complexUeMacPdu+0x593>
    98a7:	eb 98                	jmp    9841 <complexUeMacPdu+0x531>
    98a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	u32 lcg_id,shortbsr_buf_size;	//IDBSRbuffer size
	
	u32 len=0,from_len=0,total_len=0,left_len,head_len,f_flag=0,sdu_len,re_len=0;	//;;;
	u32 m_7bit_numb=0,m_15bit_numb=0;	//
	u32 longbsr_buf_sizes[LONG_BSR_SIZE]={0,0,0,0};	//BSRbuffer size
	bool crnti_flag=false, ph_flag=false,first_flag=true,con_flag=true;	//crnti; 
    98b0:	bf 01 00 00 00       	mov    $0x1,%edi
    98b5:	e9 83 fd ff ff       	jmp    963d <complexUeMacPdu+0x32d>
    98ba:	90                   	nop
    98bb:	90                   	nop
    98bc:	90                   	nop
    98bd:	90                   	nop
    98be:	90                   	nop
    98bf:	90                   	nop

000098c0 <Init_Uemac_Scheduler>:
->output:
->Special:
*******************************
*/
void Init_Uemac_Scheduler(void)
{
    98c0:	55                   	push   %ebp
    98c1:	89 e5                	mov    %esp,%ebp
    98c3:	53                   	push   %ebx
    98c4:	e8 fc ff ff ff       	call   98c5 <Init_Uemac_Scheduler+0x5>
	FIN(Init_Uemac_Scheduler(void));
	SV_PTR_GET(rlc_mac_sv);
    98c9:	e8 fc ff ff ff       	call   98ca <Init_Uemac_Scheduler+0xa>
    98ce:	89 c3                	mov    %eax,%ebx
	SV(LCGZeroToData)=false;
    98d0:	c6 80 58 01 00 00 00 	movb   $0x0,0x158(%eax)
	SV(m_freshUlBsr)=false;
    98d7:	c6 80 59 01 00 00 00 	movb   $0x0,0x159(%eax)
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;
    98de:	c6 80 5a 01 00 00 00 	movb   $0x0,0x15a(%eax)

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    98e5:	b8 1a 00 00 00       	mov    $0x1a,%eax
    98ea:	e8 fc ff ff ff       	call   98eb <Init_Uemac_Scheduler+0x2b>
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    98ef:	31 d2                	xor    %edx,%edx
    98f1:	b9 1a 00 00 00       	mov    $0x1a,%ecx
	SV(LCGZeroToData)=false;
	SV(m_freshUlBsr)=false;
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    98f6:	89 83 54 01 00 00    	mov    %eax,0x154(%ebx)
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    98fc:	e8 fc ff ff ff       	call   98fd <Init_Uemac_Scheduler+0x3d>
	SV(Periodicbsr)=NULL;
	SV(Regularbsr)=NULL;
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    9901:	b8 0d 00 00 00       	mov    $0xd,%eax
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	SV(DATA_WAIT_ALLOCATION)=false;

	SV(bsr)=(MacBufferStatus_BSR_Info *)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
	SV(Periodicbsr)=NULL;
    9906:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    990d:	00 00 00 
	SV(Regularbsr)=NULL;
    9910:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    9917:	00 00 00 
	SV(MacBuffer_RLC)=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    991a:	e8 fc ff ff ff       	call   991b <Init_Uemac_Scheduler+0x5b>
    991f:	89 83 48 01 00 00    	mov    %eax,0x148(%ebx)
	SV(LogicalChannel_Bj)=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    9925:	b8 0d 00 00 00       	mov    $0xd,%eax
    992a:	e8 fc ff ff ff       	call   992b <Init_Uemac_Scheduler+0x6b>
    992f:	89 83 44 01 00 00    	mov    %eax,0x144(%ebx)
	SV(LogicalChannel_Config)=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9935:	b8 19 00 00 00       	mov    $0x19,%eax
    993a:	e8 fc ff ff ff       	call   993b <Init_Uemac_Scheduler+0x7b>
    993f:	89 83 40 01 00 00    	mov    %eax,0x140(%ebx)
	INIT_LIST_HEAD(&(SV(MacBuffer_RLC)->list));
    9945:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    994b:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    994e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9951:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Bj)->list));
    9954:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
    995a:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    995d:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    9960:	89 50 09             	mov    %edx,0x9(%eax)
	INIT_LIST_HEAD(&(SV(LogicalChannel_Config)->list));
    9963:	8b 83 40 01 00 00    	mov    0x140(%ebx),%eax
    9969:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    996c:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    996f:	89 50 15             	mov    %edx,0x15(%eax)
	FOUT;
}
    9972:	5b                   	pop    %ebx
    9973:	5d                   	pop    %ebp
    9974:	c3                   	ret    
    9975:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    9979:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009980 <RlcRequest_arraytolist>:
->Output:RlcBufferRequest 
->Special:
*******************************
*/
RlcBufferRequest * RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num)//num
{
    9980:	55                   	push   %ebp
    9981:	89 e5                	mov    %esp,%ebp
    9983:	57                   	push   %edi
    9984:	56                   	push   %esi
    9985:	53                   	push   %ebx
    9986:	83 ec 18             	sub    $0x18,%esp
    9989:	e8 fc ff ff ff       	call   998a <RlcRequest_arraytolist+0xa>
    998e:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9991:	89 c6                	mov    %eax,%esi
	LogicalChannelConfigInfo *temp_lcc_info;
	u8 lcid;
	u32 flag;

	FIN(RlcRequest_arraytolist(RLC_Request *rlc_request_array,u32 num));
	SV_PTR_GET(rlc_mac_sv);
    9993:	e8 fc ff ff ff       	call   9994 <RlcRequest_arraytolist+0x14>
    9998:	89 c7                	mov    %eax,%edi
	rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    999a:	b8 1b 00 00 00       	mov    $0x1b,%eax
    999f:	e8 fc ff ff ff       	call   99a0 <RlcRequest_arraytolist+0x20>
    99a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    99a7:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
    99aa:	83 c0 13             	add    $0x13,%eax
    99ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    99b0:	89 42 13             	mov    %eax,0x13(%edx)
	list->prev = list;
    99b3:	89 42 17             	mov    %eax,0x17(%edx)
	for(i=0;i<num;i++)
    99b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    99b9:	85 c0                	test   %eax,%eax
    99bb:	74 52                	je     9a0f <RlcRequest_arraytolist+0x8f>
    99bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    99c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    99c8:	8b 87 40 01 00 00    	mov    0x140(%edi),%eax
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
    99ce:	0f b6 56 02          	movzbl 0x2(%esi),%edx
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    99d2:	8b 58 11             	mov    0x11(%eax),%ebx
    99d5:	83 eb 11             	sub    $0x11,%ebx
    99d8:	39 d8                	cmp    %ebx,%eax
    99da:	74 12                	je     99ee <RlcRequest_arraytolist+0x6e>
		{
			if(lcid==temp_lcc_info->lcid)
    99dc:	38 13                	cmp    %dl,(%ebx)
    99de:	74 48                	je     9a28 <RlcRequest_arraytolist+0xa8>
	for(i=0;i<num;i++)
	{
		lcid=rlc_request_array[i].lcid;
		temp_lcc_info=NULL;
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
    99e0:	8b 5b 11             	mov    0x11(%ebx),%ebx
    99e3:	83 eb 11             	sub    $0x11,%ebx
    99e6:	39 9f 40 01 00 00    	cmp    %ebx,0x140(%edi)
    99ec:	75 ee                	jne    99dc <RlcRequest_arraytolist+0x5c>
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
    99ee:	c7 04 24 60 2b 00 00 	movl   $0x2b60,(%esp)
    99f5:	e8 fc ff ff ff       	call   99f6 <RlcRequest_arraytolist+0x76>
    99fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	/*while(rlcrequest==0)//
	{
		rlcrequest=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(rlcrequest->list));
	for(i=0;i<num;i++)
    9a00:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9a04:	83 c6 13             	add    $0x13,%esi
    9a07:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9a0a:	39 55 f0             	cmp    %edx,-0x10(%ebp)
    9a0d:	75 b9                	jne    99c8 <RlcRequest_arraytolist+0x48>
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    9a0f:	8b 55 e8             	mov    -0x18(%ebp),%edx
	FRET(rlcrequest);
}
    9a12:	8b 45 ec             	mov    -0x14(%ebp),%eax
			list_add_tail(&(rlcrequest_temp->list), &(rlcrequest->list));
		}
		else
			fsm_printf("[UEMAC][RLCreq_tolist]:rlc request and lc_config error\n");
	}
	SV(Rlc_Request_Num)=num;
    9a15:	89 97 5c 01 00 00    	mov    %edx,0x15c(%edi)
	FRET(rlcrequest);
}
    9a1b:	83 c4 18             	add    $0x18,%esp
    9a1e:	5b                   	pop    %ebx
    9a1f:	5e                   	pop    %esi
    9a20:	5f                   	pop    %edi
    9a21:	5d                   	pop    %ebp
    9a22:	c3                   	ret    
    9a23:	90                   	nop
    9a24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag=0;
		list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			if(lcid==temp_lcc_info->lcid)
			{
				if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9a28:	83 7b 0d 03          	cmpl   $0x3,0xd(%ebx)
    9a2c:	77 6a                	ja     9a98 <RlcRequest_arraytolist+0x118>
				}
			}
		}
		if(flag==1)//requestMAC 
		{		
			rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9a2e:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9a33:	e8 fc ff ff ff       	call   9a34 <RlcRequest_arraytolist+0xb4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9a38:	8b 5d ec             	mov    -0x14(%ebp),%ebx
			/*while(rlcrequest_temp==0)//
			{
				rlcrequest_temp=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
			}*/
			INIT_LIST_HEAD(&(rlcrequest_temp->list));
    9a3b:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9a3e:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9a41:	89 50 17             	mov    %edx,0x17(%eax)
			rlcrequest_temp->rnti=rlc_request_array[i].rnti;
    9a44:	0f b7 0e             	movzwl (%esi),%ecx
    9a47:	66 89 08             	mov    %cx,(%eax)
			rlcrequest_temp->lcid=rlc_request_array[i].lcid;
    9a4a:	0f b6 4e 02          	movzbl 0x2(%esi),%ecx
    9a4e:	88 48 02             	mov    %cl,0x2(%eax)
			rlcrequest_temp->txQueueSize=rlc_request_array[i].txQueueSize;
    9a51:	8b 4e 03             	mov    0x3(%esi),%ecx
    9a54:	89 48 03             	mov    %ecx,0x3(%eax)
			rlcrequest_temp->txQueueHeader=rlc_request_array[i].txQueueHeader;
    9a57:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    9a5b:	66 89 48 07          	mov    %cx,0x7(%eax)
			rlcrequest_temp->retxQueueSize=rlc_request_array[i].retxQueueSize;
    9a5f:	8b 4e 09             	mov    0x9(%esi),%ecx
    9a62:	89 48 09             	mov    %ecx,0x9(%eax)
			rlcrequest_temp->retxQueueHeader=rlc_request_array[i].retxQueueHeader;
    9a65:	0f b7 4e 0d          	movzwl 0xd(%esi),%ecx
    9a69:	66 89 48 0d          	mov    %cx,0xd(%eax)
			rlcrequest_temp->statusPduSize=rlc_request_array[i].statusPduSize;
    9a6d:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    9a71:	66 89 48 0f          	mov    %cx,0xf(%eax)
			rlcrequest_temp->statusPduHeader=rlc_request_array[i].statusPduHeader;
    9a75:	0f b7 4e 11          	movzwl 0x11(%esi),%ecx
    9a79:	66 89 48 11          	mov    %cx,0x11(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    9a7d:	8b 4b 17             	mov    0x17(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    9a80:	89 53 17             	mov    %edx,0x17(%ebx)
	new->next = next;
    9a83:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	new->prev = prev;
    9a86:	89 48 17             	mov    %ecx,0x17(%eax)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    9a89:	89 58 13             	mov    %ebx,0x13(%eax)
	new->prev = prev;
	prev->next = new;
    9a8c:	89 11                	mov    %edx,(%ecx)
    9a8e:	e9 6d ff ff ff       	jmp    9a00 <RlcRequest_arraytolist+0x80>
    9a93:	90                   	nop
    9a94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					flag=1;
					break;
				}
				else
				{
					fsm_printf("[UEMAC][RLCreq_tolist]:lc_group error ,maybe it's rrc's mistake\n");
    9a98:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9a9b:	c7 04 24 1c 2b 00 00 	movl   $0x2b1c,(%esp)
    9aa2:	e8 fc ff ff ff       	call   9aa3 <RlcRequest_arraytolist+0x123>
    9aa7:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
					continue;
    9aab:	e9 30 ff ff ff       	jmp    99e0 <RlcRequest_arraytolist+0x60>

00009ab0 <RlcRequest_listtoarray>:
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9ab0:	55                   	push   %ebp
    9ab1:	89 e5                	mov    %esp,%ebp
    9ab3:	57                   	push   %edi
    9ab4:	56                   	push   %esi
    9ab5:	53                   	push   %ebx
    9ab6:	83 ec 10             	sub    $0x10,%esp
    9ab9:	e8 fc ff ff ff       	call   9aba <RlcRequest_listtoarray+0xa>
	/*while(rlc_report==0)//
	{
		rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(int));
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;
    9abe:	31 db                	xor    %ebx,%ebx
->Output:*num:IOCTLbufferRLC + void *: RLC 
->Special:
*******************************
*/
 void * RlcRequest_listtoarray( RlcBufferRequest *rlc_request,u32 *num)//numreport
{
    9ac0:	89 55 e8             	mov    %edx,-0x18(%ebp)
    9ac3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	void *rlc_report;
	u32 *temp_num;
	RLC_Request *rlc_report_temp;

	FIN(RlcRequest_listtoarray( RlcBufferRequest *rlc_request,int *num));
	SV_PTR_GET(rlc_mac_sv);
    9ac6:	e8 fc ff ff ff       	call   9ac7 <RlcRequest_listtoarray+0x17>
	rlc_report=(void *)fsm_mem_alloc(sizeof(RLC_Request)*SV(Rlc_Request_Num)+sizeof(u32));//report
    9acb:	8b 80 5c 01 00 00    	mov    0x15c(%eax),%eax
    9ad1:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    9ad4:	8d 44 50 04          	lea    0x4(%eax,%edx,2),%eax
    9ad8:	e8 fc ff ff ff       	call   9ad9 <RlcRequest_listtoarray+0x29>
    9add:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9ae0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9ae3:	8b 50 13             	mov    0x13(%eax),%edx
    9ae6:	89 c7                	mov    %eax,%edi
    9ae8:	b8 04 00 00 00       	mov    $0x4,%eax
    9aed:	83 c7 13             	add    $0x13,%edi
    9af0:	39 fa                	cmp    %edi,%edx
    9af2:	8b 0a                	mov    (%edx),%ecx
    9af4:	74 62                	je     9b58 <RlcRequest_listtoarray+0xa8>
    9af6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9af9:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    9afc:	eb 06                	jmp    9b04 <RlcRequest_listtoarray+0x54>
    9afe:	66 90                	xchg   %ax,%ax
    9b00:	89 ca                	mov    %ecx,%edx
    9b02:	89 f1                	mov    %esi,%ecx
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    9b04:	0f b7 72 ed          	movzwl -0x13(%edx),%esi
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
    9b08:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		rlc_report_temp[i].rnti=temp->rnti;
    9b0c:	66 89 70 04          	mov    %si,0x4(%eax)
		rlc_report_temp[i].lcid=temp->lcid;
    9b10:	0f b6 72 ef          	movzbl -0x11(%edx),%esi
    9b14:	89 f3                	mov    %esi,%ebx
    9b16:	88 58 06             	mov    %bl,0x6(%eax)
		rlc_report_temp[i].txQueueSize=temp->txQueueSize;
    9b19:	8b 72 f0             	mov    -0x10(%edx),%esi
    9b1c:	89 70 07             	mov    %esi,0x7(%eax)
		rlc_report_temp[i].txQueueHeader=temp->txQueueHeader;
    9b1f:	0f b7 72 f4          	movzwl -0xc(%edx),%esi
    9b23:	66 89 70 0b          	mov    %si,0xb(%eax)
		rlc_report_temp[i].retxQueueSize=temp->retxQueueSize;
    9b27:	8b 72 f6             	mov    -0xa(%edx),%esi
    9b2a:	89 70 0d             	mov    %esi,0xd(%eax)
		rlc_report_temp[i].retxQueueHeader=temp->retxQueueHeader;
    9b2d:	0f b7 72 fa          	movzwl -0x6(%edx),%esi
    9b31:	66 89 70 11          	mov    %si,0x11(%eax)
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
    9b35:	0f b7 72 fc          	movzwl -0x4(%edx),%esi
    9b39:	66 89 70 13          	mov    %si,0x13(%eax)
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
    9b3d:	0f b7 52 fe          	movzwl -0x2(%edx),%edx
    9b41:	66 89 50 15          	mov    %dx,0x15(%eax)
	}*/
	pos=NULL,p=NULL,temp=NULL;
	i=0;

	rlc_report_temp=(RLC_Request *)(((u32 *)rlc_report)+1);//+1
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9b45:	83 c0 13             	add    $0x13,%eax
    9b48:	39 cf                	cmp    %ecx,%edi
    9b4a:	8b 31                	mov    (%ecx),%esi
    9b4c:	75 b2                	jne    9b00 <RlcRequest_listtoarray+0x50>
    9b4e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    9b51:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    9b54:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
		rlc_report_temp[i].statusPduSize=temp->statusPduSize;
		rlc_report_temp[i].statusPduHeader=temp->statusPduHeader;
		i++;
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
    9b58:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9b5b:	89 1a                	mov    %ebx,(%edx)
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
    9b5d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9b60:	89 02                	mov    %eax,(%edx)
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b65:	8b 50 13             	mov    0x13(%eax),%edx
    9b68:	39 d7                	cmp    %edx,%edi
    9b6a:	8b 1a                	mov    (%edx),%ebx
    9b6c:	75 04                	jne    9b72 <RlcRequest_listtoarray+0xc2>
    9b6e:	eb 1f                	jmp    9b8f <RlcRequest_listtoarray+0xdf>
    9b70:	89 f2                	mov    %esi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    9b72:	8b 4a 04             	mov    0x4(%edx),%ecx
    9b75:	89 de                	mov    %ebx,%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    9b77:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    9b7a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    9b7d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9b7f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    9b81:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);//
    9b84:	e8 fc ff ff ff       	call   9b85 <RlcRequest_listtoarray+0xd5>
	}
	temp_num=(u32 *)rlc_report;
	*temp_num=i;//report()
	*num=sizeof(RLC_Request)*i+sizeof(u32);//RLC report
	pos=NULL,p=NULL,temp=NULL;
	list_for_each_safe(pos,p,&(rlc_request->list))//
    9b89:	39 fe                	cmp    %edi,%esi
    9b8b:	8b 1b                	mov    (%ebx),%ebx
    9b8d:	75 e1                	jne    9b70 <RlcRequest_listtoarray+0xc0>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);//
	}
	fsm_mem_free(rlc_request);
    9b8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b92:	e8 fc ff ff ff       	call   9b93 <RlcRequest_listtoarray+0xe3>
	FRET(rlc_report);
}
    9b97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9b9a:	83 c4 10             	add    $0x10,%esp
    9b9d:	5b                   	pop    %ebx
    9b9e:	5e                   	pop    %esi
    9b9f:	5f                   	pop    %edi
    9ba0:	5d                   	pop    %ebp
    9ba1:	c3                   	ret    
    9ba2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    9ba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00009bb0 <Rlc_MacRequest_copy>:
->Output:RLC_Request
->Special:
*******************************
*/
RLC_Request* Rlc_MacRequest_copy(RlcBufferRequest *temp)
{
    9bb0:	55                   	push   %ebp
    9bb1:	89 e5                	mov    %esp,%ebp
    9bb3:	53                   	push   %ebx
    9bb4:	e8 fc ff ff ff       	call   9bb5 <Rlc_MacRequest_copy+0x5>
    9bb9:	89 c3                	mov    %eax,%ebx
	FIN(Rlc_MacRequest_copy(RlcBufferRequest *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9bbb:	b8 13 00 00 00       	mov    $0x13,%eax
    9bc0:	e8 fc ff ff ff       	call   9bc1 <Rlc_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9bc5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9bc9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9bcc:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9bd0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9bd4:	8b 53 09             	mov    0x9(%ebx),%edx
    9bd7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9bda:	0f b7 13             	movzwl (%ebx),%edx
    9bdd:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9be0:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9be4:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9be8:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9bec:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9bf0:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9bf4:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9bf8:	8b 53 03             	mov    0x3(%ebx),%edx
    9bfb:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9bfe:	5b                   	pop    %ebx
    9bff:	5d                   	pop    %ebp
    9c00:	c3                   	ret    
    9c01:	eb 0d                	jmp    9c10 <LogicalChannel_ConfigInfo_copy>
    9c03:	90                   	nop
    9c04:	90                   	nop
    9c05:	90                   	nop
    9c06:	90                   	nop
    9c07:	90                   	nop
    9c08:	90                   	nop
    9c09:	90                   	nop
    9c0a:	90                   	nop
    9c0b:	90                   	nop
    9c0c:	90                   	nop
    9c0d:	90                   	nop
    9c0e:	90                   	nop
    9c0f:	90                   	nop

00009c10 <LogicalChannel_ConfigInfo_copy>:
->Output:LogicalChannelConfigInfo:MAC
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp)
{
    9c10:	55                   	push   %ebp
    9c11:	89 e5                	mov    %esp,%ebp
    9c13:	53                   	push   %ebx
    9c14:	e8 fc ff ff ff       	call   9c15 <LogicalChannel_ConfigInfo_copy+0x5>
    9c19:	89 c3                	mov    %eax,%ebx
	FIN(LogicalChannel_ConfigInfo_copy(MAC_LogicalChannelConfig_IoctrlMsg *temp));
	LogicalChannelConfigInfo *copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
    9c1b:	b8 19 00 00 00       	mov    $0x19,%eax
    9c20:	e8 fc ff ff ff       	call   9c21 <LogicalChannel_ConfigInfo_copy+0x11>
	/*while(copy==0)//
	{
		copy=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9c25:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9c28:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    9c2b:	89 50 15             	mov    %edx,0x15(%eax)
	copy->lcid=temp->logicalChannelIdentity;
    9c2e:	8b 13                	mov    (%ebx),%edx
    9c30:	88 10                	mov    %dl,(%eax)
	copy->priority=(temp->logicalChannelConfig).ul_SpecificParameters.priority;
    9c32:	8b 53 05             	mov    0x5(%ebx),%edx
    9c35:	89 50 01             	mov    %edx,0x1(%eax)
	copy->prioritizedBitRateKbps=(temp->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    9c38:	8b 53 09             	mov    0x9(%ebx),%edx
    9c3b:	89 50 05             	mov    %edx,0x5(%eax)
	copy->bucketSizeDurationMs=(temp->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    9c3e:	8b 53 0d             	mov    0xd(%ebx),%edx
    9c41:	89 50 09             	mov    %edx,0x9(%eax)
	copy->logicalChannelGroup=(temp->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    9c44:	8b 53 11             	mov    0x11(%ebx),%edx
    9c47:	89 50 0d             	mov    %edx,0xd(%eax)
	FRET(copy);
}
    9c4a:	5b                   	pop    %ebx
    9c4b:	5d                   	pop    %ebp
    9c4c:	c3                   	ret    
    9c4d:	8d 76 00             	lea    0x0(%esi),%esi

00009c50 <Mac_RlcRequest_copy>:
->Output:RlcBufferRequest:MACRLC request
->Special:
*******************************
*/
RlcBufferRequest* Mac_RlcRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9c50:	55                   	push   %ebp
    9c51:	89 e5                	mov    %esp,%ebp
    9c53:	53                   	push   %ebx
    9c54:	e8 fc ff ff ff       	call   9c55 <Mac_RlcRequest_copy+0x5>
    9c59:	89 c3                	mov    %eax,%ebx
	FIN(Mac_RlcRequest_copy(RLC_Request *temp));
	RlcBufferRequest *copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    9c5b:	b8 1b 00 00 00       	mov    $0x1b,%eax
    9c60:	e8 fc ff ff ff       	call   9c61 <Mac_RlcRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(copy->list));
    9c65:	8d 50 13             	lea    0x13(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    9c68:	89 50 13             	mov    %edx,0x13(%eax)
	list->prev = list;
    9c6b:	89 50 17             	mov    %edx,0x17(%eax)
	copy->lcid=temp->lcid;
    9c6e:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9c72:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9c75:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9c79:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9c7d:	8b 53 09             	mov    0x9(%ebx),%edx
    9c80:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9c83:	0f b7 13             	movzwl (%ebx),%edx
    9c86:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9c89:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9c8d:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9c91:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9c95:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9c99:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9c9d:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9ca1:	8b 53 03             	mov    0x3(%ebx),%edx
    9ca4:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9ca7:	5b                   	pop    %ebx
    9ca8:	5d                   	pop    %ebp
    9ca9:	c3                   	ret    
    9caa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00009cb0 <Mac_MacRequest_copy>:
->Output:RLC_Request *
->Special:
*******************************
*/
RLC_Request* Mac_MacRequest_copy(RLC_Request *temp)//RlcBufferRequest
{
    9cb0:	55                   	push   %ebp
    9cb1:	89 e5                	mov    %esp,%ebp
    9cb3:	53                   	push   %ebx
    9cb4:	e8 fc ff ff ff       	call   9cb5 <Mac_MacRequest_copy+0x5>
    9cb9:	89 c3                	mov    %eax,%ebx
	FIN(Mac_MacRequest_copy(RLC_Request *temp));
	RLC_Request *copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
    9cbb:	b8 13 00 00 00       	mov    $0x13,%eax
    9cc0:	e8 fc ff ff ff       	call   9cc1 <Mac_MacRequest_copy+0x11>
	/*while(copy==0)//
	{
		copy=(RLC_Request *)fsm_mem_alloc(sizeof(RLC_Request));
	}*/
	copy->lcid=temp->lcid;
    9cc5:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
    9cc9:	88 50 02             	mov    %dl,0x2(%eax)
	copy->retxQueueHeader=temp->retxQueueHeader;
    9ccc:	0f b7 53 0d          	movzwl 0xd(%ebx),%edx
    9cd0:	66 89 50 0d          	mov    %dx,0xd(%eax)
	copy->retxQueueSize=temp->retxQueueSize;
    9cd4:	8b 53 09             	mov    0x9(%ebx),%edx
    9cd7:	89 50 09             	mov    %edx,0x9(%eax)
	copy->rnti=temp->rnti;
    9cda:	0f b7 13             	movzwl (%ebx),%edx
    9cdd:	66 89 10             	mov    %dx,(%eax)
	copy->statusPduHeader=temp->statusPduHeader;
    9ce0:	0f b7 53 11          	movzwl 0x11(%ebx),%edx
    9ce4:	66 89 50 11          	mov    %dx,0x11(%eax)
	copy->statusPduSize=temp->statusPduSize;
    9ce8:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
    9cec:	66 89 50 0f          	mov    %dx,0xf(%eax)
	copy->txQueueHeader=temp->txQueueHeader;
    9cf0:	0f b7 53 07          	movzwl 0x7(%ebx),%edx
    9cf4:	66 89 50 07          	mov    %dx,0x7(%eax)
	copy->txQueueSize=temp->txQueueSize;
    9cf8:	8b 53 03             	mov    0x3(%ebx),%edx
    9cfb:	89 50 03             	mov    %edx,0x3(%eax)
	FRET(copy);
}
    9cfe:	5b                   	pop    %ebx
    9cff:	5d                   	pop    %ebp
    9d00:	c3                   	ret    
    9d01:	eb 0d                	jmp    9d10 <MacBufferStatus_BSR_Info_copy>
    9d03:	90                   	nop
    9d04:	90                   	nop
    9d05:	90                   	nop
    9d06:	90                   	nop
    9d07:	90                   	nop
    9d08:	90                   	nop
    9d09:	90                   	nop
    9d0a:	90                   	nop
    9d0b:	90                   	nop
    9d0c:	90                   	nop
    9d0d:	90                   	nop
    9d0e:	90                   	nop
    9d0f:	90                   	nop

00009d10 <MacBufferStatus_BSR_Info_copy>:
->Output:MacBufferStatus_BSR_Info *
->Special:
*******************************
*/
MacBufferStatus_BSR_Info* MacBufferStatus_BSR_Info_copy(void)//BSR
{
    9d10:	55                   	push   %ebp
    9d11:	89 e5                	mov    %esp,%ebp
    9d13:	53                   	push   %ebx
    9d14:	e8 fc ff ff ff       	call   9d15 <MacBufferStatus_BSR_Info_copy+0x5>
	FIN(MacBufferStatus_BSR_Info_copy(void));
	SV_PTR_GET(rlc_mac_sv);
    9d19:	e8 fc ff ff ff       	call   9d1a <MacBufferStatus_BSR_Info_copy+0xa>
    9d1e:	89 c3                	mov    %eax,%ebx
	u32 j=0;
	MacBufferStatus_BSR_Info* copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
    9d20:	b8 1a 00 00 00       	mov    $0x1a,%eax
    9d25:	e8 fc ff ff ff       	call   9d26 <MacBufferStatus_BSR_Info_copy+0x16>
	/*while(copy==0)//
	{
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
    9d2a:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9d30:	8b 52 02             	mov    0x2(%edx),%edx
    9d33:	89 50 02             	mov    %edx,0x2(%eax)
	copy->m_rnti=SV(bsr)->m_rnti;
    9d36:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9d3c:	0f b7 12             	movzwl (%edx),%edx
    9d3f:	66 89 10             	mov    %dx,(%eax)
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
    9d42:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9d48:	8b 52 06             	mov    0x6(%edx),%edx
    9d4b:	89 50 06             	mov    %edx,0x6(%eax)
	for(j=0;j<LCG;j++)
    9d4e:	31 d2                	xor    %edx,%edx
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
    9d50:	8b 8b 54 01 00 00    	mov    0x154(%ebx),%ecx
    9d56:	8b 4c 91 0a          	mov    0xa(%ecx,%edx,4),%ecx
    9d5a:	89 4c 90 0a          	mov    %ecx,0xa(%eax,%edx,4)
		copy=(MacBufferStatus_BSR_Info*)fsm_mem_alloc(sizeof(MacBufferStatus_BSR_Info));
	}*/
	copy->m_lcgnum=SV(bsr)->m_lcgnum;
	copy->m_rnti=SV(bsr)->m_rnti;
	copy->m_TotalLcgData=SV(bsr)->m_TotalLcgData;
	for(j=0;j<LCG;j++)
    9d5e:	83 c2 01             	add    $0x1,%edx
    9d61:	83 fa 04             	cmp    $0x4,%edx
    9d64:	75 ea                	jne    9d50 <MacBufferStatus_BSR_Info_copy+0x40>
		copy->m_bufferStatus[j]=SV(bsr)->m_bufferStatus[j];
	FRET(copy);
}
    9d66:	5b                   	pop    %ebx
    9d67:	5d                   	pop    %ebp
    9d68:	c3                   	ret    
    9d69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009d70 <FlushBj>:
->Output:SV(LogicalChannel_Config)lcbj
->Special:lcbjMAX_BJ/8+1:
*******************************
*/
void FlushBj(void)
{
    9d70:	55                   	push   %ebp
    9d71:	89 e5                	mov    %esp,%ebp
    9d73:	57                   	push   %edi
    9d74:	56                   	push   %esi
    9d75:	53                   	push   %ebx
    9d76:	83 ec 04             	sub    $0x4,%esp
    9d79:	e8 fc ff ff ff       	call   9d7a <FlushBj+0xa>
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
    9d7e:	e8 fc ff ff ff       	call   9d7f <FlushBj+0xf>
    9d83:	89 c7                	mov    %eax,%edi
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9d85:	8b 80 44 01 00 00    	mov    0x144(%eax),%eax
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9d8b:	8b 70 05             	mov    0x5(%eax),%esi
{
	LogicalChannelConfigInfo *temp_Logical_Channel_Config;
	u8 temp_Bj_lcid,temp_lcc_lcid,BucketSize;
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
    9d8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9d91:	83 ee 05             	sub    $0x5,%esi
    9d94:	39 f0                	cmp    %esi,%eax
    9d96:	74 63                	je     9dfb <FlushBj+0x8b>
	{
		temp_Bj_lcid=temp->lcid;
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9d98:	8b 8f 40 01 00 00    	mov    0x140(%edi),%ecx
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
	{
		temp_Bj_lcid=temp->lcid;
    9d9e:	0f b6 1e             	movzbl (%esi),%ebx
		flag_tail=false;
		temp_Logical_Channel_Config=NULL;
		list_for_each_entry(temp_Logical_Channel_Config, &(SV(LogicalChannel_Config)->list),list)//
    9da1:	8b 51 11             	mov    0x11(%ecx),%edx
    9da4:	8d 42 ef             	lea    -0x11(%edx),%eax
    9da7:	39 c1                	cmp    %eax,%ecx
    9da9:	75 0f                	jne    9dba <FlushBj+0x4a>
    9dab:	eb 43                	jmp    9df0 <FlushBj+0x80>
    9dad:	8d 76 00             	lea    0x0(%esi),%esi
    9db0:	8b 50 11             	mov    0x11(%eax),%edx
    9db3:	8d 42 ef             	lea    -0x11(%edx),%eax
    9db6:	39 c1                	cmp    %eax,%ecx
    9db8:	74 36                	je     9df0 <FlushBj+0x80>
		{
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
    9dba:	38 5a ef             	cmp    %bl,-0x11(%edx)
    9dbd:	75 f1                	jne    9db0 <FlushBj+0x40>
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
    9dbf:	8b 50 05             	mov    0x5(%eax),%edx
    9dc2:	83 fa ff             	cmp    $0xffffffff,%edx
    9dc5:	74 49                	je     9e10 <FlushBj+0xa0>
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9dc7:	8b 40 09             	mov    0x9(%eax),%eax
					if(temp->lcbj < BucketSize)
    9dca:	8b 4e 01             	mov    0x1(%esi),%ecx
					temp->lcbj=MAX_BJ/8+1;//1
					flag_tail=true;
				}
				else
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
    9dcd:	0f af c2             	imul   %edx,%eax
    9dd0:	c1 e8 03             	shr    $0x3,%eax
					if(temp->lcbj < BucketSize)
    9dd3:	0f b6 c0             	movzbl %al,%eax
    9dd6:	39 c1                	cmp    %eax,%ecx
    9dd8:	73 2e                	jae    9e08 <FlushBj+0x98>
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
    9dda:	85 d2                	test   %edx,%edx
    9ddc:	8d 42 07             	lea    0x7(%edx),%eax
    9ddf:	0f 48 d0             	cmovs  %eax,%edx
    9de2:	c1 fa 03             	sar    $0x3,%edx
    9de5:	01 ca                	add    %ecx,%edx
    9de7:	89 56 01             	mov    %edx,0x1(%esi)
    9dea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	FIN(FlushBj(void));
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelBj *head_Bj=SV(LogicalChannel_Bj),*temp=NULL;	
	bool flag_tail=false;

	list_for_each_entry(temp, &head_Bj->list,list)//
    9df0:	8b 76 05             	mov    0x5(%esi),%esi
    9df3:	83 ee 05             	sub    $0x5,%esi
    9df6:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    9df9:	75 9d                	jne    9d98 <FlushBj+0x28>
		if(flag_tail==false)
			//fsm_printf("[UEMAC][FlushBj]FlushBj ERROR");//LogicalChannelConfigLogicalChannelConfigBj
		flag_tail=false;
	}
	FOUT;
}
    9dfb:	83 c4 04             	add    $0x4,%esp
    9dfe:	5b                   	pop    %ebx
    9dff:	5e                   	pop    %esi
    9e00:	5f                   	pop    %edi
    9e01:	5d                   	pop    %ebp
    9e02:	c3                   	ret    
    9e03:	90                   	nop
    9e04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					BucketSize=(temp_Logical_Channel_Config->prioritizedBitRateKbps)*(temp_Logical_Channel_Config->bucketSizeDurationMs)/8;
					if(temp->lcbj < BucketSize)
						temp->lcbj=temp->lcbj+(temp_Logical_Channel_Config->prioritizedBitRateKbps)*TTI/8;//8byte
					else
						temp->lcbj=BucketSize;
    9e08:	89 46 01             	mov    %eax,0x1(%esi)
    9e0b:	eb e3                	jmp    9df0 <FlushBj+0x80>
    9e0d:	8d 76 00             	lea    0x0(%esi),%esi
			temp_lcc_lcid=temp_Logical_Channel_Config->lcid;
			if(temp_lcc_lcid==temp_Bj_lcid)
			{
				if((temp_Logical_Channel_Config->prioritizedBitRateKbps)==infinity)//
				{
					temp->lcbj=MAX_BJ/8+1;//1
    9e10:	c7 46 01 01 7d 00 00 	movl   $0x7d01,0x1(%esi)
    9e17:	eb d7                	jmp    9df0 <FlushBj+0x80>
    9e19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00009e20 <BufferSize2BsrSize>:
->Output:BufferSizeLevelBsrTableindex
->Special:
*******************************
*/
u32 BufferSize2BsrSize(u32 buffersize)
{
    9e20:	55                   	push   %ebp
    9e21:	89 e5                	mov    %esp,%ebp
    9e23:	53                   	push   %ebx
    9e24:	e8 fc ff ff ff       	call   9e25 <BufferSize2BsrSize+0x5>
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
    9e29:	31 d2                	xor    %edx,%edx
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9e2b:	85 c0                	test   %eax,%eax
    9e2d:	74 2b                	je     9e5a <BufferSize2BsrSize+0x3a>
    9e2f:	b2 01                	mov    $0x1,%dl
    9e31:	31 c9                	xor    %ecx,%ecx
    9e33:	eb 05                	jmp    9e3a <BufferSize2BsrSize+0x1a>
    9e35:	8d 76 00             	lea    0x0(%esi),%esi
    9e38:	89 da                	mov    %ebx,%edx
			FRET(i);
		if(BufferSizeLevelBsrTable[i]< buffersize && BufferSizeLevelBsrTable[i+1]>= buffersize)
    9e3a:	39 c8                	cmp    %ecx,%eax
    9e3c:	76 09                	jbe    9e47 <BufferSize2BsrSize+0x27>
    9e3e:	3b 04 95 40 33 00 00 	cmp    0x3340(,%edx,4),%eax
    9e45:	76 13                	jbe    9e5a <BufferSize2BsrSize+0x3a>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
    9e47:	83 fa 3f             	cmp    $0x3f,%edx
    9e4a:	74 0e                	je     9e5a <BufferSize2BsrSize+0x3a>
    9e4c:	8d 5a 01             	lea    0x1(%edx),%ebx
	FIN(BufferSize2BsrSize(u32 buffersize));
	u32 i=0;

	for(i=0;i<BSRTABLEINDEX-1;i++)
	{
		if (BufferSizeLevelBsrTable[i]==buffersize)
    9e4f:	8b 0c 9d 3c 33 00 00 	mov    0x333c(,%ebx,4),%ecx
    9e56:	39 c1                	cmp    %eax,%ecx
    9e58:	75 de                	jne    9e38 <BufferSize2BsrSize+0x18>
			FRET(i+1);
		if(i== BSRTABLEINDEX-2)
			FRET(BSRTABLEINDEX-1);
	}
	FRET(-1);
}
    9e5a:	89 d0                	mov    %edx,%eax
    9e5c:	5b                   	pop    %ebx
    9e5d:	5d                   	pop    %ebp
    9e5e:	c3                   	ret    
    9e5f:	90                   	nop

00009e60 <RefreshBufferStatusForBSR>:
->Output:SV(bsr)
->Special:
*******************************
*/
void RefreshBufferStatusForBSR(void)
{
    9e60:	55                   	push   %ebp
    9e61:	89 e5                	mov    %esp,%ebp
    9e63:	57                   	push   %edi
    9e64:	56                   	push   %esi
    9e65:	53                   	push   %ebx
    9e66:	83 ec 24             	sub    $0x24,%esp
    9e69:	e8 fc ff ff ff       	call   9e6a <RefreshBufferStatusForBSR+0xa>
	LogicalChannelConfigInfo *temp_lcc_info=NULL;
	MacBufferStatus *temp=NULL;
	struct list_head *pos1=NULL,*p1=NULL;
	struct list_head *pos=NULL,*p=NULL;
	u32 queue[LCG]={0,0,0,0};//LCG
    9e6e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    9e75:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    9e7c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    9e83:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	u32 logicalchannelgroup;
	u32 i;
	bool flag_find=false;

	FIN(RefreshBufferStatusForBSR(void));
	SV_PTR_GET(rlc_mac_sv);
    9e8a:	e8 fc ff ff ff       	call   9e8b <RefreshBufferStatusForBSR+0x2b>
    9e8f:	89 c3                	mov    %eax,%ebx
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9e91:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9e97:	8d 50 05             	lea    0x5(%eax),%edx
    9e9a:	39 50 05             	cmp    %edx,0x5(%eax)
	{
		SV(bsr)->m_lcgnum=0;
    9e9d:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
/*    if (SV(C_RNTI) == 0)//UE
    {
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
    9ea3:	0f 84 4e 01 00 00    	je     9ff7 <RefreshBufferStatusForBSR+0x197>
	{
		SV(bsr)->m_lcgnum=0;
		//printk(KERN_INFO"No BSR report to transmit\n");
		FOUT;
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
    9ea9:	0f b7 13             	movzwl (%ebx),%edx
    9eac:	66 89 10             	mov    %dx,(%eax)
	SV(bsr)->m_lcgnum=0;
    9eaf:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9eb5:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
	SV(bsr)->m_TotalLcgData=0;		
    9ebc:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9ec2:	c7 40 06 00 00 00 00 	movl   $0x0,0x6(%eax)
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9ec9:	8b 83 48 01 00 00    	mov    0x148(%ebx),%eax
    9ecf:	8b 48 05             	mov    0x5(%eax),%ecx
    9ed2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9ed5:	8b 55 dc             	mov    -0x24(%ebp),%edx
    9ed8:	31 c0                	xor    %eax,%eax
    9eda:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    9edd:	8b 09                	mov    (%ecx),%ecx
    9edf:	83 c2 05             	add    $0x5,%edx
    9ee2:	39 55 e0             	cmp    %edx,-0x20(%ebp)
    9ee5:	0f 84 a1 00 00 00    	je     9f8c <RefreshBufferStatusForBSR+0x12c>
    9eeb:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    9eee:	89 cb                	mov    %ecx,%ebx
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9ef0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    9ef3:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
    9ef9:	8b 4e 11             	mov    0x11(%esi),%ecx
    9efc:	83 c6 11             	add    $0x11,%esi
    9eff:	8b 01                	mov    (%ecx),%eax
    9f01:	39 f1                	cmp    %esi,%ecx
    9f03:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    9f06:	74 43                	je     9f4b <RefreshBufferStatusForBSR+0xeb>
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9f08:	8b 51 fc             	mov    -0x4(%ecx),%edx
    9f0b:	83 fa 03             	cmp    $0x3,%edx
    9f0e:	77 52                	ja     9f62 <RefreshBufferStatusForBSR+0x102>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9f10:	8b 45 e0             	mov    -0x20(%ebp),%eax
    9f13:	0f b6 78 fb          	movzbl -0x5(%eax),%edi
    9f17:	89 f8                	mov    %edi,%eax
    9f19:	3a 41 ef             	cmp    -0x11(%ecx),%al
    9f1c:	0f 84 a8 00 00 00    	je     9fca <RefreshBufferStatusForBSR+0x16a>
    9f22:	89 fa                	mov    %edi,%edx
    9f24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    9f27:	89 df                	mov    %ebx,%edi
    9f29:	89 d3                	mov    %edx,%ebx
    9f2b:	eb 16                	jmp    9f43 <RefreshBufferStatusForBSR+0xe3>
    9f2d:	8d 76 00             	lea    0x0(%esi),%esi
		//  list_for_each_entry(temp_lcc_info, &(SV(LogicalChannel_Config)->list),list)//
		{
			temp_lcc_info=list_entry(pos,LogicalChannelConfigInfo,list);
			//fsm_printf("MAC: temp_lcc_info:lcid:%d\n",temp_lcc_info->lcid);
			//fsm_printf("MAC: temp_lcc_info:logicalChannelGroup:%d\n",temp_lcc_info->logicalChannelGroup);
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
    9f30:	8b 50 fc             	mov    -0x4(%eax),%edx
    9f33:	83 fa 03             	cmp    $0x3,%edx
    9f36:	77 28                	ja     9f60 <RefreshBufferStatusForBSR+0x100>
			{
				if(temp->lcid==temp_lcc_info->lcid)
    9f38:	38 58 ef             	cmp    %bl,-0x11(%eax)
    9f3b:	0f 84 87 00 00 00    	je     9fc8 <RefreshBufferStatusForBSR+0x168>
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9f41:	89 c8                	mov    %ecx,%eax
    9f43:	39 c6                	cmp    %eax,%esi
    9f45:	8b 08                	mov    (%eax),%ecx
    9f47:	75 e7                	jne    9f30 <RefreshBufferStatusForBSR+0xd0>
    9f49:	89 fb                	mov    %edi,%ebx
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9f4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9f4e:	8b 13                	mov    (%ebx),%edx
    9f50:	83 c0 05             	add    $0x5,%eax
    9f53:	39 c3                	cmp    %eax,%ebx
    9f55:	74 2f                	je     9f86 <RefreshBufferStatusForBSR+0x126>
    9f57:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    9f5a:	89 d3                	mov    %edx,%ebx
    9f5c:	eb 92                	jmp    9ef0 <RefreshBufferStatusForBSR+0x90>
    9f5e:	66 90                	xchg   %ax,%ax
    9f60:	89 fb                	mov    %edi,%ebx
					break;
				}
			}
			else
			{
				fsm_printf("[UEMAC][refreshBSR]:lc_group error\n");
    9f62:	c7 04 24 98 2b 00 00 	movl   $0x2b98,(%esp)
    9f69:	e8 fc ff ff ff       	call   9f6a <RefreshBufferStatusForBSR+0x10a>
    9f6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9f71:	8b 13                	mov    (%ebx),%edx
    9f73:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    9f79:	89 45 dc             	mov    %eax,-0x24(%ebp)
    9f7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    9f7f:	83 c0 05             	add    $0x5,%eax
    9f82:	39 c3                	cmp    %eax,%ebx
    9f84:	75 d1                	jne    9f57 <RefreshBufferStatusForBSR+0xf7>
    9f86:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    9f89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		temp=list_entry(pos1,MacBufferStatus,list);
		temp_lcc_info=NULL;
		pos=NULL;p=NULL;
		//fsm_printf("[UEMAC][refreshBSR]:temp:lcid:%d\n",temp->lcid);
		list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    9f8c:	31 f6                	xor    %esi,%esi
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
	{
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
    9f8e:	8b 93 54 01 00 00    	mov    0x154(%ebx),%edx
    9f94:	01 42 06             	add    %eax,0x6(%edx)
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
    9f97:	8b bb 54 01 00 00    	mov    0x154(%ebx),%edi
    9f9d:	e8 fc ff ff ff       	call   9f9e <RefreshBufferStatusForBSR+0x13e>
    9fa2:	89 44 b7 0a          	mov    %eax,0xa(%edi,%esi,4)
		if((SV(bsr)->m_bufferStatus[i])!=0)
    9fa6:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    9fac:	8b 54 b0 0a          	mov    0xa(%eax,%esi,4),%edx
    9fb0:	85 d2                	test   %edx,%edx
    9fb2:	74 04                	je     9fb8 <RefreshBufferStatusForBSR+0x158>
			SV(bsr)->m_lcgnum++;
    9fb4:	83 40 02 01          	addl   $0x1,0x2(%eax)
		
		if(flag_find==false)
			//fsm_printf("[UEMAC][refreshBSR]LogicalChannel_Config and  MacBuffer_RLC find ERROR\n");//LogicalChannelConfiglMacBuffer_RLC
		flag_find=false;
	}
	for(i=0;i<LCG;i++)
    9fb8:	83 c6 01             	add    $0x1,%esi
    9fbb:	83 fe 04             	cmp    $0x4,%esi
    9fbe:	74 40                	je     a000 <RefreshBufferStatusForBSR+0x1a0>
	}	
	SV(bsr)->m_rnti=SV(C_RNTI);//
	SV(bsr)->m_lcgnum=0;
	SV(bsr)->m_TotalLcgData=0;		
	//list_for_each_entry(temp, &(SV(MacBuffer_RLC)->list),list)//
	list_for_each_safe(pos1,p1,(&(SV(MacBuffer_RLC)->list)))
    9fc0:	8b 44 b5 e4          	mov    -0x1c(%ebp,%esi,4),%eax
    9fc4:	eb c8                	jmp    9f8e <RefreshBufferStatusForBSR+0x12e>
    9fc6:	66 90                	xchg   %ax,%ax
    9fc8:	89 fb                	mov    %edi,%ebx
			if(temp_lcc_info->logicalChannelGroup>=0 && temp_lcc_info->logicalChannelGroup<4)
			{
				if(temp->lcid==temp_lcc_info->lcid)
				{
					logicalchannelgroup=temp_lcc_info->logicalChannelGroup;
					queue[logicalchannelgroup] =queue[logicalchannelgroup] + temp->RlcRequestparams->retxQueueHeader + temp->RlcRequestparams->retxQueueSize + temp->RlcRequestparams->statusPduHeader \
    9fca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    9fcd:	8b 41 fc             	mov    -0x4(%ecx),%eax
    9fd0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
    9fd4:	8b 48 03             	mov    0x3(%eax),%ecx
    9fd7:	03 48 09             	add    0x9(%eax),%ecx
    9fda:	01 f1                	add    %esi,%ecx
    9fdc:	0f b7 70 11          	movzwl 0x11(%eax),%esi
    9fe0:	01 f1                	add    %esi,%ecx
					+ temp->RlcRequestparams->statusPduSize + temp->RlcRequestparams->txQueueHeader + temp->RlcRequestparams->txQueueSize;
    9fe2:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    9fe6:	0f b7 40 07          	movzwl 0x7(%eax),%eax
    9fea:	01 f1                	add    %esi,%ecx
    9fec:	01 c1                	add    %eax,%ecx
    9fee:	01 4c 95 e4          	add    %ecx,-0x1c(%ebp,%edx,4)
					flag_find=true;
					break;
    9ff2:	e9 54 ff ff ff       	jmp    9f4b <RefreshBufferStatusForBSR+0xeb>
      printk(KERN_INFO"MAC not initialized, BSR deferred\n");
      FOUT;
    }*/
	if(list_empty(&(SV(MacBuffer_RLC)->list)))//MAC0
	{
		SV(bsr)->m_lcgnum=0;
    9ff7:	c7 40 02 00 00 00 00 	movl   $0x0,0x2(%eax)
    9ffe:	66 90                	xchg   %ax,%ax
		SV(bsr)->m_TotalLcgData=SV(bsr)->m_TotalLcgData+queue[i];
		SV(bsr)->m_bufferStatus[i]= BufferSize2BsrSize(queue[i]);//
		if((SV(bsr)->m_bufferStatus[i])!=0)
			SV(bsr)->m_lcgnum++;
	}
}
    a000:	83 c4 24             	add    $0x24,%esp
    a003:	5b                   	pop    %ebx
    a004:	5e                   	pop    %esi
    a005:	5f                   	pop    %edi
    a006:	5d                   	pop    %ebp
    a007:	c3                   	ret    
    a008:	90                   	nop
    a009:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a010 <GetTBsize_Allocation>:
->Output:
->Special:
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
    a010:	55                   	push   %ebp
    a011:	89 e5                	mov    %esp,%ebp
    a013:	83 ec 08             	sub    $0x8,%esp
    a016:	89 5d f8             	mov    %ebx,-0x8(%ebp)
    a019:	89 75 fc             	mov    %esi,-0x4(%ebp)
    a01c:	e8 fc ff ff ff       	call   a01d <GetTBsize_Allocation+0xd>
    a021:	89 c3                	mov    %eax,%ebx
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    a023:	e8 fc ff ff ff       	call   a024 <GetTBsize_Allocation+0x14>
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    a028:	c1 eb 03             	shr    $0x3,%ebx
*******************************
*/
u32 GetTBsize_Allocation(u32 tbsize)
{
	FIN(GetTBsize_Allocation(u32 tbsize));
	SV_PTR_GET(rlc_mac_sv);
    a02b:	89 c6                	mov    %eax,%esi
	RefreshBufferStatusForBSR();
    a02d:	e8 fc ff ff ff       	call   a02e <GetTBsize_Allocation+0x1e>
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
    a032:	8b 86 54 01 00 00    	mov    0x154(%esi),%eax
    a038:	3b 58 06             	cmp    0x6(%eax),%ebx
    a03b:	72 13                	jb     a050 <GetTBsize_Allocation+0x40>
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
	}
	else
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
    a03d:	c6 86 59 01 00 00 00 	movb   $0x0,0x159(%esi)
		FRET((tbsize)/8);
	}
}
    a044:	89 d8                	mov    %ebx,%eax
    a046:	8b 75 fc             	mov    -0x4(%ebp),%esi
    a049:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    a04c:	89 ec                	mov    %ebp,%esp
    a04e:	5d                   	pop    %ebp
    a04f:	c3                   	ret    
	RefreshBufferStatusForBSR();
	//SV(ALLOCATION_RESOURCE_BSR_INFO)=false;
	if((tbsize/8) < (SV(bsr)->m_TotalLcgData)) //BSR
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=true;
		FRET(((tbsize/8)-MAC_BSR_CTL_LENGTH));
    a050:	83 eb 04             	sub    $0x4,%ebx
	{
		//SV(ALLOCATION_RESOURCE_BSR_INFO)=false; //BSR
		SV(m_freshUlBsr)=false;
		FRET((tbsize)/8);
	}
}
    a053:	8b 75 fc             	mov    -0x4(%ebp),%esi
    a056:	89 d8                	mov    %ebx,%eax
    a058:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    a05b:	89 ec                	mov    %ebp,%esp
    a05d:	5d                   	pop    %ebp
    a05e:	c3                   	ret    
    a05f:	90                   	nop

0000a060 <DoRefreshRLCBuffserRequest>:
->Output:SV(MacBuffer_RLC) :MAC
->Special:
*******************************
*/
void DoRefreshRLCBuffserRequest (RlcBufferRequest* params)	//
{
    a060:	55                   	push   %ebp
    a061:	89 e5                	mov    %esp,%ebp
    a063:	57                   	push   %edi
    a064:	56                   	push   %esi
    a065:	53                   	push   %ebx
    a066:	83 ec 14             	sub    $0x14,%esp
    a069:	e8 fc ff ff ff       	call   a06a <DoRefreshRLCBuffserRequest+0xa>
    a06e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos,*p;
	u8 temp_lcid,temp_mac_bufferstatus_lcid;
	FIN(DoRefreshRLCBuffserRequest(RlcBufferRequest* params));
	
	SV_PTR_GET(rlc_mac_sv);
    a071:	e8 fc ff ff ff       	call   a072 <DoRefreshRLCBuffserRequest+0x12>
    a076:	89 45 f0             	mov    %eax,-0x10(%ebp)
	MacBufferStatus *temp_mac_bufferstatus=NULL;
	MacBufferStatus *temp_mac_findno=NULL;	
	bool flag=false;

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
    a079:	e8 fc ff ff ff       	call   a07a <DoRefreshRLCBuffserRequest+0x1a>
	if (SV(bsr)->m_lcgnum==0)
    a07e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a081:	8b 82 54 01 00 00    	mov    0x154(%edx),%eax
    a087:	8b 48 02             	mov    0x2(%eax),%ecx
    a08a:	85 c9                	test   %ecx,%ecx
    a08c:	75 07                	jne    a095 <DoRefreshRLCBuffserRequest+0x35>
		SV(LCGZeroToData)=true;
    a08e:	c6 82 58 01 00 00 01 	movb   $0x1,0x158(%edx)
	SV(DATA_WAIT_ALLOCATION)=true;
    a095:	8b 45 f0             	mov    -0x10(%ebp),%eax
	list_for_each_safe(pos,p,&(RLChead->list))//
    a098:	8b 55 e4             	mov    -0x1c(%ebp),%edx

	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
    a09b:	c6 80 5a 01 00 00 01 	movb   $0x1,0x15a(%eax)
	list_for_each_safe(pos,p,&(RLChead->list))//
    a0a2:	8b 42 13             	mov    0x13(%edx),%eax
    a0a5:	83 c2 13             	add    $0x13,%edx
    a0a8:	89 55 e8             	mov    %edx,-0x18(%ebp)
    a0ab:	39 d0                	cmp    %edx,%eax
    a0ad:	8b 38                	mov    (%eax),%edi
    a0af:	0f 84 ea 00 00 00    	je     a19f <DoRefreshRLCBuffserRequest+0x13f>
    a0b5:	8d 76 00             	lea    0x0(%esi),%esi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    a0b8:	8d 48 ed             	lea    -0x13(%eax),%ecx
		temp_lcid=temp->lcid;
    a0bb:	0f b6 58 ef          	movzbl -0x11(%eax),%ebx
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    a0bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
	{
		temp=list_entry(pos,RlcBufferRequest,list);
    a0c2:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		temp_lcid=temp->lcid;
		//length_rlc_request++;
		temp_mac_bufferstatus=NULL;
		list_for_each_entry(temp_mac_bufferstatus, &(SV(MacBuffer_RLC)->list),list)//
    a0c5:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a0cb:	8b 42 05             	mov    0x5(%edx),%eax
    a0ce:	8d 70 fb             	lea    -0x5(%eax),%esi
    a0d1:	39 f2                	cmp    %esi,%edx
    a0d3:	75 0d                	jne    a0e2 <DoRefreshRLCBuffserRequest+0x82>
    a0d5:	eb 39                	jmp    a110 <DoRefreshRLCBuffserRequest+0xb0>
    a0d7:	90                   	nop
    a0d8:	8b 46 05             	mov    0x5(%esi),%eax
    a0db:	8d 70 fb             	lea    -0x5(%eax),%esi
    a0de:	39 f2                	cmp    %esi,%edx
    a0e0:	74 2e                	je     a110 <DoRefreshRLCBuffserRequest+0xb0>
		{
			temp_mac_bufferstatus_lcid=temp_mac_bufferstatus->lcid;
			if(temp_lcid==temp_mac_bufferstatus_lcid)
    a0e2:	3a 58 fb             	cmp    -0x5(%eax),%bl
    a0e5:	75 f1                	jne    a0d8 <DoRefreshRLCBuffserRequest+0x78>
			{
				temp_mac_bufferstatus->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a0e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a0ea:	e8 fc ff ff ff       	call   a0eb <DoRefreshRLCBuffserRequest+0x8b>
    a0ef:	89 46 01             	mov    %eax,0x1(%esi)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    a0f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a0f5:	39 7d e8             	cmp    %edi,-0x18(%ebp)
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
		}
		flag=false;
		SV(m_freshUlBsr)=true;
    a0f8:	c6 80 59 01 00 00 01 	movb   $0x1,0x159(%eax)
	//int length_rlc_request=0;
	RefreshBufferStatusForBSR();
	if (SV(bsr)->m_lcgnum==0)
		SV(LCGZeroToData)=true;
	SV(DATA_WAIT_ALLOCATION)=true;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a0ff:	8b 17                	mov    (%edi),%edx
    a101:	74 65                	je     a168 <DoRefreshRLCBuffserRequest+0x108>
    a103:	89 f8                	mov    %edi,%eax
    a105:	89 d7                	mov    %edx,%edi
    a107:	eb af                	jmp    a0b8 <DoRefreshRLCBuffserRequest+0x58>
    a109:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a110:	b8 0d 00 00 00       	mov    $0xd,%eax
    a115:	e8 fc ff ff ff       	call   a116 <DoRefreshRLCBuffserRequest+0xb6>
			while(temp_mac_findno==0)//
    a11a:	85 c0                	test   %eax,%eax
				break;
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a11c:	89 c6                	mov    %eax,%esi
			while(temp_mac_findno==0)//
    a11e:	75 10                	jne    a130 <DoRefreshRLCBuffserRequest+0xd0>
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a120:	b8 0d 00 00 00       	mov    $0xd,%eax
    a125:	e8 fc ff ff ff       	call   a126 <DoRefreshRLCBuffserRequest+0xc6>
			}
		}
		if(flag==false)//
		{
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
    a12a:	85 c0                	test   %eax,%eax
    a12c:	74 f2                	je     a120 <DoRefreshRLCBuffserRequest+0xc0>
    a12e:	89 c6                	mov    %eax,%esi
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a130:	8b 45 ec             	mov    -0x14(%ebp),%eax
			temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			while(temp_mac_findno==0)//
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
    a133:	8d 56 05             	lea    0x5(%esi),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a136:	89 56 05             	mov    %edx,0x5(%esi)
	list->prev = list;
    a139:	89 56 09             	mov    %edx,0x9(%esi)
			temp_mac_findno->lcid=temp_lcid;
    a13c:	88 1e                	mov    %bl,(%esi)
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a13e:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a141:	e8 fc ff ff ff       	call   a142 <DoRefreshRLCBuffserRequest+0xe2>
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    a146:	8b 4d f0             	mov    -0x10(%ebp),%ecx
			{
				temp_mac_findno=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
			}
			INIT_LIST_HEAD(&(temp_mac_findno->list));
			temp_mac_findno->lcid=temp_lcid;
			temp_mac_findno->RlcRequestparams=Rlc_MacRequest_copy(temp);
    a149:	89 46 01             	mov    %eax,0x1(%esi)
			list_add_tail(&(temp_mac_findno->list), &(SV(MacBuffer_RLC)->list));
    a14c:	8b 81 48 01 00 00    	mov    0x148(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a152:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a155:	8b 48 09             	mov    0x9(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a158:	89 50 09             	mov    %edx,0x9(%eax)
    a15b:	83 c0 05             	add    $0x5,%eax
    a15e:	89 46 05             	mov    %eax,0x5(%esi)
	new->next = next;
	new->prev = prev;
    a161:	89 4e 09             	mov    %ecx,0x9(%esi)
	prev->next = new;
    a164:	89 11                	mov    %edx,(%ecx)
    a166:	eb 8a                	jmp    a0f2 <DoRefreshRLCBuffserRequest+0x92>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a168:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a16b:	8b 50 13             	mov    0x13(%eax),%edx
    a16e:	3b 55 e8             	cmp    -0x18(%ebp),%edx
    a171:	8b 1a                	mov    (%edx),%ebx
    a173:	74 2a                	je     a19f <DoRefreshRLCBuffserRequest+0x13f>
    a175:	89 d9                	mov    %ebx,%ecx
    a177:	8b 75 e8             	mov    -0x18(%ebp),%esi
    a17a:	eb 08                	jmp    a184 <DoRefreshRLCBuffserRequest+0x124>
    a17c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a180:	89 da                	mov    %ebx,%edx
    a182:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a184:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
    a187:	8d 42 ed             	lea    -0x13(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a18a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a18d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a18f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a191:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp);
    a194:	e8 fc ff ff ff       	call   a195 <DoRefreshRLCBuffserRequest+0x135>
		}
		flag=false;
		SV(m_freshUlBsr)=true;
	}
	temp=NULL;
	list_for_each_safe(pos,p,&(RLChead->list))//
    a199:	39 f3                	cmp    %esi,%ebx
    a19b:	8b 0b                	mov    (%ebx),%ecx
    a19d:	75 e1                	jne    a180 <DoRefreshRLCBuffserRequest+0x120>
	{
		temp=list_entry(pos,RlcBufferRequest,list);
		list_del_init(&(temp->list));
		fsm_mem_free(temp);
	}
	fsm_mem_free(RLChead);
    a19f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    a1a2:	e8 fc ff ff ff       	call   a1a3 <DoRefreshRLCBuffserRequest+0x143>
	FOUT;
}
    a1a7:	83 c4 14             	add    $0x14,%esp
    a1aa:	5b                   	pop    %ebx
    a1ab:	5e                   	pop    %esi
    a1ac:	5f                   	pop    %edi
    a1ad:	5d                   	pop    %ebp
    a1ae:	c3                   	ret    
    a1af:	90                   	nop

0000a1b0 <LogicalChannel_ConfigInfo_Rank_Priority>:
->Output:LogicalChannelConfigInfo 
->Special:
*******************************
*/
LogicalChannelConfigInfo* LogicalChannel_ConfigInfo_Rank_Priority()
{
    a1b0:	55                   	push   %ebp
    a1b1:	89 e5                	mov    %esp,%ebp
    a1b3:	57                   	push   %edi
    a1b4:	56                   	push   %esi
    a1b5:	53                   	push   %ebx
    a1b6:	83 ec 0c             	sub    $0xc,%esp
    a1b9:	e8 fc ff ff ff       	call   a1ba <LogicalChannel_ConfigInfo_Rank_Priority+0xa>
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
    a1be:	e8 fc ff ff ff       	call   a1bf <LogicalChannel_ConfigInfo_Rank_Priority+0xf>
    a1c3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a1c6:	b8 19 00 00 00       	mov    $0x19,%eax
    a1cb:	e8 fc ff ff ff       	call   a1cc <LogicalChannel_ConfigInfo_Rank_Priority+0x1c>
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a1d0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a1d3:	8d 50 11             	lea    0x11(%eax),%edx
{
	FIN(LogicalChannel_ConfigInfo_Rank_Priority());
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *lcc_info_priority=NULL,*temp=NULL,*temp_logicalChannel=NULL;

	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a1d6:	89 c3                	mov    %eax,%ebx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a1d8:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a1db:	89 50 15             	mov    %edx,0x15(%eax)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a1de:	8b 81 40 01 00 00    	mov    0x140(%ecx),%eax
	lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	/*while(lcc_info_priority==0)//
	{
		lcc_info_priority=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
    a1e4:	89 55 ec             	mov    %edx,-0x14(%ebp)
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a1e7:	8b 70 11             	mov    0x11(%eax),%esi
    a1ea:	83 ee 11             	sub    $0x11,%esi
    a1ed:	39 f0                	cmp    %esi,%eax
    a1ef:	0f 84 7f 00 00 00    	je     a274 <LogicalChannel_ConfigInfo_Rank_Priority+0xc4>
    a1f5:	8d 76 00             	lea    0x0(%esi),%esi
	{
		next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
    a1f8:	b8 19 00 00 00       	mov    $0x19,%eax
    a1fd:	e8 fc ff ff ff       	call   a1fe <LogicalChannel_ConfigInfo_Rank_Priority+0x4e>
		/*while(next_node==0)//
		{
			next_node=(LogicalChannelConfigInfo *)fsm_mem_alloc(sizeof(LogicalChannelConfigInfo ));
		}*/
		next_node->lcid=temp->lcid;
    a202:	0f b6 16             	movzbl (%esi),%edx
    a205:	88 10                	mov    %dl,(%eax)
		next_node->priority=temp->priority;
    a207:	8b 7e 01             	mov    0x1(%esi),%edi
    a20a:	89 78 01             	mov    %edi,0x1(%eax)
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
    a20d:	8b 56 05             	mov    0x5(%esi),%edx
    a210:	89 50 05             	mov    %edx,0x5(%eax)
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
    a213:	8b 56 09             	mov    0x9(%esi),%edx
    a216:	89 50 09             	mov    %edx,0x9(%eax)
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
    a219:	8b 56 0d             	mov    0xd(%esi),%edx
    a21c:	89 50 0d             	mov    %edx,0xd(%eax)
		INIT_LIST_HEAD(&(next_node->list));
    a21f:	8d 50 11             	lea    0x11(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a222:	89 50 11             	mov    %edx,0x11(%eax)
	list->prev = list;
    a225:	89 50 15             	mov    %edx,0x15(%eax)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    a228:	8b 4b 11             	mov    0x11(%ebx),%ecx
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a22b:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
		next_node->lcid=temp->lcid;
		next_node->priority=temp->priority;
		next_node->prioritizedBitRateKbps=temp->prioritizedBitRateKbps;
		next_node->bucketSizeDurationMs=temp->bucketSizeDurationMs;
		next_node->logicalChannelGroup=temp->logicalChannelGroup;
		INIT_LIST_HEAD(&(next_node->list));
    a22e:	89 55 f0             	mov    %edx,-0x10(%ebp)
		/* if(next_node->prioritizedBitRateKbps==-1)//
			list_add(&(next_node->list), &(lcc_info_priority->list));//
		else
		{*/
			if (list_empty(&(lcc_info_priority->list)))
    a231:	74 4d                	je     a280 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			else
			{
				flag_add=false;
				list_for_each_entry(temp_next, &(lcc_info_priority->list),list)//
    a233:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a236:	39 d3                	cmp    %edx,%ebx
    a238:	75 10                	jne    a24a <LogicalChannel_ConfigInfo_Rank_Priority+0x9a>
    a23a:	eb 44                	jmp    a280 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
    a23c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a240:	8b 4a 11             	mov    0x11(%edx),%ecx
    a243:	8d 51 ef             	lea    -0x11(%ecx),%edx
    a246:	39 d3                	cmp    %edx,%ebx
    a248:	74 36                	je     a280 <LogicalChannel_ConfigInfo_Rank_Priority+0xd0>
				{
					//  if(temp_next->prioritizedBitRateKbps==-1)
						//  continue;
					if ((next_node->priority) <= (temp_next->priority))
    a24a:	3b 79 f0             	cmp    -0x10(%ecx),%edi
    a24d:	7f f1                	jg     a240 <LogicalChannel_ConfigInfo_Rank_Priority+0x90>
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a24f:	8b 7d f0             	mov    -0x10(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a252:	8b 4a 15             	mov    0x15(%edx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a255:	89 7a 15             	mov    %edi,0x15(%edx)
					{
						list_add_tail(&(next_node->list), &(temp_next->list));
    a258:	83 c2 11             	add    $0x11,%edx
    a25b:	89 50 11             	mov    %edx,0x11(%eax)
	new->next = next;
	new->prev = prev;
    a25e:	89 48 15             	mov    %ecx,0x15(%eax)
	prev->next = new;
    a261:	89 39                	mov    %edi,(%ecx)
	}*/
	INIT_LIST_HEAD(&(lcc_info_priority->list));
	LogicalChannelConfigInfo *next_node=NULL;
	LogicalChannelConfigInfo *temp_next=NULL;
	bool flag_add=false;
	list_for_each_entry(temp, &(SV(LogicalChannel_Config)->list),list)//
    a263:	8b 76 11             	mov    0x11(%esi),%esi
    a266:	8b 45 e8             	mov    -0x18(%ebp),%eax
    a269:	83 ee 11             	sub    $0x11,%esi
    a26c:	39 b0 40 01 00 00    	cmp    %esi,0x140(%eax)
    a272:	75 84                	jne    a1f8 <LogicalChannel_ConfigInfo_Rank_Priority+0x48>
					list_add_tail(&(next_node->list), &(lcc_info_priority->list));
			}

	}
	FRET(lcc_info_priority);
}
    a274:	83 c4 0c             	add    $0xc,%esp
    a277:	89 d8                	mov    %ebx,%eax
    a279:	5b                   	pop    %ebx
    a27a:	5e                   	pop    %esi
    a27b:	5f                   	pop    %edi
    a27c:	5d                   	pop    %ebp
    a27d:	c3                   	ret    
    a27e:	66 90                	xchg   %ax,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a280:	8b 53 15             	mov    0x15(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a283:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	new->next = next;
    a286:	8b 7d ec             	mov    -0x14(%ebp),%edi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a289:	89 4b 15             	mov    %ecx,0x15(%ebx)
	new->next = next;
    a28c:	89 78 11             	mov    %edi,0x11(%eax)
	new->prev = prev;
    a28f:	89 50 15             	mov    %edx,0x15(%eax)
	prev->next = new;
    a292:	89 0a                	mov    %ecx,(%edx)
    a294:	eb cd                	jmp    a263 <LogicalChannel_ConfigInfo_Rank_Priority+0xb3>
    a296:	8d 76 00             	lea    0x0(%esi),%esi
    a299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a2a0 <PrioritySort>:
->Output:MacBufferStatus *:SV(MacBuffer_RLC)
->Special:
*******************************
*/
MacBufferStatus* PrioritySort(void)
{
    a2a0:	55                   	push   %ebp
    a2a1:	89 e5                	mov    %esp,%ebp
    a2a3:	57                   	push   %edi
    a2a4:	56                   	push   %esi
    a2a5:	53                   	push   %ebx
    a2a6:	83 ec 14             	sub    $0x14,%esp
    a2a9:	e8 fc ff ff ff       	call   a2aa <PrioritySort+0xa>
	u8 temp_Bj_lcid;
	MacBufferStatus *temp_node;
	struct list_head *pos,*p;

	FIN(PrioritySort(void));
	SV_PTR_GET(rlc_mac_sv);
    a2ae:	e8 fc ff ff ff       	call   a2af <PrioritySort+0xf>
    a2b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	LogicalChannelConfigInfo *Priority_logicalChannel=NULL,*temp_logicalChannel=NULL;
	MacBufferStatus *PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus)),*temp_mbs=NULL;
    a2b6:	b8 0d 00 00 00       	mov    $0xd,%eax
    a2bb:	e8 fc ff ff ff       	call   a2bc <PrioritySort+0x1c>
    a2c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a2c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
	/*while(PriorityMacBufferStatus==0)//
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
    a2c6:	83 c0 05             	add    $0x5,%eax
    a2c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    a2cc:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    a2cf:	89 42 09             	mov    %eax,0x9(%edx)
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a2d2:	e8 fc ff ff ff       	call   a2d3 <PrioritySort+0x33>
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a2d7:	8b 50 11             	mov    0x11(%eax),%edx
	{
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
    a2da:	89 45 f0             	mov    %eax,-0x10(%ebp)
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a2dd:	8d 72 ef             	lea    -0x11(%edx),%esi
    a2e0:	39 f0                	cmp    %esi,%eax
    a2e2:	74 7b                	je     a35f <PrioritySort+0xbf>
    a2e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a2e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
	{
		temp_Bj_lcid=temp_logicalChannel->lcid;
    a2eb:	0f b6 0e             	movzbl (%esi),%ecx
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
    a2ee:	8b 90 48 01 00 00    	mov    0x148(%eax),%edx
    a2f4:	8b 42 05             	mov    0x5(%edx),%eax
    a2f7:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a2fa:	39 da                	cmp    %ebx,%edx
    a2fc:	75 0c                	jne    a30a <PrioritySort+0x6a>
    a2fe:	eb 4e                	jmp    a34e <PrioritySort+0xae>
    a300:	8b 43 05             	mov    0x5(%ebx),%eax
    a303:	8d 58 fb             	lea    -0x5(%eax),%ebx
    a306:	39 da                	cmp    %ebx,%edx
    a308:	74 44                	je     a34e <PrioritySort+0xae>
		{
			if(temp_Bj_lcid==temp_node->lcid)
    a30a:	38 48 fb             	cmp    %cl,-0x5(%eax)
    a30d:	75 f1                	jne    a300 <PrioritySort+0x60>
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a30f:	b8 0d 00 00 00       	mov    $0xd,%eax
    a314:	e8 fc ff ff ff       	call   a315 <PrioritySort+0x75>
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
    a319:	8d 50 05             	lea    0x5(%eax),%edx
		temp_Bj_lcid=temp_logicalChannel->lcid;
		list_for_each_entry(temp_node, (&(SV(MacBuffer_RLC)->list)),list)//
		{
			if(temp_Bj_lcid==temp_node->lcid)
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    a31c:	89 c7                	mov    %eax,%edi
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a31e:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a321:	89 50 09             	mov    %edx,0x9(%eax)
			/*while(temp_mbs==0)//
			{
				temp_mbs=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
				}*/
				INIT_LIST_HEAD(&(temp_mbs->list));
				temp_mbs->lcid=temp_node->lcid;
    a324:	0f b6 03             	movzbl (%ebx),%eax
    a327:	88 07                	mov    %al,(%edi)
				temp_mbs->RlcRequestparams=Mac_MacRequest_copy(temp_node->RlcRequestparams);
    a329:	8b 43 01             	mov    0x1(%ebx),%eax
    a32c:	89 55 e0             	mov    %edx,-0x20(%ebp)
    a32f:	e8 fc ff ff ff       	call   a330 <PrioritySort+0x90>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a334:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    a337:	89 47 01             	mov    %eax,0x1(%edi)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a33a:	8b 55 e0             	mov    -0x20(%ebp),%edx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a33d:	8b 41 09             	mov    0x9(%ecx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a340:	89 51 09             	mov    %edx,0x9(%ecx)
	new->next = next;
    a343:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
	new->prev = prev;
    a346:	89 47 09             	mov    %eax,0x9(%edi)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    a349:	89 4f 05             	mov    %ecx,0x5(%edi)
	new->prev = prev;
	prev->next = new;
    a34c:	89 10                	mov    %edx,(%eax)
		PriorityMacBufferStatus=(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
	}*/
	
	INIT_LIST_HEAD(&(PriorityMacBufferStatus->list));	
	Priority_logicalChannel=LogicalChannel_ConfigInfo_Rank_Priority();
	list_for_each_entry(temp_logicalChannel, &(Priority_logicalChannel->list),list)//
    a34e:	8b 76 11             	mov    0x11(%esi),%esi
    a351:	83 ee 11             	sub    $0x11,%esi
    a354:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a357:	75 8f                	jne    a2e8 <PrioritySort+0x48>
    a359:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a35c:	8b 50 11             	mov    0x11(%eax),%edx
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a35f:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a362:	8b 1a                	mov    (%edx),%ebx
    a364:	83 c6 11             	add    $0x11,%esi
    a367:	39 f2                	cmp    %esi,%edx
    a369:	89 d9                	mov    %ebx,%ecx
    a36b:	75 07                	jne    a374 <PrioritySort+0xd4>
    a36d:	eb 20                	jmp    a38f <PrioritySort+0xef>
    a36f:	90                   	nop
    a370:	89 da                	mov    %ebx,%edx
    a372:	89 cb                	mov    %ecx,%ebx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    a374:	8b 7a 04             	mov    0x4(%edx),%edi
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
    a377:	8d 42 ef             	lea    -0x11(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    a37a:	89 79 04             	mov    %edi,0x4(%ecx)
	prev->next = next;
    a37d:	89 0f                	mov    %ecx,(%edi)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a37f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    a381:	89 52 04             	mov    %edx,0x4(%edx)
		fsm_mem_free(temp_logicalChannel);//
    a384:	e8 fc ff ff ff       	call   a385 <PrioritySort+0xe5>
				break;
			}
		}
	}
	temp_logicalChannel=NULL;
	list_for_each_safe(pos,p,&(Priority_logicalChannel->list))//
    a389:	39 de                	cmp    %ebx,%esi
    a38b:	8b 0b                	mov    (%ebx),%ecx
    a38d:	75 e1                	jne    a370 <PrioritySort+0xd0>
	{
		temp_logicalChannel=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_logicalChannel->list));//
		fsm_mem_free(temp_logicalChannel);//
	}
	fsm_mem_free(Priority_logicalChannel);
    a38f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    a392:	e8 fc ff ff ff       	call   a393 <PrioritySort+0xf3>
	FRET(PriorityMacBufferStatus);
}
    a397:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a39a:	83 c4 14             	add    $0x14,%esp
    a39d:	5b                   	pop    %ebx
    a39e:	5e                   	pop    %esi
    a39f:	5f                   	pop    %edi
    a3a0:	5d                   	pop    %ebp
    a3a1:	c3                   	ret    
    a3a2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    a3a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a3b0 <DoProduceBsr_LCGZeroToData>:
->Output: SV(Regularbsr) :BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
    a3b0:	55                   	push   %ebp
    a3b1:	89 e5                	mov    %esp,%ebp
    a3b3:	53                   	push   %ebx
    a3b4:	e8 fc ff ff ff       	call   a3b5 <DoProduceBsr_LCGZeroToData+0x5>
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a3b9:	e8 fc ff ff ff       	call   a3ba <DoProduceBsr_LCGZeroToData+0xa>
	if(SV(LCGZeroToData) == true)
    a3be:	80 b8 58 01 00 00 00 	cmpb   $0x0,0x158(%eax)
*******************************
*/
void DoProduceBsr_LCGZeroToData(void)
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
    a3c5:	89 c3                	mov    %eax,%ebx
	if(SV(LCGZeroToData) == true)
    a3c7:	75 0f                	jne    a3d8 <DoProduceBsr_LCGZeroToData+0x28>
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a3c9:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a3d0:	5b                   	pop    %ebx
    a3d1:	5d                   	pop    %ebp
    a3d2:	c3                   	ret    
    a3d3:	90                   	nop
    a3d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_LCGZeroToData(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(LCGZeroToData) == true)
	{
		RefreshBufferStatusForBSR();
    a3d8:	e8 fc ff ff ff       	call   a3d9 <DoProduceBsr_LCGZeroToData+0x29>
		if (SV(bsr)!=NULL)
    a3dd:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a3e3:	85 c0                	test   %eax,%eax
    a3e5:	74 e2                	je     a3c9 <DoProduceBsr_LCGZeroToData+0x19>
		{
			//fsm_printf("[UEMAC][BSR]have BSR\n");
			if(SV(Regularbsr)!=NULL)
    a3e7:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a3ed:	85 c0                	test   %eax,%eax
    a3ef:	74 0f                	je     a400 <DoProduceBsr_LCGZeroToData+0x50>
			{
				fsm_mem_free(SV(Regularbsr));//Regularbsr
    a3f1:	e8 fc ff ff ff       	call   a3f2 <DoProduceBsr_LCGZeroToData+0x42>
				SV(Regularbsr)=NULL;
    a3f6:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a3fd:	00 00 00 
			}
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a400:	e8 fc ff ff ff       	call   a401 <DoProduceBsr_LCGZeroToData+0x51>
    a405:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
			if((SV(Regularbsr)->m_lcgnum) >1)
    a40b:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a40f:	76 1f                	jbe    a430 <DoProduceBsr_LCGZeroToData+0x80>
			{
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a411:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a418:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a41f:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR short:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
		}
	}
	SV(LCGZeroToData)=false;	
    a425:	c6 83 58 01 00 00 00 	movb   $0x0,0x158(%ebx)
	FOUT;
}
    a42c:	5b                   	pop    %ebx
    a42d:	5d                   	pop    %ebp
    a42e:	c3                   	ret    
    a42f:	90                   	nop
				SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
				//fsm_printf("[UEMAC][BSR]MAC BSR long:%d\n",SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID);
			}
			else if((SV(Regularbsr)->m_lcgnum) ==1)
    a430:	75 97                	jne    a3c9 <DoProduceBsr_LCGZeroToData+0x19>
			{
				SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a432:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a439:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
				SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a440:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
    a446:	eb 81                	jmp    a3c9 <DoProduceBsr_LCGZeroToData+0x19>
    a448:	90                   	nop
    a449:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a450 <DoProduceBsr_PeriodicBSRTimer>:
->Output: SV(Periodicbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
    a450:	55                   	push   %ebp
    a451:	89 e5                	mov    %esp,%ebp
    a453:	53                   	push   %ebx
    a454:	e8 fc ff ff ff       	call   a455 <DoProduceBsr_PeriodicBSRTimer+0x5>
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a459:	e8 fc ff ff ff       	call   a45a <DoProduceBsr_PeriodicBSRTimer+0xa>
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a45e:	80 b8 59 01 00 00 00 	cmpb   $0x0,0x159(%eax)
*******************************
*/
void DoProduceBsr_PeriodicBSRTimer(void)
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a465:	89 c3                	mov    %eax,%ebx
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
    a467:	75 07                	jne    a470 <DoProduceBsr_PeriodicBSRTimer+0x20>
			}
		}
		SV(m_freshUlBsr)=false;
	}
	FOUT;
}
    a469:	5b                   	pop    %ebx
    a46a:	5d                   	pop    %ebp
    a46b:	c3                   	ret    
    a46c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	FIN(DoProduceBsr_PeriodicBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
	if(SV(m_freshUlBsr) ==true)// BSRNS31ms
	{
		RefreshBufferStatusForBSR ();
    a470:	e8 fc ff ff ff       	call   a471 <DoProduceBsr_PeriodicBSRTimer+0x21>
		if (SV(bsr)!=NULL)
    a475:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a47b:	85 c0                	test   %eax,%eax
    a47d:	74 34                	je     a4b3 <DoProduceBsr_PeriodicBSRTimer+0x63>
		{
			if(SV(Periodicbsr)==NULL)
    a47f:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a485:	85 c0                	test   %eax,%eax
    a487:	74 05                	je     a48e <DoProduceBsr_PeriodicBSRTimer+0x3e>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();
			else
			{
				fsm_mem_free(SV(Periodicbsr));//Regularbsr
    a489:	e8 fc ff ff ff       	call   a48a <DoProduceBsr_PeriodicBSRTimer+0x3a>
				SV(Periodicbsr)=MacBufferStatus_BSR_Info_copy();//
    a48e:	e8 fc ff ff ff       	call   a48f <DoProduceBsr_PeriodicBSRTimer+0x3f>
    a493:	89 83 50 01 00 00    	mov    %eax,0x150(%ebx)
			}
			// if(SV(ALLOCATION_RESOURCE_BSR_INFO)==true)
			// {
			if((SV(Periodicbsr)->m_lcgnum) >1)
    a499:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a49d:	76 21                	jbe    a4c0 <DoProduceBsr_PeriodicBSRTimer+0x70>
			{
				SV(MAC_CE_Tags)[period_longBSR_CE].addinPDU_flag=true;
    a49f:	c6 83 dc 01 00 00 01 	movb   $0x1,0x1dc(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
    a4a6:	c6 83 dd 01 00 00 1e 	movb   $0x1e,0x1dd(%ebx)
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a4ad:	89 83 e0 01 00 00    	mov    %eax,0x1e0(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
		}
		SV(m_freshUlBsr)=false;
    a4b3:	c6 83 59 01 00 00 00 	movb   $0x0,0x159(%ebx)
	}
	FOUT;
}
    a4ba:	5b                   	pop    %ebx
    a4bb:	5d                   	pop    %ebp
    a4bc:	c3                   	ret    
    a4bd:	8d 76 00             	lea    0x0(%esi),%esi
				SV(MAC_CE_Tags)[period_longBSR_CE].LCID=LONG_BSR_LCID;
				SV(MAC_CE_Tags)[period_longBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
			}
			else
			{
				SV(MAC_CE_Tags)[period_shortBSR_CE].addinPDU_flag=true;
    a4c0:	c6 83 d4 01 00 00 01 	movb   $0x1,0x1d4(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a4c7:	c6 83 d5 01 00 00 1d 	movb   $0x1d,0x1d5(%ebx)
				SV(MAC_CE_Tags)[period_shortBSR_CE].MAC_CE_ptr=(void *)SV(Periodicbsr);
    a4ce:	89 83 d8 01 00 00    	mov    %eax,0x1d8(%ebx)
    a4d4:	eb dd                	jmp    a4b3 <DoProduceBsr_PeriodicBSRTimer+0x63>
    a4d6:	8d 76 00             	lea    0x0(%esi),%esi
    a4d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a4e0 <DoProduceBsr_RetxBSRTimer>:
->Output: SV(Regularbsr):BSRSV(MAC_CE_Tags):
->Special:
*******************************
*/
void DoProduceBsr_RetxBSRTimer(void)
{
    a4e0:	55                   	push   %ebp
    a4e1:	89 e5                	mov    %esp,%ebp
    a4e3:	53                   	push   %ebx
    a4e4:	e8 fc ff ff ff       	call   a4e5 <DoProduceBsr_RetxBSRTimer+0x5>
	FIN(DoProduceBsr_RetxBSRTimer(void));
	SV_PTR_GET(rlc_mac_sv);
    a4e9:	e8 fc ff ff ff       	call   a4ea <DoProduceBsr_RetxBSRTimer+0xa>
    a4ee:	89 c3                	mov    %eax,%ebx
	if(list_empty((&(SV(MacBuffer_RLC)->list))))//BSRTTI BSR
    a4f0:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    a4f6:	8d 50 05             	lea    0x5(%eax),%edx
    a4f9:	39 50 05             	cmp    %edx,0x5(%eax)
    a4fc:	74 43                	je     a541 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		FOUT;
	}
	RefreshBufferStatusForBSR ();
    a4fe:	e8 fc ff ff ff       	call   a4ff <DoProduceBsr_RetxBSRTimer+0x1f>
	if (SV(bsr)!=NULL)
    a503:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a509:	85 c0                	test   %eax,%eax
    a50b:	74 34                	je     a541 <DoProduceBsr_RetxBSRTimer+0x61>
	{
		if(SV(Regularbsr)==NULL)//Regularbsr
    a50d:	8b 83 4c 01 00 00    	mov    0x14c(%ebx),%eax
    a513:	85 c0                	test   %eax,%eax
    a515:	74 05                	je     a51c <DoProduceBsr_RetxBSRTimer+0x3c>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();
		else
		{
			fsm_mem_free(SV(Regularbsr));//Regularbsr
    a517:	e8 fc ff ff ff       	call   a518 <DoProduceBsr_RetxBSRTimer+0x38>
			SV(Regularbsr)=MacBufferStatus_BSR_Info_copy();//
    a51c:	e8 fc ff ff ff       	call   a51d <DoProduceBsr_RetxBSRTimer+0x3d>
    a521:	89 83 4c 01 00 00    	mov    %eax,0x14c(%ebx)
		}
		if((SV(Regularbsr)->m_lcgnum) >1)
    a527:	83 78 02 01          	cmpl   $0x1,0x2(%eax)
    a52b:	76 1b                	jbe    a548 <DoProduceBsr_RetxBSRTimer+0x68>
		{
			SV(MAC_CE_Tags)[regular_longBSR_CE].addinPDU_flag=true;
    a52d:	c6 83 c4 01 00 00 01 	movb   $0x1,0x1c4(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
    a534:	c6 83 c5 01 00 00 1e 	movb   $0x1e,0x1c5(%ebx)
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a53b:	89 83 c8 01 00 00    	mov    %eax,0x1c8(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
	}
	FOUT;
}
    a541:	5b                   	pop    %ebx
    a542:	5d                   	pop    %ebp
    a543:	c3                   	ret    
    a544:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			SV(MAC_CE_Tags)[regular_longBSR_CE].LCID=LONG_BSR_LCID;
			SV(MAC_CE_Tags)[regular_longBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
		}
		else
		{
			SV(MAC_CE_Tags)[regular_shortBSR_CE].addinPDU_flag=true;
    a548:	c6 83 bc 01 00 00 01 	movb   $0x1,0x1bc(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].LCID=SHORT_BSR_LCID;
    a54f:	c6 83 bd 01 00 00 1d 	movb   $0x1d,0x1bd(%ebx)
			SV(MAC_CE_Tags)[regular_shortBSR_CE].MAC_CE_ptr=(void *)SV(Regularbsr);
    a556:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
		}
	}
	FOUT;
}
    a55c:	5b                   	pop    %ebx
    a55d:	5d                   	pop    %ebp
    a55e:	c3                   	ret    
    a55f:	90                   	nop

0000a560 <Free_Bsr_Info>:
->Output: 
->Special:
*******************************
*/
void Free_Bsr_Info(void)
{
    a560:	55                   	push   %ebp
    a561:	89 e5                	mov    %esp,%ebp
    a563:	53                   	push   %ebx
    a564:	e8 fc ff ff ff       	call   a565 <Free_Bsr_Info+0x5>
	FIN(Free_Bsr_Info(void));
	SV_PTR_GET(rlc_mac_sv);
    a569:	e8 fc ff ff ff       	call   a56a <Free_Bsr_Info+0xa>
    a56e:	89 c3                	mov    %eax,%ebx
	if(SV(Regularbsr)!=NULL)
    a570:	8b 80 4c 01 00 00    	mov    0x14c(%eax),%eax
    a576:	85 c0                	test   %eax,%eax
    a578:	74 0f                	je     a589 <Free_Bsr_Info+0x29>
	{
		fsm_mem_free(SV(Regularbsr));
    a57a:	e8 fc ff ff ff       	call   a57b <Free_Bsr_Info+0x1b>
		SV(Regularbsr)=NULL;
    a57f:	c7 83 4c 01 00 00 00 	movl   $0x0,0x14c(%ebx)
    a586:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    a589:	8b 83 50 01 00 00    	mov    0x150(%ebx),%eax
    a58f:	85 c0                	test   %eax,%eax
    a591:	74 0f                	je     a5a2 <Free_Bsr_Info+0x42>
	{
		fsm_mem_free(SV(Periodicbsr));
    a593:	e8 fc ff ff ff       	call   a594 <Free_Bsr_Info+0x34>
		SV(Periodicbsr)=NULL;
    a598:	c7 83 50 01 00 00 00 	movl   $0x0,0x150(%ebx)
    a59f:	00 00 00 
	}
	fsm_mem_set(SV(bsr),0,sizeof(MacBufferStatus_BSR_Info));
    a5a2:	8b 83 54 01 00 00    	mov    0x154(%ebx),%eax
    a5a8:	b9 1a 00 00 00       	mov    $0x1a,%ecx
    a5ad:	31 d2                	xor    %edx,%edx
    a5af:	e8 fc ff ff ff       	call   a5b0 <Free_Bsr_Info+0x50>
	FOUT;
}
    a5b4:	5b                   	pop    %ebx
    a5b5:	5d                   	pop    %ebp
    a5b6:	c3                   	ret    
    a5b7:	89 f6                	mov    %esi,%esi
    a5b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a5c0 <Zero_LogicalChannel_Bj_Reset>:
->Output: SV(LogicalChannel_Bj)lcbj0
->Special:
*******************************
*/
void Zero_LogicalChannel_Bj_Reset()
{
    a5c0:	55                   	push   %ebp
    a5c1:	89 e5                	mov    %esp,%ebp
    a5c3:	56                   	push   %esi
    a5c4:	53                   	push   %ebx
    a5c5:	e8 fc ff ff ff       	call   a5c6 <Zero_LogicalChannel_Bj_Reset+0x6>
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
    a5ca:	e8 fc ff ff ff       	call   a5cb <Zero_LogicalChannel_Bj_Reset+0xb>
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a5cf:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
    a5d5:	8b 4b 05             	mov    0x5(%ebx),%ecx
    a5d8:	8d 73 05             	lea    0x5(%ebx),%esi
    a5db:	39 f1                	cmp    %esi,%ecx
    a5dd:	8b 11                	mov    (%ecx),%edx
    a5df:	75 0b                	jne    a5ec <Zero_LogicalChannel_Bj_Reset+0x2c>
    a5e1:	eb 28                	jmp    a60b <Zero_LogicalChannel_Bj_Reset+0x4b>
    a5e3:	90                   	nop
    a5e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    a5e8:	89 d1                	mov    %edx,%ecx
    a5ea:	89 f2                	mov    %esi,%edx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
    a5ec:	81 79 fc 01 7d 00 00 	cmpl   $0x7d01,-0x4(%ecx)
    a5f3:	74 0d                	je     a602 <Zero_LogicalChannel_Bj_Reset+0x42>
			temp->lcbj=0;//BJ0			
    a5f5:	c7 41 fc 00 00 00 00 	movl   $0x0,-0x4(%ecx)
    a5fc:	8b 98 44 01 00 00    	mov    0x144(%eax),%ebx
	LogicalChannelBj *temp;
	struct list_head *pos=NULL,*p=NULL;	

	FIN(Zero_LogicalChannel_Bj_Reset());
	SV_PTR_GET(rlc_mac_sv);
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    a602:	8d 4b 05             	lea    0x5(%ebx),%ecx
    a605:	8b 32                	mov    (%edx),%esi
    a607:	39 ca                	cmp    %ecx,%edx
    a609:	75 dd                	jne    a5e8 <Zero_LogicalChannel_Bj_Reset+0x28>
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcbj!=(MAX_BJ/8+1))//
			temp->lcbj=0;//BJ0			
	}
	FOUT;
}
    a60b:	5b                   	pop    %ebx
    a60c:	5e                   	pop    %esi
    a60d:	5d                   	pop    %ebp
    a60e:	c3                   	ret    
    a60f:	90                   	nop

0000a610 <Init_LogicalChannel_ConfigInfo>:
->Output: SV(LogicalChannel_Bj)
->Special:
*******************************
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
    a610:	55                   	push   %ebp
    a611:	89 e5                	mov    %esp,%ebp
    a613:	57                   	push   %edi
    a614:	56                   	push   %esi
    a615:	53                   	push   %ebx
    a616:	83 ec 04             	sub    $0x4,%esp
    a619:	e8 fc ff ff ff       	call   a61a <Init_LogicalChannel_ConfigInfo+0xa>
    a61e:	89 c3                	mov    %eax,%ebx
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a620:	e8 fc ff ff ff       	call   a621 <Init_LogicalChannel_ConfigInfo+0x11>
	bool flag=false;
	struct list_head *pos=NULL,*p=NULL;
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
    a625:	0f b6 3b             	movzbl (%ebx),%edi
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a628:	8b b0 40 01 00 00    	mov    0x140(%eax),%esi
*/
void Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info)
{
	u8 temp_lc_config_lcid;
	FIN(Init_LogicalChannel_ConfigInfo(MAC_LogicalChannelConfig_IoctrlMsg *lc_info));
	SV_PTR_GET(rlc_mac_sv);
    a62e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_lc_config=NULL;
	LogicalChannelConfigInfo *temp_add=NULL;
	LogicalChannelBj *temp_bj=NULL;
	u8 temp_lcid=lc_info->logicalChannelIdentity;
	
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    a631:	8b 56 11             	mov    0x11(%esi),%edx
    a634:	83 c6 11             	add    $0x11,%esi
    a637:	39 f2                	cmp    %esi,%edx
    a639:	8b 02                	mov    (%edx),%eax
    a63b:	75 0d                	jne    a64a <Init_LogicalChannel_ConfigInfo+0x3a>
    a63d:	eb 39                	jmp    a678 <Init_LogicalChannel_ConfigInfo+0x68>
    a63f:	90                   	nop
    a640:	39 c6                	cmp    %eax,%esi
    a642:	8b 08                	mov    (%eax),%ecx
    a644:	74 32                	je     a678 <Init_LogicalChannel_ConfigInfo+0x68>
    a646:	89 c2                	mov    %eax,%edx
    a648:	89 c8                	mov    %ecx,%eax
	{
		temp_lc_config=list_entry(pos,LogicalChannelConfigInfo,list);
		temp_lc_config_lcid=temp_lc_config->lcid;
		if(temp_lcid==temp_lc_config_lcid)
    a64a:	89 f9                	mov    %edi,%ecx
    a64c:	3a 4a ef             	cmp    -0x11(%edx),%cl
    a64f:	75 ef                	jne    a640 <Init_LogicalChannel_ConfigInfo+0x30>
		{
			if((lc_info->logicalChannelConfig).haveUl_SpecificParameters==true)
    a651:	80 7b 04 00          	cmpb   $0x0,0x4(%ebx)
    a655:	74 e9                	je     a640 <Init_LogicalChannel_ConfigInfo+0x30>
			{
				temp_lc_config->priority=(lc_info->logicalChannelConfig).ul_SpecificParameters.priority;
    a657:	8b 43 05             	mov    0x5(%ebx),%eax
    a65a:	89 42 f0             	mov    %eax,-0x10(%edx)
				temp_lc_config->prioritizedBitRateKbps=(lc_info->logicalChannelConfig).ul_SpecificParameters.prioritisedBitRate;
    a65d:	8b 43 09             	mov    0x9(%ebx),%eax
    a660:	89 42 f4             	mov    %eax,-0xc(%edx)
				temp_lc_config->bucketSizeDurationMs=(lc_info->logicalChannelConfig).ul_SpecificParameters.bucketSizeDuration;
    a663:	8b 43 0d             	mov    0xd(%ebx),%eax
    a666:	89 42 f8             	mov    %eax,-0x8(%edx)
				temp_lc_config->logicalChannelGroup=(lc_info->logicalChannelConfig).ul_SpecificParameters.logicalChannelGroup;
    a669:	8b 43 11             	mov    0x11(%ebx),%eax
    a66c:	89 42 fc             	mov    %eax,-0x4(%edx)
			temp_bj->lcbj=0;
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a66f:	83 c4 04             	add    $0x4,%esp
    a672:	5b                   	pop    %ebx
    a673:	5e                   	pop    %esi
    a674:	5f                   	pop    %edi
    a675:	5d                   	pop    %ebp
    a676:	c3                   	ret    
    a677:	90                   	nop
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a678:	89 d8                	mov    %ebx,%eax
    a67a:	e8 fc ff ff ff       	call   a67b <Init_LogicalChannel_ConfigInfo+0x6b>
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a67f:	8b 55 f0             	mov    -0x10(%ebp),%edx
			}
		}
	}
	if(flag==false)
	{
		temp_add=LogicalChannel_ConfigInfo_copy(lc_info);
    a682:	89 c6                	mov    %eax,%esi
		list_add_tail(&(temp_add->list), (&(SV(LogicalChannel_Config)->list)));
    a684:	8b 82 40 01 00 00    	mov    0x140(%edx),%eax
    a68a:	8d 4e 11             	lea    0x11(%esi),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a68d:	8b 50 15             	mov    0x15(%eax),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a690:	89 48 15             	mov    %ecx,0x15(%eax)
    a693:	83 c0 11             	add    $0x11,%eax
    a696:	89 46 11             	mov    %eax,0x11(%esi)
		temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
    a699:	b8 0d 00 00 00       	mov    $0xd,%eax
	new->next = next;
	new->prev = prev;
    a69e:	89 56 15             	mov    %edx,0x15(%esi)
	prev->next = new;
    a6a1:	89 0a                	mov    %ecx,(%edx)
    a6a3:	e8 fc ff ff ff       	call   a6a4 <Init_LogicalChannel_ConfigInfo+0x94>
		/*while(temp_bj==0)//
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
    a6a8:	8d 50 05             	lea    0x5(%eax),%edx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a6ab:	89 50 05             	mov    %edx,0x5(%eax)
	list->prev = list;
    a6ae:	89 50 09             	mov    %edx,0x9(%eax)
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a6b1:	8b 0b                	mov    (%ebx),%ecx
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a6b3:	bb 01 7d 00 00       	mov    $0x7d01,%ebx
		{
			temp_bj=(LogicalChannelBj *)fsm_mem_alloc(sizeof(LogicalChannelBj));
		}*/
		//fsm_mem_set(temp_bj,0,sizeof(LogicalChannelBj));
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
    a6b8:	88 08                	mov    %cl,(%eax)
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a6ba:	31 c9                	xor    %ecx,%ecx
    a6bc:	83 7e 05 ff          	cmpl   $0xffffffff,0x5(%esi)
    a6c0:	0f 44 cb             	cmove  %ebx,%ecx
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a6c3:	8b 5d f0             	mov    -0x10(%ebp),%ebx
		INIT_LIST_HEAD(&(temp_bj->list));
		temp_bj->lcid=lc_info->logicalChannelIdentity;
		if((temp_add->prioritizedBitRateKbps)==infinity)
			temp_bj->lcbj=MAX_BJ/8+1;
		else
			temp_bj->lcbj=0;
    a6c6:	89 48 01             	mov    %ecx,0x1(%eax)
		list_add_tail(&(temp_bj->list), (&(SV(LogicalChannel_Bj)->list)));
    a6c9:	8b 8b 44 01 00 00    	mov    0x144(%ebx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a6cf:	8b 59 09             	mov    0x9(%ecx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a6d2:	89 51 09             	mov    %edx,0x9(%ecx)
    a6d5:	83 c1 05             	add    $0x5,%ecx
    a6d8:	89 48 05             	mov    %ecx,0x5(%eax)
	new->next = next;
	new->prev = prev;
    a6db:	89 58 09             	mov    %ebx,0x9(%eax)
	prev->next = new;
    a6de:	89 13                	mov    %edx,(%ebx)
	}
	// fsm_mem_free(lc_info);//modified 20140526 ,IOCTL IOCTL
	FOUT;
}
    a6e0:	83 c4 04             	add    $0x4,%esp
    a6e3:	5b                   	pop    %ebx
    a6e4:	5e                   	pop    %esi
    a6e5:	5f                   	pop    %edi
    a6e6:	5d                   	pop    %ebp
    a6e7:	c3                   	ret    
    a6e8:	90                   	nop
    a6e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000a6f0 <leftresource_morethan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a6f0:	55                   	push   %ebp
    a6f1:	89 e5                	mov    %esp,%ebp
    a6f3:	83 ec 18             	sub    $0x18,%esp
    a6f6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a6f9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a6fc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a6ff:	e8 fc ff ff ff       	call   a700 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x10>
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a704:	8b 71 01             	mov    0x1(%ecx),%esi
->Output:*res_length
->Special:
*******************************
*/
void leftresource_morethan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a707:	8b 5d 08             	mov    0x8(%ebp),%ebx
    a70a:	8b 7d 0c             	mov    0xc(%ebp),%edi
    a70d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    a710:	8b 45 14             	mov    0x14(%ebp),%eax
	FIN(leftresource_morethan_retxbuffer_eachlogicalchannel());
	temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a713:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a717:	66 89 72 0d          	mov    %si,0xd(%edx)
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a71b:	8b 71 01             	mov    0x1(%ecx),%esi
    a71e:	8b 76 09             	mov    0x9(%esi),%esi
    a721:	89 72 09             	mov    %esi,0x9(%edx)
	*res_length=*res_length-retxlength;
    a724:	29 38                	sub    %edi,(%eax)
	temp_logicalchannel_bj->lcbj-=retxlength;
    a726:	29 7b 01             	sub    %edi,0x1(%ebx)
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a729:	8b 30                	mov    (%eax),%esi
    a72b:	8b 7d 10             	mov    0x10(%ebp),%edi
    a72e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    a731:	39 fe                	cmp    %edi,%esi
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a733:	8b 71 01             	mov    0x1(%ecx),%esi
	temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
	*res_length=*res_length-retxlength;
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
    a736:	0f 83 b4 00 00 00    	jae    a7f0 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x100>
		*res_length-=txlength;
		//  break;
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
    a73c:	0f b7 7e 07          	movzwl 0x7(%esi),%edi
    a740:	66 89 7d f2          	mov    %di,-0xe(%ebp)
    a744:	0f b7 ff             	movzwl %di,%edi
    a747:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    a74a:	73 4c                	jae    a798 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xa8>
			// break;
		}
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
    a74c:	8b 76 03             	mov    0x3(%esi),%esi
    a74f:	39 75 e8             	cmp    %esi,-0x18(%ebp)
    a752:	0f 83 d8 00 00 00    	jae    a830 <leftresource_morethan_retxbuffer_eachlogicalchannel+0x140>
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a758:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a75b:	8b 7d ec             	mov    -0x14(%ebp),%edi
				temp_rlc_report->txQueueHeader=0;
    a75e:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
				//  break;
			}
			else//
			{
				temp_rlc_report->txQueueSize=*res_length;
    a764:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
    a767:	8b 08                	mov    (%eax),%ecx
    a769:	29 4b 01             	sub    %ecx,0x1(%ebx)
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a76c:	89 fb                	mov    %edi,%ebx
    a76e:	8d 4a 13             	lea    0x13(%edx),%ecx
    a771:	83 c3 13             	add    $0x13,%ebx
			{
				temp_rlc_report->txQueueSize=*res_length;
				temp_rlc_report->txQueueHeader=0;
				temp_logicalchannel_bj->lcbj-=*res_length;
				//temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
				*res_length=0;
    a774:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a77a:	8b 47 17             	mov    0x17(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a77d:	89 4f 17             	mov    %ecx,0x17(%edi)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a780:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a783:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a786:	89 08                	mov    %ecx,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a788:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a78b:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a78e:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a791:	89 ec                	mov    %ebp,%esp
    a793:	5d                   	pop    %ebp
    a794:	c3                   	ret    
    a795:	8d 76 00             	lea    0x0(%esi),%esi
	}
	else
	{
		if(*res_length>=(temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a798:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
    a79c:	66 89 72 07          	mov    %si,0x7(%edx)
			*res_length=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    a7a0:	8b 71 01             	mov    0x1(%ecx),%esi
    a7a3:	8b 38                	mov    (%eax),%edi
    a7a5:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a7a9:	29 f7                	sub    %esi,%edi
    a7ab:	89 38                	mov    %edi,(%eax)
			temp_rlc_report->txQueueSize=*res_length;
    a7ad:	89 7a 03             	mov    %edi,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=(temp_mac_buffer->RlcRequestparams->txQueueHeader+temp_rlc_report->txQueueSize);
    a7b0:	8b 49 01             	mov    0x1(%ecx),%ecx
    a7b3:	0f b7 71 07          	movzwl 0x7(%ecx),%esi
    a7b7:	8b 4b 01             	mov    0x1(%ebx),%ecx
    a7ba:	29 f1                	sub    %esi,%ecx
    a7bc:	29 f9                	sub    %edi,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a7be:	8b 7d ec             	mov    -0x14(%ebp),%edi
    a7c1:	89 4b 01             	mov    %ecx,0x1(%ebx)
			// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
			// temp_mac_buffer->RlcRequestparams->txQueueSize-=res_length;
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a7c4:	8d 5a 13             	lea    0x13(%edx),%ebx
    a7c7:	8b 4f 17             	mov    0x17(%edi),%ecx
    a7ca:	89 fe                	mov    %edi,%esi
    a7cc:	83 c6 13             	add    $0x13,%esi
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a7cf:	89 5f 17             	mov    %ebx,0x17(%edi)
    a7d2:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a7d5:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a7d8:	89 19                	mov    %ebx,(%ecx)
			*res_length=0;
    a7da:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a7e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a7e3:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a7e6:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a7e9:	89 ec                	mov    %ebp,%esp
    a7eb:	5d                   	pop    %ebp
    a7ec:	c3                   	ret    
    a7ed:	8d 76 00             	lea    0x0(%esi),%esi
	temp_logicalchannel_bj->lcbj-=retxlength;
	//temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
	// temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
	if(*res_length>=txlength)
	{
		temp_rlc_report->txQueueHeader=temp_mac_buffer->RlcRequestparams->txQueueHeader;
    a7f0:	0f b7 76 07          	movzwl 0x7(%esi),%esi
    a7f4:	66 89 72 07          	mov    %si,0x7(%edx)
		temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a7f8:	8b 49 01             	mov    0x1(%ecx),%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a7fb:	8b 75 ec             	mov    -0x14(%ebp),%esi
    a7fe:	8b 49 03             	mov    0x3(%ecx),%ecx
    a801:	89 4a 03             	mov    %ecx,0x3(%edx)
		temp_logicalchannel_bj->lcbj-=txlength;
    a804:	29 7b 01             	sub    %edi,0x1(%ebx)
    a807:	8b 4e 17             	mov    0x17(%esi),%ecx
		// temp_mac_buffer->RlcRequestparams->txQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a80a:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a80d:	89 5e 17             	mov    %ebx,0x17(%esi)
    a810:	83 c6 13             	add    $0x13,%esi
    a813:	89 72 13             	mov    %esi,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a816:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a819:	89 19                	mov    %ebx,(%ecx)
		*res_length-=txlength;
    a81b:	29 38                	sub    %edi,(%eax)
				// break;
			}
		}
	}
	FOUT;
}
    a81d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a820:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a823:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a826:	89 ec                	mov    %ebp,%esp
    a828:	5d                   	pop    %ebp
    a829:	c3                   	ret    
    a82a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		else if(*res_length < (temp_mac_buffer->RlcRequestparams->txQueueHeader))//
		{
			
			if(*res_length>= (temp_mac_buffer->RlcRequestparams->txQueueSize))//
			{
				temp_rlc_report->txQueueSize=temp_mac_buffer->RlcRequestparams->txQueueSize;
    a830:	89 72 03             	mov    %esi,0x3(%edx)
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);
    a833:	8b 49 01             	mov    0x1(%ecx),%ecx
    a836:	8b 30                	mov    (%eax),%esi
    a838:	66 2b 71 03          	sub    0x3(%ecx),%si
    a83c:	66 89 72 07          	mov    %si,0x7(%edx)

				temp_logicalchannel_bj->lcbj-=*res_length;
    a840:	8b 08                	mov    (%eax),%ecx
    a842:	29 4b 01             	sub    %ecx,0x1(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a845:	8b 5d ec             	mov    -0x14(%ebp),%ebx
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a848:	8d 4a 13             	lea    0x13(%edx),%ecx
				temp_rlc_report->txQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->txQueueSize);

				temp_logicalchannel_bj->lcbj-=*res_length;
				//  temp_mac_buffer->RlcRequestparams->txQueueHeader-=temp_rlc_report->txQueueHeader;
				// temp_mac_buffer->RlcRequestparams->txQueueSize=0;
				*res_length=0;
    a84b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    a851:	8b 43 17             	mov    0x17(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a854:	89 4b 17             	mov    %ecx,0x17(%ebx)
				list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a857:	83 c3 13             	add    $0x13,%ebx
    a85a:	89 5a 13             	mov    %ebx,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a85d:	89 42 17             	mov    %eax,0x17(%edx)
	prev->next = new;
    a860:	89 08                	mov    %ecx,(%eax)
    a862:	e9 79 ff ff ff       	jmp    a7e0 <leftresource_morethan_retxbuffer_eachlogicalchannel+0xf0>
    a867:	89 f6                	mov    %esi,%esi
    a869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000a870 <leftresource_lessthan_retxbuffer_eachlogicalchannel>:
->Output:*res_length
->Special:
*******************************
*/
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a870:	55                   	push   %ebp
    a871:	89 e5                	mov    %esp,%ebp
    a873:	83 ec 10             	sub    $0x10,%esp
    a876:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a879:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a87c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a87f:	e8 fc ff ff ff       	call   a880 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x10>
    a884:	8b 5d 14             	mov    0x14(%ebp),%ebx
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
    a887:	8b 33                	mov    (%ebx),%esi
    a889:	89 75 f0             	mov    %esi,-0x10(%ebp)
    a88c:	8b 71 01             	mov    0x1(%ecx),%esi
    a88f:	0f b7 7e 0d          	movzwl 0xd(%esi),%edi
    a893:	39 7d f0             	cmp    %edi,-0x10(%ebp)
    a896:	73 58                	jae    a8f0 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x80>
		*res_length=0;
		// break;
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
    a898:	8b 76 09             	mov    0x9(%esi),%esi
    a89b:	39 75 f0             	cmp    %esi,-0x10(%ebp)
    a89e:	0f 83 ac 00 00 00    	jae    a950 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0xe0>
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a8a4:	8b 7d f0             	mov    -0x10(%ebp),%edi
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
			temp_logicalchannel_bj->lcbj-=*res_length;
    a8a7:	8b 75 08             	mov    0x8(%ebp),%esi
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
			temp_rlc_report->retxQueueHeader=0;
    a8aa:	66 c7 42 0d 00 00    	movw   $0x0,0xd(%edx)
			temp_rlc_report->txQueueHeader=0;
    a8b0:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			// break;
		}
		else//
		{
			temp_rlc_report->retxQueueSize=*res_length;
    a8b6:	89 7a 09             	mov    %edi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=0;
			temp_rlc_report->txQueueHeader=0;
			temp_rlc_report->txQueueSize=0;
    a8b9:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
			temp_logicalchannel_bj->lcbj-=*res_length;
    a8c0:	8b 0b                	mov    (%ebx),%ecx
    a8c2:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
			*res_length=0;
    a8c5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a8cb:	8b 48 17             	mov    0x17(%eax),%ecx
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a8ce:	8d 5a 13             	lea    0x13(%edx),%ebx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a8d1:	89 58 17             	mov    %ebx,0x17(%eax)
    a8d4:	83 c0 13             	add    $0x13,%eax
    a8d7:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a8da:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a8dd:	89 19                	mov    %ebx,(%ecx)
			//break;
		}
	}
	FOUT;
}
    a8df:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a8e2:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a8e5:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a8e8:	89 ec                	mov    %ebp,%esp
    a8ea:	5d                   	pop    %ebp
    a8eb:	c3                   	ret    
    a8ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
void leftresource_lessthan_retxbuffer_eachlogicalchannel(RlcBufferRequest *mac_rlc_report,RlcBufferRequest *temp_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
    a8f0:	8b 7d 08             	mov    0x8(%ebp),%edi
    a8f3:	8b 75 f0             	mov    -0x10(%ebp),%esi
    a8f6:	29 77 01             	sub    %esi,0x1(%edi)
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a8f9:	89 df                	mov    %ebx,%edi
{
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
    a8fb:	8b 71 01             	mov    0x1(%ecx),%esi
    a8fe:	0f b7 76 0d          	movzwl 0xd(%esi),%esi
    a902:	66 89 72 0d          	mov    %si,0xd(%edx)
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a906:	8b 49 01             	mov    0x1(%ecx),%ecx
		temp_rlc_report->retxQueueSize=*res_length;
		temp_rlc_report->txQueueHeader=0;
		temp_rlc_report->txQueueSize=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a909:	8d 72 13             	lea    0x13(%edx),%esi
	FIN(leftresource_lessthan_retxbuffer_eachlogicalchannel());
	if(*res_length>=(temp_mac_buffer->RlcRequestparams->retxQueueHeader))//
	{
		temp_logicalchannel_bj->lcbj-=*res_length;
		temp_rlc_report->retxQueueHeader=temp_mac_buffer->RlcRequestparams->retxQueueHeader;
		*res_length=res_length-(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    a90c:	0f b7 49 0d          	movzwl 0xd(%ecx),%ecx
    a910:	c1 e1 02             	shl    $0x2,%ecx
    a913:	29 cf                	sub    %ecx,%edi
    a915:	89 3b                	mov    %edi,(%ebx)
		temp_rlc_report->retxQueueSize=*res_length;
    a917:	89 7a 09             	mov    %edi,0x9(%edx)
		temp_rlc_report->txQueueHeader=0;
    a91a:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
		temp_rlc_report->txQueueSize=0;
    a920:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    a927:	8b 48 17             	mov    0x17(%eax),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    a92a:	89 70 17             	mov    %esi,0x17(%eax)
		// temp_mac_buffer->RlcRequestparams->retxQueueHeader=0;
		// temp_mac_buffer->RlcRequestparams->retxQueueSize-=res_length;
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    a92d:	83 c0 13             	add    $0x13,%eax
    a930:	89 42 13             	mov    %eax,0x13(%edx)
	new->next = next;
	new->prev = prev;
    a933:	89 4a 17             	mov    %ecx,0x17(%edx)
	prev->next = new;
    a936:	89 31                	mov    %esi,(%ecx)
		*res_length=0;
    a938:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
			list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
			//break;
		}
	}
	FOUT;
}
    a93e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    a941:	8b 75 f8             	mov    -0x8(%ebp),%esi
    a944:	8b 7d fc             	mov    -0x4(%ebp),%edi
    a947:	89 ec                	mov    %ebp,%esp
    a949:	5d                   	pop    %ebp
    a94a:	c3                   	ret    
    a94b:	90                   	nop
    a94c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	else if(*res_length < (temp_mac_buffer->RlcRequestparams-> retxQueueHeader))//
	{
		if(*res_length>= (temp_mac_buffer->RlcRequestparams->retxQueueSize))//
		{
			temp_rlc_report->retxQueueSize=temp_mac_buffer->RlcRequestparams->retxQueueSize;
    a950:	89 72 09             	mov    %esi,0x9(%edx)
			temp_rlc_report->retxQueueHeader=*res_length-(temp_mac_buffer->RlcRequestparams->retxQueueSize);
    a953:	8b 49 01             	mov    0x1(%ecx),%ecx
    a956:	8b 33                	mov    (%ebx),%esi
    a958:	66 2b 71 09          	sub    0x9(%ecx),%si
    a95c:	66 89 72 0d          	mov    %si,0xd(%edx)

			temp_logicalchannel_bj->lcbj-=*res_length;
    a960:	8b 75 08             	mov    0x8(%ebp),%esi
    a963:	8b 0b                	mov    (%ebx),%ecx
    a965:	29 4e 01             	sub    %ecx,0x1(%esi)
			// temp_mac_buffer->RlcRequestparams->retxQueueHeader-=temp_rlc_report->retxQueueHeader;
			//temp_mac_buffer->RlcRequestparams->retxQueueSize=0;
			temp_rlc_report->txQueueHeader=0;
    a968:	66 c7 42 07 00 00    	movw   $0x0,0x7(%edx)
			temp_rlc_report->txQueueSize=0;
    a96e:	c7 42 03 00 00 00 00 	movl   $0x0,0x3(%edx)
    a975:	e9 4b ff ff ff       	jmp    a8c5 <leftresource_lessthan_retxbuffer_eachlogicalchannel+0x55>
    a97a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000a980 <ResourceAllocation_logicalchannel_firstretxbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a980:	55                   	push   %ebp
    a981:	89 e5                	mov    %esp,%ebp
    a983:	83 ec 24             	sub    $0x24,%esp
    a986:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    a989:	89 75 f8             	mov    %esi,-0x8(%ebp)
    a98c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    a98f:	e8 fc ff ff ff       	call   a990 <ResourceAllocation_logicalchannel_firstretxbuffer+0x10>
    a994:	8b 7d 10             	mov    0x10(%ebp),%edi
    a997:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a99a:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
    a99f:	89 d6                	mov    %edx,%esi
    a9a1:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a9a4:	e8 fc ff ff ff       	call   a9a5 <ResourceAllocation_logicalchannel_firstretxbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a9a9:	31 d2                	xor    %edx,%edx
    a9ab:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firstretxbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firstretxbuffer);
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    a9b0:	89 c3                	mov    %eax,%ebx
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    a9b2:	e8 fc ff ff ff       	call   a9b3 <ResourceAllocation_logicalchannel_firstretxbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
    a9b7:	8d 43 13             	lea    0x13(%ebx),%eax
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a9ba:	89 f1                	mov    %esi,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    a9bc:	89 43 13             	mov    %eax,0x13(%ebx)
    a9bf:	89 da                	mov    %ebx,%edx
	list->prev = list;
    a9c1:	89 43 17             	mov    %eax,0x17(%ebx)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    a9c4:	8b 46 01             	mov    0x1(%esi),%eax
    a9c7:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    a9cb:	88 43 02             	mov    %al,0x2(%ebx)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a9ce:	8b 46 01             	mov    0x1(%esi),%eax
    a9d1:	0f b7 00             	movzwl (%eax),%eax
	temp_rlc_report->statusPduHeader=0;
    a9d4:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
	temp_rlc_report->statusPduSize=0;//PDU
    a9da:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    a9e0:	66 89 03             	mov    %ax,(%ebx)
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    a9e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a9e6:	39 07                	cmp    %eax,(%edi)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    a9e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9eb:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    a9ef:	89 44 24 08          	mov    %eax,0x8(%esp)
    a9f3:	8b 45 08             	mov    0x8(%ebp),%eax
    a9f6:	89 44 24 04          	mov    %eax,0x4(%esp)
    a9fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    a9fd:	89 04 24             	mov    %eax,(%esp)
    aa00:	8b 45 f0             	mov    -0x10(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));        
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
    aa03:	73 13                	jae    aa18 <ResourceAllocation_logicalchannel_firstretxbuffer+0x98>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    aa05:	e8 fc ff ff ff       	call   aa06 <ResourceAllocation_logicalchannel_firstretxbuffer+0x86>
	}
	FOUT;
}
    aa0a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aa0d:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aa10:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aa13:	89 ec                	mov    %ebp,%esp
    aa15:	5d                   	pop    %ebp
    aa16:	c3                   	ret    
    aa17:	90                   	nop
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=0;
	temp_rlc_report->statusPduSize=0;//PDU
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aa18:	e8 fc ff ff ff       	call   aa19 <ResourceAllocation_logicalchannel_firstretxbuffer+0x99>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    aa1d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aa20:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aa23:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aa26:	89 ec                	mov    %ebp,%esp
    aa28:	5d                   	pop    %ebp
    aa29:	c3                   	ret    
    aa2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000aa30 <ResourceAllocation_logicalchannel_firststatusbuffer>:
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    aa30:	55                   	push   %ebp
    aa31:	89 e5                	mov    %esp,%ebp
    aa33:	83 ec 24             	sub    $0x24,%esp
    aa36:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    aa39:	89 75 f8             	mov    %esi,-0x8(%ebp)
    aa3c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    aa3f:	e8 fc ff ff ff       	call   aa40 <ResourceAllocation_logicalchannel_firststatusbuffer+0x10>
    aa44:	8b 7d 14             	mov    0x14(%ebp),%edi
    aa47:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aa4a:	b8 1b 00 00 00       	mov    $0x1b,%eax
->Output:*res_length
->Special:
*******************************
*/
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    aa4f:	89 d3                	mov    %edx,%ebx
    aa51:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aa54:	e8 fc ff ff ff       	call   aa55 <ResourceAllocation_logicalchannel_firststatusbuffer+0x25>
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    aa59:	31 d2                	xor    %edx,%edx
    aa5b:	b9 1b 00 00 00       	mov    $0x1b,%ecx
void ResourceAllocation_logicalchannel_firststatusbuffer(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
	FIN(ResourceAllocation_logicalchannel_firststatusbuffer());
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    aa60:	89 c6                	mov    %eax,%esi
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
    aa62:	e8 fc ff ff ff       	call   aa63 <ResourceAllocation_logicalchannel_firststatusbuffer+0x33>
	INIT_LIST_HEAD(&(temp_rlc_report->list));
    aa67:	8d 46 13             	lea    0x13(%esi),%eax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aa6a:	89 d9                	mov    %ebx,%ecx
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aa6c:	89 46 13             	mov    %eax,0x13(%esi)
    aa6f:	89 f2                	mov    %esi,%edx
	list->prev = list;
    aa71:	89 46 17             	mov    %eax,0x17(%esi)
	RlcBufferRequest *temp_rlc_report;
	
	temp_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	fsm_mem_set(temp_rlc_report,0,sizeof(RlcBufferRequest));
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
    aa74:	8b 43 01             	mov    0x1(%ebx),%eax
    aa77:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    aa7b:	88 46 02             	mov    %al,0x2(%esi)
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
    aa7e:	8b 43 01             	mov    0x1(%ebx),%eax
    aa81:	0f b7 00             	movzwl (%eax),%eax
    aa84:	66 89 06             	mov    %ax,(%esi)
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
    aa87:	8b 43 01             	mov    0x1(%ebx),%eax
    aa8a:	0f b7 40 11          	movzwl 0x11(%eax),%eax
    aa8e:	66 89 46 11          	mov    %ax,0x11(%esi)
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
    aa92:	8b 43 01             	mov    0x1(%ebx),%eax
    aa95:	0f b7 40 0f          	movzwl 0xf(%eax),%eax
    aa99:	66 89 46 0f          	mov    %ax,0xf(%esi)
	*res_length=*res_length-statuslength;        
    aa9d:	8b 07                	mov    (%edi),%eax
    aa9f:	2b 45 08             	sub    0x8(%ebp),%eax
	if(*res_length >= retxlength)
    aaa2:	3b 45 0c             	cmp    0xc(%ebp),%eax
	INIT_LIST_HEAD(&(temp_rlc_report->list));
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
    aaa5:	89 07                	mov    %eax,(%edi)
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aaa7:	8b 45 10             	mov    0x10(%ebp),%eax
    aaaa:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    aaae:	89 44 24 08          	mov    %eax,0x8(%esp)
    aab2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aab5:	89 44 24 04          	mov    %eax,0x4(%esp)
    aab9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    aabc:	89 04 24             	mov    %eax,(%esp)
    aabf:	8b 45 f0             	mov    -0x10(%ebp),%eax
	temp_rlc_report->lcid=temp_mac_buffer->RlcRequestparams->lcid;
	temp_rlc_report->rnti=temp_mac_buffer->RlcRequestparams->rnti;
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
    aac2:	73 14                	jae    aad8 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa8>
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
	}
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
    aac4:	e8 fc ff ff ff       	call   aac5 <ResourceAllocation_logicalchannel_firststatusbuffer+0x95>
	}
	FOUT;
}
    aac9:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aacc:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aacf:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aad2:	89 ec                	mov    %ebp,%esp
    aad4:	5d                   	pop    %ebp
    aad5:	c3                   	ret    
    aad6:	66 90                	xchg   %ax,%ax
	temp_rlc_report->statusPduHeader=temp_mac_buffer->RlcRequestparams->statusPduHeader;
	temp_rlc_report->statusPduSize=temp_mac_buffer->RlcRequestparams->statusPduSize;
	*res_length=*res_length-statuslength;        
	if(*res_length >= retxlength)
	{
		leftresource_morethan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength,txlength, res_length);
    aad8:	e8 fc ff ff ff       	call   aad9 <ResourceAllocation_logicalchannel_firststatusbuffer+0xa9>
	else if(*res_length < retxlength)
	{
		leftresource_lessthan_retxbuffer_eachlogicalchannel(mac_rlc_report,temp_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,retxlength, txlength,res_length);
	}
	FOUT;
}
    aadd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    aae0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    aae3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    aae6:	89 ec                	mov    %ebp,%esp
    aae8:	5d                   	pop    %ebp
    aae9:	c3                   	ret    
    aaea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000aaf0 <ResourceAllocation_foreach_logicalchannel>:
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    aaf0:	55                   	push   %ebp
    aaf1:	89 e5                	mov    %esp,%ebp
    aaf3:	83 ec 30             	sub    $0x30,%esp
    aaf6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    aaf9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    aafc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    aaff:	e8 fc ff ff ff       	call   ab00 <ResourceAllocation_foreach_logicalchannel+0x10>
    ab04:	8b 75 14             	mov    0x14(%ebp),%esi
    ab07:	8b 5d 08             	mov    0x8(%ebp),%ebx
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    ab0a:	89 55 e8             	mov    %edx,-0x18(%ebp)
    ab0d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
->Output:mac_rlc_report:RLCreport
->Special:
*******************************
*/
void ResourceAllocation_foreach_logicalchannel(RlcBufferRequest *mac_rlc_report,MacBufferStatus *temp_mac_buffer, LogicalChannelBj *temp_logicalchannel_bj,u32 statuslength,u32 retxlength,u32 txlength,u32 *res_length)
{
    ab10:	89 45 f0             	mov    %eax,-0x10(%ebp)
	FIN(ResourceAllocation_foreach_logicalchannel());
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
    ab13:	e8 fc ff ff ff       	call   ab14 <ResourceAllocation_foreach_logicalchannel+0x24>
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    ab18:	8b 7d 0c             	mov    0xc(%ebp),%edi
    ab1b:	8b 06                	mov    (%esi),%eax
    ab1d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ab20:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ab23:	01 df                	add    %ebx,%edi
    ab25:	03 7d 10             	add    0x10(%ebp),%edi
    ab28:	39 f8                	cmp    %edi,%eax
    ab2a:	73 2c                	jae    ab58 <ResourceAllocation_foreach_logicalchannel+0x68>
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
		*res_length=*res_length-(statuslength+retxlength+txlength);
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
    ab2c:	39 d8                	cmp    %ebx,%eax
    ab2e:	73 70                	jae    aba0 <ResourceAllocation_foreach_logicalchannel+0xb0>
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
	}
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ab30:	8b 5d 10             	mov    0x10(%ebp),%ebx
    ab33:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ab36:	89 74 24 08          	mov    %esi,0x8(%esp)
    ab3a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    ab3e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    ab41:	89 1c 24             	mov    %ebx,(%esp)
    ab44:	e8 fc ff ff ff       	call   ab45 <ResourceAllocation_foreach_logicalchannel+0x55>
	}
	FOUT;
}
    ab49:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ab4c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    ab4f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    ab52:	89 ec                	mov    %ebp,%esp
    ab54:	5d                   	pop    %ebp
    ab55:	c3                   	ret    
    ab56:	66 90                	xchg   %ax,%ax
	RlcBufferRequest *temp_rlc_report=NULL;
	
	SV_PTR_GET(rlc_mac_sv);	
	if(*res_length>=(statuslength+retxlength+txlength))//TBSize
	{
		temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    ab58:	8b 42 01             	mov    0x1(%edx),%eax
    ab5b:	e8 fc ff ff ff       	call   ab5c <ResourceAllocation_foreach_logicalchannel+0x6c>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ab60:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    ab63:	8b 5b 17             	mov    0x17(%ebx),%ebx
		list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    ab66:	8d 50 13             	lea    0x13(%eax),%edx
    ab69:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    ab6c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ab6f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    ab72:	89 53 17             	mov    %edx,0x17(%ebx)
    ab75:	83 c3 13             	add    $0x13,%ebx
	new->next = next;
	new->prev = prev;
    ab78:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ab7b:	89 58 13             	mov    %ebx,0x13(%eax)
	prev->next = new;
    ab7e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
    ab81:	89 50 17             	mov    %edx,0x17(%eax)
	prev->next = new;
    ab84:	89 1a                	mov    %ebx,(%edx)
		*res_length=*res_length-(statuslength+retxlength+txlength);
    ab86:	29 3e                	sub    %edi,(%esi)
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
    ab88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ab8b:	29 79 01             	sub    %edi,0x1(%ecx)
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    ab8e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    ab91:	8b 75 f8             	mov    -0x8(%ebp),%esi
    ab94:	8b 7d fc             	mov    -0x4(%ebp),%edi
    ab97:	89 ec                	mov    %ebp,%esp
    ab99:	5d                   	pop    %ebp
    ab9a:	c3                   	ret    
    ab9b:	90                   	nop
    ab9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);	
		// break;
	}
	else if(*res_length>=statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    aba0:	8b 45 10             	mov    0x10(%ebp),%eax
    aba3:	89 74 24 0c          	mov    %esi,0xc(%esp)
    aba7:	89 1c 24             	mov    %ebx,(%esp)
    abaa:	89 44 24 08          	mov    %eax,0x8(%esp)
    abae:	8b 45 0c             	mov    0xc(%ebp),%eax
    abb1:	89 44 24 04          	mov    %eax,0x4(%esp)
    abb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    abb8:	e8 fc ff ff ff       	call   abb9 <ResourceAllocation_foreach_logicalchannel+0xc9>
	else if(*res_length <statuslength)//PDU TBSizePDU
	{
		ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
	}
	FOUT;
}
    abbd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    abc0:	8b 75 f8             	mov    -0x8(%ebp),%esi
    abc3:	8b 7d fc             	mov    -0x4(%ebp),%edi
    abc6:	89 ec                	mov    %ebp,%esp
    abc8:	5d                   	pop    %ebp
    abc9:	c3                   	ret    
    abca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000abd0 <Delete_LogicalChannel_ConfigInfo>:
->Output:int *num:reportvoid *:RLC report
->Special:
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
    abd0:	55                   	push   %ebp
    abd1:	89 e5                	mov    %esp,%ebp
    abd3:	57                   	push   %edi
    abd4:	56                   	push   %esi
    abd5:	53                   	push   %ebx
    abd6:	83 ec 04             	sub    $0x4,%esp
    abd9:	e8 fc ff ff ff       	call   abda <Delete_LogicalChannel_ConfigInfo+0xa>
    abde:	89 c6                	mov    %eax,%esi
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    abe0:	e8 fc ff ff ff       	call   abe1 <Delete_LogicalChannel_ConfigInfo+0x11>
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    abe5:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
*******************************
*/
void Delete_LogicalChannel_ConfigInfo(u16 lcid_delete)
{
	FIN(Delete_LogicalChannel_ConfigInfo(u16 lcid_delete));
	SV_PTR_GET(rlc_mac_sv);
    abeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    abee:	8b 51 11             	mov    0x11(%ecx),%edx
    abf1:	8d 41 11             	lea    0x11(%ecx),%eax
    abf4:	39 c2                	cmp    %eax,%edx
    abf6:	8b 1a                	mov    (%edx),%ebx
    abf8:	75 13                	jne    ac0d <Delete_LogicalChannel_ConfigInfo+0x3d>
    abfa:	eb 44                	jmp    ac40 <Delete_LogicalChannel_ConfigInfo+0x70>
    abfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ac00:	8d 51 11             	lea    0x11(%ecx),%edx
    ac03:	8b 03                	mov    (%ebx),%eax
    ac05:	39 d3                	cmp    %edx,%ebx
    ac07:	74 37                	je     ac40 <Delete_LogicalChannel_ConfigInfo+0x70>
    ac09:	89 da                	mov    %ebx,%edx
    ac0b:	89 c3                	mov    %eax,%ebx
	{
		temp_free=list_entry(pos,LogicalChannelConfigInfo,list);
		if(temp_free->lcid==lcid_delete)
    ac0d:	0f b6 42 ef          	movzbl -0x11(%edx),%eax
    ac11:	66 39 f0             	cmp    %si,%ax
    ac14:	75 ea                	jne    ac00 <Delete_LogicalChannel_ConfigInfo+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ac16:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
    ac19:	8d 42 ef             	lea    -0x11(%edx),%eax
    ac1c:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ac1e:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    ac21:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ac23:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    ac25:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp_free);
    ac28:	e8 fc ff ff ff       	call   ac29 <Delete_LogicalChannel_ConfigInfo+0x59>
    ac2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ac30:	8b 88 40 01 00 00    	mov    0x140(%eax),%ecx
	SV_PTR_GET(rlc_mac_sv);
	LogicalChannelConfigInfo *temp_free=NULL;
	LogicalChannelBj *temp=NULL;
	struct list_head *pos=NULL,*p=NULL;

	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))
    ac36:	8b 03                	mov    (%ebx),%eax
    ac38:	8d 51 11             	lea    0x11(%ecx),%edx
    ac3b:	39 d3                	cmp    %edx,%ebx
    ac3d:	75 ca                	jne    ac09 <Delete_LogicalChannel_ConfigInfo+0x39>
    ac3f:	90                   	nop
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    ac40:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ac43:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
    ac49:	8b 51 05             	mov    0x5(%ecx),%edx
    ac4c:	8d 41 05             	lea    0x5(%ecx),%eax
    ac4f:	39 c2                	cmp    %eax,%edx
    ac51:	8b 1a                	mov    (%edx),%ebx
    ac53:	75 10                	jne    ac65 <Delete_LogicalChannel_ConfigInfo+0x95>
    ac55:	eb 41                	jmp    ac98 <Delete_LogicalChannel_ConfigInfo+0xc8>
    ac57:	90                   	nop
    ac58:	8d 51 05             	lea    0x5(%ecx),%edx
    ac5b:	8b 03                	mov    (%ebx),%eax
    ac5d:	39 d3                	cmp    %edx,%ebx
    ac5f:	74 37                	je     ac98 <Delete_LogicalChannel_ConfigInfo+0xc8>
    ac61:	89 da                	mov    %ebx,%edx
    ac63:	89 c3                	mov    %eax,%ebx
	{
		temp=list_entry(pos,LogicalChannelBj,list);
		if(temp->lcid==lcid_delete)
    ac65:	0f b6 42 fb          	movzbl -0x5(%edx),%eax
    ac69:	66 39 f0             	cmp    %si,%ax
    ac6c:	75 ea                	jne    ac58 <Delete_LogicalChannel_ConfigInfo+0x88>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ac6e:	8b 4a 04             	mov    0x4(%edx),%ecx
		{
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
    ac71:	8d 42 fb             	lea    -0x5(%edx),%eax
    ac74:	8b 3a                	mov    (%edx),%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ac76:	89 4f 04             	mov    %ecx,0x4(%edi)
	prev->next = next;
    ac79:	89 39                	mov    %edi,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ac7b:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    ac7d:	89 52 04             	mov    %edx,0x4(%edx)
			fsm_mem_free(temp);
    ac80:	e8 fc ff ff ff       	call   ac81 <Delete_LogicalChannel_ConfigInfo+0xb1>
    ac85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ac88:	8b 88 44 01 00 00    	mov    0x144(%eax),%ecx
			list_del_init(&(temp_free->list));//delete a node of LogicalChannel_Config
			fsm_mem_free(temp_free);
		}
	}
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))
    ac8e:	8b 03                	mov    (%ebx),%eax
    ac90:	8d 51 05             	lea    0x5(%ecx),%edx
    ac93:	39 d3                	cmp    %edx,%ebx
    ac95:	75 ca                	jne    ac61 <Delete_LogicalChannel_ConfigInfo+0x91>
    ac97:	90                   	nop
			list_del_init(&(temp->list));//delete a node of LogicalChannel_Bj
			fsm_mem_free(temp);
		}
	}
	FOUT;
}
    ac98:	83 c4 04             	add    $0x4,%esp
    ac9b:	5b                   	pop    %ebx
    ac9c:	5e                   	pop    %esi
    ac9d:	5f                   	pop    %edi
    ac9e:	5d                   	pop    %ebp
    ac9f:	c3                   	ret    

0000aca0 <Empty_MACBuffer_Rlc>:
->Output:
->Special:
*******************************
*/
void Empty_MACBuffer_Rlc(void)
{
    aca0:	55                   	push   %ebp
    aca1:	89 e5                	mov    %esp,%ebp
    aca3:	57                   	push   %edi
    aca4:	56                   	push   %esi
    aca5:	53                   	push   %ebx
    aca6:	e8 fc ff ff ff       	call   aca7 <Empty_MACBuffer_Rlc+0x7>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
    acab:	e8 fc ff ff ff       	call   acac <Empty_MACBuffer_Rlc+0xc>
    acb0:	89 c7                	mov    %eax,%edi
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    acb2:	8b 80 48 01 00 00    	mov    0x148(%eax),%eax
    acb8:	8b 58 05             	mov    0x5(%eax),%ebx
    acbb:	83 c0 05             	add    $0x5,%eax
    acbe:	39 c3                	cmp    %eax,%ebx
    acc0:	8b 33                	mov    (%ebx),%esi
    acc2:	75 08                	jne    accc <Empty_MACBuffer_Rlc+0x2c>
    acc4:	eb 34                	jmp    acfa <Empty_MACBuffer_Rlc+0x5a>
    acc6:	66 90                	xchg   %ax,%ax
    acc8:	89 f3                	mov    %esi,%ebx
    acca:	89 d6                	mov    %edx,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    accc:	8b 43 fc             	mov    -0x4(%ebx),%eax
    accf:	e8 fc ff ff ff       	call   acd0 <Empty_MACBuffer_Rlc+0x30>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    acd4:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_free->list));
    acd7:	8d 43 fb             	lea    -0x5(%ebx),%eax
    acda:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    acdc:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    acdf:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ace1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    ace3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    ace6:	e8 fc ff ff ff       	call   ace7 <Empty_MACBuffer_Rlc+0x47>
	FIN(Empty_MACBuffer_Rlc(void));
	SV_PTR_GET(rlc_mac_sv);
	struct list_head *pos=NULL,*p=NULL;
	MacBufferStatus *temp_free=NULL;

	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    aceb:	8b 87 48 01 00 00    	mov    0x148(%edi),%eax
    acf1:	8b 16                	mov    (%esi),%edx
    acf3:	83 c0 05             	add    $0x5,%eax
    acf6:	39 c6                	cmp    %eax,%esi
    acf8:	75 ce                	jne    acc8 <Empty_MACBuffer_Rlc+0x28>
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}	
	FOUT;
}
    acfa:	5b                   	pop    %ebx
    acfb:	5e                   	pop    %esi
    acfc:	5f                   	pop    %edi
    acfd:	5d                   	pop    %ebp
    acfe:	c3                   	ret    
    acff:	90                   	nop

0000ad00 <ResourceAllocation_Algorithm>:
->Special:
*******************************
*/

void * ResourceAllocation_Algorithm(u32 resource_len,u32 *num)//numreport
{
    ad00:	55                   	push   %ebp
    ad01:	89 e5                	mov    %esp,%ebp
    ad03:	57                   	push   %edi
    ad04:	56                   	push   %esi
    ad05:	53                   	push   %ebx
    ad06:	83 ec 3c             	sub    $0x3c,%esp
    ad09:	e8 fc ff ff ff       	call   ad0a <ResourceAllocation_Algorithm+0xa>
    ad0e:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ad11:	89 45 f0             	mov    %eax,-0x10(%ebp)
	u32 *res_length;
	u32 statuslength,retxlength,txlength;
	struct list_head *pos,*p;

	FIN(ResourceAllocation_Algorithm(int resource_len));
	SV_PTR_GET(rlc_mac_sv);
    ad14:	e8 fc ff ff ff       	call   ad15 <ResourceAllocation_Algorithm+0x15>
    ad19:	89 45 dc             	mov    %eax,-0x24(%ebp)
	priority_mac_buffer=NULL;
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
    ad1c:	b8 1b 00 00 00       	mov    $0x1b,%eax
    ad21:	e8 fc ff ff ff       	call   ad22 <ResourceAllocation_Algorithm+0x22>
    ad26:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ad29:	b8 0d 00 00 00       	mov    $0xd,%eax
    ad2e:	e8 fc ff ff ff       	call   ad2f <ResourceAllocation_Algorithm+0x2f>
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
    ad33:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ad36:	83 c6 13             	add    $0x13,%esi
    ad39:	89 75 cc             	mov    %esi,-0x34(%ebp)
	temp_mac_buffer=NULL;
	temp_free=NULL;
	temp_rlc_report=NULL;

	mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	lcbj_lessthan_zero =(MacBufferStatus *)fsm_mem_alloc(sizeof(MacBufferStatus));
    ad3c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad3f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	INIT_LIST_HEAD(&(lcbj_lessthan_zero->list));
    ad42:	83 c0 05             	add    $0x5,%eax
    ad45:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ad48:	89 42 05             	mov    %eax,0x5(%edx)
	list->prev = list;
    ad4b:	89 42 09             	mov    %eax,0x9(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ad4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ad51:	89 70 13             	mov    %esi,0x13(%eax)
	list->prev = list;
    ad54:	89 70 17             	mov    %esi,0x17(%eax)
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ad57:	e8 fc ff ff ff       	call   ad58 <ResourceAllocation_Algorithm+0x58>
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ad5c:	89 c2                	mov    %eax,%edx
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
    ad5e:	89 45 e0             	mov    %eax,-0x20(%ebp)
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ad61:	8b 40 05             	mov    0x5(%eax),%eax
    ad64:	8d 78 fb             	lea    -0x5(%eax),%edi
    ad67:	39 fa                	cmp    %edi,%edx
    ad69:	0f 84 cc 02 00 00    	je     b03b <ResourceAllocation_Algorithm+0x33b>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ad6f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ad72:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ad76:	85 c9                	test   %ecx,%ecx
    ad78:	0f 84 e5 00 00 00    	je     ae63 <ResourceAllocation_Algorithm+0x163>
    ad7e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ad85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ad8c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ad93:	90                   	nop
    ad94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    ad98:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ad9b:	8b b0 44 01 00 00    	mov    0x144(%eax),%esi
    ada1:	8b 46 05             	mov    0x5(%esi),%eax
    ada4:	8d 58 fb             	lea    -0x5(%eax),%ebx
    ada7:	39 de                	cmp    %ebx,%esi
    ada9:	75 13                	jne    adbe <ResourceAllocation_Algorithm+0xbe>
    adab:	e9 68 01 00 00       	jmp    af18 <ResourceAllocation_Algorithm+0x218>
    adb0:	8b 43 05             	mov    0x5(%ebx),%eax
    adb3:	8d 58 fb             	lea    -0x5(%eax),%ebx
    adb6:	39 de                	cmp    %ebx,%esi
    adb8:	0f 84 5a 01 00 00    	je     af18 <ResourceAllocation_Algorithm+0x218>
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
    adbe:	38 50 fb             	cmp    %dl,-0x5(%eax)
    adc1:	75 ed                	jne    adb0 <ResourceAllocation_Algorithm+0xb0>
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    adc3:	8b 47 01             	mov    0x1(%edi),%eax
    adc6:	0f b7 70 0f          	movzwl 0xf(%eax),%esi
    adca:	0f b7 50 11          	movzwl 0x11(%eax),%edx
    adce:	01 f2                	add    %esi,%edx
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    add0:	0f b7 70 0d          	movzwl 0xd(%eax),%esi
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
    add4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    add7:	8b 50 09             	mov    0x9(%eax),%edx
    adda:	01 d6                	add    %edx,%esi
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    addc:	8b 50 03             	mov    0x3(%eax),%edx
		{
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
    addf:	89 75 ec             	mov    %esi,-0x14(%ebp)
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    ade2:	0f b7 70 07          	movzwl 0x7(%eax),%esi
    ade6:	01 d6                	add    %edx,%esi
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    ade8:	81 7b 01 01 7d 00 00 	cmpl   $0x7d01,0x1(%ebx)
			if(temp_buffer_lcid==(temp_logicalchannel_bj->lcid))
			{
				// printk(KERN_INFO"lcid:%d  lcbj:%d\n",temp_buffer_lcid,temp_logicalchannel_bj->lcbj);
				statuslength=(temp_mac_buffer->RlcRequestparams->statusPduSize)+(temp_mac_buffer->RlcRequestparams->statusPduHeader);
				retxlength=(temp_mac_buffer->RlcRequestparams->retxQueueSize)+(temp_mac_buffer->RlcRequestparams->retxQueueHeader);
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
    adef:	89 75 e8             	mov    %esi,-0x18(%ebp)
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
    adf2:	0f 85 a0 01 00 00    	jne    af98 <ResourceAllocation_Algorithm+0x298>
    adf8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    adfb:	09 f2                	or     %esi,%edx
    adfd:	0b 55 e4             	or     -0x1c(%ebp),%edx
    ae00:	0f 84 92 01 00 00    	je     af98 <ResourceAllocation_Algorithm+0x298>
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
    ae06:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ae09:	01 f2                	add    %esi,%edx
    ae0b:	03 55 e4             	add    -0x1c(%ebp),%edx
    ae0e:	39 ca                	cmp    %ecx,%edx
    ae10:	0f 86 b3 01 00 00    	jbe    afc9 <ResourceAllocation_Algorithm+0x2c9>
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    ae16:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae19:	8d 45 f0             	lea    -0x10(%ebp),%eax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
    ae1c:	0f 86 eb 01 00 00    	jbe    b00d <ResourceAllocation_Algorithm+0x30d>
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ae22:	8b 75 e8             	mov    -0x18(%ebp),%esi
    ae25:	89 d9                	mov    %ebx,%ecx
    ae27:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    ae29:	89 44 24 08          	mov    %eax,0x8(%esp)
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ae2d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae30:	89 74 24 04          	mov    %esi,0x4(%esp)
    ae34:	8b 75 ec             	mov    -0x14(%ebp),%esi
    ae37:	89 34 24             	mov    %esi,(%esp)
						break;
    ae3a:	89 de                	mov    %ebx,%esi
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
						break;
					}
					else if(*res_length <statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firstretxbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,retxlength,txlength,res_length);
    ae3c:	e8 fc ff ff ff       	call   ae3d <ResourceAllocation_Algorithm+0x13d>
    ae41:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ae44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    ae48:	8b 47 05             	mov    0x5(%edi),%eax
    ae4b:	8d 78 fb             	lea    -0x5(%eax),%edi
    ae4e:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    ae51:	0f 84 d3 00 00 00    	je     af2a <ResourceAllocation_Algorithm+0x22a>
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
    ae57:	85 c9                	test   %ecx,%ecx
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
    ae59:	0f b6 50 fb          	movzbl -0x5(%eax),%edx
		if(*res_length<=0)//
    ae5d:	0f 85 35 ff ff ff    	jne    ad98 <ResourceAllocation_Algorithm+0x98>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
    ae63:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ae66:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ae69:	e8 fc ff ff ff       	call   ae6a <ResourceAllocation_Algorithm+0x16a>
    ae6e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    ae71:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ae74:	8b 58 05             	mov    0x5(%eax),%ebx
    ae77:	89 c7                	mov    %eax,%edi
    ae79:	83 c7 05             	add    $0x5,%edi
    ae7c:	39 fb                	cmp    %edi,%ebx
    ae7e:	8b 33                	mov    (%ebx),%esi
    ae80:	75 0a                	jne    ae8c <ResourceAllocation_Algorithm+0x18c>
    ae82:	eb 2d                	jmp    aeb1 <ResourceAllocation_Algorithm+0x1b1>
    ae84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    ae88:	89 f3                	mov    %esi,%ebx
    ae8a:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    ae8c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    ae8f:	e8 fc ff ff ff       	call   ae90 <ResourceAllocation_Algorithm+0x190>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ae94:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    ae96:	8d 43 fb             	lea    -0x5(%ebx),%eax
    ae99:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ae9c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    ae9f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aea1:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    aea3:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    aea6:	e8 fc ff ff ff       	call   aea7 <ResourceAllocation_Algorithm+0x1a7>
			}
		}
	}
	report_array=RlcRequest_listtoarray(mac_rlc_report,num);    
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(priority_mac_buffer->list))//
    aeab:	39 fe                	cmp    %edi,%esi
    aead:	8b 06                	mov    (%esi),%eax
    aeaf:	75 d7                	jne    ae88 <ResourceAllocation_Algorithm+0x188>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
    aeb1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    aeb4:	e8 fc ff ff ff       	call   aeb5 <ResourceAllocation_Algorithm+0x1b5>
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    aeb9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    aebc:	8b 7d d0             	mov    -0x30(%ebp),%edi
    aebf:	8b 58 05             	mov    0x5(%eax),%ebx
    aec2:	39 5d d0             	cmp    %ebx,-0x30(%ebp)
    aec5:	8b 33                	mov    (%ebx),%esi
    aec7:	75 0b                	jne    aed4 <ResourceAllocation_Algorithm+0x1d4>
    aec9:	eb 2e                	jmp    aef9 <ResourceAllocation_Algorithm+0x1f9>
    aecb:	90                   	nop
    aecc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    aed0:	89 f3                	mov    %esi,%ebx
    aed2:	89 c6                	mov    %eax,%esi
	{
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
    aed4:	8b 43 fc             	mov    -0x4(%ebx),%eax
    aed7:	e8 fc ff ff ff       	call   aed8 <ResourceAllocation_Algorithm+0x1d8>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    aedc:	8b 0b                	mov    (%ebx),%ecx
		list_del_init(&(temp_free->list));
    aede:	8d 43 fb             	lea    -0x5(%ebx),%eax
    aee1:	8b 53 04             	mov    0x4(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    aee4:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    aee7:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    aee9:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    aeeb:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_free);
    aeee:	e8 fc ff ff ff       	call   aeef <ResourceAllocation_Algorithm+0x1ef>
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(priority_mac_buffer);
	pos=NULL,p=NULL;
	list_for_each_safe(pos,p,&(lcbj_lessthan_zero->list))//
    aef3:	39 f7                	cmp    %esi,%edi
    aef5:	8b 06                	mov    (%esi),%eax
    aef7:	75 d7                	jne    aed0 <ResourceAllocation_Algorithm+0x1d0>
		temp_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_free->RlcRequestparams);
		list_del_init(&(temp_free->list));
		fsm_mem_free(temp_free);
	}
	fsm_mem_free(lcbj_lessthan_zero);
    aef9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    aefc:	e8 fc ff ff ff       	call   aefd <ResourceAllocation_Algorithm+0x1fd>
	Empty_MACBuffer_Rlc();//MacBufferStatus
    af01:	e8 fc ff ff ff       	call   af02 <ResourceAllocation_Algorithm+0x202>
	FRET(report_array);
}
    af06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    af09:	83 c4 3c             	add    $0x3c,%esp
    af0c:	5b                   	pop    %ebx
    af0d:	5e                   	pop    %esi
    af0e:	5f                   	pop    %edi
    af0f:	5d                   	pop    %ebp
    af10:	c3                   	ret    
    af11:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    af18:	8b 47 05             	mov    0x5(%edi),%eax
	{
		temp_buffer_lcid=temp_mac_buffer->lcid;
		if(*res_length<=0)//
			break;
		temp_logicalchannel_bj=NULL;
		list_for_each_entry(temp_logicalchannel_bj, (&(SV(LogicalChannel_Bj)->list)),list)//
    af1b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    af1e:	8d 78 fb             	lea    -0x5(%eax),%edi
    af21:	39 7d e0             	cmp    %edi,-0x20(%ebp)
    af24:	0f 85 2d ff ff ff    	jne    ae57 <ResourceAllocation_Algorithm+0x157>
				}			
				break;
			}
		}
	}
	if(*res_length>0)
    af2a:	85 c9                	test   %ecx,%ecx
    af2c:	0f 84 31 ff ff ff    	je     ae63 <ResourceAllocation_Algorithm+0x163>
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    af32:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    af35:	8b 58 05             	mov    0x5(%eax),%ebx
    af38:	83 eb 05             	sub    $0x5,%ebx
    af3b:	39 d8                	cmp    %ebx,%eax
    af3d:	0f 84 20 ff ff ff    	je     ae63 <ResourceAllocation_Algorithm+0x163>
    af43:	8b 7d e8             	mov    -0x18(%ebp),%edi
    af46:	0b 7d ec             	or     -0x14(%ebp),%edi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    af49:	89 75 dc             	mov    %esi,-0x24(%ebp)
    af4c:	89 c6                	mov    %eax,%esi
		}
	}
	if(*res_length>0)
	{
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
    af4e:	0b 7d e4             	or     -0x1c(%ebp),%edi
    af51:	eb 13                	jmp    af66 <ResourceAllocation_Algorithm+0x266>
    af53:	90                   	nop
    af54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    af58:	8b 5b 05             	mov    0x5(%ebx),%ebx
    af5b:	83 eb 05             	sub    $0x5,%ebx
    af5e:	39 de                	cmp    %ebx,%esi
    af60:	0f 84 fd fe ff ff    	je     ae63 <ResourceAllocation_Algorithm+0x163>
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
    af66:	85 ff                	test   %edi,%edi
    af68:	74 ee                	je     af58 <ResourceAllocation_Algorithm+0x258>
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    af6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    af6d:	8d 55 f0             	lea    -0x10(%ebp),%edx
    af70:	89 54 24 0c          	mov    %edx,0xc(%esp)
		temp_mac_buffer=NULL;
		list_for_each_entry(temp_mac_buffer, &(lcbj_lessthan_zero->list),list)//
		{	
			if(statuslength>0 || retxlength>0 ||txlength>0)
			{
				ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength, txlength,res_length);
    af74:	8b 55 ec             	mov    -0x14(%ebp),%edx
    af77:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    af7a:	89 44 24 08          	mov    %eax,0x8(%esp)
    af7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    af81:	89 54 24 04          	mov    %edx,0x4(%esp)
    af85:	89 da                	mov    %ebx,%edx
    af87:	89 04 24             	mov    %eax,(%esp)
    af8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    af8d:	e8 fc ff ff ff       	call   af8e <ResourceAllocation_Algorithm+0x28e>
    af92:	eb c4                	jmp    af58 <ResourceAllocation_Algorithm+0x258>
    af94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    af98:	8b 75 e8             	mov    -0x18(%ebp),%esi
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    af9b:	8d 45 f0             	lea    -0x10(%ebp),%eax
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    af9e:	89 d9                	mov    %ebx,%ecx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    afa0:	89 44 24 0c          	mov    %eax,0xc(%esp)
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    afa4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    afa7:	89 fa                	mov    %edi,%edx
    afa9:	89 74 24 08          	mov    %esi,0x8(%esp)
    afad:	8b 75 ec             	mov    -0x14(%ebp),%esi
    afb0:	89 74 24 04          	mov    %esi,0x4(%esp)
    afb4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    afb7:	89 34 24             	mov    %esi,(%esp)
					break;
    afba:	89 de                	mov    %ebx,%esi
						break;
					}
				}
				else if((temp_logicalchannel_bj->lcbj)>=0)
				{
					ResourceAllocation_foreach_logicalchannel(mac_rlc_report,temp_mac_buffer, temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    afbc:	e8 fc ff ff ff       	call   afbd <ResourceAllocation_Algorithm+0x2bd>
    afc1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					break;
    afc4:	e9 7f fe ff ff       	jmp    ae48 <ResourceAllocation_Algorithm+0x148>
				txlength=(temp_mac_buffer->RlcRequestparams->txQueueSize)+(temp_mac_buffer->RlcRequestparams->txQueueHeader);
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
    afc9:	e8 fc ff ff ff       	call   afca <ResourceAllocation_Algorithm+0x2ca>
    afce:	89 c2                	mov    %eax,%edx
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    afd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    afd3:	66 03 42 0f          	add    0xf(%edx),%ax
    afd7:	66 2b 45 ec          	sub    -0x14(%ebp),%ax
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
    afdb:	8d 4a 13             	lea    0x13(%edx),%ecx
				if((temp_logicalchannel_bj->lcbj)==(MAX_BJ/8+1) &&(statuslength>0 || retxlength>0 ||txlength>0))//
				{
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
    afde:	66 29 f0             	sub    %si,%ax
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    afe1:	8b 75 d8             	mov    -0x28(%ebp),%esi
    afe4:	66 2b 45 e4          	sub    -0x1c(%ebp),%ax
    afe8:	66 89 42 0f          	mov    %ax,0xf(%edx)
    afec:	8b 46 17             	mov    0x17(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    afef:	89 4e 17             	mov    %ecx,0x17(%esi)
	new->next = next;
    aff2:	8b 75 cc             	mov    -0x34(%ebp),%esi
	new->prev = prev;
    aff5:	89 42 17             	mov    %eax,0x17(%edx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
    aff8:	89 72 13             	mov    %esi,0x13(%edx)
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    affb:	89 de                	mov    %ebx,%esi
	new->prev = prev;
	prev->next = new;
    affd:	89 08                	mov    %ecx,(%eax)
    afff:	31 c9                	xor    %ecx,%ecx
					if(*res_length>=(statuslength+retxlength+txlength))//TBSize
					{
						temp_rlc_report=Mac_RlcRequest_copy(temp_mac_buffer->RlcRequestparams);
						temp_rlc_report->statusPduSize=temp_rlc_report->statusPduSize+*res_length-(statuslength+retxlength+txlength);//statusPduSize
						list_add_tail(&(temp_rlc_report->list), &(mac_rlc_report->list));
						*res_length=0;//0
    b001:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
    b008:	e9 3b fe ff ff       	jmp    ae48 <ResourceAllocation_Algorithm+0x148>
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b00d:	8b 75 e8             	mov    -0x18(%ebp),%esi
    b010:	89 d9                	mov    %ebx,%ecx
    b012:	89 fa                	mov    %edi,%edx
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
    b014:	89 44 24 0c          	mov    %eax,0xc(%esp)
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b018:	8b 45 d8             	mov    -0x28(%ebp),%eax
    b01b:	89 74 24 08          	mov    %esi,0x8(%esp)
    b01f:	8b 75 ec             	mov    -0x14(%ebp),%esi
    b022:	89 74 24 04          	mov    %esi,0x4(%esp)
    b026:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    b029:	89 34 24             	mov    %esi,(%esp)
						break;
    b02c:	89 de                	mov    %ebx,%esi
						//temp_logicalchannel_bj->lcbj-=(statuslength+retxlength+txlength);
						break;
					}
					else if(*res_length>=statuslength)//PDU
					{
						ResourceAllocation_logicalchannel_firststatusbuffer(mac_rlc_report,temp_mac_buffer,temp_logicalchannel_bj,statuslength,retxlength,txlength,res_length);
    b02e:	e8 fc ff ff ff       	call   b02f <ResourceAllocation_Algorithm+0x32f>
    b033:	8b 4d f0             	mov    -0x10(%ebp),%ecx
						break;
    b036:	e9 0d fe ff ff       	jmp    ae48 <ResourceAllocation_Algorithm+0x148>
	temp_logicalchannel_bj=NULL;
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
	pos=NULL,p=NULL;
	priority_mac_buffer=PrioritySort();
	list_for_each_entry(temp_mac_buffer, &(priority_mac_buffer->list),list)//
    b03b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
	/*while(mac_rlc_report==0)//
	{
		mac_rlc_report=(RlcBufferRequest *)fsm_mem_alloc(sizeof(RlcBufferRequest));
	}*/
	INIT_LIST_HEAD(&(mac_rlc_report->list));
	temp_logicalchannel_bj=NULL;
    b03e:	31 f6                	xor    %esi,%esi
	res_length=&resource_len;
	statuslength=0,retxlength=0,txlength=0;
    b040:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    b047:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    b04e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    b055:	e9 d0 fe ff ff       	jmp    af2a <ResourceAllocation_Algorithm+0x22a>
    b05a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000b060 <DoResourceAllocation>:
->Output: RLC report
->Special:
*******************************
*/
void DoResourceAllocation(u32 tb_size)//
{
    b060:	55                   	push   %ebp
    b061:	89 e5                	mov    %esp,%ebp
    b063:	83 ec 10             	sub    $0x10,%esp
    b066:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b069:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b06c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b06f:	e8 fc ff ff ff       	call   b070 <DoResourceAllocation+0x10>
    b074:	89 c7                	mov    %eax,%edi
	u32 num;
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
    b076:	b8 04 00 00 00       	mov    $0x4,%eax
    b07b:	e8 fc ff ff ff       	call   b07c <DoResourceAllocation+0x1c>
    b080:	89 c3                	mov    %eax,%ebx
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    b082:	e8 fc ff ff ff       	call   b083 <DoResourceAllocation+0x23>
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b087:	89 da                	mov    %ebx,%edx
	u32 *rlc_report_num=(u32 *)fsm_mem_alloc(sizeof(u32));	
	void *UEmac_Rlc_Report=NULL;
	RLC_Request *rlc_temp=NULL;

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
    b089:	89 c6                	mov    %eax,%esi
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b08b:	89 f8                	mov    %edi,%eax
    b08d:	e8 fc ff ff ff       	call   b08e <DoResourceAllocation+0x2e>
	SV(DATA_WAIT_ALLOCATION)=false;
    b092:	c6 86 5a 01 00 00 00 	movb   $0x0,0x15a(%esi)

	FIN(DoResourceAllocation(u32 tb_size));
	SV_PTR_GET(rlc_mac_sv);
	//RLC_Request *UEmac_Rlc_Report=NULL;//*temp_rlc=NULL;//UE MACRLC
	//SetFrameNo();???????????????????delay	
	UEmac_Rlc_Report=ResourceAllocation_Algorithm(tb_size,rlc_report_num);
    b099:	89 c7                	mov    %eax,%edi
		printk(KERN_INFO" rlc_Report_statusPduSize:%d\n",rlc_temp[j].statusPduSize);
		printk(KERN_INFO" rlc_Report_statusPduHeader:%d\n",rlc_temp[j].statusPduHeader);
	}*/
	//fsm_printf("MAC :%d\n",sizeof(RLC_Request));
	//fsm_do_ioctrl(STRM_TO_RLC,IOCCMD_MACtoRLC_datasend_Allow,UEmac_Rlc_Report,*rlc_report_num);//MACRLC
	fsm_printf("[UEMAC][SCHEDULER]SEND DATA ALLOW IOCTL\n");
    b09b:	c7 04 24 bc 2b 00 00 	movl   $0x2bbc,(%esp)
    b0a2:	e8 fc ff ff ff       	call   b0a3 <DoResourceAllocation+0x43>
	
	PMRLC_TRANSOP_IND ((void *)UEmac_Rlc_Report); 	//modify in 20150804
    b0a7:	89 f8                	mov    %edi,%eax
    b0a9:	e8 fc ff ff ff       	call   b0aa <DoResourceAllocation+0x4a>
	//fsm_mem_free(UEmac_Rlc_Report);//report 
	fsm_mem_free(rlc_report_num);
    b0ae:	89 d8                	mov    %ebx,%eax
    b0b0:	e8 fc ff ff ff       	call   b0b1 <DoResourceAllocation+0x51>
	FOUT;

}
    b0b5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b0b8:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b0bb:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b0be:	89 ec                	mov    %ebp,%esp
    b0c0:	5d                   	pop    %ebp
    b0c1:	c3                   	ret    
    b0c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b0c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b0d0 <Free_Uemac_Scheduler_Resource>:
->Output:
->Special:
*******************************
*/
void Free_Uemac_Scheduler_Resource(void)
{
    b0d0:	55                   	push   %ebp
    b0d1:	89 e5                	mov    %esp,%ebp
    b0d3:	57                   	push   %edi
    b0d4:	56                   	push   %esi
    b0d5:	53                   	push   %ebx
    b0d6:	e8 fc ff ff ff       	call   b0d7 <Free_Uemac_Scheduler_Resource+0x7>
	struct list_head *pos,*p;
	MacBufferStatus *temp_rlc_free=NULL;
	LogicalChannelBj *temp_bj_free=NULL;
	LogicalChannelConfigInfo *temp_lcginfo_free=NULL;//

	SV_PTR_GET(rlc_mac_sv);
    b0db:	e8 fc ff ff ff       	call   b0dc <Free_Uemac_Scheduler_Resource+0xc>
    b0e0:	89 c6                	mov    %eax,%esi
	fsm_mem_free(SV(bsr));
    b0e2:	8b 80 54 01 00 00    	mov    0x154(%eax),%eax
    b0e8:	e8 fc ff ff ff       	call   b0e9 <Free_Uemac_Scheduler_Resource+0x19>
	//fsm_mem_free(Frame_No_Allocation);
	if(SV(Regularbsr)!=NULL)
    b0ed:	8b 86 4c 01 00 00    	mov    0x14c(%esi),%eax
    b0f3:	85 c0                	test   %eax,%eax
    b0f5:	74 0f                	je     b106 <Free_Uemac_Scheduler_Resource+0x36>
	{
		fsm_mem_free(SV(Regularbsr));
    b0f7:	e8 fc ff ff ff       	call   b0f8 <Free_Uemac_Scheduler_Resource+0x28>
		SV(Regularbsr)=NULL;
    b0fc:	c7 86 4c 01 00 00 00 	movl   $0x0,0x14c(%esi)
    b103:	00 00 00 
	}
	if(SV(Periodicbsr)!=NULL)
    b106:	8b 86 50 01 00 00    	mov    0x150(%esi),%eax
    b10c:	85 c0                	test   %eax,%eax
    b10e:	74 0f                	je     b11f <Free_Uemac_Scheduler_Resource+0x4f>
	{
		fsm_mem_free(SV(Periodicbsr));
    b110:	e8 fc ff ff ff       	call   b111 <Free_Uemac_Scheduler_Resource+0x41>
		SV(Periodicbsr)=NULL;
    b115:	c7 86 50 01 00 00 00 	movl   $0x0,0x150(%esi)
    b11c:	00 00 00 
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    b11f:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b125:	8b 58 05             	mov    0x5(%eax),%ebx
    b128:	83 c0 05             	add    $0x5,%eax
    b12b:	39 c3                	cmp    %eax,%ebx
    b12d:	8b 3b                	mov    (%ebx),%edi
    b12f:	75 0b                	jne    b13c <Free_Uemac_Scheduler_Resource+0x6c>
    b131:	eb 37                	jmp    b16a <Free_Uemac_Scheduler_Resource+0x9a>
    b133:	90                   	nop
    b134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b138:	89 fb                	mov    %edi,%ebx
    b13a:	89 d7                	mov    %edx,%edi
	{
		temp_rlc_free=list_entry(pos,MacBufferStatus,list);
		fsm_mem_free(temp_rlc_free->RlcRequestparams);
    b13c:	8b 43 fc             	mov    -0x4(%ebx),%eax
    b13f:	e8 fc ff ff ff       	call   b140 <Free_Uemac_Scheduler_Resource+0x70>
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b144:	8b 53 04             	mov    0x4(%ebx),%edx
		list_del_init(&(temp_rlc_free->list));
    b147:	8d 43 fb             	lea    -0x5(%ebx),%eax
    b14a:	8b 0b                	mov    (%ebx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b14c:	89 51 04             	mov    %edx,0x4(%ecx)
	prev->next = next;
    b14f:	89 0a                	mov    %ecx,(%edx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b151:	89 1b                	mov    %ebx,(%ebx)
	list->prev = list;
    b153:	89 5b 04             	mov    %ebx,0x4(%ebx)
		fsm_mem_free(temp_rlc_free);
    b156:	e8 fc ff ff ff       	call   b157 <Free_Uemac_Scheduler_Resource+0x87>
	if(SV(Periodicbsr)!=NULL)
	{
		fsm_mem_free(SV(Periodicbsr));
		SV(Periodicbsr)=NULL;
	}
	list_for_each_safe(pos,p,(&(SV(MacBuffer_RLC)->list)))//
    b15b:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b161:	8b 17                	mov    (%edi),%edx
    b163:	83 c0 05             	add    $0x5,%eax
    b166:	39 c7                	cmp    %eax,%edi
    b168:	75 ce                	jne    b138 <Free_Uemac_Scheduler_Resource+0x68>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b16a:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b170:	8b 50 05             	mov    0x5(%eax),%edx
    b173:	83 c0 05             	add    $0x5,%eax
    b176:	39 c2                	cmp    %eax,%edx
    b178:	8b 1a                	mov    (%edx),%ebx
    b17a:	75 06                	jne    b182 <Free_Uemac_Scheduler_Resource+0xb2>
    b17c:	eb 2a                	jmp    b1a8 <Free_Uemac_Scheduler_Resource+0xd8>
    b17e:	66 90                	xchg   %ax,%ax
    b180:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b182:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
    b185:	8d 42 fb             	lea    -0x5(%edx),%eax
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b188:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b18a:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b18d:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b18f:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b191:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_bj_free=list_entry(pos,LogicalChannelBj,list);
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
    b194:	e8 fc ff ff ff       	call   b195 <Free_Uemac_Scheduler_Resource+0xc5>
		list_del_init(&(temp_rlc_free->list));
		fsm_mem_free(temp_rlc_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Bj)->list)))//
    b199:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b19f:	8b 1b                	mov    (%ebx),%ebx
    b1a1:	83 c0 05             	add    $0x5,%eax
    b1a4:	39 c7                	cmp    %eax,%edi
    b1a6:	75 d8                	jne    b180 <Free_Uemac_Scheduler_Resource+0xb0>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b1a8:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b1ae:	8b 50 11             	mov    0x11(%eax),%edx
    b1b1:	83 c0 11             	add    $0x11,%eax
    b1b4:	39 c2                	cmp    %eax,%edx
    b1b6:	8b 1a                	mov    (%edx),%ebx
    b1b8:	75 08                	jne    b1c2 <Free_Uemac_Scheduler_Resource+0xf2>
    b1ba:	eb 2c                	jmp    b1e8 <Free_Uemac_Scheduler_Resource+0x118>
    b1bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b1c0:	89 fa                	mov    %edi,%edx
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    b1c2:	8b 4a 04             	mov    0x4(%edx),%ecx
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
    b1c5:	8d 42 ef             	lea    -0x11(%edx),%eax
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b1c8:	89 df                	mov    %ebx,%edi
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    b1ca:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = next;
    b1cd:	89 19                	mov    %ebx,(%ecx)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b1cf:	89 12                	mov    %edx,(%edx)
	list->prev = list;
    b1d1:	89 52 04             	mov    %edx,0x4(%edx)
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
    b1d4:	e8 fc ff ff ff       	call   b1d5 <Free_Uemac_Scheduler_Resource+0x105>
		list_del_init(&(temp_bj_free->list));
		fsm_mem_free(temp_bj_free);
	}
	pos=NULL;
	p=NULL;
	list_for_each_safe(pos,p,(&(SV(LogicalChannel_Config)->list)))//
    b1d9:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b1df:	8b 1b                	mov    (%ebx),%ebx
    b1e1:	83 c0 11             	add    $0x11,%eax
    b1e4:	39 c7                	cmp    %eax,%edi
    b1e6:	75 d8                	jne    b1c0 <Free_Uemac_Scheduler_Resource+0xf0>
	{
		temp_lcginfo_free=list_entry(pos,LogicalChannelConfigInfo,list);
		list_del_init(&(temp_lcginfo_free->list));
		fsm_mem_free(temp_lcginfo_free);
	}
	fsm_mem_free(SV(MacBuffer_RLC));
    b1e8:	8b 86 48 01 00 00    	mov    0x148(%esi),%eax
    b1ee:	e8 fc ff ff ff       	call   b1ef <Free_Uemac_Scheduler_Resource+0x11f>
	fsm_mem_free(SV(LogicalChannel_Bj));
    b1f3:	8b 86 44 01 00 00    	mov    0x144(%esi),%eax
    b1f9:	e8 fc ff ff ff       	call   b1fa <Free_Uemac_Scheduler_Resource+0x12a>
	fsm_mem_free(SV(LogicalChannel_Config));
    b1fe:	8b 86 40 01 00 00    	mov    0x140(%esi),%eax
    b204:	e8 fc ff ff ff       	call   b205 <Free_Uemac_Scheduler_Resource+0x135>
	
	FOUT;
}
    b209:	5b                   	pop    %ebx
    b20a:	5e                   	pop    %esi
    b20b:	5f                   	pop    %edi
    b20c:	5d                   	pop    %ebp
    b20d:	c3                   	ret    
    b20e:	66 90                	xchg   %ax,%ax

0000b210 <GetRbsize>:
->Output:
->Special:
*******************************
*/
u32 GetRbsize(u32  channel_bandwidth)
{
    b210:	55                   	push   %ebp
    b211:	89 e5                	mov    %esp,%ebp
    b213:	83 ec 04             	sub    $0x4,%esp
    b216:	e8 fc ff ff ff       	call   b217 <GetRbsize+0x7>

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b21b:	83 e8 03             	sub    $0x3,%eax
    b21e:	83 f8 11             	cmp    $0x11,%eax
    b221:	76 15                	jbe    b238 <GetRbsize+0x28>
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
    b223:	c7 04 24 e8 2b 00 00 	movl   $0x2be8,(%esp)
    b22a:	e8 fc ff ff ff       	call   b22b <GetRbsize+0x1b>
    b22f:	31 c0                	xor    %eax,%eax
	}
	//}
	FRET(rbsize);
}
    b231:	c9                   	leave  
    b232:	c3                   	ret    
    b233:	90                   	nop
    b234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b238:	ff 24 85 e0 03 00 00 	jmp    *0x3e0(,%eax,4)
    b23f:	90                   	nop
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
		case 20  : rbsize=100;break;
    b240:	b8 64 00 00 00       	mov    $0x64,%eax
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b245:	c9                   	leave  
    b246:	c3                   	ret    
    b247:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b248:	b8 0f 00 00 00       	mov    $0xf,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b24d:	c9                   	leave  
    b24e:	c3                   	ret    
    b24f:	90                   	nop

	/*if(channel_bandwidth==1.4)//modified by lhl float
		rbsize=6;*/
	//else
	// {
	switch(channel_bandwidth)
    b250:	b8 19 00 00 00       	mov    $0x19,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b255:	c9                   	leave  
    b256:	c3                   	ret    
    b257:	90                   	nop
	// {
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
    b258:	b8 32 00 00 00       	mov    $0x32,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b25d:	c9                   	leave  
    b25e:	c3                   	ret    
    b25f:	90                   	nop
	switch(channel_bandwidth)
	{
		case 3   : rbsize=15;break;
		case 5   : rbsize=25;break;
		case 10  : rbsize=50;break;
		case 15  : rbsize=75;break;
    b260:	b8 4b 00 00 00       	mov    $0x4b,%eax
		case 20  : rbsize=100;break;
		default  : fsm_printf("[UEMAC][getrbsize]6\n");break;
	}
	//}
	FRET(rbsize);
}
    b265:	c9                   	leave  
    b266:	c3                   	ret    
    b267:	89 f6                	mov    %esi,%esi
    b269:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b270 <DoReceiveULgrant_Tbsize>:
    //???????????????? delay
    FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    b270:	55                   	push   %ebp
    b271:	89 e5                	mov    %esp,%ebp
    b273:	83 ec 20             	sub    $0x20,%esp
    b276:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b279:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b27c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b27f:	e8 fc ff ff ff       	call   b280 <DoReceiveULgrant_Tbsize+0x10>
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b284:	89 c7                	mov    %eax,%edi
    u16 mcs=receive_ulgrant.m_mcs;//20140725
    b286:	c1 e8 0f             	shr    $0xf,%eax
    b289:	83 e0 1f             	and    $0x1f,%eax
    b28c:	88 45 e4             	mov    %al,-0x1c(%ebp)
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b28f:	c1 ef 02             	shr    $0x2,%edi
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b292:	e8 fc ff ff ff       	call   b293 <DoReceiveULgrant_Tbsize+0x23>
}*/

u32 DoReceiveULgrant_Tbsize(Regular_ULgrant receive_ulgrant)
{
    FIN(DoReceiveULgrant_Tbsize(u32 receive_ulgrant));
    u16 RIV=receive_ulgrant.RIV;//(receive_ulgrant>>16)&(u32)(My_Pow(2,13)-1);
    b297:	66 81 e7 ff 1f       	and    $0x1fff,%di
    u16 temp_frame; 
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    b29c:	89 c3                	mov    %eax,%ebx
    rb_number=GetRbsize(BANDWIDTH);
    b29e:	b8 14 00 00 00       	mov    $0x14,%eax
    b2a3:	e8 fc ff ff ff       	call   b2a4 <DoReceiveULgrant_Tbsize+0x34>
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b2a8:	31 d2                	xor    %edx,%edx
    u16 tmp=0;
    u16 RB_length=0;
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    b2aa:	89 c6                	mov    %eax,%esi
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b2ac:	89 f8                	mov    %edi,%eax
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b2ae:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b2b2:	66 f7 f6             	div    %si
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b2b5:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b2bb:	8d 4e 01             	lea    0x1(%esi),%ecx
    u16 rb_number;
	unsigned int itbs;
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    b2be:	01 c2                	add    %eax,%edx
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    b2c0:	66 29 c1             	sub    %ax,%cx
    SV_PTR_GET(rlc_mac_sv);
    rb_number=GetRbsize(BANDWIDTH);
    //tmp=My_Floor(RIV/rb_number)+RIV%rb_number;
    tmp=RIV/rb_number+RIV%rb_number;
    if(tmp<rb_number)
        RB_length=RIV/rb_number+1;
    b2c3:	83 c0 01             	add    $0x1,%eax
    b2c6:	66 39 d6             	cmp    %dx,%si
    b2c9:	0f 47 c8             	cmova  %eax,%ecx
    else
        //RB_length=rb_number-My_Floor(RIV/rb_number)+1;
        RB_length=rb_number-RIV/rb_number+1;//20140514modified by lhl float
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b2cc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b2d0:	66 c7 43 0c 00 00    	movw   $0x0,0xc(%ebx)
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME2 && (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME7)
    b2d6:	8d 50 01             	lea    0x1(%eax),%edx
    b2d9:	83 fa 04             	cmp    $0x4,%edx
    b2dc:	77 3a                	ja     b318 <DoReceiveULgrant_Tbsize+0xa8>
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
    b2de:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b2e2:	66 c7 43 10 07 00    	movw   $0x7,0x10(%ebx)
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b2e8:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b2ec:	0f b7 c9             	movzwl %cx,%ecx
    b2ef:	8d 44 49 fd          	lea    -0x3(%ecx,%ecx,2),%eax
    b2f3:	8d 04 c0             	lea    (%eax,%eax,8),%eax
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
	}
	itbs = Ul_McsToItbsize[mcs];
    b2f6:	83 e2 1f             	and    $0x1f,%edx
	FRET(TransportBlockSizeTable[RB_length-1][itbs]);
    b2f9:	03 04 95 40 04 00 00 	add    0x440(,%edx,4),%eax
    b300:	8b 34 85 c0 04 00 00 	mov    0x4c0(,%eax,4),%esi
    //FRET(TransportBlockSizeTable[RB_length-1][mcs]);
}
    b307:	89 f0                	mov    %esi,%eax
    b309:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b30c:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b30f:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b312:	89 ec                	mov    %ebp,%esp
    b314:	5d                   	pop    %ebp
    b315:	c3                   	ret    
    b316:	66 90                	xchg   %ax,%ax
	//27
	{
		SV(ue_schedule_frame.frameNo)=temp_frame;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>UL_SUBFRAME7 && (SCHEDULE_ADVANCE+temp_subframe)<=9)
    b318:	8d 50 fc             	lea    -0x4(%eax),%edx
    b31b:	83 fa 01             	cmp    $0x1,%edx
    b31e:	76 26                	jbe    b346 <DoReceiveULgrant_Tbsize+0xd6>
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b320:	83 c0 04             	add    $0x4,%eax
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
	}
	else//
	{
		//fsm_printf("[UE MAC][DoReceiveULgrant_Tbsize]error\n");
		FRET(0);
    b323:	31 f6                	xor    %esi,%esi
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b325:	83 f8 09             	cmp    $0x9,%eax
    //???????????????? delay
	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if( (SCHEDULE_ADVANCE+temp_subframe)<=UL_SUBFRAME2)//2
    b328:	89 45 e0             	mov    %eax,-0x20(%ebp)
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
	}
	else if( (SCHEDULE_ADVANCE+temp_subframe)>9 &&  (SCHEDULE_ADVANCE+temp_subframe)%10<=2)
    b32b:	7e da                	jle    b307 <DoReceiveULgrant_Tbsize+0x97>
    b32d:	ba 67 66 66 66       	mov    $0x66666667,%edx
    b332:	f7 ea                	imul   %edx
    b334:	c1 ea 02             	shr    $0x2,%edx
    b337:	8d 04 92             	lea    (%edx,%edx,4),%eax
    b33a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    b33d:	01 c0                	add    %eax,%eax
    b33f:	29 c2                	sub    %eax,%edx
    b341:	83 fa 02             	cmp    $0x2,%edx
    b344:	7f c1                	jg     b307 <DoReceiveULgrant_Tbsize+0x97>
	//2
	{
		SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b346:	83 c7 01             	add    $0x1,%edi
    b349:	66 89 7b 0e          	mov    %di,0xe(%ebx)
		SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b34d:	66 c7 43 10 02 00    	movw   $0x2,0x10(%ebx)
    b353:	eb 93                	jmp    b2e8 <DoReceiveULgrant_Tbsize+0x78>
    b355:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    b359:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b360 <My_Pow>:
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b360:	55                   	push   %ebp
    b361:	89 e5                	mov    %esp,%ebp
    b363:	53                   	push   %ebx
    b364:	e8 fc ff ff ff       	call   b365 <My_Pow+0x5>
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b369:	85 d2                	test   %edx,%edx
->Output:numn
->Special:
*******************************
*/
u32 My_Pow(u32 num,u32 n)//numnn
{
    b36b:	89 c1                	mov    %eax,%ecx
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b36d:	b8 01 00 00 00       	mov    $0x1,%eax
    b372:	74 16                	je     b38a <My_Pow+0x2a>
    b374:	bb 01 00 00 00       	mov    $0x1,%ebx
    b379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b380:	83 c3 01             	add    $0x1,%ebx
		powint*=num;
    b383:	0f af c1             	imul   %ecx,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b386:	39 da                	cmp    %ebx,%edx
    b388:	73 f6                	jae    b380 <My_Pow+0x20>
		powint*=num;
	FRET(powint);
}
    b38a:	5b                   	pop    %ebx
    b38b:	5d                   	pop    %ebp
    b38c:	c3                   	ret    
    b38d:	8d 76 00             	lea    0x0(%esi),%esi

0000b390 <My_Log2>:
->Output:log2(rb)
->Special:
*******************************
*/
u32 My_Log2(u32 rb)
{
    b390:	55                   	push   %ebp
    b391:	89 e5                	mov    %esp,%ebp
    b393:	83 ec 04             	sub    $0x4,%esp
    b396:	e8 fc ff ff ff       	call   b397 <My_Log2+0x7>
	ret=0;
	switch(rb)//20140514modified by lhl float
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
    b39b:	ba 98 20 00 00       	mov    $0x2098,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3a0:	83 f8 19             	cmp    $0x19,%eax
    b3a3:	74 23                	je     b3c8 <My_Log2+0x38>
    b3a5:	76 29                	jbe    b3d0 <My_Log2+0x40>
    b3a7:	83 f8 4b             	cmp    $0x4b,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
    b3aa:	ba d5 2c 00 00       	mov    $0x2cd5,%edx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3af:	74 17                	je     b3c8 <My_Log2+0x38>
    b3b1:	83 f8 64             	cmp    $0x64,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
    b3b4:	66 ba 0e 30          	mov    $0x300e,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3b8:	74 0e                	je     b3c8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b3ba:	c7 04 24 1c 2c 00 00 	movl   $0x2c1c,(%esp)
    b3c1:	e8 fc ff ff ff       	call   b3c2 <My_Log2+0x32>
    b3c6:	31 d2                	xor    %edx,%edx
	}
	FRET(ret);
}//2
    b3c8:	89 d0                	mov    %edx,%eax
    b3ca:	c9                   	leave  
    b3cb:	c3                   	ret    
    b3cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3d0:	83 f8 06             	cmp    $0x6,%eax
	{
		case 6   : ret=4392 ;break;
    b3d3:	66 ba 28 11          	mov    $0x1128,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3d7:	74 ef                	je     b3c8 <My_Log2+0x38>
    b3d9:	83 f8 0f             	cmp    $0xf,%eax
	{
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
    b3dc:	66 ba fb 1a          	mov    $0x1afb,%dx
	u32 ret;
	FIN(My_Log2(u32 rb));

	//double ret;
	ret=0;
	switch(rb)//20140514modified by lhl float
    b3e0:	74 e6                	je     b3c8 <My_Log2+0x38>
		case 6   : ret=4392 ;break;
		case 15  : ret=6907;break;
		case 25  : ret=8344;break;
		case 75  : ret=11477;break;
		case 100 : ret=12302;break;
		default  :fsm_printf("[UEMAC][my_log2]RB number error ");break;
    b3e2:	c7 04 24 1c 2c 00 00 	movl   $0x2c1c,(%esp)
    b3e9:	e8 fc ff ff ff       	call   b3ea <My_Log2+0x5a>
    b3ee:	31 d2                	xor    %edx,%edx
    b3f0:	eb d6                	jmp    b3c8 <My_Log2+0x38>
    b3f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    b3f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000b400 <DoReceiveRARULgrant_Tbsize>:
->Output:
->Special:
*******************************
*/
u32 DoReceiveRARULgrant_Tbsize(RAR_ULgrant *receive_rar_ulgrant)
{
    b400:	55                   	push   %ebp
    b401:	89 e5                	mov    %esp,%ebp
    b403:	57                   	push   %edi
    b404:	56                   	push   %esi
    b405:	53                   	push   %ebx
    b406:	83 ec 1c             	sub    $0x1c,%esp
    b409:	e8 fc ff ff ff       	call   b40a <DoReceiveRARULgrant_Tbsize+0xa>
    b40e:	89 c6                	mov    %eax,%esi
	u16 rb_number;
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
    b410:	e8 fc ff ff ff       	call   b411 <DoReceiveRARULgrant_Tbsize+0x11>
    b415:	89 c7                	mov    %eax,%edi
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
    b417:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b41b:	c0 e8 03             	shr    $0x3,%al
    b41e:	83 e0 0f             	and    $0xf,%eax
    b421:	88 45 f1             	mov    %al,-0xf(%ebp)
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b424:	0f b6 06             	movzbl (%esi),%eax
    b427:	89 c3                	mov    %eax,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b429:	d0 e8                	shr    %al
	u16 temp_log;

	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
    b42b:	83 e3 01             	and    $0x1,%ebx
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
    b42e:	0f b6 d0             	movzbl %al,%edx
    b431:	0f b6 46 01          	movzbl 0x1(%esi),%eax
    b435:	83 e0 07             	and    $0x7,%eax
    b438:	c1 e0 07             	shl    $0x7,%eax
    b43b:	09 d0                	or     %edx,%eax
    b43d:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b441:	0f b6 56 02          	movzbl 0x2(%esi),%edx
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b445:	b8 14 00 00 00       	mov    $0x14,%eax
	FIN(DoReceiveRARULgrant_Tbsize(int receive_rar_ulgrant));
	SV_PTR_GET(rlc_mac_sv);
	u8 mcs=receive_rar_ulgrant->m_mcs;//20140725
	bool hopping=receive_rar_ulgrant->m_hoppingflag;
	u16 rb_assignment=receive_rar_ulgrant->rb_assignment;//20140725
	bool ulDelay=receive_rar_ulgrant->m_ulDelay;
    b44a:	c0 ea 02             	shr    $0x2,%dl
    b44d:	83 e2 01             	and    $0x1,%edx
    b450:	88 55 f0             	mov    %dl,-0x10(%ebp)
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b453:	e8 fc ff ff ff       	call   b454 <DoReceiveRARULgrant_Tbsize+0x54>
	if(rb_number<=44)
    b458:	66 83 f8 2c          	cmp    $0x2c,%ax
	u16 tmp=0;
	u16 RB_length=0;
	u16 temp_subframe;
    	u16 temp_frame; 
		
	rb_number=GetRbsize(BANDWIDTH);
    b45c:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	if(rb_number<=44)
    b460:	0f 86 6a 01 00 00    	jbe    b5d0 <DoReceiveRARULgrant_Tbsize+0x1d0>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b466:	84 db                	test   %bl,%bl
    b468:	0f 85 b2 00 00 00    	jne    b520 <DoReceiveRARULgrant_Tbsize+0x120>
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b46e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b472:	bb 0a 00 00 00       	mov    $0xa,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b477:	e8 fc ff ff ff       	call   b478 <DoReceiveRARULgrant_Tbsize+0x78>
    b47c:	31 d2                	xor    %edx,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b47e:	b8 01 00 00 00       	mov    $0x1,%eax
    b483:	b9 01 00 00 00       	mov    $0x1,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b488:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b48b:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b48d:	39 d8                	cmp    %ebx,%eax
    b48f:	76 f7                	jbe    b488 <DoReceiveRARULgrant_Tbsize+0x88>
    b491:	83 e9 01             	sub    $0x1,%ecx
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
    b494:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b498:	09 d1                	or     %edx,%ecx
    b49a:	31 d2                	xor    %edx,%edx
    b49c:	89 c8                	mov    %ecx,%eax
    b49e:	66 f7 75 f2          	divw   -0xe(%ebp)
    b4a2:	89 d3                	mov    %edx,%ebx
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b4a4:	89 c8                	mov    %ecx,%eax
    b4a6:	31 d2                	xor    %edx,%edx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b4a8:	0f b7 4d f2          	movzwl -0xe(%ebp),%ecx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b4ac:	66 f7 75 f2          	divw   -0xe(%ebp)
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
    b4b0:	83 c1 01             	add    $0x1,%ecx
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b4b3:	66 29 c1             	sub    %ax,%cx
		temp_move=rb_assignment&(int)(My_Pow(2,10-ulhopping_num)-1);
		RAR_RIV=temp_move | (temp<<(10-ulhopping_num+positon));//20141112 LHL
		//RAR_RIV=temp_move | (temp<<(10-ulhopping_num-positon));
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
    b4b6:	01 c3                	add    %eax,%ebx
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b4b8:	66 39 5d f2          	cmp    %bx,-0xe(%ebp)
    b4bc:	8d 50 01             	lea    0x1(%eax),%edx
	else
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
    b4bf:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
    b4c3:	66 c7 47 0c 00 00    	movw   $0x0,0xc(%edi)
	}
	//tmp=My_Floor(RAR_RIV/rb_number)+RAR_RIV%rb_number;
	tmp=RAR_RIV/rb_number+RAR_RIV%rb_number;//20140514modified by lhl float
	if(tmp<rb_number)
		//RB_length=My_Floor(RAR_RIV/rb_number)+1;//20140514modified by lhl float
		RB_length=RAR_RIV/rb_number+1;//rb_lengthLCRB
    b4c9:	0f 46 d1             	cmovbe %ecx,%edx
		RB_length=rb_number-RAR_RIV/rb_number+1;
	//temp_subframe=SV(sys_frame.subframeNo);
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
    b4cc:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
	if(ulDelay == true)//?????????????????????????????,delay
    b4d0:	80 7d f0 00          	cmpb   $0x0,-0x10(%ebp)
	//temp_frame=SV(sys_frame.frameNo);

	temp_subframe=SV(recv_frame).subframeNo;//ULGRNT
	temp_frame=SV(recv_frame).frameNo;
	SV(recv_frame).subframeNo=0;//
	SV(recv_frame).frameNo=0;
    b4d4:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
	if(ulDelay == true)//?????????????????????????????,delay
    b4da:	0f 84 b8 00 00 00    	je     b598 <DoReceiveRARULgrant_Tbsize+0x198>
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b4e0:	66 83 f8 01          	cmp    $0x1,%ax
    b4e4:	76 19                	jbe    b4ff <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b4e6:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b4e9:	66 83 fb 04          	cmp    $0x4,%bx
    b4ed:	0f 86 c5 00 00 00    	jbe    b5b8 <DoReceiveRARULgrant_Tbsize+0x1b8>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b4f3:	83 e8 07             	sub    $0x7,%eax
    b4f6:	66 83 f8 02          	cmp    $0x2,%ax
    b4fa:	77 0d                	ja     b509 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b4fc:	83 c1 01             	add    $0x1,%ecx
    b4ff:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
    b503:	66 c7 47 10 07 00    	movw   $0x7,0x10(%edi)
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b509:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
    b50d:	0f b7 d2             	movzwl %dx,%edx
}
    b510:	83 c4 1c             	add    $0x1c,%esp
    b513:	5b                   	pop    %ebx
    b514:	5e                   	pop    %esi
    b515:	5f                   	pop    %edi
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b516:	6b c0 54             	imul   $0x54,%eax,%eax
}
    b519:	5d                   	pop    %ebp
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
	}
	FRET(SUB_CARRIER*OFDM*mcs*RB_length);
    b51a:	0f af c2             	imul   %edx,%eax
}
    b51d:	c3                   	ret    
    b51e:	66 90                	xchg   %ax,%ax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b520:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b525:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b529:	19 c9                	sbb    %ecx,%ecx
    b52b:	f7 d1                	not    %ecx
    b52d:	83 c1 09             	add    $0x9,%ecx
    b530:	66 83 7d f2 32       	cmpw   $0x32,-0xe(%ebp)
    b535:	89 cb                	mov    %ecx,%ebx
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b537:	89 4d d8             	mov    %ecx,-0x28(%ebp)
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b53a:	19 f6                	sbb    %esi,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b53c:	e8 fc ff ff ff       	call   b53d <DoReceiveRARULgrant_Tbsize+0x13d>
    b541:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b546:	8b 4d d8             	mov    -0x28(%ebp),%ecx
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
	}
	else
	{
		if((hopping==true)&&(rb_number>49))
    b549:	83 c6 02             	add    $0x2,%esi
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b54c:	f7 e2                	mul    %edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b54e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b552:	c1 ea 06             	shr    $0x6,%edx
    b555:	83 ea 09             	sub    $0x9,%edx
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b558:	d3 f8                	sar    %cl,%eax
			ulhopping_num=2;
		else if((hopping==true)&&(rb_number<=49))
			ulhopping_num=1;
		if(hopping==false)
			ulhopping_num=0;
		positon=((My_Log2(rb_number))/1000+1)-10;
    b55a:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
		temp=(rb_assignment>>(10-ulhopping_num))&(int)(My_Pow(2,ulhopping_num)-1);
    b55e:	ba 01 00 00 00       	mov    $0x1,%edx
    b563:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
    b567:	b8 01 00 00 00       	mov    $0x1,%eax
    b56c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b570:	83 c2 01             	add    $0x1,%edx
		powint*=num;
    b573:	01 c0                	add    %eax,%eax
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b575:	39 d6                	cmp    %edx,%esi
    b577:	73 f7                	jae    b570 <DoReceiveRARULgrant_Tbsize+0x170>
    b579:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
    b57d:	83 e8 01             	sub    $0x1,%eax
    b580:	66 23 45 dc          	and    -0x24(%ebp),%ax
    b584:	29 f2                	sub    %esi,%edx
    b586:	0f b7 c0             	movzwl %ax,%eax
    b589:	8d 4a 0a             	lea    0xa(%edx),%ecx
    b58c:	89 c2                	mov    %eax,%edx
    b58e:	d3 e2                	shl    %cl,%edx
    b590:	e9 e9 fe ff ff       	jmp    b47e <DoReceiveRARULgrant_Tbsize+0x7e>
    b595:	8d 76 00             	lea    0x0(%esi),%esi
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
	}
	else
	{
		if(temp_subframe>=0 && temp_subframe<UL_SUBFRAME2)//0-2
    b598:	66 83 f8 01          	cmp    $0x1,%ax
    b59c:	76 1d                	jbe    b5bb <DoReceiveRARULgrant_Tbsize+0x1bb>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
		}
		else if(temp_subframe>=UL_SUBFRAME2 && temp_subframe<UL_SUBFRAME7)//27
    b59e:	8d 58 fe             	lea    -0x2(%eax),%ebx
    b5a1:	66 83 fb 04          	cmp    $0x4,%bx
    b5a5:	0f 86 54 ff ff ff    	jbe    b4ff <DoReceiveRARULgrant_Tbsize+0xff>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame;
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME7;
		}
		else if(temp_subframe>=UL_SUBFRAME7 && temp_subframe<=9)//79
    b5ab:	83 e8 07             	sub    $0x7,%eax
    b5ae:	66 83 f8 02          	cmp    $0x2,%ax
    b5b2:	0f 87 51 ff ff ff    	ja     b509 <DoReceiveRARULgrant_Tbsize+0x109>
		{
			SV(ue_schedule_frame.frameNo)=temp_frame+1;
    b5b8:	83 c1 01             	add    $0x1,%ecx
    b5bb:	66 89 4f 0e          	mov    %cx,0xe(%edi)
			SV(ue_schedule_frame.subframeNo)=UL_SUBFRAME2;
    b5bf:	66 c7 47 10 02 00    	movw   $0x2,0x10(%edi)
    b5c5:	e9 3f ff ff ff       	jmp    b509 <DoReceiveRARULgrant_Tbsize+0x109>
    b5ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
    b5d0:	0f b7 c0             	movzwl %ax,%eax
    b5d3:	e8 fc ff ff ff       	call   b5d4 <DoReceiveRARULgrant_Tbsize+0x1d4>
		positon=temp_log/1000+1;
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b5d8:	b9 01 00 00 00       	mov    $0x1,%ecx
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b5dd:	66 c1 e8 03          	shr    $0x3,%ax
    b5e1:	0f b7 d0             	movzwl %ax,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b5e4:	b8 01 00 00 00       	mov    $0x1,%eax
	rb_number=GetRbsize(BANDWIDTH);
	if(rb_number<=44)
	{
		//positon=My_Ceil(My_Log2(rb_number));//20140514modified by lhl float
		temp_log=My_Log2(rb_number);
		positon=temp_log/1000+1;
    b5e9:	69 d2 c5 20 00 00    	imul   $0x20c5,%edx,%edx
    b5ef:	c1 ea 14             	shr    $0x14,%edx
    b5f2:	83 c2 01             	add    $0x1,%edx
		RAR_RIV=rb_assignment&(int)(My_Pow(2,positon)-1);
    b5f5:	0f b7 d2             	movzwl %dx,%edx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b5f8:	83 c0 01             	add    $0x1,%eax
		powint*=num;
    b5fb:	01 c9                	add    %ecx,%ecx
{
	int i;
	FIN(My_Pow(u32 num,u32 n));
	int powint=1;	

	for(i=1;i<=n;i++)
    b5fd:	39 c2                	cmp    %eax,%edx
    b5ff:	73 f7                	jae    b5f8 <DoReceiveRARULgrant_Tbsize+0x1f8>
    b601:	83 e9 01             	sub    $0x1,%ecx
    b604:	31 d2                	xor    %edx,%edx
    b606:	66 23 4d ee          	and    -0x12(%ebp),%cx
    b60a:	89 c8                	mov    %ecx,%eax
    b60c:	66 f7 75 f2          	divw   -0xe(%ebp)
    b610:	89 d3                	mov    %edx,%ebx
    b612:	e9 8d fe ff ff       	jmp    b4a4 <DoReceiveRARULgrant_Tbsize+0xa4>
    b617:	90                   	nop
    b618:	90                   	nop
    b619:	90                   	nop
    b61a:	90                   	nop
    b61b:	90                   	nop
    b61c:	90                   	nop
    b61d:	90                   	nop
    b61e:	90                   	nop
    b61f:	90                   	nop

0000b620 <creat_subhead.isra.0>:
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b620:	55                   	push   %ebp
    b621:	89 e5                	mov    %esp,%ebp
    b623:	83 ec 10             	sub    $0x10,%esp
    b626:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    b629:	89 75 f8             	mov    %esi,-0x8(%ebp)
    b62c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    b62f:	e8 fc ff ff ff       	call   b630 <creat_subhead.isra.0+0x10>
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b634:	83 38 7f             	cmpl   $0x7f,(%eax)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
static void creat_subhead(FSM_PKT * skb, void **ptr, void **preptr, u8 lcid, u32 *data)
    b637:	8b 75 0c             	mov    0xc(%ebp),%esi
    b63a:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
    b63e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
{
	struct MRLC_subHead_fif_IciMsg * subfif;
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
    b641:	76 3d                	jbe    b680 <creat_subhead.isra.0+0x60>
		*data += 2;
		//fsm_printf("the data is %d\n",  *data);
	}
	else
	{
		subfif= (MRLC_subHead_fif_IciMsg *)*ptr;
    b643:	8b 1a                	mov    (%edx),%ebx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
    b645:	83 e7 1f             	and    $0x1f,%edi
    b648:	83 cf 20             	or     $0x20,%edi
    b64b:	89 f9                	mov    %edi,%ecx
    b64d:	88 0b                	mov    %cl,(%ebx)
		subfif->fandl1 = skb->len>>8;
    b64f:	8b 38                	mov    (%eax),%edi
    b651:	c1 ef 08             	shr    $0x8,%edi
		subfif->fandl1 |= 0x80;
    b654:	83 cf 80             	or     $0xffffff80,%edi
    b657:	89 f9                	mov    %edi,%ecx
    b659:	88 4b 01             	mov    %cl,0x1(%ebx)
		subfif->fandl2 = skb->len&0xff;
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b65c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
		subfif->fix.R1 = subfif->fix.R2 = 0;
		subfif->fix.E = 1;
		subfif->fix.lcid = lcid;
		subfif->fandl1 = skb->len>>8;
		subfif->fandl1 |= 0x80;
		subfif->fandl2 = skb->len&0xff;
    b65f:	8b 00                	mov    (%eax),%eax
    b661:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_octets_print(&subfif->fandl1,2);
		//subfif->fandl = subfif->fandl;
		*preptr = subfif;
    b664:	89 19                	mov    %ebx,(%ecx)
		*ptr = subfif + 1;
    b666:	83 c3 03             	add    $0x3,%ebx
    b669:	89 1a                	mov    %ebx,(%edx)
		*data += 3;
    b66b:	83 06 03             	addl   $0x3,(%esi)
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b66e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b671:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b674:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b677:	89 ec                	mov    %ebp,%esp
    b679:	5d                   	pop    %ebp
    b67a:	c3                   	ret    
    b67b:	90                   	nop
    b67c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	struct MRLC_subHead_sev_IciMsg *subsev;
	
	//fsm_printf("entering creat_subhead\n");
	if(skb->len < 128)
	{
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
    b680:	8b 0a                	mov    (%edx),%ecx
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
    b682:	83 e7 1f             	and    $0x1f,%edi
    b685:	83 cf 20             	or     $0x20,%edi
    b688:	89 fb                	mov    %edi,%ebx
    b68a:	88 19                	mov    %bl,(%ecx)
		subsev->fandl = skb->len;
    b68c:	8b 00                	mov    (%eax),%eax
		subsev->fandl  &= 0x7f;
		*preptr = subsev;
		*ptr = subsev+1;
    b68e:	8d 59 02             	lea    0x2(%ecx),%ebx
		subsev = (MRLC_subHead_sev_IciMsg *)*ptr;
		subsev->fix.R1 = subsev->fix.R2 = 0;
		subsev->fix.E = 1;
		subsev->fix.lcid = lcid;
		subsev->fandl = skb->len;
		subsev->fandl  &= 0x7f;
    b691:	83 e0 7f             	and    $0x7f,%eax
    b694:	88 41 01             	mov    %al,0x1(%ecx)
		*preptr = subsev;
    b697:	8b 45 f0             	mov    -0x10(%ebp),%eax
    b69a:	89 08                	mov    %ecx,(%eax)
		*ptr = subsev+1;
    b69c:	89 1a                	mov    %ebx,(%edx)
		*data += 2;
    b69e:	83 06 02             	addl   $0x2,(%esi)
		*preptr = subfif;
		*ptr = subfif + 1;
		*data += 3;
		//fsm_printf("the data is %d\n",  *data);
	}
}
    b6a1:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    b6a4:	8b 75 f8             	mov    -0x8(%ebp),%esi
    b6a7:	8b 7d fc             	mov    -0x4(%ebp),%edi
    b6aa:	89 ec                	mov    %ebp,%esp
    b6ac:	5d                   	pop    %ebp
    b6ad:	c3                   	ret    
    b6ae:	66 90                	xchg   %ax,%ax

0000b6b0 <PCRLC_CONFIG_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_CONFIG_REQ(void)
{
    b6b0:	55                   	push   %ebp
    b6b1:	89 e5                	mov    %esp,%ebp
    b6b3:	56                   	push   %esi
    b6b4:	53                   	push   %ebx
    b6b5:	83 ec 10             	sub    $0x10,%esp
    b6b8:	e8 fc ff ff ff       	call   b6b9 <PCRLC_CONFIG_REQ+0x9>
	CRLC_ReConfigReq_IoctrlMsg *cIoctrl = (CRLC_ReConfigReq_IoctrlMsg*)fsm_data_get();
    b6bd:	e8 fc ff ff ff       	call   b6be <PCRLC_CONFIG_REQ+0xe>
    b6c2:	89 c3                	mov    %eax,%ebx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b6c4:	e8 fc ff ff ff       	call   b6c5 <PCRLC_CONFIG_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b6c9:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    b6cc:	89 c6                	mov    %eax,%esi
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
    b6ce:	0f b6 03             	movzbl (%ebx),%eax
    b6d1:	8d 96 18 02 00 00    	lea    0x218(%esi),%edx
    b6d7:	89 14 24             	mov    %edx,(%esp)
    b6da:	8d 55 f0             	lea    -0x10(%ebp),%edx
    b6dd:	e8 fc ff ff ff       	call   b6de <PCRLC_CONFIG_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
    b6e2:	c7 04 24 40 2c 00 00 	movl   $0x2c40,(%esp)
    b6e9:	e8 fc ff ff ff       	call   b6ea <PCRLC_CONFIG_REQ+0x3a>
	switch(cIoctrl->Mode)
    b6ee:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
    b6f2:	66 83 f8 02          	cmp    $0x2,%ax
    b6f6:	0f 84 b4 00 00 00    	je     b7b0 <PCRLC_CONFIG_REQ+0x100>
    b6fc:	77 2a                	ja     b728 <PCRLC_CONFIG_REQ+0x78>
    b6fe:	66 83 f8 01          	cmp    $0x1,%ax
    b702:	0f 84 e0 00 00 00    	je     b7e8 <PCRLC_CONFIG_REQ+0x138>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
		}
		break;

	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
    b708:	c7 04 24 a0 2e 00 00 	movl   $0x2ea0,(%esp)
    b70f:	e8 fc ff ff ff       	call   b710 <PCRLC_CONFIG_REQ+0x60>
		break;

	}
	fsm_data_destroy(cIoctrl);
    b714:	89 d8                	mov    %ebx,%eax
    b716:	e8 fc ff ff ff       	call   b717 <PCRLC_CONFIG_REQ+0x67>
	cIoctrl = NULL;
	FOUT;
}
    b71b:	83 c4 10             	add    $0x10,%esp
    b71e:	5b                   	pop    %ebx
    b71f:	5e                   	pop    %esi
    b720:	5d                   	pop    %ebp
    b721:	c3                   	ret    
    b722:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	void *insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
    b728:	66 83 f8 03          	cmp    $0x3,%ax
    b72c:	74 4a                	je     b778 <PCRLC_CONFIG_REQ+0xc8>
    b72e:	66 83 f8 04          	cmp    $0x4,%ax
    b732:	75 d4                	jne    b708 <PCRLC_CONFIG_REQ+0x58>
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
		}
		break;

	case UM_DOWN:			//UM
		if(SV(ins_mode) == UM_MODE)
    b734:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b73b:	0f 85 3f 01 00 00    	jne    b880 <PCRLC_CONFIG_REQ+0x1d0>
		{
			if(insptrd == NULL)
    b741:	8b 75 f4             	mov    -0xc(%ebp),%esi
    b744:	85 f6                	test   %esi,%esi
    b746:	74 cc                	je     b714 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umRxIns = (UM_RX_Instance *)insptrd;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um recv instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b748:	0f b6 03             	movzbl (%ebx),%eax
    b74b:	c7 04 24 64 2d 00 00 	movl   $0x2d64,(%esp)
    b752:	89 44 24 04          	mov    %eax,0x4(%esp)
    b756:	e8 fc ff ff ff       	call   b757 <PCRLC_CONFIG_REQ+0xa7>
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b75b:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
    b75f:	66 89 46 06          	mov    %ax,0x6(%esi)
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
    b763:	8b 43 08             	mov    0x8(%ebx),%eax
    b766:	89 46 10             	mov    %eax,0x10(%esi)
	default:
		fsm_printf("[RLC][PCRLC_CONFIG_REQ] wrong CRLC_CONFIG_REQ\n");
		break;

	}
	fsm_data_destroy(cIoctrl);
    b769:	89 d8                	mov    %ebx,%eax
    b76b:	e8 fc ff ff ff       	call   b76c <PCRLC_CONFIG_REQ+0xbc>
	cIoctrl = NULL;
	FOUT;
}
    b770:	83 c4 10             	add    $0x10,%esp
    b773:	5b                   	pop    %ebx
    b774:	5e                   	pop    %esi
    b775:	5d                   	pop    %ebp
    b776:	c3                   	ret    
    b777:	90                   	nop
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
		}
		break;

	case UM_UP:			//UM
		if(SV(ins_mode) ==  UM_MODE)
    b778:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b77f:	0f 85 e3 00 00 00    	jne    b868 <PCRLC_CONFIG_REQ+0x1b8>
		{
			if(insptru == NULL)
    b785:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b788:	85 f6                	test   %esi,%esi
    b78a:	74 88                	je     b714 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b78c:	0f b6 03             	movzbl (%ebx),%eax
    b78f:	c7 04 24 10 2d 00 00 	movl   $0x2d10,(%esp)
    b796:	89 44 24 04          	mov    %eax,0x4(%esp)
    b79a:	e8 fc ff ff ff       	call   b79b <PCRLC_CONFIG_REQ+0xeb>
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b79f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b7a3:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b7a7:	e9 68 ff ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b7ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
		}
		break;

	case UM_UPDOWN:              	 //UM
		if(SV(ins_mode) == UM_MODE)
    b7b0:	83 be 18 02 00 00 02 	cmpl   $0x2,0x218(%esi)
    b7b7:	0f 85 93 00 00 00    	jne    b850 <PCRLC_CONFIG_REQ+0x1a0>
		{
			if(insptru != NULL)
    b7bd:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b7c0:	85 f6                	test   %esi,%esi
    b7c2:	0f 84 79 ff ff ff    	je     b741 <PCRLC_CONFIG_REQ+0x91>
			{
				umTxIns = (UM_TX_Instance *)insptru;
				fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b7c8:	0f b6 03             	movzbl (%ebx),%eax
    b7cb:	c7 04 24 10 2d 00 00 	movl   $0x2d10,(%esp)
    b7d2:	89 44 24 04          	mov    %eax,0x4(%esp)
    b7d6:	e8 fc ff ff ff       	call   b7d7 <PCRLC_CONFIG_REQ+0x127>
				umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    b7db:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
    b7df:	66 89 46 2a          	mov    %ax,0x2a(%esi)
    b7e3:	e9 59 ff ff ff       	jmp    b741 <PCRLC_CONFIG_REQ+0x91>
	findInsByRbid(cIoctrl->rbIdentity ,&insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_CONFIG_REQ] entering PCRLC_CONFIG_REQ\n ");
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		if(SV(ins_mode) == AM_MODE)
    b7e8:	83 be 18 02 00 00 03 	cmpl   $0x3,0x218(%esi)
    b7ef:	0f 85 a3 00 00 00    	jne    b898 <PCRLC_CONFIG_REQ+0x1e8>
		{
			if(insptru == NULL)
    b7f5:	8b 75 f0             	mov    -0x10(%ebp),%esi
    b7f8:	85 f6                	test   %esi,%esi
    b7fa:	0f 84 14 ff ff ff    	je     b714 <PCRLC_CONFIG_REQ+0x64>
			{
				break;
			}
			amIns = (AM_Instance *)insptru;
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:am instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
    b800:	0f b6 03             	movzbl (%ebx),%eax
    b803:	c7 04 24 74 2c 00 00 	movl   $0x2c74,(%esp)
    b80a:	89 44 24 04          	mov    %eax,0x4(%esp)
    b80e:	e8 fc ff ff ff       	call   b80f <PCRLC_CONFIG_REQ+0x15f>
			amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering;
    b813:	8b 43 14             	mov    0x14(%ebx),%eax
    b816:	89 46 1c             	mov    %eax,0x1c(%esi)
			amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit;
    b819:	8b 43 10             	mov    0x10(%ebx),%eax
    b81c:	89 46 28             	mov    %eax,0x28(%esi)
			amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit;
    b81f:	8b 43 18             	mov    0x18(%ebx),%eax
    b822:	89 46 10             	mov    %eax,0x10(%esi)
			amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    b825:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
    b829:	66 89 86 f6 22 00 00 	mov    %ax,0x22f6(%esi)
			amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    b830:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
    b834:	66 89 86 f8 22 00 00 	mov    %ax,0x22f8(%esi)
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    b83b:	0f b7 43 20          	movzwl 0x20(%ebx),%eax
    b83f:	66 89 86 fa 22 00 00 	mov    %ax,0x22fa(%esi)
			break;
    b846:	e9 c9 fe ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b84b:	90                   	nop
    b84c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case2:there is no UM  instance to be recinfiged!\n");
    b850:	c7 04 24 b8 2d 00 00 	movl   $0x2db8,(%esp)
    b857:	e8 fc ff ff ff       	call   b858 <PCRLC_CONFIG_REQ+0x1a8>
    b85c:	e9 b3 fe ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b861:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] PCRLC_CONFIG_REQ:um tran instance has configed(rbid is %d)\n",cIoctrl->rbIdentity);
			umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case3:there is no UM TX instance to be recinfiged!\n");
    b868:	c7 04 24 04 2e 00 00 	movl   $0x2e04,(%esp)
    b86f:	e8 fc ff ff ff       	call   b870 <PCRLC_CONFIG_REQ+0x1c0>
    b874:	e9 9b fe ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b879:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
			umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering;
		}
		else 
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case 4:there is no UM RX instance to be recinfiged!\n");
    b880:	c7 04 24 50 2e 00 00 	movl   $0x2e50,(%esp)
    b887:	e8 fc ff ff ff       	call   b888 <PCRLC_CONFIG_REQ+0x1d8>
    b88c:	e9 83 fe ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
			break;
		}
		else
		{
			fsm_printf("[RLC][PCRLC_CONFIG_REQ] case1:there is no AM instance to be recinfiged!\n");
    b898:	c7 04 24 c4 2c 00 00 	movl   $0x2cc4,(%esp)
    b89f:	e8 fc ff ff ff       	call   b8a0 <PCRLC_CONFIG_REQ+0x1f0>
		}
		break;
    b8a4:	e9 6b fe ff ff       	jmp    b714 <PCRLC_CONFIG_REQ+0x64>
    b8a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000b8b0 <PCRLC_BULID_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_BULID_REQ(void)
{
    b8b0:	55                   	push   %ebp
    b8b1:	89 e5                	mov    %esp,%ebp
    b8b3:	57                   	push   %edi
    b8b4:	56                   	push   %esi
    b8b5:	53                   	push   %ebx
    b8b6:	83 ec 0c             	sub    $0xc,%esp
    b8b9:	e8 fc ff ff ff       	call   b8ba <PCRLC_BULID_REQ+0xa>
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
	
	SV_PTR_GET(rlc_mac_sv);
    b8be:	e8 fc ff ff ff       	call   b8bf <PCRLC_BULID_REQ+0xf>
    b8c3:	89 c6                	mov    %eax,%esi
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
    b8c5:	c7 04 24 d0 2e 00 00 	movl   $0x2ed0,(%esp)
    b8cc:	e8 fc ff ff ff       	call   b8cd <PCRLC_BULID_REQ+0x1d>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
    b8d1:	e8 fc ff ff ff       	call   b8d2 <PCRLC_BULID_REQ+0x22>
    b8d6:	89 c7                	mov    %eax,%edi
	switch(cIoctrl->Mode)
    b8d8:	0f b7 40 02          	movzwl 0x2(%eax),%eax
    b8dc:	66 83 f8 02          	cmp    $0x2,%ax
    b8e0:	0f 84 e2 01 00 00    	je     bac8 <PCRLC_BULID_REQ+0x218>
    b8e6:	77 38                	ja     b920 <PCRLC_BULID_REQ+0x70>
    b8e8:	66 83 f8 01          	cmp    $0x1,%ax
    b8ec:	0f 84 4f 03 00 00    	je     bc41 <PCRLC_BULID_REQ+0x391>
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
		break;

	default:
		fsm_printf("[RLC][PCRLC_BULID_REQ] wrong CRLC_BULID_REQ");
    b8f2:	c7 04 24 fc 30 00 00 	movl   $0x30fc,(%esp)
    b8f9:	e8 fc ff ff ff       	call   b8fa <PCRLC_BULID_REQ+0x4a>
		break;

	}
	
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    b8fe:	b8 01 00 00 00       	mov    $0x1,%eax
    b903:	e8 fc ff ff ff       	call   b904 <PCRLC_BULID_REQ+0x54>
	cItrl->V_Flag = true;
    b908:	c6 00 01             	movb   $0x1,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    b90b:	e8 fc ff ff ff       	call   b90c <PCRLC_BULID_REQ+0x5c>
	cItrl = NULL;
	fsm_data_destroy(cIoctrl);
    b910:	89 f8                	mov    %edi,%eax
    b912:	e8 fc ff ff ff       	call   b913 <PCRLC_BULID_REQ+0x63>
	cIoctrl = NULL;
	FOUT;
}
    b917:	83 c4 0c             	add    $0xc,%esp
    b91a:	5b                   	pop    %ebx
    b91b:	5e                   	pop    %esi
    b91c:	5f                   	pop    %edi
    b91d:	5d                   	pop    %ebp
    b91e:	c3                   	ret    
    b91f:	90                   	nop
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][PCRLC_BULID_REQ] entering PCRLC_BULID_REQ\n ");
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
    b920:	66 83 f8 03          	cmp    $0x3,%ax
    b924:	0f 84 22 01 00 00    	je     ba4c <PCRLC_BULID_REQ+0x19c>
    b92a:	66 83 f8 04          	cmp    $0x4,%ax
    b92e:	75 c2                	jne    b8f2 <PCRLC_BULID_REQ+0x42>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    b930:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    b935:	e8 fc ff ff ff       	call   b936 <PCRLC_BULID_REQ+0x86>
    b93a:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    b93c:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    b940:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b944:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    b948:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_DOWN:			//UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    b94f:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    b952:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    b956:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    b959:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b95c:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    b963:	00 00 
    b965:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    b96c:	00 00 
    b96e:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    b975:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    b977:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    b97a:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    b97c:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    b982:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    b989:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    b990:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    b996:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    b99c:	eb 0d                	jmp    b9ab <PCRLC_BULID_REQ+0xfb>
    b99e:	66 90                	xchg   %ax,%ax
    b9a0:	83 fa 32             	cmp    $0x32,%edx
    b9a3:	0f 84 52 05 00 00    	je     befb <PCRLC_BULID_REQ+0x64b>
    b9a9:	89 d0                	mov    %edx,%eax
    b9ab:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    b9b2:	ff 
    b9b3:	8d 50 01             	lea    0x1(%eax),%edx
    b9b6:	74 e8                	je     b9a0 <PCRLC_BULID_REQ+0xf0>
		if(i >= MAX_CODE) 
    b9b8:	83 fa 32             	cmp    $0x32,%edx
    b9bb:	0f 84 3a 05 00 00    	je     befb <PCRLC_BULID_REQ+0x64b>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    b9c1:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    b9c4:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    b9cb:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    b9cf:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    b9d2:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    b9d5:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b9d8:	31 c0                	xor    %eax,%eax
    b9da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    b9e0:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    b9e7:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    b9e8:	83 c0 01             	add    $0x1,%eax
    b9eb:	83 f8 20             	cmp    $0x20,%eax
    b9ee:	75 f0                	jne    b9e0 <PCRLC_BULID_REQ+0x130>
    b9f0:	30 c0                	xor    %al,%al
    b9f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    b9f8:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    b9ff:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    ba03:	83 c0 01             	add    $0x1,%eax
    ba06:	3d 00 04 00 00       	cmp    $0x400,%eax
    ba0b:	75 eb                	jne    b9f8 <PCRLC_BULID_REQ+0x148>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ba0d:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    ba13:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ba19:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    ba1f:	81 c6 c0 36 00 00    	add    $0x36c0,%esi
    ba25:	89 b3 c4 10 00 00    	mov    %esi,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    ba2b:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    ba31:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);
    ba33:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    ba37:	c7 04 24 a4 30 00 00 	movl   $0x30a4,(%esp)
    ba3e:	89 44 24 04          	mov    %eax,0x4(%esp)
    ba42:	e8 fc ff ff ff       	call   ba43 <PCRLC_BULID_REQ+0x193>
		break;
    ba47:	e9 b2 fe ff ff       	jmp    b8fe <PCRLC_BULID_REQ+0x4e>
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
    ba4c:	b8 38 00 00 00       	mov    $0x38,%eax
    ba51:	e8 fc ff ff ff       	call   ba52 <PCRLC_BULID_REQ+0x1a2>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    ba56:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    ba5a:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    ba5e:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    ba62:	8d 48 30             	lea    0x30(%eax),%ecx
		break;

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    ba65:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba68:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    ba6b:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    ba6f:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    ba75:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

	case UM_UP:			//UM
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    ba7c:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    ba7f:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    ba82:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    ba89:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    ba8c:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    ba8f:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    ba95:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    ba9b:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    baa1:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    baa4:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    baa7:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",umTxIns->rbid);
    baa9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    baad:	c7 04 24 4c 30 00 00 	movl   $0x304c,(%esp)
    bab4:	89 44 24 04          	mov    %eax,0x4(%esp)
    bab8:	e8 fc ff ff ff       	call   bab9 <PCRLC_BULID_REQ+0x209>
		break;
    babd:	e9 3c fe ff ff       	jmp    b8fe <PCRLC_BULID_REQ+0x4e>
    bac2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
    bac8:	b8 cc 10 00 00       	mov    $0x10cc,%eax
    bacd:	e8 fc ff ff ff       	call   bace <PCRLC_BULID_REQ+0x21e>
    bad2:	89 c3                	mov    %eax,%ebx
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
    bad4:	0f b7 47 04          	movzwl 0x4(%edi),%eax
    bad8:	66 89 43 06          	mov    %ax,0x6(%ebx)
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    badc:	6b 47 08 64          	imul   $0x64,0x8(%edi),%eax
		umRxIns->currentStatVar = ST_TRAN;
    bae0:	c6 83 c2 10 00 00 08 	movb   $0x8,0x10c2(%ebx)
		break;

	case UM_UPDOWN:              	 //UM
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
    bae7:	89 43 10             	mov    %eax,0x10(%ebx)
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
    baea:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    baee:	88 43 03             	mov    %al,0x3(%ebx)
		umRxIns->rbId = cIoctrl->rbIdentity;
    baf1:	0f b6 07             	movzbl (%edi),%eax
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    baf4:	66 c7 83 be 10 00 00 	movw   $0x0,0x10be(%ebx)
    bafb:	00 00 
    bafd:	66 c7 83 bc 10 00 00 	movw   $0x0,0x10bc(%ebx)
    bb04:	00 00 
    bb06:	66 c7 83 c0 10 00 00 	movw   $0x0,0x10c0(%ebx)
    bb0d:	00 00 
		umRxIns =  instance_create(struct UM_RX_Instance);
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
    bb0f:	88 43 02             	mov    %al,0x2(%ebx)
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    bb12:	31 c0                	xor    %eax,%eax
		umRxIns->snFiledLength = cIoctrl->umDwParas.snFiledLength;
		umRxIns->reorderTimerValue = cIoctrl->umDwParas.timerReordering*100;
		umRxIns->currentStatVar = ST_TRAN;
		umRxIns->lcId = cIoctrl->lcIdentity;
		umRxIns->rbId = cIoctrl->rbIdentity;
		umRxIns->SN = umRxIns->vr_uh = umRxIns->vr_ur = umRxIns->vr_ux = 0;
    bb14:	66 c7 43 14 00 00    	movw   $0x0,0x14(%ebx)
		umRxIns->reorderTimer = 0;
    bb1a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		umRxIns->pduLft.sduLeft = NULL;
    bb21:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
		umRxIns->pduLft.SN_Left = -1;
    bb28:	66 c7 43 1a ff ff    	movw   $0xffff,0x1a(%ebx)
		umRxIns->pduLft.SN5_Left = -1;
    bb2e:	66 c7 43 18 ff ff    	movw   $0xffff,0x18(%ebx)
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    bb34:	eb 0d                	jmp    bb43 <PCRLC_BULID_REQ+0x293>
    bb36:	66 90                	xchg   %ax,%ax
    bb38:	83 fa 32             	cmp    $0x32,%edx
    bb3b:	0f 84 a9 03 00 00    	je     beea <PCRLC_BULID_REQ+0x63a>
    bb41:	89 d0                	mov    %edx,%eax
    bb43:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bb4a:	ff 
    bb4b:	8d 50 01             	lea    0x1(%eax),%edx
    bb4e:	74 e8                	je     bb38 <PCRLC_BULID_REQ+0x288>
		if(i >= MAX_CODE) 
    bb50:	83 fa 32             	cmp    $0x32,%edx
    bb53:	0f 84 91 03 00 00    	je     beea <PCRLC_BULID_REQ+0x63a>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			umRxIns->reorderTimerCode = i - 1;
    bb59:	89 43 0c             	mov    %eax,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bb5c:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    bb63:	ff ff ff ff 
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
    bb67:	8d 43 30             	lea    0x30(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bb6a:	89 43 30             	mov    %eax,0x30(%ebx)
	list->prev = list;
    bb6d:	89 43 34             	mov    %eax,0x34(%ebx)
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    bb70:	31 c0                	xor    %eax,%eax
    bb72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		{
			umRxIns->umRecvWindow5[i] = NULL;
    bb78:	c7 44 83 38 00 00 00 	movl   $0x0,0x38(%ebx,%eax,4)
    bb7f:	00 
			SV(allocCode[i - 1]) = -1;
		}
		INIT_LIST_HEAD(&umRxIns->umRecvBuffer.list);
		//if(umRxIns->snFiledLength == 5)
		//{
		for(i = 0; i < 32; ++i)
    bb80:	83 c0 01             	add    $0x1,%eax
    bb83:	83 f8 20             	cmp    $0x20,%eax
    bb86:	75 f0                	jne    bb78 <PCRLC_BULID_REQ+0x2c8>
    bb88:	30 c0                	xor    %al,%al
    bb8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
		{
			umRxIns->umRecvWindow10[i] = NULL;
    bb90:	c7 84 83 b8 00 00 00 	movl   $0x0,0xb8(%ebx,%eax,4)
    bb97:	00 00 00 00 
			umRxIns->umRecvWindow5[i] = NULL;
		}
		//}
		//else if(umRxIns->snFiledLength == 10)
		//{
		for(i = 0; i < 1024; ++i)
    bb9b:	83 c0 01             	add    $0x1,%eax
    bb9e:	3d 00 04 00 00       	cmp    $0x400,%eax
    bba3:	75 eb                	jne    bb90 <PCRLC_BULID_REQ+0x2e0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bba5:	8b 86 c4 36 00 00    	mov    0x36c4(%esi),%eax
		{
			umRxIns->umRecvWindow10[i] = NULL;
		}
		//}
		list_add_tail(&umRxIns->umRxList, &SV(vUm_rx_ins).umRxList);
    bbab:	8d 93 c4 10 00 00    	lea    0x10c4(%ebx),%edx
    bbb1:	8d 8e c0 36 00 00    	lea    0x36c0(%esi),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bbb7:	89 96 c4 36 00 00    	mov    %edx,0x36c4(%esi)
    bbbd:	89 8b c4 10 00 00    	mov    %ecx,0x10c4(%ebx)
	new->next = next;
	new->prev = prev;
    bbc3:	89 83 c8 10 00 00    	mov    %eax,0x10c8(%ebx)
	prev->next = new;
    bbc9:	89 10                	mov    %edx,(%eax)
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
    bbcb:	b8 38 00 00 00       	mov    $0x38,%eax
    bbd0:	e8 fc ff ff ff       	call   bbd1 <PCRLC_BULID_REQ+0x321>
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
    bbd5:	0f b7 57 0c          	movzwl 0xc(%edi),%edx
    bbd9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
		umTxIns->lcid = cIoctrl->lcIdentity;
    bbdd:	0f b6 57 01          	movzbl 0x1(%edi),%edx
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bbe1:	8d 48 30             	lea    0x30(%eax),%ecx
		//   fsm_printf("PCRLC_BULID_REQ: um recv instance has established(rbid is %d)\n",umRxIns->rbId);

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
    bbe4:	88 50 03             	mov    %dl,0x3(%eax)
		umTxIns->rbid = cIoctrl->rbIdentity;
    bbe7:	0f b6 17             	movzbl (%edi),%edx
		umTxIns->CurrentStatVar = ST_TRAN;
    bbea:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		umTxIns->SN=0;
    bbee:	66 c7 40 28 00 00    	movw   $0x0,0x28(%eax)
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bbf4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

		//
		umTxIns =  instance_create(UM_TX_Instance);
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
    bbfb:	88 50 02             	mov    %dl,0x2(%eax)
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
    bbfe:	8d 50 18             	lea    0x18(%eax),%edx
		umTxIns->snFiledLength = cIoctrl->umUpParas.snFiledLength;
		umTxIns->lcid = cIoctrl->lcIdentity;
		umTxIns->rbid = cIoctrl->rbIdentity;
		umTxIns->CurrentStatVar = ST_TRAN;
		umTxIns->SN=0;
		umTxIns->umSduBufferNum = umTxIns->umSduBufferSize = 0;
    bc01:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    bc08:	89 50 18             	mov    %edx,0x18(%eax)
	list->prev = list;
    bc0b:	89 50 1c             	mov    %edx,0x1c(%eax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    bc0e:	8b 96 fc 36 00 00    	mov    0x36fc(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bc14:	89 8e fc 36 00 00    	mov    %ecx,0x36fc(%esi)
		INIT_LIST_HEAD(&umTxIns->umSduBuffer.list);
		list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
    bc1a:	81 c6 f8 36 00 00    	add    $0x36f8,%esi
    bc20:	89 70 30             	mov    %esi,0x30(%eax)
	new->next = next;
	new->prev = prev;
    bc23:	89 50 34             	mov    %edx,0x34(%eax)
	prev->next = new;
    bc26:	89 0a                	mov    %ecx,(%edx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: um tran and recv instance has established(rbid is %d)\n",umTxIns->rbid);
    bc28:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    bc2c:	c7 04 24 ec 2f 00 00 	movl   $0x2fec,(%esp)
    bc33:	89 44 24 04          	mov    %eax,0x4(%esp)
    bc37:	e8 fc ff ff ff       	call   bc38 <PCRLC_BULID_REQ+0x388>
		break;
    bc3c:	e9 bd fc ff ff       	jmp    b8fe <PCRLC_BULID_REQ+0x4e>
	
	cIoctrl = (CRLC_BuildReq_IoctrlMsg*)fsm_data_get();
	switch(cIoctrl->Mode)
	{
	case AM_UPDOWN:                      //AM
		amIns =  instance_create(struct AM_Instance);
    bc41:	b8 0c 23 00 00       	mov    $0x230c,%eax
    bc46:	e8 fc ff ff ff       	call   bc47 <PCRLC_BULID_REQ+0x397>
    bc4b:	89 c3                	mov    %eax,%ebx
		amIns->rbId = cIoctrl->rbIdentity;
    bc4d:	0f b6 07             	movzbl (%edi),%eax
    bc50:	88 43 02             	mov    %al,0x2(%ebx)
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
    bc53:	0f b6 47 01          	movzbl 0x1(%edi),%eax
    bc57:	88 43 03             	mov    %al,0x3(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
    bc5a:	0f b6 c0             	movzbl %al,%eax
    bc5d:	89 44 24 04          	mov    %eax,0x4(%esp)
    bc61:	c7 04 24 04 2f 00 00 	movl   $0x2f04,(%esp)
    bc68:	e8 fc ff ff ff       	call   bc69 <PCRLC_BULID_REQ+0x3b9>
	struct	AM_Instance * amIns;
	struct	UM_RX_Instance *umRxIns;
	struct	UM_TX_Instance *umTxIns;
	CRLC_BuildReq_IoctrlMsg *cIoctrl;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	int i = 0;
    bc6d:	31 d2                	xor    %edx,%edx
		amIns =  instance_create(struct AM_Instance);
		amIns->rbId = cIoctrl->rbIdentity;
		//fsm_printf("the rbid is %d\n", amIns->rbId);
		amIns->lcId = cIoctrl->lcIdentity;
		fsm_printf("[RLC][PCRLC_BULID_REQ] build am instance lcid is %d\n",amIns->lcId);
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
    bc6f:	6b 47 14 64          	imul   $0x64,0x14(%edi),%eax
    bc73:	89 43 1c             	mov    %eax,0x1c(%ebx)
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
    bc76:	6b 47 10 64          	imul   $0x64,0x10(%edi),%eax
    bc7a:	89 43 28             	mov    %eax,0x28(%ebx)
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
    bc7d:	6b 47 18 64          	imul   $0x64,0x18(%edi),%eax
    bc81:	89 43 10             	mov    %eax,0x10(%ebx)
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
    bc84:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
    bc88:	66 89 83 f6 22 00 00 	mov    %ax,0x22f6(%ebx)
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
    bc8f:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
    bc93:	66 89 83 f8 22 00 00 	mov    %ax,0x22f8(%ebx)
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bc9a:	0f b7 47 20          	movzwl 0x20(%edi),%eax
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bc9e:	c7 83 f8 00 00 00 00 	movl   $0x0,0xf8(%ebx)
    bca5:	00 00 00 
    bca8:	c7 83 b8 01 00 00 00 	movl   $0x0,0x1b8(%ebx)
    bcaf:	00 00 00 
    bcb2:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
		amIns->reorderTimerValue= cIoctrl->amDwparas.timerReordering*100;
		amIns->statProhTimerValue = cIoctrl->amDwparas.timerStatusProhibit*100;
		amIns->pollRetxTimerValue = cIoctrl->amUpParas.timerPollRetransmit*100;
		amIns->pollPDU = cIoctrl->amUpParas.PollPDU;
		amIns->pollBYTE = cIoctrl->amUpParas.PollBYTE;
		amIns->maxRetxThreshold = cIoctrl->amUpParas.maxRetxThreshold;
    bcb9:	66 89 83 fa 22 00 00 	mov    %ax,0x22fa(%ebx)
		amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = amIns->amTransmittedBufferSize = 0;
    bcc0:	c7 83 a4 01 00 00 00 	movl   $0x0,0x1a4(%ebx)
    bcc7:	00 00 00 
		amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = amIns->amTransmittedBufferNum = 0;
    bcca:	c7 83 fc 00 00 00 00 	movl   $0x0,0xfc(%ebx)
    bcd1:	00 00 00 
    bcd4:	c7 83 bc 01 00 00 00 	movl   $0x0,0x1bc(%ebx)
    bcdb:	00 00 00 
    bcde:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
    bce5:	c7 83 a8 01 00 00 00 	movl   $0x0,0x1a8(%ebx)
    bcec:	00 00 00 
		amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
    bcef:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    bcf6:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    bcfd:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		amIns->currentStatVar = ST_TRAN;
    bd04:	66 c7 43 2c 08 00    	movw   $0x8,0x2c(%ebx)
		amIns->pduLft.sduLeft = NULL;
    bd0a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
		amIns->pduLft.SN_Left = -1;
    bd11:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
		amIns->pduLft.SN5_Left = -1;
    bd17:	66 c7 43 30 ff ff    	movw   $0xffff,0x30(%ebx)
		//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
		//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
    bd1d:	eb 0c                	jmp    bd2b <PCRLC_BULID_REQ+0x47b>
    bd1f:	90                   	nop
    bd20:	83 f8 32             	cmp    $0x32,%eax
    bd23:	0f 84 ab 01 00 00    	je     bed4 <PCRLC_BULID_REQ+0x624>
    bd29:	89 c2                	mov    %eax,%edx
    bd2b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bd32:	ff 
    bd33:	8d 42 01             	lea    0x1(%edx),%eax
    bd36:	74 e8                	je     bd20 <PCRLC_BULID_REQ+0x470>
		if(i >= MAX_CODE) 
    bd38:	83 f8 32             	cmp    $0x32,%eax
    bd3b:	0f 84 93 01 00 00    	je     bed4 <PCRLC_BULID_REQ+0x624>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->pollRetxTimerCode = i - 1;
    bd41:	89 53 0c             	mov    %edx,0xc(%ebx)
			SV(allocCode[i - 1]) = -1;
    bd44:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bd4b:	ff ff ff ff 
    bd4f:	eb 09                	jmp    bd5a <PCRLC_BULID_REQ+0x4aa>
    bd51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bd58:	89 d0                	mov    %edx,%eax
    bd5a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
    bd61:	ff 
    bd62:	8d 50 01             	lea    0x1(%eax),%edx
    bd65:	0f 85 a1 01 00 00    	jne    bf0c <PCRLC_BULID_REQ+0x65c>
    bd6b:	83 fa 31             	cmp    $0x31,%edx
    bd6e:	7e e8                	jle    bd58 <PCRLC_BULID_REQ+0x4a8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bd70:	89 55 f0             	mov    %edx,-0x10(%ebp)
    bd73:	c7 04 24 3c 2f 00 00 	movl   $0x2f3c,(%esp)
    bd7a:	e8 fc ff ff ff       	call   bd7b <PCRLC_BULID_REQ+0x4cb>
    bd7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bd82:	eb 06                	jmp    bd8a <PCRLC_BULID_REQ+0x4da>
    bd84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		else
		{
			amIns->reorderTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
    bd88:	89 c2                	mov    %eax,%edx
    bd8a:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
    bd91:	ff 
    bd92:	8d 42 01             	lea    0x1(%edx),%eax
    bd95:	0f 85 8d 01 00 00    	jne    bf28 <PCRLC_BULID_REQ+0x678>
    bd9b:	83 f8 31             	cmp    $0x31,%eax
    bd9e:	7e e8                	jle    bd88 <PCRLC_BULID_REQ+0x4d8>
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bda0:	c7 04 24 3c 2f 00 00 	movl   $0x2f3c,(%esp)
    bda7:	e8 fc ff ff ff       	call   bda8 <PCRLC_BULID_REQ+0x4f8>
		else
		{
			amIns->statProhTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
    bdac:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
    bdb3:	00 00 
    bdb5:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
    bdbc:	00 00 
    bdbe:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
    bdc5:	00 00 
    bdc7:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
    bdce:	00 00 
    bdd0:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
    bdd7:	00 00 
    bdd9:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
    bde0:	00 00 
		amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
    bde2:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
    bde9:	00 02 
    bdeb:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
    bdf2:	00 02 
		amIns->SN = 0;
    bdf4:	66 c7 43 2e 00 00    	movw   $0x0,0x2e(%ebx)
		amIns->statFlag = false;
    bdfa:	c6 43 06 00          	movb   $0x0,0x6(%ebx)
		fsm_printf("[RLC][PCRLC_BULID_REQ] init SN is %d\n",amIns->SN);
    bdfe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    be05:	00 
    be06:	c7 04 24 70 2f 00 00 	movl   $0x2f70,(%esp)
    be0d:	e8 fc ff ff ff       	call   be0e <PCRLC_BULID_REQ+0x55e>
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
    be12:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    be15:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
    be18:	89 43 48             	mov    %eax,0x48(%ebx)
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
    be1b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    be21:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
    be27:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
    be2d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    be33:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
    be39:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
    be3f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    be45:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
    be4b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
    be51:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
    be57:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
    be5d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
		for(i = 0;  i < 1024; ++i )
    be63:	31 c0                	xor    %eax,%eax
    be65:	8d 76 00             	lea    0x0(%esi),%esi
		{
			amIns->amRecvWindow[i] = NULL;
    be68:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
    be6f:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->amSduBuffer.list);
		INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
		INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
		INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
    be73:	83 c0 01             	add    $0x1,%eax
    be76:	3d 00 04 00 00       	cmp    $0x400,%eax
    be7b:	75 eb                	jne    be68 <PCRLC_BULID_REQ+0x5b8>
    be7d:	66 31 c0             	xor    %ax,%ax
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amTranWindow[i]= NULL;
    be80:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
    be87:	00 00 00 00 
		INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
		for(i = 0;  i < 1024; ++i )
		{
			amIns->amRecvWindow[i] = NULL;
		}
		for(i = 0;  i < 1024; ++i )
    be8b:	83 c0 01             	add    $0x1,%eax
    be8e:	3d 00 04 00 00       	cmp    $0x400,%eax
    be93:	75 eb                	jne    be80 <PCRLC_BULID_REQ+0x5d0>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    be95:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		{
			amIns->amTranWindow[i]= NULL;
		}
		list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
    be9b:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    bea1:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
    bea7:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
    bead:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
    beb3:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
    beb9:	89 10                	mov    %edx,(%eax)
		fsm_printf("[RLC][PCRLC_BULID_REQ] PCRLC_BULID_REQ: am instance has established(rbid is %d)\n",amIns->rbId);
    bebb:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
    bebf:	c7 04 24 98 2f 00 00 	movl   $0x2f98,(%esp)
    bec6:	89 44 24 04          	mov    %eax,0x4(%esp)
    beca:	e8 fc ff ff ff       	call   becb <PCRLC_BULID_REQ+0x61b>
		break;
    becf:	e9 2a fa ff ff       	jmp    b8fe <PCRLC_BULID_REQ+0x4e>
		//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    bed4:	c7 04 24 3c 2f 00 00 	movl   $0x2f3c,(%esp)
    bedb:	e8 fc ff ff ff       	call   bedc <PCRLC_BULID_REQ+0x62c>
    bee0:	b8 32 00 00 00       	mov    $0x32,%eax
    bee5:	e9 70 fe ff ff       	jmp    bd5a <PCRLC_BULID_REQ+0x4aa>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    beea:	c7 04 24 3c 2f 00 00 	movl   $0x2f3c,(%esp)
    bef1:	e8 fc ff ff ff       	call   bef2 <PCRLC_BULID_REQ+0x642>
    bef6:	e9 6c fc ff ff       	jmp    bb67 <PCRLC_BULID_REQ+0x2b7>
		//  umRxIns->reorderTimerCode =( int)umRxIns % 65536;
		//code
		while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
		if(i >= MAX_CODE) 
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
    befb:	c7 04 24 3c 2f 00 00 	movl   $0x2f3c,(%esp)
    bf02:	e8 fc ff ff ff       	call   bf03 <PCRLC_BULID_REQ+0x653>
    bf07:	e9 c3 fa ff ff       	jmp    b9cf <PCRLC_BULID_REQ+0x11f>
		{
			amIns->pollRetxTimerCode = i - 1;
			SV(allocCode[i - 1]) = -1;
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bf0c:	83 fa 31             	cmp    $0x31,%edx
    bf0f:	0f 8f 5b fe ff ff    	jg     bd70 <PCRLC_BULID_REQ+0x4c0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->reorderTimerCode = i - 1;
    bf15:	89 43 18             	mov    %eax,0x18(%ebx)
			SV(allocCode[i - 1]) = -1;
    bf18:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
    bf1f:	ff ff ff ff 
    bf23:	e9 62 fe ff ff       	jmp    bd8a <PCRLC_BULID_REQ+0x4da>
		}
		while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
		if(i >= MAX_CODE) 
    bf28:	83 f8 31             	cmp    $0x31,%eax
    bf2b:	0f 8f 6f fe ff ff    	jg     bda0 <PCRLC_BULID_REQ+0x4f0>
		{
			fsm_printf("[RLC][PCRLC_BULID_REQ] no more code to allocated \n");
		}
		else
		{
			amIns->statProhTimerCode = i - 1;
    bf31:	89 53 24             	mov    %edx,0x24(%ebx)
			SV(allocCode[i - 1]) = -1;
    bf34:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
    bf3b:	ff ff ff ff 
    bf3f:	e9 68 fe ff ff       	jmp    bdac <PCRLC_BULID_REQ+0x4fc>
    bf44:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    bf4a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0000bf50 <PCRLC_DEACT_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_DEACT_REQ(void)
{
    bf50:	55                   	push   %ebp
    bf51:	89 e5                	mov    %esp,%ebp
    bf53:	57                   	push   %edi
    bf54:	56                   	push   %esi
    bf55:	53                   	push   %ebx
    bf56:	83 ec 20             	sub    $0x20,%esp
    bf59:	e8 fc ff ff ff       	call   bf5a <PCRLC_DEACT_REQ+0xa>
	struct Buffer *buffer, *tempBuffer;
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
    bf5e:	e8 fc ff ff ff       	call   bf5f <PCRLC_DEACT_REQ+0xf>
    bf63:	89 c3                	mov    %eax,%ebx
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    bf65:	e8 fc ff ff ff       	call   bf66 <PCRLC_DEACT_REQ+0x16>
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    bf6a:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    bf70:	8d 4d f0             	lea    -0x10(%ebp),%ecx
	struct UmBuffer *umBuffer, *tempUmBuffer;
	void *insptru, *insptrd;
	CRLC_RbidBuild_IOCTRLMsg *cItrl;
	
	SV_PTR_GET(rlc_mac_sv);
	cIoctrl = (CRLC_DeactReq_IoctrlMsg*)fsm_data_get();
    bf73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
    bf76:	0f b6 00             	movzbl (%eax),%eax
    bf79:	89 14 24             	mov    %edx,(%esp)
    bf7c:	8d 55 ec             	lea    -0x14(%ebp),%edx
    bf7f:	e8 fc ff ff ff       	call   bf80 <PCRLC_DEACT_REQ+0x30>
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
    bf84:	c7 04 24 28 31 00 00 	movl   $0x3128,(%esp)
    bf8b:	e8 fc ff ff ff       	call   bf8c <PCRLC_DEACT_REQ+0x3c>
	switch(SV(ins_mode))
    bf90:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    bf96:	83 f8 02             	cmp    $0x2,%eax
    bf99:	74 3d                	je     bfd8 <PCRLC_DEACT_REQ+0x88>
    bf9b:	83 f8 03             	cmp    $0x3,%eax
    bf9e:	0f 84 a4 01 00 00    	je     c148 <PCRLC_DEACT_REQ+0x1f8>
		//AM
		fsm_mem_free(amIns);
		amIns = NULL;
		break;
	default:
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:cannot distinguish the instance to distinguish.\n");
    bfa4:	c7 04 24 60 32 00 00 	movl   $0x3260,(%esp)
    bfab:	e8 fc ff ff ff       	call   bfac <PCRLC_DEACT_REQ+0x5c>
		break;
	}
	cItrl = (CRLC_RbidBuild_IOCTRLMsg*)fsm_mem_alloc(sizeof(CRLC_RbidBuild_IOCTRLMsg));
    bfb0:	b8 01 00 00 00       	mov    $0x1,%eax
    bfb5:	e8 fc ff ff ff       	call   bfb6 <PCRLC_DEACT_REQ+0x66>
	cItrl->V_Flag = false;
    bfba:	c6 00 00             	movb   $0x0,(%eax)
	//cItrl->rbId = cIoctrl->rbIdentity;
	//fsm_do_ioctrl(STRM_TO_IPADP, CTRL_RBID_BUILD, (void*)cItrl, sizeof(CRLC_RbidBuild_IOCTRLMsg));
	fsm_mem_free(cItrl);
    bfbd:	e8 fc ff ff ff       	call   bfbe <PCRLC_DEACT_REQ+0x6e>
	cItrl = NULL;
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    bfc2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bfc5:	e8 fc ff ff ff       	call   bfc6 <PCRLC_DEACT_REQ+0x76>
	cIoctrl = NULL;

	FOUT;
}
    bfca:	83 c4 20             	add    $0x20,%esp
    bfcd:	5b                   	pop    %ebx
    bfce:	5e                   	pop    %esi
    bfcf:	5f                   	pop    %edi
    bfd0:	5d                   	pop    %ebp
    bfd1:	c3                   	ret    
    bfd2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity,&insptru, &insptrd , &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_DEACT_REQ] entering PCRLC_DEACT_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    bfd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bfdb:	85 d2                	test   %edx,%edx
    bfdd:	0f 84 b7 00 00 00    	je     c09a <PCRLC_DEACT_REQ+0x14a>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    bfe3:	8b 8a c4 10 00 00    	mov    0x10c4(%edx),%ecx
    bfe9:	8b 82 c8 10 00 00    	mov    0x10c8(%edx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    bfef:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
    bff2:	89 08                	mov    %ecx,(%eax)
		{
			umRxIns = (UM_RX_Instance *)insptrd;
			//UM
			list_del(&umRxIns->umRxList);
			fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um recv instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    bff4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    bff7:	c7 82 c4 10 00 00 00 	movl   $0x100100,0x10c4(%edx)
    bffe:	01 10 00 
	entry->prev = LIST_POISON2;
    c001:	c7 82 c8 10 00 00 00 	movl   $0x200200,0x10c8(%edx)
    c008:	02 20 00 
    c00b:	0f b6 01             	movzbl (%ecx),%eax
    c00e:	89 55 dc             	mov    %edx,-0x24(%ebp)
    c011:	c7 04 24 5c 31 00 00 	movl   $0x315c,(%esp)
    c018:	89 44 24 04          	mov    %eax,0x4(%esp)
    c01c:	e8 fc ff ff ff       	call   c01d <PCRLC_DEACT_REQ+0xcd>
			//
			if(!list_empty(&umRxIns->umRecvBuffer.list))
    c021:	8b 55 dc             	mov    -0x24(%ebp),%edx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c024:	8b 72 30             	mov    0x30(%edx),%esi
    c027:	8d 4a 30             	lea    0x30(%edx),%ecx
    c02a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    c02d:	39 f1                	cmp    %esi,%ecx
    c02f:	74 62                	je     c093 <PCRLC_DEACT_REQ+0x143>
			{
				list_for_each_entry_safe(umBuffer,tempUmBuffer, &umRxIns->umRecvBuffer.list,list)
    c031:	8b 06                	mov    (%esi),%eax
    c033:	83 ee 10             	sub    $0x10,%esi
    c036:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    c039:	89 d3                	mov    %edx,%ebx
    c03b:	8d 78 f0             	lea    -0x10(%eax),%edi
    c03e:	eb 12                	jmp    c052 <PCRLC_DEACT_REQ+0x102>
    c040:	8b 47 10             	mov    0x10(%edi),%eax
    c043:	8d 4f 10             	lea    0x10(%edi),%ecx
    c046:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    c049:	8d 50 f0             	lea    -0x10(%eax),%edx
    c04c:	74 43                	je     c091 <PCRLC_DEACT_REQ+0x141>
    c04e:	89 fe                	mov    %edi,%esi
    c050:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c052:	8b 56 14             	mov    0x14(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c055:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c058:	89 02                	mov    %eax,(%edx)
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
    c05a:	8b 55 e0             	mov    -0x20(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c05d:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    c064:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    c06b:	8b 43 0c             	mov    0xc(%ebx),%eax
    c06e:	89 84 82 28 02 00 00 	mov    %eax,0x228(%edx,%eax,4)
					fsm_pkt_destroy(umBuffer->pkt);
    c075:	8b 06                	mov    (%esi),%eax
    c077:	e8 fc ff ff ff       	call   c078 <PCRLC_DEACT_REQ+0x128>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    c07c:	89 f0                	mov    %esi,%eax
				{
					list_del(&umBuffer->list);
					//code
					SV(allocCode[umRxIns->reorderTimerCode]) = umRxIns->reorderTimerCode;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    c07e:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(umBuffer);
    c084:	e8 fc ff ff ff       	call   c085 <PCRLC_DEACT_REQ+0x135>
					umBuffer = NULL;
					if(list_empty(&umRxIns->umRecvBuffer.list))
    c089:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    c08c:	3b 4b 30             	cmp    0x30(%ebx),%ecx
    c08f:	75 af                	jne    c040 <PCRLC_DEACT_REQ+0xf0>
    c091:	89 da                	mov    %ebx,%edx
						break;
					}
				}
			}
			//UM
			fsm_mem_free(umRxIns);
    c093:	89 d0                	mov    %edx,%eax
    c095:	e8 fc ff ff ff       	call   c096 <PCRLC_DEACT_REQ+0x146>
			umRxIns = NULL;
		}
		if(insptru == NULL)
    c09a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    c09d:	85 c0                	test   %eax,%eax
    c09f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    c0a2:	0f 84 08 ff ff ff    	je     bfb0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c0a8:	8b 50 30             	mov    0x30(%eax),%edx
    c0ab:	89 c1                	mov    %eax,%ecx
    c0ad:	8b 40 34             	mov    0x34(%eax),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c0b0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    c0b3:	89 10                	mov    %edx,(%eax)
		}
		umTxIns = (UM_TX_Instance *)insptru;

		//UM
		list_del(&umTxIns->umTxList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:um tran instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c0b5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c0b8:	c7 41 30 00 01 10 00 	movl   $0x100100,0x30(%ecx)
	entry->prev = LIST_POISON2;
    c0bf:	c7 41 34 00 02 20 00 	movl   $0x200200,0x34(%ecx)
    c0c6:	0f b6 02             	movzbl (%edx),%eax
    c0c9:	c7 04 24 b4 31 00 00 	movl   $0x31b4,(%esp)
    c0d0:	89 44 24 04          	mov    %eax,0x4(%esp)
    c0d4:	e8 fc ff ff ff       	call   c0d5 <PCRLC_DEACT_REQ+0x185>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c0d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
		//UM
		if(!list_empty(&umTxIns->umSduBuffer.list))
    c0dc:	8b 7d e8             	mov    -0x18(%ebp),%edi
    c0df:	8b 58 18             	mov    0x18(%eax),%ebx
    c0e2:	83 c7 18             	add    $0x18,%edi
    c0e5:	39 df                	cmp    %ebx,%edi
    c0e7:	74 52                	je     c13b <PCRLC_DEACT_REQ+0x1eb>
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
    c0e9:	8b 03                	mov    (%ebx),%eax
    c0eb:	83 eb 10             	sub    $0x10,%ebx
    c0ee:	8d 70 f0             	lea    -0x10(%eax),%esi
    c0f1:	eb 16                	jmp    c109 <PCRLC_DEACT_REQ+0x1b9>
    c0f3:	90                   	nop
    c0f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c0f8:	8b 46 10             	mov    0x10(%esi),%eax
    c0fb:	8d 4e 10             	lea    0x10(%esi),%ecx
    c0fe:	39 cf                	cmp    %ecx,%edi
    c100:	8d 50 f0             	lea    -0x10(%eax),%edx
    c103:	74 36                	je     c13b <PCRLC_DEACT_REQ+0x1eb>
    c105:	89 f3                	mov    %esi,%ebx
    c107:	89 d6                	mov    %edx,%esi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c109:	8b 53 14             	mov    0x14(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c10c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c10f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
    c111:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c113:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    c11a:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
    c121:	e8 fc ff ff ff       	call   c122 <PCRLC_DEACT_REQ+0x1d2>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    c126:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(umBuffer,tempUmBuffer, &umTxIns->umSduBuffer.list,list)
			{
				list_del(&umBuffer->list);
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    c128:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    c12e:	e8 fc ff ff ff       	call   c12f <PCRLC_DEACT_REQ+0x1df>
				umBuffer = NULL;
				if(list_empty(&umTxIns->umSduBuffer.list))
    c133:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c136:	3b 78 18             	cmp    0x18(%eax),%edi
    c139:	75 bd                	jne    c0f8 <PCRLC_DEACT_REQ+0x1a8>
					break;
				}
			}
		}
		//UM
		fsm_mem_free(umTxIns);
    c13b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c13e:	e8 fc ff ff ff       	call   c13f <PCRLC_DEACT_REQ+0x1ef>
		umTxIns = NULL;
		break;
    c143:	e9 68 fe ff ff       	jmp    bfb0 <PCRLC_DEACT_REQ+0x60>
	case AM_MODE:
		amIns = (AM_Instance *)insptru;
    c148:	8b 75 ec             	mov    -0x14(%ebp),%esi
		if(amIns == NULL)
    c14b:	85 f6                	test   %esi,%esi
    c14d:	0f 84 5d fe ff ff    	je     bfb0 <PCRLC_DEACT_REQ+0x60>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c153:	8b 96 04 23 00 00    	mov    0x2304(%esi),%edx
    c159:	8b 86 08 23 00 00    	mov    0x2308(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c15f:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    c162:	89 10                	mov    %edx,(%eax)
		{
			break;
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
    c164:	8b 55 e4             	mov    -0x1c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c167:	c7 86 04 23 00 00 00 	movl   $0x100100,0x2304(%esi)
    c16e:	01 10 00 
	entry->prev = LIST_POISON2;
    c171:	c7 86 08 23 00 00 00 	movl   $0x200200,0x2308(%esi)
    c178:	02 20 00 
    c17b:	0f b6 02             	movzbl (%edx),%eax
    c17e:	c7 04 24 0c 32 00 00 	movl   $0x320c,(%esp)
    c185:	89 44 24 04          	mov    %eax,0x4(%esp)
    c189:	e8 fc ff ff ff       	call   c18a <PCRLC_DEACT_REQ+0x23a>
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c18e:	8b 46 0c             	mov    0xc(%esi),%eax
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c191:	8d 96 9c 01 00 00    	lea    0x19c(%esi),%edx
		}
		//AM
		list_del(&amIns->amList);
		fsm_printf("[RLC][PCRLC_DEACT_REQ] PCRLC_DEACT_REQ:am instance has been deacted(rbid is %d)\n", cIoctrl->rbIdentity);
		//code
		SV(allocCode[amIns->pollRetxTimerCode]) = amIns->pollRetxTimerCode;
    c197:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->reorderTimerCode]) = amIns->reorderTimerCode;
    c19e:	8b 46 18             	mov    0x18(%esi),%eax
    c1a1:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
		SV(allocCode[amIns->statProhTimerCode]) = amIns->statProhTimerCode;
    c1a8:	8b 46 24             	mov    0x24(%esi),%eax
    c1ab:	89 84 83 28 02 00 00 	mov    %eax,0x228(%ebx,%eax,4)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c1b2:	8b 9e 9c 01 00 00    	mov    0x19c(%esi),%ebx
		//
		if(!list_empty(&amIns->amRetxBuffer.list))
    c1b8:	39 da                	cmp    %ebx,%edx
    c1ba:	74 77                	je     c233 <PCRLC_DEACT_REQ+0x2e3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
    c1bc:	8b 03                	mov    (%ebx),%eax
    c1be:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c1c4:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c1c7:	89 d6                	mov    %edx,%esi
    c1c9:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c1cf:	eb 21                	jmp    c1f2 <PCRLC_DEACT_REQ+0x2a2>
    c1d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c1d8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c1de:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c1e4:	39 ce                	cmp    %ecx,%esi
    c1e6:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c1ec:	74 42                	je     c230 <PCRLC_DEACT_REQ+0x2e0>
    c1ee:	89 fb                	mov    %edi,%ebx
    c1f0:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c1f2:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c1f8:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c1fb:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c1fd:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c1ff:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c206:	01 10 00 
	entry->prev = LIST_POISON2;
    c209:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c210:	02 20 00 
    c213:	e8 fc ff ff ff       	call   c214 <PCRLC_DEACT_REQ+0x2c4>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c218:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRetxBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c21a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c220:	e8 fc ff ff ff       	call   c221 <PCRLC_DEACT_REQ+0x2d1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRetxBuffer.list))
    c225:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c228:	3b b0 9c 01 00 00    	cmp    0x19c(%eax),%esi
    c22e:	75 a8                	jne    c1d8 <PCRLC_DEACT_REQ+0x288>
    c230:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c233:	8b 9e f0 00 00 00    	mov    0xf0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amTransmittedBuffer.list))
    c239:	8d 96 f0 00 00 00    	lea    0xf0(%esi),%edx
    c23f:	39 da                	cmp    %ebx,%edx
    c241:	74 70                	je     c2b3 <PCRLC_DEACT_REQ+0x363>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
    c243:	8b 03                	mov    (%ebx),%eax
    c245:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c24b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c24e:	89 d6                	mov    %edx,%esi
    c250:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c256:	eb 1a                	jmp    c272 <PCRLC_DEACT_REQ+0x322>
    c258:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c25e:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c264:	39 ce                	cmp    %ecx,%esi
    c266:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c26c:	74 42                	je     c2b0 <PCRLC_DEACT_REQ+0x360>
    c26e:	89 fb                	mov    %edi,%ebx
    c270:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c272:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c278:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c27b:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c27d:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c27f:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c286:	01 10 00 
	entry->prev = LIST_POISON2;
    c289:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c290:	02 20 00 
    c293:	e8 fc ff ff ff       	call   c294 <PCRLC_DEACT_REQ+0x344>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c298:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amTransmittedBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c29a:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c2a0:	e8 fc ff ff ff       	call   c2a1 <PCRLC_DEACT_REQ+0x351>
				amBuffer = NULL;
				if(list_empty(&amIns->amTransmittedBuffer.list))
    c2a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c2a8:	3b b0 f0 00 00 00    	cmp    0xf0(%eax),%esi
    c2ae:	75 a8                	jne    c258 <PCRLC_DEACT_REQ+0x308>
    c2b0:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c2b3:	8b 5e 44             	mov    0x44(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amSduBuffer.list))
    c2b6:	8d 56 44             	lea    0x44(%esi),%edx
    c2b9:	39 da                	cmp    %ebx,%edx
    c2bb:	74 59                	je     c316 <PCRLC_DEACT_REQ+0x3c6>
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
    c2bd:	8b 03                	mov    (%ebx),%eax
    c2bf:	83 eb 0c             	sub    $0xc,%ebx
    c2c2:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c2c5:	89 d6                	mov    %edx,%esi
    c2c7:	8d 78 f4             	lea    -0xc(%eax),%edi
    c2ca:	eb 15                	jmp    c2e1 <PCRLC_DEACT_REQ+0x391>
    c2cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c2d0:	8b 47 0c             	mov    0xc(%edi),%eax
    c2d3:	8d 4f 0c             	lea    0xc(%edi),%ecx
    c2d6:	39 ce                	cmp    %ecx,%esi
    c2d8:	8d 50 f4             	lea    -0xc(%eax),%edx
    c2db:	74 36                	je     c313 <PCRLC_DEACT_REQ+0x3c3>
    c2dd:	89 fb                	mov    %edi,%ebx
    c2df:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c2e1:	8b 53 10             	mov    0x10(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c2e4:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c2e7:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
    c2e9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c2eb:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    c2f2:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
    c2f9:	e8 fc ff ff ff       	call   c2fa <PCRLC_DEACT_REQ+0x3aa>
				amsBuffer->pkt = NULL;
				fsm_mem_free(amsBuffer);
    c2fe:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amsBuffer,tempAmsBuffer, &amIns->amSduBuffer.list,list)
			{
				list_del(&amsBuffer->list);
				fsm_pkt_destroy(amsBuffer->pkt);
				amsBuffer->pkt = NULL;
    c300:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amsBuffer);
    c306:	e8 fc ff ff ff       	call   c307 <PCRLC_DEACT_REQ+0x3b7>
				amsBuffer = NULL;
				if(list_empty(&amIns->amSduBuffer.list))
    c30b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c30e:	3b 70 44             	cmp    0x44(%eax),%esi
    c311:	75 bd                	jne    c2d0 <PCRLC_DEACT_REQ+0x380>
    c313:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c316:	8b 9e b0 01 00 00    	mov    0x1b0(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->ctrlPduBuffer.list))
    c31c:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    c322:	39 da                	cmp    %ebx,%edx
    c324:	74 5b                	je     c381 <PCRLC_DEACT_REQ+0x431>
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
    c326:	8b 03                	mov    (%ebx),%eax
    c328:	83 eb 04             	sub    $0x4,%ebx
    c32b:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c32e:	89 d6                	mov    %edx,%esi
    c330:	8d 78 fc             	lea    -0x4(%eax),%edi
    c333:	eb 14                	jmp    c349 <PCRLC_DEACT_REQ+0x3f9>
    c335:	8d 76 00             	lea    0x0(%esi),%esi
    c338:	8b 47 04             	mov    0x4(%edi),%eax
    c33b:	8d 4f 04             	lea    0x4(%edi),%ecx
    c33e:	39 ce                	cmp    %ecx,%esi
    c340:	8d 50 fc             	lea    -0x4(%eax),%edx
    c343:	74 39                	je     c37e <PCRLC_DEACT_REQ+0x42e>
    c345:	89 fb                	mov    %edi,%ebx
    c347:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c349:	8b 53 08             	mov    0x8(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c34c:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c34f:	89 02                	mov    %eax,(%edx)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
    c351:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c353:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    c35a:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    c361:	e8 fc ff ff ff       	call   c362 <PCRLC_DEACT_REQ+0x412>
				buffer->pkt = NULL;
				fsm_mem_free(buffer);
    c366:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(buffer,tempBuffer, &amIns->ctrlPduBuffer.list,list)
			{
				list_del(&buffer->list);
				fsm_pkt_destroy(buffer->pkt);
				buffer->pkt = NULL;
    c368:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(buffer);
    c36e:	e8 fc ff ff ff       	call   c36f <PCRLC_DEACT_REQ+0x41f>
				buffer = NULL;
				if(list_empty(&amIns->ctrlPduBuffer.list))
    c373:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c376:	3b b0 b0 01 00 00    	cmp    0x1b0(%eax),%esi
    c37c:	75 ba                	jne    c338 <PCRLC_DEACT_REQ+0x3e8>
    c37e:	8b 75 e8             	mov    -0x18(%ebp),%esi
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c381:	8b 9e 5c 02 00 00    	mov    0x25c(%esi),%ebx
					break;
				}
			}
		}
		//
		if(!list_empty(&amIns->amRecvBuffer.list))
    c387:	8d 96 5c 02 00 00    	lea    0x25c(%esi),%edx
    c38d:	39 da                	cmp    %ebx,%edx
    c38f:	74 72                	je     c403 <PCRLC_DEACT_REQ+0x4b3>
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
    c391:	8b 03                	mov    (%ebx),%eax
    c393:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
    c399:	89 75 e8             	mov    %esi,-0x18(%ebp)
    c39c:	89 d6                	mov    %edx,%esi
    c39e:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    c3a4:	eb 1c                	jmp    c3c2 <PCRLC_DEACT_REQ+0x472>
    c3a6:	66 90                	xchg   %ax,%ax
    c3a8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    c3ae:	8d 8f 9c 00 00 00    	lea    0x9c(%edi),%ecx
    c3b4:	39 ce                	cmp    %ecx,%esi
    c3b6:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
    c3bc:	74 42                	je     c400 <PCRLC_DEACT_REQ+0x4b0>
    c3be:	89 fb                	mov    %edi,%ebx
    c3c0:	89 d7                	mov    %edx,%edi
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    c3c2:	8b 93 a0 00 00 00    	mov    0xa0(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    c3c8:	89 50 04             	mov    %edx,0x4(%eax)
	prev->next = next;
    c3cb:	89 02                	mov    %eax,(%edx)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
    c3cd:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    c3cf:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
    c3d6:	01 10 00 
	entry->prev = LIST_POISON2;
    c3d9:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
    c3e0:	02 20 00 
    c3e3:	e8 fc ff ff ff       	call   c3e4 <PCRLC_DEACT_REQ+0x494>
				amBuffer->pkt = NULL;
				fsm_mem_free(amBuffer);
    c3e8:	89 d8                	mov    %ebx,%eax
		{
			list_for_each_entry_safe(amBuffer,tempAmBuffer, &amIns->amRecvBuffer.list,list)
			{
				list_del(&amBuffer->list);
				fsm_pkt_destroy(amBuffer->pkt);
				amBuffer->pkt = NULL;
    c3ea:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(amBuffer);
    c3f0:	e8 fc ff ff ff       	call   c3f1 <PCRLC_DEACT_REQ+0x4a1>
				amBuffer = NULL;
				if(list_empty(&amIns->amRecvBuffer.list))
    c3f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c3f8:	3b b0 5c 02 00 00    	cmp    0x25c(%eax),%esi
    c3fe:	75 a8                	jne    c3a8 <PCRLC_DEACT_REQ+0x458>
    c400:	8b 75 e8             	mov    -0x18(%ebp),%esi
					break;
				}
			}
		}
		//AM
		fsm_mem_free(amIns);
    c403:	89 f0                	mov    %esi,%eax
    c405:	e8 fc ff ff ff       	call   c406 <PCRLC_DEACT_REQ+0x4b6>
		amIns = NULL;
		break;
    c40a:	e9 a1 fb ff ff       	jmp    bfb0 <PCRLC_DEACT_REQ+0x60>
    c40f:	90                   	nop

0000c410 <PCRLC_SUSPEND_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_SUSPEND_REQ(void)
{
    c410:	55                   	push   %ebp
    c411:	89 e5                	mov    %esp,%ebp
    c413:	56                   	push   %esi
    c414:	53                   	push   %ebx
    c415:	83 ec 14             	sub    $0x14,%esp
    c418:	e8 fc ff ff ff       	call   c419 <PCRLC_SUSPEND_REQ+0x9>
	CRLC_SuspendReq_IoctrlMsg *cIoctrl = (CRLC_SuspendReq_IoctrlMsg*) fsm_data_get();
    c41d:	e8 fc ff ff ff       	call   c41e <PCRLC_SUSPEND_REQ+0xe>
    c422:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c424:	e8 fc ff ff ff       	call   c425 <PCRLC_SUSPEND_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c429:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void *insptru, *insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c42c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c42e:	0f b6 06             	movzbl (%esi),%eax
    c431:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c437:	89 14 24             	mov    %edx,(%esp)
    c43a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c43d:	e8 fc ff ff ff       	call   c43e <PCRLC_SUSPEND_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
    c442:	0f b6 06             	movzbl (%esi),%eax
    c445:	89 44 24 08          	mov    %eax,0x8(%esp)
    c449:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c44f:	c7 04 24 b8 32 00 00 	movl   $0x32b8,(%esp)
    c456:	89 44 24 04          	mov    %eax,0x4(%esp)
    c45a:	e8 fc ff ff ff       	call   c45b <PCRLC_SUSPEND_REQ+0x4b>
	switch(SV(ins_mode))
    c45f:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c465:	83 f8 02             	cmp    $0x2,%eax
    c468:	74 26                	je     c490 <PCRLC_SUSPEND_REQ+0x80>
    c46a:	83 f8 03             	cmp    $0x3,%eax
    c46d:	0f 84 85 00 00 00    	je     c4f8 <PCRLC_SUSPEND_REQ+0xe8>
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
		}
		break;
	default:
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:cannot distinguish the instance \n");
    c473:	c7 04 24 20 34 00 00 	movl   $0x3420,(%esp)
    c47a:	e8 fc ff ff ff       	call   c47b <PCRLC_SUSPEND_REQ+0x6b>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c47f:	89 f0                	mov    %esi,%eax
    c481:	e8 fc ff ff ff       	call   c482 <PCRLC_SUSPEND_REQ+0x72>
	cIoctrl = NULL;
	FOUT;
}
    c486:	83 c4 14             	add    $0x14,%esp
    c489:	5b                   	pop    %ebx
    c48a:	5e                   	pop    %esi
    c48b:	5d                   	pop    %ebp
    c48c:	c3                   	ret    
    c48d:	8d 76 00             	lea    0x0(%esi),%esi
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_SUSPEND_REQ] entering PCRLC_SUSPEND_REQ(SV(ins_mode) is %d,cIoctrl->rbIdentity is %d)\n",SV(ins_mode),cIoctrl->rbIdentity);
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd != NULL)
    c490:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c493:	85 db                	test   %ebx,%ebx
    c495:	74 2e                	je     c4c5 <PCRLC_SUSPEND_REQ+0xb5>
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c497:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
	case UM_MODE:
		if(insptrd != NULL)
		{
			umRxIns = (UM_RX_Instance *)insptrd;

			umRxIns->currentStatVar = ST_SUSPEND;
    c49b:	c6 83 c2 10 00 00 09 	movb   $0x9,0x10c2(%ebx)
			fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um recv instance has suspended (rbid is %d)\n", umRxIns->rbId);
    c4a2:	c7 04 24 1c 33 00 00 	movl   $0x331c,(%esp)
    c4a9:	89 44 24 04          	mov    %eax,0x4(%esp)
    c4ad:	e8 fc ff ff ff       	call   c4ae <PCRLC_SUSPEND_REQ+0x9e>
			if(umRxIns->reorderTimer)
    c4b2:	8b 43 08             	mov    0x8(%ebx),%eax
    c4b5:	85 c0                	test   %eax,%eax
    c4b7:	74 0c                	je     c4c5 <PCRLC_SUSPEND_REQ+0xb5>
			{
				fsm_schedule_cancel(umRxIns->reorderTimer);
    c4b9:	e8 fc ff ff ff       	call   c4ba <PCRLC_SUSPEND_REQ+0xaa>
				umRxIns->reorderTimer = 0;
    c4be:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
			}
		}
		if(insptru == NULL)
    c4c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c4c8:	85 c0                	test   %eax,%eax
    c4ca:	74 b3                	je     c47f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		umTxIns = (UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_SUSPEND;
    c4cc:	c6 40 2c 09          	movb   $0x9,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
    c4d0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    c4d4:	c7 04 24 74 33 00 00 	movl   $0x3374,(%esp)
    c4db:	89 44 24 04          	mov    %eax,0x4(%esp)
    c4df:	e8 fc ff ff ff       	call   c4e0 <PCRLC_SUSPEND_REQ+0xd0>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c4e4:	89 f0                	mov    %esi,%eax
    c4e6:	e8 fc ff ff ff       	call   c4e7 <PCRLC_SUSPEND_REQ+0xd7>
	cIoctrl = NULL;
	FOUT;
}
    c4eb:	83 c4 14             	add    $0x14,%esp
    c4ee:	5b                   	pop    %ebx
    c4ef:	5e                   	pop    %esi
    c4f0:	5d                   	pop    %ebp
    c4f1:	c3                   	ret    
    c4f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:um tran instance has suspended (rbid is %d)\n", umTxIns->rbid);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c4f8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    c4fb:	85 db                	test   %ebx,%ebx
    c4fd:	0f 84 7c ff ff ff    	je     c47f <PCRLC_SUSPEND_REQ+0x6f>
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c503:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
		if(insptru == NULL)
		{
			break;
		}
		amIns =  (AM_Instance * )insptru;
		amIns->currentStatVar = ST_SUSPEND;
    c507:	66 c7 43 2c 09 00    	movw   $0x9,0x2c(%ebx)
		fsm_printf("[RLC][PCRLC_SUSPEND_REQ] PCRLC_SUSPEND_REQ:am instance has suspended (rbid is %d)\n", amIns->rbId);
    c50d:	c7 04 24 cc 33 00 00 	movl   $0x33cc,(%esp)
    c514:	89 44 24 04          	mov    %eax,0x4(%esp)
    c518:	e8 fc ff ff ff       	call   c519 <PCRLC_SUSPEND_REQ+0x109>
		if(amIns->pollRetxTimer)
    c51d:	8b 43 08             	mov    0x8(%ebx),%eax
    c520:	85 c0                	test   %eax,%eax
    c522:	74 0c                	je     c530 <PCRLC_SUSPEND_REQ+0x120>
		{
			fsm_schedule_cancel(amIns->pollRetxTimer);
    c524:	e8 fc ff ff ff       	call   c525 <PCRLC_SUSPEND_REQ+0x115>
			amIns->pollRetxTimer = 0;
    c529:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
		}
		if(amIns->reorderTimer)
    c530:	8b 43 14             	mov    0x14(%ebx),%eax
    c533:	85 c0                	test   %eax,%eax
    c535:	74 0c                	je     c543 <PCRLC_SUSPEND_REQ+0x133>
		{
			fsm_schedule_cancel(amIns->reorderTimer);
    c537:	e8 fc ff ff ff       	call   c538 <PCRLC_SUSPEND_REQ+0x128>
			amIns->reorderTimer = 0;
    c53c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
		}
		if(amIns->statProhTimer)
    c543:	8b 43 20             	mov    0x20(%ebx),%eax
    c546:	85 c0                	test   %eax,%eax
    c548:	0f 84 31 ff ff ff    	je     c47f <PCRLC_SUSPEND_REQ+0x6f>
		{
			fsm_schedule_cancel(amIns->statProhTimer);
    c54e:	e8 fc ff ff ff       	call   c54f <PCRLC_SUSPEND_REQ+0x13f>
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c553:	89 f0                	mov    %esi,%eax
			amIns->reorderTimer = 0;
		}
		if(amIns->statProhTimer)
		{
			fsm_schedule_cancel(amIns->statProhTimer);
			amIns->statProhTimer = 0;
    c555:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
		break;
	}

	//  fsm_schedule_self(0, CRLC_SUSPEND_REQ);
	//fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c55c:	e8 fc ff ff ff       	call   c55d <PCRLC_SUSPEND_REQ+0x14d>
	cIoctrl = NULL;
	FOUT;
}
    c561:	83 c4 14             	add    $0x14,%esp
    c564:	5b                   	pop    %ebx
    c565:	5e                   	pop    %esi
    c566:	5d                   	pop    %ebp
    c567:	c3                   	ret    
    c568:	90                   	nop
    c569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c570 <PCRLC_RESUME_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_RESUME_REQ(void)
{
    c570:	55                   	push   %ebp
    c571:	89 e5                	mov    %esp,%ebp
    c573:	56                   	push   %esi
    c574:	53                   	push   %ebx
    c575:	83 ec 10             	sub    $0x10,%esp
    c578:	e8 fc ff ff ff       	call   c579 <PCRLC_RESUME_REQ+0x9>
	CRLC_ResumeReq_IoctrlMsg *cIoctrl = (CRLC_ResumeReq_IoctrlMsg*) fsm_data_get();
    c57d:	e8 fc ff ff ff       	call   c57e <PCRLC_RESUME_REQ+0xe>
    c582:	89 c6                	mov    %eax,%esi
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c584:	e8 fc ff ff ff       	call   c585 <PCRLC_RESUME_REQ+0x15>
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c589:	8d 4d f4             	lea    -0xc(%ebp),%ecx
	struct  AM_Instance * amIns;
	struct  UM_RX_Instance *umRxIns;
	struct  UM_TX_Instance *umTxIns;
	void * insptru,*insptrd;
	
	SV_PTR_GET(rlc_mac_sv);
    c58c:	89 c3                	mov    %eax,%ebx
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
    c58e:	0f b6 06             	movzbl (%esi),%eax
    c591:	8d 93 18 02 00 00    	lea    0x218(%ebx),%edx
    c597:	89 14 24             	mov    %edx,(%esp)
    c59a:	8d 55 f0             	lea    -0x10(%ebp),%edx
    c59d:	e8 fc ff ff ff       	call   c59e <PCRLC_RESUME_REQ+0x2e>
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
    c5a2:	c7 04 24 70 34 00 00 	movl   $0x3470,(%esp)
    c5a9:	e8 fc ff ff ff       	call   c5aa <PCRLC_RESUME_REQ+0x3a>
	switch(SV(ins_mode))
    c5ae:	8b 83 18 02 00 00    	mov    0x218(%ebx),%eax
    c5b4:	83 f8 02             	cmp    $0x2,%eax
    c5b7:	74 1f                	je     c5d8 <PCRLC_RESUME_REQ+0x68>
    c5b9:	83 f8 03             	cmp    $0x3,%eax
    c5bc:	74 6a                	je     c628 <PCRLC_RESUME_REQ+0xb8>
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
    c5be:	c7 04 24 9f 07 00 00 	movl   $0x79f,(%esp)
    c5c5:	e8 fc ff ff ff       	call   c5c6 <PCRLC_RESUME_REQ+0x56>
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c5ca:	89 f0                	mov    %esi,%eax
    c5cc:	e8 fc ff ff ff       	call   c5cd <PCRLC_RESUME_REQ+0x5d>
	FOUT;
}
    c5d1:	83 c4 10             	add    $0x10,%esp
    c5d4:	5b                   	pop    %ebx
    c5d5:	5e                   	pop    %esi
    c5d6:	5d                   	pop    %ebp
    c5d7:	c3                   	ret    
	findInsByRbid(cIoctrl->rbIdentity, &insptru, &insptrd, &SV(ins_mode));
	fsm_printf("[RLC][PCRLC_RESUME_REQ] entering PCRLC_RESUME_REQ\n");
	switch(SV(ins_mode))
	{
	case UM_MODE:
		if(insptrd == NULL)
    c5d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c5db:	85 c0                	test   %eax,%eax
    c5dd:	74 eb                	je     c5ca <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umRxIns = ( UM_RX_Instance *)insptrd;
		umRxIns->currentStatVar = ST_TRAN;
    c5df:	c6 80 c2 10 00 00 08 	movb   $0x8,0x10c2(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um recv instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c5e6:	0f b6 06             	movzbl (%esi),%eax
    c5e9:	c7 04 24 a4 34 00 00 	movl   $0x34a4,(%esp)
    c5f0:	89 44 24 04          	mov    %eax,0x4(%esp)
    c5f4:	e8 fc ff ff ff       	call   c5f5 <PCRLC_RESUME_REQ+0x85>

		if(insptru == NULL)
    c5f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c5fc:	85 c0                	test   %eax,%eax
    c5fe:	74 ca                	je     c5ca <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		umTxIns = ( UM_TX_Instance *)insptru;
		umTxIns->CurrentStatVar = ST_TRAN;
    c600:	c6 40 2c 08          	movb   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c604:	0f b6 06             	movzbl (%esi),%eax
    c607:	c7 04 24 f8 34 00 00 	movl   $0x34f8,(%esp)
    c60e:	89 44 24 04          	mov    %eax,0x4(%esp)
    c612:	e8 fc ff ff ff       	call   c613 <PCRLC_RESUME_REQ+0xa3>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c617:	89 f0                	mov    %esi,%eax
    c619:	e8 fc ff ff ff       	call   c61a <PCRLC_RESUME_REQ+0xaa>
	FOUT;
}
    c61e:	83 c4 10             	add    $0x10,%esp
    c621:	5b                   	pop    %ebx
    c622:	5e                   	pop    %esi
    c623:	5d                   	pop    %ebp
    c624:	c3                   	ret    
    c625:	8d 76 00             	lea    0x0(%esi),%esi
		umTxIns->CurrentStatVar = ST_TRAN;
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:um tran instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
		break;

	case AM_MODE:
		if(insptru == NULL)
    c628:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c62b:	85 c0                	test   %eax,%eax
    c62d:	74 9b                	je     c5ca <PCRLC_RESUME_REQ+0x5a>
		{
			break;
		}
		amIns = (AM_Instance *)insptru;
		amIns->currentStatVar = ST_TRAN;
    c62f:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
		fsm_printf("[RLC][PCRLC_RESUME_REQ] PCRLC_RESUME_REQ:am instance has resumed(rbid is %d)\n",cIoctrl->rbIdentity);
    c635:	0f b6 06             	movzbl (%esi),%eax
    c638:	c7 04 24 4c 35 00 00 	movl   $0x354c,(%esp)
    c63f:	89 44 24 04          	mov    %eax,0x4(%esp)
    c643:	e8 fc ff ff ff       	call   c644 <PCRLC_RESUME_REQ+0xd4>
	default:
		fsm_printf("[RLC][PCRLC_RESUME_REQ]  \n");
		break;
	}
	//   fsm_mem_free(cIoctrl);
	fsm_data_destroy(cIoctrl);
    c648:	89 f0                	mov    %esi,%eax
    c64a:	e8 fc ff ff ff       	call   c64b <PCRLC_RESUME_REQ+0xdb>
	FOUT;
}
    c64f:	83 c4 10             	add    $0x10,%esp
    c652:	5b                   	pop    %ebx
    c653:	5e                   	pop    %esi
    c654:	5d                   	pop    %ebp
    c655:	c3                   	ret    
    c656:	8d 76 00             	lea    0x0(%esi),%esi
    c659:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c660 <PCRLC_STATUS_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c660:	55                   	push   %ebp
    c661:	89 e5                	mov    %esp,%ebp
    c663:	83 ec 10             	sub    $0x10,%esp
    c666:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    c669:	89 75 f8             	mov    %esi,-0x8(%ebp)
    c66c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    c66f:	e8 fc ff ff ff       	call   c670 <PCRLC_STATUS_IND+0x10>
    c674:	89 c6                	mov    %eax,%esi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c676:	b8 04 00 00 00       	mov    $0x4,%eax
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
    c67b:	89 d7                	mov    %edx,%edi
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c67d:	e8 fc ff ff ff       	call   c67e <PCRLC_STATUS_IND+0x1e>
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c682:	ba 51 00 00 00       	mov    $0x51,%edx
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
    c687:	89 c3                	mov    %eax,%ebx
	cioctrl->eventCode = evCode;
    c689:	66 89 38             	mov    %di,(%eax)
	cioctrl->rbIdentity = rbid;
    c68c:	89 f0                	mov    %esi,%eax
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c68e:	89 d9                	mov    %ebx,%ecx
**********************************************************/
void PCRLC_STATUS_IND(u8 rbid, u16 evCode)
{
	CRLC_StatusInd_IoctrlMsg *cioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
	cioctrl->eventCode = evCode;
	cioctrl->rbIdentity = rbid;
    c690:	88 43 02             	mov    %al,0x2(%ebx)
	fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND,( void * )cioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
    c693:	b8 05 00 00 00       	mov    $0x5,%eax
    c698:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
    c69f:	e8 fc ff ff ff       	call   c6a0 <PCRLC_STATUS_IND+0x40>
	fsm_mem_free(cioctrl);
    c6a4:	89 d8                	mov    %ebx,%eax
    c6a6:	e8 fc ff ff ff       	call   c6a7 <PCRLC_STATUS_IND+0x47>
	//fsm_data_destroy(cioctrl);
	cioctrl = NULL;
	FOUT;
}
    c6ab:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    c6ae:	8b 75 f8             	mov    -0x8(%ebp),%esi
    c6b1:	8b 7d fc             	mov    -0x4(%ebp),%edi
    c6b4:	89 ec                	mov    %ebp,%esp
    c6b6:	5d                   	pop    %ebp
    c6b7:	c3                   	ret    
    c6b8:	90                   	nop
    c6b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000c6c0 <PPRLC_DISC_REQ>:

//
inline void PPRLC_DISC_REQ(void)  {}
    c6c0:	55                   	push   %ebp
    c6c1:	89 e5                	mov    %esp,%ebp
    c6c3:	5d                   	pop    %ebp
    c6c4:	c3                   	ret    
    c6c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    c6c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000c6d0 <PMRLC_BUFFERREP_REQ>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
**********************************************************/
void* PMRLC_BUFFERREP_REQ(void)
{
    c6d0:	55                   	push   %ebp
    c6d1:	89 e5                	mov    %esp,%ebp
    c6d3:	57                   	push   %edi
    c6d4:	56                   	push   %esi
    c6d5:	53                   	push   %ebx
    c6d6:	83 ec 20             	sub    $0x20,%esp
    c6d9:	e8 fc ff ff ff       	call   c6da <PMRLC_BUFFERREP_REQ+0xa>
	struct AM_Instance * amIns;
	struct UM_TX_Instance *umTxIns;
	struct TM_TX_Instance *tmTxIns;
	struct AmBuffer *amBuffer;
	CtrlBuffer *ctrlBf;
	u32 num = 0,*nump;  //
    c6de:	31 db                	xor    %ebx,%ebx

	SV_PTR_GET(rlc_mac_sv);
    c6e0:	e8 fc ff ff ff       	call   c6e1 <PMRLC_BUFFERREP_REQ+0x11>
    c6e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    c6e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c6eb:	05 f4 25 00 00       	add    $0x25f4,%eax
    c6f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    c6f3:	8b 82 f4 25 00 00    	mov    0x25f4(%edx),%eax
    c6f9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    c6fc:	74 33                	je     c731 <PMRLC_BUFFERREP_REQ+0x61>
    c6fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    c701:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c708:	8b b8 48 dd ff ff    	mov    -0x22b8(%eax),%edi
    c70e:	85 ff                	test   %edi,%edi
    c710:	75 16                	jne    c728 <PMRLC_BUFFERREP_REQ+0x58>
    c712:	8b b0 a0 de ff ff    	mov    -0x2160(%eax),%esi
    c718:	85 f6                	test   %esi,%esi
    c71a:	75 0c                	jne    c728 <PMRLC_BUFFERREP_REQ+0x58>
    c71c:	8b 88 b4 de ff ff    	mov    -0x214c(%eax),%ecx
    c722:	85 c9                	test   %ecx,%ecx
    c724:	74 05                	je     c72b <PMRLC_BUFFERREP_REQ+0x5b>
    c726:	66 90                	xchg   %ax,%ax
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] am instance (rbid is %d) has data to report\n", amIns->rbId);
				num++;
    c728:	83 c3 01             	add    $0x1,%ebx

	SV_PTR_GET(rlc_mac_sv);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c72b:	8b 00                	mov    (%eax),%eax
    c72d:	39 c2                	cmp    %eax,%edx
    c72f:	75 d7                	jne    c708 <PMRLC_BUFFERREP_REQ+0x38>
				num++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c731:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c734:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c737:	05 f8 36 00 00       	add    $0x36f8,%eax
    c73c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    c73f:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
    c745:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c748:	74 13                	je     c75d <PMRLC_BUFFERREP_REQ+0x8d>
    c74a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    c74d:	8d 76 00             	lea    0x0(%esi),%esi
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c750:	83 78 f0 01          	cmpl   $0x1,-0x10(%eax)
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c754:	8b 00                	mov    (%eax),%eax
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
    c756:	83 db ff             	sbb    $0xffffffff,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c759:	39 c2                	cmp    %eax,%edx
    c75b:	75 f3                	jne    c750 <PMRLC_BUFFERREP_REQ+0x80>
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] um instance (rbid is %d) has data to report\n", umTxIns->rbid);
				num++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c75d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c760:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c763:	05 2c 37 00 00       	add    $0x372c,%eax
    c768:	89 45 dc             	mov    %eax,-0x24(%ebp)
    c76b:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
    c771:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c774:	74 17                	je     c78d <PMRLC_BUFFERREP_REQ+0xbd>
    c776:	8b 55 dc             	mov    -0x24(%ebp),%edx
    c779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c780:	83 78 f8 01          	cmpl   $0x1,-0x8(%eax)
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c784:	8b 00                	mov    (%eax),%eax
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] tm instance (rbid is %d) has data to report\n", tmTxIns->rbId);
				num++;
    c786:	83 db ff             	sbb    $0xffffffff,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    c789:	39 c2                	cmp    %eax,%edx
    c78b:	75 f3                	jne    c780 <PMRLC_BUFFERREP_REQ+0xb0>
				num++;
			}
		}
	}
	
	if(num == 0)
    c78d:	85 db                	test   %ebx,%ebx
    c78f:	0f 84 9f 02 00 00    	je     ca34 <PMRLC_BUFFERREP_REQ+0x364>
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c795:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
    c798:	8d 44 43 04          	lea    0x4(%ebx,%eax,2),%eax
    c79c:	e8 fc ff ff ff       	call   c79d <PMRLC_BUFFERREP_REQ+0xcd>
	*nump = num;
    c7a1:	89 18                	mov    %ebx,(%eax)
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c7a3:	89 c3                	mov    %eax,%ebx
		}*/
		return NULL; 	//modify 20150901
		//FOUT;
	}
	//
	nump = (u32 *) fsm_mem_alloc(sizeof(u32) + sizeof(MRLC_ReportReq_IoctrlMsg)*num);
    c7a5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    c7a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
    c7ab:	83 c3 04             	add    $0x4,%ebx
    c7ae:	8b b8 f4 25 00 00    	mov    0x25f4(%eax),%edi
	//
	if (!list_empty(&SV(vAm_ins).amList))
    c7b4:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c7b7:	0f 84 47 01 00 00    	je     c904 <PMRLC_BUFFERREP_REQ+0x234>
    c7bd:	8d 76 00             	lea    0x0(%esi),%esi
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c7c0:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
		{
			amIns = list_entry(pos,struct AM_Instance,amList);
    c7c6:	8d 97 fc dc ff ff    	lea    -0x2304(%edi),%edx
    c7cc:	89 55 f0             	mov    %edx,-0x10(%ebp)
			if(amIns->amSduBufferSize != 0 || amIns->amRetxBufferSize != 0 || amIns->ctrlPduBufferSize != 0)
    c7cf:	85 c0                	test   %eax,%eax
    c7d1:	75 1d                	jne    c7f0 <PMRLC_BUFFERREP_REQ+0x120>
    c7d3:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
    c7d9:	85 c0                	test   %eax,%eax
    c7db:	75 13                	jne    c7f0 <PMRLC_BUFFERREP_REQ+0x120>
    c7dd:	8b b7 b4 de ff ff    	mov    -0x214c(%edi),%esi
    c7e3:	85 f6                	test   %esi,%esi
    c7e5:	0f 84 0e 01 00 00    	je     c8f9 <PMRLC_BUFFERREP_REQ+0x229>
    c7eb:	90                   	nop
    c7ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			{
				mioctrl->rnti = 0;
    c7f0:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = amIns->lcId;
    c7f5:	0f b6 87 ff dc ff ff 	movzbl -0x2301(%edi),%eax
    c7fc:	88 43 02             	mov    %al,0x2(%ebx)
				mioctrl->txQueueSize = amIns->amSduBufferSize;
    c7ff:	8b 87 48 dd ff ff    	mov    -0x22b8(%edi),%eax
    c805:	89 43 03             	mov    %eax,0x3(%ebx)
				mioctrl->txQueueHeader = 2 + 2* amIns->amSduBufferNum;
    c808:	8b 97 4c dd ff ff    	mov    -0x22b4(%edi),%edx
    c80e:	8d 54 12 02          	lea    0x2(%edx,%edx,1),%edx
    c812:	66 89 53 07          	mov    %dx,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c816:	0f b7 d2             	movzwl %dx,%edx
    c819:	01 c2                	add    %eax,%edx
    c81b:	83 fa 7f             	cmp    $0x7f,%edx
    c81e:	0f 87 6c 01 00 00    	ja     c990 <PMRLC_BUFFERREP_REQ+0x2c0>
				{
					mioctrl->txQueueSize += 2;
    c824:	83 c0 02             	add    $0x2,%eax
    c827:	89 43 03             	mov    %eax,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c82a:	8b 87 a0 de ff ff    	mov    -0x2160(%edi),%eax
				mioctrl->retxQueueHeader = 2;
    c830:	66 c7 43 0d 02 00    	movw   $0x2,0xd(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
    c836:	89 43 09             	mov    %eax,0x9(%ebx)
    c839:	8b b7 98 de ff ff    	mov    -0x2168(%edi),%esi
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
    c83f:	8d 87 98 de ff ff    	lea    -0x2168(%edi),%eax
    c845:	39 f0                	cmp    %esi,%eax
    c847:	74 55                	je     c89e <PMRLC_BUFFERREP_REQ+0x1ce>
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c849:	89 7d e8             	mov    %edi,-0x18(%ebp)
    c84c:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
    c852:	89 c7                	mov    %eax,%edi
    c854:	eb 16                	jmp    c86c <PMRLC_BUFFERREP_REQ+0x19c>
    c856:	66 90                	xchg   %ax,%ax
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
						{
							if( amBuffer->pkt->len < 128 )
							{
								mioctrl->retxQueueSize += 2;
    c858:	83 43 09 02          	addl   $0x2,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c85c:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c862:	39 c7                	cmp    %eax,%edi
    c864:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c86a:	74 2f                	je     c89b <PMRLC_BUFFERREP_REQ+0x1cb>
					{
						if(isInsideTranWin(amIns,amBuffer->SN))
    c86c:	0f bf 96 94 00 00 00 	movswl 0x94(%esi),%edx
    c873:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c876:	e8 fc ff ff ff       	call   c877 <PMRLC_BUFFERREP_REQ+0x1a7>
    c87b:	84 c0                	test   %al,%al
    c87d:	74 dd                	je     c85c <PMRLC_BUFFERREP_REQ+0x18c>
						{
							if( amBuffer->pkt->len < 128 )
    c87f:	8b 06                	mov    (%esi),%eax
    c881:	83 78 50 7f          	cmpl   $0x7f,0x50(%eax)
    c885:	76 d1                	jbe    c858 <PMRLC_BUFFERREP_REQ+0x188>
							{
								mioctrl->retxQueueSize += 2;
							}
							else
							{
								mioctrl->retxQueueSize += 3;
    c887:	83 43 09 03          	addl   $0x3,0x9(%ebx)
                
				mioctrl->retxQueueSize = amIns->amRetxBufferSize;
				mioctrl->retxQueueHeader = 2;
				if( !list_empty(&amIns->amRetxBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    c88b:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
    c891:	39 c7                	cmp    %eax,%edi
    c893:	8d b0 64 ff ff ff    	lea    -0x9c(%eax),%esi
    c899:	75 d1                	jne    c86c <PMRLC_BUFFERREP_REQ+0x19c>
    c89b:	8b 7d e8             	mov    -0x18(%ebp),%edi
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c89e:	8b 87 b4 de ff ff    	mov    -0x214c(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c8a4:	8d b7 ac de ff ff    	lea    -0x2154(%edi),%esi
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
    c8aa:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
							}
						}
					}
				}
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
    c8b0:	89 c2                	mov    %eax,%edx
    c8b2:	66 89 43 0f          	mov    %ax,0xf(%ebx)
    c8b6:	8b 87 ac de ff ff    	mov    -0x2154(%edi),%eax
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
    c8bc:	39 c6                	cmp    %eax,%esi
    c8be:	74 36                	je     c8f6 <PMRLC_BUFFERREP_REQ+0x226>
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c8c0:	83 e8 04             	sub    $0x4,%eax
    c8c3:	eb 18                	jmp    c8dd <PMRLC_BUFFERREP_REQ+0x20d>
    c8c5:	8d 76 00             	lea    0x0(%esi),%esi
					{
						if( ctrlBf->pkt->len < 128 )
						{
							mioctrl->statusPduSize += 2;
    c8c8:	83 c2 02             	add    $0x2,%edx
    c8cb:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c8cf:	8b 50 04             	mov    0x4(%eax),%edx
    c8d2:	39 d6                	cmp    %edx,%esi
    c8d4:	8d 42 fc             	lea    -0x4(%edx),%eax
    c8d7:	74 1d                	je     c8f6 <PMRLC_BUFFERREP_REQ+0x226>
    c8d9:	0f b7 53 0f          	movzwl 0xf(%ebx),%edx
					{
						if( ctrlBf->pkt->len < 128 )
    c8dd:	8b 08                	mov    (%eax),%ecx
    c8df:	83 79 50 7f          	cmpl   $0x7f,0x50(%ecx)
    c8e3:	76 e3                	jbe    c8c8 <PMRLC_BUFFERREP_REQ+0x1f8>
						{
							mioctrl->statusPduSize += 2;
						}
						else
						{
							mioctrl->statusPduSize += 3;
    c8e5:	83 c2 03             	add    $0x3,%edx
    c8e8:	66 89 53 0f          	mov    %dx,0xf(%ebx)
		
				mioctrl->statusPduSize = amIns->ctrlPduBufferSize;
				mioctrl->statusPduHeader =  0;
				if( !list_empty(&amIns->ctrlPduBuffer.list) )  //mac, 20140726
				{
					list_for_each_entry(ctrlBf,&amIns->ctrlPduBuffer.list,list)
    c8ec:	8b 50 04             	mov    0x4(%eax),%edx
    c8ef:	39 d6                	cmp    %edx,%esi
    c8f1:	8d 42 fc             	lea    -0x4(%edx),%eax
    c8f4:	75 e3                	jne    c8d9 <PMRLC_BUFFERREP_REQ+0x209>
				}
				else
				{
					mioctrl->statusPduSize += 3;
				}*/
				mioctrl++;
    c8f6:	83 c3 13             	add    $0x13,%ebx
	*nump = num;
	mioctrl = (MRLC_ReportReq_IoctrlMsg*)(nump + 1);
	//
	if (!list_empty(&SV(vAm_ins).amList))
	{
		list_for_each(pos,&SV(vAm_ins).amList)
    c8f9:	8b 3f                	mov    (%edi),%edi
    c8fb:	39 7d ec             	cmp    %edi,-0x14(%ebp)
    c8fe:	0f 85 bc fe ff ff    	jne    c7c0 <PMRLC_BUFFERREP_REQ+0xf0>
    c904:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c907:	8b 82 f8 36 00 00    	mov    0x36f8(%edx),%eax
				mioctrl++;
			}
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
    c90d:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    c910:	0f 84 b2 00 00 00    	je     c9c8 <PMRLC_BUFFERREP_REQ+0x2f8>
    c916:	8b 75 e0             	mov    -0x20(%ebp),%esi
    c919:	eb 18                	jmp    c933 <PMRLC_BUFFERREP_REQ+0x263>
    c91b:	90                   	nop
    c91c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c920:	83 c2 02             	add    $0x2,%edx
    c923:	89 53 03             	mov    %edx,0x3(%ebx)
				else
				{
					mioctrl->txQueueSize += 3;
				}
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
    c926:	83 c3 13             	add    $0x13,%ebx
		}
	}

	if (!list_empty(&SV(vUm_tx_ins).umTxList))
	{
		list_for_each(pos,&SV(vUm_tx_ins).umTxList)
    c929:	8b 00                	mov    (%eax),%eax
    c92b:	39 c6                	cmp    %eax,%esi
    c92d:	0f 84 95 00 00 00    	je     c9c8 <PMRLC_BUFFERREP_REQ+0x2f8>
		{
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
    c933:	8b 48 f0             	mov    -0x10(%eax),%ecx
    c936:	85 c9                	test   %ecx,%ecx
    c938:	74 ef                	je     c929 <PMRLC_BUFFERREP_REQ+0x259>
			{
				mioctrl->rnti = 0;
    c93a:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = umTxIns->lcid;
    c93f:	0f b6 50 d3          	movzbl -0x2d(%eax),%edx
    c943:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c946:	8b 50 f0             	mov    -0x10(%eax),%edx
				mioctrl->retxQueueSize = 0;
    c949:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->retxQueueHeader = 0;
    c950:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				mioctrl->statusPduSize = 0;
    c956:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
			umTxIns= list_entry(pos,struct UM_TX_Instance,umTxList);
			if(umTxIns->umSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = umTxIns->lcid;
				mioctrl->txQueueSize = umTxIns->umSduBufferSize;
    c95c:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->retxQueueSize = 0;
				mioctrl->retxQueueHeader = 0;
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;
    c95f:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)

				if(umTxIns->snFiledLength == 5)
    c965:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c969:	66 83 f9 05          	cmp    $0x5,%cx
    c96d:	74 41                	je     c9b0 <PMRLC_BUFFERREP_REQ+0x2e0>
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
    c96f:	66 83 f9 0a          	cmp    $0xa,%cx
    c973:	74 2b                	je     c9a0 <PMRLC_BUFFERREP_REQ+0x2d0>
    c975:	0f b7 4b 07          	movzwl 0x7(%ebx),%ecx
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
				}

				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    c979:	0f b7 c9             	movzwl %cx,%ecx
    c97c:	01 d1                	add    %edx,%ecx
    c97e:	83 f9 7f             	cmp    $0x7f,%ecx
    c981:	76 9d                	jbe    c920 <PMRLC_BUFFERREP_REQ+0x250>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c983:	83 c2 03             	add    $0x3,%edx
    c986:	89 53 03             	mov    %edx,0x3(%ebx)
    c989:	eb 9b                	jmp    c926 <PMRLC_BUFFERREP_REQ+0x256>
    c98b:	90                   	nop
    c98c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    c990:	83 c0 03             	add    $0x3,%eax
    c993:	89 43 03             	mov    %eax,0x3(%ebx)
    c996:	e9 8f fe ff ff       	jmp    c82a <PMRLC_BUFFERREP_REQ+0x15a>
    c99b:	90                   	nop
    c99c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
				}
				if(umTxIns->snFiledLength == 10)
				{
					mioctrl->txQueueHeader =2 + 2*umTxIns->umSduBufferNum;
    c9a0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c9a3:	8d 4c 09 02          	lea    0x2(%ecx,%ecx,1),%ecx
    c9a7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c9ab:	eb cc                	jmp    c979 <PMRLC_BUFFERREP_REQ+0x2a9>
    c9ad:	8d 76 00             	lea    0x0(%esi),%esi
				mioctrl->statusPduSize = 0;
				mioctrl->statusPduHeader = 0;

				if(umTxIns->snFiledLength == 5)
				{
					mioctrl->txQueueHeader = 1 + 2*umTxIns->umSduBufferNum;
    c9b0:	8b 48 f4             	mov    -0xc(%eax),%ecx
    c9b3:	8d 4c 09 01          	lea    0x1(%ecx,%ecx,1),%ecx
    c9b7:	66 89 4b 07          	mov    %cx,0x7(%ebx)
    c9bb:	0f b7 48 fa          	movzwl -0x6(%eax),%ecx
    c9bf:	eb ae                	jmp    c96f <PMRLC_BUFFERREP_REQ+0x29f>
    c9c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    c9c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c9cb:	8b 82 2c 37 00 00    	mov    0x372c(%edx),%eax
				//fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] the total size is %d(lcid is %d)\n", mioctrl->txQueueSize  + mioctrl->txQueueHeader, mioctrl->lcid);
				mioctrl++;
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
    c9d1:	39 45 dc             	cmp    %eax,-0x24(%ebp)
    c9d4:	74 72                	je     ca48 <PMRLC_BUFFERREP_REQ+0x378>
    c9d6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    c9d9:	eb 2d                	jmp    ca08 <PMRLC_BUFFERREP_REQ+0x338>
    c9db:	90                   	nop
    c9dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
				{
					mioctrl->txQueueSize += 2;
    c9e0:	83 c2 02             	add    $0x2,%edx
    c9e3:	89 53 03             	mov    %edx,0x3(%ebx)
				}
				else
				{
					mioctrl->txQueueSize += 3;
				}
				mioctrl->retxQueueSize = 0;
    c9e6:	c7 43 09 00 00 00 00 	movl   $0x0,0x9(%ebx)
				mioctrl->statusPduSize = 0;
    c9ed:	66 c7 43 0f 00 00    	movw   $0x0,0xf(%ebx)
				mioctrl->statusPduHeader = 0;
    c9f3:	66 c7 43 11 00 00    	movw   $0x0,0x11(%ebx)
				mioctrl->retxQueueHeader = 0;
    c9f9:	66 c7 43 0d 00 00    	movw   $0x0,0xd(%ebx)
				//fsm_printf("the total size is %d(lcid is %d)\n", mioctrl->txQueueSize, mioctrl->lcid);
				mioctrl++;
    c9ff:	83 c3 13             	add    $0x13,%ebx
			}
		}
	}
	if (!list_empty(&SV(vTm_tx_ins).tmTxList))
	{
		list_for_each(pos,&SV(vTm_tx_ins).tmTxList)
    ca02:	8b 00                	mov    (%eax),%eax
    ca04:	39 c1                	cmp    %eax,%ecx
    ca06:	74 40                	je     ca48 <PMRLC_BUFFERREP_REQ+0x378>
		{
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
    ca08:	8b 50 f8             	mov    -0x8(%eax),%edx
    ca0b:	85 d2                	test   %edx,%edx
    ca0d:	74 f3                	je     ca02 <PMRLC_BUFFERREP_REQ+0x332>
			{
				mioctrl->rnti = 0;
    ca0f:	66 c7 03 00 00       	movw   $0x0,(%ebx)
				mioctrl->lcid = tmTxIns->lcId;
    ca14:	0f b6 50 e7          	movzbl -0x19(%eax),%edx
    ca18:	88 53 02             	mov    %dl,0x2(%ebx)
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    ca1b:	8b 50 f8             	mov    -0x8(%eax),%edx
				mioctrl->txQueueHeader = 0;
    ca1e:	66 c7 43 07 00 00    	movw   $0x0,0x7(%ebx)
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    ca24:	83 fa 7f             	cmp    $0x7f,%edx
			tmTxIns= list_entry(pos,struct TM_TX_Instance,tmTxList);
			if(tmTxIns->tmSduBufferSize != 0)
			{
				mioctrl->rnti = 0;
				mioctrl->lcid = tmTxIns->lcId;
				mioctrl->txQueueSize = tmTxIns->tmSduBufferSize;
    ca27:	89 53 03             	mov    %edx,0x3(%ebx)
				mioctrl->txQueueHeader = 0;
				if( mioctrl->txQueueSize + mioctrl->txQueueHeader < 128 )  //mac, 20140726
    ca2a:	76 b4                	jbe    c9e0 <PMRLC_BUFFERREP_REQ+0x310>
				{
					mioctrl->txQueueSize += 2;
				}
				else
				{
					mioctrl->txQueueSize += 3;
    ca2c:	83 c2 03             	add    $0x3,%edx
    ca2f:	89 53 03             	mov    %edx,0x3(%ebx)
    ca32:	eb b2                	jmp    c9e6 <PMRLC_BUFFERREP_REQ+0x316>
		}
	}
	
	if(num == 0)
	{
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] There is no data to report\n");
    ca34:	c7 04 24 9c 35 00 00 	movl   $0x359c,(%esp)
    ca3b:	e8 fc ff ff ff       	call   ca3c <PMRLC_BUFFERREP_REQ+0x36c>
		if( SV(bufferReqTimer) )
		{
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}*/
		return NULL; 	//modify 20150901
    ca40:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    ca47:	90                   	nop
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ca48:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ca4b:	83 c4 20             	add    $0x20,%esp
    ca4e:	5b                   	pop    %ebx
    ca4f:	5e                   	pop    %esi
    ca50:	5f                   	pop    %edi
    ca51:	5d                   	pop    %ebp
    ca52:	c3                   	ret    
    ca53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    ca59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000ca60 <PMRLC_TRANSOP_IND>:
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
{
    ca60:	55                   	push   %ebp
    ca61:	89 e5                	mov    %esp,%ebp
    ca63:	57                   	push   %edi
    ca64:	56                   	push   %esi
    ca65:	53                   	push   %ebx
    ca66:	83 ec 70             	sub    $0x70,%esp
    ca69:	e8 fc ff ff ff       	call   ca6a <PMRLC_TRANSOP_IND+0xa>
    ca6e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	u32 subHeadLen;
	u32 size = 0;     //the total size in a buffer to transimit	
	u16 rnti;
	//int i=0;  //FOR TEST
	
	SV_PTR_GET(rlc_mac_sv);
    ca71:	e8 fc ff ff ff       	call   ca72 <PMRLC_TRANSOP_IND+0x12>
    ca76:	89 45 cc             	mov    %eax,-0x34(%ebp)
	SV(isBufferReq) = 0;
    ca79:	c6 80 24 02 00 00 00 	movb   $0x0,0x224(%eax)
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    ca80:	8b 45 b4             	mov    -0x4c(%ebp),%eax
	if(hptr == NULL)
    ca83:	85 c0                	test   %eax,%eax
	
	SV_PTR_GET(rlc_mac_sv);
	SV(isBufferReq) = 0;
	//hptr = ptr = fsm_data_get();

	ptr = hptr; //add in 20150831
    ca85:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(hptr == NULL)
    ca88:	0f 84 d4 01 00 00    	je     cc62 <PMRLC_TRANSOP_IND+0x202>
	{
		FOUT;
	}	
	nump = (u32*)hptr;
	num = *nump;
    ca8e:	89 c2                	mov    %eax,%edx
    ca90:	8b 00                	mov    (%eax),%eax
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
    ca92:	85 c0                	test   %eax,%eax
    ca94:	0f 84 40 0a 00 00    	je     d4da <PMRLC_TRANSOP_IND+0xa7a>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    ca9a:	8b 75 b4             	mov    -0x4c(%ebp),%esi
    ca9d:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    caa0:	8d 04 50             	lea    (%eax,%edx,2),%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    caa3:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	subhead = data = sevNum = fifNum = 0;
    caa6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    caad:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cab4:	83 ee 0f             	sub    $0xf,%esi
    cab7:	01 f0                	add    %esi,%eax
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    cab9:	83 c1 04             	add    $0x4,%ecx
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cabc:	89 45 d0             	mov    %eax,-0x30(%ebp)
    cabf:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cac2:	89 75 ac             	mov    %esi,-0x54(%ebp)
	}

	//fsm_printf("After bufferReq the bufferReqTimer restart\n");
	/* */
	
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
    cac5:	89 ce                	mov    %ecx,%esi
    cac7:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    caca:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    cacd:	05 18 02 00 00       	add    $0x218,%eax
    cad2:	89 45 c0             	mov    %eax,-0x40(%ebp)
    cad5:	8d 76 00             	lea    0x0(%esi),%esi
	subhead = data = sevNum = fifNum = 0;
	//controlelm = 14 + 10;
	while(num > 0)
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    cad8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    cadb:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    cade:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    cae2:	89 14 24             	mov    %edx,(%esp)
    cae5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    cae8:	e8 fc ff ff ff       	call   cae9 <PMRLC_TRANSOP_IND+0x89>
		switch(SV(ins_mode))
    caed:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    caf0:	8b 81 18 02 00 00    	mov    0x218(%ecx),%eax
    caf6:	83 f8 02             	cmp    $0x2,%eax
    caf9:	0f 84 b9 08 00 00    	je     d3b8 <PMRLC_TRANSOP_IND+0x958>
    caff:	83 f8 03             	cmp    $0x3,%eax
    cb02:	0f 84 58 07 00 00    	je     d260 <PMRLC_TRANSOP_IND+0x800>
    cb08:	83 f8 01             	cmp    $0x1,%eax
    cb0b:	0f 84 bf 06 00 00    	je     d1d0 <PMRLC_TRANSOP_IND+0x770>
			}

			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    cb11:	c7 04 24 d4 35 00 00 	movl   $0x35d4,(%esp)
    cb18:	e8 fc ff ff ff       	call   cb19 <PMRLC_TRANSOP_IND+0xb9>
			break;
		}	
		num--;
		if(num>0)
    cb1d:	3b 75 d0             	cmp    -0x30(%ebp),%esi
    cb20:	74 06                	je     cb28 <PMRLC_TRANSOP_IND+0xc8>
		{
			mIoctrl++;
    cb22:	83 c6 13             	add    $0x13,%esi
    cb25:	eb b1                	jmp    cad8 <PMRLC_TRANSOP_IND+0x78>
    cb27:	90                   	nop
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    cb28:	8b 45 e0             	mov    -0x20(%ebp),%eax
    cb2b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    cb2e:	83 c0 04             	add    $0x4,%eax
    cb31:	e8 fc ff ff ff       	call   cb32 <PMRLC_TRANSOP_IND+0xd2>
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cb36:	8b 75 dc             	mov    -0x24(%ebp),%esi
    cb39:	83 c6 04             	add    $0x4,%esi
			mIoctrl++;
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
    cb3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cb3f:	89 f0                	mov    %esi,%eax
    cb41:	e8 fc ff ff ff       	call   cb42 <PMRLC_TRANSOP_IND+0xe2>
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    cb46:	89 f2                	mov    %esi,%edx
		}
	}
	
	/* SKBICI*/
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
    cb48:	89 45 b8             	mov    %eax,-0x48(%ebp)
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));
    cb4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cb4e:	e8 fc ff ff ff       	call   cb4f <PMRLC_TRANSOP_IND+0xef>

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    cb53:	8b 45 b8             	mov    -0x48(%ebp),%eax
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    cb56:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
	data = 0;     //
    cb59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	pkptr = fsm_pkt_create( data + sizeof(MRLC_toMac_IciMsg));
	head = fsm_mem_alloc(subhead + sizeof(MRLC_toMac_IciMsg) );  //ici,preptrE
	fsm_skb_reserve(pkptr, subhead + sizeof(MRLC_toMac_IciMsg));

	icimsg = (MRLC_toMac_IciMsg*)head;
	ptr = icimsg + 1;   //
    cb60:	83 c0 04             	add    $0x4,%eax
    cb63:	89 45 ec             	mov    %eax,-0x14(%ebp)
	data = 0;     //
	/* PDUSKB */
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
    cb66:	8b 01                	mov    (%ecx),%eax
	while(num > 0)
    cb68:	85 c0                	test   %eax,%eax
    cb6a:	74 60                	je     cbcc <PMRLC_TRANSOP_IND+0x16c>
**Created Date: 2013
**-----------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014
*********************************************************************/
void PMRLC_TRANSOP_IND (void *hptr)
    cb6c:	8d 14 c0             	lea    (%eax,%eax,8),%edx
    cb6f:	8d 04 50             	lea    (%eax,%edx,2),%eax
    cb72:	03 45 ac             	add    -0x54(%ebp),%eax
    cb75:	89 45 bc             	mov    %eax,-0x44(%ebp)
	mIoctrl = (MRLC_TransOp_IoctrlMsg *)(nump + 1);
	num = *nump;
	while(num > 0)
	{
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] number %d:\n", num);
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
    cb78:	8b 75 d8             	mov    -0x28(%ebp),%esi
    cb7b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
    cb7e:	8d 4d e8             	lea    -0x18(%ebp),%ecx
    cb81:	0f b6 46 02          	movzbl 0x2(%esi),%eax
    cb85:	8b 75 c0             	mov    -0x40(%ebp),%esi
    cb88:	89 34 24             	mov    %esi,(%esp)
    cb8b:	e8 fc ff ff ff       	call   cb8c <PMRLC_TRANSOP_IND+0x12c>
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
    cb90:	8b 55 cc             	mov    -0x34(%ebp),%edx
    cb93:	8b 82 18 02 00 00    	mov    0x218(%edx),%eax
    cb99:	83 f8 02             	cmp    $0x2,%eax
    cb9c:	0f 84 5e 04 00 00    	je     d000 <PMRLC_TRANSOP_IND+0x5a0>
    cba2:	83 f8 03             	cmp    $0x3,%eax
    cba5:	0f 84 dd 01 00 00    	je     cd88 <PMRLC_TRANSOP_IND+0x328>
    cbab:	83 f8 01             	cmp    $0x1,%eax
    cbae:	0f 84 cc 00 00 00    	je     cc80 <PMRLC_TRANSOP_IND+0x220>
				}          
            }
			break;

		default:
			fsm_printf("[RLC][PMRLC_TRANSOP_IND] cannot find the instance\n");
    cbb4:	c7 04 24 d4 35 00 00 	movl   $0x35d4,(%esp)
    cbbb:	e8 fc ff ff ff       	call   cbbc <PMRLC_TRANSOP_IND+0x15c>
			break;
		}
	
		num--;
		if(num>0)
    cbc0:	8b 75 bc             	mov    -0x44(%ebp),%esi
    cbc3:	39 75 d8             	cmp    %esi,-0x28(%ebp)
    cbc6:	0f 85 a4 00 00 00    	jne    cc70 <PMRLC_TRANSOP_IND+0x210>
		{
			mIoctrl++;
		}
	}
		
	if(0 == pkptr->len)
    cbcc:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cbcf:	8b 48 50             	mov    0x50(%eax),%ecx
    cbd2:	85 c9                	test   %ecx,%ecx
    cbd4:	0f 84 7d 08 00 00    	je     d457 <PMRLC_TRANSOP_IND+0x9f7>
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
		SV(bufferReqTimer) = 0;
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
    cbda:	8b 45 f0             	mov    -0x10(%ebp),%eax
	fix->E = 0;    //E0
    cbdd:	80 20 df             	andb   $0xdf,(%eax)
	icimsg->len = data;
    cbe0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    cbe3:	8b 55 b8             	mov    -0x48(%ebp),%edx
	icimsg->rnti = mIoctrl->rnti;
    cbe6:	8b 75 d8             	mov    -0x28(%ebp),%esi
		fsm_data_destroy(hptr);
		FOUT;
	}
	fix = (MRLC_subHead_fix_IciMsg *)preptr;
	fix->E = 0;    //E0
	icimsg->len = data;
    cbe9:	66 89 42 02          	mov    %ax,0x2(%edx)
	icimsg->rnti = mIoctrl->rnti;
    cbed:	0f b7 06             	movzwl (%esi),%eax
    cbf0:	66 89 02             	mov    %ax,(%edx)
	fsm_mem_cpy(pkptr->head, head,  data + sizeof(MRLC_toMac_IciMsg));
    cbf3:	8b 55 d0             	mov    -0x30(%ebp),%edx
    cbf6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    cbf9:	8b 82 a8 00 00 00    	mov    0xa8(%edx),%eax
    cbff:	8b 55 b8             	mov    -0x48(%ebp),%edx
    cc02:	83 c1 04             	add    $0x4,%ecx
    cc05:	e8 fc ff ff ff       	call   cc06 <PMRLC_TRANSOP_IND+0x1a6>
	fsm_mem_free(head);
    cc0a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cc0d:	e8 fc ff ff ff       	call   cc0e <PMRLC_TRANSOP_IND+0x1ae>
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cc12:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cc15:	66 83 78 02 00       	cmpw   $0x0,0x2(%eax)
	{
		send_msg3(pkptr);
    cc1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
		fsm_pkt_destroy(pkptr);
		pkptr = NULL;
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
    cc1d:	0f 85 d9 08 00 00    	jne    d4fc <PMRLC_TRANSOP_IND+0xa9c>
		send_msg3(pkptr);
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
		FOUT;
	}
	else{
		complexUeMacPdu(pkptr); //add in 20150804
    cc23:	e8 fc ff ff ff       	call   cc24 <PMRLC_TRANSOP_IND+0x1c4>
		if(SV(Tbsize_Complex)!=0)
    cc28:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cc2b:	8b 90 f4 01 00 00    	mov    0x1f4(%eax),%edx
    cc31:	85 d2                	test   %edx,%edx
    cc33:	74 0a                	je     cc3f <PMRLC_TRANSOP_IND+0x1df>
				SV(Tbsize_Complex)=0;
    cc35:	c7 80 f4 01 00 00 00 	movl   $0x0,0x1f4(%eax)
    cc3c:	00 00 00 
		
		fsm_printf("[RLC][PMRLC_TRANSOP_IND][<--] send to MAC\n");
    cc3f:	c7 04 24 2c 38 00 00 	movl   $0x382c,(%esp)
    cc46:	e8 fc ff ff ff       	call   cc47 <PMRLC_TRANSOP_IND+0x1e7>
		SV(countSentToLower)++;
    cc4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cc4e:	83 80 98 5a 00 00 01 	addl   $0x1,0x5a98(%eax)
			fsm_schedule_cancel(SV(bufferReqTimer));
			SV(bufferReqTimer) = 0;
		}
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] bufferReqTimer restart\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));*/
		fsm_data_destroy(hptr);
    cc55:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    cc58:	e8 fc ff ff ff       	call   cc59 <PMRLC_TRANSOP_IND+0x1f9>
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
    cc5d:	e8 fc ff ff ff       	call   cc5e <PMRLC_TRANSOP_IND+0x1fe>
		FOUT;
	}
}
    cc62:	83 c4 70             	add    $0x70,%esp
    cc65:	5b                   	pop    %ebx
    cc66:	5e                   	pop    %esi
    cc67:	5f                   	pop    %edi
    cc68:	5d                   	pop    %ebp
    cc69:	c3                   	ret    
    cc6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
	
		num--;
		if(num>0)
		{
			mIoctrl++;
    cc70:	83 45 d8 13          	addl   $0x13,-0x28(%ebp)
    cc74:	e9 ff fe ff ff       	jmp    cb78 <PMRLC_TRANSOP_IND+0x118>
    cc79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		//fsm_printf("[RLC][PMRLC_TRANSOP_IND] lcid is %d, mode is %d\n",mIoctrl->lcid,SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    cc80:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cc83:	85 f6                	test   %esi,%esi
    cc85:	0f 84 35 ff ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
    cc8b:	8b 46 0c             	mov    0xc(%esi),%eax
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
    cc8e:	8d 4e 0c             	lea    0xc(%esi),%ecx
    cc91:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
    cc94:	39 c1                	cmp    %eax,%ecx
    cc96:	0f 84 24 ff ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
    cc9c:	8b 38                	mov    (%eax),%edi
    cc9e:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cca1:	83 ef 04             	sub    $0x4,%edi
    cca4:	eb 18                	jmp    ccbe <PMRLC_TRANSOP_IND+0x25e>
    cca6:	66 90                	xchg   %ax,%ax
    cca8:	8b 47 04             	mov    0x4(%edi),%eax
    ccab:	8d 57 04             	lea    0x4(%edi),%edx
    ccae:	89 fb                	mov    %edi,%ebx
    ccb0:	83 e8 04             	sub    $0x4,%eax
    ccb3:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    ccb6:	0f 84 04 ff ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
    ccbc:	89 c7                	mov    %eax,%edi
				{
					if(buffer->pkt->len < 128)
    ccbe:	8b 03                	mov    (%ebx),%eax
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    ccc0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
			tmTxIns = (TM_TX_Instance *)insptru;
			if(!list_empty(&tmTxIns->tmSduBuffer.list))
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
    ccc3:	8b 40 50             	mov    0x50(%eax),%eax
					{
						subHeadLen = 2;
    ccc6:	3d 80 00 00 00       	cmp    $0x80,%eax
    cccb:	19 d2                	sbb    %edx,%edx
    cccd:	83 c2 03             	add    $0x3,%edx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    ccd0:	01 d0                	add    %edx,%eax
    ccd2:	3b 41 03             	cmp    0x3(%ecx),%eax
			{
				list_for_each_entry_safe(buffer, tempb, &tmTxIns->tmSduBuffer.list,list)
				{
					if(buffer->pkt->len < 128)
					{
						subHeadLen = 2;
    ccd5:	89 55 dc             	mov    %edx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen >  mIoctrl->txQueueSize)
    ccd8:	0f 87 e2 fe ff ff    	ja     cbc0 <PMRLC_TRANSOP_IND+0x160>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ccde:	8b 53 04             	mov    0x4(%ebx),%edx
    cce1:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cce4:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cce7:	89 10                	mov    %edx,(%eax)
						break;
					}
					else
					{
						list_del(&buffer->list);
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
    cce9:	8b 03                	mov    (%ebx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cceb:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    ccf2:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    ccf9:	8b 40 50             	mov    0x50(%eax),%eax
    ccfc:	29 46 14             	sub    %eax,0x14(%esi)
						tmTxIns->tmSduBufferNum--;
    ccff:	83 6e 18 01          	subl   $0x1,0x18(%esi)
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
    cd03:	8b 03                	mov    (%ebx),%eax
    cd05:	8b 48 50             	mov    0x50(%eax),%ecx
    cd08:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cd0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cd11:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cd17:	89 45 a0             	mov    %eax,-0x60(%ebp)
    cd1a:	e8 fc ff ff ff       	call   cd1b <PMRLC_TRANSOP_IND+0x2bb>
						fsm_skb_put(pkptr, buffer->pkt->len);
    cd1f:	8b 03                	mov    (%ebx),%eax
    cd21:	8b 50 50             	mov    0x50(%eax),%edx
    cd24:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cd27:	e8 fc ff ff ff       	call   cd28 <PMRLC_TRANSOP_IND+0x2c8>

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cd2c:	8d 55 e0             	lea    -0x20(%ebp),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cd2f:	8b 03                	mov    (%ebx),%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cd31:	8d 4d f0             	lea    -0x10(%ebp),%ecx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cd34:	83 c0 50             	add    $0x50,%eax
						tmTxIns->tmSduBufferSize -= buffer->pkt->len;
						tmTxIns->tmSduBufferNum--;
						fsm_mem_cpy(pkptr->tail,  buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);

						creat_subhead(buffer->pkt,  &ptr, &preptr, tmTxIns->lcId, &data);
    cd37:	89 54 24 04          	mov    %edx,0x4(%esp)
    cd3b:	0f b6 56 03          	movzbl 0x3(%esi),%edx
    cd3f:	89 14 24             	mov    %edx,(%esp)
    cd42:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cd45:	e8 d6 e8 ff ff       	call   b620 <creat_subhead.isra.0>
						mIoctrl->txQueueSize -= subHeadLen + buffer->pkt->len;
    cd4a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    cd4d:	8b 13                	mov    (%ebx),%edx
    cd4f:	8b 41 03             	mov    0x3(%ecx),%eax
    cd52:	2b 42 50             	sub    0x50(%edx),%eax
    cd55:	2b 45 dc             	sub    -0x24(%ebp),%eax
    cd58:	89 41 03             	mov    %eax,0x3(%ecx)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
    cd5b:	8b 03                	mov    (%ebx),%eax
    cd5d:	e8 fc ff ff ff       	call   cd5e <PMRLC_TRANSOP_IND+0x2fe>
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
    cd62:	89 d8                	mov    %ebx,%eax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] tm instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][TM] the data is \n");	//FOR TEST
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
    cd64:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(buffer);  //20140922
    cd6a:	e8 fc ff ff ff       	call   cd6b <PMRLC_TRANSOP_IND+0x30b>
						buffer = NULL;
						if(list_empty(&tmTxIns->tmSduBuffer.list))
    cd6f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cd72:	3b 46 0c             	cmp    0xc(%esi),%eax
    cd75:	0f 85 2d ff ff ff    	jne    cca8 <PMRLC_TRANSOP_IND+0x248>
						//fsm_octets_print(buffer->pkt->data+2,18);
											
						fsm_pkt_destroy(buffer->pkt);  //20140922
						buffer->pkt = NULL;
						fsm_mem_free(buffer);  //20140922
						buffer = NULL;
    cd7b:	31 db                	xor    %ebx,%ebx
    cd7d:	e9 3e fe ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
    cd82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
				break;
			}

		case AM_MODE:
			if(insptru == NULL)
    cd88:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    cd8b:	85 f6                	test   %esi,%esi
    cd8d:	0f 84 2d fe ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cd93:	8b 86 b0 01 00 00    	mov    0x1b0(%esi),%eax
				break;
			}*/

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
    cd99:	8d 96 b0 01 00 00    	lea    0x1b0(%esi),%edx
    cd9f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    cda2:	39 c2                	cmp    %eax,%edx
    cda4:	0f 84 10 01 00 00    	je     ceba <PMRLC_TRANSOP_IND+0x45a>
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    cdaa:	8b 38                	mov    (%eax),%edi
    cdac:	8d 58 fc             	lea    -0x4(%eax),%ebx
    cdaf:	83 ef 04             	sub    $0x4,%edi
    cdb2:	e9 c0 00 00 00       	jmp    ce77 <PMRLC_TRANSOP_IND+0x417>
    cdb7:	90                   	nop
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    cdb8:	8b 53 04             	mov    0x4(%ebx),%edx
    cdbb:	8b 43 08             	mov    0x8(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    cdbe:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    cdc1:	89 10                	mov    %edx,(%eax)
					else
					{
						list_del(&buffer->list);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu has been remove from list\n");
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] buffer->pkt->len=%d\n",buffer->pkt->len);
						SV(countSendCtrlPdu)++;
    cdc3:	8b 45 cc             	mov    -0x34(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    cdc6:	c7 43 04 00 01 10 00 	movl   $0x100100,0x4(%ebx)
	entry->prev = LIST_POISON2;
    cdcd:	c7 43 08 00 02 20 00 	movl   $0x200200,0x8(%ebx)
    cdd4:	83 80 a0 5a 00 00 01 	addl   $0x1,0x5aa0(%eax)
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
    cddb:	8b 03                	mov    (%ebx),%eax
    cddd:	8b 40 50             	mov    0x50(%eax),%eax
    cde0:	29 86 b8 01 00 00    	sub    %eax,0x1b8(%esi)
						amIns->ctrlPduBufferNum--;
    cde6:	83 ae bc 01 00 00 01 	subl   $0x1,0x1bc(%esi)
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
    cded:	8b 03                	mov    (%ebx),%eax
    cdef:	8b 48 50             	mov    0x50(%eax),%ecx
    cdf2:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    cdf8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cdfb:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ce01:	89 45 98             	mov    %eax,-0x68(%ebp)
    ce04:	e8 fc ff ff ff       	call   ce05 <PMRLC_TRANSOP_IND+0x3a5>
						fsm_skb_put(pkptr, buffer->pkt->len);
    ce09:	8b 03                	mov    (%ebx),%eax
    ce0b:	8b 50 50             	mov    0x50(%eax),%edx
    ce0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    ce11:	e8 fc ff ff ff       	call   ce12 <PMRLC_TRANSOP_IND+0x3b2>
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    ce16:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ce19:	8b 13                	mov    (%ebx),%edx
    ce1b:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    ce1f:	66 2b 42 50          	sub    0x50(%edx),%ax
    ce23:	66 2b 45 dc          	sub    -0x24(%ebp),%ax
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ce27:	8d 55 e0             	lea    -0x20(%ebp),%edx
						amIns->ctrlPduBufferSize -= buffer->pkt->len;
						amIns->ctrlPduBufferNum--;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] pkptr->len=%d\n",pkptr->len);
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
    ce2a:	66 89 41 0f          	mov    %ax,0xf(%ecx)
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ce2e:	8b 03                	mov    (%ebx),%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ce30:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    ce33:	89 54 24 04          	mov    %edx,0x4(%esp)
    ce37:	0f b6 56 03          	movzbl 0x3(%esi),%edx
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    ce3b:	83 c0 50             	add    $0x50,%eax
						fsm_mem_cpy(pkptr->tail, buffer->pkt->data, buffer->pkt->len);
						fsm_skb_put(pkptr, buffer->pkt->len);
						mIoctrl->statusPduSize -= buffer->pkt->len + subHeadLen;
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND] ctrlPdu transport\n");
						//break;
						creat_subhead(buffer->pkt, &ptr, &preptr, amIns->lcId , &data);
    ce3e:	89 14 24             	mov    %edx,(%esp)
    ce41:	8d 55 ec             	lea    -0x14(%ebp),%edx
    ce44:	e8 d7 e7 ff ff       	call   b620 <creat_subhead.isra.0>
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] am instance mIoctrl->statusPduSize is %d, buffer->pkt->len is %d\n", \
						//	mIoctrl->statusPduSize, buffer->pkt->len);
						//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] ctrl data transport\n");
						//fsm_octets_print(buffer->pkt->data,10);
						
						if(buffer->pkt != NULL)
    ce49:	8b 03                	mov    (%ebx),%eax
    ce4b:	85 c0                	test   %eax,%eax
    ce4d:	74 0b                	je     ce5a <PMRLC_TRANSOP_IND+0x3fa>
						{
							fsm_pkt_destroy(buffer->pkt);  //20140922
    ce4f:	e8 fc ff ff ff       	call   ce50 <PMRLC_TRANSOP_IND+0x3f0>
							buffer->pkt = NULL;
    ce54:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						}
						if(buffer != NULL)
    ce5a:	85 db                	test   %ebx,%ebx
    ce5c:	74 07                	je     ce65 <PMRLC_TRANSOP_IND+0x405>
						{
							fsm_mem_free(buffer);  //20140922
    ce5e:	89 d8                	mov    %ebx,%eax
    ce60:	e8 fc ff ff ff       	call   ce61 <PMRLC_TRANSOP_IND+0x401>

			
			//PDU
			if(!list_empty(&amIns->ctrlPduBuffer.list))
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
    ce65:	8b 47 04             	mov    0x4(%edi),%eax
    ce68:	8d 57 04             	lea    0x4(%edi),%edx
    ce6b:	89 fb                	mov    %edi,%ebx
    ce6d:	83 e8 04             	sub    $0x4,%eax
    ce70:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
    ce73:	74 3a                	je     ceaf <PMRLC_TRANSOP_IND+0x44f>
    ce75:	89 c7                	mov    %eax,%edi
				{
					if( buffer->pkt->len < 128 )
    ce77:	8b 03                	mov    (%ebx),%eax
    ce79:	8b 50 50             	mov    0x50(%eax),%edx
					{
						subHeadLen = 2;
    ce7c:	81 fa 80 00 00 00    	cmp    $0x80,%edx
    ce82:	19 c9                	sbb    %ecx,%ecx
    ce84:	83 c1 03             	add    $0x3,%ecx
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    ce87:	01 ca                	add    %ecx,%edx
			{
				list_for_each_entry_safe(buffer,tempb,&amIns->ctrlPduBuffer.list,list )
				{
					if( buffer->pkt->len < 128 )
					{
						subHeadLen = 2;
    ce89:	89 4d dc             	mov    %ecx,-0x24(%ebp)
					}
					else
					{
						subHeadLen = 3;
					}
					if(buffer->pkt->len + subHeadLen > mIoctrl->statusPduSize)
    ce8c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    ce8f:	0f b7 41 0f          	movzwl 0xf(%ecx),%eax
    ce93:	39 c2                	cmp    %eax,%edx
    ce95:	0f 86 1d ff ff ff    	jbe    cdb8 <PMRLC_TRANSOP_IND+0x358>
					{
						fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->statusPduSize is %d, data is %d\n", \
    ce9b:	89 54 24 08          	mov    %edx,0x8(%esp)
    ce9f:	89 44 24 04          	mov    %eax,0x4(%esp)
    cea3:	c7 04 24 8c 36 00 00 	movl   $0x368c,(%esp)
    ceaa:	e8 fc ff ff ff       	call   ceab <PMRLC_TRANSOP_IND+0x44b>
							break;
						}*/
					}
				}
				//
				if( !amIns->statProhTimer )
    ceaf:	8b 7e 20             	mov    0x20(%esi),%edi
    ceb2:	85 ff                	test   %edi,%edi
    ceb4:	0f 84 2f 06 00 00    	je     d4e9 <PMRLC_TRANSOP_IND+0xa89>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    ceba:	8b 45 d8             	mov    -0x28(%ebp),%eax
    cebd:	8b 48 09             	mov    0x9(%eax),%ecx
    cec0:	0f b7 50 0d          	movzwl 0xd(%eax),%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cec4:	8d 86 9c 01 00 00    	lea    0x19c(%esi),%eax
    ceca:	89 45 c8             	mov    %eax,-0x38(%ebp)
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    cecd:	8b 86 9c 01 00 00    	mov    0x19c(%esi),%eax
    ced3:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    ced6:	0f 84 cf 01 00 00    	je     d0ab <PMRLC_TRANSOP_IND+0x64b>
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
				}
			}
			
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
    cedc:	0f b7 d2             	movzwl %dx,%edx
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
    cedf:	01 ca                	add    %ecx,%edx
    cee1:	89 55 dc             	mov    %edx,-0x24(%ebp)
    cee4:	0f 84 c1 01 00 00    	je     d0ab <PMRLC_TRANSOP_IND+0x64b>
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    ceea:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    cef0:	89 5d b0             	mov    %ebx,-0x50(%ebp)
    cef3:	e9 b8 00 00 00       	jmp    cfb0 <PMRLC_TRANSOP_IND+0x550>
						}
						if( subHeadLen < size )
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
    cef8:	ba 78 05 00 00       	mov    $0x578,%edx
    cefd:	89 f8                	mov    %edi,%eax
    ceff:	e8 fc ff ff ff       	call   cf00 <PMRLC_TRANSOP_IND+0x4a0>
    cf04:	89 c3                	mov    %eax,%ebx
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
							}

							if( amIns->pduWithoutPoll >= amIns->pollPDU || amIns->byteWithoutPoll >= amIns->pollBYTE )
    cf06:	0f b7 86 f6 22 00 00 	movzwl 0x22f6(%esi),%eax
    cf0d:	66 39 86 fc 22 00 00 	cmp    %ax,0x22fc(%esi)
    cf14:	73 10                	jae    cf26 <PMRLC_TRANSOP_IND+0x4c6>
    cf16:	0f b7 96 f8 22 00 00 	movzwl 0x22f8(%esi),%edx
    cf1d:	66 39 96 fe 22 00 00 	cmp    %dx,0x22fe(%esi)
    cf24:	72 09                	jb     cf2f <PMRLC_TRANSOP_IND+0x4cf>
							{
								rlc_poll(amIns, pkp);
    cf26:	89 da                	mov    %ebx,%edx
    cf28:	89 f0                	mov    %esi,%eax
    cf2a:	e8 fc ff ff ff       	call   cf2b <PMRLC_TRANSOP_IND+0x4cb>
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
    cf2f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf32:	8b 4b 50             	mov    0x50(%ebx),%ecx
    cf35:	8b 93 ac 00 00 00    	mov    0xac(%ebx),%edx
    cf3b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    cf41:	89 45 94             	mov    %eax,-0x6c(%ebp)
    cf44:	e8 fc ff ff ff       	call   cf45 <PMRLC_TRANSOP_IND+0x4e5>
							fsm_skb_put( pkptr,pkp->len);
    cf49:	8b 53 50             	mov    0x50(%ebx),%edx
    cf4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    cf4f:	e8 fc ff ff ff       	call   cf50 <PMRLC_TRANSOP_IND+0x4f0>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    cf54:	8d 43 50             	lea    0x50(%ebx),%eax
    cf57:	89 45 c4             	mov    %eax,-0x3c(%ebp)
								rlc_poll(amIns, pkp);
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
    cf5a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    cf5d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    cf60:	8d 55 ec             	lea    -0x14(%ebp),%edx
    cf63:	89 44 24 04          	mov    %eax,0x4(%esp)
    cf67:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    cf6b:	89 04 24             	mov    %eax,(%esp)
    cf6e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    cf71:	e8 aa e6 ff ff       	call   b620 <creat_subhead.isra.0>
							size -= pkp->len + subHeadLen;
    cf76:	8b 53 50             	mov    0x50(%ebx),%edx
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND] am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, pkp->len);

							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
    cf79:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    cf80:	01 
							amIns->byteWithoutPoll += pkp->len;  //??
    cf81:	8b 43 50             	mov    0x50(%ebx),%eax
    cf84:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    cf8b:	89 d8                	mov    %ebx,%eax
							}

							fsm_mem_cpy( pkptr->tail,  pkp->data, pkp->len);
							fsm_skb_put( pkptr,pkp->len);
							creat_subhead(pkp, &ptr, &preptr, amIns->lcId,&data);
							size -= pkp->len + subHeadLen;
    cf8d:	29 55 dc             	sub    %edx,-0x24(%ebp)
    cf90:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    cf93:	29 4d dc             	sub    %ecx,-0x24(%ebp)
							//pduWithoutPollbyteWithoutPoll????????
							amIns->pduWithoutPoll++;
							amIns->byteWithoutPoll += pkp->len;  //??
							//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] retx data transport\n");
							//fsm_octets_print(pkp->data,10);
							fsm_pkt_destroy(pkp);  //20140922
    cf96:	e8 fc ff ff ff       	call   cf97 <PMRLC_TRANSOP_IND+0x537>
			//PDU
			size = mIoctrl->retxQueueSize + mIoctrl->retxQueueHeader;
			
			if( !list_empty(&amIns->amRetxBuffer.list) && size > 0 )
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    cf9b:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
    cfa1:	39 45 c8             	cmp    %eax,-0x38(%ebp)
    cfa4:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
    cfaa:	0f 84 f8 00 00 00    	je     d0a8 <PMRLC_TRANSOP_IND+0x648>
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
    cfb0:	0f bf 97 94 00 00 00 	movswl 0x94(%edi),%edx
    cfb7:	89 f0                	mov    %esi,%eax
    cfb9:	e8 fc ff ff ff       	call   cfba <PMRLC_TRANSOP_IND+0x55a>
    cfbe:	84 c0                	test   %al,%al
    cfc0:	74 d9                	je     cf9b <PMRLC_TRANSOP_IND+0x53b>
					{
						if( amBuffer->pkt->len < 128 )
    cfc2:	8b 07                	mov    (%edi),%eax
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cfc4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			{
				list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
    cfc7:	8b 40 50             	mov    0x50(%eax),%eax
						{
							subHeadLen = 2;
    cfca:	3d 80 00 00 00       	cmp    $0x80,%eax
    cfcf:	19 d2                	sbb    %edx,%edx
    cfd1:	83 c2 03             	add    $0x3,%edx
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cfd4:	39 ca                	cmp    %ecx,%edx
				{
					if(isInsideTranWin(amIns,amBuffer->SN))
					{
						if( amBuffer->pkt->len < 128 )
						{
							subHeadLen = 2;
    cfd6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
						}
						else
						{
							subHeadLen = 3;
						}
						if( subHeadLen < size )
    cfd9:	0f 83 a1 04 00 00    	jae    d480 <PMRLC_TRANSOP_IND+0xa20>
						{
							if( size - subHeadLen > MAX_PDU_SIZE)
    cfdf:	89 ca                	mov    %ecx,%edx
    cfe1:	2b 55 d4             	sub    -0x2c(%ebp),%edx
    cfe4:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    cfea:	0f 87 08 ff ff ff    	ja     cef8 <PMRLC_TRANSOP_IND+0x498>
							{
								pkp = rlc_resegment( amBuffer, MAX_PDU_SIZE);
							}
							else
							{
								pkp = rlc_resegment( amBuffer, size - subHeadLen );
    cff0:	89 f8                	mov    %edi,%eax
    cff2:	e8 fc ff ff ff       	call   cff3 <PMRLC_TRANSOP_IND+0x593>
    cff7:	89 c3                	mov    %eax,%ebx
    cff9:	e9 08 ff ff ff       	jmp    cf06 <PMRLC_TRANSOP_IND+0x4a6>
    cffe:	66 90                	xchg   %ax,%ax
				}
			}
			break;

		case UM_MODE:
			if(insptru == NULL)
    d000:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d003:	85 ff                	test   %edi,%edi
    d005:	0f 84 b5 fb ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d00b:	8b 75 d8             	mov    -0x28(%ebp),%esi
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d00e:	81 7f 20 80 00 00 00 	cmpl   $0x80,0x20(%edi)
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d015:	8b 4e 03             	mov    0x3(%esi),%ecx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d018:	19 c0                	sbb    %eax,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d01a:	0f b7 56 07          	movzwl 0x7(%esi),%edx
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			if( umTxIns->umSduBufferSize < 128 )
			{
				subHeadLen = 2;
    d01e:	83 c0 03             	add    $0x3,%eax
			}
			else
			{
				subHeadLen = 3;
			}
			if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader > subHeadLen )  //mIoctrl->txQueueHeader,  /20140726
    d021:	01 ca                	add    %ecx,%edx
    d023:	39 d0                	cmp    %edx,%eax
    d025:	0f 83 cd 03 00 00    	jae    d3f8 <PMRLC_TRANSOP_IND+0x998>
			{
				//pkp = rlc_UM_segment(umTxIns , mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);//mIoctrl->txQueueHeader,  /20140726
				if( mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen > MAX_PDU_SIZE )
    d02b:	29 c2                	sub    %eax,%edx
    d02d:	81 fa 78 05 00 00    	cmp    $0x578,%edx
    d033:	0f 86 af 03 00 00    	jbe    d3e8 <PMRLC_TRANSOP_IND+0x988>
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
    d039:	ba 78 05 00 00       	mov    $0x578,%edx
    d03e:	89 f8                	mov    %edi,%eax
    d040:	e8 fc ff ff ff       	call   d041 <PMRLC_TRANSOP_IND+0x5e1>
    d045:	89 c6                	mov    %eax,%esi
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
    d047:	85 f6                	test   %esi,%esi
    d049:	0f 84 e2 04 00 00    	je     d531 <PMRLC_TRANSOP_IND+0xad1>
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    d04f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d052:	8b 4e 50             	mov    0x50(%esi),%ecx
    d055:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
    d05b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    d061:	89 45 9c             	mov    %eax,-0x64(%ebp)
    d064:	e8 fc ff ff ff       	call   d065 <PMRLC_TRANSOP_IND+0x605>
				fsm_skb_put( pkptr,pkp->len);
    d069:	8b 56 50             	mov    0x50(%esi),%edx
    d06c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d06f:	e8 fc ff ff ff       	call   d070 <PMRLC_TRANSOP_IND+0x610>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    d074:	8d 46 50             	lea    0x50(%esi),%eax
    d077:	89 45 dc             	mov    %eax,-0x24(%ebp)
					break;
				}
				//printk("[RLC][PMRLC_TRANSOP_IND][UM] SN = %d\n",umTxIns->SN);
				fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
				fsm_skb_put( pkptr,pkp->len);
				creat_subhead(pkp, &ptr,  &preptr, umTxIns->lcid, &data);
    d07a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d07d:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d080:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d083:	89 44 24 04          	mov    %eax,0x4(%esp)
    d087:	0f b6 47 03          	movzbl 0x3(%edi),%eax
    d08b:	89 04 24             	mov    %eax,(%esp)
    d08e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d091:	e8 8a e5 ff ff       	call   b620 <creat_subhead.isra.0>

				fsm_pkt_destroy(pkp);  //20140922
    d096:	89 f0                	mov    %esi,%eax
    d098:	e8 fc ff ff ff       	call   d099 <PMRLC_TRANSOP_IND+0x639>
				pkp = NULL;
				break;
    d09d:	e9 1e fb ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
    d0a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d0a8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d0ab:	8b 55 d8             	mov    -0x28(%ebp),%edx
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d0ae:	89 f0                	mov    %esi,%eax
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d0b0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
    d0b3:	8b 52 03             	mov    0x3(%edx),%edx
    d0b6:	0f b7 79 07          	movzwl 0x7(%ecx),%edi
    d0ba:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d0bd:	0f bf 56 2e          	movswl 0x2e(%esi),%edx
    d0c1:	e8 fc ff ff ff       	call   d0c2 <PMRLC_TRANSOP_IND+0x662>
    d0c6:	84 c0                	test   %al,%al
    d0c8:	0f 84 f2 fa ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
					}*/
				}
			}
		
			//
			size = mIoctrl->txQueueSize + mIoctrl->txQueueHeader;
    d0ce:	0f b7 ff             	movzwl %di,%edi
			if(isInsideTranWin(amIns,amIns->SN) &&(size > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
    d0d1:	03 7d dc             	add    -0x24(%ebp),%edi
    d0d4:	0f 84 e6 fa ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
    d0da:	8d 46 44             	lea    0x44(%esi),%eax
    d0dd:	39 46 44             	cmp    %eax,0x44(%esi)
    d0e0:	0f 84 da fa ff ff    	je     cbc0 <PMRLC_TRANSOP_IND+0x160>
			//if(((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) > 0)&&(!list_empty(& amIns->amSduBuffer.list)))
			{
				//fsm_printf("[RLC][PMRLC_TRANSOP_IND] run to am sdu transport\n");
				if( amIns->amSduBufferSize < 128 )
				{
					subHeadLen = 2;
    d0e6:	81 7e 4c 80 00 00 00 	cmpl   $0x80,0x4c(%esi)
    d0ed:	19 c0                	sbb    %eax,%eax
    d0ef:	83 c0 03             	add    $0x3,%eax
				}
				else
				{
					subHeadLen = 3;
				}
				if( size > subHeadLen )
    d0f2:	39 f8                	cmp    %edi,%eax
    d0f4:	0f 83 b8 03 00 00    	jae    d4b2 <PMRLC_TRANSOP_IND+0xa52>
				{
					if( size - subHeadLen > MAX_PDU_SIZE )
    d0fa:	29 c7                	sub    %eax,%edi
    d0fc:	81 ff 78 05 00 00    	cmp    $0x578,%edi
    d102:	0f 86 9a 03 00 00    	jbe    d4a2 <PMRLC_TRANSOP_IND+0xa42>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
    d108:	ba 78 05 00 00       	mov    $0x578,%edx
    d10d:	89 f0                	mov    %esi,%eax
    d10f:	e8 fc ff ff ff       	call   d110 <PMRLC_TRANSOP_IND+0x6b0>
    d114:	89 c7                	mov    %eax,%edi
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
    d116:	85 ff                	test   %edi,%edi
    d118:	0f 84 02 04 00 00    	je     d520 <PMRLC_TRANSOP_IND+0xac0>
						//fsm_printf("[RLC] pduWithoutPoll is %d\n",amIns->pduWithoutPoll);
						//fsm_printf("[RLC] byteWithoutPoll is %d\n",amIns->byteWithoutPoll);
						rlc_poll(amIns,pkp);
					}*/
					//printk("[RLC][PMRLC_TRANSOP_IND] size=%d, pkp->len=%d, subHeadLen=%d\n",size,pkp->len,subHeadLen);
					fsm_mem_cpy( pkptr->tail, pkp->data, pkp->len);
    d11e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d121:	8b 4f 50             	mov    0x50(%edi),%ecx
    d124:	8b 97 ac 00 00 00    	mov    0xac(%edi),%edx
    d12a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    d130:	89 45 90             	mov    %eax,-0x70(%ebp)
    d133:	e8 fc ff ff ff       	call   d134 <PMRLC_TRANSOP_IND+0x6d4>
					if(pkptr->tail+pkp->len > pkptr->end)
    d138:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d13b:	8b 57 50             	mov    0x50(%edi),%edx
    d13e:	89 d0                	mov    %edx,%eax
    d140:	03 81 a0 00 00 00    	add    0xa0(%ecx),%eax
    d146:	39 81 a4 00 00 00    	cmp    %eax,0xa4(%ecx)
    d14c:	0f 82 10 fb ff ff    	jb     cc62 <PMRLC_TRANSOP_IND+0x202>
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
    d152:	89 c8                	mov    %ecx,%eax
    d154:	e8 fc ff ff ff       	call   d155 <PMRLC_TRANSOP_IND+0x6f5>
		fsm_printf("[RLC][PMRLC_BUFFERREP_REQ] After bufferReq the bufferReqTimer start\n");
		SV(bufferReqTimer) = fsm_schedule_self(SV(bufferReqTimerValue),SV(bufferReqTimerCode));
	}*/
	return (void*)nump;	//add in 20150804
	//FOUT;
}
    d159:	8d 47 50             	lea    0x50(%edi),%eax
    d15c:	89 45 dc             	mov    %eax,-0x24(%ebp)
					{
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
    d15f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    d162:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    d165:	8d 55 ec             	lea    -0x14(%ebp),%edx
    d168:	89 44 24 04          	mov    %eax,0x4(%esp)
    d16c:	0f b6 46 03          	movzbl 0x3(%esi),%eax
    d170:	89 04 24             	mov    %eax,(%esp)
    d173:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d176:	e8 a5 e4 ff ff       	call   b620 <creat_subhead.isra.0>
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d17b:	0f bf 86 64 12 00 00 	movswl 0x1264(%esi),%eax
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
    d182:	66 83 86 fc 22 00 00 	addw   $0x1,0x22fc(%esi)
    d189:	01 
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d18a:	83 c0 01             	add    $0x1,%eax
    d18d:	89 c2                	mov    %eax,%edx
    d18f:	c1 fa 1f             	sar    $0x1f,%edx
    d192:	c1 ea 16             	shr    $0x16,%edx
    d195:	01 d0                	add    %edx,%eax
    d197:	25 ff 03 00 00       	and    $0x3ff,%eax
    d19c:	29 d0                	sub    %edx,%eax

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d19e:	ba 0a 00 00 00       	mov    $0xa,%edx
						//printk("[RLC][PMRLC_TRANSOP_IND] skb_over_panic,%p, %p\n",pkptr->tail+pkp->len,pkptr->end);
						FOUT;
					}
					fsm_skb_put( pkptr,pkp->len);
					creat_subhead(pkp, &ptr, &preptr, amIns->lcId, &data);
					amIns->vt_s = (amIns->vt_s + 1)%(AM_WINDOW_SIZE*2);
    d1a3:	66 89 86 64 12 00 00 	mov    %ax,0x1264(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->lcId = %d\n",amIns->lcId);
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] amIns->vt_s  is updated to %d, the len of the data is %d\n",amIns->vt_s , pkp->len);

					//pduWithoutPollbyteWithoutPoll
					amIns->pduWithoutPoll++;
					amIns->byteWithoutPoll += pkp->len;
    d1aa:	8b 47 50             	mov    0x50(%edi),%eax
    d1ad:	66 01 86 fe 22 00 00 	add    %ax,0x22fe(%esi)
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] new data transport\n");
					fsm_octets_print(pkp->data,10);
    d1b4:	8b 87 ac 00 00 00    	mov    0xac(%edi),%eax
    d1ba:	e8 fc ff ff ff       	call   d1bb <PMRLC_TRANSOP_IND+0x75b>

					fsm_pkt_destroy(pkp);  //20140922
    d1bf:	89 f8                	mov    %edi,%eax
    d1c1:	e8 fc ff ff ff       	call   d1c2 <PMRLC_TRANSOP_IND+0x762>
    d1c6:	e9 f5 f9 ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
    d1cb:	90                   	nop
    d1cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	{
		findInsBylcid(mIoctrl->lcid,  &insptru, &insptrd, &SV(ins_mode));
		switch(SV(ins_mode))
		{
		case TM_MODE:
			if(insptru == NULL)
    d1d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d1d3:	85 c0                	test   %eax,%eax
    d1d5:	0f 84 42 f9 ff ff    	je     cb1d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d1db:	8b 5d e0             	mov    -0x20(%ebp),%ebx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d1de:	8d 78 0c             	lea    0xc(%eax),%edi
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d1e1:	8b 56 03             	mov    0x3(%esi),%edx
    d1e4:	0f b7 4e 07          	movzwl 0x7(%esi),%ecx
    d1e8:	01 d3                	add    %edx,%ebx
    d1ea:	01 d9                	add    %ebx,%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d1ec:	31 db                	xor    %ebx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d1ee:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d1f1:	8b 48 0c             	mov    0xc(%eax),%ecx
**********************************************************/
static void check_num(TM_TX_Instance * tmTxIns, long size, u32 *sevNum, u32 *fifNum )
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
    d1f4:	39 cf                	cmp    %ecx,%edi
    d1f6:	74 5c                	je     d254 <PMRLC_TRANSOP_IND+0x7f4>
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
    d1f8:	8b 41 fc             	mov    -0x4(%ecx),%eax
    d1fb:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d1fe:	29 c2                	sub    %eax,%edx
    d200:	78 52                	js     d254 <PMRLC_TRANSOP_IND+0x7f4>
    d202:	89 75 c8             	mov    %esi,-0x38(%ebp)
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d205:	83 e9 04             	sub    $0x4,%ecx
    d208:	31 f6                	xor    %esi,%esi
			{
				break;
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
    d20a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    d211:	eb 20                	jmp    d233 <PMRLC_TRANSOP_IND+0x7d3>
    d213:	90                   	nop
    d214:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d218:	8b 41 04             	mov    0x4(%ecx),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
			{
				if(txBuffer->pkt->len < 127)
				{
					(*sevNum)++;
    d21b:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d21e:	39 c7                	cmp    %eax,%edi
    d220:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d223:	74 20                	je     d245 <PMRLC_TRANSOP_IND+0x7e5>
		{
			size -= txBuffer->pkt->len;
    d225:	8b 40 fc             	mov    -0x4(%eax),%eax
    d228:	8b 40 50             	mov    0x50(%eax),%eax
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d22b:	29 c2                	sub    %eax,%edx
    d22d:	0f 88 e5 01 00 00    	js     d418 <PMRLC_TRANSOP_IND+0x9b8>
			{
				if(txBuffer->pkt->len < 127)
    d233:	83 f8 7e             	cmp    $0x7e,%eax
    d236:	76 e0                	jbe    d218 <PMRLC_TRANSOP_IND+0x7b8>
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d238:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d23b:	83 c3 01             	add    $0x1,%ebx
{
	struct Buffer *txBuffer;
	
	if(!list_empty(&tmTxIns->tmSduBuffer.list))
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
    d23e:	39 c7                	cmp    %eax,%edi
    d240:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d243:	75 e0                	jne    d225 <PMRLC_TRANSOP_IND+0x7c5>
    d245:	89 75 d4             	mov    %esi,-0x2c(%ebp)
    d248:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d24b:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d24e:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d251:	8d 1c 48             	lea    (%eax,%ecx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d254:	01 5d dc             	add    %ebx,-0x24(%ebp)
			break;
    d257:	e9 c1 f8 ff ff       	jmp    cb1d <PMRLC_TRANSOP_IND+0xbd>
    d25c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			//fsm_printf("[RLC][PMRLC_TRANSOP_IND] um instance(lcid is %d)'s buffer's subhead is %d \n",umTxIns->lcid,subhead);
			break;

		case AM_MODE:
			if(insptru == NULL)
    d260:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    d263:	85 ff                	test   %edi,%edi
    d265:	0f 84 b2 f8 ff ff    	je     cb1d <PMRLC_TRANSOP_IND+0xbd>
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d26b:	8b 56 03             	mov    0x3(%esi),%edx
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d26e:	8d 9f 9c 01 00 00    	lea    0x19c(%edi),%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d274:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d278:	8b 4d e0             	mov    -0x20(%ebp),%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d27b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    d282:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d289:	01 d0                	add    %edx,%eax
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d28b:	8b 56 09             	mov    0x9(%esi),%edx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d28e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    d291:	0f b7 46 0d          	movzwl 0xd(%esi),%eax
    d295:	01 d1                	add    %edx,%ecx
    d297:	01 c1                	add    %eax,%ecx
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;
    d299:	0f b7 46 11          	movzwl 0x11(%esi),%eax
    d29d:	01 c8                	add    %ecx,%eax
    d29f:	0f b7 4e 0f          	movzwl 0xf(%esi),%ecx
    d2a3:	01 c8                	add    %ecx,%eax
    d2a5:	89 4d bc             	mov    %ecx,-0x44(%ebp)
    d2a8:	8b 8f 9c 01 00 00    	mov    0x19c(%edi),%ecx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d2ae:	03 45 d4             	add    -0x2c(%ebp),%eax
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d2b1:	39 cb                	cmp    %ecx,%ebx
			if(insptru == NULL)
			{
				break;
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
    d2b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
**********************************************************/
static void check_retx_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
    d2b6:	74 78                	je     d330 <PMRLC_TRANSOP_IND+0x8d0>
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d2b8:	8b 81 64 ff ff ff    	mov    -0x9c(%ecx),%eax
    d2be:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d2c1:	29 c2                	sub    %eax,%edx
    d2c3:	0f 88 4c 02 00 00    	js     d515 <PMRLC_TRANSOP_IND+0xab5>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d2c9:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
    d2cf:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
    d2d2:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
    d2d5:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d2d8:	31 f6                	xor    %esi,%esi
    d2da:	89 7d a8             	mov    %edi,-0x58(%ebp)
    d2dd:	31 ff                	xor    %edi,%edi
    d2df:	eb 2b                	jmp    d30c <PMRLC_TRANSOP_IND+0x8ac>
    d2e1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    d2e8:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
			size -= amBuffer->pkt->len;
			if(0 <= size)
			{
				if(amBuffer->pkt->len  <  128)
				{
					(*sevNum)++;
    d2ee:	83 c7 01             	add    $0x1,%edi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d2f1:	39 c3                	cmp    %eax,%ebx
    d2f3:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d2f9:	74 29                	je     d324 <PMRLC_TRANSOP_IND+0x8c4>
		{
			//fsm_printf("[RLC][check_retx_num] the packet's len is %d, the size is %d\n",amBuffer->pkt->len,size);
			size -= amBuffer->pkt->len;
    d2fb:	8b 80 64 ff ff ff    	mov    -0x9c(%eax),%eax
    d301:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d304:	29 c2                	sub    %eax,%edx
    d306:	0f 88 24 01 00 00    	js     d430 <PMRLC_TRANSOP_IND+0x9d0>
			{
				if(amBuffer->pkt->len  <  128)
    d30c:	83 f8 7f             	cmp    $0x7f,%eax
    d30f:	76 d7                	jbe    d2e8 <PMRLC_TRANSOP_IND+0x888>
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d311:	8b 81 9c 00 00 00    	mov    0x9c(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					(*fifNum)++;
    d317:	83 c6 01             	add    $0x1,%esi
{
	struct AmBuffer *amBuffer;
	
	if(!list_empty(&amIns->amRetxBuffer.list))
	{
		list_for_each_entry(amBuffer,&amIns->amRetxBuffer.list,list)
    d31a:	39 c3                	cmp    %eax,%ebx
    d31c:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
    d322:	75 d7                	jne    d2fb <PMRLC_TRANSOP_IND+0x89b>
    d324:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d327:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d32a:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d32d:	8b 7d a8             	mov    -0x58(%ebp),%edi
    d330:	8b 8f b0 01 00 00    	mov    0x1b0(%edi),%ecx
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d336:	8d 9f b0 01 00 00    	lea    0x1b0(%edi),%ebx

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
    d33c:	31 ff                	xor    %edi,%edi
    d33e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
**********************************************************/
static void check_stat_num(struct AM_Instance *amIns,long size, u32 *sevNum, u32 *fifNum)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
    d345:	39 cb                	cmp    %ecx,%ebx
    d347:	74 46                	je     d38f <PMRLC_TRANSOP_IND+0x92f>
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d349:	8b 41 fc             	mov    -0x4(%ecx),%eax
			if(0 <= size)
    d34c:	8b 55 bc             	mov    -0x44(%ebp),%edx
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d34f:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d352:	29 c2                	sub    %eax,%edx
    d354:	78 39                	js     d38f <PMRLC_TRANSOP_IND+0x92f>
    d356:	89 75 bc             	mov    %esi,-0x44(%ebp)
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d359:	83 e9 04             	sub    $0x4,%ecx
    d35c:	31 f6                	xor    %esi,%esi
    d35e:	eb 17                	jmp    d377 <PMRLC_TRANSOP_IND+0x917>
    d360:	8b 41 04             	mov    0x4(%ecx),%eax
			size -= statBuffer->pkt->len;
			if(0 <= size)
			{
				if(statBuffer->pkt->len< 128)
				{
					(*sevNum)++;
    d363:	83 c6 01             	add    $0x1,%esi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d366:	39 c3                	cmp    %eax,%ebx
    d368:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d36b:	74 1c                	je     d389 <PMRLC_TRANSOP_IND+0x929>
		{
			//fsm_printf("[RLC][check_stat_num] the packet's len is %d, the size is %d\n",statBuffer->pkt->len,size);
			size -= statBuffer->pkt->len;
    d36d:	8b 40 fc             	mov    -0x4(%eax),%eax
    d370:	8b 40 50             	mov    0x50(%eax),%eax
			if(0 <= size)
    d373:	29 c2                	sub    %eax,%edx
    d375:	78 12                	js     d389 <PMRLC_TRANSOP_IND+0x929>
			{
				if(statBuffer->pkt->len< 128)
    d377:	83 f8 7f             	cmp    $0x7f,%eax
    d37a:	76 e4                	jbe    d360 <PMRLC_TRANSOP_IND+0x900>
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d37c:	8b 41 04             	mov    0x4(%ecx),%eax
				{
					(*sevNum)++;
				}
				else
				{
					( *fifNum)++;
    d37f:	83 c7 01             	add    $0x1,%edi
{
	struct Buffer *statBuffer;
	
	if(!list_empty(&amIns->ctrlPduBuffer.list))
	{
		list_for_each_entry(statBuffer,&amIns->ctrlPduBuffer.list,list)
    d382:	39 c3                	cmp    %eax,%ebx
    d384:	8d 48 fc             	lea    -0x4(%eax),%ecx
    d387:	75 e4                	jne    d36d <PMRLC_TRANSOP_IND+0x90d>
    d389:	89 75 b8             	mov    %esi,-0x48(%ebp)
    d38c:	8b 75 bc             	mov    -0x44(%ebp),%esi
    d38f:	03 7d c8             	add    -0x38(%ebp),%edi
    d392:	8b 45 b8             	mov    -0x48(%ebp),%eax
    d395:	03 45 c4             	add    -0x3c(%ebp),%eax
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
			check_retx_num(amIns,mIoctrl->retxQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d398:	8d 14 7f             	lea    (%edi,%edi,2),%edx
    d39b:	8d 04 42             	lea    (%edx,%eax,2),%eax
			//fsm_printf("am instance(lcid is %d)'s retx buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);
			sevNum = fifNum = 0;
			check_stat_num(amIns,mIoctrl->statusPduSize, &sevNum, &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d39e:	03 45 dc             	add    -0x24(%ebp),%eax
			//fsm_printf("am instance(lcid is %d)'s status buffer has %d 7bits sunhead,and %d 15bits\n",amIns->lcId,sevNum, fifNum);

			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{				
				subhead += 2;
    d3a1:	8d 50 02             	lea    0x2(%eax),%edx
    d3a4:	83 c0 03             	add    $0x3,%eax
    d3a7:	83 7d d4 7f          	cmpl   $0x7f,-0x2c(%ebp)
    d3ab:	0f 46 c2             	cmovbe %edx,%eax
    d3ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
    d3b1:	e9 67 f7 ff ff       	jmp    cb1d <PMRLC_TRANSOP_IND+0xbd>
    d3b6:	66 90                	xchg   %ax,%ax
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
			break;

		case UM_MODE:
			if(insptru == NULL)
    d3b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    d3bb:	85 c0                	test   %eax,%eax
    d3bd:	0f 84 5a f7 ff ff    	je     cb1d <PMRLC_TRANSOP_IND+0xbd>
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d3c3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d3c6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d3c9:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d3cd:	03 46 03             	add    0x3(%esi),%eax
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d3d0:	83 c2 02             	add    $0x2,%edx
    d3d3:	83 c1 03             	add    $0x3,%ecx
			if(insptru == NULL)
			{
				break;
			}
			umTxIns = (UM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
    d3d6:	01 45 e0             	add    %eax,-0x20(%ebp)
			if((mIoctrl->txQueueSize + mIoctrl->txQueueHeader) < 128)
			{
				subhead += 2;
    d3d9:	83 f8 7f             	cmp    $0x7f,%eax
    d3dc:	0f 47 d1             	cmova  %ecx,%edx
    d3df:	89 55 dc             	mov    %edx,-0x24(%ebp)
    d3e2:	e9 36 f7 ff ff       	jmp    cb1d <PMRLC_TRANSOP_IND+0xbd>
    d3e7:	90                   	nop
				{
					pkp = rlc_UM_segment(umTxIns,MAX_PDU_SIZE);
				}
				else
				{
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
    d3e8:	89 f8                	mov    %edi,%eax
    d3ea:	e8 fc ff ff ff       	call   d3eb <PMRLC_TRANSOP_IND+0x98b>
    d3ef:	89 c6                	mov    %eax,%esi
    d3f1:	e9 51 fc ff ff       	jmp    d047 <PMRLC_TRANSOP_IND+0x5e7>
    d3f6:	66 90                	xchg   %ax,%ax
				pkp = NULL;
				break;
			}
			else
			{
				fsm_printf("[RLC][PMRLC_TRANSOP_IND][UM] break:um instance mIoctrl->txQueueSize is %d, data is %d\n", mIoctrl->txQueueSize, buffer->pkt->len + subHeadLen);
    d3f8:	8b 13                	mov    (%ebx),%edx
    d3fa:	03 42 50             	add    0x50(%edx),%eax
    d3fd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    d401:	c7 04 24 34 36 00 00 	movl   $0x3634,(%esp)
    d408:	89 44 24 08          	mov    %eax,0x8(%esp)
    d40c:	e8 fc ff ff ff       	call   d40d <PMRLC_TRANSOP_IND+0x9ad>
				break;
    d411:	e9 aa f7 ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
    d416:	66 90                	xchg   %ax,%ax
    d418:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	{
		list_for_each_entry(txBuffer,&tmTxIns->tmSduBuffer.list,list)
		{
			size -= txBuffer->pkt->len;
			//fsm_printf("[RLC][check_num] the packet's len is %d, the size is %d\n",txBuffer->pkt->len, size);
			if(0 <= size)
    d41b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d41e:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
    d421:	8b 75 c8             	mov    -0x38(%ebp),%esi
    d424:	8d 1c 50             	lea    (%eax,%edx,2),%ebx
			}
			tmTxIns = (TM_TX_Instance *)insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize;
			sevNum = fifNum = 0;
			check_num(tmTxIns, mIoctrl->txQueueSize,  &sevNum,  &fifNum);
			subhead += 2*sevNum + 3*fifNum;
    d427:	01 5d dc             	add    %ebx,-0x24(%ebp)
    d42a:	e9 ee f6 ff ff       	jmp    cb1d <PMRLC_TRANSOP_IND+0xbd>
    d42f:	90                   	nop
    d430:	89 75 c8             	mov    %esi,-0x38(%ebp)
    d433:	8b 75 b8             	mov    -0x48(%ebp),%esi
    d436:	89 7d c4             	mov    %edi,-0x3c(%ebp)
    d439:	8b 7d a8             	mov    -0x58(%ebp),%edi
					(*fifNum)++;
				}
			}
			else
			{
				if(( size + amBuffer->pkt->len + 2 ) < 128)
    d43c:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
    d440:	83 f8 7f             	cmp    $0x7f,%eax
    d443:	77 09                	ja     d44e <PMRLC_TRANSOP_IND+0x9ee>
				{
					(*sevNum)++;
    d445:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
    d449:	e9 e2 fe ff ff       	jmp    d330 <PMRLC_TRANSOP_IND+0x8d0>
				}
				else
				{
					(*fifNum)++;
    d44e:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
    d452:	e9 d9 fe ff ff       	jmp    d330 <PMRLC_TRANSOP_IND+0x8d0>
		}
	}
		
	if(0 == pkptr->len)
	{
		fsm_printf("[RLC][PMRLC_TRANSOP_IND] there is no data to send\n");
    d457:	c7 04 24 d8 37 00 00 	movl   $0x37d8,(%esp)
    d45e:	e8 fc ff ff ff       	call   d45f <PMRLC_TRANSOP_IND+0x9ff>
		SV(bufferReqTimer) = 0;
    d463:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d466:	c7 80 34 37 00 00 00 	movl   $0x0,0x3734(%eax)
    d46d:	00 00 00 
		fsm_data_destroy(hptr);
    d470:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    d473:	e8 fc ff ff ff       	call   d474 <PMRLC_TRANSOP_IND+0xa14>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d478:	83 c4 70             	add    $0x70,%esp
    d47b:	5b                   	pop    %ebx
    d47c:	5e                   	pop    %esi
    d47d:	5f                   	pop    %edi
    d47e:	5d                   	pop    %ebp
    d47f:	c3                   	ret    
							fsm_pkt_destroy(pkp);  //20140922
							pkp = NULL;
						}
						else
						{
							fsm_printf("[RLC][PMRLC_TRANSOP_IND][AM] break:am instance mIoctrl->retxQueueSize is %d, data is %d\n", size, amBuffer->pkt->len+subHeadLen);
    d480:	03 45 d4             	add    -0x2c(%ebp),%eax
    d483:	8b 5d b0             	mov    -0x50(%ebp),%ebx
    d486:	c7 04 24 e4 36 00 00 	movl   $0x36e4,(%esp)
    d48d:	89 44 24 08          	mov    %eax,0x8(%esp)
    d491:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d494:	89 44 24 04          	mov    %eax,0x4(%esp)
    d498:	e8 fc ff ff ff       	call   d499 <PMRLC_TRANSOP_IND+0xa39>
							break;
    d49d:	e9 09 fc ff ff       	jmp    d0ab <PMRLC_TRANSOP_IND+0x64b>
					{
						pkp = rlc_AM_segment(amIns,MAX_PDU_SIZE);
					}
					else
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
    d4a2:	89 fa                	mov    %edi,%edx
    d4a4:	89 f0                	mov    %esi,%eax
    d4a6:	e8 fc ff ff ff       	call   d4a7 <PMRLC_TRANSOP_IND+0xa47>
    d4ab:	89 c7                	mov    %eax,%edi
    d4ad:	e9 64 fc ff ff       	jmp    d116 <PMRLC_TRANSOP_IND+0x6b6>
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
    d4b2:	8b 13                	mov    (%ebx),%edx
					fsm_pkt_destroy(pkp);  //20140922
					pkp = NULL;
				}
				else
				{
					fsm_printf("[RLC][PMRLC_TRANSOP_IND] break:am instance mIoctrl->txQueueSize + mIoctrl->txQueueHeader is %d, data is %d\n",\
    d4b4:	8b 75 d8             	mov    -0x28(%ebp),%esi
    d4b7:	03 42 50             	add    0x50(%edx),%eax
    d4ba:	89 44 24 08          	mov    %eax,0x8(%esp)
    d4be:	0f b7 46 07          	movzwl 0x7(%esi),%eax
    d4c2:	03 46 03             	add    0x3(%esi),%eax
    d4c5:	c7 04 24 6c 37 00 00 	movl   $0x376c,(%esp)
    d4cc:	89 44 24 04          	mov    %eax,0x4(%esp)
    d4d0:	e8 fc ff ff ff       	call   d4d1 <PMRLC_TRANSOP_IND+0xa71>
					mIoctrl->txQueueSize+mIoctrl->txQueueHeader, buffer->pkt->len + subHeadLen);
					break;
    d4d5:	e9 e6 f6 ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
	nump = (u32*)hptr;
	num = *nump;
	//fsm_printf("[RLC][PMRLC_TRANSOP_IND] entering PMRLC_TRANSOP_IND(number of instances is %d)\n", num);
	if(num == 0)
	{
		fsm_data_destroy(hptr);
    d4da:	89 d0                	mov    %edx,%eax
    d4dc:	e8 fc ff ff ff       	call   d4dd <PMRLC_TRANSOP_IND+0xa7d>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d4e1:	83 c4 70             	add    $0x70,%esp
    d4e4:	5b                   	pop    %ebx
    d4e5:	5e                   	pop    %esi
    d4e6:	5f                   	pop    %edi
    d4e7:	5d                   	pop    %ebp
    d4e8:	c3                   	ret    
				}
				//
				if( !amIns->statProhTimer )
				{
					//fsm_printf("[RLC][PMRLC_TRANSOP_IND] the statProhTimer start\n");
					amIns->statProhTimer = fsm_schedule_self(amIns->statProhTimerValue,amIns->statProhTimerCode);
    d4e9:	8b 56 24             	mov    0x24(%esi),%edx
    d4ec:	8b 46 28             	mov    0x28(%esi),%eax
    d4ef:	e8 fc ff ff ff       	call   d4f0 <PMRLC_TRANSOP_IND+0xa90>
    d4f4:	89 46 20             	mov    %eax,0x20(%esi)
    d4f7:	e9 be f9 ff ff       	jmp    ceba <PMRLC_TRANSOP_IND+0x45a>
		FOUT;
	}*/
	//fsm_pkt_send( pkptr, STRM_TO_MAC);
	if( SV(T_C_RNTI) !=0 )	//add in 20150831
	{
		send_msg3(pkptr);
    d4fc:	e8 fc ff ff ff       	call   d4fd <PMRLC_TRANSOP_IND+0xa9d>
		fsm_printf("[RLC_MAC]excute RA send_msg3!\n");
    d501:	c7 04 24 0c 38 00 00 	movl   $0x380c,(%esp)
    d508:	e8 fc ff ff ff       	call   d509 <PMRLC_TRANSOP_IND+0xaa9>
		fsm_data_destroy(hptr);
		hptr = NULL;
		PMRLC_BUFFERREP_REQ();
		FOUT;
	}
}
    d50d:	83 c4 70             	add    $0x70,%esp
    d510:	5b                   	pop    %ebx
    d511:	5e                   	pop    %esi
    d512:	5f                   	pop    %edi
    d513:	5d                   	pop    %ebp
    d514:	c3                   	ret    
			}
			amIns  = (AM_Instance * )insptru;
			data += mIoctrl->txQueueHeader + mIoctrl->txQueueSize + mIoctrl->retxQueueHeader + \
			    mIoctrl->retxQueueSize + mIoctrl->statusPduHeader + mIoctrl->statusPduSize;

			sevNum = fifNum = 0;	
    d515:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d518:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d51b:	e9 1c ff ff ff       	jmp    d43c <PMRLC_TRANSOP_IND+0x9dc>
					{
						pkp = rlc_AM_segment(amIns,size - subHeadLen);						
					}
					if(pkp == NULL)
					{
						printk("[RLC][PMRLC_TRANSOP_IND][AM] pkp == NULL\n");
    d520:	c7 04 24 40 37 00 00 	movl   $0x3740,(%esp)
    d527:	e8 fc ff ff ff       	call   d528 <PMRLC_TRANSOP_IND+0xac8>
						break;
    d52c:	e9 8f f6 ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
					pkp = rlc_UM_segment(umTxIns,mIoctrl->txQueueSize + mIoctrl->txQueueHeader - subHeadLen);						
				}
				
				if(pkp == NULL)
				{
					printk("[RLC][PMRLC_TRANSOP_IND][UM] pkp == NULL\n");
    d531:	c7 04 24 08 36 00 00 	movl   $0x3608,(%esp)
    d538:	e8 fc ff ff ff       	call   d539 <PMRLC_TRANSOP_IND+0xad9>
					break;
    d53d:	e9 7e f6 ff ff       	jmp    cbc0 <PMRLC_TRANSOP_IND+0x160>
    d542:	90                   	nop
    d543:	90                   	nop
    d544:	90                   	nop
    d545:	90                   	nop
    d546:	90                   	nop
    d547:	90                   	nop
    d548:	90                   	nop
    d549:	90                   	nop
    d54a:	90                   	nop
    d54b:	90                   	nop
    d54c:	90                   	nop
    d54d:	90                   	nop
    d54e:	90                   	nop
    d54f:	90                   	nop

0000d550 <get_AmPduhdExt>:
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d550:	55                   	push   %ebp
    d551:	89 e5                	mov    %esp,%ebp
    d553:	83 ec 14             	sub    $0x14,%esp
    d556:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d559:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d55c:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d55f:	e8 fc ff ff ff       	call   d560 <get_AmPduhdExt+0x10>
    d564:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d567:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date: 2014-10-16
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d56b:	89 d6                	mov    %edx,%esi
    d56d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d56f:	74 0f                	je     d580 <get_AmPduhdExt+0x30>
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
	}
	return count;
}
    d571:	89 d8                	mov    %ebx,%eax
    d573:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d576:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d579:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d57c:	89 ec                	mov    %ebp,%esp
    d57e:	5d                   	pop    %ebp
    d57f:	c3                   	ret    
u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d580:	8b 02                	mov    (%edx),%eax
    d582:	b9 02 00 00 00       	mov    $0x2,%ecx

u16 get_AmPduhdExt(u16 E,struct AmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d587:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d58d:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d593:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d596:	e8 fc ff ff ff       	call   d597 <get_AmPduhdExt+0x47>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d59b:	8b 06                	mov    (%esi),%eax
    d59d:	ba 02 00 00 00       	mov    $0x2,%edx
    d5a2:	e8 fc ff ff ff       	call   d5a3 <get_AmPduhdExt+0x53>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d5a7:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d5ab:	0f b7 d3             	movzwl %bx,%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
    d5ae:	83 c3 01             	add    $0x1,%ebx
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d5b1:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d5b4:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d5ba:	66 25 ff 7f          	and    $0x7fff,%ax
    d5be:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d5c3:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d5c8:	89 f2                	mov    %esi,%edx
    d5ca:	89 3c 24             	mov    %edi,(%esp)
    d5cd:	e8 fc ff ff ff       	call   d5ce <get_AmPduhdExt+0x7e>
	}
	return count;
}
    d5d2:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d5d5:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
		count++;
		
		count = get_AmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt); 
    d5d8:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d5da:	89 d8                	mov    %ebx,%eax
    d5dc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d5df:	89 ec                	mov    %ebp,%esp
    d5e1:	5d                   	pop    %ebp
    d5e2:	c3                   	ret    
    d5e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    d5e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000d5f0 <get_UmPduhdExt>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d5f0:	55                   	push   %ebp
    d5f1:	89 e5                	mov    %esp,%ebp
    d5f3:	83 ec 18             	sub    $0x18,%esp
    d5f6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
    d5f9:	89 75 f8             	mov    %esi,-0x8(%ebp)
    d5fc:	89 7d fc             	mov    %edi,-0x4(%ebp)
    d5ff:	e8 fc ff ff ff       	call   d600 <get_UmPduhdExt+0x10>
    d604:	8b 7d 08             	mov    0x8(%ebp),%edi
	if(E==1)
    d607:	66 83 f8 01          	cmp    $0x1,%ax
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
    d60b:	89 d6                	mov    %edx,%esi
    d60d:	89 cb                	mov    %ecx,%ebx
	if(E==1)
    d60f:	74 0f                	je     d620 <get_UmPduhdExt+0x30>

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
	}
	return count;
}
    d611:	89 d8                	mov    %ebx,%eax
    d613:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d616:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d619:	8b 7d fc             	mov    -0x4(%ebp),%edi
    d61c:	89 ec                	mov    %ebp,%esp
    d61e:	5d                   	pop    %ebp
    d61f:	c3                   	ret    
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d620:	0f b7 c1             	movzwl %cx,%eax
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d623:	b9 02 00 00 00       	mov    $0x2,%ecx
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
    d628:	89 45 ec             	mov    %eax,-0x14(%ebp)
u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d62b:	8b 02                	mov    (%edx),%eax
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
    d62d:	83 c3 01             	add    $0x1,%ebx

u16 get_UmPduhdExt(u16 E,struct UmBuffer *tbuff,u16 count,struct _pduhdrExt *pPduhdrExt)
{
	if(E==1)
	{
		u16 b=0;
    d630:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
    d636:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d63c:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d63f:	e8 fc ff ff ff       	call   d640 <get_UmPduhdExt+0x50>
		fsm_skb_pull(tbuff->pkt, 2) ;
    d644:	8b 06                	mov    (%esi),%eax
    d646:	ba 02 00 00 00       	mov    $0x2,%edx
    d64b:	e8 fc ff ff ff       	call   d64c <get_UmPduhdExt+0x5c>
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);
    d650:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d654:	0f b7 cb             	movzwl %bx,%ecx
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d657:	8b 55 ec             	mov    -0x14(%ebp),%edx
		pPduhdrExt->LI[count] = (b&0x7fff);
    d65a:	66 25 ff 7f          	and    $0x7fff,%ax
	if(E==1)
	{
		u16 b=0;
		fsm_mem_cpy(&b,tbuff->pkt->data,2);
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
    d65e:	66 c7 04 57 00 00    	movw   $0x0,(%edi,%edx,2)
		pPduhdrExt->LI[count] = (b&0x7fff);
    d664:	66 89 44 57 20       	mov    %ax,0x20(%edi,%edx,2)

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d669:	0f b7 44 4f fe       	movzwl -0x2(%edi,%ecx,2),%eax
    d66e:	89 f2                	mov    %esi,%edx
    d670:	89 3c 24             	mov    %edi,(%esp)
    d673:	e8 fc ff ff ff       	call   d674 <get_UmPduhdExt+0x84>
	}
	return count;
}
    d678:	8b 75 f8             	mov    -0x8(%ebp),%esi
    d67b:	8b 7d fc             	mov    -0x4(%ebp),%edi
		fsm_skb_pull(tbuff->pkt, 2) ;
		pPduhdrExt->E[count] = (b&0x1000)>>15;
		pPduhdrExt->LI[count] = (b&0x7fff);

		count++;
		count = get_UmPduhdExt(pPduhdrExt->E[count-1],tbuff,count,pPduhdrExt);
    d67e:	89 c3                	mov    %eax,%ebx
	}
	return count;
}
    d680:	89 d8                	mov    %ebx,%eax
    d682:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d685:	89 ec                	mov    %ebp,%esp
    d687:	5d                   	pop    %ebp
    d688:	c3                   	ret    
    d689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000d690 <clear_left_pdu>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void clear_left_pdu(struct pduLeft *pdu_left)
{	
    d690:	55                   	push   %ebp
    d691:	89 e5                	mov    %esp,%ebp
    d693:	53                   	push   %ebx
    d694:	e8 fc ff ff ff       	call   d695 <clear_left_pdu+0x5>
    d699:	89 c3                	mov    %eax,%ebx
	pdu_left->SN_Left = -1;
    d69b:	66 c7 40 02 ff ff    	movw   $0xffff,0x2(%eax)
	pdu_left->SN5_Left = -1;
    d6a1:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
	if(pdu_left->sduLeft != NULL)
    d6a6:	8b 40 04             	mov    0x4(%eax),%eax
    d6a9:	85 c0                	test   %eax,%eax
    d6ab:	74 0c                	je     d6b9 <clear_left_pdu+0x29>
	{
	    fsm_pkt_destroy(pdu_left->sduLeft);
    d6ad:	e8 fc ff ff ff       	call   d6ae <clear_left_pdu+0x1e>
		pdu_left->sduLeft = NULL;
    d6b2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	}               
}
    d6b9:	5b                   	pop    %ebx
    d6ba:	5d                   	pop    %ebp
    d6bb:	c3                   	ret    
    d6bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000d6c0 <rlc_AM_segment>:
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d6c0:	55                   	push   %ebp
    d6c1:	89 e5                	mov    %esp,%ebp
    d6c3:	57                   	push   %edi
    d6c4:	56                   	push   %esi
    d6c5:	53                   	push   %ebx
    d6c6:	83 ec 38             	sub    $0x38,%esp
    d6c9:	e8 fc ff ff ff       	call   d6ca <rlc_AM_segment+0xa>
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d6ce:	0f b7 75 f2          	movzwl -0xe(%ebp),%esi
** Modified by	:li xu long
** Modified Date: 2015-3-6
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{
    d6d2:	89 c7                	mov    %eax,%edi

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d6d4:	8b 40 50             	mov    0x50(%eax),%eax
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d6d7:	66 81 e6 00 fc       	and    $0xfc00,%si
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
    d6dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct AmSduBuffer *amBuffer,*tempBuffer, *tbuff;
	struct RLC_AMPDU_fixhead *fixhead, amhead;
	struct list_head *pos;
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
    d6df:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
    d6e3:	66 25 ff 03          	and    $0x3ff,%ax
    d6e7:	09 c6                	or     %eax,%esi
    d6e9:	66 89 75 f2          	mov    %si,-0xe(%ebp)
	fixhead->DorC=1;
    d6ed:	66 c1 ee 08          	shr    $0x8,%si
	fixhead->RF=0;
    d6f1:	83 e6 1f             	and    $0x1f,%esi
	fixhead->P=1;
    d6f4:	83 ce a0             	or     $0xffffffa0,%esi
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d6f7:	83 fa 02             	cmp    $0x2,%edx
	struct AmBuffer *amBuf;
	fixhead=&amhead;
	fixhead->SN=amIns->SN;
	fixhead->DorC=1;
	fixhead->RF=0;
	fixhead->P=1;
    d6fa:	89 f1                	mov    %esi,%ecx
    d6fc:	88 4d f3             	mov    %cl,-0xd(%ebp)
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
    d6ff:	0f 86 e1 06 00 00    	jbe    dde6 <rlc_AM_segment+0x726>
    d705:	8b 47 44             	mov    0x44(%edi),%eax
	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
	FSM_PKT *skb;//*skb_copy;
	struct list_head *head =&(amIns->amSduBuffer.list);
    d708:	8d 5f 44             	lea    0x44(%edi),%ebx
    d70b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
    d70e:	39 c3                	cmp    %eax,%ebx
    d710:	0f 84 02 05 00 00    	je     dc18 <rlc_AM_segment+0x558>
	{
		list_for_each_entry(amBuffer,head,list)
    d716:	8d 58 f4             	lea    -0xc(%eax),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d719:	8b 40 f4             	mov    -0xc(%eax),%eax
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
		return NULL;
	}
	size = sizeFromMac - 2;
    d71c:	83 ea 02             	sub    $0x2,%edx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d71f:	8b 40 50             	mov    0x50(%eax),%eax
    d722:	39 c2                	cmp    %eax,%edx
    d724:	0f 82 5f 06 00 00    	jb     dd89 <rlc_AM_segment+0x6c9>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d72a:	0f 84 2a 06 00 00    	je     dd5a <rlc_AM_segment+0x69a>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d730:	8d 48 02             	lea    0x2(%eax),%ecx
    d733:	39 ca                	cmp    %ecx,%edx
    d735:	0f 86 7d 06 00 00    	jbe    ddb8 <rlc_AM_segment+0x6f8>
    d73b:	89 7d e0             	mov    %edi,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    d73e:	b9 01 00 00 00       	mov    $0x1,%ecx
    d743:	bf 01 00 00 00       	mov    $0x1,%edi
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d748:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    d74e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d754:	eb 56                	jmp    d7ac <rlc_AM_segment+0xec>
    d756:	66 90                	xchg   %ax,%ax
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(amBuffer->pktstatus != FULL_SDU && flag)
    d758:	84 c9                	test   %cl,%cl
    d75a:	74 08                	je     d764 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
    d75c:	83 ce 14             	or     $0x14,%esi
    d75f:	89 f1                	mov    %esi,%ecx
    d761:	88 4d f3             	mov    %cl,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    d764:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
    d768:	74 66                	je     d7d0 <rlc_AM_segment+0x110>
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d76a:	8b 4b 0c             	mov    0xc(%ebx),%ecx
    d76d:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
    d770:	8d 59 f4             	lea    -0xc(%ecx),%ebx
    d773:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    d776:	0f 84 a9 03 00 00    	je     db25 <rlc_AM_segment+0x465>
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d77c:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    d781:	83 c7 01             	add    $0x1,%edi
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d784:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d786:	8b 41 f4             	mov    -0xc(%ecx),%eax
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
			{

				size = size - amBuffer->pkt->len - 2;
    d789:	01 da                	add    %ebx,%edx
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d78b:	8b 5d dc             	mov    -0x24(%ebp),%ebx
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    d78e:	8b 40 50             	mov    0x50(%eax),%eax
    d791:	39 d0                	cmp    %edx,%eax
    d793:	0f 87 98 03 00 00    	ja     db31 <rlc_AM_segment+0x471>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    d799:	0f 84 e7 03 00 00    	je     db86 <rlc_AM_segment+0x4c6>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    d79f:	8d 48 02             	lea    0x2(%eax),%ecx
    d7a2:	39 d1                	cmp    %edx,%ecx
    d7a4:	0f 83 1b 04 00 00    	jae    dbc5 <rlc_AM_segment+0x505>
    d7aa:	31 c9                	xor    %ecx,%ecx
			{

				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
    d7ac:	66 01 45 ec          	add    %ax,-0x14(%ebp)
				if(amBuffer->pktstatus == FULL_SDU && flag)
    d7b0:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    d7b4:	75 a2                	jne    d758 <rlc_AM_segment+0x98>
    d7b6:	84 c9                	test   %cl,%cl
    d7b8:	74 aa                	je     d764 <rlc_AM_segment+0xa4>
				{
					fixhead->FIfirst=0;
    d7ba:	83 e6 ef             	and    $0xffffffef,%esi
					fixhead->E=1;
    d7bd:	83 ce 04             	or     $0x4,%esi
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d7c0:	66 39 7d e8          	cmp    %di,-0x18(%ebp)
				size = size - amBuffer->pkt->len - 2;
				length = length + amBuffer->pkt->len;
				if(amBuffer->pktstatus == FULL_SDU && flag)
				{
					fixhead->FIfirst=0;
					fixhead->E=1;
    d7c4:	89 f1                	mov    %esi,%ecx
    d7c6:	88 4d f3             	mov    %cl,-0xd(%ebp)
				{
					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    d7c9:	75 9f                	jne    d76a <rlc_AM_segment+0xaa>
    d7cb:	90                   	nop
    d7cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    d7d0:	66 89 7d da          	mov    %di,-0x26(%ebp)
    d7d4:	8b 7d e0             	mov    -0x20(%ebp),%edi
				{
					if((amIns->amSduBufferNum)==1)
					{
						fixhead->E=0;
    d7d7:	89 f0                	mov    %esi,%eax
    d7d9:	83 e0 fb             	and    $0xfffffffb,%eax
    d7dc:	83 7f 50 01          	cmpl   $0x1,0x50(%edi)
    d7e0:	0f 45 c6             	cmovne %esi,%eax
					}
					fixhead->FIsecond=0;
    d7e3:	83 e0 f7             	and    $0xfffffff7,%eax
    d7e6:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=amBuffer->pkt->len;
    d7e9:	8b 03                	mov    (%ebx),%eax
    d7eb:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    d7ef:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
	}
	size = sizeFromMac - 2;
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
    d7f3:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
    d7f7:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d7fb:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    d7ff:	8d 34 58             	lea    (%eax,%ebx,2),%esi
    d802:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
    d805:	0f b7 de             	movzwl %si,%ebx
    d808:	89 55 e0             	mov    %edx,-0x20(%ebp)
    d80b:	89 55 c8             	mov    %edx,-0x38(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    d80e:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    d812:	0f b7 d0             	movzwl %ax,%edx
    d815:	c1 e2 08             	shl    $0x8,%edx
    d818:	66 c1 e8 08          	shr    $0x8,%ax
    d81c:	09 d0                	or     %edx,%eax
	fsm_octets_print(fixhead,2);
    d81e:	ba 02 00 00 00       	mov    $0x2,%edx
    d823:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    d827:	8d 45 f2             	lea    -0xe(%ebp),%eax
    d82a:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d82d:	e8 fc ff ff ff       	call   d82e <rlc_AM_segment+0x16e>
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d832:	89 d8                	mov    %ebx,%eax
    d834:	e8 fc ff ff ff       	call   d835 <rlc_AM_segment+0x175>
	pos = head->next;
    d839:	8b 5f 44             	mov    0x44(%edi),%ebx
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d83c:	66 83 7d da 01       	cmpw   $0x1,-0x26(%ebp)
    d841:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
	fsm_octets_print(fixhead,2);
	length = length + 2*count;
	skb = fsm_pkt_create(length) ;
    d844:	89 45 e8             	mov    %eax,-0x18(%ebp)
	pos = head->next;
	tbuff = list_entry(pos,struct AmSduBuffer,list);
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
    d847:	0f 84 f1 03 00 00    	je     dc3e <rlc_AM_segment+0x57e>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			amIns->amSduBufferSize -= lastCopyLen;
			tbuff->pktstatus = LAST_SEGMENT;
		}		
	}
	else if(count > 1)
    d84d:	0f 86 79 01 00 00    	jbe    d9cc <rlc_AM_segment+0x30c>
	{
		fsm_skb_reserve(skb,2*count);		
    d853:	8b 55 e0             	mov    -0x20(%ebp),%edx
    d856:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d859:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
    d85c:	e8 fc ff ff ff       	call   d85d <rlc_AM_segment+0x19d>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d861:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    d864:	83 e9 01             	sub    $0x1,%ecx
    d867:	89 4d e0             	mov    %ecx,-0x20(%ebp)
    d86a:	01 c9                	add    %ecx,%ecx
    d86c:	89 c8                	mov    %ecx,%eax
    d86e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    d871:	e8 fc ff ff ff       	call   d872 <rlc_AM_segment+0x1b2>
    d876:	89 45 d0             	mov    %eax,-0x30(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    d879:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d87c:	e8 fc ff ff ff       	call   d87d <rlc_AM_segment+0x1bd>
    d881:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		i = 0;
		u8 *des = skb->data;
    d884:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d887:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    d88d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d890:	8b 47 44             	mov    0x44(%edi),%eax
    d893:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
    d896:	8b 30                	mov    (%eax),%esi
    d898:	8d 58 f4             	lea    -0xc(%eax),%ebx
    d89b:	0f 84 cf 00 00 00    	je     d970 <rlc_AM_segment+0x2b0>
    d8a1:	83 ee 0c             	sub    $0xc,%esi
	else if(count > 1)
	{
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
    d8a4:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    d8aa:	eb 20                	jmp    d8cc <rlc_AM_segment+0x20c>
    d8ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
			}
			else if(i==count-1)
    d8b0:	0f 84 fa 01 00 00    	je     dab0 <rlc_AM_segment+0x3f0>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d8b6:	8b 46 0c             	mov    0xc(%esi),%eax
    d8b9:	8d 56 0c             	lea    0xc(%esi),%edx
    d8bc:	83 e8 0c             	sub    $0xc,%eax
    d8bf:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d8c2:	0f 84 a8 00 00 00    	je     d970 <rlc_AM_segment+0x2b0>
    d8c8:	89 f3                	mov    %esi,%ebx
    d8ca:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    d8cc:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    d8d0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
    d8d3:	7e db                	jle    d8b0 <rlc_AM_segment+0x1f0>
			{
				*(LI+i) = amBuffer->pkt->len;
    d8d5:	8b 13                	mov    (%ebx),%edx
    d8d7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    d8da:	8b 52 50             	mov    0x50(%edx),%edx
    d8dd:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				*(headExt+i) = 0x8000|(*(LI+i));
    d8e1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    d8e4:	66 81 ca 00 80       	or     $0x8000,%dx
    d8e9:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
				fsm_skb_put(skb,amBuffer->pkt->len);
    d8ed:	8b 03                	mov    (%ebx),%eax
    d8ef:	8b 50 50             	mov    0x50(%eax),%edx
    d8f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d8f5:	e8 fc ff ff ff       	call   d8f6 <rlc_AM_segment+0x236>
				fsm_mem_cpy(des,amBuffer->pkt->data,amBuffer->pkt->len);
    d8fa:	8b 03                	mov    (%ebx),%eax
    d8fc:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    d902:	8b 48 50             	mov    0x50(%eax),%ecx
    d905:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d908:	e8 fc ff ff ff       	call   d909 <rlc_AM_segment+0x249>
				des = des + amBuffer->pkt->len ;
    d90d:	8b 03                	mov    (%ebx),%eax
    d90f:	8b 50 50             	mov    0x50(%eax),%edx
    d912:	01 55 dc             	add    %edx,-0x24(%ebp)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    d915:	8b 43 10             	mov    0x10(%ebx),%eax
    d918:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    d91b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    d91e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    d920:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    d927:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				list_del(&amBuffer->list);
				amIns->amSduBufferNum--;
    d92e:	83 6f 50 01          	subl   $0x1,0x50(%edi)
				amIns->amSduBufferSize -= amBuffer->pkt->len;
    d932:	8b 03                	mov    (%ebx),%eax
    d934:	8b 40 50             	mov    0x50(%eax),%eax
    d937:	29 47 4c             	sub    %eax,0x4c(%edi)

				if(amBuffer->pkt != NULL)
    d93a:	8b 03                	mov    (%ebx),%eax
    d93c:	85 c0                	test   %eax,%eax
    d93e:	74 0b                	je     d94b <rlc_AM_segment+0x28b>
				{
					fsm_pkt_destroy(amBuffer->pkt);
    d940:	e8 fc ff ff ff       	call   d941 <rlc_AM_segment+0x281>
					amBuffer->pkt = NULL;
    d945:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				}
				if(amBuffer != NULL)
    d94b:	85 db                	test   %ebx,%ebx
    d94d:	74 07                	je     d956 <rlc_AM_segment+0x296>
				{
					fsm_mem_free(amBuffer);
    d94f:	89 d8                	mov    %ebx,%eax
    d951:	e8 fc ff ff ff       	call   d952 <rlc_AM_segment+0x292>
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d956:	8b 46 0c             	mov    0xc(%esi),%eax
    d959:	8d 56 0c             	lea    0xc(%esi),%edx
				if(amBuffer != NULL)
				{
					fsm_mem_free(amBuffer);
					amBuffer = NULL;
				}				
				i++;
    d95c:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
		fsm_skb_reserve(skb,2*count);		
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		i = 0;
		u8 *des = skb->data;
		list_for_each_entry_safe(amBuffer,tempBuffer,head,list)
    d961:	83 e8 0c             	sub    $0xc,%eax
    d964:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
    d967:	0f 85 5b ff ff ff    	jne    d8c8 <rlc_AM_segment+0x208>
    d96d:	8d 76 00             	lea    0x0(%esi),%esi
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d970:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    d974:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d977:	8b 55 cc             	mov    -0x34(%ebp),%edx
					amBuffer->pktstatus = LAST_SEGMENT;
				}			   
				break;
			}
		}		
		*(headExt+count-2) = (*(headExt+count-2))&0x7fff;  //last Extent E = 0;
    d97a:	66 81 64 41 fc ff 7f 	andw   $0x7fff,-0x4(%ecx,%eax,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    d981:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d984:	e8 fc ff ff ff       	call   d985 <rlc_AM_segment+0x2c5>
    d989:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    d98c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    d98f:	e8 fc ff ff ff       	call   d990 <rlc_AM_segment+0x2d0>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    d994:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d997:	ba 02 00 00 00       	mov    $0x2,%edx
    d99c:	e8 fc ff ff ff       	call   d99d <rlc_AM_segment+0x2dd>
    d9a1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    d9a4:	b9 02 00 00 00       	mov    $0x2,%ecx
    d9a9:	e8 fc ff ff ff       	call   d9aa <rlc_AM_segment+0x2ea>
		if(LI != NULL)
    d9ae:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d9b1:	85 d2                	test   %edx,%edx
    d9b3:	74 08                	je     d9bd <rlc_AM_segment+0x2fd>
		{
			fsm_mem_free(LI);
    d9b5:	8b 45 d0             	mov    -0x30(%ebp),%eax
    d9b8:	e8 fc ff ff ff       	call   d9b9 <rlc_AM_segment+0x2f9>
			LI = NULL;
		}
		if(headExt != NULL)
    d9bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d9c0:	85 c0                	test   %eax,%eax
    d9c2:	74 08                	je     d9cc <rlc_AM_segment+0x30c>
		{
			fsm_mem_free(headExt);
    d9c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d9c7:	e8 fc ff ff ff       	call   d9c8 <rlc_AM_segment+0x308>
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d9cc:	b8 a4 00 00 00       	mov    $0xa4,%eax
    d9d1:	e8 fc ff ff ff       	call   d9d2 <rlc_AM_segment+0x312>
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d9d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
	//fsm_printf(5,"[RLC][AM_segment] the context of PDU is\n");
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
    d9d9:	89 c3                	mov    %eax,%ebx
	amBuf->pkt = fsm_pkt_create(skb->truesize);
    d9db:	8b 82 b0 00 00 00    	mov    0xb0(%edx),%eax
    d9e1:	e8 fc ff ff ff       	call   d9e2 <rlc_AM_segment+0x322>
    d9e6:	89 03                	mov    %eax,(%ebx)
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d9e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d9eb:	e8 fc ff ff ff       	call   d9ec <rlc_AM_segment+0x32c>
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
    d9f0:	8b 4d c8             	mov    -0x38(%ebp),%ecx
    d9f3:	89 4b 0c             	mov    %ecx,0xc(%ebx)
	//add pdu to trasmitted Buffer
	//skb_copy=skb;
	//fsm_octets_print(skb->data,10);
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
    d9f6:	89 03                	mov    %eax,(%ebx)
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    d9f8:	8b 40 50             	mov    0x50(%eax),%eax
	amBuf->segnum = 0;
    d9fb:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
    da02:	00 00 00 
	amBuf = (AmBuffer *)fsm_mem_alloc(sizeof(AmBuffer));
	amBuf->pkt = fsm_pkt_create(skb->truesize);
	amBuf->pkt = fsm_pkt_duplicate(skb);
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
    da05:	89 83 98 00 00 00    	mov    %eax,0x98(%ebx)
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    da0b:	31 c0                	xor    %eax,%eax
    da0d:	8d 76 00             	lea    0x0(%esi),%esi
	{
		amBuf->segStart[j] = -1;
    da10:	c7 44 83 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%eax,4)
    da17:	ff 
		amBuf->segEnd[j] = -1;
    da18:	c7 44 83 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%eax,4)
    da1f:	ff 
	//amBuf->pkt = skb_copy;
	amBuf->headLen = 2*count;
	amBuf->datalen = amBuf->pkt->len;
	amBuf->segnum = 0;
	int j;
	for( j = 0; j < segNumMax; j++ )
    da20:	83 c0 01             	add    $0x1,%eax
    da23:	83 f8 10             	cmp    $0x10,%eax
    da26:	75 e8                	jne    da10 <rlc_AM_segment+0x350>
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    da28:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    da2c:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
    da32:	66 c7 83 96 00 00 00 	movw   $0xffff,0x96(%ebx)
    da39:	ff ff 
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    da3b:	8d 8f f0 00 00 00    	lea    0xf0(%edi),%ecx
	for( j = 0; j < segNumMax; j++ )
	{
		amBuf->segStart[j] = -1;
		amBuf->segEnd[j] = -1;
	}
	amBuf->SN = amIns->SN;
    da41:	66 89 83 94 00 00 00 	mov    %ax,0x94(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    da48:	8b 87 f4 00 00 00    	mov    0xf4(%edi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
    da4e:	89 97 f4 00 00 00    	mov    %edx,0xf4(%edi)
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
    da54:	89 8b 9c 00 00 00    	mov    %ecx,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
    da5a:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
    da60:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
    da62:	8b 03                	mov    (%ebx),%eax
    da64:	8b 40 50             	mov    0x50(%eax),%eax
    da67:	01 87 f8 00 00 00    	add    %eax,0xf8(%edi)
	amIns->amTransmittedBufferNum++;
	amIns->SN++;
    da6d:	0f b7 47 2e          	movzwl 0x2e(%edi),%eax
	}
	amBuf->SN = amIns->SN;
	amBuf->retxCount = -1;
	list_add_tail(&amBuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferSize += amBuf->pkt->len;
	amIns->amTransmittedBufferNum++;
    da71:	83 87 fc 00 00 00 01 	addl   $0x1,0xfc(%edi)
	amIns->SN++;
    da78:	83 c0 01             	add    $0x1,%eax
	amIns->SN %= 1024;
    da7b:	89 c2                	mov    %eax,%edx
    da7d:	66 c1 fa 0f          	sar    $0xf,%dx
    da81:	66 c1 ea 06          	shr    $0x6,%dx
    da85:	01 d0                	add    %edx,%eax
    da87:	66 25 ff 03          	and    $0x3ff,%ax
    da8b:	66 29 d0             	sub    %dx,%ax
    da8e:	66 89 47 2e          	mov    %ax,0x2e(%edi)
	fsm_printf("[RLC][rlc_AM_segment] SN = %d\n",amIns->SN);
    da92:	98                   	cwtl   
    da93:	89 44 24 04          	mov    %eax,0x4(%esp)
    da97:	c7 04 24 7c 38 00 00 	movl   $0x387c,(%esp)
    da9e:	e8 fc ff ff ff       	call   da9f <rlc_AM_segment+0x3df>
	return skb;
}
    daa3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    daa6:	83 c4 38             	add    $0x38,%esp
    daa9:	5b                   	pop    %ebx
    daaa:	5e                   	pop    %esi
    daab:	5f                   	pop    %edi
    daac:	5d                   	pop    %ebp
    daad:	c3                   	ret    
    daae:	66 90                	xchg   %ax,%ax
				}				
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    dab0:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    dab4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dab7:	89 f2                	mov    %esi,%edx
    dab9:	e8 fc ff ff ff       	call   daba <rlc_AM_segment+0x3fa>
				fsm_mem_cpy(des,amBuffer->pkt->data,lastCopyLen);
    dabe:	8b 03                	mov    (%ebx),%eax
    dac0:	89 f1                	mov    %esi,%ecx
    dac2:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    dac8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dacb:	e8 fc ff ff ff       	call   dacc <rlc_AM_segment+0x40c>
				
				if(amBuffer->pkt->len == lastCopyLen)
    dad0:	8b 03                	mov    (%ebx),%eax
    dad2:	3b 70 50             	cmp    0x50(%eax),%esi
    dad5:	0f 85 fc 01 00 00    	jne    dcd7 <rlc_AM_segment+0x617>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    dadb:	8b 43 10             	mov    0x10(%ebx),%eax
    dade:	8b 53 0c             	mov    0xc(%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dae1:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dae4:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    dae6:	c7 43 0c 00 01 10 00 	movl   $0x100100,0xc(%ebx)
	entry->prev = LIST_POISON2;
    daed:	c7 43 10 00 02 20 00 	movl   $0x200200,0x10(%ebx)
				{
					list_del(&amBuffer->list);
					amIns->amSduBufferNum--;
    daf4:	83 6f 50 01          	subl   $0x1,0x50(%edi)
					amIns->amSduBufferSize -= amBuffer->pkt->len;
    daf8:	8b 03                	mov    (%ebx),%eax
    dafa:	8b 40 50             	mov    0x50(%eax),%eax
    dafd:	29 47 4c             	sub    %eax,0x4c(%edi)
					if(amBuffer->pkt != NULL)
    db00:	8b 03                	mov    (%ebx),%eax
    db02:	85 c0                	test   %eax,%eax
    db04:	74 0b                	je     db11 <rlc_AM_segment+0x451>
					{
						fsm_pkt_destroy(amBuffer->pkt);
    db06:	e8 fc ff ff ff       	call   db07 <rlc_AM_segment+0x447>
						amBuffer->pkt = NULL;
    db0b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					}
					if(amBuffer != NULL)
    db11:	85 db                	test   %ebx,%ebx
    db13:	0f 84 57 fe ff ff    	je     d970 <rlc_AM_segment+0x2b0>
					{
						fsm_mem_free(amBuffer);
    db19:	89 d8                	mov    %ebx,%eax
    db1b:	e8 fc ff ff ff       	call   db1c <rlc_AM_segment+0x45c>
    db20:	e9 4b fe ff ff       	jmp    d970 <rlc_AM_segment+0x2b0>
    db25:	66 89 7d da          	mov    %di,-0x26(%ebp)
    db29:	8b 7d e0             	mov    -0x20(%ebp),%edi
    db2c:	e9 c2 fc ff ff       	jmp    d7f3 <rlc_AM_segment+0x133>
    db31:	66 89 7d da          	mov    %di,-0x26(%ebp)
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    db35:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
    db39:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    db3d:	8b 7d e0             	mov    -0x20(%ebp),%edi
    db40:	01 c0                	add    %eax,%eax
    db42:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    db46:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    db49:	89 45 e0             	mov    %eax,-0x20(%ebp)
    db4c:	89 45 c8             	mov    %eax,-0x38(%ebp)
    db4f:	31 c0                	xor    %eax,%eax
			{
				if(amBuffer->pktstatus ==FULL_SDU)
    db51:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    db55:	0f 84 92 01 00 00    	je     dced <rlc_AM_segment+0x62d>
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    db5b:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    db5d:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=1;
					}
				}
				else
				{
					if(flag)
    db5f:	0f 84 8e 01 00 00    	je     dcf3 <rlc_AM_segment+0x633>
					{
						fixhead->FIfirst=1;
						fixhead->E=0;
    db65:	83 e0 e3             	and    $0xffffffe3,%eax
						fixhead->FIsecond=1;
    db68:	83 c8 18             	or     $0x18,%eax
    db6b:	88 45 f3             	mov    %al,-0xd(%ebp)
    db6e:	66 90                	xchg   %ax,%ax
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
				length = length + size;
    db70:	0f b7 75 e8          	movzwl -0x18(%ebp),%esi
    db74:	66 03 75 ec          	add    -0x14(%ebp),%si
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = size;
    db78:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    db7c:	01 d6                	add    %edx,%esi
    db7e:	0f b7 de             	movzwl %si,%ebx
				length = length + size;
				break;
    db81:	e9 88 fc ff ff       	jmp    d80e <rlc_AM_segment+0x14e>
    db86:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    db8a:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    db8e:	8b 7d e0             	mov    -0x20(%ebp),%edi
    db91:	01 c9                	add    %ecx,%ecx
    db93:	66 89 4d e8          	mov    %cx,-0x18(%ebp)
    db97:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    db9b:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    db9e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    dba1:	89 45 c8             	mov    %eax,-0x38(%ebp)
    dba4:	31 c0                	xor    %eax,%eax
			{

				if(amBuffer->pktstatus == FULL_SDU)
    dba6:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dbaa:	0f 84 88 01 00 00    	je     dd38 <rlc_AM_segment+0x678>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dbb0:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    dbb2:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dbb4:	0f 84 44 01 00 00    	je     dcfe <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=1;
    dbba:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbbd:	83 e0 f3             	and    $0xfffffff3,%eax
    dbc0:	88 45 f3             	mov    %al,-0xd(%ebp)
    dbc3:	eb ab                	jmp    db70 <rlc_AM_segment+0x4b0>
    dbc5:	66 89 7d da          	mov    %di,-0x26(%ebp)
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    dbc9:	0f b7 4d da          	movzwl -0x26(%ebp),%ecx
    dbcd:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
    dbd1:	8b 7d e0             	mov    -0x20(%ebp),%edi
    dbd4:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
    dbd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
    dbda:	01 d2                	add    %edx,%edx
    dbdc:	89 45 c8             	mov    %eax,-0x38(%ebp)
    dbdf:	31 c0                	xor    %eax,%eax
					break;
				}				
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
    dbe1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    dbe5:	0f 84 5e 01 00 00    	je     dd49 <rlc_AM_segment+0x689>
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dbeb:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=1;
    dbed:	89 f0                	mov    %esi,%eax
						fixhead->FIsecond=0;
					}
				}
				else
				{
					if(flag)
    dbef:	0f 84 14 01 00 00    	je     dd09 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=1;
    dbf5:	83 c8 10             	or     $0x10,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    dbf8:	83 e0 f3             	and    $0xfffffff3,%eax
    dbfb:	88 45 f3             	mov    %al,-0xd(%ebp)
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dbfe:	8b 03                	mov    (%ebx),%eax
				length = length + amBuffer->pkt->len;
    dc00:	0f b7 75 ec          	movzwl -0x14(%ebp),%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dc04:	0f b7 40 50          	movzwl 0x50(%eax),%eax
				length = length + amBuffer->pkt->len;
    dc08:	01 d6                	add    %edx,%esi
					else
					{
						fixhead->FIsecond=0;
					}
				}
				lastCopyLen = amBuffer->pkt->len ;
    dc0a:	01 c6                	add    %eax,%esi
    dc0c:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
    dc10:	0f b7 de             	movzwl %si,%ebx
				length = length + amBuffer->pkt->len;
				break;
    dc13:	e9 f6 fb ff ff       	jmp    d80e <rlc_AM_segment+0x14e>
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dc18:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    dc1c:	31 c9                	xor    %ecx,%ecx
    dc1e:	31 db                	xor    %ebx,%ebx
    dc20:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
    dc27:	31 f6                	xor    %esi,%esi
    dc29:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dc30:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%ebp)
				length = length + amBuffer->pkt->len;
				break;
			}
		}
	}
	*(u16*)fixhead=htons(*(u16*)fixhead);
    dc36:	0f b7 d0             	movzwl %ax,%edx
    dc39:	e9 d7 fb ff ff       	jmp    d815 <rlc_AM_segment+0x155>
	
	//struct AmBuffer *amBf = (struct AmBuffer*)fsm_mem_alloc(count*sizeof(struct AmBuffer));
	//int j = 0;
	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    dc3e:	0f b7 d6             	movzwl %si,%edx
    dc41:	e8 fc ff ff ff       	call   dc42 <rlc_AM_segment+0x582>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    dc46:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dc49:	0f b7 75 d8          	movzwl -0x28(%ebp),%esi
    dc4d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    dc53:	89 f2                	mov    %esi,%edx
    dc55:	89 45 ec             	mov    %eax,-0x14(%ebp)
    dc58:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dc5b:	e8 fc ff ff ff       	call   dc5c <rlc_AM_segment+0x59c>
    dc60:	8b 55 ec             	mov    -0x14(%ebp),%edx
    dc63:	89 f1                	mov    %esi,%ecx
    dc65:	e8 fc ff ff ff       	call   dc66 <rlc_AM_segment+0x5a6>
		fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    dc6a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dc6d:	ba 02 00 00 00       	mov    $0x2,%edx
    dc72:	e8 fc ff ff ff       	call   dc73 <rlc_AM_segment+0x5b3>
    dc77:	b9 02 00 00 00       	mov    $0x2,%ecx
    dc7c:	8d 55 f2             	lea    -0xe(%ebp),%edx
    dc7f:	e8 fc ff ff ff       	call   dc80 <rlc_AM_segment+0x5c0>
		
		if(lastCopyLen == tbuff->pkt->len)
    dc84:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dc87:	3b 70 50             	cmp    0x50(%eax),%esi
    dc8a:	0f 85 84 00 00 00    	jne    dd14 <rlc_AM_segment+0x654>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    dc90:	8b 43 04             	mov    0x4(%ebx),%eax
    dc93:	8b 13                	mov    (%ebx),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    dc95:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    dc98:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    dc9a:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
	entry->prev = LIST_POISON2;
    dca0:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
		{
			list_del(&tbuff->list);
			amIns->amSduBufferNum--;
    dca7:	83 6f 50 01          	subl   $0x1,0x50(%edi)
			amIns->amSduBufferSize -= tbuff->pkt->len;
    dcab:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dcae:	8b 40 50             	mov    0x50(%eax),%eax
    dcb1:	29 47 4c             	sub    %eax,0x4c(%edi)
			if(tbuff->pkt != NULL)
    dcb4:	8b 43 f4             	mov    -0xc(%ebx),%eax
    dcb7:	85 c0                	test   %eax,%eax
    dcb9:	74 0c                	je     dcc7 <rlc_AM_segment+0x607>
			{
				fsm_pkt_destroy(tbuff->pkt);
    dcbb:	e8 fc ff ff ff       	call   dcbc <rlc_AM_segment+0x5fc>
				tbuff->pkt = NULL;
    dcc0:	c7 43 f4 00 00 00 00 	movl   $0x0,-0xc(%ebx)
			}
			if(tbuff != NULL)
    dcc7:	89 d8                	mov    %ebx,%eax
    dcc9:	83 e8 0c             	sub    $0xc,%eax
    dccc:	0f 85 f5 fc ff ff    	jne    d9c7 <rlc_AM_segment+0x307>
    dcd2:	e9 f5 fc ff ff       	jmp    d9cc <rlc_AM_segment+0x30c>
						amBuffer = NULL;
					}				
				}
				else
				{
					fsm_skb_pull(amBuffer->pkt,lastCopyLen);
    dcd7:	89 f2                	mov    %esi,%edx
    dcd9:	e8 fc ff ff ff       	call   dcda <rlc_AM_segment+0x61a>
					amIns->amSduBufferSize -= lastCopyLen;
    dcde:	29 77 4c             	sub    %esi,0x4c(%edi)
					amBuffer->pktstatus = LAST_SEGMENT;
    dce1:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    dce8:	e9 83 fc ff ff       	jmp    d970 <rlc_AM_segment+0x2b0>
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    dced:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    dcef:	89 f0                	mov    %esi,%eax
			num = num -1;
			if(size < amBuffer->pkt->len)
			{
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    dcf1:	75 37                	jne    dd2a <rlc_AM_segment+0x66a>
						fixhead->FIsecond=1;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=1;
    dcf3:	83 c8 08             	or     $0x8,%eax
    dcf6:	88 45 f3             	mov    %al,-0xd(%ebp)
    dcf9:	e9 72 fe ff ff       	jmp    db70 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    dcfe:	83 e0 f7             	and    $0xfffffff7,%eax
    dd01:	88 45 f3             	mov    %al,-0xd(%ebp)
    dd04:	e9 67 fe ff ff       	jmp    db70 <rlc_AM_segment+0x4b0>
						fixhead->FIsecond=0;
						flag=false;
					}
					else
					{
						fixhead->FIsecond=0;
    dd09:	83 e0 f7             	and    $0xfffffff7,%eax
    dd0c:	88 45 f3             	mov    %al,-0xd(%ebp)
    dd0f:	e9 ea fe ff ff       	jmp    dbfe <rlc_AM_segment+0x53e>
				tbuff = NULL;
			}		
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    dd14:	89 f2                	mov    %esi,%edx
    dd16:	e8 fc ff ff ff       	call   dd17 <rlc_AM_segment+0x657>
			amIns->amSduBufferSize -= lastCopyLen;
    dd1b:	29 77 4c             	sub    %esi,0x4c(%edi)
			tbuff->pktstatus = LAST_SEGMENT;
    dd1e:	c7 43 f8 02 00 00 00 	movl   $0x2,-0x8(%ebx)
    dd25:	e9 a2 fc ff ff       	jmp    d9cc <rlc_AM_segment+0x30c>
				if(amBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
    dd2a:	83 e0 eb             	and    $0xffffffeb,%eax
						fixhead->FIsecond=1;
    dd2d:	83 c8 08             	or     $0x8,%eax
    dd30:	88 45 f3             	mov    %al,-0xd(%ebp)
    dd33:	e9 38 fe ff ff       	jmp    db70 <rlc_AM_segment+0x4b0>
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dd38:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dd3a:	89 f0                	mov    %esi,%eax
			else if(size == amBuffer->pkt->len) 
			{

				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dd3c:	74 c0                	je     dcfe <rlc_AM_segment+0x63e>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dd3e:	83 e0 e3             	and    $0xffffffe3,%eax
    dd41:	88 45 f3             	mov    %al,-0xd(%ebp)
    dd44:	e9 27 fe ff ff       	jmp    db70 <rlc_AM_segment+0x4b0>
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dd49:	84 c0                	test   %al,%al
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dd4b:	89 f0                	mov    %esi,%eax
			}
			else							 
			{			
				if(amBuffer->pktstatus == FULL_SDU)
				{
					if(flag)
    dd4d:	74 ba                	je     dd09 <rlc_AM_segment+0x649>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    dd4f:	83 e0 e3             	and    $0xffffffe3,%eax
    dd52:	88 45 f3             	mov    %al,-0xd(%ebp)
    dd55:	e9 a4 fe ff ff       	jmp    dbfe <rlc_AM_segment+0x53e>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    dd5a:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dd61:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dd66:	b8 01 00 00 00       	mov    $0x1,%eax
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size == amBuffer->pkt->len) 
    dd6b:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    dd72:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dd78:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dd7e:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dd84:	e9 1d fe ff ff       	jmp    dba6 <rlc_AM_segment+0x4e6>
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dd89:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    dd90:	b9 01 00 00 00       	mov    $0x1,%ecx
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    dd95:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
			num = num -1;
			if(size < amBuffer->pkt->len)
    dd9a:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
    dda1:	66 c7 45 e8 02 00    	movw   $0x2,-0x18(%ebp)
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    dda7:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    ddad:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    ddb3:	e9 99 fd ff ff       	jmp    db51 <rlc_AM_segment+0x491>
				}
				lastCopyLen = size;
				length = length + size;
				break;
			}
			else if(size > (amBuffer->pkt->len + 2))
    ddb8:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
    ddbf:	b9 01 00 00 00       	mov    $0x1,%ecx
    ddc4:	ba 02 00 00 00       	mov    $0x2,%edx
    ddc9:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
	u32 size;
	u16 num = amIns->amSduBufferNum;
	bool flag=true;
    ddd0:	b8 01 00 00 00       	mov    $0x1,%eax
	//fsm_printf(5,"[RLC] entring rlc_AM_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(amBuffer,head,list)
		{
			count = count + 1;
    ddd5:	66 c7 45 da 01 00    	movw   $0x1,-0x26(%ebp)
**------------------------------------------------------------------------------------------
*******************************************************************************************/
FSM_PKT * rlc_AM_segment(struct AM_Instance *amIns,u32 sizeFromMac)
{

	u16 lastCopyLen,i=0,count = 0,length = 0;
    dddb:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    dde1:	e9 fb fd ff ff       	jmp    dbe1 <rlc_AM_segment+0x521>
	fixhead->P=1;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 2)
	{
		printk("[RLC][rlc_AM_segment] size <= 2\n");
    dde6:	c7 04 24 58 38 00 00 	movl   $0x3858,(%esp)
    dded:	e8 fc ff ff ff       	call   ddee <rlc_AM_segment+0x72e>
		return NULL;
    ddf2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ddf9:	e9 a5 fc ff ff       	jmp    daa3 <rlc_AM_segment+0x3e3>
    ddfe:	66 90                	xchg   %ax,%ax

0000de00 <rlc_UM_segment>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    de00:	55                   	push   %ebp
    de01:	89 e5                	mov    %esp,%ebp
    de03:	57                   	push   %edi
    de04:	56                   	push   %esi
    de05:	53                   	push   %ebx
    de06:	83 ec 34             	sub    $0x34,%esp
    de09:	e8 fc ff ff ff       	call   de0a <rlc_UM_segment+0xa>
    de0e:	89 d3                	mov    %edx,%ebx
		u32 size;
		int num = umIns->umSduBufferNum;
    de10:	8b 50 24             	mov    0x24(%eax),%edx
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    de13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		u32 size;
		int num = umIns->umSduBufferNum;
    de16:	89 55 e8             	mov    %edx,-0x18(%ebp)
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    de19:	0f b7 50 28          	movzwl 0x28(%eax),%edx
    de1d:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    de21:	c7 04 24 ba 07 00 00 	movl   $0x7ba,(%esp)
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
		struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
		struct RLC_UM_size10_subhead *fixhead, umhead;
		fixhead=&umhead;
		fixhead->SN=umIns->SN;
    de28:	66 81 e2 ff 03       	and    $0x3ff,%dx
    de2d:	66 25 00 fc          	and    $0xfc00,%ax
    de31:	09 d0                	or     %edx,%eax
    de33:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
		fixhead->R11=0;
    de37:	66 c1 e8 08          	shr    $0x8,%ax
		fixhead->R12=0;
		fixhead->R13=0;
    de3b:	83 e0 1f             	and    $0x1f,%eax
    de3e:	88 45 f3             	mov    %al,-0xd(%ebp)
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
    de41:	e8 fc ff ff ff       	call   de42 <rlc_UM_segment+0x42>
		if(sizeFromMac <= 2)
    de46:	83 fb 02             	cmp    $0x2,%ebx
    de49:	0f 86 7e 05 00 00    	jbe    e3cd <rlc_UM_segment+0x5cd>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    de4f:	8b 75 e4             	mov    -0x1c(%ebp),%esi

FSM_PKT * rlc_UM_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
		u32 size;
		int num = umIns->umSduBufferNum;
		struct list_head *head =&(umIns->umSduBuffer.list);
    de52:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    de55:	8b 46 18             	mov    0x18(%esi),%eax
    de58:	83 c1 18             	add    $0x18,%ecx
    de5b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
    de5e:	39 c1                	cmp    %eax,%ecx
    de60:	0f 84 82 03 00 00    	je     e1e8 <rlc_UM_segment+0x3e8>
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
			return NULL;
		}
		size = sizeFromMac - 2;
    de66:	8d 53 fe             	lea    -0x2(%ebx),%edx
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    de69:	8d 58 f0             	lea    -0x10(%eax),%ebx
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    de6c:	8b 40 f0             	mov    -0x10(%eax),%eax
    de6f:	8b 40 50             	mov    0x50(%eax),%eax
    de72:	39 c2                	cmp    %eax,%edx
    de74:	0f 82 11 05 00 00    	jb     e38b <rlc_UM_segment+0x58b>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    de7a:	0f 84 21 05 00 00    	je     e3a1 <rlc_UM_segment+0x5a1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    de80:	8d 48 02             	lea    0x2(%eax),%ecx
    de83:	39 ca                	cmp    %ecx,%edx
    de85:	0f 86 2c 05 00 00    	jbe    e3b7 <rlc_UM_segment+0x5b7>
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    de8b:	31 f6                	xor    %esi,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    de8d:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    de92:	b9 01 00 00 00       	mov    $0x1,%ecx
    de97:	66 89 75 e0          	mov    %si,-0x20(%ebp)
    de9b:	eb 4c                	jmp    dee9 <rlc_UM_segment+0xe9>
    de9d:	8d 76 00             	lea    0x0(%esi),%esi
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
						flag=false;
					}
					else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    dea0:	84 c9                	test   %cl,%cl
    dea2:	74 04                	je     dea8 <rlc_UM_segment+0xa8>
					{
	
						fixhead->FIfirst=1;
						fixhead->E=1;
    dea4:	80 4d f3 14          	orb    $0x14,-0xd(%ebp)
						flag=false;
					}
					if(num == 0)
    dea8:	39 7d e8             	cmp    %edi,-0x18(%ebp)
    deab:	74 63                	je     df10 <rlc_UM_segment+0x110>
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    dead:	8b 4b 10             	mov    0x10(%ebx),%ecx
    deb0:	39 4d ec             	cmp    %ecx,-0x14(%ebp)
    deb3:	8d 59 f0             	lea    -0x10(%ecx),%ebx
    deb6:	0f 84 b4 02 00 00    	je     e170 <rlc_UM_segment+0x370>
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    debc:	be fe ff ff ff       	mov    $0xfffffffe,%esi
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    dec1:	83 c7 01             	add    $0x1,%edi
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dec4:	29 c6                	sub    %eax,%esi
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    dec6:	8b 41 f0             	mov    -0x10(%ecx),%eax
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
				{
	
					size = size - umBuffer->pkt->len - 2;
    dec9:	01 f2                	add    %esi,%edx
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    decb:	8b 40 50             	mov    0x50(%eax),%eax
    dece:	39 d0                	cmp    %edx,%eax
    ded0:	0f 87 aa 02 00 00    	ja     e180 <rlc_UM_segment+0x380>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    ded6:	0f 84 dc 02 00 00    	je     e1b8 <rlc_UM_segment+0x3b8>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    dedc:	8d 48 02             	lea    0x2(%eax),%ecx
    dedf:	39 d1                	cmp    %edx,%ecx
    dee1:	0f 83 19 03 00 00    	jae    e200 <rlc_UM_segment+0x400>
    dee7:	31 c9                	xor    %ecx,%ecx
				{
	
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
    dee9:	66 01 45 e0          	add    %ax,-0x20(%ebp)
					if(umBuffer->pktstatus==FULL_SDU &&flag)
    deed:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    def1:	75 ad                	jne    dea0 <rlc_UM_segment+0xa0>
    def3:	84 c9                	test   %cl,%cl
    def5:	74 b1                	je     dea8 <rlc_UM_segment+0xa8>
					{	
						fixhead->FIfirst=0;
    def7:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    defb:	83 e1 ef             	and    $0xffffffef,%ecx
						fixhead->E=1;
    defe:	83 c9 04             	or     $0x4,%ecx
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    df01:	39 7d e8             	cmp    %edi,-0x18(%ebp)
					size = size - umBuffer->pkt->len - 2;
					length += umBuffer->pkt->len;
					if(umBuffer->pktstatus==FULL_SDU &&flag)
					{	
						fixhead->FIfirst=0;
						fixhead->E=1;
    df04:	88 4d f3             	mov    %cl,-0xd(%ebp)
	
						fixhead->FIfirst=1;
						fixhead->E=1;
						flag=false;
					}
					if(num == 0)
    df07:	75 a4                	jne    dead <rlc_UM_segment+0xad>
    df09:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    df10:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    df14:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    df17:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
    df1b:	89 d0                	mov    %edx,%eax
    df1d:	83 e0 fb             	and    $0xfffffffb,%eax
    df20:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
						fixhead->FIsecond=0;
						lastCopyLen = umBuffer->pkt->len;
    df24:	8d 34 7e             	lea    (%esi,%edi,2),%esi
						flag=false;
					}
					if(num == 0)
					{
						if((umIns->umSduBufferNum) == 1)
							fixhead->E=0;
    df27:	0f 45 c2             	cmovne %edx,%eax
						fixhead->FIsecond=0;
    df2a:	83 e0 f7             	and    $0xfffffff7,%eax
    df2d:	88 45 f3             	mov    %al,-0xd(%ebp)
						lastCopyLen = umBuffer->pkt->len;
    df30:	8b 03                	mov    (%ebx),%eax
    df32:	0f b7 de             	movzwl %si,%ebx
    df35:	8b 40 50             	mov    0x50(%eax),%eax
    df38:	89 45 d0             	mov    %eax,-0x30(%ebp)
    df3b:	90                   	nop
    df3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    df40:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    df44:	0f b7 d0             	movzwl %ax,%edx
    df47:	c1 e2 08             	shl    $0x8,%edx
    df4a:	66 c1 e8 08          	shr    $0x8,%ax
    df4e:	09 d0                	or     %edx,%eax
		fsm_octets_print(fixhead,2);
    df50:	ba 02 00 00 00       	mov    $0x2,%edx
    df55:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
    df59:	8d 45 f2             	lea    -0xe(%ebp),%eax
    df5c:	e8 fc ff ff ff       	call   df5d <rlc_UM_segment+0x15d>
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    df61:	89 d8                	mov    %ebx,%eax
    df63:	e8 fc ff ff ff       	call   df64 <rlc_UM_segment+0x164>
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    df68:	83 ff 01             	cmp    $0x1,%edi
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
    df6b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		pos = head->next;
    df6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    df71:	8b 58 18             	mov    0x18(%eax),%ebx
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
    df74:	0f 84 c2 02 00 00    	je     e23c <rlc_UM_segment+0x43c>
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
				umIns->umSduBufferSize -= lastCopyLen;
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
    df7a:	0f 8e 59 01 00 00    	jle    e0d9 <rlc_UM_segment+0x2d9>
		{
			fsm_skb_reserve(skb,2*count);
    df80:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df83:	8d 14 3f             	lea    (%edi,%edi,1),%edx
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    df86:	8d 77 ff             	lea    -0x1(%edi),%esi
				tbuff->pktstatus = LAST_SEGMENT;
			}
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
    df89:	e8 fc ff ff ff       	call   df8a <rlc_UM_segment+0x18a>
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    df8e:	89 75 e8             	mov    %esi,-0x18(%ebp)
    df91:	01 f6                	add    %esi,%esi
    df93:	89 f0                	mov    %esi,%eax
    df95:	89 75 cc             	mov    %esi,-0x34(%ebp)
    df98:	e8 fc ff ff ff       	call   df99 <rlc_UM_segment+0x199>
    df9d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    dfa0:	89 f0                	mov    %esi,%eax
    dfa2:	e8 fc ff ff ff       	call   dfa3 <rlc_UM_segment+0x1a3>
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    dfa7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		}
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    dfaa:	89 45 d8             	mov    %eax,-0x28(%ebp)
			int i = 0;
			unsigned char *des = skb->data;
    dfad:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dfb0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    dfb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    dfb9:	8b 42 18             	mov    0x18(%edx),%eax
    dfbc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    dfbf:	8b 30                	mov    (%eax),%esi
    dfc1:	8d 58 f0             	lea    -0x10(%eax),%ebx
    dfc4:	0f 84 c5 00 00 00    	je     e08f <rlc_UM_segment+0x28f>
		else if(count > 1)
		{
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
    dfca:	31 c0                	xor    %eax,%eax
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    dfcc:	83 ee 10             	sub    $0x10,%esi
    dfcf:	89 7d c8             	mov    %edi,-0x38(%ebp)
    dfd2:	89 c7                	mov    %eax,%edi
    dfd4:	eb 1e                	jmp    dff4 <rlc_UM_segment+0x1f4>
    dfd6:	66 90                	xchg   %ax,%ax
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
    dfd8:	0f 84 42 01 00 00    	je     e120 <rlc_UM_segment+0x320>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    dfde:	8b 46 10             	mov    0x10(%esi),%eax
    dfe1:	8d 56 10             	lea    0x10(%esi),%edx
    dfe4:	83 e8 10             	sub    $0x10,%eax
    dfe7:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    dfea:	0f 84 9c 00 00 00    	je     e08c <rlc_UM_segment+0x28c>
    dff0:	89 f3                	mov    %esi,%ebx
    dff2:	89 c6                	mov    %eax,%esi
			{
				if(i<count-1)
    dff4:	3b 7d e8             	cmp    -0x18(%ebp),%edi
    dff7:	7d df                	jge    dfd8 <rlc_UM_segment+0x1d8>
				{
					*(LI+i) = umBuffer->pkt->len;
    dff9:	8b 03                	mov    (%ebx),%eax
    dffb:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
					*(headExt+i) = 0x8000|(*(LI+i));
    dffe:	8b 55 d8             	mov    -0x28(%ebp),%edx
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
    e001:	8b 40 50             	mov    0x50(%eax),%eax
    e004:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
					*(headExt+i) = 0x8000|(*(LI+i));
    e008:	66 0d 00 80          	or     $0x8000,%ax
    e00c:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
					fsm_skb_put(skb,umBuffer->pkt->len);
    e010:	8b 03                	mov    (%ebx),%eax
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
					umBuffer = NULL;
					i++;
    e012:	83 c7 01             	add    $0x1,%edi
			{
				if(i<count-1)
				{
					*(LI+i) = umBuffer->pkt->len;
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
    e015:	8b 50 50             	mov    0x50(%eax),%edx
    e018:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e01b:	e8 fc ff ff ff       	call   e01c <rlc_UM_segment+0x21c>
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e020:	8b 03                	mov    (%ebx),%eax
    e022:	8b 48 50             	mov    0x50(%eax),%ecx
    e025:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e02b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e02e:	e8 fc ff ff ff       	call   e02f <rlc_UM_segment+0x22f>
					des = des + umBuffer->pkt->len ;
    e033:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e035:	8b 53 10             	mov    0x10(%ebx),%edx
    e038:	8b 48 50             	mov    0x50(%eax),%ecx
    e03b:	8b 43 14             	mov    0x14(%ebx),%eax
    e03e:	01 4d e0             	add    %ecx,-0x20(%ebp)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e041:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e044:	89 10                	mov    %edx,(%eax)
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e046:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e049:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    e050:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e053:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					*(headExt+i) = 0x8000|(*(LI+i));
					fsm_skb_put(skb,umBuffer->pkt->len);
					fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e05a:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= umBuffer->pkt->len;
    e05e:	8b 03                	mov    (%ebx),%eax
    e060:	8b 40 50             	mov    0x50(%eax),%eax
    e063:	29 42 20             	sub    %eax,0x20(%edx)
					fsm_pkt_destroy(umBuffer->pkt);
    e066:	8b 03                	mov    (%ebx),%eax
    e068:	e8 fc ff ff ff       	call   e069 <rlc_UM_segment+0x269>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer);
    e06d:	89 d8                	mov    %ebx,%eax
					des = des + umBuffer->pkt->len ;
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= umBuffer->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    e06f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer);
    e075:	e8 fc ff ff ff       	call   e076 <rlc_UM_segment+0x276>
			fsm_skb_reserve(skb,2*count);
			u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
			int i = 0;
			unsigned char *des = skb->data;
			list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e07a:	8b 46 10             	mov    0x10(%esi),%eax
    e07d:	8d 56 10             	lea    0x10(%esi),%edx
    e080:	83 e8 10             	sub    $0x10,%eax
    e083:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    e086:	0f 85 64 ff ff ff    	jne    dff0 <rlc_UM_segment+0x1f0>
    e08c:	8b 7d c8             	mov    -0x38(%ebp),%edi
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e08f:	8b 45 d8             	mov    -0x28(%ebp),%eax
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e092:	8b 55 cc             	mov    -0x34(%ebp),%edx
						umIns->umSduBufferSize -= lastCopyLen;
					}
					break;
				}
			}
			*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e095:	66 81 64 78 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%edi,2)
			fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e09c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e09f:	e8 fc ff ff ff       	call   e0a0 <rlc_UM_segment+0x2a0>
    e0a4:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    e0a7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e0aa:	e8 fc ff ff ff       	call   e0ab <rlc_UM_segment+0x2ab>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e0af:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e0b2:	ba 02 00 00 00       	mov    $0x2,%edx
    e0b7:	e8 fc ff ff ff       	call   e0b8 <rlc_UM_segment+0x2b8>
    e0bc:	b9 02 00 00 00       	mov    $0x2,%ecx
    e0c1:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e0c4:	e8 fc ff ff ff       	call   e0c5 <rlc_UM_segment+0x2c5>
			fsm_mem_free(LI);
    e0c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e0cc:	e8 fc ff ff ff       	call   e0cd <rlc_UM_segment+0x2cd>
			fsm_mem_free(headExt);
    e0d1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e0d4:	e8 fc ff ff ff       	call   e0d5 <rlc_UM_segment+0x2d5>
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    e0d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		umIns->SN %= 1024;
    e0dc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
			fsm_mem_free(headExt);
			LI = NULL;
			headExt = NULL;
		}
		//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count));
		umIns->SN++;
    e0df:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e0e3:	83 c0 01             	add    $0x1,%eax
		umIns->SN %= 1024;
    e0e6:	89 c2                	mov    %eax,%edx
    e0e8:	66 c1 fa 0f          	sar    $0xf,%dx
    e0ec:	66 c1 ea 06          	shr    $0x6,%dx
    e0f0:	01 d0                	add    %edx,%eax
    e0f2:	66 25 ff 03          	and    $0x3ff,%ax
    e0f6:	66 29 d0             	sub    %dx,%ax
    e0f9:	66 89 41 28          	mov    %ax,0x28(%ecx)
		fsm_printf("[RLC][rlc_UM_segment] SN = %d\n",umIns->SN);
    e0fd:	98                   	cwtl   
    e0fe:	89 44 24 04          	mov    %eax,0x4(%esp)
    e102:	c7 04 24 c0 38 00 00 	movl   $0x38c0,(%esp)
    e109:	e8 fc ff ff ff       	call   e10a <rlc_UM_segment+0x30a>
		return skb;

}
    e10e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e111:	83 c4 34             	add    $0x34,%esp
    e114:	5b                   	pop    %ebx
    e115:	5e                   	pop    %esi
    e116:	5f                   	pop    %edi
    e117:	5d                   	pop    %ebp
    e118:	c3                   	ret    
    e119:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					umBuffer = NULL;
					i++;
				}
				else if(i==count-1)
				{
					fsm_skb_put(skb,lastCopyLen);
    e120:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e123:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e126:	8b 7d c8             	mov    -0x38(%ebp),%edi
    e129:	e8 fc ff ff ff       	call   e12a <rlc_UM_segment+0x32a>
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e12e:	8b 03                	mov    (%ebx),%eax
    e130:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e133:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e139:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e13c:	e8 fc ff ff ff       	call   e13d <rlc_UM_segment+0x33d>
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e141:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e144:	8b 03                	mov    (%ebx),%eax
    e146:	e8 fc ff ff ff       	call   e147 <rlc_UM_segment+0x347>
					if(umBuffer->pkt->len == lastCopyLen)
    e14b:	8b 03                	mov    (%ebx),%eax
    e14d:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e150:	39 70 50             	cmp    %esi,0x50(%eax)
    e153:	0f 84 ee 01 00 00    	je     e347 <rlc_UM_segment+0x547>
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
						umIns->umSduBufferSize -= lastCopyLen;
    e159:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e15c:	8b 75 d0             	mov    -0x30(%ebp),%esi
						fsm_mem_free(umBuffer);
						umBuffer = NULL;
					}
					else
					{
						umBuffer->pktstatus = LAST_SEGMENT;
    e15f:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
						umIns->umSduBufferSize -= lastCopyLen;
    e166:	29 70 20             	sub    %esi,0x20(%eax)
    e169:	e9 21 ff ff ff       	jmp    e08f <rlc_UM_segment+0x28f>
    e16e:	66 90                	xchg   %ax,%ax
    e170:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			return NULL;
		}
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
    e174:	8d 34 7e             	lea    (%esi,%edi,2),%esi
    e177:	0f b7 de             	movzwl %si,%ebx
    e17a:	e9 c1 fd ff ff       	jmp    df40 <rlc_UM_segment+0x140>
    e17f:	90                   	nop
    e180:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e184:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e187:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e189:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e18d:	0f 84 3e 01 00 00    	je     e2d1 <rlc_UM_segment+0x4d1>
							fixhead->FIsecond=1;
						}
					}
					else
					{
						if(flag)
    e193:	84 c0                	test   %al,%al
    e195:	0f 84 0d 01 00 00    	je     e2a8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=1;
    e19b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e19f:	83 e0 e3             	and    $0xffffffe3,%eax
							fixhead->FIsecond=1;
    e1a2:	83 c8 18             	or     $0x18,%eax
    e1a5:	88 45 f3             	mov    %al,-0xd(%ebp)
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = size;
					length += size;
    e1a8:	01 ce                	add    %ecx,%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e1aa:	01 d6                	add    %edx,%esi
    e1ac:	0f b7 de             	movzwl %si,%ebx
						}
					}
					lastCopyLen = size;
					length += size;
					break;
    e1af:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e1b2:	e9 89 fd ff ff       	jmp    df40 <rlc_UM_segment+0x140>
    e1b7:	90                   	nop
    e1b8:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e1bc:	8d 0c 3f             	lea    (%edi,%edi,1),%ecx
    e1bf:	31 c0                	xor    %eax,%eax
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e1c1:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e1c5:	0f 84 1c 01 00 00    	je     e2e7 <rlc_UM_segment+0x4e7>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e1cb:	84 c0                	test   %al,%al
    e1cd:	0f 84 e5 00 00 00    	je     e2b8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=1;
    e1d3:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e1d7:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e1da:	83 e0 f3             	and    $0xfffffff3,%eax
    e1dd:	88 45 f3             	mov    %al,-0xd(%ebp)
    e1e0:	eb c6                	jmp    e1a8 <rlc_UM_segment+0x3a8>
    e1e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e1e8:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
    e1ec:	31 db                	xor    %ebx,%ebx
    e1ee:	31 f6                	xor    %esi,%esi
		fixhead->SN=umIns->SN;
		fixhead->R11=0;
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
    e1f0:	31 ff                	xor    %edi,%edi
					length += umBuffer->pkt->len;
					break;
				}
			}
		}
		*(u16*)fixhead=htons(*(u16*)fixhead);
    e1f2:	0f b7 d0             	movzwl %ax,%edx
    e1f5:	e9 4d fd ff ff       	jmp    df47 <rlc_UM_segment+0x147>
    e1fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
    e200:	0f b7 75 e0          	movzwl -0x20(%ebp),%esi
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e204:	8d 14 3f             	lea    (%edi,%edi,1),%edx
    e207:	31 c0                	xor    %eax,%eax
						break;
					}
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
    e209:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
    e20d:	0f 84 e1 00 00 00    	je     e2f4 <rlc_UM_segment+0x4f4>
							fixhead->FIsecond=0;
						}
					}
					else
					{
						if(flag)
    e213:	84 c0                	test   %al,%al
    e215:	0f 84 ad 00 00 00    	je     e2c8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=1;
    e21b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e21f:	83 c8 10             	or     $0x10,%eax
							fixhead->E=0;
							fixhead->FIsecond=0;
    e222:	83 e0 f3             	and    $0xfffffff3,%eax
    e225:	88 45 f3             	mov    %al,-0xd(%ebp)
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e228:	8b 03                	mov    (%ebx),%eax
					length += umBuffer->pkt->len;
    e22a:	01 d6                	add    %edx,%esi
						else
						{
							fixhead->FIsecond=0;
						}
					}
					lastCopyLen = umBuffer->pkt->len ;
    e22c:	8b 40 50             	mov    0x50(%eax),%eax
    e22f:	01 c6                	add    %eax,%esi
    e231:	89 45 d0             	mov    %eax,-0x30(%ebp)
    e234:	0f b7 de             	movzwl %si,%ebx
					length += umBuffer->pkt->len;
					break;
    e237:	e9 04 fd ff ff       	jmp    df40 <rlc_UM_segment+0x140>
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
		if(count == 1)
		{
			fsm_skb_reserve(skb,length);
    e23c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e23f:	0f b7 d6             	movzwl %si,%edx
    e242:	e8 fc ff ff ff       	call   e243 <rlc_UM_segment+0x443>
			fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e247:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e24a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e24d:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e253:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e256:	e8 fc ff ff ff       	call   e257 <rlc_UM_segment+0x457>
    e25b:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e25e:	89 f2                	mov    %esi,%edx
    e260:	e8 fc ff ff ff       	call   e261 <rlc_UM_segment+0x461>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    e265:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e268:	ba 02 00 00 00       	mov    $0x2,%edx
    e26d:	e8 fc ff ff ff       	call   e26e <rlc_UM_segment+0x46e>
    e272:	b9 02 00 00 00       	mov    $0x2,%ecx
    e277:	8d 55 f2             	lea    -0xe(%ebp),%edx
    e27a:	e8 fc ff ff ff       	call   e27b <rlc_UM_segment+0x47b>
			
			if(lastCopyLen == tbuff->pkt->len)
    e27f:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e282:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e285:	39 70 50             	cmp    %esi,0x50(%eax)
    e288:	74 77                	je     e301 <rlc_UM_segment+0x501>
				fsm_mem_free(tbuff);
				tbuff = NULL;
			}
			else
			{
				fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e28a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    e28d:	e8 fc ff ff ff       	call   e28e <rlc_UM_segment+0x48e>
				umIns->umSduBufferSize -= lastCopyLen;
    e292:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e295:	8b 75 d0             	mov    -0x30(%ebp),%esi
    e298:	29 70 20             	sub    %esi,0x20(%eax)
				tbuff->pktstatus = LAST_SEGMENT;
    e29b:	c7 43 f4 02 00 00 00 	movl   $0x2,-0xc(%ebx)
    e2a2:	e9 32 fe ff ff       	jmp    e0d9 <rlc_UM_segment+0x2d9>
    e2a7:	90                   	nop
							fixhead->FIsecond=1;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=1;
    e2a8:	80 4d f3 08          	orb    $0x8,-0xd(%ebp)
    e2ac:	e9 f7 fe ff ff       	jmp    e1a8 <rlc_UM_segment+0x3a8>
    e2b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e2b8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e2bc:	e9 e7 fe ff ff       	jmp    e1a8 <rlc_UM_segment+0x3a8>
    e2c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
							fixhead->FIsecond=0;
							flag=false;
						}
						else
						{
							fixhead->FIsecond=0;
    e2c8:	80 65 f3 f7          	andb   $0xf7,-0xd(%ebp)
    e2cc:	e9 57 ff ff ff       	jmp    e228 <rlc_UM_segment+0x428>
				num--;
				if(size < umBuffer->pkt->len)
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e2d1:	84 c0                	test   %al,%al
    e2d3:	74 d3                	je     e2a8 <rlc_UM_segment+0x4a8>
						{
							fixhead->FIfirst=0;
    e2d5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
							fixhead->E=0;
    e2d9:	83 e0 eb             	and    $0xffffffeb,%eax
							fixhead->FIsecond=1;
    e2dc:	83 c8 08             	or     $0x8,%eax
    e2df:	88 45 f3             	mov    %al,-0xd(%ebp)
    e2e2:	e9 c1 fe ff ff       	jmp    e1a8 <rlc_UM_segment+0x3a8>
				}
				else if(size == umBuffer->pkt->len) 
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e2e7:	84 c0                	test   %al,%al
    e2e9:	74 cd                	je     e2b8 <rlc_UM_segment+0x4b8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e2eb:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e2ef:	e9 b4 fe ff ff       	jmp    e1a8 <rlc_UM_segment+0x3a8>
				}
				else							
				{	
					if(umBuffer->pktstatus ==FULL_SDU)
					{
						if(flag)
    e2f4:	84 c0                	test   %al,%al
    e2f6:	74 d0                	je     e2c8 <rlc_UM_segment+0x4c8>
						{
							fixhead->FIfirst=0;
							fixhead->E=0;
							fixhead->FIsecond=0;
    e2f8:	80 65 f3 e3          	andb   $0xe3,-0xd(%ebp)
    e2fc:	e9 27 ff ff ff       	jmp    e228 <rlc_UM_segment+0x428>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e301:	8b 13                	mov    (%ebx),%edx
    e303:	8b 43 04             	mov    0x4(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e306:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e309:	89 10                	mov    %edx,(%eax)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e30b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e30e:	c7 03 00 01 10 00    	movl   $0x100100,(%ebx)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e314:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e317:	c7 43 04 00 02 20 00 	movl   $0x200200,0x4(%ebx)
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			
			if(lastCopyLen == tbuff->pkt->len)
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
    e31e:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e322:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e325:	8b 40 50             	mov    0x50(%eax),%eax
    e328:	29 42 20             	sub    %eax,0x20(%edx)
				fsm_pkt_destroy(tbuff->pkt);
    e32b:	8b 43 f0             	mov    -0x10(%ebx),%eax
    e32e:	e8 fc ff ff ff       	call   e32f <rlc_UM_segment+0x52f>
		*(u16*)fixhead=htons(*(u16*)fixhead);
		fsm_octets_print(fixhead,2);
		length += 2*count;
		skb = fsm_pkt_create(length) ;
		pos = head->next;
		tbuff = list_entry(pos,struct UmBuffer,list);	
    e333:	8d 43 f0             	lea    -0x10(%ebx),%eax
			{
				list_del(&tbuff->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(tbuff->pkt);
				tbuff->pkt = NULL;
    e336:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
				fsm_mem_free(tbuff);
    e33d:	e8 fc ff ff ff       	call   e33e <rlc_UM_segment+0x53e>
    e342:	e9 92 fd ff ff       	jmp    e0d9 <rlc_UM_segment+0x2d9>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e347:	8b 53 10             	mov    0x10(%ebx),%edx
    e34a:	8b 43 14             	mov    0x14(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e34d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e350:	89 10                	mov    %edx,(%eax)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e352:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e355:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e35c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e35f:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
					fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
					if(umBuffer->pkt->len == lastCopyLen)
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
    e366:	83 68 24 01          	subl   $0x1,0x24(%eax)
						umIns->umSduBufferSize -= umBuffer->pkt->len;
    e36a:	8b 03                	mov    (%ebx),%eax
    e36c:	8b 40 50             	mov    0x50(%eax),%eax
    e36f:	29 42 20             	sub    %eax,0x20(%edx)
						fsm_pkt_destroy(umBuffer->pkt);
    e372:	8b 03                	mov    (%ebx),%eax
    e374:	e8 fc ff ff ff       	call   e375 <rlc_UM_segment+0x575>
						umBuffer->pkt = NULL;
						fsm_mem_free(umBuffer);
    e379:	89 d8                	mov    %ebx,%eax
					{
						list_del(&umBuffer->list);
						umIns->umSduBufferNum--;
						umIns->umSduBufferSize -= umBuffer->pkt->len;
						fsm_pkt_destroy(umBuffer->pkt);
						umBuffer->pkt = NULL;
    e37b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
						fsm_mem_free(umBuffer);
    e381:	e8 fc ff ff ff       	call   e382 <rlc_UM_segment+0x582>
    e386:	e9 04 fd ff ff       	jmp    e08f <rlc_UM_segment+0x28f>
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
				num--;
				if(size < umBuffer->pkt->len)
    e38b:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e390:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e395:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e39a:	31 f6                	xor    %esi,%esi
    e39c:	e9 e8 fd ff ff       	jmp    e189 <rlc_UM_segment+0x389>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size == umBuffer->pkt->len) 
    e3a1:	b9 02 00 00 00       	mov    $0x2,%ecx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e3a6:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e3ab:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e3b0:	31 f6                	xor    %esi,%esi
    e3b2:	e9 0a fe ff ff       	jmp    e1c1 <rlc_UM_segment+0x3c1>
					}
					lastCopyLen = size;
					length += size;
					break;
				}
				else if(size > (umBuffer->pkt->len + 2))
    e3b7:	ba 02 00 00 00       	mov    $0x2,%edx
		size = sizeFromMac - 2;
		if(!list_empty(head))
		{
			list_for_each_entry(umBuffer,head,list)
			{
				count++;
    e3bc:	bf 01 00 00 00       	mov    $0x1,%edi
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
		bool flag=true;
    e3c1:	b8 01 00 00 00       	mov    $0x1,%eax
		fixhead->R12=0;
		fixhead->R13=0;
		//fixhead->FIfirst=2;
		int count = 0;
		unsigned int lastCopyLen;
		u16 length =0;
    e3c6:	31 f6                	xor    %esi,%esi
    e3c8:	e9 3c fe ff ff       	jmp    e209 <rlc_UM_segment+0x409>
		FSM_PKT *skb;
		struct list_head *pos;
		fsm_printf("[RLC] entring rlc_UM_segment\n");
		if(sizeFromMac <= 2)
		{
			printk("[RLC][rlc_UM_segment] size <= 2\n");
    e3cd:	c7 04 24 9c 38 00 00 	movl   $0x389c,(%esp)
    e3d4:	e8 fc ff ff ff       	call   e3d5 <rlc_UM_segment+0x5d5>
			return NULL;
    e3d9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    e3e0:	e9 29 fd ff ff       	jmp    e10e <rlc_UM_segment+0x30e>
    e3e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e3e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000e3f0 <rlc_UM5_segment>:
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e3f0:	55                   	push   %ebp
    e3f1:	89 e5                	mov    %esp,%ebp
    e3f3:	57                   	push   %edi
    e3f4:	56                   	push   %esi
    e3f5:	53                   	push   %ebx
    e3f6:	83 ec 38             	sub    $0x38,%esp
    e3f9:	e8 fc ff ff ff       	call   e3fa <rlc_UM5_segment+0xa>
	u32 size;
	int num = umIns->umSduBufferNum;
    e3fe:	8b 78 24             	mov    0x24(%eax),%edi
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e401:	89 d3                	mov    %edx,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e403:	0f b7 50 28          	movzwl 0x28(%eax),%edx
** Modified Date: 2015-03-06
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
    e407:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e40a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e40e:	83 e2 1f             	and    $0x1f,%edx
    e411:	83 e0 e0             	and    $0xffffffe0,%eax
    e414:	09 d0                	or     %edx,%eax
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e416:	83 fb 01             	cmp    $0x1,%ebx
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
    e419:	88 45 f3             	mov    %al,-0xd(%ebp)
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
    e41c:	0f 86 9f 05 00 00    	jbe    e9c1 <rlc_UM5_segment+0x5d1>
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e425:	c7 04 24 04 39 00 00 	movl   $0x3904,(%esp)
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
	FSM_PKT *skb;
	struct list_head *pos;
	struct list_head *head =&(umIns->umSduBuffer.list);
    e42c:	83 c0 18             	add    $0x18,%eax
    e42f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
    e432:	e8 fc ff ff ff       	call   e433 <rlc_UM5_segment+0x43>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
    e437:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e43a:	8b 42 18             	mov    0x18(%edx),%eax
	if(!list_empty(head))
    e43d:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e440:	0f 84 72 03 00 00    	je     e7b8 <rlc_UM5_segment+0x3c8>
	{
		list_for_each_entry(umBuffer,head,list)
    e446:	8d 70 f0             	lea    -0x10(%eax),%esi
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e449:	8b 40 f0             	mov    -0x10(%eax),%eax
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
		return NULL;
	}
	size = sizeFromMac - 1;
    e44c:	8d 53 ff             	lea    -0x1(%ebx),%edx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e44f:	8b 40 50             	mov    0x50(%eax),%eax
    e452:	39 c2                	cmp    %eax,%edx
    e454:	0f 82 22 05 00 00    	jb     e97c <rlc_UM5_segment+0x58c>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e45a:	0f 84 33 05 00 00    	je     e993 <rlc_UM5_segment+0x5a3>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e460:	8d 48 02             	lea    0x2(%eax),%ecx
    e463:	39 ca                	cmp    %ecx,%edx
    e465:	0f 86 3f 05 00 00    	jbe    e9aa <rlc_UM5_segment+0x5ba>

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e46b:	31 db                	xor    %ebx,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e46d:	83 ef 01             	sub    $0x1,%edi
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e470:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e476:	b9 01 00 00 00       	mov    $0x1,%ecx
    e47b:	66 89 5d e0          	mov    %bx,-0x20(%ebp)
    e47f:	eb 54                	jmp    e4d5 <rlc_UM5_segment+0xe5>
    e481:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					fixhead->FIfirst=0;
					fixhead->E=1;
					flag=false;
				}
				else if(umBuffer->pktstatus !=FULL_SDU &&flag)
    e488:	84 c9                	test   %cl,%cl
    e48a:	74 04                	je     e490 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=1;
					fixhead->E=1;
    e48c:	80 4d f3 a0          	orb    $0xa0,-0xd(%ebp)
					flag=false;
				}
				if(num == 0)
    e490:	85 ff                	test   %edi,%edi
    e492:	74 64                	je     e4f8 <rlc_UM5_segment+0x108>
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e494:	8b 4e 10             	mov    0x10(%esi),%ecx
    e497:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
    e49a:	8d 71 f0             	lea    -0x10(%ecx),%esi
    e49d:	0f 84 95 02 00 00    	je     e738 <rlc_UM5_segment+0x348>
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e4a3:	bb fe ff ff ff       	mov    $0xfffffffe,%ebx
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
    e4a8:	83 ef 01             	sub    $0x1,%edi
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e4ab:	29 c3                	sub    %eax,%ebx
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e4ad:	8b 41 f0             	mov    -0x10(%ecx),%eax
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
			{

				size = size - umBuffer->pkt->len - 2;
    e4b0:	01 da                	add    %ebx,%edx
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e4b2:	66 83 45 ec 01       	addw   $0x1,-0x14(%ebp)
			num--;
			if(size < umBuffer->pkt->len)
    e4b7:	8b 40 50             	mov    0x50(%eax),%eax
    e4ba:	39 d0                	cmp    %edx,%eax
    e4bc:	0f 87 86 02 00 00    	ja     e748 <rlc_UM5_segment+0x358>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e4c2:	0f 84 c0 02 00 00    	je     e788 <rlc_UM5_segment+0x398>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e4c8:	8d 48 02             	lea    0x2(%eax),%ecx
    e4cb:	39 d1                	cmp    %edx,%ecx
    e4cd:	0f 83 05 03 00 00    	jae    e7d8 <rlc_UM5_segment+0x3e8>
    e4d3:	31 c9                	xor    %ecx,%ecx
			{

				size = size - umBuffer->pkt->len - 2;
				length += umBuffer->pkt->len;
    e4d5:	66 01 45 e0          	add    %ax,-0x20(%ebp)
				if(umBuffer->pktstatus==FULL_SDU &&flag)
    e4d9:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e4dd:	75 a9                	jne    e488 <rlc_UM5_segment+0x98>
    e4df:	84 c9                	test   %cl,%cl
    e4e1:	74 ad                	je     e490 <rlc_UM5_segment+0xa0>
				{

					fixhead->FIfirst=0;
    e4e3:	0f b6 4d f3          	movzbl -0xd(%ebp),%ecx
    e4e7:	83 e1 7f             	and    $0x7f,%ecx
					fixhead->E=1;
    e4ea:	83 c9 20             	or     $0x20,%ecx

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e4ed:	85 ff                	test   %edi,%edi
				length += umBuffer->pkt->len;
				if(umBuffer->pktstatus==FULL_SDU &&flag)
				{

					fixhead->FIfirst=0;
					fixhead->E=1;
    e4ef:	88 4d f3             	mov    %cl,-0xd(%ebp)

					fixhead->FIfirst=1;
					fixhead->E=1;
					flag=false;
				}
				if(num == 0)
    e4f2:	75 a0                	jne    e494 <rlc_UM5_segment+0xa4>
    e4f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    e4f8:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e4fc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e4ff:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e503:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
					flag=false;
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
    e507:	89 d0                	mov    %edx,%eax
    e509:	83 e0 df             	and    $0xffffffdf,%eax
    e50c:	83 79 24 01          	cmpl   $0x1,0x24(%ecx)
    e510:	0f 45 c2             	cmovne %edx,%eax
					fixhead->FIsecond=0;
					lastCopyLen=umBuffer->pkt->len;
    e513:	01 ff                	add    %edi,%edi
				}
				if(num == 0)
				{
					if((umIns->umSduBufferNum)==1)
						fixhead->E=0;
					fixhead->FIsecond=0;
    e515:	83 e0 bf             	and    $0xffffffbf,%eax
    e518:	88 45 f3             	mov    %al,-0xd(%ebp)
					lastCopyLen=umBuffer->pkt->len;
    e51b:	8b 06                	mov    (%esi),%eax
    e51d:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e521:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
    e525:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e528:	ba 02 00 00 00       	mov    $0x2,%edx
    e52d:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e530:	e8 fc ff ff ff       	call   e531 <rlc_UM5_segment+0x141>
	length = length + (2*count-1);
    e535:	8d 5c 3b ff          	lea    -0x1(%ebx,%edi,1),%ebx
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e539:	0f b7 db             	movzwl %bx,%ebx
    e53c:	89 d8                	mov    %ebx,%eax
    e53e:	e8 fc ff ff ff       	call   e53f <rlc_UM5_segment+0x14f>
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e543:	66 83 7d ec 01       	cmpw   $0x1,-0x14(%ebp)
	}
	
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e548:	89 45 e0             	mov    %eax,-0x20(%ebp)
	pos = head->next;
    e54b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e54e:	8b 40 18             	mov    0x18(%eax),%eax
    e551:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
    e554:	0f 84 be 02 00 00    	je     e818 <rlc_UM5_segment+0x428>
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
			tbuff->pktstatus = LAST_SEGMENT;
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
    e55a:	0f 86 4d 01 00 00    	jbe    e6ad <rlc_UM5_segment+0x2bd>
	{
		fsm_skb_reserve(skb,(2*count-1));
    e560:	0f b7 5d ec          	movzwl -0x14(%ebp),%ebx
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
    e564:	31 ff                	xor    %edi,%edi
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e566:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e569:	8d 54 1b ff          	lea    -0x1(%ebx,%ebx,1),%edx
    e56d:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e570:	83 eb 01             	sub    $0x1,%ebx
			umIns->umSduBufferSize -=lastCopyLen;
		}
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
    e573:	e8 fc ff ff ff       	call   e574 <rlc_UM5_segment+0x184>
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e578:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    e57b:	01 db                	add    %ebx,%ebx
    e57d:	89 d8                	mov    %ebx,%eax
    e57f:	89 5d d0             	mov    %ebx,-0x30(%ebp)
    e582:	e8 fc ff ff ff       	call   e583 <rlc_UM5_segment+0x193>
    e587:	89 45 c8             	mov    %eax,-0x38(%ebp)
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e58a:	89 d8                	mov    %ebx,%eax
    e58c:	e8 fc ff ff ff       	call   e58d <rlc_UM5_segment+0x19d>
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e591:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	}
	else if(count > 1)
	{
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
    e594:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int i = 0;
		unsigned char *des = skb->data;
    e597:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e59a:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    e5a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e5a3:	8b 42 18             	mov    0x18(%edx),%eax
    e5a6:	8b 30                	mov    (%eax),%esi
    e5a8:	8d 58 f0             	lea    -0x10(%eax),%ebx
    e5ab:	83 ee 10             	sub    $0x10,%esi
    e5ae:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e5b1:	75 21                	jne    e5d4 <rlc_UM5_segment+0x1e4>
    e5b3:	e9 b8 00 00 00       	jmp    e670 <rlc_UM5_segment+0x280>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
    e5b8:	0f 84 32 01 00 00    	je     e6f0 <rlc_UM5_segment+0x300>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e5be:	8b 46 10             	mov    0x10(%esi),%eax
    e5c1:	8d 56 10             	lea    0x10(%esi),%edx
    e5c4:	83 e8 10             	sub    $0x10,%eax
    e5c7:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e5ca:	0f 84 a0 00 00 00    	je     e670 <rlc_UM5_segment+0x280>
    e5d0:	89 f3                	mov    %esi,%ebx
    e5d2:	89 c6                	mov    %eax,%esi
		{
			if(i<count-1)
    e5d4:	3b 7d ec             	cmp    -0x14(%ebp),%edi
    e5d7:	7d df                	jge    e5b8 <rlc_UM5_segment+0x1c8>
			{
				*(LI+i) = umBuffer->pkt->len;
    e5d9:	8b 03                	mov    (%ebx),%eax
    e5db:	8b 4d c8             	mov    -0x38(%ebp),%ecx
				*(headExt+i) = 0x80|(*(LI+i));
    e5de:	8b 55 d8             	mov    -0x28(%ebp),%edx
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
    e5e1:	8b 40 50             	mov    0x50(%eax),%eax
    e5e4:	66 89 04 79          	mov    %ax,(%ecx,%edi,2)
				*(headExt+i) = 0x80|(*(LI+i));
    e5e8:	0c 80                	or     $0x80,%al
    e5ea:	66 89 04 7a          	mov    %ax,(%edx,%edi,2)
				fsm_skb_put(skb,umBuffer->pkt->len);
    e5ee:	8b 03                	mov    (%ebx),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
				umBuffer = NULL;
				i++;
    e5f0:	83 c7 01             	add    $0x1,%edi
		{
			if(i<count-1)
			{
				*(LI+i) = umBuffer->pkt->len;
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
    e5f3:	8b 50 50             	mov    0x50(%eax),%edx
    e5f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e5f9:	e8 fc ff ff ff       	call   e5fa <rlc_UM5_segment+0x20a>
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
    e5fe:	8b 03                	mov    (%ebx),%eax
    e600:	8b 48 50             	mov    0x50(%eax),%ecx
    e603:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e609:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e60c:	e8 fc ff ff ff       	call   e60d <rlc_UM5_segment+0x21d>
				des = des + umBuffer->pkt->len ;
    e611:	8b 03                	mov    (%ebx),%eax
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e613:	8b 53 10             	mov    0x10(%ebx),%edx
    e616:	8b 48 50             	mov    0x50(%eax),%ecx
    e619:	8b 43 14             	mov    0x14(%ebx),%eax
    e61c:	01 4d dc             	add    %ecx,-0x24(%ebp)
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e61f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e622:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e625:	89 10                	mov    %edx,(%eax)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e627:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e62a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e62d:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e634:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				*(headExt+i) = 0x80|(*(LI+i));
				fsm_skb_put(skb,umBuffer->pkt->len);
				fsm_mem_cpy(des,umBuffer->pkt->data,umBuffer->pkt->len);
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
    e63b:	83 68 24 01          	subl   $0x1,0x24(%eax)
				umIns->umSduBufferSize -= tbuff->pkt->len;
    e63f:	8b 42 f0             	mov    -0x10(%edx),%eax
    e642:	8b 40 50             	mov    0x50(%eax),%eax
    e645:	29 41 20             	sub    %eax,0x20(%ecx)
				fsm_pkt_destroy(umBuffer->pkt);
    e648:	8b 03                	mov    (%ebx),%eax
    e64a:	e8 fc ff ff ff       	call   e64b <rlc_UM5_segment+0x25b>
				umBuffer->pkt = NULL;
				fsm_mem_free(umBuffer);
    e64f:	89 d8                	mov    %ebx,%eax
				des = des + umBuffer->pkt->len ;
				list_del(&umBuffer->list);
				umIns->umSduBufferNum--;
				umIns->umSduBufferSize -= tbuff->pkt->len;
				fsm_pkt_destroy(umBuffer->pkt);
				umBuffer->pkt = NULL;
    e651:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
				fsm_mem_free(umBuffer);
    e657:	e8 fc ff ff ff       	call   e658 <rlc_UM5_segment+0x268>
		fsm_skb_reserve(skb,(2*count-1));
		u16 *LI = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		u16 *headExt = (u16*)fsm_mem_alloc((count-1)*sizeof(u16));
		int i = 0;
		unsigned char *des = skb->data;
		list_for_each_entry_safe(umBuffer,tempBuffer,head,list)
    e65c:	8b 46 10             	mov    0x10(%esi),%eax
    e65f:	8d 56 10             	lea    0x10(%esi),%edx
    e662:	83 e8 10             	sub    $0x10,%eax
    e665:	39 55 e8             	cmp    %edx,-0x18(%ebp)
    e668:	0f 85 62 ff ff ff    	jne    e5d0 <rlc_UM5_segment+0x1e0>
    e66e:	66 90                	xchg   %ax,%ax
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e670:	8b 45 d8             	mov    -0x28(%ebp),%eax
    e673:	8b 5d cc             	mov    -0x34(%ebp),%ebx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e676:	8b 55 d0             	mov    -0x30(%ebp),%edx
				}
				break;
			}
							
		}
		*(headExt+count-2)=(*(headExt+count-2)&0x7fff);
    e679:	66 81 64 58 fc ff 7f 	andw   $0x7fff,-0x4(%eax,%ebx,2)
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
    e680:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e683:	e8 fc ff ff ff       	call   e684 <rlc_UM5_segment+0x294>
    e688:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    e68b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e68e:	e8 fc ff ff ff       	call   e68f <rlc_UM5_segment+0x29f>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e693:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e696:	ba 01 00 00 00       	mov    $0x1,%edx
    e69b:	e8 fc ff ff ff       	call   e69c <rlc_UM5_segment+0x2ac>
    e6a0:	b9 01 00 00 00       	mov    $0x1,%ecx
    e6a5:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e6a8:	e8 fc ff ff ff       	call   e6a9 <rlc_UM5_segment+0x2b9>
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e6ad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	umIns->SN %= 32;
    e6b0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
		fsm_mem_cpy(fsm_skb_push(skb,2*(count-1)),headExt,2*(count-1));
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
	}
	//fsm_printf("[RLC] the context of PDU is %s\n",(char*)(skb->data+2*count-1));	
	//fsm_printf("[RLC] the PDU length is %d\n",skb->len);
	umIns->SN++;
    e6b3:	0f b7 42 28          	movzwl 0x28(%edx),%eax
    e6b7:	83 c0 01             	add    $0x1,%eax
	umIns->SN %= 32;
    e6ba:	89 c2                	mov    %eax,%edx
    e6bc:	66 c1 fa 0f          	sar    $0xf,%dx
    e6c0:	66 c1 ea 0b          	shr    $0xb,%dx
    e6c4:	01 d0                	add    %edx,%eax
    e6c6:	83 e0 1f             	and    $0x1f,%eax
    e6c9:	66 29 d0             	sub    %dx,%ax
    e6cc:	66 89 41 28          	mov    %ax,0x28(%ecx)
	fsm_printf("[RLC][rlc_UM5_segment] SN = %d\n",umIns->SN);
    e6d0:	98                   	cwtl   
    e6d1:	89 44 24 04          	mov    %eax,0x4(%esp)
    e6d5:	c7 04 24 24 39 00 00 	movl   $0x3924,(%esp)
    e6dc:	e8 fc ff ff ff       	call   e6dd <rlc_UM5_segment+0x2ed>
	return skb;
}
    e6e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6e4:	83 c4 38             	add    $0x38,%esp
    e6e7:	5b                   	pop    %ebx
    e6e8:	5e                   	pop    %esi
    e6e9:	5f                   	pop    %edi
    e6ea:	5d                   	pop    %ebp
    e6eb:	c3                   	ret    
    e6ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				umBuffer = NULL;
				i++;
			}
			else if(i==count-1)
			{
				fsm_skb_put(skb,lastCopyLen);
    e6f0:	0f b7 75 c6          	movzwl -0x3a(%ebp),%esi
    e6f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e6f7:	89 f2                	mov    %esi,%edx
    e6f9:	e8 fc ff ff ff       	call   e6fa <rlc_UM5_segment+0x30a>
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
    e6fe:	8b 03                	mov    (%ebx),%eax
    e700:	89 f1                	mov    %esi,%ecx
    e702:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    e708:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e70b:	e8 fc ff ff ff       	call   e70c <rlc_UM5_segment+0x31c>
				
				if(umBuffer->pkt->len == lastCopyLen)
    e710:	8b 03                	mov    (%ebx),%eax
    e712:	3b 70 50             	cmp    0x50(%eax),%esi
    e715:	0f 84 9e 01 00 00    	je     e8b9 <rlc_UM5_segment+0x4c9>
					fsm_mem_free(umBuffer); 
					umBuffer = NULL;
				}
				else
				{
					fsm_skb_pull(umBuffer->pkt,lastCopyLen);
    e71b:	89 f2                	mov    %esi,%edx
    e71d:	e8 fc ff ff ff       	call   e71e <rlc_UM5_segment+0x32e>
					umIns->umSduBufferSize -=lastCopyLen;
    e722:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e725:	29 70 20             	sub    %esi,0x20(%eax)
					umBuffer->pktstatus=LAST_SEGMENT;
    e728:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
    e72f:	e9 3c ff ff ff       	jmp    e670 <rlc_UM5_segment+0x280>
    e734:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	size = sizeFromMac - 1;
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
    e738:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e73c:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e740:	01 ff                	add    %edi,%edi
    e742:	e9 e1 fd ff ff       	jmp    e528 <rlc_UM5_segment+0x138>
    e747:	90                   	nop
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e748:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e74c:	31 c0                	xor    %eax,%eax
    e74e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e752:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e754:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e758:	0f 84 a3 01 00 00    	je     e901 <rlc_UM5_segment+0x511>
					else
						fixhead->FIsecond=1;
				}
				else
				{
					if(flag)
    e75e:	84 c0                	test   %al,%al
    e760:	0f 84 2a 01 00 00    	je     e890 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=1;
    e766:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e76a:	83 e0 1f             	and    $0x1f,%eax
						fixhead->FIsecond=1;
    e76d:	83 c8 c0             	or     $0xffffffc0,%eax
    e770:	88 45 f3             	mov    %al,-0xd(%ebp)
    e773:	90                   	nop
    e774:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = size;
    e778:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
				length += size;
    e77c:	01 d3                	add    %edx,%ebx
				break;
    e77e:	e9 a5 fd ff ff       	jmp    e528 <rlc_UM5_segment+0x138>
    e783:	90                   	nop
    e784:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e788:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e78c:	31 c0                	xor    %eax,%eax
    e78e:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e792:	01 ff                	add    %edi,%edi
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e794:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e798:	0f 84 79 01 00 00    	je     e917 <rlc_UM5_segment+0x527>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e79e:	84 c0                	test   %al,%al
    e7a0:	0f 84 fa 00 00 00    	je     e8a0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=1;
    e7a6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e7aa:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e7ad:	83 e0 9f             	and    $0xffffff9f,%eax
    e7b0:	88 45 f3             	mov    %al,-0xd(%ebp)
    e7b3:	eb c3                	jmp    e778 <rlc_UM5_segment+0x388>
    e7b5:	8d 76 00             	lea    0x0(%esi),%esi
				break;
			}
		}
	}
	
	fsm_octets_print(fixhead,2);
    e7b8:	ba 02 00 00 00       	mov    $0x2,%edx
    e7bd:	8d 45 f3             	lea    -0xd(%ebp),%eax
    e7c0:	e8 fc ff ff ff       	call   e7c1 <rlc_UM5_segment+0x3d1>
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
    e7c5:	b8 ff ff 00 00       	mov    $0xffff,%eax
    e7ca:	e8 fc ff ff ff       	call   e7cb <rlc_UM5_segment+0x3db>
    e7cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e7d2:	e9 d6 fe ff ff       	jmp    e6ad <rlc_UM5_segment+0x2bd>
    e7d7:	90                   	nop
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e7d8:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
    e7dc:	31 c0                	xor    %eax,%eax
    e7de:	0f b7 5d e0          	movzwl -0x20(%ebp),%ebx
    e7e2:	01 ff                	add    %edi,%edi
				}
			}
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
    e7e4:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
    e7e8:	0f 84 36 01 00 00    	je     e924 <rlc_UM5_segment+0x534>
					else
						fixhead->FIsecond=0;
				}
				else
				{
					if(flag)
    e7ee:	84 c0                	test   %al,%al
    e7f0:	0f 84 ba 00 00 00    	je     e8b0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=1;
    e7f6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e7fa:	83 c8 80             	or     $0xffffff80,%eax
						fixhead->E=0;
						fixhead->FIsecond=0;
    e7fd:	83 e0 9f             	and    $0xffffff9f,%eax
    e800:	88 45 f3             	mov    %al,-0xd(%ebp)
						flag=false;
					}
					else
						fixhead->FIsecond=0;
				}
				lastCopyLen = umBuffer->pkt->len ;
    e803:	8b 06                	mov    (%esi),%eax
    e805:	0f b7 40 50          	movzwl 0x50(%eax),%eax
    e809:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
				length += umBuffer->pkt->len;
    e80d:	01 c3                	add    %eax,%ebx
				break;
    e80f:	e9 14 fd ff ff       	jmp    e528 <rlc_UM5_segment+0x138>
    e814:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);

	if(count == 1)
	{
		fsm_skb_reserve(skb,length);
    e818:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e81b:	89 da                	mov    %ebx,%edx
    e81d:	e8 fc ff ff ff       	call   e81e <rlc_UM5_segment+0x42e>
		fsm_mem_cpy(fsm_skb_push(skb,lastCopyLen),tbuff->pkt->data,lastCopyLen);
    e822:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    e825:	0f b7 5d c6          	movzwl -0x3a(%ebp),%ebx
    e829:	8b 42 f0             	mov    -0x10(%edx),%eax
    e82c:	89 da                	mov    %ebx,%edx
    e82e:	8b b0 ac 00 00 00    	mov    0xac(%eax),%esi
    e834:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e837:	e8 fc ff ff ff       	call   e838 <rlc_UM5_segment+0x448>
    e83c:	89 d9                	mov    %ebx,%ecx
    e83e:	89 f2                	mov    %esi,%edx
    e840:	e8 fc ff ff ff       	call   e841 <rlc_UM5_segment+0x451>
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
    e845:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e848:	ba 01 00 00 00       	mov    $0x1,%edx
    e84d:	e8 fc ff ff ff       	call   e84e <rlc_UM5_segment+0x45e>
    e852:	b9 01 00 00 00       	mov    $0x1,%ecx
    e857:	8d 55 f3             	lea    -0xd(%ebp),%edx
    e85a:	e8 fc ff ff ff       	call   e85b <rlc_UM5_segment+0x46b>
		
		if(lastCopyLen == tbuff->pkt->len)
    e85f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    e862:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e865:	3b 58 50             	cmp    0x50(%eax),%ebx
    e868:	0f 84 c3 00 00 00    	je     e931 <rlc_UM5_segment+0x541>
			fsm_mem_free(tbuff);
			tbuff = NULL;
		}
		else
		{
			fsm_skb_pull(tbuff->pkt,lastCopyLen);
    e86e:	89 da                	mov    %ebx,%edx
    e870:	e8 fc ff ff ff       	call   e871 <rlc_UM5_segment+0x481>
			tbuff->pktstatus = LAST_SEGMENT;
    e875:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    e878:	c7 40 f4 02 00 00 00 	movl   $0x2,-0xc(%eax)
			umIns->umSduBufferSize -=lastCopyLen;
    e87f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e882:	29 58 20             	sub    %ebx,0x20(%eax)
    e885:	e9 23 fe ff ff       	jmp    e6ad <rlc_UM5_segment+0x2bd>
    e88a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
						fixhead->E=0;
						fixhead->FIsecond=1;
						flag=false;
					}
					else
						fixhead->FIsecond=1;
    e890:	80 4d f3 40          	orb    $0x40,-0xd(%ebp)
    e894:	e9 df fe ff ff       	jmp    e778 <rlc_UM5_segment+0x388>
    e899:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}		
					else
						fixhead->FIsecond=0;
    e8a0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e8a4:	e9 cf fe ff ff       	jmp    e778 <rlc_UM5_segment+0x388>
    e8a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
						fixhead->E=0;
						fixhead->FIsecond=0;
						flag=false;
					}
					else
						fixhead->FIsecond=0;
    e8b0:	80 65 f3 bf          	andb   $0xbf,-0xd(%ebp)
    e8b4:	e9 4a ff ff ff       	jmp    e803 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e8b9:	8b 53 10             	mov    0x10(%ebx),%edx
    e8bc:	8b 43 14             	mov    0x14(%ebx),%eax
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e8bf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e8c2:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e8c5:	89 10                	mov    %edx,(%eax)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e8c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e8ca:	8b 55 d4             	mov    -0x2c(%ebp),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e8cd:	c7 43 10 00 01 10 00 	movl   $0x100100,0x10(%ebx)
	entry->prev = LIST_POISON2;
    e8d4:	c7 43 14 00 02 20 00 	movl   $0x200200,0x14(%ebx)
				fsm_mem_cpy(des,umBuffer->pkt->data,lastCopyLen);
				
				if(umBuffer->pkt->len == lastCopyLen)
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
    e8db:	83 68 24 01          	subl   $0x1,0x24(%eax)
					umIns->umSduBufferSize -= tbuff->pkt->len;
    e8df:	8b 42 f0             	mov    -0x10(%edx),%eax
    e8e2:	8b 40 50             	mov    0x50(%eax),%eax
    e8e5:	29 41 20             	sub    %eax,0x20(%ecx)
					fsm_pkt_destroy(umBuffer->pkt);
    e8e8:	8b 03                	mov    (%ebx),%eax
    e8ea:	e8 fc ff ff ff       	call   e8eb <rlc_UM5_segment+0x4fb>
					umBuffer->pkt = NULL;
					fsm_mem_free(umBuffer); 
    e8ef:	89 d8                	mov    %ebx,%eax
				{
					list_del(&umBuffer->list);
					umIns->umSduBufferNum--;
					umIns->umSduBufferSize -= tbuff->pkt->len;
					fsm_pkt_destroy(umBuffer->pkt);
					umBuffer->pkt = NULL;
    e8f1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
					fsm_mem_free(umBuffer); 
    e8f7:	e8 fc ff ff ff       	call   e8f8 <rlc_UM5_segment+0x508>
    e8fc:	e9 6f fd ff ff       	jmp    e670 <rlc_UM5_segment+0x280>
			if(size < umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e901:	84 c0                	test   %al,%al
    e903:	74 8b                	je     e890 <rlc_UM5_segment+0x4a0>
					{
						fixhead->FIfirst=0;
    e905:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
						fixhead->E=0;
    e909:	83 e0 5f             	and    $0x5f,%eax
						fixhead->FIsecond=1;
    e90c:	83 c8 40             	or     $0x40,%eax
    e90f:	88 45 f3             	mov    %al,-0xd(%ebp)
    e912:	e9 61 fe ff ff       	jmp    e778 <rlc_UM5_segment+0x388>
			else if(size == umBuffer->pkt->len)
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e917:	84 c0                	test   %al,%al
    e919:	74 85                	je     e8a0 <rlc_UM5_segment+0x4b0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e91b:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e91f:	e9 54 fe ff ff       	jmp    e778 <rlc_UM5_segment+0x388>
			else                             
			{

				if(umBuffer->pktstatus ==FULL_SDU)
				{
					if(flag)
    e924:	84 c0                	test   %al,%al
    e926:	74 88                	je     e8b0 <rlc_UM5_segment+0x4c0>
					{
						fixhead->FIfirst=0;
						fixhead->E=0;
						fixhead->FIsecond=0;
    e928:	80 65 f3 1f          	andb   $0x1f,-0xd(%ebp)
    e92c:	e9 d2 fe ff ff       	jmp    e803 <rlc_UM5_segment+0x413>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    e931:	8b 11                	mov    (%ecx),%edx
    e933:	8b 41 04             	mov    0x4(%ecx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    e936:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    e939:	89 10                	mov    %edx,(%eax)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e93b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    e93e:	c7 01 00 01 10 00    	movl   $0x100100,(%ecx)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e944:	8b 55 e4             	mov    -0x1c(%ebp),%edx
	entry->prev = LIST_POISON2;
    e947:	c7 41 04 00 02 20 00 	movl   $0x200200,0x4(%ecx)
		fsm_mem_cpy(fsm_skb_push(skb,1),fixhead,1);
		
		if(lastCopyLen == tbuff->pkt->len)
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
    e94e:	83 68 24 01          	subl   $0x1,0x24(%eax)
			umIns->umSduBufferSize -= tbuff->pkt->len;
    e952:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e955:	8b 40 50             	mov    0x50(%eax),%eax
    e958:	29 42 20             	sub    %eax,0x20(%edx)
			fsm_pkt_destroy(tbuff->pkt);
    e95b:	8b 41 f0             	mov    -0x10(%ecx),%eax
    e95e:	e8 fc ff ff ff       	call   e95f <rlc_UM5_segment+0x56f>
			tbuff->pkt = NULL;
    e963:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e966:	89 d8                	mov    %ebx,%eax
		{
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
    e968:	c7 43 f0 00 00 00 00 	movl   $0x0,-0x10(%ebx)
	fsm_octets_print(fixhead,2);
	length = length + (2*count-1);
	//fsm_printf("%d\n",length);
	skb = fsm_pkt_create(length) ;
	pos = head->next;
	tbuff = list_entry(pos,struct UmBuffer,list);
    e96f:	83 e8 10             	sub    $0x10,%eax
			list_del(&tbuff->list);
			umIns->umSduBufferNum--;
			umIns->umSduBufferSize -= tbuff->pkt->len;
			fsm_pkt_destroy(tbuff->pkt);
			tbuff->pkt = NULL;
			fsm_mem_free(tbuff);
    e972:	e8 fc ff ff ff       	call   e973 <rlc_UM5_segment+0x583>
    e977:	e9 31 fd ff ff       	jmp    e6ad <rlc_UM5_segment+0x2bd>
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
			num--;
			if(size < umBuffer->pkt->len)
    e97c:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e981:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e986:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e98c:	31 db                	xor    %ebx,%ebx
    e98e:	e9 c1 fd ff ff       	jmp    e754 <rlc_UM5_segment+0x364>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size == umBuffer->pkt->len)
    e993:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e998:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e99d:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e9a3:	31 db                	xor    %ebx,%ebx
    e9a5:	e9 ea fd ff ff       	jmp    e794 <rlc_UM5_segment+0x3a4>
				}
				lastCopyLen = size;
				length += size;
				break;
			}
			else if(size > (umBuffer->pkt->len + 2))
    e9aa:	bf 02 00 00 00       	mov    $0x2,%edi
	struct list_head *head =&(umIns->umSduBuffer.list);
	struct UmBuffer *umBuffer,*tempBuffer,*tbuff;
	struct RLC_UM_size5_head *fixhead, umhead;
	fixhead=&umhead;
	fixhead->SN=umIns->SN;
	bool flag=true;
    e9af:	b8 01 00 00 00       	mov    $0x1,%eax
	fsm_printf("[RLC] entring rlc_UM5_segment\n");
	if(!list_empty(head))
	{
		list_for_each_entry(umBuffer,head,list)
		{
			count++;
    e9b4:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)

FSM_PKT * rlc_UM5_segment(struct UM_TX_Instance *umIns,u32 sizeFromMac)
{
	u32 size;
	int num = umIns->umSduBufferNum;
	u16 length=0, count=0,lastCopyLen;
    e9ba:	31 db                	xor    %ebx,%ebx
    e9bc:	e9 23 fe ff ff       	jmp    e7e4 <rlc_UM5_segment+0x3f4>
	bool flag=true;
	//fixhead->FIfirst=2;
	
	if(sizeFromMac <= 1)
	{
		printk("[RLC][rlc_UM5_segment] size <= 1\n");
    e9c1:	c7 04 24 e0 38 00 00 	movl   $0x38e0,(%esp)
    e9c8:	e8 fc ff ff ff       	call   e9c9 <rlc_UM5_segment+0x5d9>
		return NULL;
    e9cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    e9d4:	e9 08 fd ff ff       	jmp    e6e1 <rlc_UM5_segment+0x2f1>
    e9d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0000e9e0 <rlc_resegment>:
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e9e0:	55                   	push   %ebp
    e9e1:	89 e5                	mov    %esp,%ebp
    e9e3:	57                   	push   %edi
    e9e4:	56                   	push   %esi
    e9e5:	53                   	push   %ebx
    e9e6:	83 ec 20             	sub    $0x20,%esp
    e9e9:	e8 fc ff ff ff       	call   e9ea <rlc_resegment+0xa>
	if(tbuff->segStart[0] != -1)
    e9ee:	83 78 10 ff          	cmpl   $0xffffffff,0x10(%eax)
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
{
    e9f2:	89 c3                	mov    %eax,%ebx
    e9f4:	89 55 f0             	mov    %edx,-0x10(%ebp)
	if(tbuff->segStart[0] != -1)
    e9f7:	0f 84 63 02 00 00    	je     ec60 <rlc_resegment+0x280>
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    e9fd:	b8 02 00 00 00       	mov    $0x2,%eax
    ea02:	e8 fc ff ff ff       	call   ea03 <rlc_resegment+0x23>
		int start = tbuff->segStart[0];
    ea07:	8b 4b 10             	mov    0x10(%ebx),%ecx
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
    ea0a:	8b 73 0c             	mov    0xc(%ebx),%esi
    ea0d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    ea10:	83 c6 02             	add    $0x2,%esi
{
	if(tbuff->segStart[0] != -1)
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
    ea13:	89 c7                	mov    %eax,%edi
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    ea15:	8b 43 50             	mov    0x50(%ebx),%eax
		int headLen = tbuff->headLen + 2;
    ea18:	89 75 ec             	mov    %esi,-0x14(%ebp)
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    ea1b:	8b b3 90 00 00 00    	mov    0x90(%ebx),%esi
	{
		struct RLC_AMPDU_fixhead *fixhead;
		struct RLC_AMPDU_seg_exthead *exthead;
		exthead= (RLC_AMPDU_seg_exthead *)fsm_mem_alloc(sizeof(RLC_AMPDU_seg_exthead));
		int start = tbuff->segStart[0];
		int end = tbuff->segEnd[0];
    ea21:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
    ea24:	29 c8                	sub    %ecx,%eax
    ea26:	83 c0 01             	add    $0x1,%eax
    ea29:	89 45 e8             	mov    %eax,-0x18(%ebp)
		int retxSize = headLen + dataLen;
    ea2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ea2f:	03 45 e8             	add    -0x18(%ebp),%eax
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    ea32:	3b 45 f0             	cmp    -0x10(%ebp),%eax
		int end = tbuff->segEnd[0];
		int headLen = tbuff->headLen + 2;
		int dataLen = end - start + 1;
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
    ea35:	89 75 e0             	mov    %esi,-0x20(%ebp)
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
    ea38:	88 0f                	mov    %cl,(%edi)
		int retxSize = headLen + dataLen;
		unsigned char *tail;
		int count = tbuff->segnum;
		FSM_PKT *skb;
		int i,len;
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
    ea3a:	0f 87 48 01 00 00    	ja     eb88 <rlc_resegment+0x1a8>
		{
			exthead->SO = start;
    ea40:	0f b6 d5             	movzbl %ch,%edx
    ea43:	83 e2 7f             	and    $0x7f,%edx
    ea46:	89 d6                	mov    %edx,%esi
    ea48:	0f b6 57 01          	movzbl 0x1(%edi),%edx
    ea4c:	83 e2 80             	and    $0xffffff80,%edx
    ea4f:	09 f2                	or     %esi,%edx
    ea51:	88 57 01             	mov    %dl,0x1(%edi)
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
    ea54:	8b 75 d8             	mov    -0x28(%ebp),%esi
    ea57:	03 75 ec             	add    -0x14(%ebp),%esi
    ea5a:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    ea5d:	8b 33                	mov    (%ebx),%esi
    ea5f:	8b b6 ac 00 00 00    	mov    0xac(%esi),%esi
    ea65:	01 75 e4             	add    %esi,-0x1c(%ebp)
    ea68:	8b 33                	mov    (%ebx),%esi
    ea6a:	8b b6 a0 00 00 00    	mov    0xa0(%esi),%esi
    ea70:	83 ee 01             	sub    $0x1,%esi
    ea73:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
    ea76:	0f 84 d4 01 00 00    	je     ec50 <rlc_resegment+0x270>
			{
				exthead->LSF = 1;
			}
			else
			{
				exthead->LSF = 0;
    ea7c:	83 e2 7f             	and    $0x7f,%edx
    ea7f:	88 57 01             	mov    %dl,0x1(%edi)
			}
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    ea82:	8b 13                	mov    (%ebx),%edx
    ea84:	8b 92 ac 00 00 00    	mov    0xac(%edx),%edx
    ea8a:	89 55 f0             	mov    %edx,-0x10(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    ea8d:	80 4a 01 40          	orb    $0x40,0x1(%edx)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    ea91:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ea94:	e8 fc ff ff ff       	call   ea95 <rlc_resegment+0xb5>
			fsm_skb_reserve(skb,headLen);
    ea99:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(retxSize);
    ea9c:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    ea9e:	e8 fc ff ff ff       	call   ea9f <rlc_resegment+0xbf>
			tail = fsm_skb_put(skb,dataLen);
    eaa3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eaa6:	89 f0                	mov    %esi,%eax
    eaa8:	e8 fc ff ff ff       	call   eaa9 <rlc_resegment+0xc9>
			fsm_mem_cpy(skb->data,(tbuff->pkt->data + tbuff->headLen  + start),dataLen); 
    eaad:	8b 03                	mov    (%ebx),%eax
    eaaf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    eab2:	8b 53 0c             	mov    0xc(%ebx),%edx
    eab5:	01 ca                	add    %ecx,%edx
    eab7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    eaba:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    eac0:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    eac6:	e8 fc ff ff ff       	call   eac7 <rlc_resegment+0xe7>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4); //kuo zhan tou fu zhi
    eacb:	8b 03                	mov    (%ebx),%eax
    eacd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    ead0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ead6:	83 e9 04             	sub    $0x4,%ecx
    ead9:	89 ca                	mov    %ecx,%edx
    eadb:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    eade:	83 c0 02             	add    $0x2,%eax
    eae1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    eae4:	89 f0                	mov    %esi,%eax
    eae6:	e8 fc ff ff ff       	call   eae7 <rlc_resegment+0x107>
    eaeb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    eaee:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eaf1:	e8 fc ff ff ff       	call   eaf2 <rlc_resegment+0x112>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    eaf6:	ba 02 00 00 00       	mov    $0x2,%edx
    eafb:	89 f0                	mov    %esi,%eax
    eafd:	e8 fc ff ff ff       	call   eafe <rlc_resegment+0x11e>
    eb02:	b9 02 00 00 00       	mov    $0x2,%ecx
    eb07:	89 fa                	mov    %edi,%edx
    eb09:	e8 fc ff ff ff       	call   eb0a <rlc_resegment+0x12a>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    eb0e:	ba 02 00 00 00       	mov    $0x2,%edx
    eb13:	89 f0                	mov    %esi,%eax
    eb15:	e8 fc ff ff ff       	call   eb16 <rlc_resegment+0x136>
    eb1a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eb1d:	b9 02 00 00 00       	mov    $0x2,%ecx
    eb22:	e8 fc ff ff ff       	call   eb23 <rlc_resegment+0x143>

			if(count == 1)
    eb27:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
    eb2b:	0f 84 47 01 00 00    	je     ec78 <rlc_resegment+0x298>
			{
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
    eb31:	7e 3e                	jle    eb71 <rlc_resegment+0x191>
			{				
				for(i=0; i < count-1; i++)
    eb33:	8b 4d e0             	mov    -0x20(%ebp),%ecx
    eb36:	89 d8                	mov    %ebx,%eax
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    eb38:	31 d2                	xor    %edx,%edx
    eb3a:	89 75 ec             	mov    %esi,-0x14(%ebp)
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    eb3d:	83 e9 01             	sub    $0x1,%ecx
** Modified by	:li xu long
** Modified Date:2015-03-07
**------------------------------------------------------------------------------------------
*******************************************************************************************/

FSM_PKT* rlc_resegment(struct AmBuffer *tbuff, u32 sizeFromMac)
    eb40:	89 ce                	mov    %ecx,%esi
    eb42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
    eb48:	8b 48 14             	mov    0x14(%eax),%ecx
    eb4b:	83 c2 01             	add    $0x1,%edx
    eb4e:	89 48 10             	mov    %ecx,0x10(%eax)
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
    eb51:	8b 48 54             	mov    0x54(%eax),%ecx
    eb54:	89 48 50             	mov    %ecx,0x50(%eax)
    eb57:	83 c0 04             	add    $0x4,%eax
				tbuff->segStart[0]=-1;
				tbuff->segEnd[0]=-1;
			}
			else if(count > 1)
			{				
				for(i=0; i < count-1; i++)
    eb5a:	39 f2                	cmp    %esi,%edx
    eb5c:	75 ea                	jne    eb48 <rlc_resegment+0x168>
    eb5e:	8b 75 ec             	mov    -0x14(%ebp),%esi
				{
					tbuff->segStart[i] = tbuff->segStart[i+1];
					tbuff->segEnd[i] = tbuff->segEnd[i+1];
				}
				tbuff->segStart[count-1] = -1;
    eb61:	c7 44 93 10 ff ff ff 	movl   $0xffffffff,0x10(%ebx,%edx,4)
    eb68:	ff 
				tbuff->segEnd[count-1] = -1;
    eb69:	c7 44 93 50 ff ff ff 	movl   $0xffffffff,0x50(%ebx,%edx,4)
    eb70:	ff 
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
			tbuff->segStart[0] += len;
		}
		if(exthead != NULL)
    eb71:	85 ff                	test   %edi,%edi
    eb73:	74 07                	je     eb7c <rlc_resegment+0x19c>
		{
			fsm_mem_free(exthead);
    eb75:	89 f8                	mov    %edi,%eax
    eb77:	e8 fc ff ff ff       	call   eb78 <rlc_resegment+0x198>
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    eb7c:	83 c4 20             	add    $0x20,%esp
		if(exthead != NULL)
		{
			fsm_mem_free(exthead);
			exthead=NULL;
		}
		return skb;
    eb7f:	89 f0                	mov    %esi,%eax
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
	}
}
    eb81:	5b                   	pop    %ebx
    eb82:	5e                   	pop    %esi
    eb83:	5f                   	pop    %edi
    eb84:	5d                   	pop    %ebp
    eb85:	c3                   	ret    
    eb86:	66 90                	xchg   %ax,%ax
				count--;
			}
		}
		else                    //need resegment
		{
			exthead->SO = start;
    eb88:	0f b6 c5             	movzbl %ch,%eax
			exthead->LSF = 0;
    eb8b:	83 e0 7f             	and    $0x7f,%eax
    eb8e:	88 47 01             	mov    %al,0x1(%edi)
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
    eb91:	8b 03                	mov    (%ebx),%eax
    eb93:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    eb99:	89 45 e8             	mov    %eax,-0x18(%ebp)
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
    eb9c:	80 48 01 40          	orb    $0x40,0x1(%eax)
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    eba0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eba3:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    eba6:	e8 fc ff ff ff       	call   eba7 <rlc_resegment+0x1c7>
			fsm_skb_reserve(skb,headLen);
    ebab:	8b 55 ec             	mov    -0x14(%ebp),%edx
			//*(u16 *)exthead = htons(*(u16 *)exthead);
			fixhead = ( RLC_AMPDU_fixhead *)tbuff->pkt->data;
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
    ebae:	89 c6                	mov    %eax,%esi
			fsm_skb_reserve(skb,headLen);
    ebb0:	e8 fc ff ff ff       	call   ebb1 <rlc_resegment+0x1d1>
			len = sizeFromMac - headLen;
    ebb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebb8:	2b 45 ec             	sub    -0x14(%ebp),%eax
			tail = fsm_skb_put(skb,len);
    ebbb:	89 c2                	mov    %eax,%edx
			//*(u16 *)fixhead = ntohs(*(u16 *)fixhead);
			fixhead->RF=1;
			//*(u16 *)fixhead = htons(*(u16 *)fixhead);
			skb = fsm_pkt_create(sizeFromMac);
			fsm_skb_reserve(skb,headLen);
			len = sizeFromMac - headLen;
    ebbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			tail = fsm_skb_put(skb,len);
    ebc0:	89 f0                	mov    %esi,%eax
    ebc2:	e8 fc ff ff ff       	call   ebc3 <rlc_resegment+0x1e3>
			fsm_mem_cpy(skb->data,tbuff->pkt->data + tbuff->headLen  + start,len); 
    ebc7:	8b 03                	mov    (%ebx),%eax
    ebc9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ebcc:	8b 53 0c             	mov    0xc(%ebx),%edx
    ebcf:	01 ca                	add    %ecx,%edx
    ebd1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    ebd4:	03 90 ac 00 00 00    	add    0xac(%eax),%edx
    ebda:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
    ebe0:	e8 fc ff ff ff       	call   ebe1 <rlc_resegment+0x201>
			fsm_mem_cpy(fsm_skb_push(skb,headLen - 4),tbuff->pkt->data + 2,headLen - 4);
    ebe5:	8b 03                	mov    (%ebx),%eax
    ebe7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
    ebea:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ebf0:	83 e9 02             	sub    $0x2,%ecx
    ebf3:	89 ca                	mov    %ecx,%edx
    ebf5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
    ebf8:	83 c0 02             	add    $0x2,%eax
    ebfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    ebfe:	89 f0                	mov    %esi,%eax
    ec00:	e8 fc ff ff ff       	call   ec01 <rlc_resegment+0x221>
    ec05:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    ec08:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec0b:	e8 fc ff ff ff       	call   ec0c <rlc_resegment+0x22c>
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
    ec10:	ba 02 00 00 00       	mov    $0x2,%edx
    ec15:	89 f0                	mov    %esi,%eax
    ec17:	e8 fc ff ff ff       	call   ec18 <rlc_resegment+0x238>
    ec1c:	b9 02 00 00 00       	mov    $0x2,%ecx
    ec21:	89 fa                	mov    %edi,%edx
    ec23:	e8 fc ff ff ff       	call   ec24 <rlc_resegment+0x244>
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);
    ec28:	ba 02 00 00 00       	mov    $0x2,%edx
    ec2d:	89 f0                	mov    %esi,%eax
    ec2f:	e8 fc ff ff ff       	call   ec30 <rlc_resegment+0x250>
    ec34:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec37:	b9 02 00 00 00       	mov    $0x2,%ecx
    ec3c:	e8 fc ff ff ff       	call   ec3d <rlc_resegment+0x25d>
			tbuff->segStart[0] += len;
    ec41:	8b 55 f0             	mov    -0x10(%ebp),%edx
    ec44:	01 53 10             	add    %edx,0x10(%ebx)
    ec47:	e9 25 ff ff ff       	jmp    eb71 <rlc_resegment+0x191>
    ec4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(retxSize <= sizeFromMac)//retransmite pdu segment and need not resegment
		{
			exthead->SO = start;
			if(tbuff->pkt->data + headLen  + end == tbuff->pkt->tail - 1)
			{
				exthead->LSF = 1;
    ec50:	83 ca 80             	or     $0xffffff80,%edx
    ec53:	88 57 01             	mov    %dl,0x1(%edi)
    ec56:	e9 27 fe ff ff       	jmp    ea82 <rlc_resegment+0xa2>
    ec5b:	90                   	nop
    ec5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
		return skb;
	}
	else
	{
		fsm_printf("[RLC][rlc_resegment] segment transfer has been completed");
    ec60:	c7 04 24 44 39 00 00 	movl   $0x3944,(%esp)
    ec67:	e8 fc ff ff ff       	call   ec68 <rlc_resegment+0x288>
	}
}
    ec6c:	83 c4 20             	add    $0x20,%esp
    ec6f:	5b                   	pop    %ebx
    ec70:	5e                   	pop    %esi
    ec71:	5f                   	pop    %edi
    ec72:	5d                   	pop    %ebp
    ec73:	c3                   	ret    
    ec74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			fsm_mem_cpy(fsm_skb_push(skb,2),exthead,2);
			fsm_mem_cpy(fsm_skb_push(skb,2),fixhead,2);

			if(count == 1)
			{
				tbuff->segStart[0]=-1;
    ec78:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
				tbuff->segEnd[0]=-1;
    ec7f:	c7 43 50 ff ff ff ff 	movl   $0xffffffff,0x50(%ebx)
    ec86:	e9 e6 fe ff ff       	jmp    eb71 <rlc_resegment+0x191>
    ec8b:	90                   	nop
    ec8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0000ec90 <rlc_AM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
{
    ec90:	55                   	push   %ebp
    ec91:	89 e5                	mov    %esp,%ebp
    ec93:	57                   	push   %edi
    ec94:	56                   	push   %esi
    ec95:	53                   	push   %ebx
    ec96:	83 ec 44             	sub    $0x44,%esp
    ec99:	e8 fc ff ff ff       	call   ec9a <rlc_AM_reassemble_deliver+0xa>
    ec9e:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eca1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    eca4:	e8 fc ff ff ff       	call   eca5 <rlc_AM_reassemble_deliver+0x15>
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    eca9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	struct RLC_AMPDU_fixhead *pduhdr;
	struct AmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	
	SV_PTR_GET(rlc_mac_sv);
    ecac:	89 45 e0             	mov    %eax,-0x20(%ebp)
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
    ecaf:	0f bf 82 ee 22 00 00 	movswl 0x22ee(%edx),%eax
    ecb6:	89 44 24 08          	mov    %eax,0x8(%esp)
    ecba:	0f bf 82 f4 22 00 00 	movswl 0x22f4(%edx),%eax
    ecc1:	c7 04 24 80 39 00 00 	movl   $0x3980,(%esp)
    ecc8:	89 44 24 04          	mov    %eax,0x4(%esp)
    eccc:	e8 fc ff ff ff       	call   eccd <rlc_AM_reassemble_deliver+0x3d>
	u16 h=(amIns->vr_h + 1)%1024;
    ecd1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    ecd4:	0f bf 81 ee 22 00 00 	movswl 0x22ee(%ecx),%eax
    ecdb:	83 c0 01             	add    $0x1,%eax
    ecde:	89 c2                	mov    %eax,%edx
    ece0:	c1 fa 1f             	sar    $0x1f,%edx
    ece3:	c1 ea 16             	shr    $0x16,%edx
    ece6:	01 d0                	add    %edx,%eax
    ece8:	25 ff 03 00 00       	and    $0x3ff,%eax
    eced:	29 d0                	sub    %edx,%eax
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    ecef:	0f b7 c0             	movzwl %ax,%eax
    ecf2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    ecf5:	0f b7 81 f4 22 00 00 	movzwl 0x22f4(%ecx),%eax
    ecfc:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    ecff:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    ed05:	89 d0                	mov    %edx,%eax
    ed07:	c1 f8 1f             	sar    $0x1f,%eax
    ed0a:	c1 e8 16             	shr    $0x16,%eax
    ed0d:	01 c2                	add    %eax,%edx
    ed0f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    ed15:	29 c2                	sub    %eax,%edx
    ed17:	85 d2                	test   %edx,%edx
    ed19:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ed1c:	0f 8e 16 04 00 00    	jle    f138 <rlc_AM_reassemble_deliver+0x4a8>
    ed22:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    ed25:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    ed28:	e9 8d 00 00 00       	jmp    edba <rlc_AM_reassemble_deliver+0x12a>
    ed2d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    ed30:	84 c0                	test   %al,%al
    ed32:	0f 84 88 01 00 00    	je     eec0 <rlc_AM_reassemble_deliver+0x230>
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
					//fsm_octets_print(tbuff->pkt->data,64);
				}
			}
			else if(pduhdr->E==1)
    ed38:	83 e2 04             	and    $0x4,%edx
    ed3b:	0f 85 e7 01 00 00    	jne    ef28 <rlc_AM_reassemble_deliver+0x298>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    ed41:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
    ed47:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    ed4d:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    ed50:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
				{
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
    ed52:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    ed54:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
    ed5b:	01 10 00 
	entry->prev = LIST_POISON2;
    ed5e:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
    ed65:	02 20 00 
    ed68:	e8 fc ff ff ff       	call   ed69 <rlc_AM_reassemble_deliver+0xd9>
					tbuff = NULL;
				}
			if(icimsg != NULL)
    ed6d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    ed70:	85 c9                	test   %ecx,%ecx
    ed72:	74 08                	je     ed7c <rlc_AM_reassemble_deliver+0xec>
			{
				fsm_mem_free(icimsg);
    ed74:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ed77:	e8 fc ff ff ff       	call   ed78 <rlc_AM_reassemble_deliver+0xe8>
				icimsg=NULL;
			}
			amIns->amRecvWindow[i]=NULL;
    ed7c:	8b 5d d8             	mov    -0x28(%ebp),%ebx
    ed7f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ed82:	c7 44 98 0c 00 00 00 	movl   $0x0,0xc(%eax,%ebx,4)
    ed89:	00 
	
	SV_PTR_GET(rlc_mac_sv);
	fsm_printf("[RLC][rlc_AM_reassemble_deliver] vr_r=%d, vr_h=%d\n",amIns->vr_r,amIns->vr_h);
	u16 h=(amIns->vr_h + 1)%1024;
	u16 r=amIns->vr_r;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    ed8a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ed8e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    ed95:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed98:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    ed9b:	05 00 04 00 00       	add    $0x400,%eax
    eda0:	89 c2                	mov    %eax,%edx
    eda2:	c1 fa 1f             	sar    $0x1f,%edx
    eda5:	c1 ea 16             	shr    $0x16,%edx
    eda8:	01 d0                	add    %edx,%eax
    edaa:	25 ff 03 00 00       	and    $0x3ff,%eax
    edaf:	29 d0                	sub    %edx,%eax
    edb1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    edb4:	0f 8d 7e 03 00 00    	jge    f138 <rlc_AM_reassemble_deliver+0x4a8>
	//for(i=0; i<=AM_WINDOW_SIZE; i++)
	{
		if(amIns->amRecvWindow[i] != NULL)
    edba:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    edbd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    edc0:	81 c3 98 04 00 00    	add    $0x498,%ebx
    edc6:	8b 74 98 0c          	mov    0xc(%eax,%ebx,4),%esi
    edca:	89 5d d8             	mov    %ebx,-0x28(%ebp)
    edcd:	85 f6                	test   %esi,%esi
    edcf:	74 b9                	je     ed8a <rlc_AM_reassemble_deliver+0xfa>
		{
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    edd1:	8b 06                	mov    (%esi),%eax
    edd3:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    edd9:	b8 02 00 00 00       	mov    $0x2,%eax
    edde:	e8 fc ff ff ff       	call   eddf <rlc_AM_reassemble_deliver+0x14f>
    ede3:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    ede6:	8b 43 02             	mov    0x2(%ebx),%eax
    ede9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    edec:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    edee:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    edf2:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    edf5:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    edf7:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = amIns->amRecvWindow[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_AMPDU_fixhead*)tbuff->pkt->data;
    edfc:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    ee02:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    ee05:	e8 fc ff ff ff       	call   ee06 <rlc_AM_reassemble_deliver+0x176>
    		fsm_printf("[RLC][rlc_AM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    ee0a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ee0e:	c0 e8 03             	shr    $0x3,%al
    ee11:	83 e0 01             	and    $0x1,%eax
    ee14:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ee18:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ee1c:	c0 e8 04             	shr    $0x4,%al
    ee1f:	83 e0 01             	and    $0x1,%eax
    ee22:	89 44 24 08          	mov    %eax,0x8(%esp)
    ee26:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ee2a:	c7 04 24 b4 39 00 00 	movl   $0x39b4,(%esp)
    ee31:	c0 e8 02             	shr    $0x2,%al
    ee34:	83 e0 01             	and    $0x1,%eax
    ee37:	89 44 24 04          	mov    %eax,0x4(%esp)
    ee3b:	e8 fc ff ff ff       	call   ee3c <rlc_AM_reassemble_deliver+0x1ac>
			//fsm_octets_print(tbuff->pkt->data,64);
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    ee40:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    ee44:	89 d0                	mov    %edx,%eax
    ee46:	83 e0 14             	and    $0x14,%eax
    ee49:	3c 10                	cmp    $0x10,%al
    ee4b:	0f 85 df fe ff ff    	jne    ed30 <rlc_AM_reassemble_deliver+0xa0>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ee51:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ee54:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    ee58:	66 83 f9 ff          	cmp    $0xffff,%cx
    ee5c:	74 2f                	je     ee8d <rlc_AM_reassemble_deliver+0x1fd>
    ee5e:	0f bf c9             	movswl %cx,%ecx
    ee61:	0f b6 13             	movzbl (%ebx),%edx
    ee64:	83 c1 01             	add    $0x1,%ecx
    ee67:	89 c8                	mov    %ecx,%eax
    ee69:	c1 f8 1f             	sar    $0x1f,%eax
    ee6c:	c1 e8 16             	shr    $0x16,%eax
    ee6f:	01 c1                	add    %eax,%ecx
    ee71:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ee77:	29 c1                	sub    %eax,%ecx
    ee79:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ee7d:	83 e0 03             	and    $0x3,%eax
    ee80:	c1 e0 08             	shl    $0x8,%eax
    ee83:	09 d0                	or     %edx,%eax
    ee85:	39 c1                	cmp    %eax,%ecx
    ee87:	0f 84 e3 03 00 00    	je     f270 <rlc_AM_reassemble_deliver+0x5e0>
						//fsm_octets_print(new_skb->data,new_skb->len);
					}
				}
				else
				{
					SV(countDropPacket)++;
    ee8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ee90:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    ee97:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ee9a:	e8 fc ff ff ff       	call   ee9b <rlc_AM_reassemble_deliver+0x20b>
                    
					if(tbuff->pkt != NULL)
    ee9f:	8b 06                	mov    (%esi),%eax
    eea1:	85 c0                	test   %eax,%eax
    eea3:	0f 84 98 fe ff ff    	je     ed41 <rlc_AM_reassemble_deliver+0xb1>
					{
						fsm_pkt_destroy(tbuff->pkt);
    eea9:	e8 fc ff ff ff       	call   eeaa <rlc_AM_reassemble_deliver+0x21a>
						tbuff->pkt = NULL;
    eeae:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    eeb4:	e9 88 fe ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
    eeb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
					}		
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{
				clear_left_pdu(pdu_left);
    eec0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    eec3:	e8 fc ff ff ff       	call   eec4 <rlc_AM_reassemble_deliver+0x234>
				if(pduhdr->FIsecond==0)
    eec8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    eecb:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    eecf:	0f 85 6b 02 00 00    	jne    f140 <rlc_AM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    eed5:	8b 1e                	mov    (%esi),%ebx
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    eed7:	89 d8                	mov    %ebx,%eax
    eed9:	e8 fc ff ff ff       	call   eeda <rlc_AM_reassemble_deliver+0x24a>
    eede:	83 f8 01             	cmp    $0x1,%eax
    eee1:	0f 86 9f 04 00 00    	jbe    f386 <rlc_AM_reassemble_deliver+0x6f6>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    eee7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eeea:	b9 02 00 00 00       	mov    $0x2,%ecx
    eeef:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    eef5:	e8 fc ff ff ff       	call   eef6 <rlc_AM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    eefa:	89 d8                	mov    %ebx,%eax
    eefc:	ba 06 00 00 00       	mov    $0x6,%edx
    ef01:	e8 fc ff ff ff       	call   ef02 <rlc_AM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					//list_del(&tbuff->list);
					//fsm_mem_free(tbuff);
					//tbuff=NULL;
					SV(countSendToUpper)++;
    ef06:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ef09:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP2\n");
    ef10:	c7 04 24 78 3a 00 00 	movl   $0x3a78,(%esp)
    ef17:	e8 fc ff ff ff       	call   ef18 <rlc_AM_reassemble_deliver+0x288>
    ef1c:	e9 20 fe ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
    ef21:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    ef28:	b8 40 00 00 00       	mov    $0x40,%eax
    ef2d:	e8 fc ff ff ff       	call   ef2e <rlc_AM_reassemble_deliver+0x29e>
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ef32:	31 c9                	xor    %ecx,%ecx
    ef34:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    ef36:	89 45 d0             	mov    %eax,-0x30(%ebp)
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ef39:	89 04 24             	mov    %eax,(%esp)
    ef3c:	b8 01 00 00 00       	mov    $0x1,%eax
    ef41:	e8 fc ff ff ff       	call   ef42 <rlc_AM_reassemble_deliver+0x2b2>
               
				if(pduhdr->FIfirst==1)
    ef46:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt PduhdrExt,*pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				//pPduhdrExt = &PduhdrExt;
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
    ef49:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
               
				if(pduhdr->FIfirst==1)
    ef4d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    ef51:	0f 84 81 02 00 00    	je     f1d8 <rlc_AM_reassemble_deliver+0x548>
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    ef57:	8b 55 c0             	mov    -0x40(%ebp),%edx
    ef5a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    ef5e:	66 83 f8 ff          	cmp    $0xffff,%ax
    ef62:	74 2d                	je     ef91 <rlc_AM_reassemble_deliver+0x301>
    ef64:	98                   	cwtl   
    ef65:	0f b6 13             	movzbl (%ebx),%edx
    ef68:	8d 48 01             	lea    0x1(%eax),%ecx
    ef6b:	89 c8                	mov    %ecx,%eax
    ef6d:	c1 f8 1f             	sar    $0x1f,%eax
    ef70:	c1 e8 16             	shr    $0x16,%eax
    ef73:	01 c1                	add    %eax,%ecx
    ef75:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    ef7b:	29 c1                	sub    %eax,%ecx
    ef7d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    ef81:	83 e0 03             	and    $0x3,%eax
    ef84:	c1 e0 08             	shl    $0x8,%eax
    ef87:	09 d0                	or     %edx,%eax
    ef89:	39 c1                	cmp    %eax,%ecx
    ef8b:	0f 84 08 04 00 00    	je     f399 <rlc_AM_reassemble_deliver+0x709>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    ef91:	8b 45 e0             	mov    -0x20(%ebp),%eax
    ef94:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    ef9b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    ef9e:	e8 fc ff ff ff       	call   ef9f <rlc_AM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    efa3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    efa6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    efaa:	8b 06                	mov    (%esi),%eax
    efac:	e8 fc ff ff ff       	call   efad <rlc_AM_reassemble_deliver+0x31d>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    efb1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    efb5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    efb7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    efbe:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    efc2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_AM_reassemble_deliver(struct AM_Instance *amIns, struct pduLeft *pdu_left)
    efc5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    efc8:	7f 47                	jg     f011 <rlc_AM_reassemble_deliver+0x381>
    efca:	e9 ab 00 00 00       	jmp    f07a <rlc_AM_reassemble_deliver+0x3ea>
    efcf:	90                   	nop
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    efd0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    efd6:	b9 02 00 00 00       	mov    $0x2,%ecx
    efdb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    efde:	e8 fc ff ff ff       	call   efdf <rlc_AM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    efe3:	89 d8                	mov    %ebx,%eax
    efe5:	ba 06 00 00 00       	mov    $0x6,%edx
    efea:	e8 fc ff ff ff       	call   efeb <rlc_AM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    efef:	8b 45 e0             	mov    -0x20(%ebp),%eax
    eff2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    eff9:	c7 04 24 14 3b 00 00 	movl   $0x3b14,(%esp)
    f000:	e8 fc ff ff ff       	call   f001 <rlc_AM_reassemble_deliver+0x371>
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f005:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
    f008:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
                    //fsm_octets_print(skb->data,64);

				}
               
				int j;
				for(j=1;  j<count;j++)
    f00c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f00f:	74 67                	je     f078 <rlc_AM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f011:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f014:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f017:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f01c:	89 d8                	mov    %ebx,%eax
    f01e:	e8 fc ff ff ff       	call   f01f <rlc_AM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f023:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1;  j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f025:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f027:	e8 fc ff ff ff       	call   f028 <rlc_AM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f02c:	8b 07                	mov    (%edi),%eax
    f02e:	89 da                	mov    %ebx,%edx
    f030:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f036:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f039:	89 f0                	mov    %esi,%eax
    f03b:	e8 fc ff ff ff       	call   f03c <rlc_AM_reassemble_deliver+0x3ac>
    f040:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f043:	89 d9                	mov    %ebx,%ecx
    f045:	e8 fc ff ff ff       	call   f046 <rlc_AM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f04a:	8b 07                	mov    (%edi),%eax
    f04c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f04e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f050:	e8 fc ff ff ff       	call   f051 <rlc_AM_reassemble_deliver+0x3c1>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f055:	89 f0                	mov    %esi,%eax
    f057:	e8 fc ff ff ff       	call   f058 <rlc_AM_reassemble_deliver+0x3c8>
    f05c:	83 f8 01             	cmp    $0x1,%eax
    f05f:	0f 87 6b ff ff ff    	ja     efd0 <rlc_AM_reassemble_deliver+0x340>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f065:	ba 02 00 00 00       	mov    $0x2,%edx
    f06a:	89 f0                	mov    %esi,%eax
    f06c:	e8 fc ff ff ff       	call   f06d <rlc_AM_reassemble_deliver+0x3dd>
    f071:	89 c3                	mov    %eax,%ebx
    f073:	e9 58 ff ff ff       	jmp    efd0 <rlc_AM_reassemble_deliver+0x340>
    f078:	89 fe                	mov    %edi,%esi
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f07a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f07d:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f07f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f083:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f087:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP5\n");
					//fsm_octets_print(skb->data,64);
                }
                
				if(pduhdr->FIsecond==0)
    f089:	0f 85 e1 00 00 00    	jne    f170 <rlc_AM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f08f:	e8 fc ff ff ff       	call   f090 <rlc_AM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f094:	89 da                	mov    %ebx,%edx
                }
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f096:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f098:	e8 fc ff ff ff       	call   f099 <rlc_AM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f09d:	8b 06                	mov    (%esi),%eax
    f09f:	89 da                	mov    %ebx,%edx
    f0a1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f0a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f0aa:	89 f8                	mov    %edi,%eax
    f0ac:	e8 fc ff ff ff       	call   f0ad <rlc_AM_reassemble_deliver+0x41d>
    f0b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f0b4:	89 d9                	mov    %ebx,%ecx
    f0b6:	e8 fc ff ff ff       	call   f0b7 <rlc_AM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f0bb:	8b 06                	mov    (%esi),%eax
    f0bd:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f0bf:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f0c1:	e8 fc ff ff ff       	call   f0c2 <rlc_AM_reassemble_deliver+0x432>
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f0c6:	89 f8                	mov    %edi,%eax
    f0c8:	e8 fc ff ff ff       	call   f0c9 <rlc_AM_reassemble_deliver+0x439>
    f0cd:	83 f8 01             	cmp    $0x1,%eax
    f0d0:	0f 86 9d 02 00 00    	jbe    f373 <rlc_AM_reassemble_deliver+0x6e3>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f0d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f0d9:	b9 02 00 00 00       	mov    $0x2,%ecx
    f0de:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f0e4:	e8 fc ff ff ff       	call   f0e5 <rlc_AM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f0e9:	ba 06 00 00 00       	mov    $0x6,%edx
    f0ee:	89 d8                	mov    %ebx,%eax
    f0f0:	e8 fc ff ff ff       	call   f0f1 <rlc_AM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f0f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f0f8:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP6\n");
    f0ff:	c7 04 24 48 3b 00 00 	movl   $0x3b48,(%esp)
    f106:	e8 fc ff ff ff       	call   f107 <rlc_AM_reassemble_deliver+0x477>
					//fsm_octets_print(skb->data,64);

					//list_del(&tbuff->list);
					if(tbuff->pkt != NULL)
    f10b:	8b 06                	mov    (%esi),%eax
    f10d:	85 c0                	test   %eax,%eax
    f10f:	74 0b                	je     f11c <rlc_AM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
                    {
                    	fsm_pkt_destroy(tbuff->pkt);
    f111:	e8 fc ff ff ff       	call   f112 <rlc_AM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    f116:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					{
						fsm_mem_free(tbuff);
						tbuff = NULL;
					}*/
				}
				if(pPduhdrExt != NULL)
    f11c:	8b 5d d0             	mov    -0x30(%ebp),%ebx
    f11f:	85 db                	test   %ebx,%ebx
    f121:	0f 84 1a fc ff ff    	je     ed41 <rlc_AM_reassemble_deliver+0xb1>
				{
					fsm_mem_free(pPduhdrExt);
    f127:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f12a:	e8 fc ff ff ff       	call   f12b <rlc_AM_reassemble_deliver+0x49b>
    f12f:	e9 0d fc ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
    f134:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			amIns->amRecvWindow[i]=NULL;
		}//end if
	}//end for
	FOUT;
}
    f138:	83 c4 44             	add    $0x44,%esp
    f13b:	5b                   	pop    %ebx
    f13c:	5e                   	pop    %esi
    f13d:	5f                   	pop    %edi
    f13e:	5d                   	pop    %ebp
    f13f:	c3                   	ret    
					//fsm_printf("[RLC][rlc_AM_reassemble_deliver] data len = %d\n", skb->len);
					//fsm_octets_print(skb->data,skb->len);
				}
				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    f140:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f143:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f147:	0f b6 13             	movzbl (%ebx),%edx
    f14a:	83 e0 03             	and    $0x3,%eax
    f14d:	c1 e0 08             	shl    $0x8,%eax
    f150:	09 d0                	or     %edx,%eax
    f152:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f155:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = tbuff->pkt;
    f159:	8b 06                	mov    (%esi),%eax
    f15b:	89 42 04             	mov    %eax,0x4(%edx)
					/*list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;*/
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f15e:	c7 04 24 40 3a 00 00 	movl   $0x3a40,(%esp)
    f165:	e8 fc ff ff ff       	call   f166 <rlc_AM_reassemble_deliver+0x4d6>
    f16a:	e9 d2 fb ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
    f16f:	90                   	nop
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f170:	e8 fc ff ff ff       	call   f171 <rlc_AM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f175:	89 da                	mov    %ebx,%edx
					}	*/			
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f177:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f179:	e8 fc ff ff ff       	call   f17a <rlc_AM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f17e:	8b 06                	mov    (%esi),%eax
    f180:	89 da                	mov    %ebx,%edx
    f182:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f188:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f18b:	89 f8                	mov    %edi,%eax
    f18d:	e8 fc ff ff ff       	call   f18e <rlc_AM_reassemble_deliver+0x4fe>
    f192:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f195:	89 d9                	mov    %ebx,%ecx
    f197:	e8 fc ff ff ff       	call   f198 <rlc_AM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f19c:	8b 06                	mov    (%esi),%eax
    f19e:	8b 50 50             	mov    0x50(%eax),%edx
    f1a1:	e8 fc ff ff ff       	call   f1a2 <rlc_AM_reassemble_deliver+0x512>

					pdu_left->SN_Left = pduhdr->SN;
    f1a6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f1a9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f1ad:	0f b6 13             	movzbl (%ebx),%edx
    f1b0:	83 e0 03             	and    $0x3,%eax
    f1b3:	c1 e0 08             	shl    $0x8,%eax
    f1b6:	09 d0                	or     %edx,%eax
    f1b8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f1bb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f1bf:	89 7a 04             	mov    %edi,0x4(%edx)
                    //list_del(&tbuff->list);
                    if(tbuff->pkt != NULL)
    f1c2:	8b 06                	mov    (%esi),%eax
    f1c4:	85 c0                	test   %eax,%eax
    f1c6:	0f 85 45 ff ff ff    	jne    f111 <rlc_AM_reassemble_deliver+0x481>
    f1cc:	e9 4b ff ff ff       	jmp    f11c <rlc_AM_reassemble_deliver+0x48c>
    f1d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f1d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f1db:	e8 fc ff ff ff       	call   f1dc <rlc_AM_reassemble_deliver+0x54c>
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f1e0:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f1e3:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f1e7:	89 d8                	mov    %ebx,%eax
    f1e9:	e8 fc ff ff ff       	call   f1ea <rlc_AM_reassemble_deliver+0x55a>

					fsm_skb_reserve(new_skb,length);
    f1ee:	89 da                	mov    %ebx,%edx
				}
				else
				{
					clear_left_pdu(pdu_left);
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f1f0:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
    f1f2:	e8 fc ff ff ff       	call   f1f3 <rlc_AM_reassemble_deliver+0x563>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f1f7:	8b 06                	mov    (%esi),%eax
    f1f9:	89 da                	mov    %ebx,%edx
    f1fb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f201:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f204:	89 f8                	mov    %edi,%eax
    f206:	e8 fc ff ff ff       	call   f207 <rlc_AM_reassemble_deliver+0x577>
    f20b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f20e:	89 d9                	mov    %ebx,%ecx
    f210:	e8 fc ff ff ff       	call   f211 <rlc_AM_reassemble_deliver+0x581>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f215:	8b 06                	mov    (%esi),%eax
    f217:	89 da                	mov    %ebx,%edx


					skb = new_skb;
    f219:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f21b:	e8 fc ff ff ff       	call   f21c <rlc_AM_reassemble_deliver+0x58c>


					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f220:	89 f8                	mov    %edi,%eax
    f222:	e8 fc ff ff ff       	call   f223 <rlc_AM_reassemble_deliver+0x593>
    f227:	83 f8 01             	cmp    $0x1,%eax
    f22a:	0f 86 34 02 00 00    	jbe    f464 <rlc_AM_reassemble_deliver+0x7d4>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f230:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f233:	b9 02 00 00 00       	mov    $0x2,%ecx
    f238:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f23e:	e8 fc ff ff ff       	call   f23f <rlc_AM_reassemble_deliver+0x5af>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f243:	89 d8                	mov    %ebx,%eax
    f245:	ba 06 00 00 00       	mov    $0x6,%edx
    f24a:	e8 fc ff ff ff       	call   f24b <rlc_AM_reassemble_deliver+0x5bb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f24f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f252:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP4\n");
    f259:	c7 04 24 e0 3a 00 00 	movl   $0x3ae0,(%esp)
    f260:	e8 fc ff ff ff       	call   f261 <rlc_AM_reassemble_deliver+0x5d1>
    f265:	e9 47 fd ff ff       	jmp    efb1 <rlc_AM_reassemble_deliver+0x321>
    f26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    f270:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    f273:	8b 16                	mov    (%esi),%edx
    f275:	8b 41 04             	mov    0x4(%ecx),%eax
    f278:	8b 40 50             	mov    0x50(%eax),%eax
    f27b:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    f27f:	0f b7 d8             	movzwl %ax,%ebx
    f282:	89 d8                	mov    %ebx,%eax
    f284:	e8 fc ff ff ff       	call   f285 <rlc_AM_reassemble_deliver+0x5f5>
					fsm_skb_reserve(new_skb,length);
    f289:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    f28b:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f28d:	e8 fc ff ff ff       	call   f28e <rlc_AM_reassemble_deliver+0x5fe>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    f292:	8b 06                	mov    (%esi),%eax
    f294:	8b 58 50             	mov    0x50(%eax),%ebx
    f297:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f29d:	89 f8                	mov    %edi,%eax
    f29f:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f2a2:	89 da                	mov    %ebx,%edx
    f2a4:	e8 fc ff ff ff       	call   f2a5 <rlc_AM_reassemble_deliver+0x615>
    f2a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f2ac:	89 d9                	mov    %ebx,%ecx
    f2ae:	e8 fc ff ff ff       	call   f2af <rlc_AM_reassemble_deliver+0x61f>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f2b3:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f2b6:	8b 42 04             	mov    0x4(%edx),%eax
    f2b9:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f2bf:	8b 58 50             	mov    0x50(%eax),%ebx
    f2c2:	89 f8                	mov    %edi,%eax
    f2c4:	89 55 f0             	mov    %edx,-0x10(%ebp)
    f2c7:	89 da                	mov    %ebx,%edx
    f2c9:	e8 fc ff ff ff       	call   f2ca <rlc_AM_reassemble_deliver+0x63a>
    f2ce:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f2d1:	89 d9                	mov    %ebx,%ecx
    f2d3:	e8 fc ff ff ff       	call   f2d4 <rlc_AM_reassemble_deliver+0x644>
					clear_left_pdu(pdu_left);
    f2d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f2db:	e8 fc ff ff ff       	call   f2dc <rlc_AM_reassemble_deliver+0x64c>
					if(tbuff->pkt != NULL)
    f2e0:	8b 06                	mov    (%esi),%eax
    f2e2:	85 c0                	test   %eax,%eax
    f2e4:	74 0b                	je     f2f1 <rlc_AM_reassemble_deliver+0x661>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f2e6:	e8 fc ff ff ff       	call   f2e7 <rlc_AM_reassemble_deliver+0x657>
						tbuff->pkt = NULL;							
    f2eb:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    f2f1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f2f4:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f2f8:	75 4c                	jne    f346 <rlc_AM_reassemble_deliver+0x6b6>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f2fa:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;							
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    f2fc:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f2fe:	e8 fc ff ff ff       	call   f2ff <rlc_AM_reassemble_deliver+0x66f>
    f303:	83 f8 01             	cmp    $0x1,%eax
    f306:	0f 86 6b 01 00 00    	jbe    f477 <rlc_AM_reassemble_deliver+0x7e7>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f30c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f30f:	b9 02 00 00 00       	mov    $0x2,%ecx
    f314:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f31a:	e8 fc ff ff ff       	call   f31b <rlc_AM_reassemble_deliver+0x68b>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f31f:	89 d8                	mov    %ebx,%eax
    f321:	ba 06 00 00 00       	mov    $0x6,%edx
    f326:	e8 fc ff ff ff       	call   f327 <rlc_AM_reassemble_deliver+0x697>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f32b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f32e:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP1\n");
    f335:	c7 04 24 0c 3a 00 00 	movl   $0x3a0c,(%esp)
    f33c:	e8 fc ff ff ff       	call   f33d <rlc_AM_reassemble_deliver+0x6ad>
    f341:	e9 fb f9 ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
						//fsm_octets_print(skb->data,skb->len);
						//list_del(&tbuff->list);//20150123
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    f346:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    f349:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f34d:	0f b6 13             	movzbl (%ebx),%edx
    f350:	83 e0 03             	and    $0x3,%eax
    f353:	c1 e0 08             	shl    $0x8,%eax
    f356:	09 d0                	or     %edx,%eax
    f358:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f35b:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    f35f:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] not a complete SDU\n");
    f362:	c7 04 24 40 3a 00 00 	movl   $0x3a40,(%esp)
    f369:	e8 fc ff ff ff       	call   f36a <rlc_AM_reassemble_deliver+0x6da>
    f36e:	e9 ce f9 ff ff       	jmp    ed41 <rlc_AM_reassemble_deliver+0xb1>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f373:	ba 02 00 00 00       	mov    $0x2,%edx
    f378:	89 f8                	mov    %edi,%eax
    f37a:	e8 fc ff ff ff       	call   f37b <rlc_AM_reassemble_deliver+0x6eb>
    f37f:	89 c3                	mov    %eax,%ebx
    f381:	e9 50 fd ff ff       	jmp    f0d6 <rlc_AM_reassemble_deliver+0x446>
				if(pduhdr->FIsecond==0)
				{
					skb = tbuff->pkt;
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f386:	89 d8                	mov    %ebx,%eax
    f388:	ba 02 00 00 00       	mov    $0x2,%edx
    f38d:	e8 fc ff ff ff       	call   f38e <rlc_AM_reassemble_deliver+0x6fe>
    f392:	89 c3                	mov    %eax,%ebx
    f394:	e9 4e fb ff ff       	jmp    eee7 <rlc_AM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    f399:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f39c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    f39f:	8b 42 04             	mov    0x4(%edx),%eax
    f3a2:	8b 40 50             	mov    0x50(%eax),%eax
    f3a5:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    f3a9:	0f b7 d8             	movzwl %ax,%ebx
    f3ac:	89 d8                	mov    %ebx,%eax
    f3ae:	e8 fc ff ff ff       	call   f3af <rlc_AM_reassemble_deliver+0x71f>

						fsm_skb_reserve(new_skb,length);
    f3b3:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    f3b5:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
    f3b7:	e8 fc ff ff ff       	call   f3b8 <rlc_AM_reassemble_deliver+0x728>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    f3bc:	8b 06                	mov    (%esi),%eax
    f3be:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f3c4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    f3c7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f3ca:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f3ce:	89 f8                	mov    %edi,%eax
    f3d0:	89 da                	mov    %ebx,%edx
    f3d2:	e8 fc ff ff ff       	call   f3d3 <rlc_AM_reassemble_deliver+0x743>
    f3d7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f3da:	89 d9                	mov    %ebx,%ecx
    f3dc:	e8 fc ff ff ff       	call   f3dd <rlc_AM_reassemble_deliver+0x74d>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f3e1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f3e4:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f3e8:	8b 06                	mov    (%esi),%eax
    f3ea:	e8 fc ff ff ff       	call   f3eb <rlc_AM_reassemble_deliver+0x75b>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f3ef:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f3f2:	8b 42 04             	mov    0x4(%edx),%eax
    f3f5:	8b 58 50             	mov    0x50(%eax),%ebx
    f3f8:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    f3fe:	89 f8                	mov    %edi,%eax
    f400:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f403:	89 da                	mov    %ebx,%edx
    f405:	e8 fc ff ff ff       	call   f406 <rlc_AM_reassemble_deliver+0x776>
    f40a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    f40d:	89 d9                	mov    %ebx,%ecx
						skb = new_skb;
    f40f:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    f411:	e8 fc ff ff ff       	call   f412 <rlc_AM_reassemble_deliver+0x782>
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f416:	89 f8                	mov    %edi,%eax
    f418:	e8 fc ff ff ff       	call   f419 <rlc_AM_reassemble_deliver+0x789>
    f41d:	83 f8 01             	cmp    $0x1,%eax
    f420:	76 68                	jbe    f48a <rlc_AM_reassemble_deliver+0x7fa>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f422:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f425:	b9 02 00 00 00       	mov    $0x2,%ecx
    f42a:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f430:	e8 fc ff ff ff       	call   f431 <rlc_AM_reassemble_deliver+0x7a1>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    f435:	ba 06 00 00 00       	mov    $0x6,%edx
    f43a:	89 d8                	mov    %ebx,%eax
    f43c:	e8 fc ff ff ff       	call   f43d <rlc_AM_reassemble_deliver+0x7ad>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    f441:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f444:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_AM_reassemble_deliver] <--send to PDCP3\n");
    f44b:	c7 04 24 ac 3a 00 00 	movl   $0x3aac,(%esp)
    f452:	e8 fc ff ff ff       	call   f453 <rlc_AM_reassemble_deliver+0x7c3>
						//fsm_octets_print(skb->data,64);
						clear_left_pdu(pdu_left);
    f457:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f45a:	e8 fc ff ff ff       	call   f45b <rlc_AM_reassemble_deliver+0x7cb>
				count = get_AmPduhdExt(1,tbuff,0,pPduhdrExt); 
               
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    f45f:	e9 4d fb ff ff       	jmp    efb1 <rlc_AM_reassemble_deliver+0x321>

					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f464:	ba 02 00 00 00       	mov    $0x2,%edx
    f469:	89 f8                	mov    %edi,%eax
    f46b:	e8 fc ff ff ff       	call   f46c <rlc_AM_reassemble_deliver+0x7dc>
    f470:	89 c3                	mov    %eax,%ebx
    f472:	e9 b9 fd ff ff       	jmp    f230 <rlc_AM_reassemble_deliver+0x5a0>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f477:	ba 02 00 00 00       	mov    $0x2,%edx
    f47c:	89 f8                	mov    %edi,%eax
    f47e:	e8 fc ff ff ff       	call   f47f <rlc_AM_reassemble_deliver+0x7ef>
    f483:	89 c3                	mov    %eax,%ebx
    f485:	e9 82 fe ff ff       	jmp    f30c <rlc_AM_reassemble_deliver+0x67c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f48a:	ba 02 00 00 00       	mov    $0x2,%edx
    f48f:	89 f8                	mov    %edi,%eax
    f491:	e8 fc ff ff ff       	call   f492 <rlc_AM_reassemble_deliver+0x802>
    f496:	89 c3                	mov    %eax,%ebx
    f498:	eb 88                	jmp    f422 <rlc_AM_reassemble_deliver+0x792>
    f49a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0000f4a0 <rlc_UM_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    f4a0:	55                   	push   %ebp
    f4a1:	89 e5                	mov    %esp,%ebp
    f4a3:	57                   	push   %edi
    f4a4:	56                   	push   %esi
    f4a5:	53                   	push   %ebx
    f4a6:	83 ec 44             	sub    $0x44,%esp
    f4a9:	e8 fc ff ff ff       	call   f4aa <rlc_UM_reassemble_deliver+0xa>
    f4ae:	89 55 c0             	mov    %edx,-0x40(%ebp)
    f4b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
    f4b4:	c7 04 24 7c 3b 00 00 	movl   $0x3b7c,(%esp)
    f4bb:	e8 fc ff ff ff       	call   f4bc <rlc_UM_reassemble_deliver+0x1c>
	SV_PTR_GET(rlc_mac_sv);
    f4c0:	e8 fc ff ff ff       	call   f4c1 <rlc_UM_reassemble_deliver+0x21>
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f4c5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f4c8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fsm_printf("[RLC] Enter rlc_UM_reassemble_deliver\n ");
	SV_PTR_GET(rlc_mac_sv);
    f4cb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	u16 length,count,i;
	struct RLC_UM_size10_subhead *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
    f4ce:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    f4d5:	83 c0 01             	add    $0x1,%eax
    f4d8:	89 c2                	mov    %eax,%edx
    f4da:	c1 fa 1f             	sar    $0x1f,%edx
    f4dd:	c1 ea 16             	shr    $0x16,%edx
    f4e0:	01 d0                	add    %edx,%eax
    f4e2:	25 ff 03 00 00       	and    $0x3ff,%eax
    f4e7:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f4e9:	0f b7 c0             	movzwl %ax,%eax
    f4ec:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    f4ef:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    f4f6:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f4f9:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
    f4ff:	89 d0                	mov    %edx,%eax
    f501:	c1 f8 1f             	sar    $0x1f,%eax
    f504:	c1 e8 16             	shr    $0x16,%eax
    f507:	01 c2                	add    %eax,%edx
    f509:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    f50f:	29 c2                	sub    %eax,%edx
    f511:	85 d2                	test   %edx,%edx
    f513:	89 55 c8             	mov    %edx,-0x38(%ebp)
    f516:	0f 8e 2c 04 00 00    	jle    f948 <rlc_UM_reassemble_deliver+0x4a8>
    f51c:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
    f51f:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    f522:	e9 83 00 00 00       	jmp    f5aa <rlc_UM_reassemble_deliver+0x10a>
    f527:	90                   	nop
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    f528:	84 c0                	test   %al,%al
    f52a:	0f 84 a0 01 00 00    	je     f6d0 <rlc_UM_reassemble_deliver+0x230>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft=tbuff->pkt;
					fsm_printf("[RLC] Not a complet SDU\n");
				}
			}
			else if(pduhdr->E==1)
    f530:	83 e2 04             	and    $0x4,%edx
    f533:	0f 85 ff 01 00 00    	jne    f738 <rlc_UM_reassemble_deliver+0x298>
				{
					fsm_mem_free(pPduhdrExt);
					pPduhdrExt = NULL;
				}
			}
			if(tbuff != NULL)
    f539:	85 f6                	test   %esi,%esi
    f53b:	74 20                	je     f55d <rlc_UM_reassemble_deliver+0xbd>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    f53d:	8b 46 14             	mov    0x14(%esi),%eax
    f540:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    f543:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    f546:	89 10                	mov    %edx,(%eax)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    f548:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    f54a:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    f551:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    f558:	e8 fc ff ff ff       	call   f559 <rlc_UM_reassemble_deliver+0xb9>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    f55d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    f560:	85 f6                	test   %esi,%esi
    f562:	74 08                	je     f56c <rlc_UM_reassemble_deliver+0xcc>
			{
				fsm_mem_free(icimsg);
    f564:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f567:	e8 fc ff ff ff       	call   f568 <rlc_UM_reassemble_deliver+0xc8>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    f56c:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f56f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f572:	c7 44 98 08 00 00 00 	movl   $0x0,0x8(%eax,%ebx,4)
    f579:	00 
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	u16 h=(umIns->vr_uh + 1)%1024;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+1024)%1024 < (r-h+1024)%1024; i=(i+1)%1024)
    f57a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f57e:	81 65 ec ff 03 00 00 	andl   $0x3ff,-0x14(%ebp)
    f585:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f588:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    f58b:	05 00 04 00 00       	add    $0x400,%eax
    f590:	89 c2                	mov    %eax,%edx
    f592:	c1 fa 1f             	sar    $0x1f,%edx
    f595:	c1 ea 16             	shr    $0x16,%edx
    f598:	01 d0                	add    %edx,%eax
    f59a:	25 ff 03 00 00       	and    $0x3ff,%eax
    f59f:	29 d0                	sub    %edx,%eax
    f5a1:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    f5a4:	0f 8d 9e 03 00 00    	jge    f948 <rlc_UM_reassemble_deliver+0x4a8>
	{
		if(umIns->umRecvWindow10[i] != NULL)
    f5aa:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f5ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f5b0:	83 c3 2c             	add    $0x2c,%ebx
    f5b3:	8b 44 98 08          	mov    0x8(%eax,%ebx,4),%eax
    f5b7:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    f5ba:	85 c0                	test   %eax,%eax
    f5bc:	74 bc                	je     f57a <rlc_UM_reassemble_deliver+0xda>
		{
			fsm_printf("[RLC]  umIns->umRecvWindow10[i] != NULL, i = %d\n",i);
    f5be:	8b 5d ec             	mov    -0x14(%ebp),%ebx
    f5c1:	c7 04 24 a4 3b 00 00 	movl   $0x3ba4,(%esp)
    f5c8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    f5cc:	e8 fc ff ff ff       	call   f5cd <rlc_UM_reassemble_deliver+0x12d>
			tbuff = umIns->umRecvWindow10[i];
    f5d1:	8b 5d dc             	mov    -0x24(%ebp),%ebx
    f5d4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f5d7:	8b 74 98 08          	mov    0x8(%eax,%ebx,4),%esi
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    f5db:	8b 06                	mov    (%esi),%eax
    f5dd:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    f5e3:	b8 02 00 00 00       	mov    $0x2,%eax
    f5e8:	e8 fc ff ff ff       	call   f5e9 <rlc_UM_reassemble_deliver+0x149>
    f5ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    f5f0:	8b 43 02             	mov    0x2(%ebx),%eax
    f5f3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f5f6:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    f5f8:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    f5fc:	88 42 01             	mov    %al,0x1(%edx)
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f5ff:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f601:	ba 02 00 00 00       	mov    $0x2,%edx
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			//fsm_octets_print(tbuff->pkt->data,64);
			pduhdr=(RLC_UM_size10_subhead*)tbuff->pkt->data;
    f606:	8b 98 ac 00 00 00    	mov    0xac(%eax),%ebx
    f60c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    f60f:	e8 fc ff ff ff       	call   f610 <rlc_UM_reassemble_deliver+0x170>
			//get_UmPduhead(umIns->umRecvWindow10[i],pduhdr) ;
			fsm_octets_print(pduhdr,2);
    f614:	ba 02 00 00 00       	mov    $0x2,%edx
    f619:	89 d8                	mov    %ebx,%eax
    f61b:	e8 fc ff ff ff       	call   f61c <rlc_UM_reassemble_deliver+0x17c>
          	fsm_printf("[RLC][rlc_UM_reassemble_deliver] pduhdr->E=%d, pduhdr->FIfirst=%d, pduhdr->FIsecond=%d\n",pduhdr->E, pduhdr->FIfirst,pduhdr->FIsecond);
    f620:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f624:	c0 e8 03             	shr    $0x3,%al
    f627:	83 e0 01             	and    $0x1,%eax
    f62a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    f62e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f632:	c0 e8 04             	shr    $0x4,%al
    f635:	83 e0 01             	and    $0x1,%eax
    f638:	89 44 24 08          	mov    %eax,0x8(%esp)
    f63c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f640:	c7 04 24 d8 3b 00 00 	movl   $0x3bd8,(%esp)
    f647:	c0 e8 02             	shr    $0x2,%al
    f64a:	83 e0 01             	and    $0x1,%eax
    f64d:	89 44 24 04          	mov    %eax,0x4(%esp)
    f651:	e8 fc ff ff ff       	call   f652 <rlc_UM_reassemble_deliver+0x1b2>
			
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    f656:	0f b6 53 01          	movzbl 0x1(%ebx),%edx
    f65a:	89 d0                	mov    %edx,%eax
    f65c:	83 e0 14             	and    $0x14,%eax
    f65f:	3c 10                	cmp    $0x10,%al
    f661:	0f 85 c1 fe ff ff    	jne    f528 <rlc_UM_reassemble_deliver+0x88>
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f667:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f66a:	0f b7 4a 02          	movzwl 0x2(%edx),%ecx
    f66e:	66 83 f9 ff          	cmp    $0xffff,%cx
    f672:	74 2f                	je     f6a3 <rlc_UM_reassemble_deliver+0x203>
    f674:	0f bf c9             	movswl %cx,%ecx
    f677:	0f b6 13             	movzbl (%ebx),%edx
    f67a:	83 c1 01             	add    $0x1,%ecx
    f67d:	89 c8                	mov    %ecx,%eax
    f67f:	c1 f8 1f             	sar    $0x1f,%eax
    f682:	c1 e8 16             	shr    $0x16,%eax
    f685:	01 c1                	add    %eax,%ecx
    f687:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f68d:	29 c1                	sub    %eax,%ecx
    f68f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f693:	83 e0 03             	and    $0x3,%eax
    f696:	c1 e0 08             	shl    $0x8,%eax
    f699:	09 d0                	or     %edx,%eax
    f69b:	39 c1                	cmp    %eax,%ecx
    f69d:	0f 84 e5 03 00 00    	je     fa88 <rlc_UM_reassemble_deliver+0x5e8>
						fsm_printf("[RLC] Not a complet SDU\n");
					}
				}
				else
				{
					SV(countDropPacket)++;
    f6a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f6a6:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    f6ad:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f6b0:	e8 fc ff ff ff       	call   f6b1 <rlc_UM_reassemble_deliver+0x211>
					if(tbuff->pkt != NULL)
    f6b5:	8b 06                	mov    (%esi),%eax
    f6b7:	85 c0                	test   %eax,%eax
    f6b9:	0f 84 7a fe ff ff    	je     f539 <rlc_UM_reassemble_deliver+0x99>
					{
						fsm_pkt_destroy(tbuff->pkt);
    f6bf:	e8 fc ff ff ff       	call   f6c0 <rlc_UM_reassemble_deliver+0x220>
						tbuff->pkt = NULL;
    f6c4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    f6ca:	e9 6a fe ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
    f6cf:	90                   	nop
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    f6d0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f6d3:	e8 fc ff ff ff       	call   f6d4 <rlc_UM_reassemble_deliver+0x234>

				if(pduhdr->FIsecond==0)
    f6d8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f6db:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    f6df:	0f 85 6b 02 00 00    	jne    f950 <rlc_UM_reassemble_deliver+0x4b0>
				{
					skb = tbuff->pkt;
    f6e5:	8b 1e                	mov    (%esi),%ebx
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f6e7:	89 d8                	mov    %ebx,%eax
    f6e9:	e8 fc ff ff ff       	call   f6ea <rlc_UM_reassemble_deliver+0x24a>
    f6ee:	83 f8 01             	cmp    $0x1,%eax
    f6f1:	0f 86 a7 04 00 00    	jbe    fb9e <rlc_UM_reassemble_deliver+0x6fe>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f6f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f6fa:	b9 02 00 00 00       	mov    $0x2,%ecx
    f6ff:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f705:	e8 fc ff ff ff       	call   f706 <rlc_UM_reassemble_deliver+0x266>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f70a:	89 d8                	mov    %ebx,%eax
    f70c:	ba 06 00 00 00       	mov    $0x6,%edx
    f711:	e8 fc ff ff ff       	call   f712 <rlc_UM_reassemble_deliver+0x272>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f716:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f719:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
    f720:	c7 04 24 64 3c 00 00 	movl   $0x3c64,(%esp)
    f727:	e8 fc ff ff ff       	call   f728 <rlc_UM_reassemble_deliver+0x288>
    f72c:	e9 08 fe ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
    f731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f738:	b8 40 00 00 00       	mov    $0x40,%eax
    f73d:	e8 fc ff ff ff       	call   f73e <rlc_UM_reassemble_deliver+0x29e>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f742:	31 c9                	xor    %ecx,%ecx
    f744:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    f746:	89 45 d0             	mov    %eax,-0x30(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f749:	89 04 24             	mov    %eax,(%esp)
    f74c:	b8 01 00 00 00       	mov    $0x1,%eax
    f751:	e8 fc ff ff ff       	call   f752 <rlc_UM_reassemble_deliver+0x2b2>
                
				if(pduhdr->FIfirst==1)
    f756:	8b 5d e8             	mov    -0x18(%ebp),%ebx
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
    f759:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
                
				if(pduhdr->FIfirst==1)
    f75d:	f6 43 01 10          	testb  $0x10,0x1(%ebx)
    f761:	0f 84 89 02 00 00    	je     f9f0 <rlc_UM_reassemble_deliver+0x550>
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
    f767:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f76a:	0f b7 42 02          	movzwl 0x2(%edx),%eax
    f76e:	66 83 f8 ff          	cmp    $0xffff,%ax
    f772:	74 2d                	je     f7a1 <rlc_UM_reassemble_deliver+0x301>
    f774:	98                   	cwtl   
    f775:	0f b6 13             	movzbl (%ebx),%edx
    f778:	8d 48 01             	lea    0x1(%eax),%ecx
    f77b:	89 c8                	mov    %ecx,%eax
    f77d:	c1 f8 1f             	sar    $0x1f,%eax
    f780:	c1 e8 16             	shr    $0x16,%eax
    f783:	01 c1                	add    %eax,%ecx
    f785:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
    f78b:	29 c1                	sub    %eax,%ecx
    f78d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f791:	83 e0 03             	and    $0x3,%eax
    f794:	c1 e0 08             	shl    $0x8,%eax
    f797:	09 d0                	or     %edx,%eax
    f799:	39 c1                	cmp    %eax,%ecx
    f79b:	0f 84 10 04 00 00    	je     fbb1 <rlc_UM_reassemble_deliver+0x711>
						clear_left_pdu(pdu_left);
                       
					}
					else
					{
						SV(countDropPacket)++;
    f7a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f7a4:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    f7ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f7ae:	e8 fc ff ff ff       	call   f7af <rlc_UM_reassemble_deliver+0x30f>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    f7b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f7b6:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    f7ba:	8b 06                	mov    (%esi),%eax
    f7bc:	e8 fc ff ff ff       	call   f7bd <rlc_UM_reassemble_deliver+0x31d>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f7c1:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
    f7c5:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f7c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f7ce:	8d 5c 00 fe          	lea    -0x2(%eax,%eax,1),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f7d2:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    f7d5:	89 5d cc             	mov    %ebx,-0x34(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f7d8:	7f 47                	jg     f821 <rlc_UM_reassemble_deliver+0x381>
    f7da:	e9 ab 00 00 00       	jmp    f88a <rlc_UM_reassemble_deliver+0x3ea>
    f7df:	90                   	nop
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f7e0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f7e6:	b9 02 00 00 00       	mov    $0x2,%ecx
    f7eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f7ee:	e8 fc ff ff ff       	call   f7ef <rlc_UM_reassemble_deliver+0x34f>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f7f3:	89 d8                	mov    %ebx,%eax
    f7f5:	ba 06 00 00 00       	mov    $0x6,%edx
    f7fa:	e8 fc ff ff ff       	call   f7fb <rlc_UM_reassemble_deliver+0x35b>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f7ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f802:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f809:	c7 04 24 00 3d 00 00 	movl   $0x3d00,(%esp)
    f810:	e8 fc ff ff ff       	call   f811 <rlc_UM_reassemble_deliver+0x371>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f815:	8b 5d cc             	mov    -0x34(%ebp),%ebx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
    f818:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
				}
               
				int j;
				for(j=1; j<count;j++)
    f81c:	39 5d f0             	cmp    %ebx,-0x10(%ebp)
    f81f:	74 67                	je     f888 <rlc_UM_reassemble_deliver+0x3e8>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f821:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f824:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f827:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    f82c:	89 d8                	mov    %ebx,%eax
    f82e:	e8 fc ff ff ff       	call   f82f <rlc_UM_reassemble_deliver+0x38f>

					fsm_skb_reserve(new_skb,length);
    f833:	89 da                	mov    %ebx,%edx
               
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f835:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    f837:	e8 fc ff ff ff       	call   f838 <rlc_UM_reassemble_deliver+0x398>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f83c:	8b 07                	mov    (%edi),%eax
    f83e:	89 da                	mov    %ebx,%edx
    f840:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f846:	89 45 d8             	mov    %eax,-0x28(%ebp)
    f849:	89 f0                	mov    %esi,%eax
    f84b:	e8 fc ff ff ff       	call   f84c <rlc_UM_reassemble_deliver+0x3ac>
    f850:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f853:	89 d9                	mov    %ebx,%ecx
    f855:	e8 fc ff ff ff       	call   f856 <rlc_UM_reassemble_deliver+0x3b6>
					fsm_skb_pull(tbuff->pkt,length ) ;
    f85a:	8b 07                	mov    (%edi),%eax
    f85c:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    f85e:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    f860:	e8 fc ff ff ff       	call   f861 <rlc_UM_reassemble_deliver+0x3c1>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f865:	89 f0                	mov    %esi,%eax
    f867:	e8 fc ff ff ff       	call   f868 <rlc_UM_reassemble_deliver+0x3c8>
    f86c:	83 f8 01             	cmp    $0x1,%eax
    f86f:	0f 87 6b ff ff ff    	ja     f7e0 <rlc_UM_reassemble_deliver+0x340>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    f875:	ba 02 00 00 00       	mov    $0x2,%edx
    f87a:	89 f0                	mov    %esi,%eax
    f87c:	e8 fc ff ff ff       	call   f87d <rlc_UM_reassemble_deliver+0x3dd>
    f881:	89 c3                	mov    %eax,%ebx
    f883:	e9 58 ff ff ff       	jmp    f7e0 <rlc_UM_reassemble_deliver+0x340>
    f888:	89 fe                	mov    %edi,%esi
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f88a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
				{
					length = tbuff->pkt->len;
    f88d:	8b 06                	mov    (%esi),%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f88f:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f893:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
    f897:	89 d8                	mov    %ebx,%eax
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP5\n");
				}
                
				if(pduhdr->FIsecond==0)
    f899:	0f 85 e1 00 00 00    	jne    f980 <rlc_UM_reassemble_deliver+0x4e0>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f89f:	e8 fc ff ff ff       	call   f8a0 <rlc_UM_reassemble_deliver+0x400>
					fsm_skb_reserve(new_skb,length);
    f8a4:	89 da                	mov    %ebx,%edx
				}
                
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f8a6:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f8a8:	e8 fc ff ff ff       	call   f8a9 <rlc_UM_reassemble_deliver+0x409>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f8ad:	8b 06                	mov    (%esi),%eax
    f8af:	89 da                	mov    %ebx,%edx
    f8b1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f8b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8ba:	89 f8                	mov    %edi,%eax
    f8bc:	e8 fc ff ff ff       	call   f8bd <rlc_UM_reassemble_deliver+0x41d>
    f8c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8c4:	89 d9                	mov    %ebx,%ecx
    f8c6:	e8 fc ff ff ff       	call   f8c7 <rlc_UM_reassemble_deliver+0x427>
					fsm_skb_pull(tbuff->pkt,length) ;
    f8cb:	8b 06                	mov    (%esi),%eax
    f8cd:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
    f8cf:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
    f8d1:	e8 fc ff ff ff       	call   f8d2 <rlc_UM_reassemble_deliver+0x432>
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    f8d6:	89 f8                	mov    %edi,%eax
    f8d8:	e8 fc ff ff ff       	call   f8d9 <rlc_UM_reassemble_deliver+0x439>
    f8dd:	83 f8 01             	cmp    $0x1,%eax
    f8e0:	0f 86 a5 02 00 00    	jbe    fb8b <rlc_UM_reassemble_deliver+0x6eb>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    f8e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    f8e9:	b9 02 00 00 00       	mov    $0x2,%ecx
    f8ee:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    f8f4:	e8 fc ff ff ff       	call   f8f5 <rlc_UM_reassemble_deliver+0x455>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    f8f9:	ba 06 00 00 00       	mov    $0x6,%edx
    f8fe:	89 d8                	mov    %ebx,%eax
    f900:	e8 fc ff ff ff       	call   f901 <rlc_UM_reassemble_deliver+0x461>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    f905:	8b 45 e0             	mov    -0x20(%ebp),%eax
    f908:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP6\n");				
    f90f:	c7 04 24 34 3d 00 00 	movl   $0x3d34,(%esp)
    f916:	e8 fc ff ff ff       	call   f917 <rlc_UM_reassemble_deliver+0x477>
					if(tbuff->pkt != NULL)
    f91b:	8b 06                	mov    (%esi),%eax
    f91d:	85 c0                	test   %eax,%eax
    f91f:	74 0b                	je     f92c <rlc_UM_reassemble_deliver+0x48c>
					pdu_left->SN_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					fsm_printf("[RLC]Not a complet SDU\n");
					if(tbuff->pkt != NULL)
					{
						fsm_pkt_destroy(tbuff->pkt);
    f921:	e8 fc ff ff ff       	call   f922 <rlc_UM_reassemble_deliver+0x482>
						tbuff->pkt = NULL;
    f926:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
				}
				if(pPduhdrExt != NULL)
    f92c:	8b 7d d0             	mov    -0x30(%ebp),%edi
    f92f:	85 ff                	test   %edi,%edi
    f931:	0f 84 02 fc ff ff    	je     f539 <rlc_UM_reassemble_deliver+0x99>
				{
					fsm_mem_free(pPduhdrExt);
    f937:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f93a:	e8 fc ff ff ff       	call   f93b <rlc_UM_reassemble_deliver+0x49b>
    f93f:	e9 f5 fb ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
    f944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			}
			umIns->umRecvWindow10[i]=NULL;
			
		}//end if
	}//end for
}
    f948:	83 c4 44             	add    $0x44,%esp
    f94b:	5b                   	pop    %ebx
    f94c:	5e                   	pop    %esi
    f94d:	5f                   	pop    %edi
    f94e:	5d                   	pop    %ebp
    f94f:	c3                   	ret    
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP2\n");
				}

				else
				{
					pdu_left->SN_Left = pduhdr->SN;
    f950:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f953:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f957:	0f b6 13             	movzbl (%ebx),%edx
    f95a:	83 e0 03             	and    $0x3,%eax
    f95d:	c1 e0 08             	shl    $0x8,%eax
    f960:	09 d0                	or     %edx,%eax
    f962:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f965:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft=tbuff->pkt;
    f969:	8b 06                	mov    (%esi),%eax
    f96b:	89 42 04             	mov    %eax,0x4(%edx)
					fsm_printf("[RLC] Not a complet SDU\n");
    f96e:	c7 04 24 d8 07 00 00 	movl   $0x7d8,(%esp)
    f975:	e8 fc ff ff ff       	call   f976 <rlc_UM_reassemble_deliver+0x4d6>
    f97a:	e9 ba fb ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
    f97f:	90                   	nop
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f980:	e8 fc ff ff ff       	call   f981 <rlc_UM_reassemble_deliver+0x4e1>
					fsm_skb_reserve(new_skb,length);
    f985:	89 da                	mov    %ebx,%edx
					
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
    f987:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    f989:	e8 fc ff ff ff       	call   f98a <rlc_UM_reassemble_deliver+0x4ea>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    f98e:	8b 06                	mov    (%esi),%eax
    f990:	89 da                	mov    %ebx,%edx
    f992:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    f998:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f99b:	89 f8                	mov    %edi,%eax
    f99d:	e8 fc ff ff ff       	call   f99e <rlc_UM_reassemble_deliver+0x4fe>
    f9a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9a5:	89 d9                	mov    %ebx,%ecx
    f9a7:	e8 fc ff ff ff       	call   f9a8 <rlc_UM_reassemble_deliver+0x508>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
    f9ac:	8b 06                	mov    (%esi),%eax
    f9ae:	8b 50 50             	mov    0x50(%eax),%edx
    f9b1:	e8 fc ff ff ff       	call   f9b2 <rlc_UM_reassemble_deliver+0x512>
                   
					pdu_left->SN_Left = pduhdr->SN;
    f9b6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    f9b9:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    f9bd:	0f b6 13             	movzbl (%ebx),%edx
    f9c0:	83 e0 03             	and    $0x3,%eax
    f9c3:	c1 e0 08             	shl    $0x8,%eax
    f9c6:	09 d0                	or     %edx,%eax
    f9c8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    f9cb:	66 89 42 02          	mov    %ax,0x2(%edx)
					pdu_left->sduLeft = new_skb;
    f9cf:	89 7a 04             	mov    %edi,0x4(%edx)
					fsm_printf("[RLC]Not a complet SDU\n");
    f9d2:	c7 04 24 f1 07 00 00 	movl   $0x7f1,(%esp)
    f9d9:	e8 fc ff ff ff       	call   f9da <rlc_UM_reassemble_deliver+0x53a>
					if(tbuff->pkt != NULL)
    f9de:	8b 06                	mov    (%esi),%eax
    f9e0:	85 c0                	test   %eax,%eax
    f9e2:	0f 85 39 ff ff ff    	jne    f921 <rlc_UM_reassemble_deliver+0x481>
    f9e8:	e9 3f ff ff ff       	jmp    f92c <rlc_UM_reassemble_deliver+0x48c>
    f9ed:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
    f9f0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    f9f3:	e8 fc ff ff ff       	call   f9f4 <rlc_UM_reassemble_deliver+0x554>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    f9f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    f9fb:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    f9ff:	89 d8                	mov    %ebx,%eax
    fa01:	e8 fc ff ff ff       	call   fa02 <rlc_UM_reassemble_deliver+0x562>
					fsm_skb_reserve(new_skb,length);
    fa06:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
    fa08:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    fa0a:	e8 fc ff ff ff       	call   fa0b <rlc_UM_reassemble_deliver+0x56b>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    fa0f:	8b 06                	mov    (%esi),%eax
    fa11:	89 da                	mov    %ebx,%edx
    fa13:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fa19:	89 45 d8             	mov    %eax,-0x28(%ebp)
    fa1c:	89 f8                	mov    %edi,%eax
    fa1e:	e8 fc ff ff ff       	call   fa1f <rlc_UM_reassemble_deliver+0x57f>
    fa23:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fa26:	89 d9                	mov    %ebx,%ecx
    fa28:	e8 fc ff ff ff       	call   fa29 <rlc_UM_reassemble_deliver+0x589>
					fsm_skb_pull(tbuff->pkt,length ) ;
    fa2d:	8b 06                	mov    (%esi),%eax
    fa2f:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    fa31:	89 fb                	mov    %edi,%ebx

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
    fa33:	e8 fc ff ff ff       	call   fa34 <rlc_UM_reassemble_deliver+0x594>
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fa38:	89 f8                	mov    %edi,%eax
    fa3a:	e8 fc ff ff ff       	call   fa3b <rlc_UM_reassemble_deliver+0x59b>
    fa3f:	83 f8 01             	cmp    $0x1,%eax
    fa42:	0f 86 34 02 00 00    	jbe    fc7c <rlc_UM_reassemble_deliver+0x7dc>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fa48:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fa4b:	b9 02 00 00 00       	mov    $0x2,%ecx
    fa50:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fa56:	e8 fc ff ff ff       	call   fa57 <rlc_UM_reassemble_deliver+0x5b7>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    fa5b:	89 d8                	mov    %ebx,%eax
    fa5d:	ba 06 00 00 00       	mov    $0x6,%edx
    fa62:	e8 fc ff ff ff       	call   fa63 <rlc_UM_reassemble_deliver+0x5c3>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    fa67:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fa6a:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP4\n");
    fa71:	c7 04 24 cc 3c 00 00 	movl   $0x3ccc,(%esp)
    fa78:	e8 fc ff ff ff       	call   fa79 <rlc_UM_reassemble_deliver+0x5d9>
    fa7d:	e9 3f fd ff ff       	jmp    f7c1 <rlc_UM_reassemble_deliver+0x321>
    fa82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
    fa88:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    fa8b:	8b 16                	mov    (%esi),%edx
    fa8d:	8b 41 04             	mov    0x4(%ecx),%eax
    fa90:	8b 40 50             	mov    0x50(%eax),%eax
    fa93:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
    fa97:	0f b7 d8             	movzwl %ax,%ebx
    fa9a:	89 d8                	mov    %ebx,%eax
    fa9c:	e8 fc ff ff ff       	call   fa9d <rlc_UM_reassemble_deliver+0x5fd>
					fsm_skb_reserve(new_skb,length);
    faa1:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN_Left != -1 && (pdu_left->SN_Left+1)%1024==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
    faa3:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
    faa5:	e8 fc ff ff ff       	call   faa6 <rlc_UM_reassemble_deliver+0x606>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
    faaa:	8b 06                	mov    (%esi),%eax
    faac:	8b 58 50             	mov    0x50(%eax),%ebx
    faaf:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fab5:	89 f8                	mov    %edi,%eax
    fab7:	89 55 f0             	mov    %edx,-0x10(%ebp)
    faba:	89 da                	mov    %ebx,%edx
    fabc:	e8 fc ff ff ff       	call   fabd <rlc_UM_reassemble_deliver+0x61d>
    fac1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fac4:	89 d9                	mov    %ebx,%ecx
    fac6:	e8 fc ff ff ff       	call   fac7 <rlc_UM_reassemble_deliver+0x627>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    facb:	8b 55 c0             	mov    -0x40(%ebp),%edx
    face:	8b 42 04             	mov    0x4(%edx),%eax
    fad1:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fad7:	8b 58 50             	mov    0x50(%eax),%ebx
    fada:	89 f8                	mov    %edi,%eax
    fadc:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fadf:	89 da                	mov    %ebx,%edx
    fae1:	e8 fc ff ff ff       	call   fae2 <rlc_UM_reassemble_deliver+0x642>
    fae6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fae9:	89 d9                	mov    %ebx,%ecx
    faeb:	e8 fc ff ff ff       	call   faec <rlc_UM_reassemble_deliver+0x64c>
					clear_left_pdu(pdu_left);
    faf0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    faf3:	e8 fc ff ff ff       	call   faf4 <rlc_UM_reassemble_deliver+0x654>
					if(tbuff->pkt != NULL)
    faf8:	8b 06                	mov    (%esi),%eax
    fafa:	85 c0                	test   %eax,%eax
    fafc:	74 0b                	je     fb09 <rlc_UM_reassemble_deliver+0x669>
					{
						fsm_pkt_destroy(tbuff->pkt);
    fafe:	e8 fc ff ff ff       	call   faff <rlc_UM_reassemble_deliver+0x65f>
						tbuff->pkt = NULL;
    fb03:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
    fb09:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fb0c:	f6 43 01 08          	testb  $0x8,0x1(%ebx)
    fb10:	75 4c                	jne    fb5e <rlc_UM_reassemble_deliver+0x6be>
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fb12:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
    fb14:	89 fb                	mov    %edi,%ebx
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fb16:	e8 fc ff ff ff       	call   fb17 <rlc_UM_reassemble_deliver+0x677>
    fb1b:	83 f8 01             	cmp    $0x1,%eax
    fb1e:	0f 86 6b 01 00 00    	jbe    fc8f <rlc_UM_reassemble_deliver+0x7ef>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fb24:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fb27:	b9 02 00 00 00       	mov    $0x2,%ecx
    fb2c:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fb32:	e8 fc ff ff ff       	call   fb33 <rlc_UM_reassemble_deliver+0x693>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    fb37:	89 d8                	mov    %ebx,%eax
    fb39:	ba 06 00 00 00       	mov    $0x6,%edx
    fb3e:	e8 fc ff ff ff       	call   fb3f <rlc_UM_reassemble_deliver+0x69f>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    fb43:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fb46:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP1\n");
    fb4d:	c7 04 24 30 3c 00 00 	movl   $0x3c30,(%esp)
    fb54:	e8 fc ff ff ff       	call   fb55 <rlc_UM_reassemble_deliver+0x6b5>
    fb59:	e9 db f9 ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
					}
					else
					{
						pdu_left->SN_Left = pduhdr->SN;
    fb5e:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    fb61:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
    fb65:	0f b6 13             	movzbl (%ebx),%edx
    fb68:	83 e0 03             	and    $0x3,%eax
    fb6b:	c1 e0 08             	shl    $0x8,%eax
    fb6e:	09 d0                	or     %edx,%eax
    fb70:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fb73:	66 89 42 02          	mov    %ax,0x2(%edx)
						pdu_left->sduLeft = new_skb;
    fb77:	89 7a 04             	mov    %edi,0x4(%edx)
						fsm_printf("[RLC] Not a complet SDU\n");
    fb7a:	c7 04 24 d8 07 00 00 	movl   $0x7d8,(%esp)
    fb81:	e8 fc ff ff ff       	call   fb82 <rlc_UM_reassemble_deliver+0x6e2>
    fb86:	e9 ae f9 ff ff       	jmp    f539 <rlc_UM_reassemble_deliver+0x99>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fb8b:	ba 02 00 00 00       	mov    $0x2,%edx
    fb90:	89 f8                	mov    %edi,%eax
    fb92:	e8 fc ff ff ff       	call   fb93 <rlc_UM_reassemble_deliver+0x6f3>
    fb97:	89 c3                	mov    %eax,%ebx
    fb99:	e9 48 fd ff ff       	jmp    f8e6 <rlc_UM_reassemble_deliver+0x446>
				{
					skb = tbuff->pkt;
	
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fb9e:	89 d8                	mov    %ebx,%eax
    fba0:	ba 02 00 00 00       	mov    $0x2,%edx
    fba5:	e8 fc ff ff ff       	call   fba6 <rlc_UM_reassemble_deliver+0x706>
    fbaa:	89 c3                	mov    %eax,%ebx
    fbac:	e9 46 fb ff ff       	jmp    f6f7 <rlc_UM_reassemble_deliver+0x257>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
    fbb1:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fbb4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
    fbb7:	8b 42 04             	mov    0x4(%edx),%eax
    fbba:	8b 40 50             	mov    0x50(%eax),%eax
    fbbd:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
    fbc1:	0f b7 d8             	movzwl %ax,%ebx
    fbc4:	89 d8                	mov    %ebx,%eax
    fbc6:	e8 fc ff ff ff       	call   fbc7 <rlc_UM_reassemble_deliver+0x727>
						fsm_skb_reserve(new_skb,length);
    fbcb:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
    fbcd:	89 c7                	mov    %eax,%edi
						fsm_skb_reserve(new_skb,length);
    fbcf:	e8 fc ff ff ff       	call   fbd0 <rlc_UM_reassemble_deliver+0x730>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
    fbd4:	8b 06                	mov    (%esi),%eax
    fbd6:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    fbdc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    fbdf:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fbe2:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
    fbe6:	89 f8                	mov    %edi,%eax
    fbe8:	89 da                	mov    %ebx,%edx
    fbea:	e8 fc ff ff ff       	call   fbeb <rlc_UM_reassemble_deliver+0x74b>
    fbef:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fbf2:	89 d9                	mov    %ebx,%ecx
    fbf4:	e8 fc ff ff ff       	call   fbf5 <rlc_UM_reassemble_deliver+0x755>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    fbf9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    fbfc:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    fc00:	8b 06                	mov    (%esi),%eax
    fc02:	e8 fc ff ff ff       	call   fc03 <rlc_UM_reassemble_deliver+0x763>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fc07:	8b 55 c0             	mov    -0x40(%ebp),%edx
    fc0a:	8b 42 04             	mov    0x4(%edx),%eax
    fc0d:	8b 58 50             	mov    0x50(%eax),%ebx
    fc10:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
    fc16:	89 f8                	mov    %edi,%eax
    fc18:	89 55 d8             	mov    %edx,-0x28(%ebp)
    fc1b:	89 da                	mov    %ebx,%edx
    fc1d:	e8 fc ff ff ff       	call   fc1e <rlc_UM_reassemble_deliver+0x77e>
    fc22:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fc25:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
    fc27:	89 fb                	mov    %edi,%ebx
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
    fc29:	e8 fc ff ff ff       	call   fc2a <rlc_UM_reassemble_deliver+0x78a>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fc2e:	89 f8                	mov    %edi,%eax
    fc30:	e8 fc ff ff ff       	call   fc31 <rlc_UM_reassemble_deliver+0x791>
    fc35:	83 f8 01             	cmp    $0x1,%eax
    fc38:	76 68                	jbe    fca2 <rlc_UM_reassemble_deliver+0x802>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fc3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    fc3d:	b9 02 00 00 00       	mov    $0x2,%ecx
    fc42:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    fc48:	e8 fc ff ff ff       	call   fc49 <rlc_UM_reassemble_deliver+0x7a9>
						fsm_pkt_send(skb,STRM_TO_PDCP);
    fc4d:	ba 06 00 00 00       	mov    $0x6,%edx
    fc52:	89 d8                	mov    %ebx,%eax
    fc54:	e8 fc ff ff ff       	call   fc55 <rlc_UM_reassemble_deliver+0x7b5>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
    fc59:	8b 45 e0             	mov    -0x20(%ebp),%eax
    fc5c:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM_reassemble_deliver] <--send to PDCP3\n");
    fc63:	c7 04 24 98 3c 00 00 	movl   $0x3c98,(%esp)
    fc6a:	e8 fc ff ff ff       	call   fc6b <rlc_UM_reassemble_deliver+0x7cb>
						
						clear_left_pdu(pdu_left);
    fc6f:	8b 45 c0             	mov    -0x40(%ebp),%eax
    fc72:	e8 fc ff ff ff       	call   fc73 <rlc_UM_reassemble_deliver+0x7d3>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt); 
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN_Left != -1&&(pdu_left->SN_Left+1)%1024==pduhdr->SN)
					{
    fc77:	e9 45 fb ff ff       	jmp    f7c1 <rlc_UM_reassemble_deliver+0x321>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fc7c:	ba 02 00 00 00       	mov    $0x2,%edx
    fc81:	89 f8                	mov    %edi,%eax
    fc83:	e8 fc ff ff ff       	call   fc84 <rlc_UM_reassemble_deliver+0x7e4>
    fc88:	89 c3                	mov    %eax,%ebx
    fc8a:	e9 b9 fd ff ff       	jmp    fa48 <rlc_UM_reassemble_deliver+0x5a8>
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fc8f:	ba 02 00 00 00       	mov    $0x2,%edx
    fc94:	89 f8                	mov    %edi,%eax
    fc96:	e8 fc ff ff ff       	call   fc97 <rlc_UM_reassemble_deliver+0x7f7>
    fc9b:	89 c3                	mov    %eax,%ebx
    fc9d:	e9 82 fe ff ff       	jmp    fb24 <rlc_UM_reassemble_deliver+0x684>

						skb = new_skb;
						
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
    fca2:	ba 02 00 00 00       	mov    $0x2,%edx
    fca7:	89 f8                	mov    %edi,%eax
    fca9:	e8 fc ff ff ff       	call   fcaa <rlc_UM_reassemble_deliver+0x80a>
    fcae:	89 c3                	mov    %eax,%ebx
    fcb0:	eb 88                	jmp    fc3a <rlc_UM_reassemble_deliver+0x79a>
    fcb2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    fcb9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0000fcc0 <rlc_UM5_reassemble_deliver>:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
    fcc0:	55                   	push   %ebp
    fcc1:	89 e5                	mov    %esp,%ebp
    fcc3:	57                   	push   %edi
    fcc4:	56                   	push   %esi
    fcc5:	53                   	push   %ebx
    fcc6:	83 ec 34             	sub    $0x34,%esp
    fcc9:	e8 fc ff ff ff       	call   fcca <rlc_UM5_reassemble_deliver+0xa>
    fcce:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    fcd1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	SV_PTR_GET(rlc_mac_sv);
    fcd4:	e8 fc ff ff ff       	call   fcd5 <rlc_UM5_reassemble_deliver+0x15>
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fcd9:	8b 55 d8             	mov    -0x28(%ebp),%edx
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fcdc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
{
	SV_PTR_GET(rlc_mac_sv);
    fcdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct RLC_UM_size5_head *pduhdr;
	struct UmBuffer *tbuff;
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
    fce2:	0f bf 82 c0 10 00 00 	movswl 0x10c0(%edx),%eax
    fce9:	83 c0 01             	add    $0x1,%eax
    fcec:	89 c2                	mov    %eax,%edx
    fcee:	c1 fa 1f             	sar    $0x1f,%edx
    fcf1:	c1 ea 1b             	shr    $0x1b,%edx
    fcf4:	01 d0                	add    %edx,%eax
    fcf6:	83 e0 1f             	and    $0x1f,%eax
    fcf9:	29 d0                	sub    %edx,%eax
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fcfb:	0f b7 c0             	movzwl %ax,%eax
    fcfe:	89 45 c8             	mov    %eax,-0x38(%ebp)
    fd01:	0f b7 81 bc 10 00 00 	movzwl 0x10bc(%ecx),%eax
    fd08:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fd0b:	8d 50 20             	lea    0x20(%eax),%edx
    fd0e:	89 d0                	mov    %edx,%eax
    fd10:	c1 f8 1f             	sar    $0x1f,%eax
    fd13:	c1 e8 1b             	shr    $0x1b,%eax
    fd16:	01 c2                	add    %eax,%edx
    fd18:	83 e2 1f             	and    $0x1f,%edx
    fd1b:	29 c2                	sub    %eax,%edx
    fd1d:	85 d2                	test   %edx,%edx
    fd1f:	89 55 cc             	mov    %edx,-0x34(%ebp)
    fd22:	0f 8e d8 03 00 00    	jle    10100 <rlc_UM5_reassemble_deliver+0x440>
    fd28:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fd2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fd2e:	e9 8d 00 00 00       	jmp    fdc0 <rlc_UM5_reassemble_deliver+0x100>
    fd33:	90                   	nop
    fd34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
    fd38:	84 d2                	test   %dl,%dl
    fd3a:	0f 84 38 01 00 00    	je     fe78 <rlc_UM5_reassemble_deliver+0x1b8>
					list_del(&tbuff->list);
					fsm_mem_free(tbuff);
					tbuff=NULL;
				}
			}
			else if(pduhdr->E==1)
    fd40:	a8 20                	test   $0x20,%al
    fd42:	0f 85 98 01 00 00    	jne    fee0 <rlc_UM5_reassemble_deliver+0x220>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
    fd48:	8b 46 14             	mov    0x14(%esi),%eax
    fd4b:	8b 56 10             	mov    0x10(%esi),%edx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
    fd4e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
    fd51:	89 10                	mov    %edx,(%eax)
				}
			}
			if(tbuff != NULL)
			{
				list_del(&tbuff->list);
				fsm_mem_free(tbuff);
    fd53:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
    fd55:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
    fd5c:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
    fd63:	e8 fc ff ff ff       	call   fd64 <rlc_UM5_reassemble_deliver+0xa4>
				tbuff = NULL;
			}
			if(icimsg != NULL)
    fd68:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fd6b:	85 c0                	test   %eax,%eax
    fd6d:	74 08                	je     fd77 <rlc_UM5_reassemble_deliver+0xb7>
			{
				fsm_mem_free(icimsg);
    fd6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    fd72:	e8 fc ff ff ff       	call   fd73 <rlc_UM5_reassemble_deliver+0xb3>
				icimsg=NULL;
			}
			umIns->umRecvWindow10[i]=NULL;
    fd77:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    fd7a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fd7d:	c7 84 88 b8 00 00 00 	movl   $0x0,0xb8(%eax,%ecx,4)
    fd84:	00 00 00 00 
	MRLC_fromMac_IciMsg *mac_ici;
	URLC_IciMsg *icimsg;
	int i;
	u16 h=(umIns->vr_uh + 1)%32;
	u16 r=umIns->vr_ur;
	for(i=h; (i-h+32)%32 < (r-h+32)%32; i=(i+1)%32)
    fd88:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fd8b:	83 c2 01             	add    $0x1,%edx
    fd8e:	89 d0                	mov    %edx,%eax
    fd90:	c1 f8 1f             	sar    $0x1f,%eax
    fd93:	c1 e8 1b             	shr    $0x1b,%eax
    fd96:	01 c2                	add    %eax,%edx
    fd98:	83 e2 1f             	and    $0x1f,%edx
    fd9b:	29 c2                	sub    %eax,%edx
    fd9d:	89 d0                	mov    %edx,%eax
    fd9f:	2b 45 c8             	sub    -0x38(%ebp),%eax
    fda2:	89 55 f0             	mov    %edx,-0x10(%ebp)
    fda5:	83 c0 20             	add    $0x20,%eax
    fda8:	89 c2                	mov    %eax,%edx
    fdaa:	c1 fa 1f             	sar    $0x1f,%edx
    fdad:	c1 ea 1b             	shr    $0x1b,%edx
    fdb0:	01 d0                	add    %edx,%eax
    fdb2:	83 e0 1f             	and    $0x1f,%eax
    fdb5:	29 d0                	sub    %edx,%eax
    fdb7:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    fdba:	0f 8d 40 03 00 00    	jge    10100 <rlc_UM5_reassemble_deliver+0x440>
	{
		if(umIns->umRecvWindow5[i] != NULL)
    fdc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fdc3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    fdc6:	8b 74 90 38          	mov    0x38(%eax,%edx,4),%esi
    fdca:	85 f6                	test   %esi,%esi
    fdcc:	74 ba                	je     fd88 <rlc_UM5_reassemble_deliver+0xc8>
		{

			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
    fdce:	8b 06                	mov    (%esi),%eax
    fdd0:	8b 98 a8 00 00 00    	mov    0xa8(%eax),%ebx
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
    fdd6:	b8 02 00 00 00       	mov    $0x2,%eax
    fddb:	e8 fc ff ff ff       	call   fddc <rlc_UM5_reassemble_deliver+0x11c>
    fde0:	89 45 e8             	mov    %eax,-0x18(%ebp)
			icimsg->pbCh = mac_ici->pbCh;
    fde3:	8b 43 02             	mov    0x2(%ebx),%eax
    fde6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fde9:	88 02                	mov    %al,(%edx)
			icimsg->rbId = mac_ici->lcid;
    fdeb:	0f b6 43 06          	movzbl 0x6(%ebx),%eax
    fdef:	88 42 01             	mov    %al,0x1(%edx)
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fdf2:	8b 06                	mov    (%esi),%eax
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fdf4:	ba 02 00 00 00       	mov    $0x2,%edx
			tbuff = umIns->umRecvWindow5[i];
			mac_ici = (MRLC_fromMac_IciMsg *)tbuff->pkt->head;
			icimsg = (URLC_IciMsg *)fsm_mem_alloc(sizeof(URLC_IciMsg));
			icimsg->pbCh = mac_ici->pbCh;
			icimsg->rbId = mac_ici->lcid;
			pduhdr=(RLC_UM_size5_head*)tbuff->pkt->data;
    fdf9:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
    fdff:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
			//*(u16*)fixhead=ntohs(*(u16*)fixhead); 
			fsm_skb_pull(tbuff->pkt, 2) ;
    fe02:	e8 fc ff ff ff       	call   fe03 <rlc_UM5_reassemble_deliver+0x143>
          
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
    fe07:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe0a:	0f b6 02             	movzbl (%edx),%eax
    fe0d:	89 c2                	mov    %eax,%edx
    fe0f:	83 e2 a0             	and    $0xffffffa0,%edx
    fe12:	80 fa 80             	cmp    $0x80,%dl
    fe15:	0f 85 1d ff ff ff    	jne    fd38 <rlc_UM5_reassemble_deliver+0x78>
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
    fe1b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    fe1e:	0f b7 11             	movzwl (%ecx),%edx
    fe21:	66 83 fa ff          	cmp    $0xffff,%dx
    fe25:	74 20                	je     fe47 <rlc_UM5_reassemble_deliver+0x187>
    fe27:	0f bf d2             	movswl %dx,%edx
    fe2a:	83 e0 1f             	and    $0x1f,%eax
    fe2d:	83 c2 01             	add    $0x1,%edx
    fe30:	89 d1                	mov    %edx,%ecx
    fe32:	c1 f9 1f             	sar    $0x1f,%ecx
    fe35:	c1 e9 1b             	shr    $0x1b,%ecx
    fe38:	01 ca                	add    %ecx,%edx
    fe3a:	83 e2 1f             	and    $0x1f,%edx
    fe3d:	29 ca                	sub    %ecx,%edx
    fe3f:	39 c2                	cmp    %eax,%edx
    fe41:	0f 84 c1 03 00 00    	je     10208 <rlc_UM5_reassemble_deliver+0x548>
						pdu_left->sduLeft = new_skb;
					}
				}
				else
				{
					SV(countDropPacket)++;
    fe47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fe4a:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
					clear_left_pdu(pdu_left);
    fe51:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fe54:	e8 fc ff ff ff       	call   fe55 <rlc_UM5_reassemble_deliver+0x195>
					if(tbuff->pkt != NULL)
    fe59:	8b 06                	mov    (%esi),%eax
    fe5b:	85 c0                	test   %eax,%eax
    fe5d:	0f 84 e5 fe ff ff    	je     fd48 <rlc_UM5_reassemble_deliver+0x88>
					{
						fsm_pkt_destroy(tbuff->pkt);
    fe63:	e8 fc ff ff ff       	call   fe64 <rlc_UM5_reassemble_deliver+0x1a4>
						tbuff->pkt = NULL;
    fe68:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    fe6e:	e9 d5 fe ff ff       	jmp    fd48 <rlc_UM5_reassemble_deliver+0x88>
    fe73:	90                   	nop
    fe74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
			}
			else if((pduhdr->E==0)&&(pduhdr->FIfirst==0))
			{

				clear_left_pdu(pdu_left);
    fe78:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    fe7b:	e8 fc ff ff ff       	call   fe7c <rlc_UM5_reassemble_deliver+0x1bc>

				if(pduhdr->FIsecond==0)
    fe80:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe83:	0f b6 02             	movzbl (%edx),%eax
    fe86:	a8 40                	test   $0x40,%al
    fe88:	0f 85 7a 02 00 00    	jne    10108 <rlc_UM5_reassemble_deliver+0x448>
				{

					skb = tbuff->pkt;
    fe8e:	8b 1e                	mov    (%esi),%ebx
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
    fe90:	89 d8                	mov    %ebx,%eax
    fe92:	e8 fc ff ff ff       	call   fe93 <rlc_UM5_reassemble_deliver+0x1d3>
    fe97:	83 f8 01             	cmp    $0x1,%eax
    fe9a:	0f 86 35 04 00 00    	jbe    102d5 <rlc_UM5_reassemble_deliver+0x615>
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    fea0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fea3:	b9 02 00 00 00       	mov    $0x2,%ecx
    fea8:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    feae:	e8 fc ff ff ff       	call   feaf <rlc_UM5_reassemble_deliver+0x1ef>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    feb3:	89 d8                	mov    %ebx,%eax
    feb5:	ba 06 00 00 00       	mov    $0x6,%edx
    feba:	e8 fc ff ff ff       	call   febb <rlc_UM5_reassemble_deliver+0x1fb>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    febf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    fec2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    fec9:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
    fed0:	e8 fc ff ff ff       	call   fed1 <rlc_UM5_reassemble_deliver+0x211>
    fed5:	e9 6e fe ff ff       	jmp    fd48 <rlc_UM5_reassemble_deliver+0x88>
    feda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    fee0:	b8 40 00 00 00       	mov    $0x40,%eax
    fee5:	e8 fc ff ff ff       	call   fee6 <rlc_UM5_reassemble_deliver+0x226>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    feea:	31 c9                	xor    %ecx,%ecx
    feec:	89 f2                	mov    %esi,%edx
				}
			}
			else if(pduhdr->E==1)
			{
				struct _pduhdrExt *pPduhdrExt;
				pPduhdrExt = (struct _pduhdrExt *)fsm_mem_alloc(sizeof(struct _pduhdrExt));
    feee:	89 45 dc             	mov    %eax,-0x24(%ebp)
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
    fef1:	89 04 24             	mov    %eax,(%esp)
    fef4:	b8 01 00 00 00       	mov    $0x1,%eax
    fef9:	e8 fc ff ff ff       	call   fefa <rlc_UM5_reassemble_deliver+0x23a>
    fefe:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
                
				if(pduhdr->FIfirst==1)
    ff02:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff05:	0f b6 08             	movzbl (%eax),%ecx
    ff08:	84 c9                	test   %cl,%cl
    ff0a:	0f 89 60 02 00 00    	jns    10170 <rlc_UM5_reassemble_deliver+0x4b0>
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
    ff10:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ff13:	0f b7 02             	movzwl (%edx),%eax
    ff16:	66 83 f8 ff          	cmp    $0xffff,%ax
    ff1a:	74 20                	je     ff3c <rlc_UM5_reassemble_deliver+0x27c>
    ff1c:	98                   	cwtl   
    ff1d:	83 e1 1f             	and    $0x1f,%ecx
    ff20:	83 c0 01             	add    $0x1,%eax
    ff23:	89 c2                	mov    %eax,%edx
    ff25:	c1 fa 1f             	sar    $0x1f,%edx
    ff28:	c1 ea 17             	shr    $0x17,%edx
    ff2b:	01 d0                	add    %edx,%eax
    ff2d:	25 ff 01 00 00       	and    $0x1ff,%eax
    ff32:	29 d0                	sub    %edx,%eax
    ff34:	39 c8                	cmp    %ecx,%eax
    ff36:	0f 84 ac 03 00 00    	je     102e8 <rlc_UM5_reassemble_deliver+0x628>
						clear_left_pdu(pdu_left);
                        
					}
					else
					{
						SV(countDropPacket)++;
    ff3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ff3f:	83 80 9c 5a 00 00 01 	addl   $0x1,0x5a9c(%eax)
						clear_left_pdu(pdu_left);
    ff46:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    ff49:	e8 fc ff ff ff       	call   ff4a <rlc_UM5_reassemble_deliver+0x28a>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
    ff4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ff51:	0f b7 50 20          	movzwl 0x20(%eax),%edx
    ff55:	8b 06                	mov    (%esi),%eax
    ff57:	e8 fc ff ff ff       	call   ff58 <rlc_UM5_reassemble_deliver+0x298>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    ff5c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
    ff60:	89 f7                	mov    %esi,%edi
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    ff62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ff69:	8d 54 00 fe          	lea    -0x2(%eax,%eax,1),%edx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    ff6d:	83 f8 01             	cmp    $0x1,%eax
** Modified by	:
** Modified Date:
**------------------------------------------------------------------------------------------
*******************************************************************************************/

void rlc_UM5_reassemble_deliver(struct UM_RX_Instance *umIns, struct pduLeft *pdu_left)
    ff70:	89 55 d0             	mov    %edx,-0x30(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    ff73:	7f 4c                	jg     ffc1 <rlc_UM5_reassemble_deliver+0x301>
    ff75:	e9 b0 00 00 00       	jmp    1002a <rlc_UM5_reassemble_deliver+0x36a>
    ff7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
    ff80:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ff83:	b9 02 00 00 00       	mov    $0x2,%ecx
    ff88:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
    ff8e:	e8 fc ff ff ff       	call   ff8f <rlc_UM5_reassemble_deliver+0x2cf>
					fsm_pkt_send(skb,STRM_TO_PDCP);
    ff93:	ba 06 00 00 00       	mov    $0x6,%edx
    ff98:	89 d8                	mov    %ebx,%eax
    ff9a:	e8 fc ff ff ff       	call   ff9b <rlc_UM5_reassemble_deliver+0x2db>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
    ff9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    ffa2:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    ffa9:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
    ffb0:	e8 fc ff ff ff       	call   ffb1 <rlc_UM5_reassemble_deliver+0x2f1>
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    ffb5:	8b 55 d0             	mov    -0x30(%ebp),%edx
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
					fsm_pkt_send(skb,STRM_TO_PDCP);
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
    ffb8:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
				}
                
				int j;
				for(j=1; j<count;j++)
    ffbc:	39 55 ec             	cmp    %edx,-0x14(%ebp)
    ffbf:	74 67                	je     10028 <rlc_UM5_reassemble_deliver+0x368>
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ffc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ffc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ffc7:	0f b7 5c 10 22       	movzwl 0x22(%eax,%edx,1),%ebx
    ffcc:	89 d8                	mov    %ebx,%eax
    ffce:	e8 fc ff ff ff       	call   ffcf <rlc_UM5_reassemble_deliver+0x30f>

					fsm_skb_reserve(new_skb,length);
    ffd3:	89 da                	mov    %ebx,%edx
                
				int j;
				for(j=1; j<count;j++)
				{
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);
    ffd5:	89 c6                	mov    %eax,%esi

					fsm_skb_reserve(new_skb,length);
    ffd7:	e8 fc ff ff ff       	call   ffd8 <rlc_UM5_reassemble_deliver+0x318>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
    ffdc:	8b 07                	mov    (%edi),%eax
    ffde:	89 da                	mov    %ebx,%edx
    ffe0:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ffe6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ffe9:	89 f0                	mov    %esi,%eax
    ffeb:	e8 fc ff ff ff       	call   ffec <rlc_UM5_reassemble_deliver+0x32c>
    fff0:	8b 55 e0             	mov    -0x20(%ebp),%edx
    fff3:	89 d9                	mov    %ebx,%ecx
    fff5:	e8 fc ff ff ff       	call   fff6 <rlc_UM5_reassemble_deliver+0x336>
					fsm_skb_pull(tbuff->pkt,length ) ;
    fffa:	8b 07                	mov    (%edi),%eax
    fffc:	89 da                	mov    %ebx,%edx
					skb = new_skb;
    fffe:	89 f3                	mov    %esi,%ebx
					length = pPduhdrExt->LI[j];
					FSM_PKT *new_skb = fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
   10000:	e8 fc ff ff ff       	call   10001 <rlc_UM5_reassemble_deliver+0x341>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10005:	89 f0                	mov    %esi,%eax
   10007:	e8 fc ff ff ff       	call   10008 <rlc_UM5_reassemble_deliver+0x348>
   1000c:	83 f8 01             	cmp    $0x1,%eax
   1000f:	0f 87 6b ff ff ff    	ja     ff80 <rlc_UM5_reassemble_deliver+0x2c0>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   10015:	ba 02 00 00 00       	mov    $0x2,%edx
   1001a:	89 f0                	mov    %esi,%eax
   1001c:	e8 fc ff ff ff       	call   1001d <rlc_UM5_reassemble_deliver+0x35d>
   10021:	89 c3                	mov    %eax,%ebx
   10023:	e9 58 ff ff ff       	jmp    ff80 <rlc_UM5_reassemble_deliver+0x2c0>
   10028:	89 fe                	mov    %edi,%esi
                    
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
   1002a:	8b 06                	mov    (%esi),%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   1002c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   1002f:	0f b7 58 50          	movzwl 0x50(%eax),%ebx
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   10033:	f6 01 40             	testb  $0x40,(%ecx)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10036:	89 d8                	mov    %ebx,%eax
					SV(countSendToUpper)++;
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
                    
				}
               
				if(pduhdr->FIsecond==0)
   10038:	0f 85 e2 00 00 00    	jne    10120 <rlc_UM5_reassemble_deliver+0x460>
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   1003e:	e8 fc ff ff ff       	call   1003f <rlc_UM5_reassemble_deliver+0x37f>
					fsm_skb_reserve(new_skb,length);
   10043:	89 da                	mov    %ebx,%edx
				}
               
				if(pduhdr->FIsecond==0)
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10045:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
   10047:	e8 fc ff ff ff       	call   10048 <rlc_UM5_reassemble_deliver+0x388>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1004c:	8b 06                	mov    (%esi),%eax
   1004e:	89 da                	mov    %ebx,%edx
   10050:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10056:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10059:	89 f8                	mov    %edi,%eax
   1005b:	e8 fc ff ff ff       	call   1005c <rlc_UM5_reassemble_deliver+0x39c>
   10060:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10063:	89 d9                	mov    %ebx,%ecx
   10065:	e8 fc ff ff ff       	call   10066 <rlc_UM5_reassemble_deliver+0x3a6>
					fsm_skb_pull(tbuff->pkt,length) ;
   1006a:	8b 06                	mov    (%esi),%eax
   1006c:	89 da                	mov    %ebx,%edx
					skb = new_skb ;
   1006e:	89 fb                	mov    %edi,%ebx
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length) ;
   10070:	e8 fc ff ff ff       	call   10071 <rlc_UM5_reassemble_deliver+0x3b1>
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10075:	89 f8                	mov    %edi,%eax
   10077:	e8 fc ff ff ff       	call   10078 <rlc_UM5_reassemble_deliver+0x3b8>
   1007c:	83 f8 01             	cmp    $0x1,%eax
   1007f:	0f 86 1f 02 00 00    	jbe    102a4 <rlc_UM5_reassemble_deliver+0x5e4>
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
			    	}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   10085:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10088:	b9 02 00 00 00       	mov    $0x2,%ecx
   1008d:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   10093:	e8 fc ff ff ff       	call   10094 <rlc_UM5_reassemble_deliver+0x3d4>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   10098:	89 d8                	mov    %ebx,%eax
   1009a:	ba 06 00 00 00       	mov    $0x6,%edx
   1009f:	e8 fc ff ff ff       	call   100a0 <rlc_UM5_reassemble_deliver+0x3e0>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   100a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   100a7:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");                  
   100ae:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
   100b5:	e8 fc ff ff ff       	call   100b6 <rlc_UM5_reassemble_deliver+0x3f6>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   100ba:	8b 56 10             	mov    0x10(%esi),%edx
   100bd:	8b 46 14             	mov    0x14(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   100c0:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   100c3:	89 10                	mov    %edx,(%eax)
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
   100c5:	8b 06                	mov    (%esi),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   100c7:	c7 46 10 00 01 10 00 	movl   $0x100100,0x10(%esi)
	entry->prev = LIST_POISON2;
   100ce:	c7 46 14 00 02 20 00 	movl   $0x200200,0x14(%esi)
   100d5:	e8 fc ff ff ff       	call   100d6 <rlc_UM5_reassemble_deliver+0x416>
					tbuff->pkt = NULL;
					fsm_mem_free(tbuff);
   100da:	89 f0                	mov    %esi,%eax
                    
					pdu_left->SN5_Left = pduhdr->SN;
					pdu_left->sduLeft = new_skb;
					list_del(&tbuff->list);
					fsm_pkt_destroy(tbuff->pkt);	
					tbuff->pkt = NULL;
   100dc:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					fsm_mem_free(tbuff);
   100e2:	e8 fc ff ff ff       	call   100e3 <rlc_UM5_reassemble_deliver+0x423>
					tbuff = NULL;
				}
				if(pPduhdrExt != NULL)
   100e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   100ea:	85 c0                	test   %eax,%eax
   100ec:	0f 84 76 fc ff ff    	je     fd68 <rlc_UM5_reassemble_deliver+0xa8>
				{
					fsm_mem_free(pPduhdrExt);
   100f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   100f5:	e8 fc ff ff ff       	call   100f6 <rlc_UM5_reassemble_deliver+0x436>
   100fa:	e9 69 fc ff ff       	jmp    fd68 <rlc_UM5_reassemble_deliver+0xa8>
   100ff:	90                   	nop
			}
			umIns->umRecvWindow10[i]=NULL;
		}//end if
	}//end for
    
}
   10100:	83 c4 34             	add    $0x34,%esp
   10103:	5b                   	pop    %ebx
   10104:	5e                   	pop    %esi
   10105:	5f                   	pop    %edi
   10106:	5d                   	pop    %ebp
   10107:	c3                   	ret    
					tbuff=NULL;
				}

				else
				{
					pdu_left->SN5_Left = pduhdr->SN;
   10108:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1010b:	83 e0 1f             	and    $0x1f,%eax
   1010e:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft=tbuff->pkt;
   10111:	8b 06                	mov    (%esi),%eax
   10113:	89 42 04             	mov    %eax,0x4(%edx)
   10116:	e9 2d fc ff ff       	jmp    fd48 <rlc_UM5_reassemble_deliver+0x88>
   1011b:	90                   	nop
   1011c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10120:	e8 fc ff ff ff       	call   10121 <rlc_UM5_reassemble_deliver+0x461>
					fsm_skb_reserve(new_skb,length);
   10125:	89 da                	mov    %ebx,%edx
					tbuff = NULL;
				}
				else
				{
					length = tbuff->pkt->len;
					FSM_PKT *new_skb = fsm_pkt_create(length);
   10127:	89 c7                	mov    %eax,%edi
					fsm_skb_reserve(new_skb,length);
   10129:	e8 fc ff ff ff       	call   1012a <rlc_UM5_reassemble_deliver+0x46a>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1012e:	8b 06                	mov    (%esi),%eax
   10130:	89 da                	mov    %ebx,%edx
   10132:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10138:	89 45 ec             	mov    %eax,-0x14(%ebp)
   1013b:	89 f8                	mov    %edi,%eax
   1013d:	e8 fc ff ff ff       	call   1013e <rlc_UM5_reassemble_deliver+0x47e>
   10142:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10145:	89 d9                	mov    %ebx,%ecx
   10147:	e8 fc ff ff ff       	call   10148 <rlc_UM5_reassemble_deliver+0x488>
					fsm_skb_pull(tbuff->pkt,tbuff->pkt->len) ;
   1014c:	8b 06                	mov    (%esi),%eax
   1014e:	8b 50 50             	mov    0x50(%eax),%edx
   10151:	e8 fc ff ff ff       	call   10152 <rlc_UM5_reassemble_deliver+0x492>
                    
					pdu_left->SN5_Left = pduhdr->SN;
   10156:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   10159:	0f b6 02             	movzbl (%edx),%eax
   1015c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1015f:	83 e0 1f             	and    $0x1f,%eax
   10162:	66 89 02             	mov    %ax,(%edx)
					pdu_left->sduLeft = new_skb;
   10165:	89 7a 04             	mov    %edi,0x4(%edx)
   10168:	e9 4d ff ff ff       	jmp    100ba <rlc_UM5_reassemble_deliver+0x3fa>
   1016d:	8d 76 00             	lea    0x0(%esi),%esi
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
					}
				}
				else
				{
					clear_left_pdu(pdu_left);
   10170:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10173:	e8 fc ff ff ff       	call   10174 <rlc_UM5_reassemble_deliver+0x4b4>

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10178:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1017b:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1017f:	89 d8                	mov    %ebx,%eax
   10181:	e8 fc ff ff ff       	call   10182 <rlc_UM5_reassemble_deliver+0x4c2>

					fsm_skb_reserve(new_skb,length);
   10186:	89 da                	mov    %ebx,%edx
				else
				{
					clear_left_pdu(pdu_left);

					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);
   10188:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   1018a:	e8 fc ff ff ff       	call   1018b <rlc_UM5_reassemble_deliver+0x4cb>
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
   1018f:	8b 06                	mov    (%esi),%eax
   10191:	89 da                	mov    %ebx,%edx
   10193:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10199:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1019c:	89 f8                	mov    %edi,%eax
   1019e:	e8 fc ff ff ff       	call   1019f <rlc_UM5_reassemble_deliver+0x4df>
   101a3:	8b 55 e0             	mov    -0x20(%ebp),%edx
   101a6:	89 d9                	mov    %ebx,%ecx
   101a8:	e8 fc ff ff ff       	call   101a9 <rlc_UM5_reassemble_deliver+0x4e9>
					fsm_skb_pull(tbuff->pkt,length ) ;
   101ad:	8b 06                	mov    (%esi),%eax
   101af:	89 da                	mov    %ebx,%edx
					skb = new_skb;
   101b1:	89 fb                	mov    %edi,%ebx
					length =pPduhdrExt->LI[0];
					FSM_PKT *new_skb =fsm_pkt_create(length);

					fsm_skb_reserve(new_skb,length);
					fsm_mem_cpy(fsm_skb_push(new_skb,length),tbuff->pkt->data,length);
					fsm_skb_pull(tbuff->pkt,length ) ;
   101b3:	e8 fc ff ff ff       	call   101b4 <rlc_UM5_reassemble_deliver+0x4f4>
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   101b8:	89 f8                	mov    %edi,%eax
   101ba:	e8 fc ff ff ff       	call   101bb <rlc_UM5_reassemble_deliver+0x4fb>
   101bf:	83 f8 01             	cmp    $0x1,%eax
   101c2:	0f 86 f7 01 00 00    	jbe    103bf <rlc_UM5_reassemble_deliver+0x6ff>
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
					}
					fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   101c8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   101cb:	b9 02 00 00 00       	mov    $0x2,%ecx
   101d0:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   101d6:	e8 fc ff ff ff       	call   101d7 <rlc_UM5_reassemble_deliver+0x517>
					fsm_pkt_send(skb,STRM_TO_PDCP);
   101db:	89 d8                	mov    %ebx,%eax
   101dd:	ba 06 00 00 00       	mov    $0x6,%edx
   101e2:	e8 fc ff ff ff       	call   101e3 <rlc_UM5_reassemble_deliver+0x523>
					//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
					SV(countSendToUpper)++;
   101e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   101ea:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
					fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   101f1:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
   101f8:	e8 fc ff ff ff       	call   101f9 <rlc_UM5_reassemble_deliver+0x539>
   101fd:	e9 5a fd ff ff       	jmp    ff5c <rlc_UM5_reassemble_deliver+0x29c>
   10202:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			if((pduhdr->E==0)&&(pduhdr->FIfirst==1))
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
   10208:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
   1020b:	8b 16                	mov    (%esi),%edx
   1020d:	8b 41 04             	mov    0x4(%ecx),%eax
   10210:	8b 40 50             	mov    0x50(%eax),%eax
   10213:	66 03 42 50          	add    0x50(%edx),%ax
					new_skb = fsm_pkt_create(length);
   10217:	0f b7 d8             	movzwl %ax,%ebx
   1021a:	89 d8                	mov    %ebx,%eax
   1021c:	e8 fc ff ff ff       	call   1021d <rlc_UM5_reassemble_deliver+0x55d>

					fsm_skb_reserve(new_skb,length);
   10221:	89 da                	mov    %ebx,%edx
			{
				if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%32==pduhdr->SN)
				{
					FSM_PKT *new_skb;
					length = pdu_left->sduLeft->len + tbuff->pkt->len;
					new_skb = fsm_pkt_create(length);
   10223:	89 c7                	mov    %eax,%edi

					fsm_skb_reserve(new_skb,length);
   10225:	e8 fc ff ff ff       	call   10226 <rlc_UM5_reassemble_deliver+0x566>
					fsm_mem_cpy(fsm_skb_push(new_skb,tbuff->pkt->len),tbuff->pkt->data,tbuff->pkt->len);
   1022a:	8b 06                	mov    (%esi),%eax
   1022c:	8b 58 50             	mov    0x50(%eax),%ebx
   1022f:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10235:	89 f8                	mov    %edi,%eax
   10237:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1023a:	89 da                	mov    %ebx,%edx
   1023c:	e8 fc ff ff ff       	call   1023d <rlc_UM5_reassemble_deliver+0x57d>
   10241:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10244:	89 d9                	mov    %ebx,%ecx
   10246:	e8 fc ff ff ff       	call   10247 <rlc_UM5_reassemble_deliver+0x587>
					fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1024b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1024e:	8b 42 04             	mov    0x4(%edx),%eax
   10251:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   10257:	8b 58 50             	mov    0x50(%eax),%ebx
   1025a:	89 f8                	mov    %edi,%eax
   1025c:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1025f:	89 da                	mov    %ebx,%edx
   10261:	e8 fc ff ff ff       	call   10262 <rlc_UM5_reassemble_deliver+0x5a2>
   10266:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10269:	89 d9                	mov    %ebx,%ecx
   1026b:	e8 fc ff ff ff       	call   1026c <rlc_UM5_reassemble_deliver+0x5ac>
					clear_left_pdu(pdu_left);
   10270:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10273:	e8 fc ff ff ff       	call   10274 <rlc_UM5_reassemble_deliver+0x5b4>
					if(tbuff->pkt != NULL)
   10278:	8b 06                	mov    (%esi),%eax
   1027a:	85 c0                	test   %eax,%eax
   1027c:	74 0b                	je     10289 <rlc_UM5_reassemble_deliver+0x5c9>
					{
						fsm_pkt_destroy(tbuff->pkt);
   1027e:	e8 fc ff ff ff       	call   1027f <rlc_UM5_reassemble_deliver+0x5bf>
						tbuff->pkt = NULL;
   10283:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
					}
					if(pduhdr->FIsecond==0)
   10289:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1028c:	0f b6 01             	movzbl (%ecx),%eax
   1028f:	a8 40                	test   $0x40,%al
   10291:	74 24                	je     102b7 <rlc_UM5_reassemble_deliver+0x5f7>
						SV(countSendToUpper)++;
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n"); 
					}
					else
					{
						pdu_left->SN5_Left = pduhdr->SN;
   10293:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10296:	83 e0 1f             	and    $0x1f,%eax
   10299:	66 89 02             	mov    %ax,(%edx)
						pdu_left->sduLeft = new_skb;
   1029c:	89 7a 04             	mov    %edi,0x4(%edx)
   1029f:	e9 a4 fa ff ff       	jmp    fd48 <rlc_UM5_reassemble_deliver+0x88>
					fsm_skb_pull(tbuff->pkt,length) ;
					skb = new_skb ;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
			    	{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   102a4:	ba 02 00 00 00       	mov    $0x2,%edx
   102a9:	89 f8                	mov    %edi,%eax
   102ab:	e8 fc ff ff ff       	call   102ac <rlc_UM5_reassemble_deliver+0x5ec>
   102b0:	89 c3                	mov    %eax,%ebx
   102b2:	e9 ce fd ff ff       	jmp    10085 <rlc_UM5_reassemble_deliver+0x3c5>
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   102b7:	ba 06 00 00 00       	mov    $0x6,%edx
   102bc:	89 f8                	mov    %edi,%eax
   102be:	e8 fc ff ff ff       	call   102bf <rlc_UM5_reassemble_deliver+0x5ff>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   102c3:	89 f8                	mov    %edi,%eax
						fsm_pkt_destroy(tbuff->pkt);
						tbuff->pkt = NULL;
					}
					if(pduhdr->FIsecond==0)
					{
						skb = new_skb;
   102c5:	89 fb                	mov    %edi,%ebx
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   102c7:	e8 fc ff ff ff       	call   102c8 <rlc_UM5_reassemble_deliver+0x608>
   102cc:	83 f8 01             	cmp    $0x1,%eax
   102cf:	0f 87 cb fb ff ff    	ja     fea0 <rlc_UM5_reassemble_deliver+0x1e0>

					skb = tbuff->pkt;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
						skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   102d5:	89 d8                	mov    %ebx,%eax
   102d7:	ba 02 00 00 00       	mov    $0x2,%edx
   102dc:	e8 fc ff ff ff       	call   102dd <rlc_UM5_reassemble_deliver+0x61d>
   102e1:	89 c3                	mov    %eax,%ebx
   102e3:	e9 b8 fb ff ff       	jmp    fea0 <rlc_UM5_reassemble_deliver+0x1e0>
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
   102e8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   102eb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   102ee:	8b 42 04             	mov    0x4(%edx),%eax
   102f1:	8b 40 50             	mov    0x50(%eax),%eax
   102f4:	66 03 41 20          	add    0x20(%ecx),%ax
						new_skb = fsm_pkt_create(length);
   102f8:	0f b7 d8             	movzwl %ax,%ebx
   102fb:	89 d8                	mov    %ebx,%eax
   102fd:	e8 fc ff ff ff       	call   102fe <rlc_UM5_reassemble_deliver+0x63e>

						fsm_skb_reserve(new_skb,length);
   10302:	89 da                	mov    %ebx,%edx
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
						FSM_PKT *new_skb;
						length = pdu_left->sduLeft->len + pPduhdrExt->LI[0];
						new_skb = fsm_pkt_create(length);
   10304:	89 c7                	mov    %eax,%edi

						fsm_skb_reserve(new_skb,length);
   10306:	e8 fc ff ff ff       	call   10307 <rlc_UM5_reassemble_deliver+0x647>
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
   1030b:	8b 06                	mov    (%esi),%eax
   1030d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10313:	89 45 e0             	mov    %eax,-0x20(%ebp)
   10316:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10319:	0f b7 58 20          	movzwl 0x20(%eax),%ebx
   1031d:	89 f8                	mov    %edi,%eax
   1031f:	89 da                	mov    %ebx,%edx
   10321:	e8 fc ff ff ff       	call   10322 <rlc_UM5_reassemble_deliver+0x662>
   10326:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10329:	89 d9                	mov    %ebx,%ecx
   1032b:	e8 fc ff ff ff       	call   1032c <rlc_UM5_reassemble_deliver+0x66c>
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
   10330:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10333:	0f b7 50 20          	movzwl 0x20(%eax),%edx
   10337:	8b 06                	mov    (%esi),%eax
   10339:	e8 fc ff ff ff       	call   1033a <rlc_UM5_reassemble_deliver+0x67a>
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   1033e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10341:	8b 42 04             	mov    0x4(%edx),%eax
   10344:	8b 58 50             	mov    0x50(%eax),%ebx
   10347:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
   1034d:	89 f8                	mov    %edi,%eax
   1034f:	89 55 e0             	mov    %edx,-0x20(%ebp)
   10352:	89 da                	mov    %ebx,%edx
   10354:	e8 fc ff ff ff       	call   10355 <rlc_UM5_reassemble_deliver+0x695>
   10359:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1035c:	89 d9                	mov    %ebx,%ecx

						skb = new_skb;
   1035e:	89 fb                	mov    %edi,%ebx
						new_skb = fsm_pkt_create(length);

						fsm_skb_reserve(new_skb,length);
						fsm_mem_cpy(fsm_skb_push(new_skb,pPduhdrExt->LI[0]),tbuff->pkt->data,pPduhdrExt->LI[0]);
						fsm_skb_pull(tbuff->pkt,pPduhdrExt->LI[0] ) ;
						fsm_mem_cpy(fsm_skb_push(new_skb,pdu_left->sduLeft->len),pdu_left->sduLeft->data,pdu_left->sduLeft->len);
   10360:	e8 fc ff ff ff       	call   10361 <rlc_UM5_reassemble_deliver+0x6a1>

						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10365:	ba 06 00 00 00       	mov    $0x6,%edx
   1036a:	89 f8                	mov    %edi,%eax
   1036c:	e8 fc ff ff ff       	call   1036d <rlc_UM5_reassemble_deliver+0x6ad>
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
   10371:	89 f8                	mov    %edi,%eax
   10373:	e8 fc ff ff ff       	call   10374 <rlc_UM5_reassemble_deliver+0x6b4>
   10378:	83 f8 01             	cmp    $0x1,%eax
   1037b:	76 55                	jbe    103d2 <rlc_UM5_reassemble_deliver+0x712>
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
						}
						fsm_mem_cpy(skb->head,icimsg,sizeof(URLC_IciMsg));
   1037d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   10380:	b9 02 00 00 00       	mov    $0x2,%ecx
   10385:	8b 83 a8 00 00 00    	mov    0xa8(%ebx),%eax
   1038b:	e8 fc ff ff ff       	call   1038c <rlc_UM5_reassemble_deliver+0x6cc>
						fsm_pkt_send(skb,STRM_TO_PDCP);
   10390:	ba 06 00 00 00       	mov    $0x6,%edx
   10395:	89 d8                	mov    %ebx,%eax
   10397:	e8 fc ff ff ff       	call   10398 <rlc_UM5_reassemble_deliver+0x6d8>
						//fsm_pkt_send(skb, STRM_TO_IPADP);	//for test 20150828
						SV(countSendToUpper)++;
   1039c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1039f:	83 80 90 5a 00 00 01 	addl   $0x1,0x5a90(%eax)
						fsm_printf("[RLC][rlc_UM5_reassemble_deliver] <--send to PDCP\n");
   103a6:	c7 04 24 68 3d 00 00 	movl   $0x3d68,(%esp)
   103ad:	e8 fc ff ff ff       	call   103ae <rlc_UM5_reassemble_deliver+0x6ee>
                      
						clear_left_pdu(pdu_left);
   103b2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   103b5:	e8 fc ff ff ff       	call   103b6 <rlc_UM5_reassemble_deliver+0x6f6>
				count = get_UmPduhdExt(1,tbuff,0,pPduhdrExt);  
                
				if(pduhdr->FIfirst==1)
				{
					if(pdu_left->SN5_Left != -1 && (pdu_left->SN5_Left+1)%512==pduhdr->SN)
					{
   103ba:	e9 9d fb ff ff       	jmp    ff5c <rlc_UM5_reassemble_deliver+0x29c>
					fsm_skb_pull(tbuff->pkt,length ) ;
					skb = new_skb;
					//fsm_printf(5,"%s\n",skb->data);
					if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
					{
			    		skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   103bf:	ba 02 00 00 00       	mov    $0x2,%edx
   103c4:	89 f8                	mov    %edi,%eax
   103c6:	e8 fc ff ff ff       	call   103c7 <rlc_UM5_reassemble_deliver+0x707>
   103cb:	89 c3                	mov    %eax,%ebx
   103cd:	e9 f6 fd ff ff       	jmp    101c8 <rlc_UM5_reassemble_deliver+0x508>
						skb = new_skb;
						//fsm_printf(5,"%s\n",skb->data);
						fsm_pkt_send(skb,STRM_TO_PDCP);
						if( fsm_skb_headroom(skb) < sizeof(URLC_IciMsg) )
						{
							skb = fsm_skb_realloc_headeroom(skb,sizeof(URLC_IciMsg));
   103d2:	ba 02 00 00 00       	mov    $0x2,%edx
   103d7:	89 f8                	mov    %edi,%eax
   103d9:	e8 fc ff ff ff       	call   103da <rlc_UM5_reassemble_deliver+0x71a>
   103de:	89 c3                	mov    %eax,%ebx
   103e0:	eb 9b                	jmp    1037d <rlc_UM5_reassemble_deliver+0x6bd>
   103e2:	90                   	nop
   103e3:	90                   	nop
   103e4:	90                   	nop
   103e5:	90                   	nop
   103e6:	90                   	nop
   103e7:	90                   	nop
   103e8:	90                   	nop
   103e9:	90                   	nop
   103ea:	90                   	nop
   103eb:	90                   	nop
   103ec:	90                   	nop
   103ed:	90                   	nop
   103ee:	90                   	nop
   103ef:	90                   	nop

000103f0 <Am_instance_build>:
void skb_printf(FSM_PKT *pkt);
void buff_printf(struct AM_Instance *amIns);


void Am_instance_build()
{
   103f0:	55                   	push   %ebp
   103f1:	89 e5                	mov    %esp,%ebp
   103f3:	57                   	push   %edi
   103f4:	56                   	push   %esi
   103f5:	53                   	push   %ebx
   103f6:	83 ec 08             	sub    $0x8,%esp
   103f9:	e8 fc ff ff ff       	call   103fa <Am_instance_build+0xa>
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
   103fe:	e8 fc ff ff ff       	call   103ff <Am_instance_build+0xf>
   10403:	89 c2                	mov    %eax,%edx
	amIns =  instance_create(struct AM_Instance);
   10405:	b8 0c 23 00 00       	mov    $0x230c,%eax
   1040a:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1040d:	e8 fc ff ff ff       	call   1040e <Am_instance_build+0x1e>
	amIns->rbId = 4;
   10412:	c6 40 02 04          	movb   $0x4,0x2(%eax)
void Am_instance_build()
{
    struct AM_Instance *amIns;
    int i;
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   10416:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 4;
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 4;
   10418:	c6 40 03 04          	movb   $0x4,0x3(%eax)
	amIns->reorderTimerValue= 100*100;
   1041c:	c7 40 1c 10 27 00 00 	movl   $0x2710,0x1c(%eax)
	amIns->statProhTimerValue =150*150;
   10423:	c7 40 28 e4 57 00 00 	movl   $0x57e4,0x28(%eax)
	amIns->pollRetxTimerValue = 100*100;
   1042a:	c7 40 10 10 27 00 00 	movl   $0x2710,0x10(%eax)
	amIns->pollPDU = 32;
   10431:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   10438:	20 00 
	amIns->pollBYTE = 1000;
   1043a:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   10441:	e8 03 
	amIns->maxRetxThreshold = 4;
   10443:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   1044a:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   1044c:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10453:	00 00 00 
   10456:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   1045d:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10464:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10467:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   1046e:	00 00 00 
   10471:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10478:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   1047f:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10482:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10489:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   10490:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   10497:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   1049d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   104a0:	eb 08                	jmp    104aa <Am_instance_build+0xba>
   104a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   104a8:	89 fe                	mov    %edi,%esi
   104aa:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   104b1:	ff 
   104b2:	8d 7e 01             	lea    0x1(%esi),%edi
   104b5:	0f 85 b4 01 00 00    	jne    1066f <Am_instance_build+0x27f>
   104bb:	83 ff 31             	cmp    $0x31,%edi
   104be:	7e e8                	jle    104a8 <Am_instance_build+0xb8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   104c0:	89 55 f0             	mov    %edx,-0x10(%ebp)
   104c3:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   104ca:	e8 fc ff ff ff       	call   104cb <Am_instance_build+0xdb>
   104cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
   104d2:	eb 06                	jmp    104da <Am_instance_build+0xea>
   104d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   104d8:	89 f7                	mov    %esi,%edi
   104da:	83 bc ba 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%edi,4)
   104e1:	ff 
   104e2:	8d 77 01             	lea    0x1(%edi),%esi
   104e5:	0f 85 68 01 00 00    	jne    10653 <Am_instance_build+0x263>
   104eb:	83 fe 31             	cmp    $0x31,%esi
   104ee:	7e e8                	jle    104d8 <Am_instance_build+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   104f0:	89 55 f0             	mov    %edx,-0x10(%ebp)
   104f3:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   104fa:	e8 fc ff ff ff       	call   104fb <Am_instance_build+0x10b>
   104ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10502:	eb 06                	jmp    1050a <Am_instance_build+0x11a>
   10504:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10508:	89 c6                	mov    %eax,%esi
   1050a:	83 bc b2 28 02 00 00 	cmpl   $0xffffffff,0x228(%edx,%esi,4)
   10511:	ff 
   10512:	8d 46 01             	lea    0x1(%esi),%eax
   10515:	0f 85 1c 01 00 00    	jne    10637 <Am_instance_build+0x247>
   1051b:	83 f8 31             	cmp    $0x31,%eax
   1051e:	7e e8                	jle    10508 <Am_instance_build+0x118>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10520:	89 55 f0             	mov    %edx,-0x10(%ebp)
   10523:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   1052a:	e8 fc ff ff ff       	call   1052b <Am_instance_build+0x13b>
   1052f:	8b 55 f0             	mov    -0x10(%ebp),%edx
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10532:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10535:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   10538:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   1053b:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10541:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10547:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   1054d:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10553:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   10559:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   1055f:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10565:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   1056b:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10571:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10577:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   1057d:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10583:	31 c0                	xor    %eax,%eax
	else
		{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10585:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   1058c:	00 00 
   1058e:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   10595:	00 00 
   10597:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   1059e:	00 00 
   105a0:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   105a7:	00 00 
   105a9:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   105b0:	00 00 
   105b2:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   105b9:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   105bb:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   105c2:	00 02 
   105c4:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   105cb:	00 02 
   105cd:	8d 76 00             	lea    0x0(%esi),%esi
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   105d0:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   105d7:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   105db:	83 c0 01             	add    $0x1,%eax
   105de:	3d 00 04 00 00       	cmp    $0x400,%eax
   105e3:	75 eb                	jne    105d0 <Am_instance_build+0x1e0>
   105e5:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   105e8:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   105ef:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   105f3:	83 c0 01             	add    $0x1,%eax
   105f6:	3d 00 04 00 00       	cmp    $0x400,%eax
   105fb:	75 eb                	jne    105e8 <Am_instance_build+0x1f8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   105fd:	8b 82 f8 25 00 00    	mov    0x25f8(%edx),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10603:	8d 8b 04 23 00 00    	lea    0x2304(%ebx),%ecx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10609:	89 8a f8 25 00 00    	mov    %ecx,0x25f8(%edx)
   1060f:	81 c2 f4 25 00 00    	add    $0x25f4,%edx
   10615:	89 93 04 23 00 00    	mov    %edx,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   1061b:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10621:	89 08                	mov    %ecx,(%eax)
	fsm_printf(" am instance has established\n");
   10623:	c7 04 24 25 08 00 00 	movl   $0x825,(%esp)
   1062a:	e8 fc ff ff ff       	call   1062b <Am_instance_build+0x23b>

    FOUT;
}
   1062f:	83 c4 08             	add    $0x8,%esp
   10632:	5b                   	pop    %ebx
   10633:	5e                   	pop    %esi
   10634:	5f                   	pop    %edi
   10635:	5d                   	pop    %ebp
   10636:	c3                   	ret    
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10637:	83 f8 31             	cmp    $0x31,%eax
   1063a:	0f 8f e0 fe ff ff    	jg     10520 <Am_instance_build+0x130>
	else
		{
		amIns->statProhTimerCode = i - 1;
   10640:	89 73 24             	mov    %esi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10643:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   1064a:	ff ff ff ff 
   1064e:	e9 df fe ff ff       	jmp    10532 <Am_instance_build+0x142>
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10653:	83 fe 31             	cmp    $0x31,%esi
   10656:	0f 8f 94 fe ff ff    	jg     104f0 <Am_instance_build+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   1065c:	89 7b 18             	mov    %edi,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   1065f:	c7 84 ba 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%edi,4)
   10666:	ff ff ff ff 
   1066a:	e9 9b fe ff ff       	jmp    1050a <Am_instance_build+0x11a>
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   1066f:	83 ff 31             	cmp    $0x31,%edi
   10672:	0f 8f 48 fe ff ff    	jg     104c0 <Am_instance_build+0xd0>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10678:	89 73 0c             	mov    %esi,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   1067b:	c7 84 b2 28 02 00 00 	movl   $0xffffffff,0x228(%edx,%esi,4)
   10682:	ff ff ff ff 
   10686:	e9 4f fe ff ff       	jmp    104da <Am_instance_build+0xea>
   1068b:	90                   	nop
   1068c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

00010690 <UM_instance_bulid>:

    FOUT;
}

void UM_instance_bulid(void)
{
   10690:	55                   	push   %ebp
   10691:	89 e5                	mov    %esp,%ebp
   10693:	83 ec 08             	sub    $0x8,%esp
   10696:	e8 fc ff ff ff       	call   10697 <UM_instance_bulid+0x7>
	SV_PTR_GET(rlc_mac_sv);
   1069b:	e8 fc ff ff ff       	call   1069c <UM_instance_bulid+0xc>
	SV(umText).snFiledLength = 5;
	SV(umText).lcid = 2;
	SV(umText).rbid = 2 ;
	SV(umText).CurrentStatVar = ST_TRAN;
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
   106a0:	8d 90 64 5a 00 00    	lea    0x5a64(%eax),%edx

void UM_instance_bulid(void)
{
	SV_PTR_GET(rlc_mac_sv);
 //    SV(umText) =  instance_create(UM_TX_Instance);
	SV(umText).snFiledLength = 5;
   106a6:	66 c7 80 76 5a 00 00 	movw   $0x5,0x5a76(%eax)
   106ad:	05 00 
	SV(umText).lcid = 2;
   106af:	c6 80 4f 5a 00 00 02 	movb   $0x2,0x5a4f(%eax)
	SV(umText).rbid = 2 ;
   106b6:	c6 80 4e 5a 00 00 02 	movb   $0x2,0x5a4e(%eax)
	SV(umText).CurrentStatVar = ST_TRAN;
   106bd:	c6 80 78 5a 00 00 08 	movb   $0x8,0x5a78(%eax)
	SV(umText).umSduBufferNum = SV(umText).umSduBufferSize = 0;
   106c4:	c7 80 6c 5a 00 00 00 	movl   $0x0,0x5a6c(%eax)
   106cb:	00 00 00 
   106ce:	c7 80 70 5a 00 00 00 	movl   $0x0,0x5a70(%eax)
   106d5:	00 00 00 
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   106d8:	89 90 64 5a 00 00    	mov    %edx,0x5a64(%eax)
	list->prev = list;
   106de:	89 90 68 5a 00 00    	mov    %edx,0x5a68(%eax)
	INIT_LIST_HEAD(&SV(umText).umSduBuffer.list);
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
   106e4:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
   106eb:	00 
   106ec:	c7 04 24 9c 3d 00 00 	movl   $0x3d9c,(%esp)
   106f3:	e8 fc ff ff ff       	call   106f4 <UM_instance_bulid+0x64>
}
   106f8:	c9                   	leave  
   106f9:	c3                   	ret    
   106fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00010700 <test>:
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
void test()
{
   10700:	55                   	push   %ebp
   10701:	89 e5                	mov    %esp,%ebp
   10703:	53                   	push   %ebx
   10704:	83 ec 10             	sub    $0x10,%esp
   10707:	e8 fc ff ff ff       	call   10708 <test+0x8>
	struct AM_Instance *amIns;
	void *up, *down;
	SV_PTR_GET(rlc_mac_sv);
   1070c:	e8 fc ff ff ff       	call   1070d <test+0xd>
	//fsm_schedule_self(0,SEGMENT);
	//
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
   10711:	8d 4d f8             	lea    -0x8(%ebp),%ecx
   10714:	8d 55 f4             	lea    -0xc(%ebp),%edx
   10717:	05 18 02 00 00       	add    $0x218,%eax
   1071c:	89 04 24             	mov    %eax,(%esp)
   1071f:	b8 08 00 00 00       	mov    $0x8,%eax
   10724:	e8 fc ff ff ff       	call   10725 <test+0x25>
	amIns = (AM_Instance *)up;	
   10729:	8b 5d f4             	mov    -0xc(%ebp),%ebx
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   1072c:	85 db                	test   %ebx,%ebx
   1072e:	74 30                	je     10760 <test+0x60>
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
   10730:	8b 53 18             	mov    0x18(%ebx),%edx
   10733:	b8 40 0d 03 00       	mov    $0x30d40,%eax
   10738:	e8 fc ff ff ff       	call   10739 <test+0x39>
   1073d:	89 43 14             	mov    %eax,0x14(%ebx)
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
   10740:	8b 43 18             	mov    0x18(%ebx),%eax
   10743:	c7 04 24 dc 3d 00 00 	movl   $0x3ddc,(%esp)
   1074a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1074e:	e8 fc ff ff ff       	call   1074f <test+0x4f>
}
   10753:	83 c4 10             	add    $0x10,%esp
   10756:	5b                   	pop    %ebx
   10757:	5d                   	pop    %ebp
   10758:	c3                   	ret    
   10759:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	//fsm_schedule_self(0,RESEGMENT);
	//
	//fsm_schedule_self(0,REASSAMBLE);
	findInsBylcid(8, &up, &down, &SV(ins_mode));
	amIns = (AM_Instance *)up;	
	if(amIns == NULL) fsm_printf("the instance is not exist\n");
   10760:	c7 04 24 43 08 00 00 	movl   $0x843,(%esp)
   10767:	e8 fc ff ff ff       	call   10768 <test+0x68>
   1076c:	eb d2                	jmp    10740 <test+0x40>
   1076e:	66 90                	xchg   %ax,%ax

00010770 <skb_printf>:
	}
	nposBf = NULL;
}

void skb_printf(FSM_PKT *pkt)
{
   10770:	55                   	push   %ebp
   10771:	89 e5                	mov    %esp,%ebp
   10773:	83 ec 08             	sub    $0x8,%esp
   10776:	e8 fc ff ff ff       	call   10777 <skb_printf+0x7>
	fsm_printf("%s\n",(char *)(pkt->data+4));
   1077b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10781:	c7 04 24 5e 08 00 00 	movl   $0x85e,(%esp)
   10788:	83 c0 04             	add    $0x4,%eax
   1078b:	89 44 24 04          	mov    %eax,0x4(%esp)
   1078f:	e8 fc ff ff ff       	call   10790 <skb_printf+0x20>
	FOUT;
}
   10794:	c9                   	leave  
   10795:	c3                   	ret    
   10796:	8d 76 00             	lea    0x0(%esi),%esi
   10799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000107a0 <buff_printf>:
	else amIns->reorderTimer = fsm_schedule_self(200000,  amIns->reorderTimerCode);
	fsm_printf("amIns->pollRetxTimerCode is %d\n",amIns->reorderTimerCode);
}

void buff_printf(struct AM_Instance *amIns)
{
   107a0:	55                   	push   %ebp
   107a1:	89 e5                	mov    %esp,%ebp
   107a3:	57                   	push   %edi
   107a4:	56                   	push   %esi
   107a5:	53                   	push   %ebx
   107a6:	83 ec 08             	sub    $0x8,%esp
   107a9:	e8 fc ff ff ff       	call   107aa <buff_printf+0xa>
   107ae:	89 c3                	mov    %eax,%ebx
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   107b0:	c7 04 24 62 08 00 00 	movl   $0x862,(%esp)
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
   107b7:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
	struct AmBuffer *nposBf= NULL;
	struct  AmSduBuffer *sdupos = NULL;
	struct  AmSduBuffer *sduBf = NULL;

	//
	fsm_printf("printf the amRetxBuffer\n");
   107bd:	e8 fc ff ff ff       	call   107be <buff_printf+0x1e>
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
   107c2:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   107c8:	c7 04 24 7b 08 00 00 	movl   $0x87b,(%esp)
   107cf:	89 44 24 04          	mov    %eax,0x4(%esp)
   107d3:	e8 fc ff ff ff       	call   107d4 <buff_printf+0x34>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   107d8:	8b b3 9c 01 00 00    	mov    0x19c(%ebx),%esi
	if( !list_empty(&amIns->amRetxBuffer.list) )
   107de:	39 f7                	cmp    %esi,%edi
   107e0:	74 56                	je     10838 <buff_printf+0x98>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   107e2:	8b 1e                	mov    (%esi),%ebx
   107e4:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   107ea:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
   107f0:	eb 0a                	jmp    107fc <buff_printf+0x5c>
   107f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   107f8:	89 de                	mov    %ebx,%esi
   107fa:	89 d3                	mov    %edx,%ebx
		{
			fsm_printf("The PDU SN is %d\n",amRetxBf->SN);
   107fc:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   10803:	c7 04 24 97 08 00 00 	movl   $0x897,(%esp)
   1080a:	89 44 24 04          	mov    %eax,0x4(%esp)
   1080e:	e8 fc ff ff ff       	call   1080f <buff_printf+0x6f>
			skb_printf(amRetxBf->pkt);
   10813:	8b 06                	mov    (%esi),%eax
   10815:	e8 fc ff ff ff       	call   10816 <buff_printf+0x76>
	//
	fsm_printf("printf the amRetxBuffer\n");
	fsm_printf("the amRetxBufferSize is %d\n",amIns->amRetxBufferSize);
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   1081a:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   10820:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   10826:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1082c:	39 c7                	cmp    %eax,%edi
   1082e:	75 c8                	jne    107f8 <buff_printf+0x58>
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
	}
	nposBf = NULL;
}
   10830:	83 c4 08             	add    $0x8,%esp
   10833:	5b                   	pop    %ebx
   10834:	5e                   	pop    %esi
   10835:	5f                   	pop    %edi
   10836:	5d                   	pop    %ebp
   10837:	c3                   	ret    
			skb_printf(amRetxBf->pkt);
		}
	}
	else
	{
		fsm_printf("The amRetxBuffer is empty\n");
   10838:	c7 04 24 a9 08 00 00 	movl   $0x8a9,(%esp)
   1083f:	e8 fc ff ff ff       	call   10840 <buff_printf+0xa0>
   10844:	eb ea                	jmp    10830 <buff_printf+0x90>
   10846:	8d 76 00             	lea    0x0(%esi),%esi
   10849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010850 <add_data_retx>:
{
	fsm_printf("%s\n",(char *)(pkt->data+4));
	FOUT;
}
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
   10850:	55                   	push   %ebp
   10851:	89 e5                	mov    %esp,%ebp
   10853:	57                   	push   %edi
   10854:	56                   	push   %esi
   10855:	53                   	push   %ebx
   10856:	83 ec 04             	sub    $0x4,%esp
   10859:	e8 fc ff ff ff       	call   1085a <add_data_retx+0xa>
   1085e:	89 c6                	mov    %eax,%esi
	SV_PTR_GET(rlc_mac_sv);
   10860:	e8 fc ff ff ff       	call   10861 <add_data_retx+0x11>
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10865:	b8 1a 00 00 00       	mov    $0x1a,%eax
   1086a:	e8 fc ff ff ff       	call   1086b <add_data_retx+0x1b>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   1086f:	ba 02 00 00 00       	mov    $0x2,%edx
void add_data_retx(struct AM_Instance*amIns, u8 lcid)
{
	SV_PTR_GET(rlc_mac_sv);
	char*sdu1 = "context 1.";
	char *sdu2 = "context 2.";
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10874:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->data;;
   10876:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 0;
	fix->P = 0;
	fix->RF = 0;
	fix->SN = 0;
   1087c:	c6 00 00             	movb   $0x0,(%eax)
   1087f:	c6 40 01 84          	movb   $0x84,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10883:	89 d8                	mov    %ebx,%eax
   10885:	e8 fc ff ff ff       	call   10886 <add_data_retx+0x36>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   1088a:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10890:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 0;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10895:	c6 00 0b             	movb   $0xb,(%eax)
   10898:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   1089c:	89 d8                	mov    %ebx,%eax
   1089e:	e8 fc ff ff ff       	call   1089f <add_data_retx+0x4f>
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
   108a3:	b8 c4 08 00 00       	mov    $0x8c4,%eax
   108a8:	e8 fc ff ff ff       	call   108a9 <add_data_retx+0x59>
   108ad:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   108b3:	ba c4 08 00 00       	mov    $0x8c4,%edx
   108b8:	89 c1                	mov    %eax,%ecx
   108ba:	89 f8                	mov    %edi,%eax
   108bc:	e8 fc ff ff ff       	call   108bd <add_data_retx+0x6d>
	fsm_skb_put(skb,strlen(sdu1));
   108c1:	b8 c4 08 00 00       	mov    $0x8c4,%eax
   108c6:	e8 fc ff ff ff       	call   108c7 <add_data_retx+0x77>
   108cb:	89 c2                	mov    %eax,%edx
   108cd:	89 d8                	mov    %ebx,%eax
   108cf:	e8 fc ff ff ff       	call   108d0 <add_data_retx+0x80>
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
   108d4:	b8 cf 08 00 00       	mov    $0x8cf,%eax
   108d9:	e8 fc ff ff ff       	call   108da <add_data_retx+0x8a>
   108de:	8b bb a0 00 00 00    	mov    0xa0(%ebx),%edi
   108e4:	ba cf 08 00 00       	mov    $0x8cf,%edx
   108e9:	89 c1                	mov    %eax,%ecx
   108eb:	89 f8                	mov    %edi,%eax
   108ed:	e8 fc ff ff ff       	call   108ee <add_data_retx+0x9e>
	fsm_skb_put(skb,strlen(sdu2));
   108f2:	b8 cf 08 00 00       	mov    $0x8cf,%eax
   108f7:	e8 fc ff ff ff       	call   108f8 <add_data_retx+0xa8>
   108fc:	89 c2                	mov    %eax,%edx
   108fe:	89 d8                	mov    %ebx,%eax
   10900:	e8 fc ff ff ff       	call   10901 <add_data_retx+0xb1>

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10905:	b8 a4 00 00 00       	mov    $0xa4,%eax
   1090a:	e8 fc ff ff ff       	call   1090b <add_data_retx+0xbb>
	ambuf->pkt = skb;
   1090f:	89 18                	mov    %ebx,(%eax)
	fsm_mem_cpy(skb->tail, sdu1, strlen(sdu1));
	fsm_skb_put(skb,strlen(sdu1));
	fsm_mem_cpy(skb->tail, sdu2, strlen(sdu2));
	fsm_skb_put(skb,strlen(sdu2));

	AmBuffer*ambuf = (AmBuffer*)fsm_mem_alloc(sizeof(AmBuffer));
   10911:	89 c7                	mov    %eax,%edi
	ambuf->pkt = skb;
	ambuf->pktstatus = FULL_SDU;
   10913:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	ambuf->pos = 0;
   1091a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10921:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10928:	00 00 00 
	ambuf->segStart[0] = 0;
   1092b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	ambuf->segEnd[0] = 20;
   10932:	c7 40 50 14 00 00 00 	movl   $0x14,0x50(%eax)
	ambuf->retxCount = 0;
   10939:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10940:	00 00 
	ambuf->SN = 0;
   10942:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10949:	00 00 
	ambuf->headLen = 2*2;
   1094b:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 20;
   10952:	c7 80 98 00 00 00 14 	movl   $0x14,0x98(%eax)
   10959:	00 00 00 
	fsm_printf("add data in retx buffer\n");
   1095c:	c7 04 24 da 08 00 00 	movl   $0x8da,(%esp)
   10963:	e8 fc ff ff ff       	call   10964 <add_data_retx+0x114>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10968:	8b 86 a0 01 00 00    	mov    0x1a0(%esi),%eax
	list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
   1096e:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10974:	89 96 a0 01 00 00    	mov    %edx,0x1a0(%esi)
   1097a:	81 c6 9c 01 00 00    	add    $0x19c,%esi
   10980:	89 b7 9c 00 00 00    	mov    %esi,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   10986:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   1098c:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   1098e:	83 c4 04             	add    $0x4,%esp
   10991:	5b                   	pop    %ebx
   10992:	5e                   	pop    %esi
   10993:	5f                   	pop    %edi
   10994:	5d                   	pop    %ebp
   10995:	c3                   	ret    
   10996:	8d 76 00             	lea    0x0(%esi),%esi
   10999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

000109a0 <Am_instance_add>:
	//   list_add_tail(&umTxIns->umTxList, &SV(vUm_tx_ins).umTxList);
	fsm_printf("PCRLC_BULID_REQ: um tran instance has established(rbid is %d)\n",SV(umText).rbid);
}

void Am_instance_add()
{
   109a0:	55                   	push   %ebp
   109a1:	89 e5                	mov    %esp,%ebp
   109a3:	57                   	push   %edi
   109a4:	56                   	push   %esi
   109a5:	53                   	push   %ebx
   109a6:	83 ec 04             	sub    $0x4,%esp
   109a9:	e8 fc ff ff ff       	call   109aa <Am_instance_add+0xa>
    struct AM_Instance *amIns;
    int i = 0;
    SV_PTR_GET(rlc_mac_sv);
   109ae:	e8 fc ff ff ff       	call   109af <Am_instance_add+0xf>
   109b3:	89 c6                	mov    %eax,%esi
	amIns =  instance_create(struct AM_Instance);
   109b5:	b8 0c 23 00 00       	mov    $0x230c,%eax
   109ba:	e8 fc ff ff ff       	call   109bb <Am_instance_add+0x1b>
}

void Am_instance_add()
{
    struct AM_Instance *amIns;
    int i = 0;
   109bf:	31 d2                	xor    %edx,%edx
    SV_PTR_GET(rlc_mac_sv);
	amIns =  instance_create(struct AM_Instance);
   109c1:	89 c3                	mov    %eax,%ebx
	amIns->rbId = 8;
   109c3:	c6 40 02 08          	movb   $0x8,0x2(%eax)
	//fsm_printf("the rbid is %d\n", amIns->rbId);
	amIns->lcId = 8;
   109c7:	c6 40 03 08          	movb   $0x8,0x3(%eax)
	amIns->reorderTimerValue= 1000*100;
   109cb:	c7 40 1c a0 86 01 00 	movl   $0x186a0,0x1c(%eax)
	amIns->statProhTimerValue = 2000*100;
   109d2:	c7 40 28 40 0d 03 00 	movl   $0x30d40,0x28(%eax)
	amIns->pollRetxTimerValue = 1000*100;
   109d9:	c7 40 10 a0 86 01 00 	movl   $0x186a0,0x10(%eax)
	amIns->pollPDU = 32;
   109e0:	66 c7 80 f6 22 00 00 	movw   $0x20,0x22f6(%eax)
   109e7:	20 00 
	amIns->pollBYTE = 1000;
   109e9:	66 c7 80 f8 22 00 00 	movw   $0x3e8,0x22f8(%eax)
   109f0:	e8 03 
	amIns->maxRetxThreshold = 4;
   109f2:	66 c7 80 fa 22 00 00 	movw   $0x4,0x22fa(%eax)
   109f9:	04 00 
	amIns->amRetxBufferSize = amIns->amSduBufferSize = amIns->ctrlPduBufferSize = 0;
   109fb:	c7 80 b8 01 00 00 00 	movl   $0x0,0x1b8(%eax)
   10a02:	00 00 00 
   10a05:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
   10a0c:	c7 80 a4 01 00 00 00 	movl   $0x0,0x1a4(%eax)
   10a13:	00 00 00 
	amIns->amRetxBufferNum = amIns->amSduBufferNum = amIns->ctrlPduBufferNum = 0;
   10a16:	c7 80 bc 01 00 00 00 	movl   $0x0,0x1bc(%eax)
   10a1d:	00 00 00 
   10a20:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
   10a27:	c7 80 a8 01 00 00 00 	movl   $0x0,0x1a8(%eax)
   10a2e:	00 00 00 
	amIns->pollRetxTimer = amIns->reorderTimer = amIns->statProhTimer = 0;
   10a31:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   10a38:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
   10a3f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amIns->currentStatVar = ST_TRAN;
   10a46:	66 c7 40 2c 08 00    	movw   $0x8,0x2c(%eax)
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
   10a4c:	eb 0d                	jmp    10a5b <Am_instance_add+0xbb>
   10a4e:	66 90                	xchg   %ax,%ax
   10a50:	83 f8 32             	cmp    $0x32,%eax
   10a53:	0f 84 8a 01 00 00    	je     10be3 <Am_instance_add+0x243>
   10a59:	89 c2                	mov    %eax,%edx
   10a5b:	83 bc 96 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edx,4)
   10a62:	ff 
   10a63:	8d 42 01             	lea    0x1(%edx),%eax
   10a66:	74 e8                	je     10a50 <Am_instance_add+0xb0>
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10a68:	83 f8 32             	cmp    $0x32,%eax
   10a6b:	0f 84 72 01 00 00    	je     10be3 <Am_instance_add+0x243>
	else
	{
		amIns->pollRetxTimerCode = i - 1;
   10a71:	89 53 0c             	mov    %edx,0xc(%ebx)
		SV(allocCode[i - 1]) = -1;
   10a74:	c7 84 96 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edx,4)
   10a7b:	ff ff ff ff 
   10a7f:	eb 09                	jmp    10a8a <Am_instance_add+0xea>
   10a81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10a88:	89 f8                	mov    %edi,%eax
   10a8a:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10a91:	ff 
   10a92:	8d 78 01             	lea    0x1(%eax),%edi
   10a95:	0f 85 6a 01 00 00    	jne    10c05 <Am_instance_add+0x265>
   10a9b:	83 ff 31             	cmp    $0x31,%edi
   10a9e:	7e e8                	jle    10a88 <Am_instance_add+0xe8>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10aa0:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   10aa7:	e8 fc ff ff ff       	call   10aa8 <Am_instance_add+0x108>
   10aac:	eb 04                	jmp    10ab2 <Am_instance_add+0x112>
   10aae:	66 90                	xchg   %ax,%ax
	else
	{
		amIns->reorderTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10ab0:	89 c7                	mov    %eax,%edi
   10ab2:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10ab9:	ff 
   10aba:	8d 47 01             	lea    0x1(%edi),%eax
   10abd:	0f 85 6a 01 00 00    	jne    10c2d <Am_instance_add+0x28d>
   10ac3:	83 f8 31             	cmp    $0x31,%eax
   10ac6:	7e e8                	jle    10ab0 <Am_instance_add+0x110>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10ac8:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   10acf:	e8 fc ff ff ff       	call   10ad0 <Am_instance_add+0x130>
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
   10ad4:	8d 43 44             	lea    0x44(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10ad7:	89 43 44             	mov    %eax,0x44(%ebx)
	list->prev = list;
   10ada:	89 43 48             	mov    %eax,0x48(%ebx)
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
   10add:	8d 83 5c 02 00 00    	lea    0x25c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10ae3:	89 83 5c 02 00 00    	mov    %eax,0x25c(%ebx)
	list->prev = list;
   10ae9:	89 83 60 02 00 00    	mov    %eax,0x260(%ebx)
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
   10aef:	8d 83 9c 01 00 00    	lea    0x19c(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10af5:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
	list->prev = list;
   10afb:	89 83 a0 01 00 00    	mov    %eax,0x1a0(%ebx)
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
   10b01:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10b07:	89 83 f0 00 00 00    	mov    %eax,0xf0(%ebx)
	list->prev = list;
   10b0d:	89 83 f4 00 00 00    	mov    %eax,0xf4(%ebx)
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
   10b13:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
   10b19:	89 83 b0 01 00 00    	mov    %eax,0x1b0(%ebx)
	list->prev = list;
   10b1f:	89 83 b4 01 00 00    	mov    %eax,0x1b4(%ebx)
	for(i = 0;  i < 1024; ++i )
   10b25:	31 c0                	xor    %eax,%eax
	else
	{
		amIns->statProhTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	amIns->vt_s = amIns->vt_a = amIns->vr_x = amIns->vr_h = amIns->vr_ms = amIns->vr_r = 0;
   10b27:	66 c7 83 f4 22 00 00 	movw   $0x0,0x22f4(%ebx)
   10b2e:	00 00 
   10b30:	66 c7 83 f2 22 00 00 	movw   $0x0,0x22f2(%ebx)
   10b37:	00 00 
   10b39:	66 c7 83 ee 22 00 00 	movw   $0x0,0x22ee(%ebx)
   10b40:	00 00 
   10b42:	66 c7 83 f0 22 00 00 	movw   $0x0,0x22f0(%ebx)
   10b49:	00 00 
   10b4b:	66 c7 83 66 12 00 00 	movw   $0x0,0x1266(%ebx)
   10b52:	00 00 
   10b54:	66 c7 83 64 12 00 00 	movw   $0x0,0x1264(%ebx)
   10b5b:	00 00 
	amIns->vr_mr = amIns->vt_ms = AM_WINDOW_SIZE;
   10b5d:	66 c7 83 68 12 00 00 	movw   $0x200,0x1268(%ebx)
   10b64:	00 02 
   10b66:	66 c7 83 ec 22 00 00 	movw   $0x200,0x22ec(%ebx)
   10b6d:	00 02 
   10b6f:	90                   	nop
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
   10b70:	c7 84 83 6c 12 00 00 	movl   $0x0,0x126c(%ebx,%eax,4)
   10b77:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amSduBuffer.list);
	INIT_LIST_HEAD(&amIns->amRecvBuffer.list);
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
   10b7b:	83 c0 01             	add    $0x1,%eax
   10b7e:	3d 00 04 00 00       	cmp    $0x400,%eax
   10b83:	75 eb                	jne    10b70 <Am_instance_add+0x1d0>
   10b85:	66 31 c0             	xor    %ax,%ax
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
		amIns->amTranWindow[i]= NULL;
   10b88:	c7 84 83 64 02 00 00 	movl   $0x0,0x264(%ebx,%eax,4)
   10b8f:	00 00 00 00 
	INIT_LIST_HEAD(&amIns->amRetxBuffer.list);
	INIT_LIST_HEAD(&amIns->amTransmittedBuffer.list);
	INIT_LIST_HEAD(&amIns->ctrlPduBuffer.list);
	for(i = 0;  i < 1024; ++i )
		amIns->amRecvWindow[i] = NULL;
	for(i = 0;  i < 1024; ++i )
   10b93:	83 c0 01             	add    $0x1,%eax
   10b96:	3d 00 04 00 00       	cmp    $0x400,%eax
   10b9b:	75 eb                	jne    10b88 <Am_instance_add+0x1e8>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10b9d:	8b 86 f8 25 00 00    	mov    0x25f8(%esi),%eax
		amIns->amTranWindow[i]= NULL;
	list_add_tail(&amIns->amList, &SV(vAm_ins).amList);
   10ba3:	8d 93 04 23 00 00    	lea    0x2304(%ebx),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10ba9:	89 96 f8 25 00 00    	mov    %edx,0x25f8(%esi)
   10baf:	81 c6 f4 25 00 00    	add    $0x25f4,%esi
   10bb5:	89 b3 04 23 00 00    	mov    %esi,0x2304(%ebx)
	new->next = next;
	new->prev = prev;
   10bbb:	89 83 08 23 00 00    	mov    %eax,0x2308(%ebx)
	prev->next = new;
   10bc1:	89 10                	mov    %edx,(%eax)
	fsm_printf(" am instance has established\n");
   10bc3:	c7 04 24 25 08 00 00 	movl   $0x825,(%esp)
   10bca:	e8 fc ff ff ff       	call   10bcb <Am_instance_add+0x22b>

//
	add_data_retx(amIns,8);
   10bcf:	89 d8                	mov    %ebx,%eax
   10bd1:	ba 08 00 00 00       	mov    $0x8,%edx
   10bd6:	e8 fc ff ff ff       	call   10bd7 <Am_instance_add+0x237>
	//amIns->pollRetxTimer = fsm_schedule_self(200000, amIns->pollRetxTimerCode);
//      fsm_printf("the pollRetxTimerCode is %d, the pollRetxTimer is %d\n", amIns->pollRetxTimerCode, amIns->pollRetxTimer);
    FOUT;
}
   10bdb:	83 c4 04             	add    $0x4,%esp
   10bde:	5b                   	pop    %ebx
   10bdf:	5e                   	pop    %esi
   10be0:	5f                   	pop    %edi
   10be1:	5d                   	pop    %ebp
   10be2:	c3                   	ret    
	//      amIns->pollRetxTimerCode =(int)amIns % 65536;                                 //
	//      amIns->reorderTimerCode = ((int)amIns + 1) %65536;
	//     amIns->statProhTimerCode = ((int)amIns + 2) %65536;
	//code
	while((SV(allocCode[i++]) == -1)&&(i < MAX_CODE));
	if(i >=MAX_CODE) fsm_printf("no more code to allocated \n");
   10be3:	c7 04 24 09 08 00 00 	movl   $0x809,(%esp)
   10bea:	e8 fc ff ff ff       	call   10beb <Am_instance_add+0x24b>
   10bef:	b8 32 00 00 00       	mov    $0x32,%eax
	else
	{
		amIns->pollRetxTimerCode = i - 1;
		SV(allocCode[i - 1]) = -1;
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10bf4:	83 bc 86 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%eax,4)
   10bfb:	ff 
   10bfc:	8d 78 01             	lea    0x1(%eax),%edi
   10bff:	0f 84 96 fe ff ff    	je     10a9b <Am_instance_add+0xfb>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10c05:	83 ff 31             	cmp    $0x31,%edi
   10c08:	0f 8f 92 fe ff ff    	jg     10aa0 <Am_instance_add+0x100>
	else
	{
		amIns->reorderTimerCode = i - 1;
   10c0e:	89 43 18             	mov    %eax,0x18(%ebx)
		SV(allocCode[i - 1]) = -1;
   10c11:	c7 84 86 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%eax,4)
   10c18:	ff ff ff ff 
	}
	while((SV(allocCode[i++]) == -1)&&(i<MAX_CODE));
   10c1c:	8d 47 01             	lea    0x1(%edi),%eax
   10c1f:	83 bc be 28 02 00 00 	cmpl   $0xffffffff,0x228(%esi,%edi,4)
   10c26:	ff 
   10c27:	0f 84 96 fe ff ff    	je     10ac3 <Am_instance_add+0x123>
	if(i >= MAX_CODE) fsm_printf("no more code to allocated \n");
   10c2d:	83 f8 31             	cmp    $0x31,%eax
   10c30:	0f 8f 92 fe ff ff    	jg     10ac8 <Am_instance_add+0x128>
	else
	{
		amIns->statProhTimerCode = i - 1;
   10c36:	89 7b 24             	mov    %edi,0x24(%ebx)
		SV(allocCode[i - 1]) = -1;
   10c39:	c7 84 be 28 02 00 00 	movl   $0xffffffff,0x228(%esi,%edi,4)
   10c40:	ff ff ff ff 
   10c44:	e9 8b fe ff ff       	jmp    10ad4 <Am_instance_add+0x134>
   10c49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00010c50 <addPollData>:
}


//build()
void addPollData()
{
   10c50:	55                   	push   %ebp
   10c51:	89 e5                	mov    %esp,%ebp
   10c53:	57                   	push   %edi
   10c54:	56                   	push   %esi
   10c55:	53                   	push   %ebx
   10c56:	83 ec 04             	sub    $0x4,%esp
   10c59:	e8 fc ff ff ff       	call   10c5a <addPollData+0xa>
	FSM_PKT *skb = NULL;
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
   10c5e:	66 c7 45 f0 01 80    	movw   $0x8001,-0x10(%ebp)
	unsigned short data = 0x0002;
   10c64:	66 c7 45 f2 02 00    	movw   $0x2,-0xe(%ebp)
	SV_PTR_GET(rlc_mac_sv);
   10c6a:	e8 fc ff ff ff       	call   10c6b <addPollData+0x1b>
   10c6f:	89 c6                	mov    %eax,%esi
	skb = fsm_pkt_create(4);
   10c71:	b8 04 00 00 00       	mov    $0x4,%eax
   10c76:	e8 fc ff ff ff       	call   10c77 <addPollData+0x27>
   10c7b:	89 c7                	mov    %eax,%edi
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10c7d:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10c82:	e8 fc ff ff ff       	call   10c83 <addPollData+0x33>

	fsm_mem_cpy(skb->tail,&hdr,2);
   10c87:	b9 02 00 00 00       	mov    $0x2,%ecx
   10c8c:	8d 55 f0             	lea    -0x10(%ebp),%edx
	struct AmBuffer *amTxedBuffer;
	unsigned short hdr = 0x8001;
	unsigned short data = 0x0002;
	SV_PTR_GET(rlc_mac_sv);
	skb = fsm_pkt_create(4);
	amTxedBuffer = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10c8f:	89 c3                	mov    %eax,%ebx

	fsm_mem_cpy(skb->tail,&hdr,2);
   10c91:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10c97:	e8 fc ff ff ff       	call   10c98 <addPollData+0x48>
	fsm_skb_put(skb,2);
   10c9c:	ba 02 00 00 00       	mov    $0x2,%edx
   10ca1:	89 f8                	mov    %edi,%eax
   10ca3:	e8 fc ff ff ff       	call   10ca4 <addPollData+0x54>
	fsm_mem_cpy(skb->tail,&data,2);
   10ca8:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10cae:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10cb1:	b9 02 00 00 00       	mov    $0x2,%ecx
   10cb6:	e8 fc ff ff ff       	call   10cb7 <addPollData+0x67>
	fsm_skb_put(skb,2);
   10cbb:	ba 02 00 00 00       	mov    $0x2,%edx
   10cc0:	89 f8                	mov    %edi,%eax
   10cc2:	e8 fc ff ff ff       	call   10cc3 <addPollData+0x73>
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10cc7:	8d 93 9c 00 00 00    	lea    0x9c(%ebx),%edx

	fsm_mem_cpy(skb->tail,&hdr,2);
	fsm_skb_put(skb,2);
	fsm_mem_cpy(skb->tail,&data,2);
	fsm_skb_put(skb,2);
	amTxedBuffer->pkt = skb;
   10ccd:	89 3b                	mov    %edi,(%ebx)
	amTxedBuffer->SN = 0x0001;
   10ccf:	66 c7 83 94 00 00 00 	movw   $0x1,0x94(%ebx)
   10cd6:	01 00 
	amTxedBuffer->pktstatus = 1;
   10cd8:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	amTxedBuffer->headLen = 2;
   10cdf:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amTxedBuffer->retxCount = 0;
   10ce6:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   10ced:	00 00 
	amTxedBuffer->segnum = 0;
   10cef:	c7 83 90 00 00 00 00 	movl   $0x0,0x90(%ebx)
   10cf6:	00 00 00 
	SV(amText).pduWithoutPoll = 32;
	SV(amText).byteWithoutPoll = 1000;
	SV(amText).amRetxBufferNum++;
   10cf9:	83 86 e8 38 00 00 01 	addl   $0x1,0x38e8(%esi)
	amTxedBuffer->SN = 0x0001;
	amTxedBuffer->pktstatus = 1;
	amTxedBuffer->headLen = 2;
	amTxedBuffer->retxCount = 0;
	amTxedBuffer->segnum = 0;
	SV(amText).pduWithoutPoll = 32;
   10d00:	66 c7 86 3c 5a 00 00 	movw   $0x20,0x5a3c(%esi)
   10d07:	20 00 
	SV(amText).byteWithoutPoll = 1000;
   10d09:	66 c7 86 3e 5a 00 00 	movw   $0x3e8,0x5a3e(%esi)
   10d10:	e8 03 
	SV(amText).amRetxBufferNum++;
	SV(amText).amRetxBufferSize += skb->len;
   10d12:	8b 47 50             	mov    0x50(%edi),%eax
   10d15:	01 86 e4 38 00 00    	add    %eax,0x38e4(%esi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10d1b:	8b 86 e0 38 00 00    	mov    0x38e0(%esi),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10d21:	89 96 e0 38 00 00    	mov    %edx,0x38e0(%esi)
	list_add_tail(&(amTxedBuffer->list),&SV(amText).amRetxBuffer.list);
   10d27:	81 c6 dc 38 00 00    	add    $0x38dc,%esi
   10d2d:	89 b3 9c 00 00 00    	mov    %esi,0x9c(%ebx)
	new->next = next;
	new->prev = prev;
   10d33:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
	prev->next = new;
   10d39:	89 10                	mov    %edx,(%eax)
	FOUT;
}
   10d3b:	83 c4 04             	add    $0x4,%esp
   10d3e:	5b                   	pop    %ebx
   10d3f:	5e                   	pop    %esi
   10d40:	5f                   	pop    %edi
   10d41:	5d                   	pop    %ebp
   10d42:	c3                   	ret    
   10d43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   10d49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010d50 <addPollRetxData>:
void addPollRetxData(struct AM_Instance*amIns)
{
   10d50:	55                   	push   %ebp
   10d51:	89 e5                	mov    %esp,%ebp
   10d53:	57                   	push   %edi
   10d54:	56                   	push   %esi
   10d55:	53                   	push   %ebx
   10d56:	e8 fc ff ff ff       	call   10d57 <addPollRetxData+0x7>
   10d5b:	89 c6                	mov    %eax,%esi
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10d5d:	b8 1a 00 00 00       	mov    $0x1a,%eax
   10d62:	e8 fc ff ff ff       	call   10d63 <addPollRetxData+0x13>
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10d67:	ba 02 00 00 00       	mov    $0x2,%edx
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10d6c:	8d be f0 00 00 00    	lea    0xf0(%esi),%edi
void addPollRetxData(struct AM_Instance*amIns)
{
	char *sdu1 = "Hello world";
	char *sdu2 = " hahahahaho";
	struct AmBuffer *ambuf;
	FSM_PKT *skb = fsm_pkt_create(22 + sizeof(RLC_AMDPDU_seg_ind) + sizeof(RLC_AMPDU_fixhead));	
   10d72:	89 c3                	mov    %eax,%ebx
	RLC_AMPDU_fixhead*fix = (RLC_AMPDU_fixhead*)skb->tail;
   10d74:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	fix->DorC = 1;
	fix->E = 1;
	fix->FIfirst = fix->FIsecond = 1;
	fix->P = 0;
	fix->RF = 1;
	fix->SN = 0;
   10d7a:	c6 00 00             	movb   $0x0,(%eax)
   10d7d:	c6 40 01 dc          	movb   $0xdc,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
   10d81:	89 d8                	mov    %ebx,%eax
   10d83:	e8 fc ff ff ff       	call   10d84 <addPollRetxData+0x34>
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
   10d88:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
	ind->E = 0;
	ind->LI = 11;
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10d8e:	ba 02 00 00 00       	mov    $0x2,%edx
	fix->RF = 1;
	fix->SN = 0;
	fsm_skb_put(skb,sizeof(RLC_AMPDU_fixhead));
	RLC_AMDPDU_seg_ind *ind = (RLC_AMDPDU_seg_ind *)skb->tail;
	ind->E = 0;
	ind->LI = 11;
   10d93:	c6 00 0b             	movb   $0xb,(%eax)
   10d96:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	fsm_skb_put(skb,sizeof(RLC_AMDPDU_seg_ind));
   10d9a:	89 d8                	mov    %ebx,%eax
   10d9c:	e8 fc ff ff ff       	call   10d9d <addPollRetxData+0x4d>
	fsm_mem_cpy(skb->tail, sdu1, 11);
   10da1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10da7:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10dac:	ba f3 08 00 00       	mov    $0x8f3,%edx
   10db1:	e8 fc ff ff ff       	call   10db2 <addPollRetxData+0x62>
	fsm_skb_put(skb,11);
   10db6:	ba 0b 00 00 00       	mov    $0xb,%edx
   10dbb:	89 d8                	mov    %ebx,%eax
   10dbd:	e8 fc ff ff ff       	call   10dbe <addPollRetxData+0x6e>
	fsm_mem_cpy(skb->tail, sdu2, 11);
   10dc2:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   10dc8:	b9 0b 00 00 00       	mov    $0xb,%ecx
   10dcd:	ba ff 08 00 00       	mov    $0x8ff,%edx
   10dd2:	e8 fc ff ff ff       	call   10dd3 <addPollRetxData+0x83>
	fsm_skb_put(skb,11);
   10dd7:	ba 0b 00 00 00       	mov    $0xb,%edx
   10ddc:	89 d8                	mov    %ebx,%eax
   10dde:	e8 fc ff ff ff       	call   10ddf <addPollRetxData+0x8f>

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
   10de3:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10de8:	e8 fc ff ff ff       	call   10de9 <addPollRetxData+0x99>
	ambuf->pkt = skb;
   10ded:	89 18                	mov    %ebx,(%eax)
	ambuf->SN = 0;
	ambuf->headLen = 2*2;
	ambuf->datalen = 22;
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10def:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
	fsm_mem_cpy(skb->tail, sdu2, 11);
	fsm_skb_put(skb,11);

	ambuf = (struct AmBuffer*)fsm_mem_alloc(sizeof(struct AmBuffer));
	ambuf->pkt = skb;
	ambuf->pktstatus = ANY_SEGMENT;
   10df5:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	ambuf->pos = 0;
   10dfc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ambuf->segnum = 1;
   10e03:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   10e0a:	00 00 00 
	ambuf->segStart[0] = 3;
   10e0d:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
	ambuf->segEnd[0] = 18;
   10e14:	c7 40 50 12 00 00 00 	movl   $0x12,0x50(%eax)
	ambuf->retxCount = 0;
   10e1b:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
   10e22:	00 00 
	ambuf->SN = 0;
   10e24:	66 c7 80 94 00 00 00 	movw   $0x0,0x94(%eax)
   10e2b:	00 00 
	ambuf->headLen = 2*2;
   10e2d:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
	ambuf->datalen = 22;
   10e34:	c7 80 98 00 00 00 16 	movl   $0x16,0x98(%eax)
   10e3b:	00 00 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10e3e:	8b 96 f4 00 00 00    	mov    0xf4(%esi),%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10e44:	89 8e f4 00 00 00    	mov    %ecx,0xf4(%esi)
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
   10e4a:	89 b8 9c 00 00 00    	mov    %edi,0x9c(%eax)
	new->next = next;
	new->prev = prev;
   10e50:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
	prev->next = new;
   10e56:	89 0a                	mov    %ecx,(%edx)
	amIns->amTransmittedBufferNum++;
   10e58:	83 86 fc 00 00 00 01 	addl   $0x1,0xfc(%esi)
	amIns->amTransmittedBufferSize += skb->len;
   10e5f:	8b 43 50             	mov    0x50(%ebx),%eax
   10e62:	01 86 f8 00 00 00    	add    %eax,0xf8(%esi)
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10e68:	5b                   	pop    %ebx
	//fsm_printf("add data in retx buffer\n");
	//list_add_tail(&ambuf->list, &amIns->amRetxBuffer.list);
	list_add_tail(&ambuf->list, &amIns->amTransmittedBuffer.list);
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
   10e69:	66 83 86 64 12 00 00 	addw   $0x1,0x1264(%esi)
   10e70:	01 
	amIns->amTransmittedBufferSize += skb->len;
	amIns->vt_s++;
	list_add_tail(&(amTxedBuffer->list),&amIns->amTransmittedBuffer.list);*/
	
	FOUT;
}
   10e71:	5e                   	pop    %esi
   10e72:	5f                   	pop    %edi
   10e73:	5d                   	pop    %ebp
   10e74:	c3                   	ret    
   10e75:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   10e79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00010e80 <addpkt_recvData>:


void addpkt_recvData(struct AM_Instance *amIns)
{
   10e80:	55                   	push   %ebp
   10e81:	89 e5                	mov    %esp,%ebp
   10e83:	57                   	push   %edi
   10e84:	56                   	push   %esi
   10e85:	53                   	push   %ebx
   10e86:	83 ec 20             	sub    $0x20,%esp
   10e89:	e8 fc ff ff ff       	call   10e8a <addpkt_recvData+0xa>
   10e8e:	89 c3                	mov    %eax,%ebx
	unsigned short hdr;
	unsigned char *str1 = "pkt1";
	unsigned char *str2 = "pkt2";
	unsigned char *str3 = "pkt3";
	unsigned char *str4 = "pkt4";
	SV_PTR_GET(rlc_mac_sv);
   10e90:	e8 fc ff ff ff       	call   10e91 <addpkt_recvData+0x11>

	skb1 = fsm_pkt_create(6);
   10e95:	b8 06 00 00 00       	mov    $0x6,%eax
   10e9a:	e8 fc ff ff ff       	call   10e9b <addpkt_recvData+0x1b>
   10e9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	amTxedBuffer1= (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));	
   10ea2:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10ea7:	e8 fc ff ff ff       	call   10ea8 <addpkt_recvData+0x28>
   10eac:	89 c7                	mov    %eax,%edi
	skb2 = fsm_pkt_create(6);
   10eae:	b8 06 00 00 00       	mov    $0x6,%eax
   10eb3:	e8 fc ff ff ff       	call   10eb4 <addpkt_recvData+0x34>
   10eb8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10ebb:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10ec0:	e8 fc ff ff ff       	call   10ec1 <addpkt_recvData+0x41>
   10ec5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	skb3 = fsm_pkt_create(6);
   10ec8:	b8 06 00 00 00       	mov    $0x6,%eax
   10ecd:	e8 fc ff ff ff       	call   10ece <addpkt_recvData+0x4e>
   10ed2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10ed5:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10eda:	e8 fc ff ff ff       	call   10edb <addpkt_recvData+0x5b>
   10edf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	skb4 = fsm_pkt_create(6);
   10ee2:	b8 06 00 00 00       	mov    $0x6,%eax
   10ee7:	e8 fc ff ff ff       	call   10ee8 <addpkt_recvData+0x68>
   10eec:	89 45 d8             	mov    %eax,-0x28(%ebp)
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10eef:	b8 a4 00 00 00       	mov    $0xa4,%eax
   10ef4:	e8 fc ff ff ff       	call   10ef5 <addpkt_recvData+0x75>

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10ef9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10efc:	b9 02 00 00 00       	mov    $0x2,%ecx
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));

	hdr = 0x8000;
   10f01:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	skb2 = fsm_pkt_create(6);
	amTxedBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb3 = fsm_pkt_create(6);
	amTxedBuffer3 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb4 = fsm_pkt_create(6);
	amTxedBuffer4 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   10f07:	89 c6                	mov    %eax,%esi

	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
   10f09:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   10f0f:	8d 55 f2             	lea    -0xe(%ebp),%edx
   10f12:	e8 fc ff ff ff       	call   10f13 <addpkt_recvData+0x93>
	fsm_skb_put(skb1,2);
   10f17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f1a:	ba 02 00 00 00       	mov    $0x2,%edx
   10f1f:	e8 fc ff ff ff       	call   10f20 <addpkt_recvData+0xa0>
	fsm_mem_cpy(skb1->tail,str1,4);
   10f24:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10f27:	ba 0b 09 00 00       	mov    $0x90b,%edx
   10f2c:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   10f32:	b9 04 00 00 00       	mov    $0x4,%ecx
   10f37:	e8 fc ff ff ff       	call   10f38 <addpkt_recvData+0xb8>
	fsm_skb_put(skb1,4);
   10f3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f3f:	ba 04 00 00 00       	mov    $0x4,%edx
   10f44:	e8 fc ff ff ff       	call   10f45 <addpkt_recvData+0xc5>
	amTxedBuffer1->pkt = skb1;
   10f49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10f4c:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
   10f52:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   10f59:	00 00 
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10f5b:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
   10f61:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amTxedBuffer1->headLen = 2;
   10f68:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	hdr = 0x8000;
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,str1,4);
	fsm_skb_put(skb1,4);
	amTxedBuffer1->pkt = skb1;
   10f6f:	89 07                	mov    %eax,(%edi)
	amTxedBuffer1->SN = 0x0000;
	amTxedBuffer1->pktstatus = FULL_SDU;
	amTxedBuffer1->headLen = 2;
	amTxedBuffer1->datalen = 4;
   10f71:	c7 87 98 00 00 00 04 	movl   $0x4,0x98(%edi)
   10f78:	00 00 00 
	amTxedBuffer1->retxCount = -1;
   10f7b:	66 c7 87 96 00 00 00 	movw   $0xffff,0x96(%edi)
   10f82:	ff ff 
	amTxedBuffer1->segnum = 0;
   10f84:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   10f8b:	00 00 00 
	amTxedBuffer1->pos = 0;
   10f8e:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	amTxedBuffer1->segEnd[0] = -1;
   10f95:	c7 47 50 ff ff ff ff 	movl   $0xffffffff,0x50(%edi)
	amTxedBuffer1->segStart[0] = -1;
   10f9c:	c7 47 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edi)
	amIns->amTransmittedBufferNum++;
   10fa3:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb1->len;
   10faa:	8b 40 50             	mov    0x50(%eax),%eax
   10fad:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   10fb3:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   10fb9:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   10fc0:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   10fc1:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   10fc7:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->prev = prev;
   10fcd:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10fd3:	8b 7d e0             	mov    -0x20(%ebp),%edi
	prev->next = new;
   10fd6:	89 10                	mov    %edx,(%eax)
   10fd8:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amTxedBuffer1->segEnd[0] = -1;
	amTxedBuffer1->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);
   10fdb:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10fde:	b9 02 00 00 00       	mov    $0x2,%ecx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb1->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer1->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8001;
   10fe3:	66 c7 45 f2 01 80    	movw   $0x8001,-0xe(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   10fe9:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   10fef:	e8 fc ff ff ff       	call   10ff0 <addpkt_recvData+0x170>
	fsm_skb_put(skb2,2);
   10ff4:	ba 02 00 00 00       	mov    $0x2,%edx
   10ff9:	89 f8                	mov    %edi,%eax
   10ffb:	e8 fc ff ff ff       	call   10ffc <addpkt_recvData+0x17c>
	fsm_mem_cpy(skb2->tail,str2,4);
   11000:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   11006:	b9 04 00 00 00       	mov    $0x4,%ecx
   1100b:	ba 10 09 00 00       	mov    $0x910,%edx
   11010:	e8 fc ff ff ff       	call   11011 <addpkt_recvData+0x191>
	fsm_skb_put(skb2,4);
   11015:	ba 04 00 00 00       	mov    $0x4,%edx
   1101a:	89 f8                	mov    %edi,%eax
   1101c:	e8 fc ff ff ff       	call   1101d <addpkt_recvData+0x19d>
	amTxedBuffer2->pkt = skb2;
   11021:	8b 45 ec             	mov    -0x14(%ebp),%eax
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   11024:	8b 55 ec             	mov    -0x14(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11027:	8b 4d ec             	mov    -0x14(%ebp),%ecx
	hdr = 0x8001;
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
   1102a:	89 38                	mov    %edi,(%eax)
	amTxedBuffer2->SN = 0x0001;
   1102c:	66 c7 80 94 00 00 00 	movw   $0x1,0x94(%eax)
   11033:	01 00 
	amTxedBuffer2->segEnd[0] = -1;
	amTxedBuffer2->segStart[0] = -1;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);
   11035:	81 c2 9c 00 00 00    	add    $0x9c,%edx
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,str2,4);
	fsm_skb_put(skb2,4);
	amTxedBuffer2->pkt = skb2;
	amTxedBuffer2->SN = 0x0001;
	amTxedBuffer2->pktstatus = FULL_SDU;
   1103b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
	amTxedBuffer2->headLen = 2;
   11042:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer2->datalen = 4;
   11049:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   11050:	00 00 00 
	amTxedBuffer2->retxCount = -1;
   11053:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   1105a:	ff ff 
	amTxedBuffer2->segnum = 0;
   1105c:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
   11063:	00 00 00 
	amTxedBuffer2->pos = 0;
   11066:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer2->segEnd[0] = -1;
   1106d:	c7 40 50 ff ff ff ff 	movl   $0xffffffff,0x50(%eax)
	amTxedBuffer2->segStart[0] = -1;
   11074:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   1107b:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb2->len;
   11082:	8b 47 50             	mov    0x50(%edi),%eax
   11085:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
   1108b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1108e:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   11094:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   1109b:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   1109c:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   110a2:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)
	new->prev = prev;
   110a8:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
   110ae:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   110b3:	89 10                	mov    %edx,(%eax)
   110b5:	8b 55 dc             	mov    -0x24(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb2->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer2->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8002;
   110b8:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	fsm_mem_cpy(skb3->tail,&hdr,2);
   110be:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   110c4:	8d 55 f2             	lea    -0xe(%ebp),%edx
   110c7:	e8 fc ff ff ff       	call   110c8 <addpkt_recvData+0x248>
	fsm_skb_put(skb3,2);
   110cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   110cf:	ba 02 00 00 00       	mov    $0x2,%edx
   110d4:	e8 fc ff ff ff       	call   110d5 <addpkt_recvData+0x255>
	fsm_mem_cpy(skb3->tail,str3,4);
   110d9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   110dc:	ba 15 09 00 00       	mov    $0x915,%edx
   110e1:	8b 81 a0 00 00 00    	mov    0xa0(%ecx),%eax
   110e7:	b9 04 00 00 00       	mov    $0x4,%ecx
   110ec:	e8 fc ff ff ff       	call   110ed <addpkt_recvData+0x26d>
	fsm_skb_put(skb3,4);
   110f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   110f4:	ba 04 00 00 00       	mov    $0x4,%edx
   110f9:	e8 fc ff ff ff       	call   110fa <addpkt_recvData+0x27a>
	amTxedBuffer3->pkt = skb3;
   110fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11101:	8b 55 dc             	mov    -0x24(%ebp),%edx
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11104:	8b 4d e8             	mov    -0x18(%ebp),%ecx
	amTxedBuffer3->SN = 0x0002;
   11107:	66 c7 80 94 00 00 00 	movw   $0x2,0x94(%eax)
   1110e:	02 00 
	hdr = 0x8002;
	fsm_mem_cpy(skb3->tail,&hdr,2);
	fsm_skb_put(skb3,2);
	fsm_mem_cpy(skb3->tail,str3,4);
	fsm_skb_put(skb3,4);
	amTxedBuffer3->pkt = skb3;
   11110:	89 10                	mov    %edx,(%eax)
	amTxedBuffer3->SN = 0x0002;
	amTxedBuffer3->pktstatus = ANY_SEGMENT;
   11112:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
	amTxedBuffer3->headLen = 2;
   11119:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	amTxedBuffer3->datalen = 4;
   11120:	c7 80 98 00 00 00 04 	movl   $0x4,0x98(%eax)
   11127:	00 00 00 
	amTxedBuffer3->retxCount = -1;
   1112a:	66 c7 80 96 00 00 00 	movw   $0xffff,0x96(%eax)
   11131:	ff ff 
	amTxedBuffer3->segnum = 1;
   11133:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
   1113a:	00 00 00 
	amTxedBuffer3->pos = 0;
   1113d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	amTxedBuffer3->segEnd[0] = 6;
   11144:	c7 40 50 06 00 00 00 	movl   $0x6,0x50(%eax)
	amTxedBuffer3->segStart[0] = 2;
   1114b:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	amIns->amTransmittedBufferNum++;
   11152:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb3->len;
   11159:	8b 42 50             	mov    0x50(%edx),%eax
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   1115c:	8b 55 e8             	mov    -0x18(%ebp),%edx
	amTxedBuffer3->segnum = 1;
	amTxedBuffer3->pos = 0;
	amTxedBuffer3->segEnd[0] = 6;
	amTxedBuffer3->segStart[0] = 2;
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
   1115f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->vt_s++;
   11165:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   1116c:	01 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   1116d:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);
   11173:	81 c2 9c 00 00 00    	add    $0x9c,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11179:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1117f:	89 b9 9c 00 00 00    	mov    %edi,0x9c(%ecx)

	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
   11185:	8b 7d d8             	mov    -0x28(%ebp),%edi
	new->prev = prev;
   11188:	89 81 a0 00 00 00    	mov    %eax,0xa0(%ecx)
   1118e:	b9 02 00 00 00       	mov    $0x2,%ecx
	prev->next = new;
   11193:	89 10                	mov    %edx,(%eax)
   11195:	8d 55 f2             	lea    -0xe(%ebp),%edx
	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb3->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer3->list,&amIns->amTransmittedBuffer.list);

	hdr = 0x8003;
   11198:	66 c7 45 f2 03 80    	movw   $0x8003,-0xe(%ebp)
	fsm_mem_cpy(skb4->tail,&hdr,2);
   1119e:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   111a4:	e8 fc ff ff ff       	call   111a5 <addpkt_recvData+0x325>
	fsm_skb_put(skb4,2);
   111a9:	ba 02 00 00 00       	mov    $0x2,%edx
   111ae:	89 f8                	mov    %edi,%eax
   111b0:	e8 fc ff ff ff       	call   111b1 <addpkt_recvData+0x331>
	fsm_mem_cpy(skb4->tail,str4,4);
   111b5:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
   111bb:	b9 04 00 00 00       	mov    $0x4,%ecx
   111c0:	ba 1a 09 00 00       	mov    $0x91a,%edx
   111c5:	e8 fc ff ff ff       	call   111c6 <addpkt_recvData+0x346>
	fsm_skb_put(skb4,4);
   111ca:	ba 04 00 00 00       	mov    $0x4,%edx
   111cf:	89 f8                	mov    %edi,%eax
   111d1:	e8 fc ff ff ff       	call   111d2 <addpkt_recvData+0x352>
	amTxedBuffer4->segStart[1] = 8;

	amIns->amTransmittedBufferNum++;
	amIns->amTransmittedBufferSize += skb4->len;
	amIns->vt_s++;
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
   111d6:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
	hdr = 0x8003;
	fsm_mem_cpy(skb4->tail,&hdr,2);
	fsm_skb_put(skb4,2);
	fsm_mem_cpy(skb4->tail,str4,4);
	fsm_skb_put(skb4,4);
	amTxedBuffer4->pkt = skb4;
   111dc:	89 3e                	mov    %edi,(%esi)
	amTxedBuffer4->SN = 0x0003;
   111de:	66 c7 86 94 00 00 00 	movw   $0x3,0x94(%esi)
   111e5:	03 00 
	amTxedBuffer4->pktstatus = ANY_SEGMENT;
   111e7:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
	amTxedBuffer4->headLen = 2;
   111ee:	c7 46 0c 02 00 00 00 	movl   $0x2,0xc(%esi)
	amTxedBuffer4->datalen = 4;
   111f5:	c7 86 98 00 00 00 04 	movl   $0x4,0x98(%esi)
   111fc:	00 00 00 
	amTxedBuffer4->retxCount = -1;
   111ff:	66 c7 86 96 00 00 00 	movw   $0xffff,0x96(%esi)
   11206:	ff ff 
	amTxedBuffer4->segnum = 2;
   11208:	c7 86 90 00 00 00 02 	movl   $0x2,0x90(%esi)
   1120f:	00 00 00 
	amTxedBuffer4->pos = 0;
   11212:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
	amTxedBuffer4->segEnd[0] = 7;
   11219:	c7 46 50 07 00 00 00 	movl   $0x7,0x50(%esi)
	amTxedBuffer4->segStart[0] = 5;
   11220:	c7 46 10 05 00 00 00 	movl   $0x5,0x10(%esi)
	amTxedBuffer4->segEnd[1] = 10;
   11227:	c7 46 54 0a 00 00 00 	movl   $0xa,0x54(%esi)
	amTxedBuffer4->segStart[1] = 8;
   1122e:	c7 46 14 08 00 00 00 	movl   $0x8,0x14(%esi)

	amIns->amTransmittedBufferNum++;
   11235:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	amIns->amTransmittedBufferSize += skb4->len;
   1123c:	8b 47 50             	mov    0x50(%edi),%eax
   1123f:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   11245:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   11248:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
	amIns->vt_s++;
   1124e:	66 83 83 64 12 00 00 	addw   $0x1,0x1264(%ebx)
   11255:	01 
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   11256:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	new->next = next;
   1125c:	89 be 9c 00 00 00    	mov    %edi,0x9c(%esi)
	new->prev = prev;
   11262:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   11268:	89 10                	mov    %edx,(%eax)
	list_add_tail(&amTxedBuffer4->list,&amIns->amTransmittedBuffer.list);
	fsm_printf("has added data for ctrl_pkt_recv\n");
   1126a:	c7 04 24 fc 3d 00 00 	movl   $0x3dfc,(%esp)
   11271:	e8 fc ff ff ff       	call   11272 <addpkt_recvData+0x3f2>
	FOUT;
}
   11276:	83 c4 20             	add    $0x20,%esp
   11279:	5b                   	pop    %ebx
   1127a:	5e                   	pop    %esi
   1127b:	5f                   	pop    %edi
   1127c:	5d                   	pop    %ebp
   1127d:	c3                   	ret    
   1127e:	66 90                	xchg   %ax,%ax

00011280 <addPktTranData>:

void addPktTranData(struct AM_Instance*amIns)
{
   11280:	55                   	push   %ebp
   11281:	89 e5                	mov    %esp,%ebp
   11283:	57                   	push   %edi
   11284:	56                   	push   %esi
   11285:	53                   	push   %ebx
   11286:	83 ec 0c             	sub    $0xc,%esp
   11289:	e8 fc ff ff ff       	call   1128a <addPktTranData+0xa>
   1128e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	FSM_PKT *skb1 = NULL;
	struct AmBuffer *amRecvBuffer1 = NULL;
	FSM_PKT *skb2 = NULL;
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
   11291:	b8 06 00 00 00       	mov    $0x6,%eax
   11296:	e8 fc ff ff ff       	call   11297 <addPktTranData+0x17>
   1129b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1129e:	b8 a4 00 00 00       	mov    $0xa4,%eax
   112a3:	e8 fc ff ff ff       	call   112a4 <addPktTranData+0x24>
   112a8:	89 c7                	mov    %eax,%edi
	skb2= fsm_pkt_create(2+6);
   112aa:	b8 08 00 00 00       	mov    $0x8,%eax
   112af:	e8 fc ff ff ff       	call   112b0 <addPktTranData+0x30>
   112b4:	89 c6                	mov    %eax,%esi
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   112b6:	b8 a4 00 00 00       	mov    $0xa4,%eax
   112bb:	e8 fc ff ff ff       	call   112bc <addPktTranData+0x3c>

	unsigned short data = 0x0000;
   112c0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)
	unsigned short hdr = 0X0000;
   112c6:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	struct AmBuffer *amRecvBuffer2 = NULL;

	skb1= fsm_pkt_create(2+4);
	amRecvBuffer1 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
	skb2= fsm_pkt_create(2+6);
	amRecvBuffer2 = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   112cc:	89 c3                	mov    %eax,%ebx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);
   112ce:	e8 fc ff ff ff       	call   112cf <addPktTranData+0x4f>

	hdr = 0x8000;
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
   112d3:	8b 55 e8             	mov    -0x18(%ebp),%edx
   112d6:	b9 02 00 00 00       	mov    $0x2,%ecx

	unsigned short data = 0x0000;
	unsigned short hdr = 0X0000;
	SV_PTR_GET(rlc_mac_sv);

	hdr = 0x8000;
   112db:	66 c7 45 f2 00 80    	movw   $0x8000,-0xe(%ebp)
	data = 0x0001;	
   112e1:	66 c7 45 f0 01 00    	movw   $0x1,-0x10(%ebp)
	fsm_mem_cpy(skb1->tail,&hdr,2);
   112e7:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   112ed:	8d 55 f2             	lea    -0xe(%ebp),%edx
   112f0:	e8 fc ff ff ff       	call   112f1 <addPktTranData+0x71>
	fsm_skb_put(skb1,2);
   112f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   112f8:	ba 02 00 00 00       	mov    $0x2,%edx
   112fd:	e8 fc ff ff ff       	call   112fe <addPktTranData+0x7e>
	fsm_mem_cpy(skb1->tail,&data,2);
   11302:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11305:	b9 02 00 00 00       	mov    $0x2,%ecx
   1130a:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   11310:	8d 55 f0             	lea    -0x10(%ebp),%edx
   11313:	e8 fc ff ff ff       	call   11314 <addPktTranData+0x94>
	fsm_skb_put(skb1,2);
   11318:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1131b:	ba 02 00 00 00       	mov    $0x2,%edx
   11320:	e8 fc ff ff ff       	call   11321 <addPktTranData+0xa1>
	amRecvBuffer1->pkt = skb1;
   11325:	8b 45 e8             	mov    -0x18(%ebp),%eax

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11328:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
   1132d:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%edi)
   11334:	00 00 

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11336:	8d 55 f2             	lea    -0xe(%ebp),%edx
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
   11339:	c7 47 04 01 00 00 00 	movl   $0x1,0x4(%edi)
	amRecvBuffer1->headLen = 2;
   11340:	c7 47 0c 02 00 00 00 	movl   $0x2,0xc(%edi)
	data = 0x0001;	
	fsm_mem_cpy(skb1->tail,&hdr,2);
	fsm_skb_put(skb1,2);
	fsm_mem_cpy(skb1->tail,&data,2);
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
   11347:	89 07                	mov    %eax,(%edi)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11349:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb1,2);
	amRecvBuffer1->pkt = skb1;
	amRecvBuffer1->SN = 0x0000;
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
   1134c:	66 c7 87 96 00 00 00 	movw   $0x0,0x96(%edi)
   11353:	00 00 
	amRecvBuffer1->segnum = 0;
   11355:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%edi)
   1135c:	00 00 00 
	amIns->vr_r++;
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
   1135f:	66 c7 45 f2 02 80    	movw   $0x8002,-0xe(%ebp)
	amRecvBuffer1->pktstatus = 1;
	amRecvBuffer1->headLen = 2;
	amRecvBuffer1->retxCount = 0;
	amRecvBuffer1->segnum = 0;
	
	amIns->vr_r++;
   11365:	66 83 80 f4 22 00 00 	addw   $0x1,0x22f4(%eax)
   1136c:	01 
	amIns->amRecvWindow[0] = amRecvBuffer1;
   1136d:	89 b8 6c 12 00 00    	mov    %edi,0x126c(%eax)

	amIns->amRecvWindow[1] = NULL;
   11373:	c7 80 70 12 00 00 00 	movl   $0x0,0x1270(%eax)
   1137a:	00 00 00 

	hdr = 0x8002;
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
   1137d:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
	amIns->amRecvWindow[0] = amRecvBuffer1;

	amIns->amRecvWindow[1] = NULL;

	hdr = 0x8002;
	data = 0x0003;	
   11383:	66 c7 45 f0 03 00    	movw   $0x3,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&hdr,2);
   11389:	e8 fc ff ff ff       	call   1138a <addPktTranData+0x10a>
	fsm_skb_put(skb2,2);
   1138e:	ba 02 00 00 00       	mov    $0x2,%edx
   11393:	89 f0                	mov    %esi,%eax
   11395:	e8 fc ff ff ff       	call   11396 <addPktTranData+0x116>
	fsm_mem_cpy(skb2->tail,&data,2);
   1139a:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   113a0:	b9 02 00 00 00       	mov    $0x2,%ecx
   113a5:	8d 55 f0             	lea    -0x10(%ebp),%edx
   113a8:	e8 fc ff ff ff       	call   113a9 <addPktTranData+0x129>
	fsm_skb_put(skb2,2);
   113ad:	ba 02 00 00 00       	mov    $0x2,%edx
   113b2:	89 f0                	mov    %esi,%eax
   113b4:	e8 fc ff ff ff       	call   113b5 <addPktTranData+0x135>
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
   113b9:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   113bf:	8d 55 f0             	lea    -0x10(%ebp),%edx
   113c2:	b9 02 00 00 00       	mov    $0x2,%ecx
	data = 0x0003;	
	fsm_mem_cpy(skb2->tail,&hdr,2);
	fsm_skb_put(skb2,2);
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);
	data = 0x0004;
   113c7:	66 c7 45 f0 04 00    	movw   $0x4,-0x10(%ebp)
	fsm_mem_cpy(skb2->tail,&data,2);
   113cd:	e8 fc ff ff ff       	call   113ce <addPktTranData+0x14e>
	fsm_skb_put(skb2,2);
   113d2:	89 f0                	mov    %esi,%eax
   113d4:	ba 02 00 00 00       	mov    $0x2,%edx
   113d9:	e8 fc ff ff ff       	call   113da <addPktTranData+0x15a>
	amRecvBuffer2->segEnd[0] = 1;
	amRecvBuffer2->segStart[1] = -1;
	amRecvBuffer2->segEnd[1] = -1;
	amRecvBuffer2->segStart[2] = -1;
	amRecvBuffer2->segEnd[2] = -1;
	amIns->amRecvWindow[2] = amRecvBuffer2;
   113de:	8b 45 ec             	mov    -0x14(%ebp),%eax
	fsm_skb_put(skb2,2);
	data = 0x0004;
	fsm_mem_cpy(skb2->tail,&data,2);
	fsm_skb_put(skb2,2);

	amRecvBuffer2->pkt = skb2;
   113e1:	89 33                	mov    %esi,(%ebx)
	amRecvBuffer2->SN = 0x0002;
   113e3:	66 c7 83 94 00 00 00 	movw   $0x2,0x94(%ebx)
   113ea:	02 00 
	amRecvBuffer2->pktstatus = 2;
   113ec:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	amRecvBuffer2->headLen = 2;
   113f3:	c7 43 0c 02 00 00 00 	movl   $0x2,0xc(%ebx)
	amRecvBuffer2->retxCount = 0;
   113fa:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   11401:	00 00 
	amRecvBuffer2->segnum = 3;
   11403:	c7 83 90 00 00 00 03 	movl   $0x3,0x90(%ebx)
   1140a:	00 00 00 
	amRecvBuffer2->segStart[0] = 0;
   1140d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
	amRecvBuffer2->segEnd[0] = 1;
   11414:	c7 43 50 01 00 00 00 	movl   $0x1,0x50(%ebx)
	amRecvBuffer2->segStart[1] = -1;
   1141b:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
	amRecvBuffer2->segEnd[1] = -1;
   11422:	c7 43 54 ff ff ff ff 	movl   $0xffffffff,0x54(%ebx)
	amRecvBuffer2->segStart[2] = -1;
   11429:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
	amRecvBuffer2->segEnd[2] = -1;
   11430:	c7 43 58 ff ff ff ff 	movl   $0xffffffff,0x58(%ebx)
	amIns->amRecvWindow[2] = amRecvBuffer2;
   11437:	89 98 74 12 00 00    	mov    %ebx,0x1274(%eax)
	amIns->vr_h = 3;
   1143d:	66 c7 80 ee 22 00 00 	movw   $0x3,0x22ee(%eax)
   11444:	03 00 
	amIns->vr_ms = 1;
   11446:	66 c7 80 f2 22 00 00 	movw   $0x1,0x22f2(%eax)
   1144d:	01 00 
   1144f:	83 c4 0c             	add    $0xc,%esp
   11452:	5b                   	pop    %ebx
   11453:	5e                   	pop    %esi
   11454:	5f                   	pop    %edi
   11455:	5d                   	pop    %ebp
   11456:	c3                   	ret    
   11457:	90                   	nop
   11458:	90                   	nop
   11459:	90                   	nop
   1145a:	90                   	nop
   1145b:	90                   	nop
   1145c:	90                   	nop
   1145d:	90                   	nop
   1145e:	90                   	nop
   1145f:	90                   	nop

00011460 <Assemble_ctrlPduPart2>:
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11460:	55                   	push   %ebp
   11461:	89 e5                	mov    %esp,%ebp
   11463:	57                   	push   %edi
   11464:	56                   	push   %esi
   11465:	53                   	push   %ebx
   11466:	83 ec 1c             	sub    $0x1c,%esp
   11469:	e8 fc ff ff ff       	call   1146a <Assemble_ctrlPduPart2+0xa>
   1146e:	89 c7                	mov    %eax,%edi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11470:	b8 02 00 00 00       	mov    $0x2,%eax
**Modified by:
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
   11475:	89 ce                	mov    %ecx,%esi
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11477:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1147a:	e8 fc ff ff ff       	call   1147b <Assemble_ctrlPduPart2+0x1b>
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1147f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11482:	89 d1                	mov    %edx,%ecx
   11484:	c1 e1 06             	shl    $0x6,%ecx
   11487:	66 c1 ea 02          	shr    $0x2,%dx
**Modified Date:
************************************************************************/

void Assemble_ctrlPduPart2 (struct Buffer *ctrlBf, SequenceNumber sn,u32 *pduLen,u32 size)
{
	ctrlPduPart2 *part2 = (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   1148b:	89 c3                	mov    %eax,%ebx
	memset(part2,0,sizeof(ctrlPduPart2));
	part2->NACK_SN = sn;
   1148d:	88 50 01             	mov    %dl,0x1(%eax)
	part2->E2 = 1;	
   11490:	89 c8                	mov    %ecx,%eax
   11492:	83 c8 10             	or     $0x10,%eax
   11495:	88 45 eb             	mov    %al,-0x15(%ebp)
   11498:	88 03                	mov    %al,(%ebx)
	if (*pduLen + 6 < size)
   1149a:	8b 06                	mov    (%esi),%eax
   1149c:	8d 50 06             	lea    0x6(%eax),%edx
   1149f:	89 55 f0             	mov    %edx,-0x10(%ebp)
   114a2:	8b 55 08             	mov    0x8(%ebp),%edx
   114a5:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   114a8:	73 66                	jae    11510 <Assemble_ctrlPduPart2+0xb0>
	{
		part2->E1 =1;
   114aa:	83 c9 30             	or     $0x30,%ecx
   114ad:	ba 01 00 00 00       	mov    $0x1,%edx
   114b2:	88 0b                	mov    %cl,(%ebx)
   114b4:	8b 06                	mov    (%esi),%eax
	}
	else if (*pduLen + 6 == size)
	{
		part2->E1 =0;
	}
	fsm_printf("[RLC][Assemble_ctrlPduPart2] pdulen = %d, size = %d, E1 = %d\n",*pduLen,size,part2->E1);
   114b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
   114ba:	8b 55 08             	mov    0x8(%ebp),%edx
   114bd:	89 44 24 04          	mov    %eax,0x4(%esp)
   114c1:	c7 04 24 20 3e 00 00 	movl   $0x3e20,(%esp)
   114c8:	89 54 24 08          	mov    %edx,0x8(%esp)
   114cc:	e8 fc ff ff ff       	call   114cd <Assemble_ctrlPduPart2+0x6d>
	*(u16 *)part2 = htons(*(u16 *)part2);
	fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   114d1:	b9 02 00 00 00       	mov    $0x2,%ecx
   114d6:	89 da                	mov    %ebx,%edx
   114d8:	66 c1 03 08          	rolw   $0x8,(%ebx)
   114dc:	8b 07                	mov    (%edi),%eax
   114de:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   114e4:	e8 fc ff ff ff       	call   114e5 <Assemble_ctrlPduPart2+0x85>
	fsm_skb_put(ctrlBf->pkt,2);
   114e9:	8b 07                	mov    (%edi),%eax
   114eb:	ba 02 00 00 00       	mov    $0x2,%edx
   114f0:	e8 fc ff ff ff       	call   114f1 <Assemble_ctrlPduPart2+0x91>
	*pduLen += 2;
   114f5:	83 06 02             	addl   $0x2,(%esi)
	if ( part2 != NULL )
   114f8:	85 db                	test   %ebx,%ebx
   114fa:	74 07                	je     11503 <Assemble_ctrlPduPart2+0xa3>
	{
		fsm_mem_free(part2);
   114fc:	89 d8                	mov    %ebx,%eax
   114fe:	e8 fc ff ff ff       	call   114ff <Assemble_ctrlPduPart2+0x9f>
		part2=NULL;
	}
}
   11503:	83 c4 1c             	add    $0x1c,%esp
   11506:	5b                   	pop    %ebx
   11507:	5e                   	pop    %esi
   11508:	5f                   	pop    %edi
   11509:	5d                   	pop    %ebp
   1150a:	c3                   	ret    
   1150b:	90                   	nop
   1150c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	part2->E2 = 1;	
	if (*pduLen + 6 < size)
	{
		part2->E1 =1;
	}
	else if (*pduLen + 6 == size)
   11510:	74 06                	je     11518 <Assemble_ctrlPduPart2+0xb8>
	{
		part2->E1 =0;
   11512:	31 d2                	xor    %edx,%edx
   11514:	eb a0                	jmp    114b6 <Assemble_ctrlPduPart2+0x56>
   11516:	66 90                	xchg   %ax,%ax
   11518:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   1151c:	83 e2 df             	and    $0xffffffdf,%edx
   1151f:	88 13                	mov    %dl,(%ebx)
   11521:	31 d2                	xor    %edx,%edx
   11523:	8b 06                	mov    (%esi),%eax
   11525:	eb 8f                	jmp    114b6 <Assemble_ctrlPduPart2+0x56>
   11527:	89 f6                	mov    %esi,%esi
   11529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

00011530 <size_of_ctrl_pdu>:
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
{
   11530:	55                   	push   %ebp
   11531:	89 e5                	mov    %esp,%ebp
   11533:	57                   	push   %edi
   11534:	56                   	push   %esi
   11535:	53                   	push   %ebx
   11536:	83 ec 0c             	sub    $0xc,%esp
   11539:	e8 fc ff ff ff       	call   1153a <size_of_ctrl_pdu+0xa>
	u32 size = 0;
	int i;
	//PDU
	size = 2;  //
   1153e:	bb 02 00 00 00       	mov    $0x2,%ebx
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
   11543:	0f bf 90 ee 22 00 00 	movswl 0x22ee(%eax),%edx
   1154a:	0f bf 88 f4 22 00 00 	movswl 0x22f4(%eax),%ecx
   11551:	83 ea 01             	sub    $0x1,%edx
   11554:	39 d1                	cmp    %edx,%ecx
   11556:	7c 20                	jl     11578 <size_of_ctrl_pdu+0x48>
					}
				}
			}
		}
	}
	fsm_printf("[RLC][size_of_ctrl_pdu] size of ctrl pdu is %d\n",size);
   11558:	89 5c 24 04          	mov    %ebx,0x4(%esp)
   1155c:	c7 04 24 60 3e 00 00 	movl   $0x3e60,(%esp)
   11563:	e8 fc ff ff ff       	call   11564 <size_of_ctrl_pdu+0x34>
	return size;
}
   11568:	89 d8                	mov    %ebx,%eax
   1156a:	83 c4 0c             	add    $0xc,%esp
   1156d:	5b                   	pop    %ebx
   1156e:	5e                   	pop    %esi
   1156f:	5f                   	pop    %edi
   11570:	5d                   	pop    %ebp
   11571:	c3                   	ret    
   11572:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   11578:	0f bf 90 f2 22 00 00 	movswl 0x22f2(%eax),%edx
   1157f:	39 d1                	cmp    %edx,%ecx
   11581:	7d d5                	jge    11558 <size_of_ctrl_pdu+0x28>
**Created Date: 2014/10/15
**---------------------------------------------------------------------
**Modified by:ChenLang
**Modified Date:2015/03
************************************************************************/
u32 size_of_ctrl_pdu(struct AM_Instance *amIns)
   11583:	29 ca                	sub    %ecx,%edx
   11585:	c1 e2 02             	shl    $0x2,%edx
   11588:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1158b:	8d 3c 88             	lea    (%eax,%ecx,4),%edi
   1158e:	31 d2                	xor    %edx,%edx
   11590:	eb 13                	jmp    115a5 <size_of_ctrl_pdu+0x75>
   11592:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
   11598:	83 f9 03             	cmp    $0x3,%ecx
   1159b:	74 43                	je     115e0 <size_of_ctrl_pdu+0xb0>
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   1159d:	83 c2 04             	add    $0x4,%edx
	int i;
	//PDU
	size = 2;  //
	if( amIns->vr_r < amIns->vr_h -1 )  //PDU
	{
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
   115a0:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   115a3:	74 b3                	je     11558 <size_of_ctrl_pdu+0x28>
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
   115a5:	8b 84 17 6c 12 00 00 	mov    0x126c(%edi,%edx,1),%eax
   115ac:	85 c0                	test   %eax,%eax
   115ae:	74 28                	je     115d8 <size_of_ctrl_pdu+0xa8>
			{
				size += 2;//2
			}
			else //PDU
			{
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)
   115b0:	8b 48 04             	mov    0x4(%eax),%ecx
   115b3:	83 f9 01             	cmp    $0x1,%ecx
   115b6:	74 e5                	je     1159d <size_of_ctrl_pdu+0x6d>
				{
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{
						size += 6;//soendsostart6
   115b8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
   115bc:	8d 73 06             	lea    0x6(%ebx),%esi
   115bf:	0f 4f de             	cmovg  %esi,%ebx
					}
					if( amIns->amRecvWindow[i]->pktstatus ==  LAST_SEGMENT)
   115c2:	83 f9 02             	cmp    $0x2,%ecx
   115c5:	75 d1                	jne    11598 <size_of_ctrl_pdu+0x68>
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
   115c7:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   115cd:	8d 04 40             	lea    (%eax,%eax,2),%eax
   115d0:	8d 5c 43 fa          	lea    -0x6(%ebx,%eax,2),%ebx
   115d4:	eb c7                	jmp    1159d <size_of_ctrl_pdu+0x6d>
   115d6:	66 90                	xchg   %ax,%ax
		for( i = amIns->vr_r; i < amIns->vr_ms; i++)
		{
			//sn = i;
			if( amIns->amRecvWindow[i] == NULL )
			{
				size += 2;//2
   115d8:	83 c3 02             	add    $0x2,%ebx
   115db:	eb c0                	jmp    1159d <size_of_ctrl_pdu+0x6d>
   115dd:	8d 76 00             	lea    0x0(%esi),%esi
					{
						size += (amIns->amRecvWindow[i]->segnum - 1)*6;
					}
					else if( amIns->amRecvWindow[i]->pktstatus ==  ANY_SEGMENT)
					{
						size += amIns->amRecvWindow[i]->segnum*6;
   115e0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
   115e6:	8d 04 40             	lea    (%eax,%eax,2),%eax
   115e9:	8d 1c 43             	lea    (%ebx,%eax,2),%ebx
   115ec:	eb af                	jmp    1159d <size_of_ctrl_pdu+0x6d>
   115ee:	66 90                	xchg   %ax,%ax

000115f0 <rlc_ctrl_pkt_trans>:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   115f0:	55                   	push   %ebp
   115f1:	89 e5                	mov    %esp,%ebp
   115f3:	57                   	push   %edi
   115f4:	56                   	push   %esi
   115f5:	53                   	push   %ebx
   115f6:	83 ec 30             	sub    $0x30,%esp
   115f9:	e8 fc ff ff ff       	call   115fa <rlc_ctrl_pkt_trans+0xa>
   115fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
	u32 pduLen;
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
   11601:	c7 04 24 90 3e 00 00 	movl   $0x3e90,(%esp)
   11608:	e8 fc ff ff ff       	call   11609 <rlc_ctrl_pkt_trans+0x19>
	pduLen = 0;
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   1160d:	8b 45 d8             	mov    -0x28(%ebp),%eax
	ctrlPduPart1 *part1;
	ctrlPduPart2 *part2;
	ctrlPduPart3 *part3; // pdu3
	FIN(rlc_ctrl_pkt_trans());
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] entering rlc_ctrl_pkt_trans()\n");
	pduLen = 0;
   11610:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	size = 0;
	size = size_of_ctrl_pdu(amIns);
   11617:	e8 fc ff ff ff       	call   11618 <rlc_ctrl_pkt_trans+0x28>
   1161c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
   1161f:	89 44 24 04          	mov    %eax,0x4(%esp)
   11623:	c7 04 24 cc 3e 00 00 	movl   $0x3ecc,(%esp)
   1162a:	e8 fc ff ff ff       	call   1162b <rlc_ctrl_pkt_trans+0x3b>
	if( size < 2)  //PDU2
   1162f:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
   11633:	0f 86 fc 04 00 00    	jbe    11b35 <rlc_ctrl_pkt_trans+0x545>
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
   11639:	b8 0c 00 00 00       	mov    $0xc,%eax
   1163e:	e8 fc ff ff ff       	call   1163f <rlc_ctrl_pkt_trans+0x4f>
   11643:	89 45 ec             	mov    %eax,-0x14(%ebp)
	memset(ctrlBf,0,sizeof(struct Buffer));
   11646:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1164c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11653:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	ctrlBf->pkt = fsm_pkt_create(size);
   1165a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1165d:	e8 fc ff ff ff       	call   1165e <rlc_ctrl_pkt_trans+0x6e>
   11662:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11665:	89 02                	mov    %eax,(%edx)
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11667:	b8 02 00 00 00       	mov    $0x2,%eax
   1166c:	e8 fc ff ff ff       	call   1166d <rlc_ctrl_pkt_trans+0x7d>
	memset(part1,0,sizeof(ctrlPduPart1));
   11671:	66 c7 00 00 00       	movw   $0x0,(%eax)
		FOUT;
	}
	ctrlBf = (struct Buffer *)fsm_mem_alloc(sizeof(struct Buffer));
	memset(ctrlBf,0,sizeof(struct Buffer));
	ctrlBf->pkt = fsm_pkt_create(size);
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   11676:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	part1->D_C = 0;
	part1->CPT = 0;
   11678:	c6 40 01 00          	movb   $0x0,0x1(%eax)
	part1->ACK_SN = amIns->vr_ms;	
   1167c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1167f:	0f b6 90 f2 22 00 00 	movzbl 0x22f2(%eax),%edx
   11686:	0f b6 03             	movzbl (%ebx),%eax
   11689:	c1 e2 02             	shl    $0x2,%edx
   1168c:	83 e0 03             	and    $0x3,%eax
   1168f:	09 d0                	or     %edx,%eax
   11691:	88 03                	mov    %al,(%ebx)
   11693:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11696:	0f b7 82 f2 22 00 00 	movzwl 0x22f2(%edx),%eax
   1169d:	66 c1 e8 06          	shr    $0x6,%ax
   116a1:	83 e0 0f             	and    $0xf,%eax
   116a4:	88 43 01             	mov    %al,0x1(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
   116a7:	0f bf 82 f2 22 00 00 	movswl 0x22f2(%edx),%eax
   116ae:	c7 04 24 20 3f 00 00 	movl   $0x3f20,(%esp)
   116b5:	89 44 24 04          	mov    %eax,0x4(%esp)
   116b9:	e8 fc ff ff ff       	call   116ba <rlc_ctrl_pkt_trans+0xca>
	fsm_octets_print(part1,2);
   116be:	ba 02 00 00 00       	mov    $0x2,%edx
   116c3:	89 d8                	mov    %ebx,%eax
   116c5:	e8 fc ff ff ff       	call   116c6 <rlc_ctrl_pkt_trans+0xd6>
	if( size == 2 )  //PDU
   116ca:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
   116ce:	0f 84 9b 02 00 00    	je     1196f <rlc_ctrl_pkt_trans+0x37f>
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
   116d4:	c7 04 24 48 3f 00 00 	movl   $0x3f48,(%esp)
   116db:	e8 fc ff ff ff       	call   116dc <rlc_ctrl_pkt_trans+0xec>
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   116e0:	b9 02 00 00 00       	mov    $0x2,%ecx
		pduLen += 2;
	}
	else  //NACK
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
   116e5:	80 0b 02             	orb    $0x2,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   116e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   116eb:	66 c1 03 08          	rolw   $0x8,(%ebx)
   116ef:	8b 02                	mov    (%edx),%eax
   116f1:	89 da                	mov    %ebx,%edx
   116f3:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   116f9:	e8 fc ff ff ff       	call   116fa <rlc_ctrl_pkt_trans+0x10a>
		fsm_skb_put(ctrlBf->pkt,2);
   116fe:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11701:	ba 02 00 00 00       	mov    $0x2,%edx
   11706:	8b 01                	mov    (%ecx),%eax
   11708:	e8 fc ff ff ff       	call   11709 <rlc_ctrl_pkt_trans+0x119>
		pduLen += 2;
   1170d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11710:	83 c0 02             	add    $0x2,%eax
		if( part1 != NULL )
   11713:	85 db                	test   %ebx,%ebx
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] there is nack\n");
		part1->E1 = 1;
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
		fsm_skb_put(ctrlBf->pkt,2);
		pduLen += 2;
   11715:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if( part1 != NULL )
   11718:	74 0a                	je     11724 <rlc_ctrl_pkt_trans+0x134>
		{
			fsm_mem_free(part1);
   1171a:	89 d8                	mov    %ebx,%eax
   1171c:	e8 fc ff ff ff       	call   1171d <rlc_ctrl_pkt_trans+0x12d>
   11721:	8b 45 f0             	mov    -0x10(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
   11724:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11727:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1172b:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11732:	89 44 24 08          	mov    %eax,0x8(%esp)
   11736:	0f bf 83 f4 22 00 00 	movswl 0x22f4(%ebx),%eax
   1173d:	c7 04 24 74 3f 00 00 	movl   $0x3f74,(%esp)
   11744:	89 44 24 04          	mov    %eax,0x4(%esp)
   11748:	e8 fc ff ff ff       	call   11749 <rlc_ctrl_pkt_trans+0x159>
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1174d:	0f b7 83 f4 22 00 00 	movzwl 0x22f4(%ebx),%eax
   11754:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   11757:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   1175a:	0f bf d0             	movswl %ax,%edx
   1175d:	0f 83 3d 02 00 00    	jae    119a0 <rlc_ctrl_pkt_trans+0x3b0>
   11763:	0f bf 8b f2 22 00 00 	movswl 0x22f2(%ebx),%ecx
   1176a:	39 ca                	cmp    %ecx,%edx
   1176c:	0f 8d 2e 02 00 00    	jge    119a0 <rlc_ctrl_pkt_trans+0x3b0>
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11772:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11775:	8d 5a 01             	lea    0x1(%edx),%ebx
   11778:	89 5d dc             	mov    %ebx,-0x24(%ebp)
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   1177b:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   1177f:	8d b4 91 6c 12 00 00 	lea    0x126c(%ecx,%edx,4),%esi
   11786:	66 90                	xchg   %ax,%ax
   11788:	8b 45 dc             	mov    -0x24(%ebp),%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   1178b:	c7 04 24 b4 3f 00 00 	movl   $0x3fb4,(%esp)
**Modified by:
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
   11792:	83 e8 01             	sub    $0x1,%eax
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
   11795:	89 44 24 04          	mov    %eax,0x4(%esp)
   11799:	e8 fc ff ff ff       	call   1179a <rlc_ctrl_pkt_trans+0x1aa>
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
   1179e:	8b 0e                	mov    (%esi),%ecx
   117a0:	85 c9                	test   %ecx,%ecx
   117a2:	0f 84 f8 02 00 00    	je     11aa0 <rlc_ctrl_pkt_trans+0x4b0>
					}
				}
			}
			else
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] != NULL\n");
   117a8:	c7 04 24 14 40 00 00 	movl   $0x4014,(%esp)
   117af:	e8 fc ff ff ff       	call   117b0 <rlc_ctrl_pkt_trans+0x1c0>
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
   117b4:	8b 06                	mov    (%esi),%eax
   117b6:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
   117ba:	0f 84 80 01 00 00    	je     11940 <rlc_ctrl_pkt_trans+0x350>
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
   117c0:	8b 50 10             	mov    0x10(%eax),%edx
   117c3:	85 d2                	test   %edx,%edx
   117c5:	0f 8e 8d 00 00 00    	jle    11858 <rlc_ctrl_pkt_trans+0x268>
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
   117cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   117ce:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   117d1:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   117d5:	89 04 24             	mov    %eax,(%esp)
   117d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   117db:	e8 fc ff ff ff       	call   117dc <rlc_ctrl_pkt_trans+0x1ec>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   117e0:	b8 04 00 00 00       	mov    $0x4,%eax
   117e5:	e8 fc ff ff ff       	call   117e6 <rlc_ctrl_pkt_trans+0x1f6>
						memset(part3,0,sizeof(ctrlPduPart3));
   117ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				if( amIns->amRecvWindow[i]->pktstatus != FULL_SDU)  //
				{				
					if( amIns->amRecvWindow[i]->segStart[0] > 0 )
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   117f0:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
   117f2:	c6 40 02 00          	movb   $0x0,0x2(%eax)
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   117f6:	8b 06                	mov    (%esi),%eax
   117f8:	8b 50 10             	mov    0x10(%eax),%edx
   117fb:	0f b6 03             	movzbl (%ebx),%eax
   117fe:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
   11805:	83 e0 03             	and    $0x3,%eax
   11808:	09 c8                	or     %ecx,%eax
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1180a:	b9 04 00 00 00       	mov    $0x4,%ecx
					{					
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
   1180f:	88 03                	mov    %al,(%ebx)
   11811:	89 d0                	mov    %edx,%eax
   11813:	66 c1 e8 06          	shr    $0x6,%ax
   11817:	88 43 01             	mov    %al,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   1181a:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   1181d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11820:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);//
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = 0;
						part3->SOend = amIns->amRecvWindow[i]->segStart[0];
						*(u32 *)part3 = htons(*(u32 *)part3);
   11824:	0f b7 c0             	movzwl %ax,%eax
   11827:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11829:	8b 02                	mov    (%edx),%eax
   1182b:	89 da                	mov    %ebx,%edx
   1182d:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11833:	e8 fc ff ff ff       	call   11834 <rlc_ctrl_pkt_trans+0x244>
						fsm_skb_put(ctrlBf->pkt,4);
   11838:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   1183b:	ba 04 00 00 00       	mov    $0x4,%edx
   11840:	8b 01                	mov    (%ecx),%eax
   11842:	e8 fc ff ff ff       	call   11843 <rlc_ctrl_pkt_trans+0x253>
						pduLen += 4;
   11847:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   1184b:	85 db                	test   %ebx,%ebx
   1184d:	74 07                	je     11856 <rlc_ctrl_pkt_trans+0x266>
						{
							fsm_mem_free(part3);
   1184f:	89 d8                	mov    %ebx,%eax
   11851:	e8 fc ff ff ff       	call   11852 <rlc_ctrl_pkt_trans+0x262>
   11856:	8b 06                	mov    (%esi),%eax
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11858:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
**Modified Date:
************************************************************************/


void rlc_ctrl_pkt_trans(struct AM_Instance *amIns)
{
   1185e:	31 ff                	xor    %edi,%edi
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11860:	0f bf 5d e8          	movswl -0x18(%ebp),%ebx
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11864:	83 ea 01             	sub    $0x1,%edx
   11867:	39 d7                	cmp    %edx,%edi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11869:	89 5d e0             	mov    %ebx,-0x20(%ebp)
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   1186c:	0f 83 c4 00 00 00    	jae    11936 <rlc_ctrl_pkt_trans+0x346>
   11872:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11878:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1187b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   1187e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11881:	89 04 24             	mov    %eax,(%esp)
   11884:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11887:	e8 fc ff ff ff       	call   11888 <rlc_ctrl_pkt_trans+0x298>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1188c:	b8 04 00 00 00       	mov    $0x4,%eax
   11891:	e8 fc ff ff ff       	call   11892 <rlc_ctrl_pkt_trans+0x2a2>
						memset(part3,0,sizeof(ctrlPduPart3));
   11896:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   1189c:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   1189e:	8b 06                	mov    (%esi),%eax
   118a0:	8b 54 b8 50          	mov    0x50(%eax,%edi,4),%edx
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   118a4:	83 c7 01             	add    $0x1,%edi
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   118a7:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
   118ab:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
   118ae:	83 e0 01             	and    $0x1,%eax
   118b1:	09 c8                	or     %ecx,%eax
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   118b3:	b9 04 00 00 00       	mov    $0x4,%ecx
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
					{
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
   118b8:	66 c1 ea 07          	shr    $0x7,%dx
   118bc:	88 43 02             	mov    %al,0x2(%ebx)
   118bf:	88 53 03             	mov    %dl,0x3(%ebx)
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
   118c2:	8b 16                	mov    (%esi),%edx
   118c4:	8b 54 ba 10          	mov    0x10(%edx,%edi,4),%edx
   118c8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
   118cb:	c1 e2 02             	shl    $0x2,%edx
   118ce:	88 55 eb             	mov    %dl,-0x15(%ebp)
   118d1:	0f b6 13             	movzbl (%ebx),%edx
   118d4:	83 e2 03             	and    $0x3,%edx
   118d7:	0a 55 eb             	or     -0x15(%ebp),%dl
   118da:	88 13                	mov    %dl,(%ebx)
   118dc:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
   118e0:	66 c1 ea 06          	shr    $0x6,%dx
   118e4:	88 53 01             	mov    %dl,0x1(%ebx)
						*(u32 *)part3 = htons(*(u32 *)part3);
   118e7:	0f b7 03             	movzwl (%ebx),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   118ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
   118ed:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[j];
						part3->SOend = amIns->amRecvWindow[i]->segStart[j+1] ;
						*(u32 *)part3 = htons(*(u32 *)part3);
   118f1:	0f b7 c0             	movzwl %ax,%eax
   118f4:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   118f6:	8b 02                	mov    (%edx),%eax
   118f8:	89 da                	mov    %ebx,%edx
   118fa:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11900:	e8 fc ff ff ff       	call   11901 <rlc_ctrl_pkt_trans+0x311>
						fsm_skb_put(ctrlBf->pkt,4);
   11905:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11908:	ba 04 00 00 00       	mov    $0x4,%edx
   1190d:	8b 01                	mov    (%ecx),%eax
   1190f:	e8 fc ff ff ff       	call   11910 <rlc_ctrl_pkt_trans+0x320>
						pduLen += 4;
   11914:	83 45 f0 04          	addl   $0x4,-0x10(%ebp)
						if( part3 != NULL )
   11918:	85 db                	test   %ebx,%ebx
   1191a:	74 07                	je     11923 <rlc_ctrl_pkt_trans+0x333>
						{
							fsm_mem_free(part3);
   1191c:	89 d8                	mov    %ebx,%eax
   1191e:	e8 fc ff ff ff       	call   1191f <rlc_ctrl_pkt_trans+0x32f>
   11923:	8b 06                	mov    (%esi),%eax
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}				
					for( j = 0; j < amIns->amRecvWindow[i]->segnum - 1; j++ )
   11925:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
   1192b:	83 ea 01             	sub    $0x1,%edx
   1192e:	39 d7                	cmp    %edx,%edi
   11930:	0f 82 42 ff ff ff    	jb     11878 <rlc_ctrl_pkt_trans+0x288>
						{
							fsm_mem_free(part3);
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
   11936:	83 78 04 03          	cmpl   $0x3,0x4(%eax)
   1193a:	0f 84 e1 00 00 00    	je     11a21 <rlc_ctrl_pkt_trans+0x431>
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
						if( part3 != NULL )
						{
							fsm_mem_free(part3);
   11940:	8b 45 f0             	mov    -0x10(%ebp),%eax
		{
			fsm_mem_free(part1);
			part1=NULL;
		}
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_r = %d, vr_ms = %d, pdulen = %d\n",amIns->vr_r,amIns->vr_ms,pduLen);
		for( i = amIns->vr_r; i < amIns->vr_ms && pduLen < size; i++ )
   11943:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11946:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
   11949:	0f bf 83 f2 22 00 00 	movswl 0x22f2(%ebx),%eax
   11950:	0f 97 c2             	seta   %dl
   11953:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   11956:	0f 9f c0             	setg   %al
   11959:	83 c6 04             	add    $0x4,%esi
   1195c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   11960:	66 83 45 e8 01       	addw   $0x1,-0x18(%ebp)
   11965:	84 c2                	test   %al,%dl
   11967:	0f 85 1b fe ff ff    	jne    11788 <rlc_ctrl_pkt_trans+0x198>
   1196d:	eb 31                	jmp    119a0 <rlc_ctrl_pkt_trans+0x3b0>
	part1->ACK_SN = amIns->vr_ms;	
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] vr_ms = %d\n",amIns->vr_ms);
	fsm_octets_print(part1,2);
	if( size == 2 )  //PDU
	{
		part1->E1 = 0;
   1196f:	80 23 fd             	andb   $0xfd,(%ebx)
		*(u16 *)part1 = htons(*(u16 *)part1);
		fsm_mem_cpy(ctrlBf->pkt->tail,part1,2);
   11972:	89 da                	mov    %ebx,%edx
   11974:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11977:	66 c1 03 08          	rolw   $0x8,(%ebx)
   1197b:	8b 01                	mov    (%ecx),%eax
   1197d:	b9 02 00 00 00       	mov    $0x2,%ecx
   11982:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11988:	e8 fc ff ff ff       	call   11989 <rlc_ctrl_pkt_trans+0x399>
		fsm_skb_put(ctrlBf->pkt,2);
   1198d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   11990:	ba 02 00 00 00       	mov    $0x2,%edx
   11995:	8b 03                	mov    (%ebx),%eax
   11997:	e8 fc ff ff ff       	call   11998 <rlc_ctrl_pkt_trans+0x3a8>
		pduLen += 2;
   1199c:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   119a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   119a3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   119a6:	8b 5d d8             	mov    -0x28(%ebp),%ebx
					}
				}
			}
		}
	}
	amIns->ctrlPduBufferNum++;
   119a9:	8b 90 bc 01 00 00    	mov    0x1bc(%eax),%edx
   119af:	83 c2 01             	add    $0x1,%edx
   119b2:	89 90 bc 01 00 00    	mov    %edx,0x1bc(%eax)
	amIns->ctrlPduBufferSize += ctrlBf->pkt->len;
   119b8:	8b 01                	mov    (%ecx),%eax
   119ba:	8b 40 50             	mov    0x50(%eax),%eax
   119bd:	03 83 b8 01 00 00    	add    0x1b8(%ebx),%eax
   119c3:	89 83 b8 01 00 00    	mov    %eax,0x1b8(%ebx)
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
   119c9:	89 54 24 04          	mov    %edx,0x4(%esp)
   119cd:	89 44 24 08          	mov    %eax,0x8(%esp)
   119d1:	c7 04 24 50 40 00 00 	movl   $0x4050,(%esp)
   119d8:	e8 fc ff ff ff       	call   119d9 <rlc_ctrl_pkt_trans+0x3e9>
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
   119dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   119e0:	89 d9                	mov    %ebx,%ecx
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   119e2:	8b 83 b4 01 00 00    	mov    0x1b4(%ebx),%eax
   119e8:	81 c1 b0 01 00 00    	add    $0x1b0,%ecx
   119ee:	83 c2 04             	add    $0x4,%edx
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   119f1:	89 93 b4 01 00 00    	mov    %edx,0x1b4(%ebx)
   119f7:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	new->next = next;
	new->prev = prev;
   119fa:	89 43 08             	mov    %eax,0x8(%ebx)
   119fd:	89 4b 04             	mov    %ecx,0x4(%ebx)
	prev->next = new;
   11a00:	89 10                	mov    %edx,(%eax)
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
   11a02:	8b 03                	mov    (%ebx),%eax
   11a04:	8b 50 50             	mov    0x50(%eax),%edx
   11a07:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11a0d:	e8 fc ff ff ff       	call   11a0e <rlc_ctrl_pkt_trans+0x41e>
	amIns->statFlag = false;
   11a12:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11a15:	c6 40 06 00          	movb   $0x0,0x6(%eax)
	FOUT;
}
   11a19:	83 c4 30             	add    $0x30,%esp
   11a1c:	5b                   	pop    %ebx
   11a1d:	5e                   	pop    %esi
   11a1e:	5f                   	pop    %edi
   11a1f:	5d                   	pop    %ebp
   11a20:	c3                   	ret    
							part3=NULL;
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
   11a21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a24:	8d 4d f0             	lea    -0x10(%ebp),%ecx
   11a27:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
   11a2b:	89 04 24             	mov    %eax,(%esp)
   11a2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11a31:	e8 fc ff ff ff       	call   11a32 <rlc_ctrl_pkt_trans+0x442>
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11a36:	b8 04 00 00 00       	mov    $0x4,%eax
   11a3b:	e8 fc ff ff ff       	call   11a3c <rlc_ctrl_pkt_trans+0x44c>
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11a40:	b9 04 00 00 00       	mov    $0x4,%ecx
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
   11a45:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
						}
					}
					if( amIns->amRecvWindow[i]->pktstatus == ANY_SEGMENT)  //
					{			
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
   11a4b:	89 c3                	mov    %eax,%ebx
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
   11a4d:	80 08 fc             	orb    $0xfc,(%eax)
   11a50:	c6 40 01 ff          	movb   $0xff,0x1(%eax)
						*(u32 *)part3 = htons(*(u32 *)part3);
   11a54:	0f b7 00             	movzwl (%eax),%eax
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11a57:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11a5a:	66 c1 c0 08          	rol    $0x8,%ax
						Assemble_ctrlPduPart2(ctrlBf,sn,&pduLen,size);
						part3= (ctrlPduPart3*)fsm_mem_alloc(sizeof(ctrlPduPart3));
						memset(part3,0,sizeof(ctrlPduPart3));
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
   11a5e:	0f b7 c0             	movzwl %ax,%eax
   11a61:	89 03                	mov    %eax,(%ebx)
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
   11a63:	8b 02                	mov    (%edx),%eax
   11a65:	89 da                	mov    %ebx,%edx
   11a67:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11a6d:	e8 fc ff ff ff       	call   11a6e <rlc_ctrl_pkt_trans+0x47e>
						fsm_skb_put(ctrlBf->pkt,4);
   11a72:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11a75:	ba 04 00 00 00       	mov    $0x4,%edx
   11a7a:	8b 01                	mov    (%ecx),%eax
   11a7c:	e8 fc ff ff ff       	call   11a7d <rlc_ctrl_pkt_trans+0x48d>
						pduLen += 4;
   11a81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a84:	83 c0 04             	add    $0x4,%eax
						if( part3 != NULL )
   11a87:	85 db                	test   %ebx,%ebx
						part3->SOstart = amIns->amRecvWindow[i]->segEnd[amIns->amRecvWindow[i]->segnum-1];
						part3->SOend = 0x7fff;
						*(u32 *)part3 = htons(*(u32 *)part3);
						fsm_mem_cpy(ctrlBf->pkt->tail,part3,4);
						fsm_skb_put(ctrlBf->pkt,4);
						pduLen += 4;
   11a89:	89 45 f0             	mov    %eax,-0x10(%ebp)
						if( part3 != NULL )
   11a8c:	0f 84 b1 fe ff ff    	je     11943 <rlc_ctrl_pkt_trans+0x353>
						{
							fsm_mem_free(part3);
   11a92:	89 d8                	mov    %ebx,%eax
   11a94:	e8 fc ff ff ff       	call   11a95 <rlc_ctrl_pkt_trans+0x4a5>
   11a99:	e9 a2 fe ff ff       	jmp    11940 <rlc_ctrl_pkt_trans+0x350>
   11a9e:	66 90                	xchg   %ax,%ax
		{
			fsm_printf("[RLC][rlc_ctrl_pkt_trans] i = %d\n",i);
			sn = i;
			if(amIns->amRecvWindow[i] == NULL)  //PDU
			{
				fsm_printf("[RLC][rlc_ctrl_pkt_trans] amIns->amRecvWindow[i] == NULL\n");
   11aa0:	c7 04 24 d8 3f 00 00 	movl   $0x3fd8,(%esp)
   11aa7:	e8 fc ff ff ff       	call   11aa8 <rlc_ctrl_pkt_trans+0x4b8>
				if( pduLen+2<=size )
   11aac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11aaf:	8d 50 02             	lea    0x2(%eax),%edx
   11ab2:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
   11ab5:	0f 82 88 fe ff ff    	jb     11943 <rlc_ctrl_pkt_trans+0x353>
				{
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
   11abb:	b8 02 00 00 00       	mov    $0x2,%eax
   11ac0:	e8 fc ff ff ff       	call   11ac1 <rlc_ctrl_pkt_trans+0x4d1>
   11ac5:	89 c3                	mov    %eax,%ebx
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
   11ac7:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
   11acb:	c1 e0 06             	shl    $0x6,%eax
   11ace:	88 03                	mov    %al,(%ebx)
   11ad0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
   11ad4:	66 c1 ea 02          	shr    $0x2,%dx
   11ad8:	88 53 01             	mov    %dl,0x1(%ebx)
					if( pduLen+2==size )
   11adb:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11ade:	83 c2 02             	add    $0x2,%edx
   11ae1:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
   11ae4:	74 48                	je     11b2e <rlc_ctrl_pkt_trans+0x53e>
					{
						part2->E1=0; //E11
					}
					else
					{
						part2->E1=1;
   11ae6:	83 c8 20             	or     $0x20,%eax
   11ae9:	88 03                	mov    %al,(%ebx)
					}
					part2->E2=0;
   11aeb:	80 23 ef             	andb   $0xef,(%ebx)
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
   11aee:	b9 02 00 00 00       	mov    $0x2,%ecx
   11af3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11af6:	66 c1 03 08          	rolw   $0x8,(%ebx)
   11afa:	8b 02                	mov    (%edx),%eax
   11afc:	89 da                	mov    %ebx,%edx
   11afe:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11b04:	e8 fc ff ff ff       	call   11b05 <rlc_ctrl_pkt_trans+0x515>
					fsm_skb_put(ctrlBf->pkt,2);
   11b09:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11b0c:	ba 02 00 00 00       	mov    $0x2,%edx
   11b11:	8b 01                	mov    (%ecx),%eax
   11b13:	e8 fc ff ff ff       	call   11b14 <rlc_ctrl_pkt_trans+0x524>
					pduLen += 2;
   11b18:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b1b:	83 c0 02             	add    $0x2,%eax
					if( part2 != NULL )
   11b1e:	85 db                	test   %ebx,%ebx
					}
					part2->E2=0;
					*(u16 *)part2 = htons(*(u16 *)part2);
					fsm_mem_cpy(ctrlBf->pkt->tail,part2,2);
					fsm_skb_put(ctrlBf->pkt,2);
					pduLen += 2;
   11b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if( part2 != NULL )
   11b23:	0f 85 69 ff ff ff    	jne    11a92 <rlc_ctrl_pkt_trans+0x4a2>
   11b29:	e9 15 fe ff ff       	jmp    11943 <rlc_ctrl_pkt_trans+0x353>
					part2= (ctrlPduPart2*)fsm_mem_alloc(sizeof(ctrlPduPart2));
					memset(part2,0,sizeof(ctrlPduPart2));
					part2->NACK_SN = sn;
					if( pduLen+2==size )
					{
						part2->E1=0; //E11
   11b2e:	83 e0 df             	and    $0xffffffdf,%eax
   11b31:	88 03                	mov    %al,(%ebx)
   11b33:	eb b6                	jmp    11aeb <rlc_ctrl_pkt_trans+0x4fb>
	size = 0;
	size = size_of_ctrl_pdu(amIns);
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] size = %d\n",size);
	if( size < 2)  //PDU2
	{
		fsm_printf("[RLC][rlc_ctrl_pkt_trans] discard the PDU\n");
   11b35:	c7 04 24 f4 3e 00 00 	movl   $0x3ef4,(%esp)
   11b3c:	e8 fc ff ff ff       	call   11b3d <rlc_ctrl_pkt_trans+0x54d>
	fsm_printf("[RLC][rlc_ctrl_pkt_trans] ctrlPduBufferNum = %d, ctlPduSize = %d\n",amIns->ctrlPduBufferNum,amIns->ctrlPduBufferSize);
	list_add_tail(&ctrlBf->list,&amIns->ctrlPduBuffer.list);
	fsm_octets_print(ctrlBf->pkt->data,ctrlBf->pkt->len);
	amIns->statFlag = false;
	FOUT;
}
   11b41:	83 c4 30             	add    $0x30,%esp
   11b44:	5b                   	pop    %ebx
   11b45:	5e                   	pop    %esi
   11b46:	5f                   	pop    %edi
   11b47:	5d                   	pop    %ebp
   11b48:	c3                   	ret    
   11b49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00011b50 <ack_handler>:
**----------------------------------------------------------------------------------
**Modified by: ZhangYi
**Modified Date: 2014/10/13
**********************************************************************************************/
void ack_handler(struct AM_Instance *amIns,SequenceNumber ackSn)   //20141013
{
   11b50:	55                   	push   %ebp
   11b51:	89 e5                	mov    %esp,%ebp
   11b53:	57                   	push   %edi
   11b54:	56                   	push   %esi
   11b55:	53                   	push   %ebx
   11b56:	83 ec 10             	sub    $0x10,%esp
   11b59:	e8 fc ff ff ff       	call   11b5a <ack_handler+0xa>
   11b5e:	89 c3                	mov    %eax,%ebx
   11b60:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11b64:	0f b7 90 66 12 00 00 	movzwl 0x1266(%eax),%edx
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11b6b:	0f bf 45 ee          	movswl -0x12(%ebp),%eax
   11b6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11b72:	8d 83 f0 00 00 00    	lea    0xf0(%ebx),%eax
   11b78:	89 45 f0             	mov    %eax,-0x10(%ebp)
   11b7b:	90                   	nop
   11b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	//struct AmBuffer *amTxedBf;
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	int i;
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
   11b80:	66 39 55 ee          	cmp    %dx,-0x12(%ebp)
   11b84:	7f 12                	jg     11b98 <ack_handler+0x48>
   11b86:	0f bf c2             	movswl %dx,%eax
   11b89:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11b8f:	39 4d e8             	cmp    %ecx,-0x18(%ebp)
   11b92:	0f 8d 17 02 00 00    	jge    11daf <ack_handler+0x25f>
   11b98:	0f b7 b3 64 12 00 00 	movzwl 0x1264(%ebx),%esi
   11b9f:	66 39 d6             	cmp    %dx,%si
   11ba2:	7f 14                	jg     11bb8 <ack_handler+0x68>
   11ba4:	0f bf c2             	movswl %dx,%eax
   11ba7:	0f bf f6             	movswl %si,%esi
   11baa:	8d 88 00 fe ff ff    	lea    -0x200(%eax),%ecx
   11bb0:	39 ce                	cmp    %ecx,%esi
   11bb2:	0f 8d f7 01 00 00    	jge    11daf <ack_handler+0x25f>
	{
		if( amIns->vt_a == amIns->pollSn )
   11bb8:	66 39 93 00 23 00 00 	cmp    %dx,0x2300(%ebx)
   11bbf:	0f 84 bb 01 00 00    	je     11d80 <ack_handler+0x230>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11bc5:	8b 8b f0 00 00 00    	mov    0xf0(%ebx),%ecx
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
			}
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11bcb:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
   11bce:	74 45                	je     11c15 <ack_handler+0xc5>
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11bd0:	8b 01                	mov    (%ecx),%eax
   11bd2:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11bd8:	8b 7d f0             	mov    -0x10(%ebp),%edi
   11bdb:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11be0:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11be4:	75 19                	jne    11bff <ack_handler+0xaf>
   11be6:	e9 2f 01 00 00       	jmp    11d1a <ack_handler+0x1ca>
   11beb:	90                   	nop
   11bec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   11bf0:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11bf7:	0f 84 1b 01 00 00    	je     11d18 <ack_handler+0x1c8>
		}

		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11bfd:	89 f0                	mov    %esi,%eax
   11bff:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11c05:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11c0b:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11c11:	39 cf                	cmp    %ecx,%edi
   11c13:	75 db                	jne    11bf0 <ack_handler+0xa0>
   11c15:	8b 8b 9c 01 00 00    	mov    0x19c(%ebx),%ecx
			}
			//nposBf = NULL;
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
   11c1b:	8d bb 9c 01 00 00    	lea    0x19c(%ebx),%edi
   11c21:	39 cf                	cmp    %ecx,%edi
   11c23:	74 3c                	je     11c61 <ack_handler+0x111>
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11c25:	8b 01                	mov    (%ecx),%eax
   11c27:	8d b1 64 ff ff ff    	lea    -0x9c(%ecx),%esi
   11c2d:	2d 9c 00 00 00       	sub    $0x9c,%eax
			{
				if( amRetxBf->SN == amIns->vt_a )
   11c32:	66 39 51 f8          	cmp    %dx,-0x8(%ecx)
   11c36:	75 13                	jne    11c4b <ack_handler+0xfb>
   11c38:	eb 50                	jmp    11c8a <ack_handler+0x13a>
   11c3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11c40:	66 39 90 94 00 00 00 	cmp    %dx,0x94(%eax)
   11c47:	74 3f                	je     11c88 <ack_handler+0x138>
		}

		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   11c49:	89 f0                	mov    %esi,%eax
   11c4b:	8b b0 9c 00 00 00    	mov    0x9c(%eax),%esi
   11c51:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
   11c57:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
   11c5d:	39 cf                	cmp    %ecx,%edi
   11c5f:	75 df                	jne    11c40 <ack_handler+0xf0>
					break;
				}
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
   11c61:	0f bf c2             	movswl %dx,%eax
   11c64:	83 c0 01             	add    $0x1,%eax
   11c67:	89 c1                	mov    %eax,%ecx
   11c69:	c1 f9 1f             	sar    $0x1f,%ecx
   11c6c:	c1 e9 16             	shr    $0x16,%ecx
   11c6f:	01 c8                	add    %ecx,%eax
   11c71:	25 ff 03 00 00       	and    $0x3ff,%eax
   11c76:	29 c8                	sub    %ecx,%eax
   11c78:	89 c2                	mov    %eax,%edx
   11c7a:	66 89 83 66 12 00 00 	mov    %ax,0x1266(%ebx)
   11c81:	e9 fa fe ff ff       	jmp    11b80 <ack_handler+0x30>
   11c86:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amRetxBuffer.list) )
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
   11c88:	89 c6                	mov    %eax,%esi
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11c8a:	8b be 90 00 00 00    	mov    0x90(%esi),%edi
   11c90:	31 d2                	xor    %edx,%edx
   11c92:	8b 83 a4 01 00 00    	mov    0x1a4(%ebx),%eax
   11c98:	85 ff                	test   %edi,%edi
   11c9a:	74 1d                	je     11cb9 <ack_handler+0x169>
   11c9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11ca0:	03 44 96 10          	add    0x10(%esi,%edx,4),%eax
   11ca4:	2b 44 96 50          	sub    0x50(%esi,%edx,4),%eax
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11ca8:	83 c2 01             	add    $0x1,%edx
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   11cab:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
		{
			list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
			{
				if( amRetxBf->SN == amIns->vt_a )
				{
					for( i = 0; i <amRetxBf->segnum; i++)
   11cb1:	3b 96 90 00 00 00    	cmp    0x90(%esi),%edx
   11cb7:	72 e7                	jb     11ca0 <ack_handler+0x150>
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11cb9:	2b 46 0c             	sub    0xc(%esi),%eax
					amIns->amRetxBufferNum--;
   11cbc:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				{
					for( i = 0; i <amRetxBf->segnum; i++)
					{
						amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   11cc3:	89 83 a4 01 00 00    	mov    %eax,0x1a4(%ebx)
					amIns->amRetxBufferNum--;
					if(amRetxBf->pkt != NULL)
   11cc9:	8b 06                	mov    (%esi),%eax
   11ccb:	85 c0                	test   %eax,%eax
   11ccd:	74 0b                	je     11cda <ack_handler+0x18a>
					{
						fsm_pkt_destroy( amRetxBf->pkt );
   11ccf:	e8 fc ff ff ff       	call   11cd0 <ack_handler+0x180>
						amRetxBf->pkt = NULL;
   11cd4:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11cda:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amRetxBf->list);
					if(amRetxBf != NULL)
   11ce0:	85 f6                	test   %esi,%esi
   11ce2:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11ce8:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11ceb:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11ced:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11cf4:	01 10 00 
	entry->prev = LIST_POISON2;
   11cf7:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11cfe:	02 20 00 
   11d01:	74 07                	je     11d0a <ack_handler+0x1ba>
					{
						fsm_mem_free(amRetxBf);
   11d03:	89 f0                	mov    %esi,%eax
   11d05:	e8 fc ff ff ff       	call   11d06 <ack_handler+0x1b6>
   11d0a:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11d11:	e9 4b ff ff ff       	jmp    11c61 <ack_handler+0x111>
   11d16:	66 90                	xchg   %ax,%ax
		//vt_a
		if( !list_empty(&amIns->amTransmittedBuffer.list) )
		{
			list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
			{
				if( amTxedBuffer->SN == amIns->vt_a )
   11d18:	89 c6                	mov    %eax,%esi
				{
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11d1a:	8b 06                	mov    (%esi),%eax
   11d1c:	8b 40 50             	mov    0x50(%eax),%eax
   11d1f:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11d25:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					if(amTxedBuffer->pkt != NULL)
   11d2c:	8b 06                	mov    (%esi),%eax
   11d2e:	85 c0                	test   %eax,%eax
   11d30:	74 0b                	je     11d3d <ack_handler+0x1ed>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   11d32:	e8 fc ff ff ff       	call   11d33 <ack_handler+0x1e3>
						amTxedBuffer->pkt = NULL;
   11d37:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11d3d:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   11d43:	85 f6                	test   %esi,%esi
   11d45:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11d4b:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11d4e:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11d50:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11d57:	01 10 00 
	entry->prev = LIST_POISON2;
   11d5a:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11d61:	02 20 00 
   11d64:	74 07                	je     11d6d <ack_handler+0x21d>
					{
						fsm_mem_free(amTxedBuffer);
   11d66:	89 f0                	mov    %esi,%eax
   11d68:	e8 fc ff ff ff       	call   11d69 <ack_handler+0x219>
   11d6d:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11d74:	e9 9c fe ff ff       	jmp    11c15 <ack_handler+0xc5>
   11d79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while( (amIns->vt_a<ackSn||ackSn<amIns->vt_a-AM_WINDOW_SIZE) && (amIns->vt_a<amIns->vt_s||amIns->vt_s<amIns->vt_a-AM_WINDOW_SIZE))
	{
		if( amIns->vt_a == amIns->pollSn )
		{
			//
			if(amIns->pollRetxTimer)
   11d80:	8b 43 08             	mov    0x8(%ebx),%eax
   11d83:	85 c0                	test   %eax,%eax
   11d85:	0f 84 3a fe ff ff    	je     11bc5 <ack_handler+0x75>
			{
				fsm_schedule_cancel(amIns->pollRetxTimer);
   11d8b:	e8 fc ff ff ff       	call   11d8c <ack_handler+0x23c>
				amIns->pollRetxTimer = 0;
   11d90:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
				fsm_printf("[RLC][ack_handler] pollRetsTimer cancelled\n");
   11d97:	c7 04 24 94 40 00 00 	movl   $0x4094,(%esp)
   11d9e:	e8 fc ff ff ff       	call   11d9f <ack_handler+0x24f>
   11da3:	0f b7 93 66 12 00 00 	movzwl 0x1266(%ebx),%edx
   11daa:	e9 16 fe ff ff       	jmp    11bc5 <ack_handler+0x75>
			}
			//nposBf = NULL;
		}
		amIns->vt_a = (amIns->vt_a + 1)%(AM_WINDOW_SIZE*2);
	}
	amIns->vt_ms = (amIns->vt_a + AM_WINDOW_SIZE)%(AM_WINDOW_SIZE*2);
   11daf:	05 00 02 00 00       	add    $0x200,%eax
   11db4:	89 c2                	mov    %eax,%edx
   11db6:	c1 fa 1f             	sar    $0x1f,%edx
   11db9:	c1 ea 16             	shr    $0x16,%edx
   11dbc:	01 d0                	add    %edx,%eax
   11dbe:	25 ff 03 00 00       	and    $0x3ff,%eax
   11dc3:	29 d0                	sub    %edx,%eax
   11dc5:	66 89 83 68 12 00 00 	mov    %ax,0x1268(%ebx)
}
   11dcc:	83 c4 10             	add    $0x10,%esp
   11dcf:	5b                   	pop    %ebx
   11dd0:	5e                   	pop    %esi
   11dd1:	5f                   	pop    %edi
   11dd2:	5d                   	pop    %ebp
   11dd3:	c3                   	ret    
   11dd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11dda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

00011de0 <no_so_handler>:
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11de0:	55                   	push   %ebp
   11de1:	89 e5                	mov    %esp,%ebp
   11de3:	57                   	push   %edi
   11de4:	56                   	push   %esi
   11de5:	53                   	push   %ebx
   11de6:	83 ec 14             	sub    $0x14,%esp
   11de9:	e8 fc ff ff ff       	call   11dea <no_so_handler+0xa>
   11dee:	89 c3                	mov    %eax,%ebx
   11df0:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11df3:	8d bb f0 00 00 00    	lea    0xf0(%ebx),%edi
**Modified by:
**Modified Date:
**********************************************************************************************/

void no_so_handler(struct AM_Instance *amIns, ctrlPduPart2 *part2, bool *isPduFound)
{
   11df9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
	struct AmBuffer *amTxedBuffer;	//
	struct AmBuffer *amRetxBf;
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
   11dfc:	c7 04 24 c0 40 00 00 	movl   $0x40c0,(%esp)
   11e03:	e8 fc ff ff ff       	call   11e04 <no_so_handler+0x24>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11e08:	8b 83 f0 00 00 00    	mov    0xf0(%ebx),%eax
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   11e0e:	39 c7                	cmp    %eax,%edi
   11e10:	74 61                	je     11e73 <no_so_handler+0x93>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11e12:	8b 10                	mov    (%eax),%edx
   11e14:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11e1a:	8b 75 f0             	mov    -0x10(%ebp),%esi
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11e1d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   11e20:	89 55 e4             	mov    %edx,-0x1c(%ebp)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11e23:	0f b6 16             	movzbl (%esi),%edx
   11e26:	0f b6 76 01          	movzbl 0x1(%esi),%esi
   11e2a:	c0 ea 06             	shr    $0x6,%dl
   11e2d:	0f b6 d2             	movzbl %dl,%edx
   11e30:	c1 e6 02             	shl    $0x2,%esi
   11e33:	09 d6                	or     %edx,%esi
   11e35:	0f bf 50 f8          	movswl -0x8(%eax),%edx
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11e39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11e3c:	2d 9c 00 00 00       	sub    $0x9c,%eax
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11e41:	39 d6                	cmp    %edx,%esi
   11e43:	75 18                	jne    11e5d <no_so_handler+0x7d>
   11e45:	e9 e7 01 00 00       	jmp    12031 <no_so_handler+0x251>
   11e4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11e50:	0f bf 90 94 00 00 00 	movswl 0x94(%eax),%edx
   11e57:	39 f2                	cmp    %esi,%edx
   11e59:	74 25                	je     11e80 <no_so_handler+0xa0>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   11e5b:	89 c8                	mov    %ecx,%eax
   11e5d:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   11e63:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   11e69:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   11e6f:	39 d7                	cmp    %edx,%edi
   11e71:	75 dd                	jne    11e50 <no_so_handler+0x70>
				break;
			}
		}
	}
	FOUT;
}
   11e73:	83 c4 14             	add    $0x14,%esp
   11e76:	5b                   	pop    %ebx
   11e77:	5e                   	pop    %esi
   11e78:	5f                   	pop    %edi
   11e79:	5d                   	pop    %ebp
   11e7a:	c3                   	ret    
   11e7b:	90                   	nop
   11e7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
   11e80:	89 c6                	mov    %eax,%esi
			{
				*isPduFound = true;
   11e82:	8b 4d ec             	mov    -0x14(%ebp),%ecx
   11e85:	c6 01 01             	movb   $0x1,(%ecx)
				amTxedBuffer->segStart[0] = 0;
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11e88:	8b 06                	mov    (%esi),%eax
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
		{
			if( part2->NACK_SN == amTxedBuffer->SN )
			{
				*isPduFound = true;
				amTxedBuffer->segStart[0] = 0;
   11e8a:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;
   11e91:	8b 40 50             	mov    0x50(%eax),%eax
   11e94:	89 46 50             	mov    %eax,0x50(%esi)

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   11e97:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   11e9e:	66 83 f8 ff          	cmp    $0xffff,%ax
   11ea2:	0f 84 28 01 00 00    	je     11fd0 <no_so_handler+0x1f0>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   11ea8:	83 c0 01             	add    $0x1,%eax
   11eab:	66 89 86 96 00 00 00 	mov    %ax,0x96(%esi)
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
   11eb2:	c7 04 24 f0 40 00 00 	movl   $0x40f0,(%esp)
   11eb9:	e8 fc ff ff ff       	call   11eba <no_so_handler+0xda>
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   11ebe:	0f bf 96 96 00 00 00 	movswl 0x96(%esi),%edx
   11ec5:	0f b7 83 fa 22 00 00 	movzwl 0x22fa(%ebx),%eax
   11ecc:	39 c2                	cmp    %eax,%edx
   11ece:	74 18                	je     11ee8 <no_so_handler+0x108>
						}
					}
				}
				else
				{
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   11ed0:	c7 04 24 18 41 00 00 	movl   $0x4118,(%esp)
   11ed7:	e8 fc ff ff ff       	call   11ed8 <no_so_handler+0xf8>
				break;
			}
		}
	}
	FOUT;
}
   11edc:	83 c4 14             	add    $0x14,%esp
   11edf:	5b                   	pop    %ebx
   11ee0:	5e                   	pop    %esi
   11ee1:	5f                   	pop    %edi
   11ee2:	5d                   	pop    %ebp
   11ee3:	c3                   	ret    
   11ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				}
				//
				fsm_printf("[RLC][no_so_handler]find the NACK PDU \n");
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   11ee8:	b8 04 00 00 00       	mov    $0x4,%eax
   11eed:	e8 fc ff ff ff       	call   11eee <no_so_handler+0x10e>
					mioctrl->eventCode = 0;
   11ef2:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   11ef7:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
   11efb:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   11efe:	e8 fc ff ff ff       	call   11eff <no_so_handler+0x11f>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   11f03:	8b 06                	mov    (%esi),%eax
   11f05:	8b 40 50             	mov    0x50(%eax),%eax
   11f08:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
					amIns->amTransmittedBufferNum--;
   11f0e:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   11f15:	8b 06                	mov    (%esi),%eax
   11f17:	e8 fc ff ff ff       	call   11f18 <no_so_handler+0x138>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11f1c:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   11f22:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
					amTxedBuffer->pkt = NULL;
   11f28:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   11f2e:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   11f31:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   11f33:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   11f35:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   11f3c:	01 10 00 
	entry->prev = LIST_POISON2;
   11f3f:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   11f46:	02 20 00 
   11f49:	e8 fc ff ff ff       	call   11f4a <no_so_handler+0x16a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   11f4e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   11f54:	8d 93 9c 01 00 00    	lea    0x19c(%ebx),%edx
   11f5a:	39 c2                	cmp    %eax,%edx
   11f5c:	0f 84 11 ff ff ff    	je     11e73 <no_so_handler+0x93>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11f62:	8b 30                	mov    (%eax),%esi
   11f64:	8d b8 64 ff ff ff    	lea    -0x9c(%eax),%edi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11f6a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11f6d:	89 7d ec             	mov    %edi,-0x14(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11f70:	0f bf 40 f8          	movswl -0x8(%eax),%eax
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11f74:	89 75 e8             	mov    %esi,-0x18(%ebp)
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11f77:	0f b6 31             	movzbl (%ecx),%esi
   11f7a:	89 f1                	mov    %esi,%ecx
   11f7c:	c0 e9 06             	shr    $0x6,%cl
   11f7f:	89 ce                	mov    %ecx,%esi
   11f81:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   11f84:	81 e6 ff 00 00 00    	and    $0xff,%esi
   11f8a:	0f b6 79 01          	movzbl 0x1(%ecx),%edi
   11f8e:	c1 e7 02             	shl    $0x2,%edi
   11f91:	09 f7                	or     %esi,%edi
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11f93:	8b 75 e8             	mov    -0x18(%ebp),%esi
   11f96:	81 ee 9c 00 00 00    	sub    $0x9c,%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
   11f9c:	39 f8                	cmp    %edi,%eax
   11f9e:	75 15                	jne    11fb5 <no_so_handler+0x1d5>
   11fa0:	eb 3c                	jmp    11fde <no_so_handler+0x1fe>
   11fa2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   11fa8:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   11faf:	39 f8                	cmp    %edi,%eax
   11fb1:	74 2e                	je     11fe1 <no_so_handler+0x201>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11fb3:	89 ce                	mov    %ecx,%esi
   11fb5:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
   11fbb:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   11fc1:	8d 86 9c 00 00 00    	lea    0x9c(%esi),%eax
   11fc7:	39 c2                	cmp    %eax,%edx
   11fc9:	75 dd                	jne    11fa8 <no_so_handler+0x1c8>
   11fcb:	e9 a3 fe ff ff       	jmp    11e73 <no_so_handler+0x93>
				amTxedBuffer->segEnd[0] = amTxedBuffer->pkt->len;

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   11fd0:	66 c7 86 96 00 00 00 	movw   $0x0,0x96(%esi)
   11fd7:	00 00 
   11fd9:	e9 d4 fe ff ff       	jmp    11eb2 <no_so_handler+0xd2>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   11fde:	8b 75 ec             	mov    -0x14(%ebp),%esi
						{
							if( amRetxBf->SN == part2->NACK_SN )
							{
								amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   11fe1:	8b 06                	mov    (%esi),%eax
   11fe3:	8b 40 50             	mov    0x50(%eax),%eax
   11fe6:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
								amIns->amRetxBufferNum--;
   11fec:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
								fsm_pkt_destroy( amRetxBf->pkt );
   11ff3:	8b 06                	mov    (%esi),%eax
   11ff5:	e8 fc ff ff ff       	call   11ff6 <no_so_handler+0x216>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   11ffa:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
   12000:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
								amRetxBf->pkt = NULL;
   12006:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1200c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1200f:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   12011:	89 f0                	mov    %esi,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12013:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   1201a:	01 10 00 
	entry->prev = LIST_POISON2;
   1201d:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   12024:	02 20 00 
   12027:	e8 fc ff ff ff       	call   12028 <no_so_handler+0x248>
								amRetxBf = NULL;
								break;
   1202c:	e9 42 fe ff ff       	jmp    11e73 <no_so_handler+0x93>
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to no_so_handler\n");
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12031:	89 ce                	mov    %ecx,%esi
   12033:	e9 4a fe ff ff       	jmp    11e82 <no_so_handler+0xa2>
   12038:	90                   	nop
   12039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

00012040 <rlc_ctrl_pkt_recv>:
**Modified by:
**Modified Date:
************************************************************************/

void rlc_ctrl_pkt_recv(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   12040:	55                   	push   %ebp
   12041:	89 e5                	mov    %esp,%ebp
   12043:	56                   	push   %esi
   12044:	53                   	push   %ebx
   12045:	83 ec 08             	sub    $0x8,%esp
   12048:	e8 fc ff ff ff       	call   12049 <rlc_ctrl_pkt_recv+0x9>
   1204d:	89 d6                	mov    %edx,%esi
	u32 pduLen=0;
	u8 E1=0;
	bool isPduFound = false;

	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
   1204f:	c7 04 24 44 41 00 00 	movl   $0x4144,(%esp)
   12056:	e8 fc ff ff ff       	call   12057 <rlc_ctrl_pkt_recv+0x17>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
   1205b:	8b 46 50             	mov    0x50(%esi),%eax
   1205e:	c7 04 24 84 41 00 00 	movl   $0x4184,(%esp)
   12065:	89 44 24 04          	mov    %eax,0x4(%esp)
   12069:	e8 fc ff ff ff       	call   1206a <rlc_ctrl_pkt_recv+0x2a>
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   1206e:	b8 02 00 00 00       	mov    $0x2,%eax
   12073:	e8 fc ff ff ff       	call   12074 <rlc_ctrl_pkt_recv+0x34>
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   12078:	b9 02 00 00 00       	mov    $0x2,%ecx
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
	memset(part1,0,sizeof(ctrlPduPart1));
   1207d:	66 c7 00 00 00       	movw   $0x0,(%eax)
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   12082:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	FIN(rlc_ctrl_pkt_recv());
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] entering rlc_ctrl_pkt_recv() function\n");
	fsm_printf("[RLC][rlc_ctrl_pkt_recv]  (pkt->len is %d)\n", pkt->len);
	
	pduLen = pkt->len;
	part1 = (ctrlPduPart1 *)fsm_mem_alloc(sizeof(ctrlPduPart1));
   12088:	89 c3                	mov    %eax,%ebx
	memset(part1,0,sizeof(ctrlPduPart1));
	fsm_mem_cpy(part1,pkt->data,2);//PKT
   1208a:	e8 fc ff ff ff       	call   1208b <rlc_ctrl_pkt_recv+0x4b>
	fsm_skb_pull(pkt,2);
   1208f:	ba 02 00 00 00       	mov    $0x2,%edx
   12094:	89 f0                	mov    %esi,%eax
   12096:	e8 fc ff ff ff       	call   12097 <rlc_ctrl_pkt_recv+0x57>
	*(u16 *)part1 = ntohs(*(u16 *)part1);
	pduLen -= 2;
	fsm_octets_print(part1,2);
   1209b:	ba 02 00 00 00       	mov    $0x2,%edx
   120a0:	89 d8                	mov    %ebx,%eax
   120a2:	66 c1 03 08          	rolw   $0x8,(%ebx)
   120a6:	e8 fc ff ff ff       	call   120a7 <rlc_ctrl_pkt_recv+0x67>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->E1 is %d)\n",part1->E1);	
   120ab:	0f b6 03             	movzbl (%ebx),%eax
   120ae:	d0 e8                	shr    %al
   120b0:	83 e0 01             	and    $0x1,%eax
   120b3:	89 44 24 04          	mov    %eax,0x4(%esp)
   120b7:	c7 04 24 b0 41 00 00 	movl   $0x41b0,(%esp)
   120be:	e8 fc ff ff ff       	call   120bf <rlc_ctrl_pkt_recv+0x7f>
	fsm_printf("[RLC][rlc_ctrl_pkt_recv] (part1->acksn is %d)\n",part1->ACK_SN);
   120c3:	0f b6 03             	movzbl (%ebx),%eax
   120c6:	c0 e8 02             	shr    $0x2,%al
   120c9:	0f b6 d0             	movzbl %al,%edx
   120cc:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
   120d0:	c7 04 24 dc 41 00 00 	movl   $0x41dc,(%esp)
   120d7:	83 e0 0f             	and    $0xf,%eax
   120da:	c1 e0 06             	shl    $0x6,%eax
   120dd:	09 d0                	or     %edx,%eax
   120df:	89 44 24 04          	mov    %eax,0x4(%esp)
   120e3:	e8 fc ff ff ff       	call   120e4 <rlc_ctrl_pkt_recv+0xa4>
		{
			fsm_mem_free(part3);
			part3=NULL;
		}
	}
}
   120e8:	83 c4 08             	add    $0x8,%esp
   120eb:	5b                   	pop    %ebx
   120ec:	5e                   	pop    %esi
   120ed:	5d                   	pop    %ebp
   120ee:	c3                   	ret    
   120ef:	90                   	nop

000120f0 <rlc_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_retx(struct AM_Instance *amIns,struct AmBuffer *amTxedBuffer)
{
   120f0:	55                   	push   %ebp
   120f1:	89 e5                	mov    %esp,%ebp
   120f3:	57                   	push   %edi
   120f4:	56                   	push   %esi
   120f5:	53                   	push   %ebx
   120f6:	83 ec 10             	sub    $0x10,%esp
   120f9:	e8 fc ff ff ff       	call   120fa <rlc_retx+0xa>
   120fe:	89 c3                	mov    %eax,%ebx
   12100:	89 d6                	mov    %edx,%esi
	struct AmBuffer *amRetxBf;
	struct AmBuffer *nposBf;
	int i;

	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
   12102:	c7 04 24 0c 42 00 00 	movl   $0x420c,(%esp)
   12109:	e8 fc ff ff ff       	call   1210a <rlc_retx+0x1a>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   1210e:	8b 83 9c 01 00 00    	mov    0x19c(%ebx),%eax
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
   12114:	8d 8b 9c 01 00 00    	lea    0x19c(%ebx),%ecx
   1211a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1211d:	39 c1                	cmp    %eax,%ecx
   1211f:	74 5a                	je     1217b <rlc_retx+0x8b>
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12121:	8b 38                	mov    (%eax),%edi
   12123:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   12129:	0f b7 8e 94 00 00 00 	movzwl 0x94(%esi),%ecx
   12130:	0f b7 40 f8          	movzwl -0x8(%eax),%eax
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12134:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
   1213a:	66 39 c8             	cmp    %cx,%ax
   1213d:	0f 84 a2 02 00 00    	je     123e5 <rlc_retx+0x2f5>
   12143:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12146:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   12149:	eb 17                	jmp    12162 <rlc_retx+0x72>
   1214b:	90                   	nop
   1214c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12150:	0f b7 87 94 00 00 00 	movzwl 0x94(%edi),%eax
   12157:	66 39 c8             	cmp    %cx,%ax
   1215a:	0f 84 b8 01 00 00    	je     12318 <rlc_retx+0x228>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12160:	89 d7                	mov    %edx,%edi
   12162:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
   12168:	8d 87 9c 00 00 00    	lea    0x9c(%edi),%eax
   1216e:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12174:	39 c3                	cmp    %eax,%ebx
   12176:	75 d8                	jne    12150 <rlc_retx+0x60>
   12178:	8b 5d ec             	mov    -0x14(%ebp),%ebx
		}
		//nposBf = NULL;
	}

	//
	amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   1217b:	8b 06                	mov    (%esi),%eax
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
   1217d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   12180:	8b 40 50             	mov    0x50(%eax),%eax
   12183:	29 83 f8 00 00 00    	sub    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum--;
   12189:	83 ab fc 00 00 00 01 	subl   $0x1,0xfc(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12190:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
   12196:	8b 86 a0 00 00 00    	mov    0xa0(%esi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   1219c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1219f:	89 10                	mov    %edx,(%eax)
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
   121a1:	8d 96 9c 00 00 00    	lea    0x9c(%esi),%edx
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   121a7:	c7 86 9c 00 00 00 00 	movl   $0x100100,0x9c(%esi)
   121ae:	01 10 00 
	entry->prev = LIST_POISON2;
   121b1:	c7 86 a0 00 00 00 00 	movl   $0x200200,0xa0(%esi)
   121b8:	02 20 00 
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   121bb:	8b 83 a0 01 00 00    	mov    0x1a0(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   121c1:	89 93 a0 01 00 00    	mov    %edx,0x1a0(%ebx)
	new->next = next;
   121c7:	89 8e 9c 00 00 00    	mov    %ecx,0x9c(%esi)
	new->prev = prev;
   121cd:	89 86 a0 00 00 00    	mov    %eax,0xa0(%esi)
	prev->next = new;
   121d3:	89 10                	mov    %edx,(%eax)
	if( amTxedBuffer->pktstatus != FULL_SDU )
   121d5:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
   121d9:	0f 84 e9 01 00 00    	je     123c8 <rlc_retx+0x2d8>
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   121df:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   121e5:	8b 93 a4 01 00 00    	mov    0x1a4(%ebx),%edx
   121eb:	85 c0                	test   %eax,%eax
   121ed:	74 29                	je     12218 <rlc_retx+0x128>
   121ef:	31 c0                	xor    %eax,%eax
   121f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		{
			if( amTxedBuffer->segStart[i] != -1 )
   121f8:	8b 4c 86 10          	mov    0x10(%esi,%eax,4),%ecx
   121fc:	83 f9 ff             	cmp    $0xffffffff,%ecx
   121ff:	74 0c                	je     1220d <rlc_retx+0x11d>
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
   12201:	29 ca                	sub    %ecx,%edx
   12203:	03 54 86 50          	add    0x50(%esi,%eax,4),%edx
   12207:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	amIns->amTransmittedBufferNum--;
	list_del(&amTxedBuffer->list);
	list_add_tail(&amTxedBuffer->list,&amIns->amRetxBuffer.list);
	if( amTxedBuffer->pktstatus != FULL_SDU )
	{
		for( i = 0; i < amTxedBuffer->segnum; i++)
   1220d:	83 c0 01             	add    $0x1,%eax
   12210:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   12216:	72 e0                	jb     121f8 <rlc_retx+0x108>
			if( amTxedBuffer->segStart[i] != -1 )
			{
				amIns->amRetxBufferSize += amTxedBuffer->segEnd[i] - amTxedBuffer->segStart[i];
			}
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
   12218:	03 56 0c             	add    0xc(%esi),%edx
   1221b:	89 93 a4 01 00 00    	mov    %edx,0x1a4(%ebx)
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
	}
	amIns->amRetxBufferNum++;
   12221:	83 83 a8 01 00 00 01 	addl   $0x1,0x1a8(%ebx)
	fsm_printf("[RLC][rlc_retx] has move to RetxBuffer,%d\n",amTxedBuffer->SN);
   12228:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   1222f:	c7 04 24 70 42 00 00 	movl   $0x4270,(%esp)
   12236:	89 44 24 04          	mov    %eax,0x4(%esp)
   1223a:	e8 fc ff ff ff       	call   1223b <rlc_retx+0x14b>
	//
	amTxedBf = (struct AmBuffer *)fsm_mem_alloc(sizeof(struct AmBuffer));
   1223f:	b8 a4 00 00 00       	mov    $0xa4,%eax
   12244:	e8 fc ff ff ff       	call   12245 <rlc_retx+0x155>
   12249:	89 c7                	mov    %eax,%edi
	//amTxedBf->pkt = fsm_pkt_create(amTxedBuffer->pkt->len+fsm_skb_headroom(amTxedBuffer->pkt));
	amTxedBf->pkt = fsm_pkt_duplicate(amTxedBuffer->pkt);
   1224b:	8b 06                	mov    (%esi),%eax
   1224d:	e8 fc ff ff ff       	call   1224e <rlc_retx+0x15e>
   12252:	89 07                	mov    %eax,(%edi)
	//fsm_mem_cpy(amTxedBf->pkt->data,amTxedBuffer->pkt->data,amTxedBuffer->pkt->len);
	//fsm_skb_put(amTxedBf->pkt,amTxedBuffer->pkt->len);
	amTxedBf->datalen = amTxedBuffer->datalen;
   12254:	8b 86 98 00 00 00    	mov    0x98(%esi),%eax
   1225a:	89 87 98 00 00 00    	mov    %eax,0x98(%edi)
	amTxedBf->headLen = amTxedBuffer->headLen;
   12260:	8b 46 0c             	mov    0xc(%esi),%eax
   12263:	89 47 0c             	mov    %eax,0xc(%edi)
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
   12266:	8b 46 04             	mov    0x4(%esi),%eax
   12269:	89 47 04             	mov    %eax,0x4(%edi)
	amTxedBf->pos = amTxedBuffer->pos;
   1226c:	8b 46 08             	mov    0x8(%esi),%eax
   1226f:	89 47 08             	mov    %eax,0x8(%edi)
	amTxedBf->retxCount = amTxedBuffer->retxCount;
   12272:	0f b7 86 96 00 00 00 	movzwl 0x96(%esi),%eax
   12279:	66 89 87 96 00 00 00 	mov    %ax,0x96(%edi)
	amTxedBf->segnum = amTxedBuffer->segnum;
   12280:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12286:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
	for( i = 0;i < amTxedBuffer->segnum; i++)
   1228c:	8b 86 90 00 00 00    	mov    0x90(%esi),%eax
   12292:	85 c0                	test   %eax,%eax
   12294:	74 1d                	je     122b3 <rlc_retx+0x1c3>
   12296:	31 c0                	xor    %eax,%eax
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
   12298:	8b 54 86 10          	mov    0x10(%esi,%eax,4),%edx
   1229c:	89 54 87 10          	mov    %edx,0x10(%edi,%eax,4)
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
   122a0:	8b 54 86 50          	mov    0x50(%esi,%eax,4),%edx
   122a4:	89 54 87 50          	mov    %edx,0x50(%edi,%eax,4)
	amTxedBf->headLen = amTxedBuffer->headLen;
	amTxedBf->pktstatus = amTxedBuffer->pktstatus;
	amTxedBf->pos = amTxedBuffer->pos;
	amTxedBf->retxCount = amTxedBuffer->retxCount;
	amTxedBf->segnum = amTxedBuffer->segnum;
	for( i = 0;i < amTxedBuffer->segnum; i++)
   122a8:	83 c0 01             	add    $0x1,%eax
   122ab:	3b 86 90 00 00 00    	cmp    0x90(%esi),%eax
   122b1:	72 e5                	jb     12298 <rlc_retx+0x1a8>
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   122b3:	0f b7 86 94 00 00 00 	movzwl 0x94(%esi),%eax
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   122ba:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   122c0:	8d 8b f0 00 00 00    	lea    0xf0(%ebx),%ecx
	for( i = 0;i < amTxedBuffer->segnum; i++)
	{
		amTxedBf->segStart[i] = amTxedBuffer->segStart[i];
		amTxedBf->segEnd[i] = amTxedBuffer->segEnd[i];
	}
	amTxedBf->SN = amTxedBuffer->SN;
   122c6:	66 89 87 94 00 00 00 	mov    %ax,0x94(%edi)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
   122cd:	8b 83 f4 00 00 00    	mov    0xf4(%ebx),%eax
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
   122d3:	89 93 f4 00 00 00    	mov    %edx,0xf4(%ebx)
	list_add_tail(&amTxedBf->list,&amIns->amTransmittedBuffer.list);
   122d9:	89 8f 9c 00 00 00    	mov    %ecx,0x9c(%edi)
	new->next = next;
	new->prev = prev;
   122df:	89 87 a0 00 00 00    	mov    %eax,0xa0(%edi)
	prev->next = new;
   122e5:	89 10                	mov    %edx,(%eax)
	amIns->amTransmittedBufferSize += amTxedBf->pkt->len;
   122e7:	8b 07                	mov    (%edi),%eax
   122e9:	8b 40 50             	mov    0x50(%eax),%eax
   122ec:	01 83 f8 00 00 00    	add    %eax,0xf8(%ebx)
	amIns->amTransmittedBufferNum++;
   122f2:	83 83 fc 00 00 00 01 	addl   $0x1,0xfc(%ebx)
	fsm_printf("[RLC][rlc_retx] has copy to amTxedBuffer,%d\n",amTxedBuffer->SN);
   122f9:	0f bf 86 94 00 00 00 	movswl 0x94(%esi),%eax
   12300:	c7 04 24 9c 42 00 00 	movl   $0x429c,(%esp)
   12307:	89 44 24 04          	mov    %eax,0x4(%esp)
   1230b:	e8 fc ff ff ff       	call   1230c <rlc_retx+0x21c>
	FOUT;
}
   12310:	83 c4 10             	add    $0x10,%esp
   12313:	5b                   	pop    %ebx
   12314:	5e                   	pop    %esi
   12315:	5f                   	pop    %edi
   12316:	5d                   	pop    %ebp
   12317:	c3                   	ret    
   12318:	8b 5d ec             	mov    -0x14(%ebp),%ebx
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
		{
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
   1231b:	98                   	cwtl   
   1231c:	89 44 24 04          	mov    %eax,0x4(%esp)
   12320:	c7 04 24 3c 42 00 00 	movl   $0x423c,(%esp)
   12327:	e8 fc ff ff ff       	call   12328 <rlc_retx+0x238>
				if( amRetxBf->pktstatus != FULL_SDU )
   1232c:	83 7f 04 01          	cmpl   $0x1,0x4(%edi)
   12330:	0f 84 a2 00 00 00    	je     123d8 <rlc_retx+0x2e8>
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   12336:	8b 87 90 00 00 00    	mov    0x90(%edi),%eax
   1233c:	8b 8b a4 01 00 00    	mov    0x1a4(%ebx),%ecx
   12342:	85 c0                	test   %eax,%eax
   12344:	74 22                	je     12368 <rlc_retx+0x278>
   12346:	31 c0                	xor    %eax,%eax
					{
						if( amRetxBf->segStart[i] != -1 )
   12348:	8b 54 87 10          	mov    0x10(%edi,%eax,4),%edx
   1234c:	83 fa ff             	cmp    $0xffffffff,%edx
   1234f:	74 0c                	je     1235d <rlc_retx+0x26d>
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12351:	2b 54 87 50          	sub    0x50(%edi,%eax,4),%edx
   12355:	01 d1                	add    %edx,%ecx
   12357:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
			if( amRetxBf->SN == amTxedBuffer->SN )
			{
				fsm_printf("[RLC][rlc_retx] has found the pdu %d in RetxBuffer\n",amRetxBf->SN);
				if( amRetxBf->pktstatus != FULL_SDU )
				{
					for( i = 0; i < amRetxBf->segnum; i++)
   1235d:	83 c0 01             	add    $0x1,%eax
   12360:	3b 87 90 00 00 00    	cmp    0x90(%edi),%eax
   12366:	72 e0                	jb     12348 <rlc_retx+0x258>
						if( amRetxBf->segStart[i] != -1 )
						{
							amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
						}
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
   12368:	2b 4f 0c             	sub    0xc(%edi),%ecx
   1236b:	89 8b a4 01 00 00    	mov    %ecx,0x1a4(%ebx)
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
				}
				amIns->amRetxBufferNum--;
   12371:	83 ab a8 01 00 00 01 	subl   $0x1,0x1a8(%ebx)
				if(amRetxBf->pkt != NULL)
   12378:	8b 07                	mov    (%edi),%eax
   1237a:	85 c0                	test   %eax,%eax
   1237c:	74 0b                	je     12389 <rlc_retx+0x299>
				{
					fsm_pkt_destroy( amRetxBf->pkt );
   1237e:	e8 fc ff ff ff       	call   1237f <rlc_retx+0x28f>
					amRetxBf->pkt = NULL;
   12383:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12389:	8b 97 9c 00 00 00    	mov    0x9c(%edi),%edx
				}
				list_del(&amRetxBf->list);
				if(amRetxBf != NULL)
   1238f:	85 ff                	test   %edi,%edi
   12391:	8b 87 a0 00 00 00    	mov    0xa0(%edi),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12397:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1239a:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1239c:	c7 87 9c 00 00 00 00 	movl   $0x100100,0x9c(%edi)
   123a3:	01 10 00 
	entry->prev = LIST_POISON2;
   123a6:	c7 87 a0 00 00 00 00 	movl   $0x200200,0xa0(%edi)
   123ad:	02 20 00 
   123b0:	0f 84 c5 fd ff ff    	je     1217b <rlc_retx+0x8b>
				{
					fsm_mem_free(amRetxBf);
   123b6:	89 f8                	mov    %edi,%eax
   123b8:	e8 fc ff ff ff       	call   123b9 <rlc_retx+0x2c9>
   123bd:	e9 b9 fd ff ff       	jmp    1217b <rlc_retx+0x8b>
   123c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		}
		amIns->amRetxBufferSize += amTxedBuffer->headLen;
	}
	else
	{
		amIns->amRetxBufferSize += amTxedBuffer->pkt->len;
   123c8:	8b 06                	mov    (%esi),%eax
   123ca:	8b 40 50             	mov    0x50(%eax),%eax
   123cd:	01 83 a4 01 00 00    	add    %eax,0x1a4(%ebx)
   123d3:	e9 49 fe ff ff       	jmp    12221 <rlc_retx+0x131>
					}
					amIns->amRetxBufferSize -= amRetxBf->headLen;
				}
				else
				{
					amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   123d8:	8b 07                	mov    (%edi),%eax
   123da:	8b 40 50             	mov    0x50(%eax),%eax
   123dd:	29 83 a4 01 00 00    	sub    %eax,0x1a4(%ebx)
   123e3:	eb 8c                	jmp    12371 <rlc_retx+0x281>
	FIN(rlc_retx());
	fsm_printf("[RLC][rlc_retx] entering rlc_retx() function\n");
	//PDU
	if( !list_empty(&amIns->amRetxBuffer.list) )
	{
		list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   123e5:	89 d7                	mov    %edx,%edi
   123e7:	e9 2f ff ff ff       	jmp    1231b <rlc_retx+0x22b>
   123ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

000123f0 <so_handler>:
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   123f0:	55                   	push   %ebp
   123f1:	89 e5                	mov    %esp,%ebp
   123f3:	57                   	push   %edi
   123f4:	56                   	push   %esi
   123f5:	53                   	push   %ebx
   123f6:	83 ec 20             	sub    $0x20,%esp
   123f9:	e8 fc ff ff ff       	call   123fa <so_handler+0xa>
   123fe:	0f b7 75 08          	movzwl 0x8(%ebp),%esi
   12402:	89 45 e8             	mov    %eax,-0x18(%ebp)
   12405:	89 cf                	mov    %ecx,%edi
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12407:	89 c1                	mov    %eax,%ecx
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12409:	8b 80 f0 00 00 00    	mov    0xf0(%eax),%eax
   1240f:	81 c1 f0 00 00 00    	add    $0xf0,%ecx
**Modified Date:
**********************************************************************************************/


void so_handler(struct AM_Instance *amIns, ctrlPduPart3 *part3, bool *isPduFound,SequenceNumber nackSn)
{
   12415:	89 55 ec             	mov    %edx,-0x14(%ebp)
	struct AmBuffer * nposBf;
	struct AmBuffer * reposBf;
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   12418:	39 c1                	cmp    %eax,%ecx
   1241a:	74 3d                	je     12459 <so_handler+0x69>
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   1241c:	8b 18                	mov    (%eax),%ebx
   1241e:	8d 90 64 ff ff ff    	lea    -0x9c(%eax),%edx
   12424:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
		{
			if( nackSn == amTxedBuffer->SN )
   1242a:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   1242e:	75 13                	jne    12443 <so_handler+0x53>
   12430:	eb 2f                	jmp    12461 <so_handler+0x71>
   12432:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
   12438:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   1243f:	74 27                	je     12468 <so_handler+0x78>
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12441:	89 d3                	mov    %edx,%ebx
   12443:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   12449:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   1244f:	81 ea 9c 00 00 00    	sub    $0x9c,%edx
   12455:	39 c1                	cmp    %eax,%ecx
   12457:	75 df                	jne    12438 <so_handler+0x48>
				break;
			}
		}
	}
	FOUT;
}
   12459:	83 c4 20             	add    $0x20,%esp
   1245c:	5b                   	pop    %ebx
   1245d:	5e                   	pop    %esi
   1245e:	5f                   	pop    %edi
   1245f:	5d                   	pop    %ebp
   12460:	c3                   	ret    
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		list_for_each_entry_safe(amTxedBuffer, nposBf, &amIns->amTransmittedBuffer.list,list)
   12461:	89 d3                	mov    %edx,%ebx
   12463:	90                   	nop
   12464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		{
			if( nackSn == amTxedBuffer->SN )
			{
				*isPduFound = true;
   12468:	c6 07 01             	movb   $0x1,(%edi)
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
   1246b:	0f bf c6             	movswl %si,%eax
   1246e:	89 44 24 04          	mov    %eax,0x4(%esp)
   12472:	c7 04 24 cc 42 00 00 	movl   $0x42cc,(%esp)
   12479:	e8 fc ff ff ff       	call   1247a <so_handler+0x8a>
				for( i = 0; i < amTxedBuffer->segnum; i++ )
   1247e:	8b 8b 90 00 00 00    	mov    0x90(%ebx),%ecx
   12484:	85 c9                	test   %ecx,%ecx
   12486:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   12489:	0f 84 d1 01 00 00    	je     12660 <so_handler+0x270>
   1248f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12492:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   12496:	0f b6 7a 03          	movzbl 0x3(%edx),%edi
   1249a:	31 d2                	xor    %edx,%edx
   1249c:	66 89 75 e6          	mov    %si,-0x1a(%ebp)
   124a0:	89 d6                	mov    %edx,%esi
   124a2:	d0 e8                	shr    %al
   124a4:	0f b6 c0             	movzbl %al,%eax
   124a7:	c1 e7 07             	shl    $0x7,%edi
   124aa:	09 c7                	or     %eax,%edi
   124ac:	31 c0                	xor    %eax,%eax
   124ae:	89 7d dc             	mov    %edi,-0x24(%ebp)
   124b1:	eb 0f                	jmp    124c2 <so_handler+0xd2>
   124b3:	90                   	nop
   124b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   124b8:	83 c0 01             	add    $0x1,%eax
   124bb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   124be:	89 c6                	mov    %eax,%esi
   124c0:	74 5e                	je     12520 <so_handler+0x130>
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
   124c2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   124c5:	39 4c 83 10          	cmp    %ecx,0x10(%ebx,%eax,4)
   124c9:	75 ed                	jne    124b8 <so_handler+0xc8>
   124cb:	8b 7d ec             	mov    -0x14(%ebp),%edi
   124ce:	0f b6 17             	movzbl (%edi),%edx
   124d1:	c0 ea 02             	shr    $0x2,%dl
   124d4:	0f b6 fa             	movzbl %dl,%edi
   124d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   124da:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
   124de:	0f b6 52 02          	movzbl 0x2(%edx),%edx
   124e2:	c1 e1 06             	shl    $0x6,%ecx
   124e5:	83 e2 01             	and    $0x1,%edx
   124e8:	09 f9                	or     %edi,%ecx
   124ea:	c1 e2 0e             	shl    $0xe,%edx
   124ed:	09 ca                	or     %ecx,%edx
   124ef:	39 54 83 50          	cmp    %edx,0x50(%ebx,%eax,4)
   124f3:	75 c3                	jne    124b8 <so_handler+0xc8>
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   124f5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   124f8:	89 f2                	mov    %esi,%edx
   124fa:	89 55 e0             	mov    %edx,-0x20(%ebp)
   124fd:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12501:	c7 04 24 04 43 00 00 	movl   $0x4304,(%esp)
   12508:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   1250c:	e8 fc ff ff ff       	call   1250d <so_handler+0x11d>
   12511:	8b bb 90 00 00 00    	mov    0x90(%ebx),%edi
						break;
   12517:	8b 55 e0             	mov    -0x20(%ebp),%edx
				fsm_printf("[RLC][so_handler] has found pdu %d from amTxedBuffer\n",nackSn);
				for( i = 0; i < amTxedBuffer->segnum; i++ )
				{
					if(amTxedBuffer->segStart[i]==part3->SOstart&&amTxedBuffer->segEnd[i]==part3->SOend)
					{
						fsm_printf("[RLC][so_handler] has found segum %d from amTxedBuffer\n",amTxedBuffer->segnum);
   1251a:	89 7d f0             	mov    %edi,-0x10(%ebp)
						break;
   1251d:	eb 07                	jmp    12526 <so_handler+0x136>
   1251f:	90                   	nop
   12520:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
   12524:	89 c2                	mov    %eax,%edx
					}
				}
				if( i == amTxedBuffer->segnum )
   12526:	3b 55 f0             	cmp    -0x10(%ebp),%edx
   12529:	0f 84 31 01 00 00    	je     12660 <so_handler+0x270>
					amTxedBuffer->segnum++;
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
   1252f:	0f b7 83 96 00 00 00 	movzwl 0x96(%ebx),%eax
   12536:	66 83 f8 ff          	cmp    $0xffff,%ax
   1253a:	0f 84 10 01 00 00    	je     12650 <so_handler+0x260>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   12540:	83 c0 01             	add    $0x1,%eax
   12543:	66 89 83 96 00 00 00 	mov    %ax,0x96(%ebx)
   1254a:	98                   	cwtl   
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   1254b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1254e:	0f b7 91 fa 22 00 00 	movzwl 0x22fa(%ecx),%edx
   12555:	39 c2                	cmp    %eax,%edx
   12557:	74 1f                	je     12578 <so_handler+0x188>
						}
					}
				}
				else
				{
					rlc_retx(amIns,amTxedBuffer);
   12559:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1255c:	89 da                	mov    %ebx,%edx
   1255e:	e8 fc ff ff ff       	call   1255f <so_handler+0x16f>
					fsm_printf("[RLC][rlc_ctrl_pkt_recv] run to rlc_retx()\n");
   12563:	c7 04 24 18 41 00 00 	movl   $0x4118,(%esp)
   1256a:	e8 fc ff ff ff       	call   1256b <so_handler+0x17b>
				break;
			}
		}
	}
	FOUT;
}
   1256f:	83 c4 20             	add    $0x20,%esp
   12572:	5b                   	pop    %ebx
   12573:	5e                   	pop    %esi
   12574:	5f                   	pop    %edi
   12575:	5d                   	pop    %ebp
   12576:	c3                   	ret    
   12577:	90                   	nop
					amTxedBuffer->retxCount++;
				}
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
   12578:	c7 04 24 64 43 00 00 	movl   $0x4364,(%esp)
   1257f:	e8 fc ff ff ff       	call   12580 <so_handler+0x190>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   12584:	b8 04 00 00 00       	mov    $0x4,%eax
   12589:	e8 fc ff ff ff       	call   1258a <so_handler+0x19a>
					mioctrl->eventCode = 0;
					mioctrl->rbIdentity = amIns->rbId;
   1258e:	8b 7d e8             	mov    -0x18(%ebp),%edi
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
				{
					fsm_printf("[RLC][so_handler] the number of retx is already the max\n");
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
					mioctrl->eventCode = 0;
   12591:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12596:	0f b6 57 02          	movzbl 0x2(%edi),%edx
   1259a:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   1259d:	e8 fc ff ff ff       	call   1259e <so_handler+0x1ae>
					mioctrl = NULL;
					//PDU
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   125a2:	8b 03                	mov    (%ebx),%eax
   125a4:	8b 40 50             	mov    0x50(%eax),%eax
   125a7:	29 87 f8 00 00 00    	sub    %eax,0xf8(%edi)
					amIns->amTransmittedBufferNum--;
   125ad:	83 af fc 00 00 00 01 	subl   $0x1,0xfc(%edi)
					fsm_pkt_destroy( amTxedBuffer->pkt );
   125b4:	8b 03                	mov    (%ebx),%eax
   125b6:	e8 fc ff ff ff       	call   125b7 <so_handler+0x1c7>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   125bb:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
   125c1:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
					amTxedBuffer->pkt = NULL;
   125c7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   125cd:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   125d0:	89 10                	mov    %edx,(%eax)
					list_del(&amTxedBuffer->list);
					fsm_mem_free(amTxedBuffer);
   125d2:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   125d4:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   125db:	01 10 00 
	entry->prev = LIST_POISON2;
   125de:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   125e5:	02 20 00 
   125e8:	e8 fc ff ff ff       	call   125e9 <so_handler+0x1f9>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   125ed:	8b 87 9c 01 00 00    	mov    0x19c(%edi),%eax
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   125f3:	89 fa                	mov    %edi,%edx
   125f5:	81 c2 9c 01 00 00    	add    $0x19c,%edx
   125fb:	39 c2                	cmp    %eax,%edx
   125fd:	0f 84 56 fe ff ff    	je     12459 <so_handler+0x69>
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   12603:	8b 18                	mov    (%eax),%ebx
   12605:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1260b:	81 eb 9c 00 00 00    	sub    $0x9c,%ebx
						{
							if( amRetxBf->SN == nackSn)
   12611:	66 39 70 f8          	cmp    %si,-0x8(%eax)
   12615:	75 18                	jne    1262f <so_handler+0x23f>
   12617:	e9 b6 00 00 00       	jmp    126d2 <so_handler+0x2e2>
   1261c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
   12620:	66 39 b3 94 00 00 00 	cmp    %si,0x94(%ebx)
   12627:	0f 84 a7 00 00 00    	je     126d4 <so_handler+0x2e4>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   1262d:	89 cb                	mov    %ecx,%ebx
   1262f:	8b 83 9c 00 00 00    	mov    0x9c(%ebx),%eax
   12635:	8d 88 64 ff ff ff    	lea    -0x9c(%eax),%ecx
   1263b:	8d 83 9c 00 00 00    	lea    0x9c(%ebx),%eax
   12641:	39 c2                	cmp    %eax,%edx
   12643:	75 db                	jne    12620 <so_handler+0x230>
   12645:	e9 0f fe ff ff       	jmp    12459 <so_handler+0x69>
   1264a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				}

				//retxCount
				if( amTxedBuffer->retxCount == -1 )   //
				{
					amTxedBuffer->retxCount = 0;
   12650:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   12657:	00 00 
   12659:	31 c0                	xor    %eax,%eax
   1265b:	e9 eb fe ff ff       	jmp    1254b <so_handler+0x15b>
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12660:	8b 45 ec             	mov    -0x14(%ebp),%eax
					if(part3->SOend  == 0x7fff ) //
   12663:	8b 4d ec             	mov    -0x14(%ebp),%ecx
						break;
					}
				}
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
   12666:	0f b6 50 02          	movzbl 0x2(%eax),%edx
   1266a:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1266e:	d0 ea                	shr    %dl
   12670:	0f b6 d2             	movzbl %dl,%edx
   12673:	c1 e0 07             	shl    $0x7,%eax
   12676:	09 d0                	or     %edx,%eax
   12678:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1267b:	89 44 93 10          	mov    %eax,0x10(%ebx,%edx,4)
					if(part3->SOend  == 0x7fff ) //
   1267f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12682:	0f b6 02             	movzbl (%edx),%eax
   12685:	0f b6 52 01          	movzbl 0x1(%edx),%edx
   12689:	c0 e8 02             	shr    $0x2,%al
   1268c:	0f b6 c0             	movzbl %al,%eax
   1268f:	c1 e2 06             	shl    $0x6,%edx
   12692:	09 c2                	or     %eax,%edx
   12694:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
   12698:	83 e0 01             	and    $0x1,%eax
   1269b:	c1 e0 0e             	shl    $0xe,%eax
   1269e:	09 c2                	or     %eax,%edx
   126a0:	66 81 fa ff 7f       	cmp    $0x7fff,%dx
   126a5:	0f 84 c1 00 00 00    	je     1276c <so_handler+0x37c>
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
					}
					else
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = part3->SOend;
   126ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126ae:	0f b7 d2             	movzwl %dx,%edx
   126b1:	89 54 83 50          	mov    %edx,0x50(%ebx,%eax,4)
					}
					amTxedBuffer->segnum++;
   126b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   126b8:	83 c0 01             	add    $0x1,%eax
   126bb:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
					fsm_printf("[RLC][so_handler]it is the last segnum\n");
   126c1:	c7 04 24 3c 43 00 00 	movl   $0x433c,(%esp)
   126c8:	e8 fc ff ff ff       	call   126c9 <so_handler+0x2d9>
   126cd:	e9 5d fe ff ff       	jmp    1252f <so_handler+0x13f>
					fsm_mem_free(amTxedBuffer);
					amTxedBuffer = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, reposBf, &amIns->amRetxBuffer.list,list)
   126d2:	89 cb                	mov    %ecx,%ebx
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   126d4:	83 7b 04 01          	cmpl   $0x1,0x4(%ebx)
   126d8:	0f 84 9f 00 00 00    	je     1277d <so_handler+0x38d>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   126de:	8b 93 90 00 00 00    	mov    0x90(%ebx),%edx
   126e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   126e7:	85 d2                	test   %edx,%edx
   126e9:	8b 88 a4 01 00 00    	mov    0x1a4(%eax),%ecx
   126ef:	74 27                	je     12718 <so_handler+0x328>
   126f1:	8b 75 e8             	mov    -0x18(%ebp),%esi
   126f4:	31 c0                	xor    %eax,%eax
   126f6:	66 90                	xchg   %ax,%ax
									{
										if( amRetxBf->segStart[i] != -1 )
   126f8:	8b 54 83 10          	mov    0x10(%ebx,%eax,4),%edx
   126fc:	83 fa ff             	cmp    $0xffffffff,%edx
   126ff:	74 0c                	je     1270d <so_handler+0x31d>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12701:	2b 54 83 50          	sub    0x50(%ebx,%eax,4),%edx
   12705:	01 d1                	add    %edx,%ecx
   12707:	89 8e a4 01 00 00    	mov    %ecx,0x1a4(%esi)
						{
							if( amRetxBf->SN == nackSn)
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   1270d:	83 c0 01             	add    $0x1,%eax
   12710:	3b 83 90 00 00 00    	cmp    0x90(%ebx),%eax
   12716:	72 e0                	jb     126f8 <so_handler+0x308>
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12718:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1271b:	2b 4b 0c             	sub    0xc(%ebx),%ecx
   1271e:	89 88 a4 01 00 00    	mov    %ecx,0x1a4(%eax)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12724:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12727:	83 a8 a8 01 00 00 01 	subl   $0x1,0x1a8(%eax)
								fsm_pkt_destroy( amRetxBf->pkt );
   1272e:	8b 03                	mov    (%ebx),%eax
   12730:	e8 fc ff ff ff       	call   12731 <so_handler+0x341>
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12735:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
   1273b:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
								amRetxBf->pkt = NULL;
   12741:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12747:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   1274a:	89 10                	mov    %edx,(%eax)
								list_del(&amRetxBf->list);
								fsm_mem_free(amRetxBf);
   1274c:	89 d8                	mov    %ebx,%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   1274e:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12755:	01 10 00 
	entry->prev = LIST_POISON2;
   12758:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   1275f:	02 20 00 
   12762:	e8 fc ff ff ff       	call   12763 <so_handler+0x373>
								amRetxBf= NULL;
								break;
   12767:	e9 ed fc ff ff       	jmp    12459 <so_handler+0x69>
				if( i == amTxedBuffer->segnum )
				{
					amTxedBuffer->segStart[amTxedBuffer->segnum] = part3->SOstart;
					if(part3->SOend  == 0x7fff ) //
					{
						amTxedBuffer->segEnd[amTxedBuffer->segnum] = amTxedBuffer->pkt->len;
   1276c:	8b 03                	mov    (%ebx),%eax
   1276e:	8b 7d f0             	mov    -0x10(%ebp),%edi
   12771:	8b 40 50             	mov    0x50(%eax),%eax
   12774:	89 44 bb 50          	mov    %eax,0x50(%ebx,%edi,4)
   12778:	e9 38 ff ff ff       	jmp    126b5 <so_handler+0x2c5>
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   1277d:	8b 03                	mov    (%ebx),%eax
   1277f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   12782:	8b 40 50             	mov    0x50(%eax),%eax
   12785:	29 82 a4 01 00 00    	sub    %eax,0x1a4(%edx)
   1278b:	eb 97                	jmp    12724 <so_handler+0x334>
   1278d:	8d 76 00             	lea    0x0(%esi),%esi

00012790 <rlc_poll>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll(struct AM_Instance *amIns, FSM_PKT * pkt)
{
   12790:	55                   	push   %ebp
   12791:	89 e5                	mov    %esp,%ebp
   12793:	56                   	push   %esi
   12794:	53                   	push   %ebx
   12795:	83 ec 04             	sub    $0x4,%esp
   12798:	e8 fc ff ff ff       	call   12799 <rlc_poll+0x9>
   1279d:	89 d6                	mov    %edx,%esi
   1279f:	89 c3                	mov    %eax,%ebx
	//u16 amHdr = 0x0000; //AM PDU
	RLC_AMPDU_fixhead * amHdr;

	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
   127a1:	c7 04 24 a0 43 00 00 	movl   $0x43a0,(%esp)
   127a8:	e8 fc ff ff ff       	call   127a9 <rlc_poll+0x19>
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
   127ad:	8b 96 ac 00 00 00    	mov    0xac(%esi),%edx
	*(u16*)amHdr=htons(*(u16*)amHdr);
   127b3:	0f b7 02             	movzwl (%edx),%eax
   127b6:	66 c1 c0 08          	rol    $0x8,%ax
	if(amHdr->P!=1)
   127ba:	89 c1                	mov    %eax,%ecx
	{
		amHdr->P = 1;
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   127bc:	0f b7 f0             	movzwl %ax,%esi
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
	if(amHdr->P!=1)
   127bf:	66 c1 e9 08          	shr    $0x8,%cx
   127c3:	f6 c1 20             	test   $0x20,%cl
	FIN(rlc_poll());
	//SV_PTR_GET(rlc_sv);
	fsm_printf("[RLC][rlc_poll] entring rlc_poll()\n");
	//fsm_mem_cpy(&amHdr,pkt->data,2);//	
	amHdr = (RLC_AMPDU_fixhead *)pkt->data;
	*(u16*)amHdr=htons(*(u16*)amHdr);
   127c6:	66 89 02             	mov    %ax,(%edx)
	if(amHdr->P!=1)
   127c9:	75 0c                	jne    127d7 <rlc_poll+0x47>
	{
		amHdr->P = 1;
   127cb:	83 c9 20             	or     $0x20,%ecx
   127ce:	88 4a 01             	mov    %cl,0x1(%edx)
	}
	*(u16*)amHdr=ntohs(*(u16*)amHdr);
   127d1:	0f b7 02             	movzwl (%edx),%eax
   127d4:	0f b7 f0             	movzwl %ax,%esi
   127d7:	66 c1 e8 08          	shr    $0x8,%ax
   127db:	c1 e6 08             	shl    $0x8,%esi
   127de:	09 f0                	or     %esi,%eax
   127e0:	66 89 02             	mov    %ax,(%edx)
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
	amIns->byteWithoutPoll = 0;
	amIns->pollSn = amIns->vt_s - 1;
   127e3:	0f b7 83 64 12 00 00 	movzwl 0x1264(%ebx),%eax
	/*if( (amHdr&0x2000)>>13 == 0 )
	{
		amHdr|=1<<13; //polling1
	}
	fsm_mem_cpy(pkt->data,&amHdr,2);//*/
	amIns->pduWithoutPoll = 0;
   127ea:	66 c7 83 fc 22 00 00 	movw   $0x0,0x22fc(%ebx)
   127f1:	00 00 
	amIns->byteWithoutPoll = 0;
   127f3:	66 c7 83 fe 22 00 00 	movw   $0x0,0x22fe(%ebx)
   127fa:	00 00 
	amIns->pollSn = amIns->vt_s - 1;
   127fc:	83 e8 01             	sub    $0x1,%eax
   127ff:	66 89 83 00 23 00 00 	mov    %ax,0x2300(%ebx)
	if(amIns->pollRetxTimer)
   12806:	8b 43 08             	mov    0x8(%ebx),%eax
   12809:	85 c0                	test   %eax,%eax
   1280b:	74 0c                	je     12819 <rlc_poll+0x89>
	{
		fsm_schedule_cancel(amIns->pollRetxTimer);
   1280d:	e8 fc ff ff ff       	call   1280e <rlc_poll+0x7e>
		amIns->pollRetxTimer = 0;
   12812:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	}
	amIns->pollRetxTimer = fsm_schedule_self(amIns->pollRetxTimerValue,amIns->pollRetxTimerCode);
   12819:	8b 53 0c             	mov    0xc(%ebx),%edx
   1281c:	8b 43 10             	mov    0x10(%ebx),%eax
   1281f:	e8 fc ff ff ff       	call   12820 <rlc_poll+0x90>
   12824:	89 43 08             	mov    %eax,0x8(%ebx)
	fsm_printf("[RLC][rlc_poll] pollretxTimer start\n");
   12827:	c7 04 24 c4 43 00 00 	movl   $0x43c4,(%esp)
   1282e:	e8 fc ff ff ff       	call   1282f <rlc_poll+0x9f>
	FOUT;
}
   12833:	83 c4 04             	add    $0x4,%esp
   12836:	5b                   	pop    %ebx
   12837:	5e                   	pop    %esi
   12838:	5d                   	pop    %ebp
   12839:	c3                   	ret    
   1283a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

00012840 <rlc_poll_retx>:
**Modified by: ZhangYi
**Modified Date: 2014
************************************************************************/

void rlc_poll_retx(struct AM_Instance *amIns)
{
   12840:	55                   	push   %ebp
   12841:	89 e5                	mov    %esp,%ebp
   12843:	57                   	push   %edi
   12844:	56                   	push   %esi
   12845:	53                   	push   %ebx
   12846:	83 ec 24             	sub    $0x24,%esp
   12849:	e8 fc ff ff ff       	call   1284a <rlc_poll_retx+0xa>
   1284e:	89 c6                	mov    %eax,%esi
	struct AmBuffer *amRetxBf;  //PDU
	CRLC_StatusInd_IoctrlMsg *mioctrl;
	int i;

	FIN(rlc_poll_retx());
	fsm_printf("[RLC][rlc_poll_retx] entering rlc_poll_retx() function\n");
   12850:	c7 04 24 ec 43 00 00 	movl   $0x43ec,(%esp)
   12857:	e8 fc ff ff ff       	call   12858 <rlc_poll_retx+0x18>
	//
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
   1285c:	8d 8e f0 00 00 00    	lea    0xf0(%esi),%ecx
   12862:	3b 8e f0 00 00 00    	cmp    0xf0(%esi),%ecx
   12868:	89 4d f0             	mov    %ecx,-0x10(%ebp)
   1286b:	0f 84 a5 02 00 00    	je     12b16 <rlc_poll_retx+0x2d6>
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");
   12871:	c7 04 24 24 44 00 00 	movl   $0x4424,(%esp)
   12878:	e8 fc ff ff ff       	call   12879 <rlc_poll_retx+0x39>

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1287d:	8b 86 f0 00 00 00    	mov    0xf0(%esi),%eax
   12883:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12886:	8b 38                	mov    (%eax),%edi
   12888:	8d 98 64 ff ff ff    	lea    -0x9c(%eax),%ebx
   1288e:	0f 84 94 02 00 00    	je     12b28 <rlc_poll_retx+0x2e8>
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   12894:	8d 8e 9c 01 00 00    	lea    0x19c(%esi),%ecx
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   1289a:	81 ef 9c 00 00 00    	sub    $0x9c,%edi
					mioctrl->rbIdentity = amIns->rbId;
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   128a0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
   128a3:	eb 21                	jmp    128c6 <rlc_poll_retx+0x86>
   128a5:	8d 76 00             	lea    0x0(%esi),%esi
	if( !list_empty(&amIns->amTransmittedBuffer.list) )
	{
		fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx() anTransmittedBuffer is not empty\n");

		//for( pos = amIns->amTransmittedBuffer.list.prev; pos != &amIns->amTransmittedBuffer.list; pos = pos->prev )
		list_for_each_entry_safe(amTxedBuffer, pos, &amIns->amTransmittedBuffer.list,list)
   128a8:	8b 87 9c 00 00 00    	mov    0x9c(%edi),%eax
   128ae:	8d 97 9c 00 00 00    	lea    0x9c(%edi),%edx
   128b4:	2d 9c 00 00 00       	sub    $0x9c,%eax
   128b9:	39 55 f0             	cmp    %edx,-0x10(%ebp)
   128bc:	0f 84 66 02 00 00    	je     12b28 <rlc_poll_retx+0x2e8>
   128c2:	89 fb                	mov    %edi,%ebx
   128c4:	89 c7                	mov    %eax,%edi
		{
			//amTxedBuffer = list_entry(pos,struct AmBuffer,list);
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
   128c6:	0f bf 96 64 12 00 00 	movswl 0x1264(%esi),%edx
   128cd:	0f bf 83 94 00 00 00 	movswl 0x94(%ebx),%eax
   128d4:	83 ea 01             	sub    $0x1,%edx
   128d7:	39 d0                	cmp    %edx,%eax
   128d9:	75 cd                	jne    128a8 <rlc_poll_retx+0x68>
			{
				if( amTxedBuffer->retxCount == -1 )
   128db:	0f b7 93 96 00 00 00 	movzwl 0x96(%ebx),%edx
   128e2:	66 83 fa ff          	cmp    $0xffff,%dx
   128e6:	0f 84 1c 02 00 00    	je     12b08 <rlc_poll_retx+0x2c8>
				{
					amTxedBuffer->retxCount = 0;
				}
				else
				{
					amTxedBuffer->retxCount++;
   128ec:	83 c2 01             	add    $0x1,%edx
   128ef:	66 89 93 96 00 00 00 	mov    %dx,0x96(%ebx)
				}
				fsm_printf("[RLC][rlc_poll_retx] the pdu of rlc_poll_retx's SN is %d\n",amTxedBuffer->SN);
   128f6:	89 44 24 04          	mov    %eax,0x4(%esp)
   128fa:	c7 04 24 6c 44 00 00 	movl   $0x446c,(%esp)
   12901:	e8 fc ff ff ff       	call   12902 <rlc_poll_retx+0xc2>
				fsm_printf("[RLC][rlc_poll_retx] the retxCount is %d, the maxThreshold is %d\n",amTxedBuffer->retxCount,amIns->maxRetxThreshold);
   12906:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   1290d:	89 44 24 08          	mov    %eax,0x8(%esp)
   12911:	0f bf 83 96 00 00 00 	movswl 0x96(%ebx),%eax
   12918:	c7 04 24 a8 44 00 00 	movl   $0x44a8,(%esp)
   1291f:	89 44 24 04          	mov    %eax,0x4(%esp)
   12923:	e8 fc ff ff ff       	call   12924 <rlc_poll_retx+0xe4>
				//
				if( amTxedBuffer->retxCount == amIns->maxRetxThreshold )
   12928:	0f bf 93 96 00 00 00 	movswl 0x96(%ebx),%edx
   1292f:	0f b7 86 fa 22 00 00 	movzwl 0x22fa(%esi),%eax
   12936:	39 c2                	cmp    %eax,%edx
   12938:	0f 85 02 02 00 00    	jne    12b40 <rlc_poll_retx+0x300>
				{
					fsm_printf("[RLC][rlc_poll_retx] has reach the maxRetxThreshold\n");
   1293e:	c7 04 24 ec 44 00 00 	movl   $0x44ec,(%esp)
   12945:	e8 fc ff ff ff       	call   12946 <rlc_poll_retx+0x106>
					mioctrl = (CRLC_StatusInd_IoctrlMsg*)fsm_mem_alloc(sizeof(CRLC_StatusInd_IoctrlMsg));
   1294a:	b8 04 00 00 00       	mov    $0x4,%eax
   1294f:	e8 fc ff ff ff       	call   12950 <rlc_poll_retx+0x110>
					mioctrl->eventCode = 0;
   12954:	66 c7 00 00 00       	movw   $0x0,(%eax)
					mioctrl->rbIdentity = amIns->rbId;
   12959:	0f b6 56 02          	movzbl 0x2(%esi),%edx
   1295d:	88 50 02             	mov    %dl,0x2(%eax)
					//fsm_do_ioctrl(STRM_TO_RRC, CRLC_STATUS_IND, (void*)mioctrl, sizeof(CRLC_StatusInd_IoctrlMsg));
					fsm_mem_free(mioctrl);
   12960:	e8 fc ff ff ff       	call   12961 <rlc_poll_retx+0x121>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
   12965:	8b 96 9c 01 00 00    	mov    0x19c(%esi),%edx
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
   1296b:	39 55 e8             	cmp    %edx,-0x18(%ebp)
   1296e:	74 6b                	je     129db <rlc_poll_retx+0x19b>
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12970:	8d 82 64 ff ff ff    	lea    -0x9c(%edx),%eax
   12976:	8b 0a                	mov    (%edx),%ecx
   12978:	89 45 e4             	mov    %eax,-0x1c(%ebp)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   1297b:	0f b7 83 94 00 00 00 	movzwl 0x94(%ebx),%eax
   12982:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12986:	8d 81 64 ff ff ff    	lea    -0x9c(%ecx),%eax
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   1298c:	0f b7 4d ec          	movzwl -0x14(%ebp),%ecx
   12990:	66 39 4a f8          	cmp    %cx,-0x8(%edx)
   12994:	0f 84 cc 01 00 00    	je     12b66 <rlc_poll_retx+0x326>
   1299a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
   1299d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
   129a0:	89 7d e0             	mov    %edi,-0x20(%ebp)
   129a3:	0f b7 7d ec          	movzwl -0x14(%ebp),%edi
   129a7:	eb 16                	jmp    129bf <rlc_poll_retx+0x17f>
   129a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   129b0:	66 39 b8 94 00 00 00 	cmp    %di,0x94(%eax)
   129b7:	0f 84 93 00 00 00    	je     12a50 <rlc_poll_retx+0x210>
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   129bd:	89 c8                	mov    %ecx,%eax
   129bf:	8b 88 9c 00 00 00    	mov    0x9c(%eax),%ecx
   129c5:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   129cb:	81 e9 9c 00 00 00    	sub    $0x9c,%ecx
   129d1:	39 d3                	cmp    %edx,%ebx
   129d3:	75 db                	jne    129b0 <rlc_poll_retx+0x170>
   129d5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   129d8:	8b 7d e0             	mov    -0x20(%ebp),%edi
					//nposBf = NULL;
					}

					//PDU
					//pos = pos->next;
					amIns->amTransmittedBufferSize -= amTxedBuffer->pkt->len;
   129db:	8b 03                	mov    (%ebx),%eax
   129dd:	8b 40 50             	mov    0x50(%eax),%eax
   129e0:	29 86 f8 00 00 00    	sub    %eax,0xf8(%esi)
					amIns->amTransmittedBufferNum--;
   129e6:	83 ae fc 00 00 00 01 	subl   $0x1,0xfc(%esi)
					if(amTxedBuffer->pkt != NULL)
   129ed:	8b 03                	mov    (%ebx),%eax
   129ef:	85 c0                	test   %eax,%eax
   129f1:	74 0b                	je     129fe <rlc_poll_retx+0x1be>
					{
						fsm_pkt_destroy( amTxedBuffer->pkt );
   129f3:	e8 fc ff ff ff       	call   129f4 <rlc_poll_retx+0x1b4>
						amTxedBuffer->pkt = NULL;
   129f8:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   129fe:	8b 93 9c 00 00 00    	mov    0x9c(%ebx),%edx
					}
					list_del(&amTxedBuffer->list);
					if(amTxedBuffer != NULL)
   12a04:	85 db                	test   %ebx,%ebx
   12a06:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12a0c:	89 42 04             	mov    %eax,0x4(%edx)
	prev->next = next;
   12a0f:	89 10                	mov    %edx,(%eax)
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12a11:	c7 83 9c 00 00 00 00 	movl   $0x100100,0x9c(%ebx)
   12a18:	01 10 00 
	entry->prev = LIST_POISON2;
   12a1b:	c7 83 a0 00 00 00 00 	movl   $0x200200,0xa0(%ebx)
   12a22:	02 20 00 
   12a25:	74 07                	je     12a2e <rlc_poll_retx+0x1ee>
					{
						fsm_mem_free(amTxedBuffer);
   12a27:	89 d8                	mov    %ebx,%eax
   12a29:	e8 fc ff ff ff       	call   12a2a <rlc_poll_retx+0x1ea>
						amTxedBuffer = NULL;
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
   12a2e:	8b 86 a4 01 00 00    	mov    0x1a4(%esi),%eax
   12a34:	c7 04 24 24 45 00 00 	movl   $0x4524,(%esp)
   12a3b:	89 44 24 04          	mov    %eax,0x4(%esp)
   12a3f:	e8 fc ff ff ff       	call   12a40 <rlc_poll_retx+0x200>
   12a44:	e9 5f fe ff ff       	jmp    128a8 <rlc_poll_retx+0x68>
   12a49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
   12a50:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
   12a53:	89 c2                	mov    %eax,%edx
   12a55:	8b 7d e0             	mov    -0x20(%ebp),%edi
							{
								if( amRetxBf->pktstatus != FULL_SDU )
   12a58:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
   12a5c:	0f 84 ce 00 00 00    	je     12b30 <rlc_poll_retx+0x2f0>
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12a62:	8b 8a 90 00 00 00    	mov    0x90(%edx),%ecx
   12a68:	85 c9                	test   %ecx,%ecx
   12a6a:	8b 8e a4 01 00 00    	mov    0x1a4(%esi),%ecx
   12a70:	74 33                	je     12aa5 <rlc_poll_retx+0x265>
   12a72:	89 5d ec             	mov    %ebx,-0x14(%ebp)
   12a75:	31 c0                	xor    %eax,%eax
   12a77:	89 cb                	mov    %ecx,%ebx
   12a79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
									{
										if( amRetxBf->segStart[i] != -1 )
   12a80:	8b 4c 82 10          	mov    0x10(%edx,%eax,4),%ecx
   12a84:	83 f9 ff             	cmp    $0xffffffff,%ecx
   12a87:	74 0c                	je     12a95 <rlc_poll_retx+0x255>
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
   12a89:	2b 4c 82 50          	sub    0x50(%edx,%eax,4),%ecx
   12a8d:	01 cb                	add    %ecx,%ebx
   12a8f:	89 9e a4 01 00 00    	mov    %ebx,0x1a4(%esi)
						{
							if( amRetxBf->SN == amTxedBuffer->SN )
							{
								if( amRetxBf->pktstatus != FULL_SDU )
								{
									for( i = 0; i < amRetxBf->segnum; i++)
   12a95:	83 c0 01             	add    $0x1,%eax
   12a98:	3b 82 90 00 00 00    	cmp    0x90(%edx),%eax
   12a9e:	72 e0                	jb     12a80 <rlc_poll_retx+0x240>
   12aa0:	89 d9                	mov    %ebx,%ecx
   12aa2:	8b 5d ec             	mov    -0x14(%ebp),%ebx
										if( amRetxBf->segStart[i] != -1 )
										{
											amIns->amRetxBufferSize -= amRetxBf->segEnd[i] - amRetxBf->segStart[i];
										}
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
   12aa5:	89 c8                	mov    %ecx,%eax
   12aa7:	2b 42 0c             	sub    0xc(%edx),%eax
   12aaa:	89 86 a4 01 00 00    	mov    %eax,0x1a4(%esi)
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
								}
								amIns->amRetxBufferNum--;
   12ab0:	83 ae a8 01 00 00 01 	subl   $0x1,0x1a8(%esi)
	__list_del(entry->prev, entry->next);
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
   12ab7:	8b 82 a0 00 00 00    	mov    0xa0(%edx),%eax
   12abd:	8b 8a 9c 00 00 00    	mov    0x9c(%edx),%ecx
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
	next->prev = prev;
   12ac3:	89 41 04             	mov    %eax,0x4(%ecx)
	prev->next = next;
   12ac6:	89 08                	mov    %ecx,(%eax)
								list_del(&amRetxBf->list);
								if(amRetxBf->pkt != NULL)
   12ac8:	8b 02                	mov    (%edx),%eax
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
   12aca:	c7 82 9c 00 00 00 00 	movl   $0x100100,0x9c(%edx)
   12ad1:	01 10 00 
	entry->prev = LIST_POISON2;
   12ad4:	c7 82 a0 00 00 00 00 	movl   $0x200200,0xa0(%edx)
   12adb:	02 20 00 
   12ade:	85 c0                	test   %eax,%eax
   12ae0:	74 11                	je     12af3 <rlc_poll_retx+0x2b3>
								{
									fsm_pkt_destroy( amRetxBf->pkt );
   12ae2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   12ae5:	e8 fc ff ff ff       	call   12ae6 <rlc_poll_retx+0x2a6>
									amRetxBf->pkt = NULL;
   12aea:	8b 55 dc             	mov    -0x24(%ebp),%edx
   12aed:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
								}
								if(amRetxBf != NULL)
   12af3:	85 d2                	test   %edx,%edx
   12af5:	0f 84 e0 fe ff ff    	je     129db <rlc_poll_retx+0x19b>
								{
									fsm_mem_free(amRetxBf);
   12afb:	89 d0                	mov    %edx,%eax
   12afd:	e8 fc ff ff ff       	call   12afe <rlc_poll_retx+0x2be>
   12b02:	e9 d4 fe ff ff       	jmp    129db <rlc_poll_retx+0x19b>
   12b07:	90                   	nop
			//if( amTxedBuffer->SN >= amIns->vt_a && amTxedBuffer->SN < amIns->vt_s)
			if( amTxedBuffer->SN == amIns->vt_s - 1 )
			{
				if( amTxedBuffer->retxCount == -1 )
				{
					amTxedBuffer->retxCount = 0;
   12b08:	66 c7 83 96 00 00 00 	movw   $0x0,0x96(%ebx)
   12b0f:	00 00 
   12b11:	e9 e0 fd ff ff       	jmp    128f6 <rlc_poll_retx+0xb6>
			}
		}
	}
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
   12b16:	c7 04 24 a0 45 00 00 	movl   $0x45a0,(%esp)
   12b1d:	e8 fc ff ff ff       	call   12b1e <rlc_poll_retx+0x2de>
   12b22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	FOUT;
}
   12b28:	83 c4 24             	add    $0x24,%esp
   12b2b:	5b                   	pop    %ebx
   12b2c:	5e                   	pop    %esi
   12b2d:	5f                   	pop    %edi
   12b2e:	5d                   	pop    %ebp
   12b2f:	c3                   	ret    
									}
									amIns->amRetxBufferSize -= amRetxBf->headLen;
								}
								else
								{
									amIns->amRetxBufferSize -= amRetxBf->pkt->len;
   12b30:	8b 02                	mov    (%edx),%eax
   12b32:	8b 40 50             	mov    0x50(%eax),%eax
   12b35:	29 86 a4 01 00 00    	sub    %eax,0x1a4(%esi)
   12b3b:	e9 70 ff ff ff       	jmp    12ab0 <rlc_poll_retx+0x270>
					}
					fsm_printf("[RLC][rlc_poll_retx] retx amretxbuffersize is %d\n",amIns->amRetxBufferSize);
				}
				else
				{
					fsm_printf("[RLC][rlc_poll_retx] rlc_poll_retx pdu has not reach maxRetxThreshold\n");
   12b40:	c7 04 24 58 45 00 00 	movl   $0x4558,(%esp)
   12b47:	e8 fc ff ff ff       	call   12b48 <rlc_poll_retx+0x308>
					rlc_poll(amIns,amTxedBuffer->pkt);	//
   12b4c:	8b 13                	mov    (%ebx),%edx
   12b4e:	89 f0                	mov    %esi,%eax
   12b50:	e8 fc ff ff ff       	call   12b51 <rlc_poll_retx+0x311>
					rlc_retx(amIns,amTxedBuffer);
   12b55:	89 da                	mov    %ebx,%edx
   12b57:	89 f0                	mov    %esi,%eax
   12b59:	e8 fc ff ff ff       	call   12b5a <rlc_poll_retx+0x31a>
	else
	{
		fsm_printf("[RLC][rlc_poll_retx] amTransmittedBuffer is empty\n");
	}
	FOUT;
}
   12b5e:	83 c4 24             	add    $0x24,%esp
   12b61:	5b                   	pop    %ebx
   12b62:	5e                   	pop    %esi
   12b63:	5f                   	pop    %edi
   12b64:	5d                   	pop    %ebp
   12b65:	c3                   	ret    
					fsm_mem_free(mioctrl);
					mioctrl = NULL;
					//PDU
					if( !list_empty(&amIns->amRetxBuffer.list) )
					{
						list_for_each_entry_safe(amRetxBf, nposBf, &amIns->amRetxBuffer.list,list)
   12b66:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12b69:	e9 ea fe ff ff       	jmp    12a58 <rlc_poll_retx+0x218>
